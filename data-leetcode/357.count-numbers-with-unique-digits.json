[
    {
        "title": "Insert Interval",
        "question_content": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\n&nbsp;\nExample 1:\n\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\nExample 2:\n\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\n&nbsp;\nConstraints:\n\n\t0 <= intervals.length <= 104\n\tintervals[i].length == 2\n\t0 <= starti <= endi <= 105\n\tintervals is sorted by starti in ascending order.\n\tnewInterval.length == 2\n\t0 <= start <= end <= 105",
        "solutions": [
            {
                "id": 21602,
                "title": "short-and-straight-forward-java-solution",
                "content": "Hi guys!\\n\\nHere's a pretty straight-forward and concise solution below.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new LinkedList<>();\\n        int i = 0;\\n        // add all the intervals ending before newInterval starts\\n        while (i < intervals.size() && intervals.get(i).end < newInterval.start)\\n            result.add(intervals.get(i++));\\n        // merge all overlapping intervals to one considering newInterval\\n        while (i < intervals.size() && intervals.get(i).start <= newInterval.end) {\\n            newInterval = new Interval( // we could mutate newInterval here also\\n                    Math.min(newInterval.start, intervals.get(i).start),\\n                    Math.max(newInterval.end, intervals.get(i).end));\\n            i++;\\n        }\\n        result.add(newInterval); // add the union of intervals we got\\n        // add all the rest\\n        while (i < intervals.size()) result.add(intervals.get(i++)); \\n        return result;\\n    }\\n\\nHope it helps.",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nHere's a pretty straight-forward and concise solution below.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new LinkedList<>();\\n        int i = 0;\\n        // add all the intervals ending before newInterval starts\\n        while (i < intervals.size() && intervals.get(i).end < newInterval.start)\\n            result.add(intervals.get(i++));\\n        // merge all overlapping intervals to one considering newInterval\\n        while (i < intervals.size() && intervals.get(i).start <= newInterval.end) {\\n            newInterval = new Interval( // we could mutate newInterval here also\\n                    Math.min(newInterval.start, intervals.get(i).start),\\n                    Math.max(newInterval.end, intervals.get(i).end));\\n            i++;\\n        }\\n        result.add(newInterval); // add the union of intervals we got\\n        // add all the rest\\n        while (i < intervals.size()) result.add(intervals.get(i++)); \\n        return result;\\n    }\\n\\nHope it helps.",
                "codeTag": "Unknown"
            },
            {
                "id": 21622,
                "title": "7-lines-3-easy-solutions",
                "content": "**Solution 1:** (7 lines, 88 ms)\\n\\nCollect the intervals strictly left or right of the new interval, then merge the new one with the middle ones (if any) before inserting it between left and right ones.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left = [i for i in intervals if i.end < s]\\n        right = [i for i in intervals if i.start > e]\\n        if left + right != intervals:\\n            s = min(s, intervals[len(left)].start)\\n            e = max(e, intervals[~len(right)].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 2:** (8 lines, 84 ms)\\n\\nSame algorithm as solution 1, but different implementation with only one pass and explicitly collecting the to-be-merged intervals.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        parts = merge, left, right = [], [], []\\n        for i in intervals:\\n            parts[(i.end < s) - (i.start > e)].append(i)\\n        if merge:\\n            s = min(s, merge[0].start)\\n            e = max(e, merge[-1].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 3:** (11 lines, 80 ms)\\n\\nSame again, but collect and merge while going over the intervals once.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left, right = [], []\\n        for i in intervals:\\n            if i.end < s:\\n                left += i,\\n            elif i.start > e:\\n                right += i,\\n            else:\\n                s = min(s, i.start)\\n                e = max(e, i.end)\\n        return left + [Interval(s, e)] + right",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1:** (7 lines, 88 ms)\\n\\nCollect the intervals strictly left or right of the new interval, then merge the new one with the middle ones (if any) before inserting it between left and right ones.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left = [i for i in intervals if i.end < s]\\n        right = [i for i in intervals if i.start > e]\\n        if left + right != intervals:\\n            s = min(s, intervals[len(left)].start)\\n            e = max(e, intervals[~len(right)].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 2:** (8 lines, 84 ms)\\n\\nSame algorithm as solution 1, but different implementation with only one pass and explicitly collecting the to-be-merged intervals.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        parts = merge, left, right = [], [], []\\n        for i in intervals:\\n            parts[(i.end < s) - (i.start > e)].append(i)\\n        if merge:\\n            s = min(s, merge[0].start)\\n            e = max(e, merge[-1].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 3:** (11 lines, 80 ms)\\n\\nSame again, but collect and merge while going over the intervals once.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left, right = [], []\\n        for i in intervals:\\n            if i.end < s:\\n                left += i,\\n            elif i.start > e:\\n                right += i,\\n            else:\\n                s = min(s, i.start)\\n                e = max(e, i.end)\\n        return left + [Interval(s, e)] + right",
                "codeTag": "Python3"
            },
            {
                "id": 1327206,
                "title": "99-16-faster-proper-explaination-c-solution-o-n",
                "content": "Here 3 cases will arive:\\n1) ***Non Overlapping intervals before given newInterval*** -> push into the ans vector \\n2) **Overlapping of intervals and newInterval** update new interval \\n   starting point of newInterval will be min of the interval starting point \\n   or starting point of newInterval\\n   Ending point will be the max of interval ending point or newInterval          end point.\\n3) **Non overlapping intervals after the newintervals have been merged** ->    push ito ans vector   \\n   \\n**Time complexity - O(N)** \\n**space complexity - O(1)**\\n\\nAlso, please do not use sorting algo here because we have already provided with sorted list.\\n\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote and comment if have doubt**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21600,
                "title": "short-java-code",
                "content": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<Interval>();\\n        for (Interval i : intervals) {\\n            if (newInterval == null || i.end < newInterval.start)\\n                result.add(i);\\n            else if (i.start > newInterval.end) {\\n                result.add(newInterval);\\n                result.add(i);\\n                newInterval = null;\\n            } else {\\n                newInterval.start = Math.min(newInterval.start, i.start);\\n                newInterval.end = Math.max(newInterval.end, i.end);\\n            }\\n        }\\n        if (newInterval != null)\\n            result.add(newInterval);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<Interval>();\\n        for (Interval i : intervals) {\\n            if (newInterval == null || i.end < newInterval.start)\\n                result.add(i);\\n            else if (i.start > newInterval.end) {\\n                result.add(newInterval);\\n                result.add(i);\\n                newInterval = null;\\n            } else {\\n                newInterval.start = Math.min(newInterval.start, i.start);\\n                newInterval.end = Math.max(newInterval.end, i.end);\\n            }\\n        }\\n        if (newInterval != null)\\n            result.add(newInterval);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21809,
                "title": "python-o-n-and-o-nlgn-solutions",
                "content": "        \\n    \\n    # O(nlgn) time, the same as Merge Intervals \\n    # https://leetcode.com/problems/merge-intervals/\\n    def insert1(self, intervals, newInterval):\\n        intervals.append(newInterval)\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x.start):\\n            if res and res[-1].end >= i.start:\\n                res[-1].end = max(res[-1].end, i.end)\\n            else:\\n                res.append(i)\\n        return res\\n        \\n    # O(n) time, not in-place, make use of the \\n    # property that the intervals were initially sorted \\n    # according to their start times\\n    def insert(self, intervals, newInterval):\\n        res, n = [], newInterval\\n        for index, i in enumerate(intervals):\\n            if i.end < n.start:\\n                res.append(i)\\n            elif n.end < i.start:\\n                res.append(n)\\n                return res+intervals[index:]  # can return earlier\\n            else:  # overlap case\\n                n.start = min(n.start, i.start)\\n                n.end = max(n.end, i.end)\\n        res.append(n)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    \\n    # O(nlgn) time, the same as Merge Intervals \\n    # https://leetcode.com/problems/merge-intervals/\\n    def insert1(self, intervals, newInterval):\\n        intervals.append(newInterval)\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x.start):\\n            if res and res[-1].end >= i.start:\\n                res[-1].end = max(res[-1].end, i.end)\\n            else:\\n                res.append(i)\\n        return res\\n        \\n    # O(n) time, not in-place, make use of the \\n    # property that the intervals were initially sorted \\n    # according to their start times\\n    def insert(self, intervals, newInterval):\\n        res, n = [], newInterval\\n        for index, i in enumerate(intervals):\\n            if i.end < n.start:\\n                res.append(i)\\n            elif n.end < i.start:\\n                res.append(n)\\n                return res+intervals[index:]  # can return earlier\\n            else:  # overlap case\\n                n.start = min(n.start, i.start)\\n                n.end = max(n.end, i.end)\\n        res.append(n)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 959756,
                "title": "java-1ms-easy-line-by-line-explanation",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Iterate through all slots\\n        for(int[] slot : intervals)\\n        {\\n            \\n            // if newInterval before slot insert newInterval & update slot as new interval\\n            if(newInterval[1] < slot[0])\\n            {\\n                result.add(newInterval);\\n                newInterval = slot;\\n            } \\n            \\n            // if slot is lesser than new Interval insert slot\\n            else if(slot[1] < newInterval[0])\\n            {\\n                result.add(slot);\\n            } \\n            \\n            // if above conditions fail its an overlap since possibility of new interval existing in left & right of slot is checked\\n            // update lowest of start & highest of end & not insert\\n            else {\\n                newInterval[0] = Math.min(newInterval[0],slot[0]);\\n                newInterval[1] = Math.max(newInterval[1],slot[1]);\\n            }\\n        }\\n        \\n        // insert the last newInterval\\n        result.add(newInterval);\\n        \\n        // convert to int[][] array\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Iterate through all slots\\n        for(int[] slot : intervals)\\n        {\\n            \\n            // if newInterval before slot insert newInterval & update slot as new interval\\n            if(newInterval[1] < slot[0])\\n            {\\n                result.add(newInterval);\\n                newInterval = slot;\\n            } \\n            \\n            // if slot is lesser than new Interval insert slot\\n            else if(slot[1] < newInterval[0])\\n            {\\n                result.add(slot);\\n            } \\n            \\n            // if above conditions fail its an overlap since possibility of new interval existing in left & right of slot is checked\\n            // update lowest of start & highest of end & not insert\\n            else {\\n                newInterval[0] = Math.min(newInterval[0],slot[0]);\\n                newInterval[1] = Math.max(newInterval[1],slot[1]);\\n            }\\n        }\\n        \\n        // insert the last newInterval\\n        result.add(newInterval);\\n        \\n        // convert to int[][] array\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21599,
                "title": "elegant-c-stl-solution-using-equal-range-to-find-overlapped-intervals",
                "content": "    class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            auto compare = [] (const Interval &intv1, const Interval &intv2)\\n                              { return intv1.end < intv2.start; };\\n            auto range = equal_range(intervals.begin(), intervals.end(), newInterval, compare);\\n            auto itr1 = range.first, itr2 = range.second;\\n            if (itr1 == itr2) {\\n                intervals.insert(itr1, newInterval);\\n            } else {\\n                itr2--;\\n                itr2->start = min(newInterval.start, itr1->start);\\n                itr2->end = max(newInterval.end, itr2->end);\\n                intervals.erase(itr1, itr2);\\n            }\\n            return intervals;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            auto compare = [] (const Interval &intv1, const Interval &intv2)\\n                              { return intv1.end < intv2.start; }",
                "codeTag": "Java"
            },
            {
                "id": 477856,
                "title": "beat-99-consice-java-solution",
                "content": "```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n        \\n        for (int i = 0; i < intervals.length; i ++) {\\n\\t\\t\\t/*1. No overlap and toAdd appears before current interval, add toAdd to result.*/\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n            /*2. Has overlap, update the toAdd to the merged interval.*/\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n\\t\\t\\t/*3. No overlap and toAdd appears after current interval, add current interval to result.*/\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n        \\n        for (int i = 0; i < intervals.length; i ++) {\\n\\t\\t\\t/*1. No overlap and toAdd appears before current interval, add toAdd to result.*/\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n            /*2. Has overlap, update the toAdd to the merged interval.*/\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n\\t\\t\\t/*3. No overlap and toAdd appears after current interval, add current interval to result.*/\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844494,
                "title": "python-o-n-solution-explained",
                "content": "I am not sure, why this problem is marked as hard, because we do not use any smart ideas to solve it: just do what is asked: traverse our intervals and merge them. Let us consider the case: `intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]` and go through our code:\\n\\n1. Interval `[1,2]` is before `[4,8]`, that is `y < I[0]`, so we just add it to our `res`.\\n2. Interval `[3,5]` is not before `[4,8]` but not after also, so it is the third case and we need to update `I`: `I = [3,8]` now.\\n3. Interval `[6,7]`: the same logic, update `I = [3,8]` now (it did not change though)\\n4. Interval `[8,10]`: still condition number `3`, so `I = [3,10]` now.\\n5. Interval `[12,16]`: it is after our `I`, so this is condition number `2` and we `break` from our loop: `i = 3` now.\\n6. Outside loop we combine `res = [1,2]`, `I = [3,10]` and `intervals[4:] = [12,16]`.\\n\\nWhy we use `i -= 1` inside our loop, before `break`? It can happen, that we did not visit this part and it means, that our suffix `intervals[i+1:]` should be empty.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(n)` as well and additional space complexity (if we do not count our output) is `O(1)`.\\n\\n**Note**: that intstead of traversing our intervals with linear search, we can use binary search, however it will not reduce the overall complexity of algorithm, our result will have in average `O(n)` elements.\\n\\n```\\nclass Solution:\\n    def insert(self, intervals, I):\\n        res, i = [], -1\\n        for i, (x, y) in enumerate(intervals):\\n            if y < I[0]:\\n                res.append([x, y])\\n            elif I[1] < x:\\n                i -= 1\\n                break\\n            else:\\n                I[0] = min(I[0], x)\\n                I[1] = max(I[1], y)\\n                \\n        return res + [I] + intervals[i+1:]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, I):\\n        res, i = [], -1\\n        for i, (x, y) in enumerate(intervals):\\n            if y < I[0]:\\n                res.append([x, y])\\n            elif I[1] < x:\\n                i -= 1\\n                break\\n            else:\\n                I[0] = min(I[0], x)\\n                I[1] = max(I[1], y)\\n                \\n        return res + [I] + intervals[i+1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844523,
                "title": "c-super-clean-clear-short-simple-solution-o-n-time-o-1-space",
                "content": "the main idea is that when iterating over the intervals there are three cases: \\n1. the new interval is in the range of the other interval\\n2. the new interval\\'s range is before the other\\n3. the new interval is after the range of other interval\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        vector<vector<int>> result;\\n        \\n        for (size_t i = 0; i < intervals.size(); i++)\\n        {\\n\\t\\t\\t//  the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if (intervals[i][1] < newInterval[0])\\n            {\\n                result.push_back(intervals[i]);\\n            }\\n\\t\\t\\t// the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            else if (intervals[i][0] > newInterval[1])\\n            {\\n                result.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\t\\t\\t// the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1])\\n            {\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n\\n            }\\n        }\\n        \\n        result.push_back(newInterval); \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        vector<vector<int>> result;\\n        \\n        for (size_t i = 0; i < intervals.size(); i++)\\n        {\\n\\t\\t\\t//  the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if (intervals[i][1] < newInterval[0])\\n            {\\n                result.push_back(intervals[i]);\\n            }\\n\\t\\t\\t// the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            else if (intervals[i][0] > newInterval[1])\\n            {\\n                result.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\t\\t\\t// the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1])\\n            {\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n\\n            }\\n        }\\n        \\n        result.push_back(newInterval); \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844549,
                "title": "python-super-short-simple-clean-solution-99-faster",
                "content": "the main idea is that when iterating over the intervals there are three cases:\\n\\n1. the new interval is in the range of the other interval\\n2. the new interval\\'s range is before the other\\n3. the new interval is after the range of other interval\\n\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        \\n        for interval in intervals:\\n\\t\\t\\t# the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if interval[1] < newInterval[0]:\\n                result.append(interval)\\n            # the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            elif interval[0] > newInterval[1]:\\n                result.append(newInterval)\\n                newInterval = interval\\n            # the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            elif interval[1] >= newInterval[0] or interval[0] <= newInterval[1]:\\n                newInterval[0] = min(interval[0], newInterval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n\\n        \\n        result.append(newInterval); \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        \\n        for interval in intervals:\\n\\t\\t\\t# the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if interval[1] < newInterval[0]:\\n                result.append(interval)\\n            # the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            elif interval[0] > newInterval[1]:\\n                result.append(newInterval)\\n                newInterval = interval\\n            # the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            elif interval[1] >= newInterval[0] or interval[0] <= newInterval[1]:\\n                newInterval[0] = min(interval[0], newInterval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n\\n        \\n        result.append(newInterval); \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556269,
                "title": "simple-concise-js-solution-w-comments",
                "content": "use ES6 destructuring assignment to make code much more concise and readable.\\n\\n```\\n// O(n), O(n)\\nvar insert = function (intervals, newInterval) {\\n  let [start, end] = newInterval;\\n  let left = [];\\n  let right = [];\\n  \\n  for (const interval of intervals) {\\n    const [first, last] = interval;\\n\\t\\n\\t// current interval is smaller than newInterval\\n    if (last < start) left.push(interval);\\n\\t\\n\\t// current interval is larger than newInterval\\n    else if (first > end) right.push(interval);\\n\\t\\n\\t// there is a overlap\\n    else {\\n      start = Math.min(start, first);\\n      end = Math.max(end, last);\\n    }\\n  }\\n  \\n  return [...left, [start, end], ...right]; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(n), O(n)\\nvar insert = function (intervals, newInterval) {\\n  let [start, end] = newInterval;\\n  let left = [];\\n  let right = [];\\n  \\n  for (const interval of intervals) {\\n    const [first, last] = interval;\\n\\t\\n\\t// current interval is smaller than newInterval\\n    if (last < start) left.push(interval);\\n\\t\\n\\t// current interval is larger than newInterval\\n    else if (first > end) right.push(interval);\\n\\t\\n\\t// there is a overlap\\n    else {\\n      start = Math.min(start, first);\\n      end = Math.max(end, last);\\n    }\\n  }\\n  \\n  return [...left, [start, end], ...right]; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844394,
                "title": "python-js-go-c-o-n-by-boundary-checking-w-comment",
                "content": "Python O( n ) by boundary checking\\n\\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        \\n        # Constant to help us access start point and end point of interval\\n        START, END = 0, 1\\n        \\n        s, e = newInterval[START], newInterval[END]\\n        \\n        left, right = [], []\\n        \\n        for cur_interval in intervals:\\n            \\n            if cur_interval[END] < s:\\n                # current interval is on the left-hand side of newInterval\\n                left += [ cur_interval ]\\n                \\n            elif cur_interval[START] > e:\\n                # current interval is on the right-hand side of newInterval\\n                right += [ cur_interval ]\\n                \\n            else:\\n                # current interval has overlap with newInterval\\n                # merge and update boundary\\n                s = min(s, cur_interval[START])\\n                e = max(e, cur_interval[END])\\n                \\n        return left + [ [s, e] ] + right    \\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar insert = function(intervals, newInterval) {\\n    \\n    const [START, END] = [0, 1];\\n    \\n    // start point as well as end point of new interval\\n    let [s, e] = [ newInterval[START], newInterval[END] ];\\n    \\n    // left: \\u3000record of intervals on left hand side\\n    // right:\\u3000record of intervals on right hand side\\n    let [left, right] = [ [], [] ];\\n    \\n    for( let curInterval of intervals){\\n        \\n        if( curInterval[END] < s ){\\n            \\n            // current interval is on the left hand side of newInterval\\n            left.push( curInterval);\\n            \\n        }else if( curInterval[START] > e ){\\n            \\n            // current interval is on the right hand side of newInterval\\n            right.push( curInterval );\\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = Math.min( s, curInterval[START] );\\n            e = Math.max( e, curInterval[END] );\\n            \\n        }\\n        \\n    }\\n    \\n    let result = left.concat( [ [s, e] ]).concat(right);\\n    return result;\\n    \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n\\n```\\n// native Go doesn\\'t have built-in interger min/max library function\\n// we have to make it manually\\n\\nfunc max(x, y int) int{\\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\nfunc min(x, y int) int{\\n    if x <= y{\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\n// ---------------------------------\\n\\n\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    // Constant to help us access start point and end point of interval\\n    const START, END = 0, 1\\n    \\n    s := newInterval[START]\\n    e := newInterval[END]\\n    \\n    left := make( [][]int, 0)\\n    right := make( [][]int, 0)\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if curInterval[END] < s{\\n            \\n            // current interval is on the left hand side of newInterval\\n            left = append(left, curInterval)\\n            \\n        }else if curInterval[START] > e{\\n            \\n            // current interval is on the right hand side of newInterval\\n            right = append(right, curInterval)\\n            \\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = min( s, curInterval[START] )\\n            e = max( e, curInterval[END] )\\n            \\n        }\\n    }\\n    \\n    result := make( [][]int, 0)\\n    result = append(result, left...)\\n    result = append(result, []int{s, e} )\\n    result = append(result, right...)\\n    \\n    return result\\n    \\n}\\n```\\n\\n---\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        // Constant to help us access start point and end point of interval\\n        const int START=0, END=1;\\n        \\n        int s=newInterval[START], e=newInterval[END];\\n        \\n        vector< vector<int> > left, right;\\n        \\n        for( auto& curInterval : intervals ) {\\n            \\n            if (curInterval[END] < s){\\n                \\n                // current interval is on the left hand side of newInterval\\n                left.push_back( curInterval );\\n                \\n            }else if( curInterval[START] > e ){\\n                \\n                // current interval is on the right hand side of newInterval\\n                right.push_back( curInterval );\\n            \\n            }else{\\n                // current interval has overlap with newInterval\\n                // merge and update boundary\\n                s = min(s, curInterval[START] );\\n                e = max(e, curInterval[END] );\\n            }\\n        }\\n        \\n        result.insert( result.end(), left.begin(), left.end() );\\n        result.push_back( {s, e} );\\n        result.insert( result.end(), right.begin(), right.end() );\\n        \\n        return result;\\n        \\n        \\n    }\\nprivate:\\n    vector< vector<int> > result;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        \\n        # Constant to help us access start point and end point of interval\\n        START, END = 0, 1\\n        \\n        s, e = newInterval[START], newInterval[END]\\n        \\n        left, right = [], []\\n        \\n        for cur_interval in intervals:\\n            \\n            if cur_interval[END] < s:\\n                # current interval is on the left-hand side of newInterval\\n                left += [ cur_interval ]\\n                \\n            elif cur_interval[START] > e:\\n                # current interval is on the right-hand side of newInterval\\n                right += [ cur_interval ]\\n                \\n            else:\\n                # current interval has overlap with newInterval\\n                # merge and update boundary\\n                s = min(s, cur_interval[START])\\n                e = max(e, cur_interval[END])\\n                \\n        return left + [ [s, e] ] + right    \\n```\n```\\nvar insert = function(intervals, newInterval) {\\n    \\n    const [START, END] = [0, 1];\\n    \\n    // start point as well as end point of new interval\\n    let [s, e] = [ newInterval[START], newInterval[END] ];\\n    \\n    // left: \\u3000record of intervals on left hand side\\n    // right:\\u3000record of intervals on right hand side\\n    let [left, right] = [ [], [] ];\\n    \\n    for( let curInterval of intervals){\\n        \\n        if( curInterval[END] < s ){\\n            \\n            // current interval is on the left hand side of newInterval\\n            left.push( curInterval);\\n            \\n        }else if( curInterval[START] > e ){\\n            \\n            // current interval is on the right hand side of newInterval\\n            right.push( curInterval );\\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = Math.min( s, curInterval[START] );\\n            e = Math.max( e, curInterval[END] );\\n            \\n        }\\n        \\n    }\\n    \\n    let result = left.concat( [ [s, e] ]).concat(right);\\n    return result;\\n    \\n};\\n```\n```\\n// native Go doesn\\'t have built-in interger min/max library function\\n// we have to make it manually\\n\\nfunc max(x, y int) int{\\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\nfunc min(x, y int) int{\\n    if x <= y{\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\n// ---------------------------------\\n\\n\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    // Constant to help us access start point and end point of interval\\n    const START, END = 0, 1\\n    \\n    s := newInterval[START]\\n    e := newInterval[END]\\n    \\n    left := make( [][]int, 0)\\n    right := make( [][]int, 0)\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if curInterval[END] < s{\\n            \\n            // current interval is on the left hand side of newInterval\\n            left = append(left, curInterval)\\n            \\n        }else if curInterval[START] > e{\\n            \\n            // current interval is on the right hand side of newInterval\\n            right = append(right, curInterval)\\n            \\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = min( s, curInterval[START] )\\n            e = max( e, curInterval[END] )\\n            \\n        }\\n    }\\n    \\n    result := make( [][]int, 0)\\n    result = append(result, left...)\\n    result = append(result, []int{s, e} )\\n    result = append(result, right...)\\n    \\n    return result\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        // Constant to help us access start point and end point of interval\\n        const int START=0, END=1;\\n        \\n        int s=newInterval[START], e=newInterval[END];\\n        \\n        vector< vector<int> > left, right;\\n        \\n        for( auto& curInterval : intervals ) {\\n            \\n            if (curInterval[END] < s){\\n                \\n                // current interval is on the left hand side of newInterval\\n                left.push_back( curInterval );\\n                \\n            }else if( curInterval[START] > e ){\\n                \\n                // current interval is on the right hand side of newInterval\\n                right.push_back( curInterval );\\n            \\n            }else{\\n                // current interval has overlap with newInterval\\n                // merge and update boundary\\n                s = min(s, curInterval[START] );\\n                e = max(e, curInterval[END] );\\n            }\\n        }\\n        \\n        result.insert( result.end(), left.begin(), left.end() );\\n        result.push_back( {s, e} );\\n        result.insert( result.end(), right.begin(), right.end() );\\n        \\n        return result;\\n        \\n        \\n    }\\nprivate:\\n    vector< vector<int> > result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955134,
                "title": "java-solution-with-explanation-and-comments",
                "content": "# Approach and Explanation\\n<!-- Describe your approach to solving the problem. -->\\n1. This code defines a class Solution that contains a method insert which takes in two parameters: an array of intervals represented by a 2D array, and a new interval represented by a 1D array. The method returns a new 2D array containing the merged intervals.\\n\\n2. The approach of this code is to add the intervals that come before the new interval to the answer arraylist, then check if the new interval should be merged with the last interval in the answer arraylist, and finally, add the remaining intervals from the input array to the answer arraylist.\\n\\n3. The code first initializes an empty ArrayList called ans. The variable idx is initialized to 0, and the while loop iterates through the input intervals array. The loop compares the starting value of the current interval with the starting value of the new interval, and if the current interval\\'s starting value is less than the new interval\\'s starting value, it is added to the ans arraylist. If the starting value of the current interval is greater than or equal to the new interval\\'s starting value, the loop breaks. This ensures that the intervals in the ans arraylist will be in the same order as they were in the input array, but with the new interval inserted in the correct position.\\n\\n4. Next, the code checks if the ans arraylist is empty or if the new interval\\'s starting value is greater than the last interval\\'s ending value in the ans arraylist. If either of these conditions is true, the new interval is added to the ans arraylist. Otherwise, the last interval in the ans arraylist is merged with the new interval by updating the last interval\\'s ending value to be the maximum of the last interval\\'s ending value and the new interval\\'s ending value.\\n\\n5. Finally, the while loop iterates through the remaining intervals in the input array. The loop compares the ending value of the last interval in the ans arraylist with the starting value of the current interval. If the last interval\\'s ending value is greater than or equal to the current interval\\'s starting value, it means the two intervals overlap and should be merged. The last interval\\'s ending value is updated to be the maximum of the last interval\\'s ending value and the current interval\\'s ending value. If the last interval\\'s ending value is less than the current interval\\'s starting value, it means the two intervals do not overlap and the current interval is added to the ans arraylist.\\n\\n6. After the while loop, the ans arraylist is converted to a 2D array and returned as the final output.\\n```\\n//TC = O(n)\\n//Sc = O(n)\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {   \\n       // Initialize an ArrayList to hold the merged intervals\\n        ArrayList<int[]> ans = new ArrayList<>();\\n        // Initialize a variable to track our position in the input intervals array\\n        int idx = 0;\\n        // Loop through the input intervals\\n        while(idx < intervals.length){\\n            // If the current interval starts before the new interval, add it to the answer list\\n            if(intervals[idx][0] < newInterval[0]){\\n                ans.add(intervals[idx]);\\n                idx++;\\n            // If the current interval starts after or at the same time as the new interval, exit the loop\\n            }else{\\n                break;\\n            }\\n        }\\n        // If the answer list is empty or the last interval in the answer list ends before the new interval starts\\n        // add the new interval to the answer list\\n        if(ans.size() == 0 || (newInterval[0] > ans.get(ans.size()-1)[1])){\\n            ans.add(newInterval);\\n        // If the last interval in the answer list overlaps with the new interval, merge them by updating the end time of the last interval\\n        }else{\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            lastInterval[1] = Math.max(lastInterval[1],newInterval[1]);\\n        }\\n        // Loop through the remaining intervals in the input array\\n        while(idx < intervals.length){\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            // If the last interval in the answer list overlaps with the current interval, merge them by updating the end time of the last interval\\n            if(lastInterval[1] >= intervals[idx][0]){\\n                lastInterval[1] = Math.max(lastInterval[1], intervals[idx][1]);\\n            }else{\\n                // If the last interval does not overlap with the current interval, add it to the answer list\\n                ans.add(intervals[idx]);\\n            }\\n            idx++;\\n        }\\n        // Convert the ArrayList to a 2D int array and return it\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//TC = O(n)\\n//Sc = O(n)\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {   \\n       // Initialize an ArrayList to hold the merged intervals\\n        ArrayList<int[]> ans = new ArrayList<>();\\n        // Initialize a variable to track our position in the input intervals array\\n        int idx = 0;\\n        // Loop through the input intervals\\n        while(idx < intervals.length){\\n            // If the current interval starts before the new interval, add it to the answer list\\n            if(intervals[idx][0] < newInterval[0]){\\n                ans.add(intervals[idx]);\\n                idx++;\\n            // If the current interval starts after or at the same time as the new interval, exit the loop\\n            }else{\\n                break;\\n            }\\n        }\\n        // If the answer list is empty or the last interval in the answer list ends before the new interval starts\\n        // add the new interval to the answer list\\n        if(ans.size() == 0 || (newInterval[0] > ans.get(ans.size()-1)[1])){\\n            ans.add(newInterval);\\n        // If the last interval in the answer list overlaps with the new interval, merge them by updating the end time of the last interval\\n        }else{\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            lastInterval[1] = Math.max(lastInterval[1],newInterval[1]);\\n        }\\n        // Loop through the remaining intervals in the input array\\n        while(idx < intervals.length){\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            // If the last interval in the answer list overlaps with the current interval, merge them by updating the end time of the last interval\\n            if(lastInterval[1] >= intervals[idx][0]){\\n                lastInterval[1] = Math.max(lastInterval[1], intervals[idx][1]);\\n            }else{\\n                // If the last interval does not overlap with the current interval, add it to the answer list\\n                ans.add(intervals[idx]);\\n            }\\n            idx++;\\n        }\\n        // Convert the ArrayList to a 2D int array and return it\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21659,
                "title": "my-binary-search-approach-implementation-2ms",
                "content": "I know this is a little messy. For clean and simple code, please use the O(n) approach. We have great answer here with just 3 while loops. The BS approach utilizes the ordered characteristic of the input. For me, I want to get the position of the interval that is the first to have start equal to or larger than the inserted interval's start. Similarly, I get the position of the interval that is the first to have end equal to or larger than the new interval's end. Then I can get the range of intervals that the new interval connects. There are some corner cases that need to be considered, i.e. when the new interval has no overlap with any of the existing intervals (smaller, larger, or the original list is empty). In these corner cases, we just don't need to update the new interval. The code could possibly be cleaner and simpler without sacrificing the speed, or even with less time and space. Please let me know if you have any suggestions. Thank you!\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<>();\\n        if (intervals == null || newInterval == null) return result;\\n        int iStart = findStartPos(intervals, newInterval.start);\\n        int iEnd = findEndPos(intervals, newInterval.end);\\n        if (iStart > 0 && intervals.get(iStart - 1).end >= newInterval.start) iStart--;\\n        if (iEnd == intervals.size() || intervals.get(iEnd).start > newInterval.end) iEnd--;\\n        \\n        //If not in the corner cases, this condition should apply.\\n        if (iStart <= iEnd) {\\n            newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end));\\n        }\\n\\n        int i = 0;\\n        while (i < iStart) result.add(intervals.get(i++));\\n        result.add(newInterval);\\n        i = iEnd + 1;\\n        while (i < intervals.size()) result.add(intervals.get(i++));\\n        return result;\\n    }\\n    \\n    private int findStartPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).start == value) return m;\\n            else if (intervals.get(m).start < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int findEndPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).end == value) return m;\\n            else if (intervals.get(m).end < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "I know this is a little messy. For clean and simple code, please use the O(n) approach. We have great answer here with just 3 while loops. The BS approach utilizes the ordered characteristic of the input. For me, I want to get the position of the interval that is the first to have start equal to or larger than the inserted interval's start. Similarly, I get the position of the interval that is the first to have end equal to or larger than the new interval's end. Then I can get the range of intervals that the new interval connects. There are some corner cases that need to be considered, i.e. when the new interval has no overlap with any of the existing intervals (smaller, larger, or the original list is empty). In these corner cases, we just don't need to update the new interval. The code could possibly be cleaner and simpler without sacrificing the speed, or even with less time and space. Please let me know if you have any suggestions. Thank you!\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<>();\\n        if (intervals == null || newInterval == null) return result;\\n        int iStart = findStartPos(intervals, newInterval.start);\\n        int iEnd = findEndPos(intervals, newInterval.end);\\n        if (iStart > 0 && intervals.get(iStart - 1).end >= newInterval.start) iStart--;\\n        if (iEnd == intervals.size() || intervals.get(iEnd).start > newInterval.end) iEnd--;\\n        \\n        //If not in the corner cases, this condition should apply.\\n        if (iStart <= iEnd) {\\n            newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end));\\n        }\\n\\n        int i = 0;\\n        while (i < iStart) result.add(intervals.get(i++));\\n        result.add(newInterval);\\n        i = iEnd + 1;\\n        while (i < intervals.size()) result.add(intervals.get(i++));\\n        return result;\\n    }\\n    \\n    private int findStartPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).start == value) return m;\\n            else if (intervals.get(m).start < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int findEndPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).end == value) return m;\\n            else if (intervals.get(m).end < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3056665,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=nPwyAn_2nT8&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=16) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/QmhQJ3Du/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=nPwyAn_2nT8&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=16) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/QmhQJ3Du/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 21753,
                "title": "o-n-python-solution",
                "content": "    class Solution:\\n        # @param intervals, a list of Intervals\\n        # @param newInterval, a Interval\\n        # @return a list of Interval\\n        def insert(self, intervals, newInterval):\\n            start = newInterval.start\\n            end = newInterval.end\\n            result = []\\n            i = 0\\n            while i < len(intervals):\\n                if start <= intervals[i].end:\\n                    if end < intervals[i].start:\\n                        break\\n                    start = min(start, intervals[i].start)\\n                    end = max(end, intervals[i].end)\\n                else:\\n                    result.append(intervals[i])\\n                i += 1\\n            result.append(Interval(start, end))\\n            result += intervals[i:]\\n            return result",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param intervals, a list of Intervals\\n        # @param newInterval, a Interval\\n        # @return a list of Interval\\n        def insert(self, intervals, newInterval):\\n            start = newInterval.start\\n            end = newInterval.end\\n            result = []\\n            i = 0\\n            while i < len(intervals):\\n                if start <= intervals[i].end:\\n                    if end < intervals[i].start:\\n                        break\\n                    start = min(start, intervals[i].start)\\n                    end = max(end, intervals[i].end)\\n                else:\\n                    result.append(intervals[i])\\n                i += 1\\n            result.append(Interval(start, end))\\n            result += intervals[i:]\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 3056559,
                "title": "super-easy-explanation-c-o-n-simple-solution",
                "content": "# **Consider \\uD83D\\uDC4D**\\n```\\n                    Please Upvote If You Find It Helpful.\\n```\\n# Approach\\nThere are 3 cases:\\n1. **Non overlapping intervals before given new interval** push into the res vector.\\n2. In this case check for **overlapping intervals and new interval** and merge then as\\n    Starting point if new interval will be minimun of starting point of intervals or new interval(given)\\n    Ending point of new interval will be the max of ending point of interval or new interval(given)\\n3. **Non overlapping intervals after the new interval** is merged is pushed into the res vector\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```\\n                                 Give a \\uD83D\\uDC4D\\n```\\nLet\\'s connect on [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful.\\n```\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n                                 Give a \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056954,
                "title": "c-java-python-short-crisp-approach",
                "content": "**Approach:**\\n* The approach used is to `first` iterate through the given intervals, and keeping track of the index of the interval where the new `interval` should be inserted such that the intervals remain `sorted`. Then it will `merge` any overlapping intervals with the new interval and update its `start` and `end` times. `Finally`, it will insert the new interval into the correct position in the intervals and `return` the modified intervals.\\n* The `key` idea behind this approach is to maintain the `sorted` order of the intervals, and to `merge` any overlapping intervals with the new interval. \\n* By iterating through the intervals and keeping track of the index where the new interval should be `inserted`, we can ensure that the intervals `remain` sorted, and by merging any `overlapping` intervals with the new interval, we can ensure that the final `output` has no `overlapping` intervals.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> res;\\n        int i = 0, n = intervals.size();\\n        while (i < n && intervals[i][1] < newInterval[0]) res.push_back(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = {min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])}, i++;\\n        res.push_back(newInterval);\\n        while (i < n) res.push_back(intervals[i++]);\\n        return res;\\n    }\\n};\\n```\\n**Java:**\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, n = intervals.length;\\n        while (i < n && intervals[i][1] < newInterval[0]) res.add(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = new int[] {Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])}, i++;\\n        res.add(newInterval);\\n        while (i < n) res.add(intervals[i++]);\\n        return res.toArray(new int[res.size()][2]);\\n    }\\n}\\n```\\n**Python:**\\n\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        n = len(intervals)\\n        while i < n and intervals[i][1] < newInterval[0]:\\n            res.append(intervals[i])\\n            i += 1\\n        while i < n and intervals[i][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        res.append(newInterval)\\n        while i < n:\\n            res.append(intervals[i])\\n            i += 1\\n        return res\\n```\\n\\n----\\nThe **Time complexity** is **O(n)** \\nThe **Space complexity** is **O(n)** .\\n\\n----\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> res;\\n        int i = 0, n = intervals.size();\\n        while (i < n && intervals[i][1] < newInterval[0]) res.push_back(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = {min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])}, i++;\\n        res.push_back(newInterval);\\n        while (i < n) res.push_back(intervals[i++]);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, n = intervals.length;\\n        while (i < n && intervals[i][1] < newInterval[0]) res.add(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = new int[] {Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])}, i++;\\n        res.add(newInterval);\\n        while (i < n) res.add(intervals[i++]);\\n        return res.toArray(new int[res.size()][2]);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        n = len(intervals)\\n        while i < n and intervals[i][1] < newInterval[0]:\\n            res.append(intervals[i])\\n            i += 1\\n        while i < n and intervals[i][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        res.append(newInterval)\\n        while i < n:\\n            res.append(intervals[i])\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21632,
                "title": "very-short-and-easy-to-understand-c-solution",
                "content": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        vector<Interval> ret;\\n        auto it = intervals.begin();\\n        for(; it!=intervals.end(); ++it){\\n\\t\\t\\tif(newInterval.end < (*it).start) //all intervals after will not overlap with the newInterval\\n\\t\\t\\t\\tbreak; \\n\\t\\t\\telse if(newInterval.start > (*it).end) //*it will not overlap with the newInterval\\n\\t\\t\\t\\tret.push_back(*it); \\n            else{ //update newInterval bacause *it overlap with the newInterval\\n                newInterval.start = min(newInterval.start, (*it).start);\\n                newInterval.end = max(newInterval.end, (*it).end);\\n            }\\t\\n        }\\n        // don't forget the rest of the intervals and the newInterval\\n\\t\\tret.push_back(newInterval);\\n\\t\\tfor(; it!=intervals.end(); ++it)\\n\\t\\t\\tret.push_back(*it);\\n\\t\\treturn ret;\\n    }\\nMy question is why this code need 500ms !?",
                "solutionTags": [],
                "code": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        vector<Interval> ret;\\n        auto it = intervals.begin();\\n        for(; it!=intervals.end(); ++it){\\n\\t\\t\\tif(newInterval.end < (*it).start) //all intervals after will not overlap with the newInterval\\n\\t\\t\\t\\tbreak; \\n\\t\\t\\telse if(newInterval.start > (*it).end) //*it will not overlap with the newInterval\\n\\t\\t\\t\\tret.push_back(*it); \\n            else{ //update newInterval bacause *it overlap with the newInterval\\n                newInterval.start = min(newInterval.start, (*it).start);\\n                newInterval.end = max(newInterval.end, (*it).end);\\n            }\\t\\n        }\\n        // don't forget the rest of the intervals and the newInterval\\n\\t\\tret.push_back(newInterval);\\n\\t\\tfor(; it!=intervals.end(); ++it)\\n\\t\\t\\tret.push_back(*it);\\n\\t\\treturn ret;\\n    }\\nMy question is why this code need 500ms !?",
                "codeTag": "Unknown"
            },
            {
                "id": 21815,
                "title": "two-easy-o-n-c-solutions-with-explanations",
                "content": "By far the best solution I have seen is of `O(n)` time (some solutions claim to be of `O(logn)` turns out to be `O(n)`). One of the simplest ideas is to compare each interval in `intervals` (`intervals[i]`) with `newInterval` and then perform respective operations according to their relationships.\\n\\n 1. If they overlap, merge them to `newInterval`;\\n 2. If `intervals[i]` is to the left of `newInterval`, push `intervals[i]` to the result vector;\\n 3. If `newInterval` is to the left of `intervals[i]`, push `newInterval` and all the remaining intervals (`intervals[i]`, ..., `intervals[n - 1]`) to the result vector.\\n\\nThe code is as follows. \\n\\n    class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            vector<Interval> res;\\n            int n = intervals.size();\\n            for (int i = 0; i < n; i++) {\\n                if (intervals[i].end < newInterval.start)\\n                    res.push_back(intervals[i]);\\n                else if (newInterval.end < intervals[i].start) {\\n                    res.push_back(newInterval);\\n                    for (int j = i; j < n; j++)\\n                        res.push_back(intervals[j]);\\n                    return res; \\n                }\\n                else newInterval = merge(intervals[i], newInterval);\\n            }\\n            res.push_back(newInterval);\\n            return res;\\n        }\\n    private:\\n        Interval merge(Interval& interval1, Interval& interval2) {\\n            int start = min(interval1.start, interval2.start);\\n            int end = max(interval1.end, interval2.end);\\n            return Interval(start, end);\\n        }\\n    };\\n\\nAnother idea is to search for the two ends of the overlapping intervals using binary search. Then we only need to merge `newInterval` with the intervals at the two ends if they overlap. All the intervals within the two ends will be contained in` newInterval`.\\n\\nLet's do the example in the problem statement: `intervals = [1, 2], [3, 5], [6, 7], [8, 10], [12, 16]` and `newInterval = [4, 9]`. We first find the rightmost interval with `start` smaller than that of `newInterval`, which is `[3, 5]`. Then we find the leftmost interval with `end` larger than that of `newInterval`, which is `[8, 10]`. Then all the intervals between them will be contained within `newInterval` (you may check this to convince yourself) and so can be safely ignored. We only need to check whether `newInterval` overlaps with the two intervals on the two ends and merge them if necessary.\\n\\nThe complete code is as follows.\\n\\n    class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            int n = intervals.size(), leftEnd, rightEnd, l, r;\\n            vector<Interval> res;\\n            // Find the rightmost interval with start smaller than that of newInterval\\n            for (l = 0, r = n - 1; l <= r; ) {\\n                int mid = l + ((r - l) >> 1);\\n                if (intervals[mid].start > newInterval.start)\\n                    r = mid - 1;\\n                else l = mid + 1;\\n            } \\n            leftEnd = r;\\n            // Find the leftmost interval with end larger than that of newInterval\\n            for (l = 0, r = n - 1; l <= r; ) {\\n                int mid = l + ((r - l) >> 1);\\n                if (intervals[mid].end < newInterval.end)\\n                    l = mid + 1;\\n                else r = mid - 1;\\n            }\\n            rightEnd = l;\\n            // Merge newInterval with intervals[leftEnd] and intervals[rightEnd] if necessary\\n            if (leftEnd >= 0 && intervals[leftEnd].end >= newInterval.start)\\n                newInterval.start = intervals[leftEnd--].start;\\n            if (rightEnd < n && intervals[rightEnd].start <= newInterval.end)\\n                newInterval.end = intervals[rightEnd++].end;\\n            // Save the intervals sequentially\\n            for (int i = 0; i <= leftEnd; i++)\\n                res.push_back(intervals[i]);\\n            res.push_back(newInterval);\\n            for (int i = rightEnd; i < n; i++)\\n                res.push_back(intervals[i]);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            vector<Interval> res;\\n            int n = intervals.size();\\n            for (int i = 0; i < n; i++) {\\n                if (intervals[i].end < newInterval.start)\\n                    res.push_back(intervals[i]);\\n                else if (newInterval.end < intervals[i].start) {\\n                    res.push_back(newInterval);\\n                    for (int j = i; j < n; j++)\\n                        res.push_back(intervals[j]);\\n                    return res; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3056524,
                "title": "python3-merge-interval-solution-explained-space-complexity-o-n-o-1",
                "content": "**Intuition**\\n\\nThis problem is almost the same as [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/) if we first insert ```newInterval``` into ```intervals``` such that ```intervals``` is still sorted by the start time, and then merge overlapped intervals.\\n\\n - use binary search to find the index where ```newInterval``` should be instered into ```intervals```. O(logN)\\n - Insert the ```newInterval```. O(N)\\n - merge overlapped intervals if there are any.\\n    - We can interately build a stack, and merge a new interval with the last interval in the stack if they overlap.\\n    - To check if a new interval is overlap with the last interval in stack, we simply check if the last end is greater than or equal to the new start. If it is, we merge the two intervals by using the last start as the start, and the max(lastEnd, newEnd) as the end.\\n    - If there is no overlap between the new interval and the last interval in stack, we simply add the new interval to the stack.\\n\\n**Solution 1** using stack\\n\\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        stack = []\\n        for s,e in intervals:\\n            if stack and stack[-1][1] >= s:\\n                lastS,lastE = stack.pop()\\n                stack.append([lastS, max(lastE,e)])\\n            else:\\n                stack.append([s,e])\\n        return stack\\n```\\n\\nWe don\\'t really need to use a stack, but using the list slicing in Python to merge the overlapped intervals.\\n\\n**Solution 2** inplace merge\\n\\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        i = 0\\n        while i<len(intervals):\\n            s,e = intervals[i]\\n            if i>0 and intervals[i-1][1] >= s:\\n                lastS,lastE = intervals[i-1]\\n                intervals[i-1:i+1] = [[lastS, max(lastE,e)]]\\n            else:\\n                i += 1\\n        return intervals\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n",
                "solutionTags": [],
                "code": "```newInterval```\n```intervals```\n```intervals```\n```newInterval```\n```intervals```\n```newInterval```\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        stack = []\\n        for s,e in intervals:\\n            if stack and stack[-1][1] >= s:\\n                lastS,lastE = stack.pop()\\n                stack.append([lastS, max(lastE,e)])\\n            else:\\n                stack.append([s,e])\\n        return stack\\n```\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        i = 0\\n        while i<len(intervals):\\n            s,e = intervals[i]\\n            if i>0 and intervals[i-1][1] >= s:\\n                lastS,lastE = intervals[i-1]\\n                intervals[i-1:i+1] = [[lastS, max(lastE,e)]]\\n            else:\\n                i += 1\\n        return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902628,
                "title": "c-optimized-solution-9-lines-beats-95-time",
                "content": "```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        \\n        while(i < n && intervals[i][1] < newInterval[0])    res.push_back(intervals[i++]);\\n\\t\\t\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        while(i < n)    res.push_back(intervals[i++]);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        \\n        while(i < n && intervals[i][1] < newInterval[0])    res.push_back(intervals[i++]);\\n\\t\\t\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        while(i < n)    res.push_back(intervals[i++]);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342029,
                "title": "javascript-solution-beats-99-79",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let size = intervals.length;\\n    let index = 0;\\n    let res = [];\\n    \\n    while(index < size && intervals[index][1] < newInterval[0]) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    while(index < size && intervals[index][0] <= newInterval[1]) {\\n        newInterval[0] = Math.min(newInterval[0], intervals[index][0]);\\n        newInterval[1] = Math.max(newInterval[1], intervals[index][1]);\\n        index++;\\n    }\\n    res.push(newInterval);\\n    while(index < size) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let size = intervals.length;\\n    let index = 0;\\n    let res = [];\\n    \\n    while(index < size && intervals[index][1] < newInterval[0]) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    while(index < size && intervals[index][0] <= newInterval[1]) {\\n        newInterval[0] = Math.min(newInterval[0], intervals[index][0]);\\n        newInterval[1] = Math.max(newInterval[1], intervals[index][1]);\\n        index++;\\n    }\\n    res.push(newInterval);\\n    while(index < size) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313612,
                "title": "python3-faster-than-99-58-36ms-14-9mb",
                "content": "Python3 - Faster than 99.58% - 36ms & 14.9MB\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        intervals.sort(key=lambda x: x[0])\\n        \\n        result = []\\n        for interval in intervals:\\n            if not result or result[-1][1] < interval[0]:\\n                result.append(interval)\\n            else:\\n                result[-1][1] = max(result[-1][1],interval[1])\\n                \\n        return result\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        intervals.sort(key=lambda x: x[0])\\n        \\n        result = []\\n        for interval in intervals:\\n            if not result or result[-1][1] < interval[0]:\\n                result.append(interval)\\n            else:\\n                result[-1][1] = max(result[-1][1],interval[1])\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298982,
                "title": "javascript-solution-95-fast",
                "content": "```\\nvar insert = function (intervals, newInterval) {\\n    if (intervals.length === 0) {\\n        return [ newInterval ];\\n    }\\n\\n    const result = [];\\n    let flag = 0;\\n    let i;\\n\\n    for (i = 0; i < intervals.length; i++) {\\n        const interval = intervals[i];\\n        if (newInterval[0] > interval[1]){\\n            result.push(interval);\\n        } else if (newInterval[1] < interval[0]){\\n            result.push(newInterval);\\n            flag = 1;\\n            break;\\n        } else {\\n            newInterval[0] = Math.min(newInterval[0], interval[0]);\\n            newInterval[1] = Math.max(newInterval[1], interval[1]);\\n        }\\n    }\\n\\n    if (flag === 0) {\\n        result.push(newInterval);\\n        return result;\\n    } else {\\n        return result.concat(intervals.splice(i));\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insert = function (intervals, newInterval) {\\n    if (intervals.length === 0) {\\n        return [ newInterval ];\\n    }\\n\\n    const result = [];\\n    let flag = 0;\\n    let i;\\n\\n    for (i = 0; i < intervals.length; i++) {\\n        const interval = intervals[i];\\n        if (newInterval[0] > interval[1]){\\n            result.push(interval);\\n        } else if (newInterval[1] < interval[0]){\\n            result.push(newInterval);\\n            flag = 1;\\n            break;\\n        } else {\\n            newInterval[0] = Math.min(newInterval[0], interval[0]);\\n            newInterval[1] = Math.max(newInterval[1], interval[1]);\\n        }\\n    }\\n\\n    if (flag === 0) {\\n        result.push(newInterval);\\n        return result;\\n    } else {\\n        return result.concat(intervals.splice(i));\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845073,
                "title": "python-3-sweep-line-heap-explanations",
                "content": "### Explanation\\n- Typical `Sweep Line` question, use `heap` for help\\n- Mark every start as `-1`, every end as `1`\\n- Sort all start & end points\\n- Close interval only when counter `cur` equals to `0`\\n- Check out below comments for more detail\\n### Implementation\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        heap, ans, = [], [] \\n        for s, e in intervals + [newInterval]: # add start & end to heap (-1 is start, 1 is end)\\n            heapq.heappush(heap, (s, -1))\\n            heapq.heappush(heap, (e, 1))\\n        cur, s = 0, None            \\n        while heap:                            \\n            i, val = heapq.heappop(heap)       # pop heap\\n            if s is None: s = i                # is s is None, assign i to s (interval start)\\n            cur += val                         # keep counting until close interval\\n            if not cur:                        # when cur == 0, meaning we can close the interval\\n                ans.append([s, i])             # append interval to ans\\n                s = None                       # reset s to None\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        heap, ans, = [], [] \\n        for s, e in intervals + [newInterval]: # add start & end to heap (-1 is start, 1 is end)\\n            heapq.heappush(heap, (s, -1))\\n            heapq.heappush(heap, (e, 1))\\n        cur, s = 0, None            \\n        while heap:                            \\n            i, val = heapq.heappop(heap)       # pop heap\\n            if s is None: s = i                # is s is None, assign i to s (interval start)\\n            cur += val                         # keep counting until close interval\\n            if not cur:                        # when cur == 0, meaning we can close the interval\\n                ans.append([s, i])             # append interval to ans\\n                s = None                       # reset s to None\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 844719,
                "title": "golang-idiomatic-solution",
                "content": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    res := make([][]int, 0)\\n    \\n    i := 0\\n    \\n    for ; i < len(intervals) && intervals[i][1] < newInterval[0]; i++ {\\n        res = append(res, intervals[i])\\n    }\\n    \\n    for ; i < len(intervals) && intervals[i][0] <= newInterval[1]; i++ {\\n        newInterval[0] = min(intervals[i][0], newInterval[0])\\n        newInterval[1] = max(intervals[i][1], newInterval[1])\\n    }\\n    \\n    res = append(res, newInterval)\\n    \\n    for i < len(intervals) {\\n        res = append(res, intervals[i])\\n        i++\\n    }\\n    \\n    return res\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    res := make([][]int, 0)\\n    \\n    i := 0\\n    \\n    for ; i < len(intervals) && intervals[i][1] < newInterval[0]; i++ {\\n        res = append(res, intervals[i])\\n    }\\n    \\n    for ; i < len(intervals) && intervals[i][0] <= newInterval[1]; i++ {\\n        newInterval[0] = min(intervals[i][0], newInterval[0])\\n        newInterval[1] = max(intervals[i][1], newInterval[1])\\n    }\\n    \\n    res = append(res, newInterval)\\n    \\n    for i < len(intervals) {\\n        res = append(res, intervals[i])\\n        i++\\n    }\\n    \\n    return res\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2429511,
                "title": "java-explained-solution",
                "content": "```\\n/*\\nInterval will not be overlapped\\ncase 1 : when interval[end] < newInterval[start],ex-newInterval = [4,8], interval = [1,2]\\ncase 2 : when interval[start] > newInterval[end],ex-newInterval = [4,8], interval = [12,16]\\ncase 3 : when new interval is already added in output list\\n\\nremaining all cases they will be overlapped\\n*/\\n\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> res = new ArrayList<>();\\n        for(int[] interval: intervals){\\n            // case3 and case1\\n            if(newInterval==null || interval[1]<newInterval[0]){\\n                res.add(interval);\\n            }else if(interval[0]>newInterval[1]){ // case 2\\n                res.add(newInterval);\\n                res.add(interval);\\n                newInterval = null;\\n            }else{ // overlapping\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        if(newInterval!=null) res.add(newInterval);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nInterval will not be overlapped\\ncase 1 : when interval[end] < newInterval[start],ex-newInterval = [4,8], interval = [1,2]\\ncase 2 : when interval[start] > newInterval[end],ex-newInterval = [4,8], interval = [12,16]\\ncase 3 : when new interval is already added in output list\\n\\nremaining all cases they will be overlapped\\n*/\\n\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> res = new ArrayList<>();\\n        for(int[] interval: intervals){\\n            // case3 and case1\\n            if(newInterval==null || interval[1]<newInterval[0]){\\n                res.add(interval);\\n            }else if(interval[0]>newInterval[1]){ // case 2\\n                res.add(newInterval);\\n                res.add(interval);\\n                newInterval = null;\\n            }else{ // overlapping\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        if(newInterval!=null) res.add(newInterval);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388642,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\\n        var res = new List<int[]>();\\n        \\n        foreach (var interval in intervals)\\n        {\\n            if (interval[0] > newInterval[1])\\n            {\\n                res.Add(newInterval);\\n                newInterval = interval;\\n            }\\n            else if (interval[1] < newInterval[0])\\n            {\\n                res.Add(interval);\\n            }\\n            else\\n            {\\n                newInterval[0] = Math.Min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.Max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        res.Add(newInterval);\\n        \\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\\n        var res = new List<int[]>();\\n        \\n        foreach (var interval in intervals)\\n        {\\n            if (interval[0] > newInterval[1])\\n            {\\n                res.Add(newInterval);\\n                newInterval = interval;\\n            }\\n            else if (interval[1] < newInterval[0])\\n            {\\n                res.Add(interval);\\n            }\\n            else\\n            {\\n                newInterval[0] = Math.Min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.Max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        res.Add(newInterval);\\n        \\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464497,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "Ported to C# from [Java solution](https://leetcode.com/problems/insert-interval/discuss/463417/My-concise-Java-solution-(single-pass-O(n)-3-steps))\\n\\n```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval)\\n    {\\n        List<int[]> result = new List<int[]>();\\n        int i = 0;\\n\\n        // Step 1 - add all intervals ending before newInterval starts\\n        while (i < intervals.Length && intervals[i][1] < newInterval[0])\\n            result.Add(intervals[i++]);\\n\\n        // Step 2 - update the newInterval by merging with all overlapping intervals\\n        while (i < intervals.Length && intervals[i][0] <= newInterval[1])\\n        {\\n            newInterval[0] = Math.Min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.Max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        result.Add(newInterval); // add updated interval\\n\\n        // Step 3 - add remaining intervals\\n        while (i < intervals.Length)\\n            result.Add(intervals[i++]);\\n        \\n        return result.ToArray();\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval)\\n    {\\n        List<int[]> result = new List<int[]>();\\n        int i = 0;\\n\\n        // Step 1 - add all intervals ending before newInterval starts\\n        while (i < intervals.Length && intervals[i][1] < newInterval[0])\\n            result.Add(intervals[i++]);\\n\\n        // Step 2 - update the newInterval by merging with all overlapping intervals\\n        while (i < intervals.Length && intervals[i][0] <= newInterval[1])\\n        {\\n            newInterval[0] = Math.Min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.Max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        result.Add(newInterval); // add updated interval\\n\\n        // Step 3 - add remaining intervals\\n        while (i < intervals.Length)\\n            result.Add(intervals[i++]);\\n        \\n        return result.ToArray();\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250459,
                "title": "very-simple-javascript-o-n-solution",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    const result = [];\\n    \\n    for (let i = 0; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n        \\n        // If overlaps\\n        if (Math.max(interval[0], newInterval[0]) <= Math.min(interval[1], newInterval[1])) {\\n            newInterval = [Math.min(interval[0], newInterval[0]), Math.max(interval[1], newInterval[1])];\\n            continue;\\n        }\\n        \\n        // If lower\\n        if (interval[0] > newInterval[1]) {\\n            result.push(newInterval, ...intervals.slice(i));\\n            return result;\\n        }\\n        \\n        result.push(interval);\\n    }\\n    \\n    result.push(newInterval);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    const result = [];\\n    \\n    for (let i = 0; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n        \\n        // If overlaps\\n        if (Math.max(interval[0], newInterval[0]) <= Math.min(interval[1], newInterval[1])) {\\n            newInterval = [Math.min(interval[0], newInterval[0]), Math.max(interval[1], newInterval[1])];\\n            continue;\\n        }\\n        \\n        // If lower\\n        if (interval[0] > newInterval[1]) {\\n            result.push(newInterval, ...intervals.slice(i));\\n            return result;\\n        }\\n        \\n        result.push(interval);\\n    }\\n    \\n    result.push(newInterval);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1221925,
                "title": "java-solution-with-comments-o-n",
                "content": "The approach is to:\\n1. Skip all the intervals that end before the newInterval starts because they would not overlap anyway. So we add them to the final result.\\n2. For those intervals that overlap with the newInterval, we will merge them before inserting into the final result list. We say that an interval b overlaps with a is b.start <= a.end.\\n3. At the end, we will add the remaining intervals from the original array that do not overlap with the newInterval.\\n\\nWe will use a List since we do not know the size of our merged intervals beforehand and then we will convert the list to the required 2-dimensional array\\n\\n```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length; // length of intervals\\n        if (intervals == null || n == 0) {\\n            return new int[][] { newInterval };\\n        }\\n        \\n        // result list to be converted to int[] at the end\\n        List<int[]> result = new ArrayList<>();\\n        \\n        // skip the intervals that end before new interval\\n        int i = 0;\\n        \\n        while (i < n && intervals[i][1] < newInterval[0]) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        \\n        // merge all intervals that overlap with newInterval\\n        while (i < n && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n        // add the newly merged interval\\n        result.add(newInterval);\\n        \\n        // add all the remaining intervals to result\\n        while (i < n) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n\\n\\t\\t// convert to a 2d array\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "The approach is to:\\n1. Skip all the intervals that end before the newInterval starts because they would not overlap anyway. So we add them to the final result.\\n2. For those intervals that overlap with the newInterval, we will merge them before inserting into the final result list. We say that an interval b overlaps with a is b.start <= a.end.\\n3. At the end, we will add the remaining intervals from the original array that do not overlap with the newInterval.\\n\\nWe will use a List since we do not know the size of our merged intervals beforehand and then we will convert the list to the required 2-dimensional array\\n\\n```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length; // length of intervals\\n        if (intervals == null || n == 0) {\\n            return new int[][] { newInterval };\\n        }\\n        \\n        // result list to be converted to int[] at the end\\n        List<int[]> result = new ArrayList<>();\\n        \\n        // skip the intervals that end before new interval\\n        int i = 0;\\n        \\n        while (i < n && intervals[i][1] < newInterval[0]) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        \\n        // merge all intervals that overlap with newInterval\\n        while (i < n && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n        // add the newly merged interval\\n        result.add(newInterval);\\n        \\n        // add all the remaining intervals to result\\n        while (i < n) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n\\n\\t\\t// convert to a 2d array\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 685007,
                "title": "python-very-simple-solution-based-on-merge-intervals",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ## RC ##\\n\\t\\t## Similar to Leetcode 56. Merge Intervals ##\\n\\t\\t## LOGIC ##\\n\\t\\t## 1. As per the problem statement, the intervals are initially sorted, so we donot need to sort them, we can just insert the new interval in the right position and apply the merge intervals algorithm. ##\\n\\t\\t## TIME COMPLEXICITY : O(N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(1) ##\\n        \\n        i = 0\\n        while( i<len(intervals) and intervals[i][0] < newInterval[0]):\\n            i+= 1\\n        \\n        intervals.insert(i,newInterval)\\n        \\n        ans = []\\n        for interval in intervals:\\n            if len(ans) == 0 or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ## RC ##\\n\\t\\t## Similar to Leetcode 56. Merge Intervals ##\\n\\t\\t## LOGIC ##\\n\\t\\t## 1. As per the problem statement, the intervals are initially sorted, so we donot need to sort them, we can just insert the new interval in the right position and apply the merge intervals algorithm. ##\\n\\t\\t## TIME COMPLEXICITY : O(N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(1) ##\\n        \\n        i = 0\\n        while( i<len(intervals) and intervals[i][0] < newInterval[0]):\\n            i+= 1\\n        \\n        intervals.insert(i,newInterval)\\n        \\n        ans = []\\n        for interval in intervals:\\n            if len(ans) == 0 or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056535,
                "title": "python3-79-ms-faster-than-93-12-of-python3-clean-and-easy-to-understand",
                "content": "```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        for i in range(len(intervals)):\\n            if newInterval[1] < intervals[i][0]:\\n                result.append(newInterval)\\n                return result + intervals[i:]\\n            elif newInterval[0] > intervals[i][1]:\\n                result.append(intervals[i])\\n            else:\\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\\n        result.append(newInterval)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        for i in range(len(intervals)):\\n            if newInterval[1] < intervals[i][0]:\\n                result.append(newInterval)\\n                return result + intervals[i:]\\n            elif newInterval[0] > intervals[i][1]:\\n                result.append(intervals[i])\\n            else:\\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\\n        result.append(newInterval)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1430986,
                "title": "binary-search-solution",
                "content": "First looking where to insert elements from new interval using binary search (to left of the interval or into the interval itself) - O(log N). Second composing two lists left and right to the new interval. Third merging if start or end falls in between of any interval. Overall worst case still O(N) but binary search helps in cases like new interval consumes all intervals.\\n\\n**Python**\\n```\\n    def bsearch(intervals: List[List[int]], x: int) -> int:\\n        lo, hi = 0, len(intervals)\\n        mid = 0\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if intervals[mid][0] > x:\\n                hi = mid\\n            elif intervals[mid][1] < x:\\n                lo = mid + 1\\n            else:\\n                break\\n        return mid\\n \\n    def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        li, ri = bsearch(intervals, s), bsearch(intervals, e)\\n        l = intervals[:li + int(li < len(intervals) and intervals[li][1] < s)]\\n        r = intervals[ri + int(ri >= len(intervals) or intervals[ri][0] <= e):]\\n        if len(l) + len(r) != len(intervals):\\n            s = min(s, intervals[len(l)][0])\\n            e = max(e, intervals[-len(r)-1][1])\\n        return l + [[s, e]] + r\\n```\\n\\n**Javascript**\\n```\\nconst bsearch = (intervals, x) => {\\n    let mid = 0;\\n    let lo = 0;\\n    let hi = intervals.length;\\n    while (lo < hi) {\\n        mid = (lo + hi - Number((lo + hi) % 2 !== 0)) / 2;\\n        if (intervals[mid][0] > x)\\n            hi = mid;\\n        else if (intervals[mid][1] < x)\\n            lo = mid + 1\\n        else\\n            break;\\n    }\\n    return mid;\\n}\\n\\nconst insert = (intervals, newInterval) => {\\n    let [s, e] = newInterval;\\n    const li = bsearch(intervals, newInterval[0]);\\n    const ri = bsearch(intervals, newInterval[1]);\\n    const l = intervals.slice(0, li + Number(li < intervals.length && intervals[li][1] < s));\\n    const r = intervals.slice(ri + Number(ri >= intervals.length || intervals[ri][0] <= e))\\n    if (l.length + r.length !== intervals.length) {\\n        s = Math.min(s, intervals[l.length][0]);\\n        e = Math.max(e, intervals[intervals.length - r.length - 1][1]);\\n    }\\n    return [...l, [s, e], ...r];\\n};\\n```\\n\\n**Rust**\\n```\\n    use std::cmp::Ordering;\\n    fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        let (mut s, mut e) = (new_interval[0], new_interval[1]);\\n        let pred = |x| {\\n            move |i: &Vec<i32>| {\\n                if i[0] > x {\\n                    Ordering::Greater\\n                } else if i[1] < x {\\n                    Ordering::Less\\n                } else {\\n                    Ordering::Equal\\n                }\\n            }\\n        };\\n        let li = intervals.binary_search_by(pred(s)).unwrap_or_else(|x| x);\\n        let ri = intervals.binary_search_by(pred(e)).unwrap_or_else(|x| x);\\n        let l = &intervals[..(li + usize::from(li < intervals.len() && intervals[li][1] < s))];\\n        let r = &intervals[(ri + usize::from(ri >= intervals.len() || intervals[ri][0] <= e)).min(intervals.len())..];\\n        if l.len() + r.len() != intervals.len() {\\n            s = s.min(intervals[l.len()][0]);\\n            e = e.max(intervals[intervals.len() - r.len() - 1][1]);\\n        }\\n        vec![l, &vec![vec![s, e]], r].concat()\\n    }\\n```",
                "solutionTags": [
                    "Python",
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\n    def bsearch(intervals: List[List[int]], x: int) -> int:\\n        lo, hi = 0, len(intervals)\\n        mid = 0\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if intervals[mid][0] > x:\\n                hi = mid\\n            elif intervals[mid][1] < x:\\n                lo = mid + 1\\n            else:\\n                break\\n        return mid\\n \\n    def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        li, ri = bsearch(intervals, s), bsearch(intervals, e)\\n        l = intervals[:li + int(li < len(intervals) and intervals[li][1] < s)]\\n        r = intervals[ri + int(ri >= len(intervals) or intervals[ri][0] <= e):]\\n        if len(l) + len(r) != len(intervals):\\n            s = min(s, intervals[len(l)][0])\\n            e = max(e, intervals[-len(r)-1][1])\\n        return l + [[s, e]] + r\\n```\n```\\nconst bsearch = (intervals, x) => {\\n    let mid = 0;\\n    let lo = 0;\\n    let hi = intervals.length;\\n    while (lo < hi) {\\n        mid = (lo + hi - Number((lo + hi) % 2 !== 0)) / 2;\\n        if (intervals[mid][0] > x)\\n            hi = mid;\\n        else if (intervals[mid][1] < x)\\n            lo = mid + 1\\n        else\\n            break;\\n    }\\n    return mid;\\n}\\n\\nconst insert = (intervals, newInterval) => {\\n    let [s, e] = newInterval;\\n    const li = bsearch(intervals, newInterval[0]);\\n    const ri = bsearch(intervals, newInterval[1]);\\n    const l = intervals.slice(0, li + Number(li < intervals.length && intervals[li][1] < s));\\n    const r = intervals.slice(ri + Number(ri >= intervals.length || intervals[ri][0] <= e))\\n    if (l.length + r.length !== intervals.length) {\\n        s = Math.min(s, intervals[l.length][0]);\\n        e = Math.max(e, intervals[intervals.length - r.length - 1][1]);\\n    }\\n    return [...l, [s, e], ...r];\\n};\\n```\n```\\n    use std::cmp::Ordering;\\n    fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        let (mut s, mut e) = (new_interval[0], new_interval[1]);\\n        let pred = |x| {\\n            move |i: &Vec<i32>| {\\n                if i[0] > x {\\n                    Ordering::Greater\\n                } else if i[1] < x {\\n                    Ordering::Less\\n                } else {\\n                    Ordering::Equal\\n                }\\n            }\\n        };\\n        let li = intervals.binary_search_by(pred(s)).unwrap_or_else(|x| x);\\n        let ri = intervals.binary_search_by(pred(e)).unwrap_or_else(|x| x);\\n        let l = &intervals[..(li + usize::from(li < intervals.len() && intervals[li][1] < s))];\\n        let r = &intervals[(ri + usize::from(ri >= intervals.len() || intervals[ri][0] <= e)).min(intervals.len())..];\\n        if l.len() + r.len() != intervals.len() {\\n            s = s.min(intervals[l.len()][0]);\\n            e = e.max(intervals[intervals.len() - r.len() - 1][1]);\\n        }\\n        vec![l, &vec![vec![s, e]], r].concat()\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 463417,
                "title": "my-concise-java-solution-single-pass-o-n-3-steps-with-explanation",
                "content": "The idea is simple. Since the intervals are already sorted by start time, all we need is one pass from left to right. \\n**3 steps:**\\n1. Add any intervals that finish before the new interval starts.\\n2. Update the new interval by merging it will all overlapping intervals. Add the updated newInterval to result.\\n3. Add remaining intervals to result, and voila!\\n\\nHere\\'s the code\\n```\\npublic int[][] insert(int[][] intervals, int[] newInterval) {       \\n\\tList<int[]> result = new ArrayList<>();        \\n\\tint i=0;\\n\\n\\t// Step 1 - add all intervals ending before newInterval starts\\n\\twhile (i<intervals.length && intervals[i][1] < newInterval[0]) result.add(intervals[i++]);\\n\\n\\t// Step 2 - update the newInterval by merging with all overlapping intervals\\n\\twhile (i<intervals.length && intervals[i][0] <= newInterval[1]) {\\n\\t\\tnewInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n\\t\\tnewInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n\\t\\ti++;\\n\\t}\\n\\tresult.add(newInterval); // add updated interval\\n\\n\\t// Step 3 - add remaining intervals\\n\\twhile (i<intervals.length) result.add(intervals[i++]);\\n\\treturn result.toArray(new int[0][2]);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] insert(int[][] intervals, int[] newInterval) {       \\n\\tList<int[]> result = new ArrayList<>();        \\n\\tint i=0;\\n\\n\\t// Step 1 - add all intervals ending before newInterval starts\\n\\twhile (i<intervals.length && intervals[i][1] < newInterval[0]) result.add(intervals[i++]);\\n\\n\\t// Step 2 - update the newInterval by merging with all overlapping intervals\\n\\twhile (i<intervals.length && intervals[i][0] <= newInterval[1]) {\\n\\t\\tnewInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n\\t\\tnewInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n\\t\\ti++;\\n\\t}\\n\\tresult.add(newInterval); // add updated interval\\n\\n\\t// Step 3 - add remaining intervals\\n\\twhile (i<intervals.length) result.add(intervals[i++]);\\n\\treturn result.toArray(new int[0][2]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056859,
                "title": "c-easy-intutive-solution-in-o-nlogn-time-complexity",
                "content": "# Intuition\\nIt is similar to the question [Merge Intervals](https://leetcode.com/problems/merge-intervals/) must try before doing this problem.\\n\\n# Approach\\nInsert the new interval in and then the question becomes same as merge intervals.\\n\\n# Complexity\\n- Time complexity:O(NLogN)\\n\\n- Space complexity:O(2*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval});\\n        sort(intervals.begin() , intervals.end());\\n        int j = 0 , n = intervals.size();\\n        for(int i = 1 ; i < n ; i++){\\n            if(intervals[j][1] >= intervals[i][0]){\\n                intervals[j][1] = max(intervals[j][1] , intervals[i][1]);\\n            }\\n            else{\\n                j++;\\n                intervals[j] = intervals[i];\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(int i = 0 ; i <= j ; i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n*I just did this solution for doing it some other way and i know there exist a O(N) solution too*\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval});\\n        sort(intervals.begin() , intervals.end());\\n        int j = 0 , n = intervals.size();\\n        for(int i = 1 ; i < n ; i++){\\n            if(intervals[j][1] >= intervals[i][0]){\\n                intervals[j][1] = max(intervals[j][1] , intervals[i][1]);\\n            }\\n            else{\\n                j++;\\n                intervals[j] = intervals[i];\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(int i = 0 ; i <= j ; i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912542,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var i = 0\\n\\n        while i < intervals.count, intervals[i][1] < newInterval[0] {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        var newInterval = newInterval\\n        while i < intervals.count, intervals[i][0] <= newInterval[1] {\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        }\\n\\n        ans.append(newInterval)\\n\\n        while i < intervals.count {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var i = 0\\n\\n        while i < intervals.count, intervals[i][1] < newInterval[0] {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        var newInterval = newInterval\\n        while i < intervals.count, intervals[i][0] <= newInterval[1] {\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        }\\n\\n        ans.append(newInterval)\\n\\n        while i < intervals.count {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444764,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        l = bisect.bisect_left([x[1] for x in intervals],newInterval[0])\\n        r = bisect.bisect_right([x[0] for x in intervals],newInterval[1])\\n        \\n        if l < len(intervals):\\n            newInterval[0] = min(newInterval[0],intervals[l][0])\\n            \\n        if r > 0:\\n            newInterval[1] = max(newInterval[1],intervals[r-1][1])\\n            \\n        return intervals[:l] + [ newInterval ] + intervals[r:]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        l = bisect.bisect_left([x[1] for x in intervals],newInterval[0])\\n        r = bisect.bisect_right([x[0] for x in intervals],newInterval[1])\\n        \\n        if l < len(intervals):\\n            newInterval[0] = min(newInterval[0],intervals[l][0])\\n            \\n        if r > 0:\\n            newInterval[1] = max(newInterval[1],intervals[r-1][1])\\n            \\n        return intervals[:l] + [ newInterval ] + intervals[r:]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 792436,
                "title": "c-one-pass-o-n-solution",
                "content": "```csharp\\npublic int[][] Insert(int[][] intervals, int[] newInterval) \\n{\\n\\tif(intervals.Length == 0)\\n\\t{\\n\\t\\treturn new int[][] { newInterval };\\n\\t}        \\n\\n\\tList<int[]> result = new List<int[]>();\\n\\tforeach(var interval in intervals)\\n\\t{\\n\\t\\tif(newInterval[0] > interval[1])\\n\\t\\t{\\n\\t\\t\\tresult.Add(interval);\\n\\t\\t}\\n\\n\\t\\telse if(newInterval[1] < interval[0])\\n\\t\\t{\\n\\t\\t\\tresult.Add(newInterval);\\n\\t\\t\\tnewInterval = interval;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewInterval[0] = Math.Min(interval[0], newInterval[0]);\\n\\t\\t\\tnewInterval[1] = Math.Max(interval[1], newInterval[1]);\\n\\t\\t}\\n\\t}\\n\\n\\tresult.Add(newInterval);\\n\\treturn result.ToArray();\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[][] Insert(int[][] intervals, int[] newInterval) \\n{\\n\\tif(intervals.Length == 0)\\n\\t{\\n\\t\\treturn new int[][] { newInterval };\\n\\t}        \\n\\n\\tList<int[]> result = new List<int[]>();\\n\\tforeach(var interval in intervals)\\n\\t{\\n\\t\\tif(newInterval[0] > interval[1])\\n\\t\\t{\\n\\t\\t\\tresult.Add(interval);\\n\\t\\t}\\n\\n\\t\\telse if(newInterval[1] < interval[0])\\n\\t\\t{\\n\\t\\t\\tresult.Add(newInterval);\\n\\t\\t\\tnewInterval = interval;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewInterval[0] = Math.Min(interval[0], newInterval[0]);\\n\\t\\t\\tnewInterval[1] = Math.Max(interval[1], newInterval[1]);\\n\\t\\t}\\n\\t}\\n\\n\\tresult.Add(newInterval);\\n\\treturn result.ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056498,
                "title": "c-short-easy-code-with-explanation",
                "content": "# Intuition\\nThe main idea of solving this problem is that when iterate over the intervals, there are three cases:\\n\\n1) the new interval\\'s range is before the range of current interval.\\nExample new interval= {3,4} and current interval= {6,9}\\n\\n2) the new interval is after the range of current interval.\\nExample new interval= {5,7} and current interval= {2,3}\\n3) the new interval range overlaps with the range of current interval.\\nExample interval= {5,9} and new interval= {6,11}\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimple iterate through intervals.\\n- If case 1 occurs,ie. The new interval\\'s range is before the current interval, so we can insert the new interval into answer and update new interval to the current interval.\\n- If case 2 occurs,ie. The new interval is after the range of current interval, so we can simply insert the current interval into answer.\\n- If case 3 occurs,ie. The new interval overlaps with current interval, so we update the first element of new interval to the minimum of current interval and new interval and update the second element of new interval to the maximum of current interval and new interval.\\nExample interval= {5,9} and new interval= {6,11}. Then update new interval = {min(5,6),max(9,11)}={5,11}\\n- At the end of iterations simply insert new interval to the answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<intervals.size();i++){\\n            //case 1 occurs\\n            if(intervals[i][0] > newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\n            //case 2 occurs\\n            else if(intervals[i][1] < newInterval[0]){ans.push_back(intervals[i]);}       \\n    \\n            //case 3 occurs\\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        //final step\\n        ans.push_back(newInterval); \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<intervals.size();i++){\\n            //case 1 occurs\\n            if(intervals[i][0] > newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\n            //case 2 occurs\\n            else if(intervals[i][1] < newInterval[0]){ans.push_back(intervals[i]);}       \\n    \\n            //case 3 occurs\\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        //final step\\n        ans.push_back(newInterval); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738782,
                "title": "solution-swift-insert-interval-test-cases",
                "content": "```swift\\nclass Solution {\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [newInterval] }\\n        guard !newInterval.isEmpty else { return intervals }\\n        \\n        var idx = 0, new = newInterval, result: [[Int]] = []\\n        let len = intervals.count\\n        \\n        while idx < len, intervals[idx][1] < new[0] {\\n            result.append(intervals[idx])\\n            idx += 1\\n        }\\n        \\n        while idx < len, intervals[idx][0] <= new[1] {\\n            new[0] = min(intervals[idx][0], new[0])\\n            new[1] = max(intervals[idx][1], new[1])\\n            idx += 1\\n        }\\n        \\n        result.append(new)\\n        \\n        for i in idx..<len { result.append(intervals[i]) }\\n        \\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.insert([[1,3],[6,9]], [2,5])\\n        XCTAssertEqual(value, [[1,5],[6,9]])\\n    }\\n    \\n    // Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\\n    func test1() {\\n        let value = solution.insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])\\n        XCTAssertEqual(value, [[1,2],[3,10],[12,16]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [newInterval] }\\n        guard !newInterval.isEmpty else { return intervals }\\n        \\n        var idx = 0, new = newInterval, result: [[Int]] = []\\n        let len = intervals.count\\n        \\n        while idx < len, intervals[idx][1] < new[0] {\\n            result.append(intervals[idx])\\n            idx += 1\\n        }\\n        \\n        while idx < len, intervals[idx][0] <= new[1] {\\n            new[0] = min(intervals[idx][0], new[0])\\n            new[1] = max(intervals[idx][1], new[1])\\n            idx += 1\\n        }\\n        \\n        result.append(new)\\n        \\n        for i in idx..<len { result.append(intervals[i]) }\\n        \\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.insert([[1,3],[6,9]], [2,5])\\n        XCTAssertEqual(value, [[1,5],[6,9]])\\n    }\\n    \\n    // Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\\n    func test1() {\\n        let value = solution.insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])\\n        XCTAssertEqual(value, [[1,2],[3,10],[12,16]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844503,
                "title": "c-simple-explained-solution-o-n-time-o-1-space-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size();\\n        \\n        if (n == 0) // edge case #1: no intervals in original list\\n            return {newInterval};\\n        \\n        if (intervals[n-1][1] < newInterval[0]) { // edge case #2: new interval goes in the end of the list with no overlap\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        vector<vector<int>> res;\\n        int i = 0;\\n        for(; i<n; i++) {\\n            \\n            if (intervals[i][1] < newInterval[0]) // new interval doesn\\'t overlap\\n                res.push_back(intervals[i]);\\n            else {\\n                int first = min(intervals[i][0], newInterval[0]);\\n                int last = newInterval[1];\\n                \\n                while (i < n && last >= intervals[i][0]) { // while new interval overlaps:\\n                    last = max(intervals[i][1], newInterval[1]);\\n                    i++;\\n                }\\n                res.push_back({first, last});\\n                break;\\n            }\\n        }\\n        \\n        while (i < n) { // add the rest\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size();\\n        \\n        if (n == 0) // edge case #1: no intervals in original list\\n            return {newInterval};\\n        \\n        if (intervals[n-1][1] < newInterval[0]) { // edge case #2: new interval goes in the end of the list with no overlap\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        vector<vector<int>> res;\\n        int i = 0;\\n        for(; i<n; i++) {\\n            \\n            if (intervals[i][1] < newInterval[0]) // new interval doesn\\'t overlap\\n                res.push_back(intervals[i]);\\n            else {\\n                int first = min(intervals[i][0], newInterval[0]);\\n                int last = newInterval[1];\\n                \\n                while (i < n && last >= intervals[i][0]) { // while new interval overlaps:\\n                    last = max(intervals[i][1], newInterval[1]);\\n                    i++;\\n                }\\n                res.push_back({first, last});\\n                break;\\n            }\\n        }\\n        \\n        while (i < n) { // add the rest\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21698,
                "title": "java-2ms-o-log-n-o-1-binary-search-solution-beats-97-7-with-clear-explaination",
                "content": "The idea is using binary search to find the position that the newInterval to be inserted. \\n\\nSince the original intervals are sorted and disjoint, we can apply binary search to find the insertion index of newInterval.start (by interval.start), and to find the insertion index of newInterval.end(by interval.end), \\u3010see LeeCode problem #35\\u3011. Then remove the overlapped elements of the list and merge the newInterval with boundary elements on two sides.\\n\\nComplexity: O(log n) in time (in fact, depending on the implement of the access method list.get(i) and of list.subList(int, int).clear()); O(1) in space.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Since the original list is sorted and all intervals are disjoint,\\n\\t\\t\\t * apply binary search to find the insertion index for the new\\n\\t\\t\\t * interval. [LC35]\\n\\t\\t\\t * \\n\\t\\t\\t * 1. Find insIdx=the insertion index of new.start, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).start>=new.start.\\n\\t\\t\\t * \\n\\t\\t\\t * 2. Find nxtIdx=the insertion index of new.end, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).end>=new.end.\\n\\t\\t\\t * \\n\\t\\t\\t * 3. Remove all elements of the list with indices insIdx<=i<nxtIdx.\\n\\t\\t\\t * \\n\\t\\t\\t * 4. Merge new with list.get(insIdx-1) or list.get(nxtIdx) or both.\\n\\t\\t\\t */\\n\\n\\t\\t\\tint n = intervals.size();\\n\\t\\t\\tif (n == 0) {\\n\\t\\t\\t\\tintervals.add(newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint low = 0, high = n - 1, mid = 0;\\n\\t\\t\\tint temp, target = newInterval.start;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).start;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// insIdx = the index where new interval to be inserted\\n\\t\\t\\tint insIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval pre = (insIdx == 0) ? null : intervals.get(insIdx - 1);\\n\\t\\t\\t// 0<=insIdx<=n, pre=[insIdx-1], pre.start<new.start\\n\\n\\t\\t\\tlow = insIdx;\\n\\t\\t\\thigh = n - 1;\\n\\t\\t\\ttarget = newInterval.end;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).end;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// nxtIdx= the next index after the inserted new interval\\n\\t\\t\\tint nxtIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval nxt = (nxtIdx == n) ? null : intervals.get(nxtIdx);\\n\\t\\t\\t// insIdx<=nxtIdx<=n, nxt=[nxtIdx], nxt.end>=new.end\\n\\n\\t\\t\\t// [0]...[insIdx-1] <--> [insIdx]...[nxtIdx-1][nxtIdx]...[n]\\n\\t\\t\\tintervals.subList(insIdx, nxtIdx).clear();\\n\\n\\t\\t\\t// check whether newInterval can be merged with pre or nxt\\n\\t\\t\\tboolean isMerged = false, isMerged2 = false;\\n\\t\\t\\tif (insIdx > 0 && pre.end >= newInterval.start) {\\n\\t\\t\\t\\tpre.end = Math.max(pre.end, newInterval.end);\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (nxtIdx < n && newInterval.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = Math.min(nxt.start, newInterval.start);\\n\\t\\t\\t\\tisMerged2 = isMerged;\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!isMerged) {\\n\\t\\t\\t\\tintervals.add(insIdx, newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// merged with pre or nxt or both, deal with the both case\\n\\t\\t\\tif (isMerged2 && pre.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = pre.start; // pre.start < new.start, nxt.start;\\n\\t\\t\\t\\tintervals.remove(insIdx - 1); // remove pre\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn intervals;\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "The idea is using binary search to find the position that the newInterval to be inserted. \\n\\nSince the original intervals are sorted and disjoint, we can apply binary search to find the insertion index of newInterval.start (by interval.start), and to find the insertion index of newInterval.end(by interval.end), \\u3010see LeeCode problem #35\\u3011. Then remove the overlapped elements of the list and merge the newInterval with boundary elements on two sides.\\n\\nComplexity: O(log n) in time (in fact, depending on the implement of the access method list.get(i) and of list.subList(int, int).clear()); O(1) in space.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Since the original list is sorted and all intervals are disjoint,\\n\\t\\t\\t * apply binary search to find the insertion index for the new\\n\\t\\t\\t * interval. [LC35]\\n\\t\\t\\t * \\n\\t\\t\\t * 1. Find insIdx=the insertion index of new.start, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).start>=new.start.\\n\\t\\t\\t * \\n\\t\\t\\t * 2. Find nxtIdx=the insertion index of new.end, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).end>=new.end.\\n\\t\\t\\t * \\n\\t\\t\\t * 3. Remove all elements of the list with indices insIdx<=i<nxtIdx.\\n\\t\\t\\t * \\n\\t\\t\\t * 4. Merge new with list.get(insIdx-1) or list.get(nxtIdx) or both.\\n\\t\\t\\t */\\n\\n\\t\\t\\tint n = intervals.size();\\n\\t\\t\\tif (n == 0) {\\n\\t\\t\\t\\tintervals.add(newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint low = 0, high = n - 1, mid = 0;\\n\\t\\t\\tint temp, target = newInterval.start;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).start;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// insIdx = the index where new interval to be inserted\\n\\t\\t\\tint insIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval pre = (insIdx == 0) ? null : intervals.get(insIdx - 1);\\n\\t\\t\\t// 0<=insIdx<=n, pre=[insIdx-1], pre.start<new.start\\n\\n\\t\\t\\tlow = insIdx;\\n\\t\\t\\thigh = n - 1;\\n\\t\\t\\ttarget = newInterval.end;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).end;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// nxtIdx= the next index after the inserted new interval\\n\\t\\t\\tint nxtIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval nxt = (nxtIdx == n) ? null : intervals.get(nxtIdx);\\n\\t\\t\\t// insIdx<=nxtIdx<=n, nxt=[nxtIdx], nxt.end>=new.end\\n\\n\\t\\t\\t// [0]...[insIdx-1] <--> [insIdx]...[nxtIdx-1][nxtIdx]...[n]\\n\\t\\t\\tintervals.subList(insIdx, nxtIdx).clear();\\n\\n\\t\\t\\t// check whether newInterval can be merged with pre or nxt\\n\\t\\t\\tboolean isMerged = false, isMerged2 = false;\\n\\t\\t\\tif (insIdx > 0 && pre.end >= newInterval.start) {\\n\\t\\t\\t\\tpre.end = Math.max(pre.end, newInterval.end);\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (nxtIdx < n && newInterval.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = Math.min(nxt.start, newInterval.start);\\n\\t\\t\\t\\tisMerged2 = isMerged;\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!isMerged) {\\n\\t\\t\\t\\tintervals.add(insIdx, newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// merged with pre or nxt or both, deal with the both case\\n\\t\\t\\tif (isMerged2 && pre.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = pre.start; // pre.start < new.start, nxt.start;\\n\\t\\t\\t\\tintervals.remove(insIdx - 1); // remove pre\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn intervals;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 844481,
                "title": "c-clean-and-commented-with-example-explained-o-n-time",
                "content": "****Explaination****\\n- **1st While loop** to put all intervals that are to the left of the inserted interval. \\n-  **2nd While loop to** merge all intervals that intersect with the inserted interval.\\n-  **3rd While loop** put all intervals that are to the right of the inserted interval.\\n\\n****Example****\\nGiven [1,2],[3,5],[6,7],[8,10],[12,14], insert and merge [4,9] in as [1,2],[3,10],[12,14]\\n![image](https://assets.leetcode.com/users/images/58677d7a-175e-4f97-ab36-44d01d3195e5_1599985042.67296.png)\\n\\n****Code****\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> sol;\\n        if(!size(intervals) and !size(newInterval)){\\n            sol.push_back(newInterval);\\n            return sol;\\n        }\\n        if(!size(intervals)){\\n            sol.push_back(newInterval);\\n            return(sol);\\n        }\\n        int i=0;\\n        int start=newInterval[0];\\n        int end=newInterval[1];\\n\\t\\t//while #1 put all intervals that are to the left of the inserted interval. \\n                while(i<size(intervals) and  intervals[i][1]<newInterval[0]) \\n                    sol.push_back(intervals[i++]);\\n\\t\\t//while #2 merge all intervals that intersect with the inserted interval.\\n                while(i<size(intervals) and intervals[i][0]<=end){\\n                    start = min(start, intervals[i][0]);\\n                    end = max(end, intervals[i][1]);\\n                    i++;\\n                }\\n                sol.push_back({start,end});\\n\\t//while #3 put all intervals that are to the right of the inserted interval.\\n            while(i<size(intervals))\\n                sol.push_back(intervals[i++]);\\n        return sol;          \\n    }\\n};\\n```\\n****Complexity****\\nO(n)",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> sol;\\n        if(!size(intervals) and !size(newInterval)){\\n            sol.push_back(newInterval);\\n            return sol;\\n        }\\n        if(!size(intervals)){\\n            sol.push_back(newInterval);\\n            return(sol);\\n        }\\n        int i=0;\\n        int start=newInterval[0];\\n        int end=newInterval[1];\\n\\t\\t//while #1 put all intervals that are to the left of the inserted interval. \\n                while(i<size(intervals) and  intervals[i][1]<newInterval[0]) \\n                    sol.push_back(intervals[i++]);\\n\\t\\t//while #2 merge all intervals that intersect with the inserted interval.\\n                while(i<size(intervals) and intervals[i][0]<=end){\\n                    start = min(start, intervals[i][0]);\\n                    end = max(end, intervals[i][1]);\\n                    i++;\\n                }\\n                sol.push_back({start,end});\\n\\t//while #3 put all intervals that are to the right of the inserted interval.\\n            while(i<size(intervals))\\n                sol.push_back(intervals[i++]);\\n        return sol;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844417,
                "title": "python-simple-explained-solution-o-n-time-o-1-space-faster-than-99",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\n        # edge case #1: no intervals in original list\\n        if len(intervals) == 0:\\n            return [newInterval]\\n\\t\\t\\t\\n        # edge case #2: new interval goes in the end of the list with no overlap\\n        if intervals[-1][1] < newInterval[0]:\\n            return intervals + [newInterval]\\n\\t\\t\\t\\n        # edge case #3: new interval goes in the beginning of the list with no overlap\\n        if newInterval[1] < intervals[0][0]:\\n            return [newInterval] + intervals\\n\\t\\t\\t\\n        res = []\\n        i = 0\\n        for curr_interval in intervals:\\n            # new interval doesn\\'t overlap\\n            if curr_interval[1] < newInterval[0]:\\n                res.append(curr_interval)\\n            else:\\n                first = min(curr_interval[0], newInterval[0])\\n                last = newInterval[1]\\n                i = intervals.index(curr_interval)\\n\\t\\t\\t\\t\\n                # while new interval overlaps:\\n                while i < len(intervals) and last >= intervals[i][0]:\\n                    last = max(intervals[i][1], newInterval[1])\\n                    i+=1\\n                res.append([first, last])\\n                break\\n\\t\\t\\t\\t\\n        # add the rest\\n        res += intervals[i:]\\n        return res\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\n        # edge case #1: no intervals in original list\\n        if len(intervals) == 0:\\n            return [newInterval]\\n\\t\\t\\t\\n        # edge case #2: new interval goes in the end of the list with no overlap\\n        if intervals[-1][1] < newInterval[0]:\\n            return intervals + [newInterval]\\n\\t\\t\\t\\n        # edge case #3: new interval goes in the beginning of the list with no overlap\\n        if newInterval[1] < intervals[0][0]:\\n            return [newInterval] + intervals\\n\\t\\t\\t\\n        res = []\\n        i = 0\\n        for curr_interval in intervals:\\n            # new interval doesn\\'t overlap\\n            if curr_interval[1] < newInterval[0]:\\n                res.append(curr_interval)\\n            else:\\n                first = min(curr_interval[0], newInterval[0])\\n                last = newInterval[1]\\n                i = intervals.index(curr_interval)\\n\\t\\t\\t\\t\\n                # while new interval overlaps:\\n                while i < len(intervals) and last >= intervals[i][0]:\\n                    last = max(intervals[i][1], newInterval[1])\\n                    i+=1\\n                res.append([first, last])\\n                break\\n\\t\\t\\t\\t\\n        # add the rest\\n        res += intervals[i:]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134823,
                "title": "python-6-lines-easy-to-understand-60-ms-beats-96",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        new, i = [], 0\\n        for i, it in enumerate(intervals):\\n            if newInterval.end < it.start: i -= 1; break\\n            elif it.end < newInterval.start: new += it,\\n            else: newInterval.start, newInterval.end = min(it.start, newInterval.start), max(it.end, newInterval.end)\\n        return new + [newInterval] + intervals[i + 1:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        new, i = [], 0\\n        for i, it in enumerate(intervals):\\n            if newInterval.end < it.start: i -= 1; break\\n            elif it.end < newInterval.start: new += it,\\n            else: newInterval.start, newInterval.end = min(it.start, newInterval.start), max(it.end, newInterval.end)\\n        return new + [newInterval] + intervals[i + 1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21828,
                "title": "my-ac-java-in-place-solution",
                "content": "    public class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            if(intervals.isEmpty()){\\n                intervals.add(newInterval);\\n                return intervals;\\n            }\\n            \\n            int start = newInterval.start;\\n            int end = newInterval.end;\\n            ListIterator<Interval> li = intervals.listIterator();\\n            boolean inserted = false;\\n            while(li.hasNext()){\\n                Interval itv = li.next();\\n                if(start <= itv.end){\\n                    if(end < itv.start){ //newInterval does not overlap with current itv, time to insert\\n                        li.remove();\\n                        li.add(new Interval(start, end));\\n                        li.add(itv);\\n                        inserted = true;\\n                        break;\\n                    }\\n                    \\n                    // still some overlap so compare start & end\\n                    start = Math.min(start, itv.start);\\n                    end = Math.max(end, itv.end);\\n                    li.remove();\\n                }\\n            }\\n            \\n            if(!inserted){\\n                intervals.add(new Interval(start, end));\\n            }\\n            \\n            return intervals;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            if(intervals.isEmpty()){\\n                intervals.add(newInterval);\\n                return intervals;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3057760,
                "title": "java-99th-percentile-one-pass-explained-article",
                "content": "![image.png](https://assets.leetcode.com/users/images/79f9f39a-f625-4707-9c7b-dcbb13533e2b_1673854957.9331577.png)\\n\\n\\n# Intuition\\nWe are given a non-overlapping, sorted intervals array. These properties are essential because we can utilize them to solve the problem in one pass.\\n\\nLet\\'s visualize a few possibilities that we may have. Imagine these given intervals:\\n```\\n    [     ] [ ] [  ]\\n```\\nImagine them on an x-axis line.\\n\\nWe may need to insert the following intervals:\\n```\\n    [     ] [ ] [  ]\\n |           |   \\n\\n | |\\n                         | |\\n\\n```\\n\\nThese are three situations where we may need to insert a new interval.\\n\\nThe first one overlaps multiple given intervals, the second one doesn\\'t overlap and should be inserted in the beginning, and the last is non-overlapping and should be inserted in the end.\\n\\nWe either need to *merge* the interval with one of the given intervals (or multiple), or insert it.\\n\\n*If we merge an interval, we don\\'t impact the intervals previously added*, because they are sorted. `nextIntervalEnd > previousStart`, which is always true because of non-overlapping sorted property.\\n\\nTherefore we need to merge intervals *until* we find an interval that started after the merged interval.\\n\\nIf the given interval doesn\\'t overlap with the merged interval, we simply add it to the result array.\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> mergedIntervals = new ArrayList<>();\\n        int[] merged = new int[] {newInterval[0], newInterval[1]};\\n        boolean isInserted = false;\\n\\n        for (int[] interval : intervals) {\\n            if(interval[0] > merged[1]) {\\n                if(!isInserted) {\\n                    mergedIntervals.add(merged);\\n                    isInserted = true;\\n                }\\n                mergedIntervals.add(interval);\\n                \\n            } else {\\n                // does intersect\\n                if(doesIntersect(merged, interval)) {\\n                    merged[0] = Math.min(merged[0], interval[0]);\\n                    merged[1] = Math.max(merged[1], interval[1]);\\n                } else {\\n                    // not intersecting\\n                    mergedIntervals.add(interval);\\n                }\\n                \\n                \\n            }\\n        }\\n\\n        // new interval is at the end\\n        if(!isInserted) {\\n            mergedIntervals.add(merged);\\n            isInserted = true;\\n        }\\n\\n        // Java specific to copy to arr[][]...\\n        int[][] res = new int[mergedIntervals.size()][2];\\n        for(int i = 0; i < mergedIntervals.size(); i++) {\\n            res[i] = mergedIntervals.get(i);\\n        }\\n        return res;\\n\\n    }\\n\\n    private boolean doesIntersect(int[] intervalA, int[] intervalB) {\\n        return intervalA[0] <= intervalB[1] && intervalB[0] <= intervalA[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    [     ] [ ] [  ]\\n```\n```\\n    [     ] [ ] [  ]\\n |           |   \\n\\n | |\\n                         | |\\n\\n```\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> mergedIntervals = new ArrayList<>();\\n        int[] merged = new int[] {newInterval[0], newInterval[1]};\\n        boolean isInserted = false;\\n\\n        for (int[] interval : intervals) {\\n            if(interval[0] > merged[1]) {\\n                if(!isInserted) {\\n                    mergedIntervals.add(merged);\\n                    isInserted = true;\\n                }\\n                mergedIntervals.add(interval);\\n                \\n            } else {\\n                // does intersect\\n                if(doesIntersect(merged, interval)) {\\n                    merged[0] = Math.min(merged[0], interval[0]);\\n                    merged[1] = Math.max(merged[1], interval[1]);\\n                } else {\\n                    // not intersecting\\n                    mergedIntervals.add(interval);\\n                }\\n                \\n                \\n            }\\n        }\\n\\n        // new interval is at the end\\n        if(!isInserted) {\\n            mergedIntervals.add(merged);\\n            isInserted = true;\\n        }\\n\\n        // Java specific to copy to arr[][]...\\n        int[][] res = new int[mergedIntervals.size()][2];\\n        for(int i = 0; i < mergedIntervals.size(); i++) {\\n            res[i] = mergedIntervals.get(i);\\n        }\\n        return res;\\n\\n    }\\n\\n    private boolean doesIntersect(int[] intervalA, int[] intervalB) {\\n        return intervalA[0] <= intervalB[1] && intervalB[0] <= intervalA[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643451,
                "title": "explained-simple-and-clear-python3-code",
                "content": "\\n# Approach\\nThe solution follows the logic of iterating through the intervals to find the correct position to insert the new interval while maintaining the sorted order. After insertion, it iterates over the modified array to merge any overlapping intervals by updating the end time of the previous interval if necessary. Finally, it returns the modified array with the new interval inserted and any overlapping intervals merged.\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, inv: List[List[int]], nw: List[int]) -> List[List[int]]:\\n        #insert nw\\n        test=True\\n        for i in range(len(inv)):\\n            if inv[i][0]>nw[0]:\\n                test=False\\n                inv.insert(i,nw)\\n        if test:\\n            inv.append(nw)\\n\\n        i=1\\n        while i<len(inv):\\n            if inv[i-1][1]>=inv[i][0]:\\n                inv[i-1][1]=max (inv[i-1][1],inv[i][1])\\n                inv.pop(i)\\n            else:\\n                i+=1\\n            \\n        return inv\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, inv: List[List[int]], nw: List[int]) -> List[List[int]]:\\n        #insert nw\\n        test=True\\n        for i in range(len(inv)):\\n            if inv[i][0]>nw[0]:\\n                test=False\\n                inv.insert(i,nw)\\n        if test:\\n            inv.append(nw)\\n\\n        i=1\\n        while i<len(inv):\\n            if inv[i-1][1]>=inv[i][0]:\\n                inv[i-1][1]=max (inv[i-1][1],inv[i][1])\\n                inv.pop(i)\\n            else:\\n                i+=1\\n            \\n        return inv\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056720,
                "title": "java-short-beats-99-26-priorityqueue",
                "content": "# One Pass (Beats 99.26%) : Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        /*  \\n            Test Case 1.\\n            newInterval : [2,5]\\n            intervals : [[1,3],[6,9]]\\n                                 ^\\n        */\\n        for (int[] interval : intervals) {\\n            if (interval[1] < newInterval[0]) {\\n                list.add(interval);\\n\\n                // second interval[1] =>  [6, 9] > [1, 5]\\n            } else if (interval[0] > newInterval[1]) {\\n                list.add(new int[] {newInterval[0], newInterval[1]}); // added (1,5)\\n                newInterval = interval; // (6,9)\\n\\n                // first interval[0] => [1, 3] >= [2,5]\\n            } else if (interval[1] >= newInterval[0]) {\\n                // newInterval = [1, 5]\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        list.add(newInterval); // added (6, 9) => list: [(1, 5), (6, 9)]\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\n# PriorityQueue : Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        for (int[] interval : intervals) pq.add(interval);\\n        pq.add(newInterval);\\n        \\n        List<int[]> res = new ArrayList<>(); \\n        int[] prev = pq.poll();        \\n        while (!pq.isEmpty()) {             \\n            int[] cur = pq.poll();\\n            if (prev[1] >= cur[0]) {\\n                prev = new int[]{prev[0], Math.max(cur[1], prev[1])};\\n            } else {\\n                res.add(prev);\\n                prev = cur;\\n            }\\n        }\\n        res.add(prev);       \\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        /*  \\n            Test Case 1.\\n            newInterval : [2,5]\\n            intervals : [[1,3],[6,9]]\\n                                 ^\\n        */\\n        for (int[] interval : intervals) {\\n            if (interval[1] < newInterval[0]) {\\n                list.add(interval);\\n\\n                // second interval[1] =>  [6, 9] > [1, 5]\\n            } else if (interval[0] > newInterval[1]) {\\n                list.add(new int[] {newInterval[0], newInterval[1]}); // added (1,5)\\n                newInterval = interval; // (6,9)\\n\\n                // first interval[0] => [1, 3] >= [2,5]\\n            } else if (interval[1] >= newInterval[0]) {\\n                // newInterval = [1, 5]\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        list.add(newInterval); // added (6, 9) => list: [(1, 5), (6, 9)]\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        for (int[] interval : intervals) pq.add(interval);\\n        pq.add(newInterval);\\n        \\n        List<int[]> res = new ArrayList<>(); \\n        int[] prev = pq.poll();        \\n        while (!pq.isEmpty()) {             \\n            int[] cur = pq.poll();\\n            if (prev[1] >= cur[0]) {\\n                prev = new int[]{prev[0], Math.max(cur[1], prev[1])};\\n            } else {\\n                res.add(prev);\\n                prev = cur;\\n            }\\n        }\\n        res.add(prev);       \\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038557,
                "title": "java-greedy",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for(int[] in: intervals){\\n            if(in[1] < newInterval[0]){\\n                ans.add(in);\\n            }\\n            else if(in[0] > newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = in;\\n            }\\n            else{\\n                newInterval[0] = Math.min(newInterval[0], in[0]);\\n                newInterval[1] = Math.max(newInterval[1], in[1]);\\n            }\\n        }\\n        \\n        ans.add(newInterval);\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for(int[] in: intervals){\\n            if(in[1] < newInterval[0]){\\n                ans.add(in);\\n            }\\n            else if(in[0] > newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = in;\\n            }\\n            else{\\n                newInterval[0] = Math.min(newInterval[0], in[0]);\\n                newInterval[1] = Math.max(newInterval[1], in[1]);\\n            }\\n        }\\n        \\n        ans.add(newInterval);\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804462,
                "title": "java-99-solution-one-pass-o-n-with-comments",
                "content": "\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> l = new ArrayList<>();\\n        // 1. if an interval end before newInterval start, it can be added to output directly.\\n        // 2. if an interval overlapping with new Interval, merge it into new Interval. overlapping if an interval end after new Interval start and start before new Interval end.\\n        // 3  after all overlapping intervals processed, add the merged new Interval (or the original new interval if no interval meet #2 condition, i.e. no overlap)\\n        // 4. add the rest non overlapping intervals. all the rest have start after new interval end.\\n        \\n        int i = 0, N = intervals.length;\\n        while (i < N && intervals[i][1] < newInterval[0]) // #1\\n            l.add(intervals[i++]);\\n        \\n        while (i < N && intervals[i][0] <= newInterval[1]) { // #2\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i++][1]);\\n        }\\n        \\n        l.add(newInterval); // #3       \\n        while (i < N) l.add(intervals[i++]);  // #4\\n        return l.toArray(new int[][]{});\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> l = new ArrayList<>();\\n        // 1. if an interval end before newInterval start, it can be added to output directly.\\n        // 2. if an interval overlapping with new Interval, merge it into new Interval. overlapping if an interval end after new Interval start and start before new Interval end.\\n        // 3  after all overlapping intervals processed, add the merged new Interval (or the original new interval if no interval meet #2 condition, i.e. no overlap)\\n        // 4. add the rest non overlapping intervals. all the rest have start after new interval end.\\n        \\n        int i = 0, N = intervals.length;\\n        while (i < N && intervals[i][1] < newInterval[0]) // #1\\n            l.add(intervals[i++]);\\n        \\n        while (i < N && intervals[i][0] <= newInterval[1]) { // #2\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i++][1]);\\n        }\\n        \\n        l.add(newInterval); // #3       \\n        while (i < N) l.add(intervals[i++]);  // #4\\n        return l.toArray(new int[][]{});\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 703958,
                "title": "javascript-explanation",
                "content": "* append new interval to list of intervals\\n* sort by beg time\\n* then do merge intervals \\n\\n(I know sorting will raise time to O(nlogn) and there are some solutions out there that yield O(n))\\n\\n```javascript\\nconst insert = (intervals, newInterval) => {\\n    if(!intervals) return [];\\n    const ans = new Array();\\n    \\n    intervals.push(newInterval);\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    if(intervals.length === 1) return intervals;\\n    const prev = [intervals[0][0], intervals[0][1]];\\n    for(let i = 1; i < intervals.length; i++) {\\n        const curr = intervals[i];\\n        if(isOverlap(prev, curr)) {\\n            prev[0] = Math.min(prev[0], curr[0]);\\n            prev[1] = Math.max(prev[1], curr[1]);\\n        } else {\\n            ans.push([...prev]);\\n            prev[0] = curr[0];\\n            prev[1] = curr[1];\\n        }\\n        \\n        if(i === intervals.length - 1) ans.push([...prev])\\n    }\\n    \\n    return ans;\\n};\\n\\nconst isOverlap = (prev, curr) => {\\n    return  prev[1] >= curr[0] && prev[1] <= curr[1]\\n            || prev[0] >= curr[0] && prev[0] <= curr[1]\\n            || prev[0] <= curr[0] && prev[1] >= curr[1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst insert = (intervals, newInterval) => {\\n    if(!intervals) return [];\\n    const ans = new Array();\\n    \\n    intervals.push(newInterval);\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    if(intervals.length === 1) return intervals;\\n    const prev = [intervals[0][0], intervals[0][1]];\\n    for(let i = 1; i < intervals.length; i++) {\\n        const curr = intervals[i];\\n        if(isOverlap(prev, curr)) {\\n            prev[0] = Math.min(prev[0], curr[0]);\\n            prev[1] = Math.max(prev[1], curr[1]);\\n        } else {\\n            ans.push([...prev]);\\n            prev[0] = curr[0];\\n            prev[1] = curr[1];\\n        }\\n        \\n        if(i === intervals.length - 1) ans.push([...prev])\\n    }\\n    \\n    return ans;\\n};\\n\\nconst isOverlap = (prev, curr) => {\\n    return  prev[1] >= curr[0] && prev[1] <= curr[1]\\n            || prev[0] >= curr[0] && prev[0] <= curr[1]\\n            || prev[0] <= curr[0] && prev[1] >= curr[1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21813,
                "title": "short-simple-o-n-in-place-java-solution-with-explanation",
                "content": "The idea is to look at each interval in the list. If it intersects with newInterval then merge it to newInterval and delete it. In the end add newInterval back to its corresponding place.\\n\\n    public class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            ListIterator<Interval> i = intervals.listIterator();\\n            Interval in;\\n            while (i.hasNext()) {\\n                in = i.next();\\n                if (newInterval.end < in.start) {\\n                    i.previous();\\n                    break;\\n                }\\n                if (in.start <= newInterval.end && newInterval.start <= in.end) {\\n                    newInterval.start = Math.min(newInterval.start, in.start);\\n                    newInterval.end = Math.max(newInterval.end, in.end);\\n                    i.previous();\\n                    i.remove();\\n                }\\n            }\\n            i.add(newInterval);\\n            return intervals;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            ListIterator<Interval> i = intervals.listIterator();\\n            Interval in;\\n            while (i.hasNext()) {\\n                in = i.next();\\n                if (newInterval.end < in.start) {\\n                    i.previous();\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3992539,
                "title": "best-solution-in-c-100-easily-understandable",
                "content": "# Approach\\nExplained in the code using comments\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n\\n        //sort using the same logic as Merge Intervals question\\n        sort(intervals.begin(), intervals.end()); \\n\\n        for(auto it: intervals)\\n        {\\n            //if interval before is smaller add that\\n            if(it[1] < newInterval[0]) \\n                ans.push_back(it);\\n\\n            //if the newInterval is smaller add that\\n            else if(newInterval[1] < it[0]) \\n            {\\n                ans.push_back(newInterval);\\n                newInterval = it;\\n            }\\n            \\n            //if newInterval lies within the currentIntervals\\n            else \\n            {\\n                newInterval[0] = min(newInterval[0], it[0]);\\n                newInterval[1] = max(newInterval[1], it[1]);\\n            } \\n        }\\n\\n        //add the last Interval\\n        ans.push_back(newInterval);\\n\\n        return ans;                                                                          \\n    }\\n};\\n```\\n\\n![pleaseupvotye.jpeg](https://assets.leetcode.com/users/images/e1cd0d4f-0255-4afa-8f6e-b5fff843647b_1693664013.5913265.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n\\n        //sort using the same logic as Merge Intervals question\\n        sort(intervals.begin(), intervals.end()); \\n\\n        for(auto it: intervals)\\n        {\\n            //if interval before is smaller add that\\n            if(it[1] < newInterval[0]) \\n                ans.push_back(it);\\n\\n            //if the newInterval is smaller add that\\n            else if(newInterval[1] < it[0]) \\n            {\\n                ans.push_back(newInterval);\\n                newInterval = it;\\n            }\\n            \\n            //if newInterval lies within the currentIntervals\\n            else \\n            {\\n                newInterval[0] = min(newInterval[0], it[0]);\\n                newInterval[1] = max(newInterval[1], it[1]);\\n            } \\n        }\\n\\n        //add the last Interval\\n        ans.push_back(newInterval);\\n\\n        return ans;                                                                          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057457,
                "title": "simple-c-beats-99-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all if we think of approach so we can do this by using linear search or Binary search . So we know  Bianry search has logn timpecomplexity but through binary search we find where to insert in logn but we have to merge with others and insert also that will take O(n) so there is no need of binary search we can do a linear serach as well beacuse both will be O(n).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nComing to Approach first we can think of many conditions but We only need to check three conditions that are :\\n- Insert those intervals who are not overlapping and are less than our new Interval \\n- Now check if our new Interval is overalpping wiht any other interval(s) so either insert if not overlapping or merge if overallping with others\\n- Now insert those who are left i.e those intervals which are greater than new Interval\\n*These condtions can easily be checked using a while loop*\\nFor second condition when the inertvals are overlapping we can do that by :\\n` (a,b)  and (c,d) the  new interval: [min(a,c),max(b,d)]`\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inv, vector<int>& newI) {\\n       vector<vector<int>>ans;\\n       int n=inv.size();\\n        int i=0;\\n        // insert those intervals which are not overlapping and less than newInterval\\n       while(i<n and inv[i][1]<newI[0]){\\n           ans.push_back(inv[i++]);\\n       }\\n       // now insert the new Interval or merge the interval if neccessary\\n\\n       while(i<n and newI[1]>=inv[i][0]){\\n           newI[0]=min(newI[0],inv[i][0]);\\n           newI[1]=max(newI[1],inv[i][1]);\\n           i++;\\n       }\\n       ans.push_back(newI);\\n      // insert thse intervals which are left or greater than the newInterval\\n      while(i<n ){\\n          ans.push_back(inv[i++]);\\n      }\\n       return ans; \\n    }\\n};\\n```\\n**Please upVote If Found HelpFull \\uD83D\\uDD3C**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inv, vector<int>& newI) {\\n       vector<vector<int>>ans;\\n       int n=inv.size();\\n        int i=0;\\n        // insert those intervals which are not overlapping and less than newInterval\\n       while(i<n and inv[i][1]<newI[0]){\\n           ans.push_back(inv[i++]);\\n       }\\n       // now insert the new Interval or merge the interval if neccessary\\n\\n       while(i<n and newI[1]>=inv[i][0]){\\n           newI[0]=min(newI[0],inv[i][0]);\\n           newI[1]=max(newI[1],inv[i][1]);\\n           i++;\\n       }\\n       ans.push_back(newI);\\n      // insert thse intervals which are left or greater than the newInterval\\n      while(i<n ){\\n          ans.push_back(inv[i++]);\\n      }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681746,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let result = []\\n    \\n    for(let i = 0; i < intervals.length; i++){\\n        //not overlapping with current interval\\n        if(newInterval[1] < intervals[i][0]){\\n            result.push(newInterval)\\n            result.push(...intervals.slice(i))\\n            return result\\n        }else if(newInterval[0] > intervals[i][1]){\\n            result.push(intervals[i])\\n        }else{\\n            //is overlapping with current interval\\n            newInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]\\n            //extend interval if needed\\n        }\\n    }\\n    result.push(newInterval)\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let result = []\\n    \\n    for(let i = 0; i < intervals.length; i++){\\n        //not overlapping with current interval\\n        if(newInterval[1] < intervals[i][0]){\\n            result.push(newInterval)\\n            result.push(...intervals.slice(i))\\n            return result\\n        }else if(newInterval[0] > intervals[i][1]){\\n            result.push(intervals[i])\\n        }else{\\n            //is overlapping with current interval\\n            newInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]\\n            //extend interval if needed\\n        }\\n    }\\n    result.push(newInterval)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581680,
                "title": "python-easy-solution-two-approaches",
                "content": "\\t# 1st Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\tintervals.append(newInterval)\\n\\t\\t\\tintervals.sort(key=lambda x: x[0])\\n\\t\\t\\tstart = intervals[0][0]\\n\\t\\t\\tend = intervals[0][1]\\n\\t\\t\\ti = 1\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tif intervals[i][0] <= end:\\n\\t\\t\\t\\t\\tend = max(end, intervals[i][1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append([start, end])\\n\\t\\t\\t\\t\\tstart = intervals[i][0]\\n\\t\\t\\t\\t\\tend = intervals[i][1]\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append([start, end])\\n\\t\\t\\treturn res\\n\\n\\t# 2nd Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\ti = 0\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals) and intervals[i][1] < newInterval[0]:\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\twhile i < len(intervals) and intervals[i][0] <= newInterval[1]:\\n\\t\\t\\t\\tnewInterval[0] = min(intervals[i][0], newInterval[0])\\n\\t\\t\\t\\tnewInterval[1] = max(intervals[i][1], newInterval[1])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append(newInterval)\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# 1st Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\tintervals.append(newInterval)\\n\\t\\t\\tintervals.sort(key=lambda x: x[0])\\n\\t\\t\\tstart = intervals[0][0]\\n\\t\\t\\tend = intervals[0][1]\\n\\t\\t\\ti = 1\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tif intervals[i][0] <= end:\\n\\t\\t\\t\\t\\tend = max(end, intervals[i][1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append([start, end])\\n\\t\\t\\t\\t\\tstart = intervals[i][0]\\n\\t\\t\\t\\t\\tend = intervals[i][1]\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append([start, end])\\n\\t\\t\\treturn res\\n\\n\\t# 2nd Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\ti = 0\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals) and intervals[i][1] < newInterval[0]:\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\twhile i < len(intervals) and intervals[i][0] <= newInterval[1]:\\n\\t\\t\\t\\tnewInterval[0] = min(intervals[i][0], newInterval[0])\\n\\t\\t\\t\\tnewInterval[1] = max(intervals[i][1], newInterval[1])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append(newInterval)\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1506902,
                "title": "java-easy-to-understand-o-n-code-with-comments",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Handling edge case when intervals is empty\\n        if(intervals.length == 0){\\n            if(newInterval.length != 0)\\n                result.add(newInterval);\\n            return result.toArray(new int[result.size()][]);\\n        }\\n        \\n        int i=0;\\n        \\n        // 1. Copy until overlap is not found\\n        while(i < intervals.length && newInterval[0] > intervals[i][1])\\n            result.add(intervals[i++]);\\n        \\n        // 2. Update newInterval by comparing it with overlapped intervals\\n        while(i < intervals.length && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        \\n        // 3. Add the updated newInterval\\n        result.add(newInterval);\\n        \\n        // 4. Copy the remaining in the intervals list to the final result\\n        while(i < intervals.length)\\n            result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Handling edge case when intervals is empty\\n        if(intervals.length == 0){\\n            if(newInterval.length != 0)\\n                result.add(newInterval);\\n            return result.toArray(new int[result.size()][]);\\n        }\\n        \\n        int i=0;\\n        \\n        // 1. Copy until overlap is not found\\n        while(i < intervals.length && newInterval[0] > intervals[i][1])\\n            result.add(intervals[i++]);\\n        \\n        // 2. Update newInterval by comparing it with overlapped intervals\\n        while(i < intervals.length && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        \\n        // 3. Add the updated newInterval\\n        result.add(newInterval);\\n        \\n        // 4. Copy the remaining in the intervals list to the final result\\n        while(i < intervals.length)\\n            result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261009,
                "title": "zero-bullshit-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 844384,
                "title": "java-greedily-absorb-overlapping-intervals-o-n-time-o-1-extra-space-explained",
                "content": "```\\n\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        \\n        int i=0;\\n\\t\\t/* Add all intervals ending earlier than the start of newInterval */\\n        while(i < intervals.length && intervals[i][1] < newInterval[0]){\\n            result.add(intervals[i++]);\\n        }\\n        \\n\\t\\t/* Greedily absorb any interval that overlaps with newInterval */\\n        while(i < intervals.length && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n\\t\\t/* Add newInterval to the result list */\\n        result.add(newInterval);\\n\\t\\t\\n\\t\\t/* Add any remaining intervals. These start later than the end\\n\\t\\t   time of newInterval */\\n        while(i < intervals.length) result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        \\n        int i=0;\\n\\t\\t/* Add all intervals ending earlier than the start of newInterval */\\n        while(i < intervals.length && intervals[i][1] < newInterval[0]){\\n            result.add(intervals[i++]);\\n        }\\n        \\n\\t\\t/* Greedily absorb any interval that overlaps with newInterval */\\n        while(i < intervals.length && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n\\t\\t/* Add newInterval to the result list */\\n        result.add(newInterval);\\n\\t\\t\\n\\t\\t/* Add any remaining intervals. These start later than the end\\n\\t\\t   time of newInterval */\\n        while(i < intervals.length) result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 530137,
                "title": "hard-problem-c-easy-solution",
                "content": "Not sure why this problem is marked as Hard, it\\'s on the \\'easy\\' side of Easy.\\n```cpp\\nvector<vector<int>> insert(vector<vector<int>>& ints, vector<int>& ni, int i = 0) {\\n    vector<vector<int>> res;\\n    for (; i < ints.size() && ints[i][0] <= ni[1]; ++i) {\\n        if (ints[i][1] < ni[0])\\n            res.push_back(ints[i]);\\n        else {\\n            ni[0] = min(ni[0], ints[i][0]);\\n            ni[1] = max(ni[1], ints[i][1]);\\n        }\\n    }\\n    res.push_back(ni);\\n    res.insert(end(res), begin(ints) + i, end(ints));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<vector<int>> insert(vector<vector<int>>& ints, vector<int>& ni, int i = 0) {\\n    vector<vector<int>> res;\\n    for (; i < ints.size() && ints[i][0] <= ni[1]; ++i) {\\n        if (ints[i][1] < ni[0])\\n            res.push_back(ints[i]);\\n        else {\\n            ni[0] = min(ni[0], ints[i][0]);\\n            ni[1] = max(ni[1], ints[i][1]);\\n        }\\n    }\\n    res.push_back(ni);\\n    res.insert(end(res), begin(ints) + i, end(ints));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 395709,
                "title": "beautiful-rust-solution-o-n-0-ms",
                "content": "As straightforward as possible.\\nAvoided most of heap memory allocation in method.\\n\\n```\\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        use std::cmp::{min, max};\\n        let mut less = vec![];\\n        let mut more = vec![];\\n        let mut start = new_interval[0];\\n        let mut end = new_interval[1];\\n        \\n        for curr in intervals{\\n            if curr[1] < new_interval[0]{\\n                less.push(curr);\\n            }\\n            else if curr[0]>new_interval[1]{\\n                more.push(curr);\\n            }\\n            else {\\n                start = min(curr[0], start);\\n                end = max(curr[1], end);\\n            }\\n        }\\n        less.push(vec![start, end]);\\n        less.append(&mut more);\\n        less\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        use std::cmp::{min, max};\\n        let mut less = vec![];\\n        let mut more = vec![];\\n        let mut start = new_interval[0];\\n        let mut end = new_interval[1];\\n        \\n        for curr in intervals{\\n            if curr[1] < new_interval[0]{\\n                less.push(curr);\\n            }\\n            else if curr[0]>new_interval[1]{\\n                more.push(curr);\\n            }\\n            else {\\n                start = min(curr[0], start);\\n                end = max(curr[1], end);\\n            }\\n        }\\n        less.push(vec![start, end]);\\n        less.append(&mut more);\\n        less\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289422,
                "title": "simple-java-solution-with-new-signature-1ms",
                "content": "```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        for (int[] interval : intervals) {\\n\\t\\t   // If not overlapped, we always add the smaller one to the result and point newInterval to the larger one.\\n            if (newInterval[1] < interval[0]) {\\n                result.add(newInterval);\\n                newInterval = interval;\\n            } else if (newInterval[0] > interval[1]) {\\n                result.add(interval);\\n            } else {\\n\\t\\t\\t// If overlapped, update the newInterval\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        result.add(newInterval);\\n        return result.toArray(new int[][]{});\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        for (int[] interval : intervals) {\\n\\t\\t   // If not overlapped, we always add the smaller one to the result and point newInterval to the larger one.\\n            if (newInterval[1] < interval[0]) {\\n                result.add(newInterval);\\n                newInterval = interval;\\n            } else if (newInterval[0] > interval[1]) {\\n                result.add(interval);\\n            } else {\\n\\t\\t\\t// If overlapped, update the newInterval\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        result.add(newInterval);\\n        return result.toArray(new int[][]{});\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21595,
                "title": "c-clean-code",
                "content": "**Steps**\\n1. add all intervals smaller than newitv to the new array\\n2. merge all intervals overlap with newitv, then add the merged interval to the new array;\\n3. add all intervals that is leftover (no overlap) into the new array;\\n```\\nclass Solution {\\npublic:\\n    vector<Interval> insert(vector<Interval>& a, Interval newitv) {\\n        vector<Interval> res;\\n        int i = 0;\\n        for (; i < a.size() && a[i].end < newitv.start; i++) res.push_back(a[i]);\\n        \\n        for (; i < a.size() && max(a[i].start, newitv.start) <= min(a[i].end, newitv.end); i++) {\\n            newitv.start = min(a[i].start, newitv.start);\\n            newitv.end = max(a[i].end, newitv.end);\\n        }\\n        res.push_back(newitv);\\n\\n        for (; i < a.size(); i++) res.push_back(a[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<Interval> insert(vector<Interval>& a, Interval newitv) {\\n        vector<Interval> res;\\n        int i = 0;\\n        for (; i < a.size() && a[i].end < newitv.start; i++) res.push_back(a[i]);\\n        \\n        for (; i < a.size() && max(a[i].start, newitv.start) <= min(a[i].end, newitv.end); i++) {\\n            newitv.start = min(a[i].start, newitv.start);\\n            newitv.end = max(a[i].end, newitv.end);\\n        }\\n        res.push_back(newitv);\\n\\n        for (; i < a.size(); i++) res.push_back(a[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21776,
                "title": "my-18ms-c-code-with-explanation",
                "content": "        class Solution {\\n    public:\\n      std::vector<Interval> insert(std::vector<Interval> &intervals, Interval newInterval) {\\n    \\n        auto partial_order =[](const Interval & a, const Interval & b){\\n          return a.end < b.start;\\n        };\\n    \\n        auto less = std::lower_bound(intervals.begin(), intervals.end(), newInterval, partial_order);\\n    \\n        auto greater = std::upper_bound(intervals.begin(), intervals.end(), newInterval, partial_order);\\n        //printf(\"The index position: %d %d\\\\n\", less - intervals.begin(), greater - intervals.begin());\\n        std::vector<Interval> answer; \\n    \\n        answer.insert(answer.end(), intervals.begin(), less);\\n        answer.push_back(mergeEqual(less, greater, newInterval));\\n        answer.insert(answer.end(), greater, intervals.end());\\n        return answer;\\n      }\\n    \\n    private:\\n    \\n      // Merge the new interval with an array of intervals, all intervals in the \\n      // array equal with the new interval in terms of the partial order we \\n      // defined.\\n      // In other words all of them are overlapped with the new interval.\\n    \\n      Interval mergeEqual(const std::vector<Interval>::iterator & first, const std::vector<Interval>::iterator & last, const Interval &target){\\n    \\n        Interval answer(target);\\n        if(first < last){\\n          answer = merge(answer, *first);\\n          answer = merge(answer, *(last-1));\\n        }\\n        return answer;\\n      }\\n      // Merge two overlapped intervals.\\n      Interval merge(const Interval & a, const Interval & b) {\\n        return Interval(std::min(a.start, b.start), std::max(a.end, b.end));\\n      }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n      std::vector<Interval> insert(std::vector<Interval> &intervals, Interval newInterval) {\\n    \\n        auto partial_order =[](const Interval & a, const Interval & b){\\n          return a.end < b.start;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21844,
                "title": "concise-solution-using-stl",
                "content": "use lower_bound find the left and right bound of newinterval, step back or forward if need.\\n\\n\\n    bool comp1(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.start < rhs.start;\\n\\t}\\n\\tbool comp2(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.end < rhs.end;\\n\\t}\\n\\n\\tvector<Interval> insert(vector<Interval> &intervals, Interval newInterval) \\n\\t{\\n\\t\\tvector<Interval>::iterator begin = lower_bound(intervals.begin(), intervals.end(), newInterval, comp1);\\n\\t\\tif(begin != intervals.begin() && (begin - 1)->end >= newInterval.start)\\n\\t\\t{\\n\\t\\t\\t--begin;\\n\\t\\t\\tnewInterval.start = begin->start;\\n\\t\\t}\\n\\n\\t\\tvector<Interval>::iterator end = lower_bound(intervals.begin(), intervals.end(), newInterval, comp2);\\t\\t\\n\\t\\tif(end != intervals.end() && end->start <= newInterval.end)\\n\\t\\t{\\n\\t\\t\\tnewInterval.end = end->end;\\n\\t\\t\\t++end;\\t\\t\\t\\n\\t\\t}\\n\\t\\tvector<Interval>::iterator t = intervals.erase(begin, end);\\n\\t\\tintervals.insert(t, newInterval);\\n\\n\\t\\treturn intervals;\\n\\t}",
                "solutionTags": [],
                "code": "use lower_bound find the left and right bound of newinterval, step back or forward if need.\\n\\n\\n    bool comp1(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.start < rhs.start;\\n\\t}\\n\\tbool comp2(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.end < rhs.end;\\n\\t}\\n\\n\\tvector<Interval> insert(vector<Interval> &intervals, Interval newInterval) \\n\\t{\\n\\t\\tvector<Interval>::iterator begin = lower_bound(intervals.begin(), intervals.end(), newInterval, comp1);\\n\\t\\tif(begin != intervals.begin() && (begin - 1)->end >= newInterval.start)\\n\\t\\t{\\n\\t\\t\\t--begin;\\n\\t\\t\\tnewInterval.start = begin->start;\\n\\t\\t}\\n\\n\\t\\tvector<Interval>::iterator end = lower_bound(intervals.begin(), intervals.end(), newInterval, comp2);\\t\\t\\n\\t\\tif(end != intervals.end() && end->start <= newInterval.end)\\n\\t\\t{\\n\\t\\t\\tnewInterval.end = end->end;\\n\\t\\t\\t++end;\\t\\t\\t\\n\\t\\t}\\n\\t\\tvector<Interval>::iterator t = intervals.erase(begin, end);\\n\\t\\tintervals.insert(t, newInterval);\\n\\n\\t\\treturn intervals;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3734438,
                "title": "11-lines-of-clean-and-optimized-code-step-by-step-approach",
                "content": "# Approach:\\nMy approach to solving the problem is as follows:\\n\\n- Initialize an empty array for the left side of the intervals and another empty array for the right side.\\n- Iterate through each interval in the given intervals.\\n- Check if the current interval is completely before the new interval. If so, add it to the left array.\\n- Check if the current interval is completely after the new interval. If so, add it to the right array.\\n- If the current interval overlaps with the new interval, update the new interval\\'s start and end values to cover both intervals.\\n- Finally, combine the left array, the new interval, and the right array to get the result.\\n# Complexity:\\n- Time complexity: The time complexity of this approach is O(n), where n is the number of intervals.\\n- Space complexity: The space complexity is also O(n), where n is the number of intervals.\\n\\n# Code\\n```\\nfunction insert(intervals: number[][], newInterval: number[]): number[][] {\\n    let [newStart, newEnd] = newInterval, left = [], right = [];\\n    for( let int of intervals ){\\n        let [start, end] = int;\\n        if( end < newStart )left.push(int);\\n        else if( start > newEnd )right.push(int);\\n        else {\\n            newStart = Math.min(start, newStart);\\n            newEnd = Math.max(end, newEnd);\\n        }\\n    }\\n    return [...left, [newStart, newEnd], ...right]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\nfunction insert(intervals: number[][], newInterval: number[]): number[][] {\\n    let [newStart, newEnd] = newInterval, left = [], right = [];\\n    for( let int of intervals ){\\n        let [start, end] = int;\\n        if( end < newStart )left.push(int);\\n        else if( start > newEnd )right.push(int);\\n        else {\\n            newStart = Math.min(start, newStart);\\n            newEnd = Math.max(end, newEnd);\\n        }\\n    }\\n    return [...left, [newStart, newEnd], ...right]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467746,
                "title": "awesome-logic-python3",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        list1=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                list1.append(newInterval)\\n                return list1+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                list1.append(intervals[i])\\n            else:\\n                newInterval=[min(newInterval[0],intervals[i][0]),max(intervals[i][1],newInterval[1])]\\n        list1.append(newInterval)\\n        return list1\\n                \\n````\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        list1=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                list1.append(newInterval)\\n                return list1+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                list1.append(intervals[i])\\n            else:\\n                newInterval=[min(newInterval[0],intervals[i][0]),max(intervals[i][1],newInterval[1])]\\n        list1.append(newInterval)\\n        return list1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248191,
                "title": "easy-java-solution-3ms-solved-using-a-single-loop",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int [][] merged = new int[intervals.length+1][];\\n        int c = 0;\\n        for (int []i : intervals) {\\n            merged[c++] = i;\\n        }\\n        merged[intervals.length] = newInterval;\\n        Arrays.sort(merged , (a,b) -> Integer.compare(a[0], b[0]));\\n        List<int []> l1 = new ArrayList<>();\\n        for(int [] arr : merged){\\n            if(l1.size() == 0) l1.add(arr);\\n            else{\\n                int [] prevArr = l1.get(l1.size()-1);\\n                if(arr[0] <= prevArr[1]){\\n                    prevArr[1] = Math.max(prevArr[1] , arr[1]);\\n                }\\n                else l1.add(arr);\\n            }\\n        }\\n        return l1.toArray(new int[l1.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int [][] merged = new int[intervals.length+1][];\\n        int c = 0;\\n        for (int []i : intervals) {\\n            merged[c++] = i;\\n        }\\n        merged[intervals.length] = newInterval;\\n        Arrays.sort(merged , (a,b) -> Integer.compare(a[0], b[0]));\\n        List<int []> l1 = new ArrayList<>();\\n        for(int [] arr : merged){\\n            if(l1.size() == 0) l1.add(arr);\\n            else{\\n                int [] prevArr = l1.get(l1.size()-1);\\n                if(arr[0] <= prevArr[1]){\\n                    prevArr[1] = Math.max(prevArr[1] , arr[1]);\\n                }\\n                else l1.add(arr);\\n            }\\n        }\\n        return l1.toArray(new int[l1.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057348,
                "title": "c-same-logic-of-merge-intervals-2-pointers-comments-added",
                "content": "### Merge Interval Problem\\n### https://leetcode.com/problems/merge-intervals/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        // just remember the merge intervals problem\\n        // try to change this problem into that\\n        \\n        // add newInterval to the intervals\\n        intervals.push_back(newInterval);\\n        \\n        // now sort this\\n        sort(intervals.begin(),intervals.end());\\n        \\n        // now use the same logic that we used in merge intervals\\n        vector<vector<int>> ans;\\n        int n = intervals.size();\\n        int i=0,j=1;                                // using 2 pointers\\n        ans.push_back(intervals[i]);                // very first interval\\n        \\n        while(j<n)\\n        {\\n            // if my new interval is not overalpping with previous one then just add this\\n            if(intervals[j][0]>ans[i][1])\\n            {\\n                i++;                                // move previous pointer\\n                ans.push_back(intervals[j]);\\n            }\\n            // if it is overlapping then update prev second by curr second\\n            else\\n            {\\n                ans[i][1] = max(ans[i][1],intervals[j][1]);\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        // just remember the merge intervals problem\\n        // try to change this problem into that\\n        \\n        // add newInterval to the intervals\\n        intervals.push_back(newInterval);\\n        \\n        // now sort this\\n        sort(intervals.begin(),intervals.end());\\n        \\n        // now use the same logic that we used in merge intervals\\n        vector<vector<int>> ans;\\n        int n = intervals.size();\\n        int i=0,j=1;                                // using 2 pointers\\n        ans.push_back(intervals[i]);                // very first interval\\n        \\n        while(j<n)\\n        {\\n            // if my new interval is not overalpping with previous one then just add this\\n            if(intervals[j][0]>ans[i][1])\\n            {\\n                i++;                                // move previous pointer\\n                ans.push_back(intervals[j]);\\n            }\\n            // if it is overlapping then update prev second by curr second\\n            else\\n            {\\n                ans[i][1] = max(ans[i][1],intervals[j][1]);\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057029,
                "title": "c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ (not considering answer array)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        bool inserted = false;\\n        for (int i = 0; i < intervals.size(); i++) {\\n            // current interval can be merged with last ans interval\\n            int siz = ans.size();\\n            if (siz != 0 && ans[siz - 1][1] >= intervals[i][0]) {\\n                ans[siz - 1][1] = max(ans[siz - 1][1], intervals[i][1]);\\n                continue;\\n            }\\n            // newInterval complete dis-joint with current interval\\n            if (intervals[i][1] < newInterval[0]) {\\n                ans.push_back(intervals[i]);\\n                continue;\\n            }\\n            if (intervals[i][0] > newInterval[1]) {\\n                if (!inserted) ans.push_back(newInterval);\\n                ans.push_back(intervals[i]);\\n                inserted = true;\\n                continue;\\n            }\\n\\n            // newInterval overlapping with current interval\\n            ans.push_back({min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])});\\n            inserted = true;\\n        }\\n        // still not inserted\\n        if (!inserted) ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        bool inserted = false;\\n        for (int i = 0; i < intervals.size(); i++) {\\n            // current interval can be merged with last ans interval\\n            int siz = ans.size();\\n            if (siz != 0 && ans[siz - 1][1] >= intervals[i][0]) {\\n                ans[siz - 1][1] = max(ans[siz - 1][1], intervals[i][1]);\\n                continue;\\n            }\\n            // newInterval complete dis-joint with current interval\\n            if (intervals[i][1] < newInterval[0]) {\\n                ans.push_back(intervals[i]);\\n                continue;\\n            }\\n            if (intervals[i][0] > newInterval[1]) {\\n                if (!inserted) ans.push_back(newInterval);\\n                ans.push_back(intervals[i]);\\n                inserted = true;\\n                continue;\\n            }\\n\\n            // newInterval overlapping with current interval\\n            ans.push_back({min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])});\\n            inserted = true;\\n        }\\n        // still not inserted\\n        if (!inserted) ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056927,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n      List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n         for (int i = 0; i < intervals.length; i ++) {\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n      List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n         for (int i = 0; i < intervals.length; i ++) {\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056577,
                "title": "python-o-n-beats-90-easy",
                "content": "**if you like the solution -- Please vote this code**\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ans=[]\\n        i=0\\n        \\n        while i<len(intervals) and newInterval[0]>intervals[i][1]:\\n            ans.append(intervals[i])\\n            i+=1\\n            \\n        while i<len(intervals) and intervals[i][0]<=newInterval[1]:\\n            newInterval[0]=min(intervals[i][0],newInterval[0])\\n            newInterval[1]=max(intervals[i][1],newInterval[1])\\n            i+=1\\n        ans.append(newInterval)\\n        \\n        while i<len(intervals):\\n            ans.append(intervals[i])\\n            i+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ans=[]\\n        i=0\\n        \\n        while i<len(intervals) and newInterval[0]>intervals[i][1]:\\n            ans.append(intervals[i])\\n            i+=1\\n            \\n        while i<len(intervals) and intervals[i][0]<=newInterval[1]:\\n            newInterval[0]=min(intervals[i][0],newInterval[0])\\n            newInterval[1]=max(intervals[i][1],newInterval[1])\\n            i+=1\\n        ans.append(newInterval)\\n        \\n        while i<len(intervals):\\n            ans.append(intervals[i])\\n            i+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733979,
                "title": "javascript-solution-based-on-merge-intervals",
                "content": "This solution is written based on the solution to **Merge Intervals** https://leetcode.com/problems/merge-intervals/\\n\\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\n var insert = function(intervals, newInterval) {\\n    const n = intervals.length\\n    // insert interval based on newInterval[0]\\n\\t// note: can be improved by using binary search\\n    let idx = 0\\n    \\n    while (idx < n) {\\n        if (intervals[idx][0] >= newInterval[0]) {\\n            break\\n        }\\n        idx++\\n    }\\n    \\n    intervals.splice(idx, 0, newInterval)\\n    \\n    // after the newInterval is inserted\\n\\t// we need to handle overlapping intervals\\n    let i = 0\\n    \\n\\t// run until i is the last index on intervals\\n    while (i < intervals.length - 1) {\\n       \\n\\t   // does not overlap\\n\\t   if (intervals[i][1] < intervals[i+1][0]) {\\n            i++\\n            continue\\n        }\\n        \\n\\t\\t// overlap\\n        intervals[i][1] = Math.max(intervals[i+1][1], intervals[i][1])\\n        \\n\\t\\t// intervals[i] has absorbed intervals[i+1]\\n\\t\\t// remove intervals[i+1]\\n        intervals.splice(i+1,1)\\n    }\\n    \\n    return intervals\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\n var insert = function(intervals, newInterval) {\\n    const n = intervals.length\\n    // insert interval based on newInterval[0]\\n\\t// note: can be improved by using binary search\\n    let idx = 0\\n    \\n    while (idx < n) {\\n        if (intervals[idx][0] >= newInterval[0]) {\\n            break\\n        }\\n        idx++\\n    }\\n    \\n    intervals.splice(idx, 0, newInterval)\\n    \\n    // after the newInterval is inserted\\n\\t// we need to handle overlapping intervals\\n    let i = 0\\n    \\n\\t// run until i is the last index on intervals\\n    while (i < intervals.length - 1) {\\n       \\n\\t   // does not overlap\\n\\t   if (intervals[i][1] < intervals[i+1][0]) {\\n            i++\\n            continue\\n        }\\n        \\n\\t\\t// overlap\\n        intervals[i][1] = Math.max(intervals[i+1][1], intervals[i][1])\\n        \\n\\t\\t// intervals[i] has absorbed intervals[i+1]\\n\\t\\t// remove intervals[i+1]\\n        intervals.splice(i+1,1)\\n    }\\n    \\n    return intervals\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1319389,
                "title": "python3-1-pass-solution",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        # skip all intervals that are strictly smaller than newInterval\\n        # i.e. interval[1] < newInterval[0]\\n        # after this while loop, `idx` will be the index of first interval that\\'s not strictly smaller than newInterval\\n        idx = 0\\n        while idx < len(intervals) and intervals[idx][1] < newInterval[0]:\\n            idx += 1\\n\\n        for i in range(idx, len(intervals)):\\n            interval = intervals[i]\\n            if interval[0] > newInterval[1]:\\n                # because `intervals` is sorted on start time and is non-overlapping, whenever an interval \\n                # is strictly larger than newInterval, we can skip the rest and return result\\n                return intervals[:idx] + [newInterval] + intervals[i:]\\n            # if interval is not strictly larger than newInterval, we can merge it and update newInterval\\n            newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\\n\\n        return intervals[:idx] + [newInterval]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        # skip all intervals that are strictly smaller than newInterval\\n        # i.e. interval[1] < newInterval[0]\\n        # after this while loop, `idx` will be the index of first interval that\\'s not strictly smaller than newInterval\\n        idx = 0\\n        while idx < len(intervals) and intervals[idx][1] < newInterval[0]:\\n            idx += 1\\n\\n        for i in range(idx, len(intervals)):\\n            interval = intervals[i]\\n            if interval[0] > newInterval[1]:\\n                # because `intervals` is sorted on start time and is non-overlapping, whenever an interval \\n                # is strictly larger than newInterval, we can skip the rest and return result\\n                return intervals[:idx] + [newInterval] + intervals[i:]\\n            # if interval is not strictly larger than newInterval, we can merge it and update newInterval\\n            newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\\n\\n        return intervals[:idx] + [newInterval]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096028,
                "title": "python-easy-solution-with-complete-explanation",
                "content": "The code is pretty staright forward \\nfirstly we are appending the new element in the interval and then sorting the array on ethe basis of first element and that it what lambda x:x[0] is doing. After that we are checking if len< 0 then its empty and returning the new element. Otherwise we are checking for the condtion for merging the intervals. So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index and after this condition is True and the intervals are merged we are just poping out the current i else we will continue till the end.\\n\\n        intervals.append(newInterval)\\n        intervals.sort(key = lambda x:x[0])\\n        print(intervals)\\n        \\n        if len(intervals)<0:\\n            return newInterval\\n        \\n        i = 1\\n\\n        while i < len(intervals):\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n                \\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i)\\n            else:\\n                i+=1\\n                continue\\n                \\n        return intervals\\n\\nUpvote if you find it helful",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The code is pretty staright forward \\nfirstly we are appending the new element in the interval and then sorting the array on ethe basis of first element and that it what lambda x:x[0] is doing. After that we are checking if len< 0 then its empty and returning the new element. Otherwise we are checking for the condtion for merging the intervals. So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index and after this condition is True and the intervals are merged we are just poping out the current i else we will continue till the end.\\n\\n        intervals.append(newInterval)\\n        intervals.sort(key = lambda x:x[0])\\n        print(intervals)\\n        \\n        if len(intervals)<0:\\n            return newInterval\\n        \\n        i = 1\\n\\n        while i < len(intervals):\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n                \\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i)\\n            else:\\n                i+=1\\n                continue\\n                \\n        return intervals\\n\\nUpvote if you find it helful",
                "codeTag": "Python3"
            },
            {
                "id": 741146,
                "title": "swift-simple-steps-o-n-complexity",
                "content": "Time: O(n), Space: O(n)\\n```\\nfunc insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tvar new = newInterval\\n\\tvar index = 0\\n\\n\\t// add the non-conflicting beginning\\n\\twhile index < intervals.count && intervals[index][1] < new[0] {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\t// merge the conflictions\\n\\twhile index < intervals.count && intervals[index][0] <= new[1] {\\n\\t\\tnew[0] = min(intervals[index][0], new[0])\\n\\t\\tnew[1] = max(intervals[index][1], new[1])\\n\\t\\tindex += 1\\n\\t}\\n\\tresult.append(new)\\n\\n\\t// add the rest\\n\\twhile index < intervals.count {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tvar new = newInterval\\n\\tvar index = 0\\n\\n\\t// add the non-conflicting beginning\\n\\twhile index < intervals.count && intervals[index][1] < new[0] {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\t// merge the conflictions\\n\\twhile index < intervals.count && intervals[index][0] <= new[1] {\\n\\t\\tnew[0] = min(intervals[index][0], new[0])\\n\\t\\tnew[1] = max(intervals[index][1], new[1])\\n\\t\\tindex += 1\\n\\t}\\n\\tresult.append(new)\\n\\n\\t// add the rest\\n\\twhile index < intervals.count {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502484,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> resultList = new ArrayList<>();\\n        \\n        for(int[] interval : intervals) {\\n            if(newInterval[0] > interval[1]) {\\n                resultList.add(interval);\\n            }\\n            else if(newInterval[1] < interval[0]) {\\n                resultList.add(newInterval);\\n                newInterval = interval;\\n            }\\n            else {\\n                int[] merged = new int[] {Math.min(newInterval[0], interval[0]), Math.max(newInterval[1], interval[1])};\\n                newInterval = merged;\\n            }\\n        }\\n        resultList.add(newInterval);\\n        \\n        return resultList.toArray(new int[resultList.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> resultList = new ArrayList<>();\\n        \\n        for(int[] interval : intervals) {\\n            if(newInterval[0] > interval[1]) {\\n                resultList.add(interval);\\n            }\\n            else if(newInterval[1] < interval[0]) {\\n                resultList.add(newInterval);\\n                newInterval = interval;\\n            }\\n            else {\\n                int[] merged = new int[] {Math.min(newInterval[0], interval[0]), Math.max(newInterval[1], interval[1])};\\n                newInterval = merged;\\n            }\\n        }\\n        resultList.add(newInterval);\\n        \\n        return resultList.toArray(new int[resultList.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463679,
                "title": "java-10-lines-o-n-1ms",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        for (int[] next: intervals) {\\n            if (next[1]<newInterval[0]) list.add(next);\\n            else if (newInterval[1]<next[0]) {\\n                list.add(newInterval);\\n                newInterval = next;\\n            }\\n            else newInterval = new int[]{Math.min(newInterval[0], next[0]), Math.max(newInterval[1], next[1])};\\n        }\\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        for (int[] next: intervals) {\\n            if (next[1]<newInterval[0]) list.add(next);\\n            else if (newInterval[1]<next[0]) {\\n                list.add(newInterval);\\n                newInterval = next;\\n            }\\n            else newInterval = new int[]{Math.min(newInterval[0], next[0]), Math.max(newInterval[1], next[1])};\\n        }\\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689977,
                "title": "easy-to-understand-c-solution-o-n",
                "content": "# Intution & Approach\\n# Use three loops.\\n1.) Insert all the intervals which are strictly lesser than the new Interval.\\n2.)(When the new interval is overlaping) In second loop maintain a start and end variable and find the start point and end point of interval and insert that interval in resultant vector.\\n3.)When the intervals values are strictly greater than the new interval insert all the intervals till end.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i=0;\\n        bool flag=false;\\n        int start=newInterval[0];;\\n        int end=newInterval[1];\\n// Insert all the intervals which are strictly lesser than the new Interval.\\n        while(i<intervals.size() && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n// Overlapping intervals\\n        while(i<intervals.size() && intervals[i][0]<=newInterval[1])\\n        {\\n            \\n            start=min(intervals[i][0],start);\\n            end=max(intervals[i][1],end);\\n            i++;\\n        }\\n//Strictly Greater intervals\\n        result.push_back({start,end});\\n        while(i<intervals.size())\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n       \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i=0;\\n        bool flag=false;\\n        int start=newInterval[0];;\\n        int end=newInterval[1];\\n// Insert all the intervals which are strictly lesser than the new Interval.\\n        while(i<intervals.size() && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n// Overlapping intervals\\n        while(i<intervals.size() && intervals[i][0]<=newInterval[1])\\n        {\\n            \\n            start=min(intervals[i][0],start);\\n            end=max(intervals[i][1],end);\\n            i++;\\n        }\\n//Strictly Greater intervals\\n        result.push_back({start,end});\\n        while(i<intervals.size())\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n       \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057287,
                "title": "c-easy-to-understand-beats-75",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& ne) {\\n        intervals.push_back(ne);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        int j=0;\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[j][1]>=intervals[i][0]){\\n                intervals[j][1]=max(intervals[j][1],intervals[i][1]);\\n               \\n            }\\n            else{\\n                j++;\\n                intervals[j]=intervals[i];\\n            }\\n        }\\n        \\n       for(int i=0;i<=j;i++){\\n           ans.push_back(intervals[i]);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& ne) {\\n        intervals.push_back(ne);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        int j=0;\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[j][1]>=intervals[i][0]){\\n                intervals[j][1]=max(intervals[j][1],intervals[i][1]);\\n               \\n            }\\n            else{\\n                j++;\\n                intervals[j]=intervals[i];\\n            }\\n        }\\n        \\n       for(int i=0;i<=j;i++){\\n           ans.push_back(intervals[i]);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057001,
                "title": "c-easy-solution-using-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inter, vector<int>& nInter) {\\n        vector<int>a,b;\\n        vector<vector<int>>ans;\\n        for(auto &val:inter){\\n            a.push_back(val[0]);\\n            b.push_back(val[1]);\\n        }\\n        int x=upper_bound(a.begin(),a.end(),nInter[0])-a.begin()-1;\\n        int y=upper_bound(a.begin(),a.end(),nInter[1])-a.begin()-1;\\n        \\n        \\n        if(x==y){\\n            if(x==-1){\\n                ans.push_back(nInter);\\n                for(int i=0;i<inter.size();i++){\\n                    ans.push_back(inter[i]);\\n                    \\n                }\\n                return ans;\\n            }\\n            else{\\n                if(nInter[0]>inter[x][1]){\\n                    for(int i=0;i<inter.size();i++){\\n                        ans.push_back(inter[i]);\\n                        if(i==x){\\n                            ans.push_back(nInter);\\n                        }\\n                        \\n                    }\\n                    return ans;\\n                }\\n            }\\n        }\\n        bool flag=true;\\n        for(int i=0;i<inter.size();i++){\\n            if(flag&&(i==x||x==-1)){\\n                if(x!=-1&&inter[x][1]<nInter[0]){\\n                    ans.push_back(inter[x]);\\n                }\\n                ans.push_back({min(nInter[0],inter[x+(x==-1||inter[x][1]<nInter[0])][0]),max(nInter[1],inter[y][1])});\\n                i=y;\\n                flag=false;\\n            }\\n            else{\\n                ans.push_back(inter[i]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\n**Please Upvote it really Motivates me**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inter, vector<int>& nInter) {\\n        vector<int>a,b;\\n        vector<vector<int>>ans;\\n        for(auto &val:inter){\\n            a.push_back(val[0]);\\n            b.push_back(val[1]);\\n        }\\n        int x=upper_bound(a.begin(),a.end(),nInter[0])-a.begin()-1;\\n        int y=upper_bound(a.begin(),a.end(),nInter[1])-a.begin()-1;\\n        \\n        \\n        if(x==y){\\n            if(x==-1){\\n                ans.push_back(nInter);\\n                for(int i=0;i<inter.size();i++){\\n                    ans.push_back(inter[i]);\\n                    \\n                }\\n                return ans;\\n            }\\n            else{\\n                if(nInter[0]>inter[x][1]){\\n                    for(int i=0;i<inter.size();i++){\\n                        ans.push_back(inter[i]);\\n                        if(i==x){\\n                            ans.push_back(nInter);\\n                        }\\n                        \\n                    }\\n                    return ans;\\n                }\\n            }\\n        }\\n        bool flag=true;\\n        for(int i=0;i<inter.size();i++){\\n            if(flag&&(i==x||x==-1)){\\n                if(x!=-1&&inter[x][1]<nInter[0]){\\n                    ans.push_back(inter[x]);\\n                }\\n                ans.push_back({min(nInter[0],inter[x+(x==-1||inter[x][1]<nInter[0])][0]),max(nInter[1],inter[y][1])});\\n                i=y;\\n                flag=false;\\n            }\\n            else{\\n                ans.push_back(inter[i]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056444,
                "title": "daily-leetcoding-challenge-january-day-16",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-interval/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Linear Search\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-interval/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2489404,
                "title": "c-easy-and-concise",
                "content": "```\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto &it : intervals) {\\n            if(it[1] >= newInterval[0] and it[0] <= newInterval[1]) {\\n                newInterval[0] = min(it[0],newInterval[0]);\\n                newInterval[1] = max(it[1],newInterval[1]);\\n            }\\n            else {\\n                if(it[0] > newInterval[0]) \\n                    swap(it,newInterval);\\n                ans.push_back(it);\\n            }\\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto &it : intervals) {\\n            if(it[1] >= newInterval[0] and it[0] <= newInterval[1]) {\\n                newInterval[0] = min(it[0],newInterval[0]);\\n                newInterval[1] = max(it[1],newInterval[1]);\\n            }\\n            else {\\n                if(it[0] > newInterval[0]) \\n                    swap(it,newInterval);\\n                ans.push_back(it);\\n            }\\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2435713,
                "title": "c-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    // merge intervals.\\n    vector<vector<int>> merge(vector<vector<int>>&ans,int n)\\n    {\\n        vector<vector<int>>res;\\n        res.push_back(ans[0]);\\n        int prev=res[0][1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(ans[i][0]<=prev)\\n            {\\n                res[res.size()-1][1]=max(res[res.size()-1][1],ans[i][1]);\\n                prev=res[res.size()-1][1];\\n            }\\n            else\\n            {\\n                res.push_back(ans[i]);\\n                prev=ans[i][1];\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n=intervals.size();\\n        // Adding interval \\n        vector<vector<int>>ans;\\n        bool first=false;\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(!first && intervals[i][0]>=newInterval[0])\\n            {\\n                ans.push_back(newInterval);\\n                first=true;\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                i++;\\n            }\\n        }\\n        if(!first)\\n            ans.push_back(newInterval);\\n \\n        // merge intervals\\n        return merge(ans,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // merge intervals.\\n    vector<vector<int>> merge(vector<vector<int>>&ans,int n)\\n    {\\n        vector<vector<int>>res;\\n        res.push_back(ans[0]);\\n        int prev=res[0][1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(ans[i][0]<=prev)\\n            {\\n                res[res.size()-1][1]=max(res[res.size()-1][1],ans[i][1]);\\n                prev=res[res.size()-1][1];\\n            }\\n            else\\n            {\\n                res.push_back(ans[i]);\\n                prev=ans[i][1];\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n=intervals.size();\\n        // Adding interval \\n        vector<vector<int>>ans;\\n        bool first=false;\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(!first && intervals[i][0]>=newInterval[0])\\n            {\\n                ans.push_back(newInterval);\\n                first=true;\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                i++;\\n            }\\n        }\\n        if(!first)\\n            ans.push_back(newInterval);\\n \\n        // merge intervals\\n        return merge(ans,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271812,
                "title": "python-simplest-solution-with-explanation-beg-to-adv-interval",
                "content": "```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        if len(intervals) < 2 and len(newInterval) == 0: # if there is only one element in the provided list and if htere is no element in newInterval\\n            return intervals # then just return interval. \\n      \\n        intervals.append(newInterval) # merging both the lists.\\n        \\n        # Below is the same program for merge interval, as we have to return a list with overlape. \\n        \\n        intervals.sort()# Sorting the list, if we dont then we wont be able to check for the overlapping intervals.\\n        start = intervals[0][0] # saving first element of the sublist in a variable for comparing it. \\n        end = intervals[0][1] # saving second element of the sublist in a variable for comparing it. \\n        res = [] # crerating a empty list for saving the result. \\n        \\n        for i in range(1, len(intervals)):# traversing the list from 1 as 0th element of the list is allocated to the variables, start & end.\\n            interval = intervals[i]# assigning i`th element to the a variable for performing the logic.\\n            if interval[0]<=end: # overlapping intervals\\n                end = max(interval[1], end)\\n            else:  # non-overlapping interval, add the previous interval and reset\\n                res.append([start, end])\\n                start = interval[0] # updating start variable with current interval element.\\n                end = interval[1]# updating end variable with current interval element.\\n        res.append([start, end])  # add the last interval\\n        return res\\n```\\n***Found helpful, Do upvote !!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        if len(intervals) < 2 and len(newInterval) == 0: # if there is only one element in the provided list and if htere is no element in newInterval\\n            return intervals # then just return interval. \\n      \\n        intervals.append(newInterval) # merging both the lists.\\n        \\n        # Below is the same program for merge interval, as we have to return a list with overlape. \\n        \\n        intervals.sort()# Sorting the list, if we dont then we wont be able to check for the overlapping intervals.\\n        start = intervals[0][0] # saving first element of the sublist in a variable for comparing it. \\n        end = intervals[0][1] # saving second element of the sublist in a variable for comparing it. \\n        res = [] # crerating a empty list for saving the result. \\n        \\n        for i in range(1, len(intervals)):# traversing the list from 1 as 0th element of the list is allocated to the variables, start & end.\\n            interval = intervals[i]# assigning i`th element to the a variable for performing the logic.\\n            if interval[0]<=end: # overlapping intervals\\n                end = max(interval[1], end)\\n            else:  # non-overlapping interval, add the previous interval and reset\\n                res.append([start, end])\\n                start = interval[0] # updating start variable with current interval element.\\n                end = interval[1]# updating end variable with current interval element.\\n        res.append([start, end])  # add the last interval\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159738,
                "title": "kotlin-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\\n        \\n\\n        var ans = mutableListOf<IntArray>()\\n        \\n        \\n        var start = newInterval[0]\\n        var end = newInterval[1]\\n        \\n        var counter = 0\\n        \\n        // get the intervals which are smaller than the newInterval\\n        while(counter < intervals.size && intervals[counter][1] < start) ans.add(intervals[counter++])\\n        \\n        // check if any overlapping exist and define the boundraies for the merged intervals\\n        while(counter < intervals.size && intervals[counter][0] <= end){\\n            start = Math.min(intervals[counter][0],start)\\n            end = Math.max(intervals[counter++][1],end)\\n        }\\n        \\n        // add the merged intervals\\n        ans.add(intArrayOf(start,end))\\n        \\n        // add the remaining part that its size is larger than the merged part\\n        while(counter < intervals.size) ans.add(intervals[counter++])\\n\\n        return ans.toTypedArray()\\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\\n        \\n\\n        var ans = mutableListOf<IntArray>()\\n        \\n        \\n        var start = newInterval[0]\\n        var end = newInterval[1]\\n        \\n        var counter = 0\\n        \\n        // get the intervals which are smaller than the newInterval\\n        while(counter < intervals.size && intervals[counter][1] < start) ans.add(intervals[counter++])\\n        \\n        // check if any overlapping exist and define the boundraies for the merged intervals\\n        while(counter < intervals.size && intervals[counter][0] <= end){\\n            start = Math.min(intervals[counter][0],start)\\n            end = Math.max(intervals[counter++][1],end)\\n        }\\n        \\n        // add the merged intervals\\n        ans.add(intArrayOf(start,end))\\n        \\n        // add the remaining part that its size is larger than the merged part\\n        while(counter < intervals.size) ans.add(intervals[counter++])\\n\\n        return ans.toTypedArray()\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105125,
                "title": "east-to-understand-c-solution-very-intuitive",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>> &intervals, vector<int> &new_interval)\\n    {\\n        vector<vector<int>> res;\\n        int n = intervals.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int low = max(intervals[i][0], new_interval[0]);\\n            int high = min(intervals[i][1], new_interval[1]);\\n\\n            // overlapping condition\\n            if (low <= high)\\n            {\\n                int union_low = min(intervals[i][0], new_interval[0]);\\n                int union_high = max(intervals[i][1], new_interval[1]);\\n\\n                new_interval = {union_low, union_high};\\n            }\\n            else\\n            {\\n                if (intervals[i][1] < new_interval[0])\\n                {\\n                    res.push_back(intervals[i]);\\n                }\\n                else if (new_interval[1] < intervals[i][0])\\n                {\\n                    res.push_back(new_interval);\\n                    new_interval = intervals[i];\\n                }\\n            }\\n        }\\n        res.push_back(new_interval);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>> &intervals, vector<int> &new_interval)\\n    {\\n        vector<vector<int>> res;\\n        int n = intervals.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int low = max(intervals[i][0], new_interval[0]);\\n            int high = min(intervals[i][1], new_interval[1]);\\n\\n            // overlapping condition\\n            if (low <= high)\\n            {\\n                int union_low = min(intervals[i][0], new_interval[0]);\\n                int union_high = max(intervals[i][1], new_interval[1]);\\n\\n                new_interval = {union_low, union_high};\\n            }\\n            else\\n            {\\n                if (intervals[i][1] < new_interval[0])\\n                {\\n                    res.push_back(intervals[i]);\\n                }\\n                else if (new_interval[1] < intervals[i][0])\\n                {\\n                    res.push_back(new_interval);\\n                    new_interval = intervals[i];\\n                }\\n            }\\n        }\\n        res.push_back(new_interval);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075054,
                "title": "c-easy-o-n",
                "content": "\\n\\n```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        int i=0;\\n\\t\\t\\n\\t\\t//Insert the interval in sorted order\\n        while(i<intervals.size() && newInterval[0]>intervals[i][0])\\n            i++;\\n        intervals.insert(intervals.begin()+i,newInterval);\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n\\t\\t/*If end of previous inserted interval end value  is less than next Interval end value then only we have to consider it otherwise \\n\\t\\t\\tdiscard and move ahead . If true check whether the current interval is overlapping with the next then merge and Push . If not just push interval in the ans vector. */\\n            if(ans[j][1] <= intervals[i][1])\\n            if(ans[j][1]>=intervals[i][0])\\n                ans[j][1] = intervals[i][1];\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        int i=0;\\n\\t\\t\\n\\t\\t//Insert the interval in sorted order\\n        while(i<intervals.size() && newInterval[0]>intervals[i][0])\\n            i++;\\n        intervals.insert(intervals.begin()+i,newInterval);\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n\\t\\t/*If end of previous inserted interval end value  is less than next Interval end value then only we have to consider it otherwise \\n\\t\\t\\tdiscard and move ahead . If true check whether the current interval is overlapping with the next then merge and Push . If not just push interval in the ans vector. */\\n            if(ans[j][1] <= intervals[i][1])\\n            if(ans[j][1]>=intervals[i][0])\\n                ans[j][1] = intervals[i][1];\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680989,
                "title": "easy-faster-than-91-72-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto x: intervals){\\n            if(x[1]<newInterval[0]){\\n                ans.push_back(x);\\n            }else if(x[0]>newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = x;\\n            }else{\\n                newInterval[0] = min(x[0],newInterval[0]);\\n                newInterval[1] = max(x[1],newInterval[1]);\\n            }            \\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto x: intervals){\\n            if(x[1]<newInterval[0]){\\n                ans.push_back(x);\\n            }else if(x[0]>newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = x;\\n            }else{\\n                newInterval[0] = min(x[0],newInterval[0]);\\n                newInterval[1] = max(x[1],newInterval[1]);\\n            }            \\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877685,
                "title": "java-solution-with-figures-diagrams-easy-3-step-process-update-with-new-signature",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> out = new ArrayList<>();\\n        int i = 0;\\n        \\n        /*\\n        Step 1.\\n        Add all intervals before newInterval (that don\\'t overlap with newInterval so just 1 in this case\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------        \\n         */\\n        while( i<intervals.length && intervals[i][1] < newInterval[0] ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        // \\n        /*\\n        Step 2.\\n        Now i is at an interval that we merge with OR that we don\\'t merge with (case B)\\n        Case A.\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------   \\n\\n        Case B.\\n            1.                          2.  \\n          -----                       ------\\n                    -------------   \\n                    \\n        \"intervals[i][0] <= newInterval[1]\" below means if the current interval\\'s start is before or \\n\\t\\tat the newIntervals end, it should be part of the merge interval. Look at the diagram,\\n\\t\\tin case A it is easy to see 4. is the last interval we take. In case B. there are no intervals so the while never loops\\n         */\\n        while( i<intervals.length && intervals[i][0] <= newInterval[1] ){\\n            newInterval[0] = Math.min( newInterval[0], intervals[i][0] ); \\n            newInterval[1] = Math.max( newInterval[1], intervals[i][1] ); \\n            i++;\\n        }\\n        \\n\\t\\t// Add the insert interval\\n        out.add(newInterval);\\n        \\n        // Step 3. Add all of the intervals that come after the inserted interval if any\\n        while( i<intervals.length ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        return out.toArray(new int[out.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> out = new ArrayList<>();\\n        int i = 0;\\n        \\n        /*\\n        Step 1.\\n        Add all intervals before newInterval (that don\\'t overlap with newInterval so just 1 in this case\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------        \\n         */\\n        while( i<intervals.length && intervals[i][1] < newInterval[0] ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        // \\n        /*\\n        Step 2.\\n        Now i is at an interval that we merge with OR that we don\\'t merge with (case B)\\n        Case A.\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------   \\n\\n        Case B.\\n            1.                          2.  \\n          -----                       ------\\n                    -------------   \\n                    \\n        \"intervals[i][0] <= newInterval[1]\" below means if the current interval\\'s start is before or \\n\\t\\tat the newIntervals end, it should be part of the merge interval. Look at the diagram,\\n\\t\\tin case A it is easy to see 4. is the last interval we take. In case B. there are no intervals so the while never loops\\n         */\\n        while( i<intervals.length && intervals[i][0] <= newInterval[1] ){\\n            newInterval[0] = Math.min( newInterval[0], intervals[i][0] ); \\n            newInterval[1] = Math.max( newInterval[1], intervals[i][1] ); \\n            i++;\\n        }\\n        \\n\\t\\t// Add the insert interval\\n        out.add(newInterval);\\n        \\n        // Step 3. Add all of the intervals that come after the inserted interval if any\\n        while( i<intervals.length ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        return out.toArray(new int[out.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864312,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        left, merge, right = [], [], []\\n        for x in intervals: # credit to @StefanPochmann\\n            if x[0] > e:\\n                right.append(x)\\n            elif x[1] < s:\\n                left.append(x)\\n            else:\\n                merge.append(x)\\n        if merge:\\n            s = min(merge[0][0], s)\\n            e = max(merge[-1][1], e)\\n            \\n        return left + [[s,e]] + right\\n            \\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        left, merge, right = [], [], []\\n        for x in intervals: # credit to @StefanPochmann\\n            if x[0] > e:\\n                right.append(x)\\n            elif x[1] < s:\\n                left.append(x)\\n            else:\\n                merge.append(x)\\n        if merge:\\n            s = min(merge[0][0], s)\\n            e = max(merge[-1][1], e)\\n            \\n        return left + [[s,e]] + right\\n            \\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602609,
                "title": "simple-python-o-n-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals, new):\\n        \\n        merged,t,l = [], 0, len(intervals)       \\n        for curr in intervals:\\n            \\n            # If interval[i] completely smaller than new one\\n            if new[0]>curr[1]:\\n                merged.append(curr)\\n             \\n            # If interval[i] completely greater than new\\n            elif curr[0]>new[1]:\\n                break\\n             \\n            # If interval[i] is overlapping with new\\n            else:              \\n                # choose minm and maxm boundaries from both\\n                new[0] = min(new[0], curr[0])\\n                new[1] = max(new[1], curr[1])\\n            \\n            t+=1\\n            \\n        # Apeending last new interval\\n        merged.append(new)\\n        \\n        # Now understand this part\\n        # i) If new part extend till end than simply return merged ones\\n        # ii) If not till end than return merged + remainling intervals\\n        return merged+intervals[t:] if t<l else merged\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, new):\\n        \\n        merged,t,l = [], 0, len(intervals)       \\n        for curr in intervals:\\n            \\n            # If interval[i] completely smaller than new one\\n            if new[0]>curr[1]:\\n                merged.append(curr)\\n             \\n            # If interval[i] completely greater than new\\n            elif curr[0]>new[1]:\\n                break\\n             \\n            # If interval[i] is overlapping with new\\n            else:              \\n                # choose minm and maxm boundaries from both\\n                new[0] = min(new[0], curr[0])\\n                new[1] = max(new[1], curr[1])\\n            \\n            t+=1\\n            \\n        # Apeending last new interval\\n        merged.append(new)\\n        \\n        # Now understand this part\\n        # i) If new part extend till end than simply return merged ones\\n        # ii) If not till end than return merged + remainling intervals\\n        return merged+intervals[t:] if t<l else merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562487,
                "title": "extremely-easy-understanding-java",
                "content": "All the intervals can be classified into three groups:\\n\\n1. non-overlapping interval ends before the `newInterval`\\n2. overlapping intervals\\n2. non-overlapping interval starts after the `newInterval`\\n\\nFor intervals in the first and third group, we don\\'t need to do anything rather than adding them to the result set.\\nFor the second group, we just merge their `startTime` and `endTime`, with our `newInterval`, and add the final merged interval to the result.\\n\\n```java\\nList<int[]> result = new ArrayList<>();\\nint index = 0;\\n// Add all non-overlapping intervals before the \\'newSpan\\'\\nwhile (index < intervals.length && intervals[index][1] < newSpan[0]) {\\n\\tresult.add(intervals[index++]);\\n}\\n// Merge all overlapping intervals into the newSpan\\nwhile (index < intervals.length && intervals[index][0] <= newSpan[1]) {\\n\\tint[] thisSpan = intervals[index++];\\n\\tnewSpan[0] = Math.min(thisSpan[0], newSpan[0]);\\n\\tnewSpan[1] = Math.max(thisSpan[1], newSpan[1]);\\n\\n}\\nresult.add(newSpan);  // return the merged newspan\\n\\n// Add all remaining non-overlapping intervals after the merged newSpan\\nwhile (index < intervals.length) {\\n\\tresult.add(intervals[index++]);\\n}\\n\\nreturn result.toArray(new int[result.size()][]);\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```java\\nList<int[]> result = new ArrayList<>();\\nint index = 0;\\n// Add all non-overlapping intervals before the \\'newSpan\\'\\nwhile (index < intervals.length && intervals[index][1] < newSpan[0]) {\\n\\tresult.add(intervals[index++]);\\n}\\n// Merge all overlapping intervals into the newSpan\\nwhile (index < intervals.length && intervals[index][0] <= newSpan[1]) {\\n\\tint[] thisSpan = intervals[index++];\\n\\tnewSpan[0] = Math.min(thisSpan[0], newSpan[0]);\\n\\tnewSpan[1] = Math.max(thisSpan[1], newSpan[1]);\\n\\n}\\nresult.add(newSpan);  // return the merged newspan\\n\\n// Add all remaining non-overlapping intervals after the merged newSpan\\nwhile (index < intervals.length) {\\n\\tresult.add(intervals[index++]);\\n}\\n\\nreturn result.toArray(new int[result.size()][]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499881,
                "title": "python-two-different-solutions",
                "content": "1. Using two pointers\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            return [newInterval]\\n        \\n        x = len(intervals)\\n        i = 0\\n        while(i<x and intervals[i][1]<newInterval[0]):\\n            i += 1\\n            \\n        j = i\\n        while(j<x and intervals[j][0]<=newInterval[1]):\\n            j += 1\\n\\n\\n        if i == j:\\n            ret = newInterval\\n        else:\\n            start = min(intervals[i][0], newInterval[0])\\n            end = max(intervals[j-1][1],newInterval[1])\\n            ret = [start,end]\\n            \\n        return intervals[:i] + [ret] + intervals[j:]\\n```\\n\\n2. Use previous solution\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        \\n        intervals.sort()\\n        \\n        merged=[]\\n        for interval in intervals:\\n            if not merged or merged[-1][1] < interval[0]:\\n                merged.append(interval)\\n            else:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n                \\n        return merged\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            return [newInterval]\\n        \\n        x = len(intervals)\\n        i = 0\\n        while(i<x and intervals[i][1]<newInterval[0]):\\n            i += 1\\n            \\n        j = i\\n        while(j<x and intervals[j][0]<=newInterval[1]):\\n            j += 1\\n\\n\\n        if i == j:\\n            ret = newInterval\\n        else:\\n            start = min(intervals[i][0], newInterval[0])\\n            end = max(intervals[j-1][1],newInterval[1])\\n            ret = [start,end]\\n            \\n        return intervals[:i] + [ret] + intervals[j:]\\n```\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        \\n        intervals.sort()\\n        \\n        merged=[]\\n        for interval in intervals:\\n            if not merged or merged[-1][1] < interval[0]:\\n                merged.append(interval)\\n            else:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n                \\n        return merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436879,
                "title": "javascript-solution-o-n",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let results = [];\\n    \\n    let i = 0;\\n    while(i < intervals.length && intervals[i][1] < newInterval[0]) {\\n        results.push(intervals[i]);\\n        i++;\\n    }\\n    \\n    newInterval = [Math.min(newInterval[0], i < intervals.length ? intervals[i][0] : Infinity), newInterval[1]];    \\n                                       \\n    while(i < intervals.length && newInterval[1] >= intervals[i][0]) {\\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n        i++;\\n    }       \\n    results.push(newInterval);\\n   return results.concat(intervals.slice(i, intervals.length));\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let results = [];\\n    \\n    let i = 0;\\n    while(i < intervals.length && intervals[i][1] < newInterval[0]) {\\n        results.push(intervals[i]);\\n        i++;\\n    }\\n    \\n    newInterval = [Math.min(newInterval[0], i < intervals.length ? intervals[i][0] : Infinity), newInterval[1]];    \\n                                       \\n    while(i < intervals.length && newInterval[1] >= intervals[i][0]) {\\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n        i++;\\n    }       \\n    results.push(newInterval);\\n   return results.concat(intervals.slice(i, intervals.length));\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 309024,
                "title": "c-98-beat-o-n-single-pass-looper-lew-pah-luu-purrrrr",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        vector<vector<int>> aResult;\\n        \\n        int aIndex = 0;\\n        while (aIndex < intervals.size() && intervals[aIndex][1] < newInterval[0]) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        while (aIndex < intervals.size() && intervals[aIndex][0] <= newInterval[1]) {\\n            newInterval[1] = max(newInterval[1], intervals[aIndex][1]);\\n            newInterval[0] = min(newInterval[0], intervals[aIndex][0]);\\n            ++aIndex;\\n        }\\n        aResult.push_back(newInterval);\\n        \\n        while (aIndex < intervals.size()) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\n$ Dolla Dolla Plz $$ TY",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        vector<vector<int>> aResult;\\n        \\n        int aIndex = 0;\\n        while (aIndex < intervals.size() && intervals[aIndex][1] < newInterval[0]) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        while (aIndex < intervals.size() && intervals[aIndex][0] <= newInterval[1]) {\\n            newInterval[1] = max(newInterval[1], intervals[aIndex][1]);\\n            newInterval[0] = min(newInterval[0], intervals[aIndex][0]);\\n            ++aIndex;\\n        }\\n        aResult.push_back(newInterval);\\n        \\n        while (aIndex < intervals.size()) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304135,
                "title": "go-8ms-6-2mb",
                "content": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    ret := make([][]int, 0)\\n    for i, v := range intervals {\\n\\t\\tif v[1] < newInterval[0] {\\n\\t\\t\\tret = append(ret, v)\\n            continue\\n\\t\\t}\\n        \\n        if v[0] > newInterval[1] {\\n            ret = append(ret, newInterval)\\n            ret = append(ret, intervals[i:]...)\\n            return ret\\n\\t\\t}\\n        \\n        newInterval[0] = min(newInterval[0], v[0])\\n        newInterval[1] = max(newInterval[1], v[1])\\n\\t}\\n    return append(ret, newInterval)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    ret := make([][]int, 0)\\n    for i, v := range intervals {\\n\\t\\tif v[1] < newInterval[0] {\\n\\t\\t\\tret = append(ret, v)\\n            continue\\n\\t\\t}\\n        \\n        if v[0] > newInterval[1] {\\n            ret = append(ret, newInterval)\\n            ret = append(ret, intervals[i:]...)\\n            return ret\\n\\t\\t}\\n        \\n        newInterval[0] = min(newInterval[0], v[0])\\n        newInterval[1] = max(newInterval[1], v[1])\\n\\t}\\n    return append(ret, newInterval)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279899,
                "title": "java-iteration-new-method-signature",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, size = intervals.length;\\n        while(i< size && intervals[i][1] < newInterval[0]){\\n            res.add(intervals[i]); \\n            i++;\\n        }\\n        while(i < size && intervals[i][0] <=  newInterval[1]){\\n           int[] cur = new int[]{Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])};\\n                newInterval = cur; \\n            i++;\\n        }\\n        res.add(newInterval);\\n        while(i < size){\\n            res.add(intervals[i]);\\n            i++;\\n        }\\n        int[][] insert = new int[res.size()][2];\\n        for(int j = 0; j < res.size(); j++){\\n            insert[j] = res.get(j);\\n        }\\n        return insert;\\n    }\\n}\\n```\\n\\nintervals[i][0] <= newInterval[1] is the key to create newInterval recursively.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, size = intervals.length;\\n        while(i< size && intervals[i][1] < newInterval[0]){\\n            res.add(intervals[i]); \\n            i++;\\n        }\\n        while(i < size && intervals[i][0] <=  newInterval[1]){\\n           int[] cur = new int[]{Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])};\\n                newInterval = cur; \\n            i++;\\n        }\\n        res.add(newInterval);\\n        while(i < size){\\n            res.add(intervals[i]);\\n            i++;\\n        }\\n        int[][] insert = new int[res.size()][2];\\n        for(int j = 0; j < res.size(); j++){\\n            insert[j] = res.get(j);\\n        }\\n        return insert;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180320,
                "title": "python-easy-solution-beat-100-36ms",
                "content": "I extract all the start time points from intervals to a list, all the end time points to another list. Then make use of binary search to check the position of the newInterval. Once I found out the position ( the overlapping duration), then I replace them with the new interval.\\n```\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :type newInterval: Interval\\n        :rtype: List[Interval]\\n        \"\"\"\\n        left, right = newInterval.start, newInterval.end\\n        start = [interval.start for interval in intervals]\\n        end = [interval.end for interval in intervals]\\n        i = bisect.bisect_left(start, left)\\n        j = bisect.bisect(end, right)\\n        if i > 0 and left <= intervals[i-1].end:\\n            left = intervals[i-1].start\\n            i = i - 1\\n        if j < len(intervals) and right >= intervals[j].start:\\n            right = intervals[j].end\\n            j = j + 1\\n        intervals[i:j] = [Interval(left, right)]\\n        return intervals\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :type newInterval: Interval\\n        :rtype: List[Interval]\\n        \"\"\"\\n        left, right = newInterval.start, newInterval.end\\n        start = [interval.start for interval in intervals]\\n        end = [interval.end for interval in intervals]\\n        i = bisect.bisect_left(start, left)\\n        j = bisect.bisect(end, right)\\n        if i > 0 and left <= intervals[i-1].end:\\n            left = intervals[i-1].start\\n            i = i - 1\\n        if j < len(intervals) and right >= intervals[j].start:\\n            right = intervals[j].end\\n            j = j + 1\\n        intervals[i:j] = [Interval(left, right)]\\n        return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21676,
                "title": "clean-and-short-java-solution-with-explanation",
                "content": "There are three cases with inserting an interval: \\n\\n 1. the start value of the newInterval < the old interval end:  insert the old interval and increment the index as we will know where this newInterval should be inserted.\\n 2.  the start value of the old interval > newInterval end:  we simply insert the old interval as there is no effect on where the newInterval should be inserted.\\n 3.  Otherwise, we need to merge the interval, simply be getting the min of start and max of end value.\\n\\nIn the end, we insert the newInterval based on the index we get on the fly.\\n\\n\\n    public class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            List<Interval> res = new ArrayList<>();\\n            int index = 0;\\n            for(int i = 0; i < intervals.size(); i++) {\\n                if(intervals.get(i).end < newInterval.start) {\\n                    res.add(intervals.get(i));\\n                    index++;\\n                } else if(intervals.get(i).start > newInterval.end) {\\n                    res.add(intervals.get(i));\\n                } else {\\n                    newInterval.start = Math.min(intervals.get(i).start, newInterval.start);\\n                    newInterval.end = Math.max(intervals.get(i).end, newInterval.end);\\n                }\\n            }\\n            res.add(index, newInterval);\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            List<Interval> res = new ArrayList<>();\\n            int index = 0;\\n            for(int i = 0; i < intervals.size(); i++) {\\n                if(intervals.get(i).end < newInterval.start) {\\n                    res.add(intervals.get(i));\\n                    index++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4077652,
                "title": "optimal-solution-o-n-line-by-line-commented-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n  O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int i = 0 ;\\n        int n = intervals.size();\\n        vector<vector<int>>result;\\n        while(i < intervals.size()){\\n          if(intervals[i][1] < newInterval[0]){\\n            result.push_back(intervals[i]);\\n          }\\n          else if(intervals[i][0] > newInterval[1]){\\n            break;   \\n          }\\n          else{ // merging step \\n        // newInterval\\'s starting point will be min. of starting point of both newIntervals and intervals\\n               newInterval[0] = min(newInterval[0] , intervals[i][0]);\\n               newInterval[1] = max(newInterval[1] , intervals[i][1]);\\n          }\\n          i++;\\n        }\\n        result.push_back(newInterval);\\n\\n        while(i < n ){ // if newInterval\\'s starting point will be greater than all given intervals\\'s stating point(we pass throuth loop)//\\n          result.push_back(intervals[i]);\\n          i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int i = 0 ;\\n        int n = intervals.size();\\n        vector<vector<int>>result;\\n        while(i < intervals.size()){\\n          if(intervals[i][1] < newInterval[0]){\\n            result.push_back(intervals[i]);\\n          }\\n          else if(intervals[i][0] > newInterval[1]){\\n            break;   \\n          }\\n          else{ // merging step \\n        // newInterval\\'s starting point will be min. of starting point of both newIntervals and intervals\\n               newInterval[0] = min(newInterval[0] , intervals[i][0]);\\n               newInterval[1] = max(newInterval[1] , intervals[i][1]);\\n          }\\n          i++;\\n        }\\n        result.push_back(newInterval);\\n\\n        while(i < n ){ // if newInterval\\'s starting point will be greater than all given intervals\\'s stating point(we pass throuth loop)//\\n          result.push_back(intervals[i]);\\n          i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929854,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        l = []\\n        for i in intervals:\\n            if i[1] < newInterval[0]:\\n                l.append(i)\\n            elif i[0] > newInterval[1]:\\n                l.append(newInterval)\\n                newInterval = i\\n            elif i[1] >= newInterval[0] or i[0] <= newInterval[1]:\\n                newInterval[0] = min(i[0],newInterval[0])\\n                newInterval[1] = max(newInterval[1],i[1])\\n        l.append(newInterval)\\n        return l\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        l = []\\n        for i in intervals:\\n            if i[1] < newInterval[0]:\\n                l.append(i)\\n            elif i[0] > newInterval[1]:\\n                l.append(newInterval)\\n                newInterval = i\\n            elif i[1] >= newInterval[0] or i[0] <= newInterval[1]:\\n                newInterval[0] = min(i[0],newInterval[0])\\n                newInterval[1] = max(newInterval[1],i[1])\\n        l.append(newInterval)\\n        return l\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057652,
                "title": "simple-easy-to-understand",
                "content": "# Complexity\n- Time complexity: **O(N)**\n\n- Space complexity: **O(1)** #if we ignore answer list\n\n# Code\n```\nclass Solution(object):\n    def insert(self, inter, new):\n        flag = False\n        res = []\n        for li in inter:\n            if not flag:\n                if li[0] > new[1]:\n                    res.append(new)\n                    res.append(li)\n                    flag = True\n                elif li[1] < new[0]:\n                    res.append(li)\n                elif new[0] >= li[0] and new[1] >= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif new[0] >= li[0] and new[0] <= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif li[0] >= new[0] and li[0] <= new[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n            else:\n                if res[-1][0] <= li[0] and li[0] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] >= res[-1][0] and li[1] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] <= res[-1][0] and res[-1][1] >= li[0]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                else:\n                    res.append(li)\n        if not flag: res.append(new)\n        return res\n```\nIf you have any **doubt** ask me in comments and UpVote, if you like it **:)**",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def insert(self, inter, new):\n        flag = False\n        res = []\n        for li in inter:\n            if not flag:\n                if li[0] > new[1]:\n                    res.append(new)\n                    res.append(li)\n                    flag = True\n                elif li[1] < new[0]:\n                    res.append(li)\n                elif new[0] >= li[0] and new[1] >= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif new[0] >= li[0] and new[0] <= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif li[0] >= new[0] and li[0] <= new[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n            else:\n                if res[-1][0] <= li[0] and li[0] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] >= res[-1][0] and li[1] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] <= res[-1][0] and res[-1][1] >= li[0]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                else:\n                    res.append(li)\n        if not flag: res.append(new)\n        return res\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057584,
                "title": "fastest-python-solution-explained",
                "content": "# Intuition\\nThe intuition is simple we just need to expand the values which come under same component i.e. connected\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFind the starting index from where potential connection can occur so if ending value of any given interval is greater than equal to newInterval starting value then they can be connected.\\n\\nSimilarly, if ending index of newInterval is greater than equal to starting value of any given interval then they can be also in potential conection. so change index of end pointer to current index\\n\\nFinally if starting pointer(intially st=-1) has not changed at that means newIntwrval is greatest of all. Similarly if end pointer(initially end=-1) has never changed that means it is before the interval pointed by starting pointer(st) \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        st=-1\\n        end=-1\\n        n=len(intervals)\\n        if n==0:\\n            return [newInterval]\\n        for i in range(n):\\n            if st==-1:\\n                if newInterval[0]<=intervals[i][1]:\\n                    st=i\\n            if st!=-1:\\n                if newInterval[1]>=intervals[i][0]:\\n                    end=i+1\\n        if st==-1:\\n            intervals.append(newInterval)\\n        elif end==-1:\\n            intervals.insert(st,newInterval)\\n        else:\\n            ni=[min(newInterval[0],intervals[st][0]),max(newInterval[1],intervals[end-1][1])]\\n            intervals[st:end]=[ni]\\n        \\n        return intervals\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        st=-1\\n        end=-1\\n        n=len(intervals)\\n        if n==0:\\n            return [newInterval]\\n        for i in range(n):\\n            if st==-1:\\n                if newInterval[0]<=intervals[i][1]:\\n                    st=i\\n            if st!=-1:\\n                if newInterval[1]>=intervals[i][0]:\\n                    end=i+1\\n        if st==-1:\\n            intervals.append(newInterval)\\n        elif end==-1:\\n            intervals.insert(st,newInterval)\\n        else:\\n            ni=[min(newInterval[0],intervals[st][0]),max(newInterval[1],intervals[end-1][1])]\\n            intervals[st:end]=[ni]\\n        \\n        return intervals\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057502,
                "title": "live-coding-0-ms-and-beats-99-with-video-explanation-in-english-and-hindi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nMy approach in ENGLISH\\n\\nhttps://youtu.be/qTTqgwvfBZs\\n\\nIN HINDI\\n\\nhttps://youtu.be/rDGgpi1HUXk\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        List<int[]>ans = new ArrayList();\\n        for(int i=0;i<n;i++){\\n            if(intervals[i][1]<newInterval[0]){\\n                ans.add(intervals[i]);\\n            }\\n            else if(intervals[i][0]>newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            }else if(intervals[i][1]>=newInterval[0] || intervals[i][0]<=newInterval[1]){\\n                newInterval[0] = Math.min(newInterval[0],intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1],intervals[i][1]);\\n            }\\n        }\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        List<int[]>ans = new ArrayList();\\n        for(int i=0;i<n;i++){\\n            if(intervals[i][1]<newInterval[0]){\\n                ans.add(intervals[i]);\\n            }\\n            else if(intervals[i][0]>newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            }else if(intervals[i][1]>=newInterval[0] || intervals[i][0]<=newInterval[1]){\\n                newInterval[0] = Math.min(newInterval[0],intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1],intervals[i][1]);\\n            }\\n        }\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057466,
                "title": "c-begineer-friendly-easy-understanding-union-find-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BCBBfE0HV_0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n        vector<vector<int>>ans;\\n\\n        // 2 cases.\\n        for(auto currentInterval:intervals){\\n        //case 1 :non overlapping\\n        // new interval is after current interval. add current interval to the ans.\\n        if(currentInterval[1]<newInterval[0]){ans.push_back(currentInterval);}\\n        // if new interval comes before current interval that means we need to make it current interval and check for overlaping with others. And our new interval will also be add to ans.\\n        else if(newInterval[1]<currentInterval[0]){\\n                    ans.push_back(newInterval);\\n                    //update it to new interval for overlapping checking.\\n                    newInterval = currentInterval;\\n        }\\n        // case 2 :overlapping\\n        else{\\n            // update the newInterval for checking overlapping.\\n            newInterval[0] = min(currentInterval[0],newInterval[0]);\\n            newInterval[1] = max(currentInterval[1],newInterval[1]);\\n\\n        }\\n\\n        }\\n        // Add the last non overlaping interval (newInterval)\\n        ans.push_back(newInterval);\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sort",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n        vector<vector<int>>ans;\\n\\n        // 2 cases.\\n        for(auto currentInterval:intervals){\\n        //case 1 :non overlapping\\n        // new interval is after current interval. add current interval to the ans.\\n        if(currentInterval[1]<newInterval[0]){ans.push_back(currentInterval);}\\n        // if new interval comes before current interval that means we need to make it current interval and check for overlaping with others. And our new interval will also be add to ans.\\n        else if(newInterval[1]<currentInterval[0]){\\n                    ans.push_back(newInterval);\\n                    //update it to new interval for overlapping checking.\\n                    newInterval = currentInterval;\\n        }\\n        // case 2 :overlapping\\n        else{\\n            // update the newInterval for checking overlapping.\\n            newInterval[0] = min(currentInterval[0],newInterval[0]);\\n            newInterval[1] = max(currentInterval[1],newInterval[1]);\\n\\n        }\\n\\n        }\\n        // Add the last non overlaping interval (newInterval)\\n        ans.push_back(newInterval);\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057150,
                "title": "python-solution-using-binary-search-and-simple-merge-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition was to first iterate through the `intervals` and find correct index to insert `newInterval`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this approach I first found the correct index to insert the given interval, and then the key to this question is understanding how to merge the intervals, Thus following are the steps involved in the question:\\n1) find the position where new interval should be inserted based on the end time of the intervals given. (used binary search to optimize time)\\n2) for merging intervals take minimum of ( `intervals[k][0]` and `newInterval[0]` ) and maximum of ( `intervals[k][0]` and `newInterval[0]` )    \\nNote: here `k` is the index found using binary search\\n3) simply store it in new result list and return it.\\n\\nThis approach is quite fast:\\n![asdasd.PNG](https://assets.leetcode.com/users/images/91b1baa7-3f3b-40a4-9895-ea2e219b3134_1673846919.1683147.png)\\n\\n\\nHope it Helps!!\\n\\n# Code\\n```\\ndef binary_search(x, n):\\n    s = 0\\n    e = len(x) - 1\\n    while s<=e:\\n        mid = (s+e)//2\\n        if x[mid] == n:\\n            return mid\\n        elif x[mid] < n:\\n            s  = mid + 1\\n        else:\\n            e = mid - 1\\n    return e+1\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            intervals.append(newInterval)\\n            return intervals\\n        x = []\\n        for i in range(len(intervals)):\\n            x.append(intervals[i][1])\\n\\n        k = binary_search(x,newInterval[0])\\n        res = intervals[:k] #to store intervals till `k`th index\\n        while k < len(intervals) and intervals[k][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[k][0], newInterval[0])\\n            newInterval[1] = max(intervals[k][1], newInterval[1])\\n            k += 1\\n        res.append(newInterval)\\n        #adding remaining elements to the list\\n        res += intervals[k:]  \\n        return res        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\ndef binary_search(x, n):\\n    s = 0\\n    e = len(x) - 1\\n    while s<=e:\\n        mid = (s+e)//2\\n        if x[mid] == n:\\n            return mid\\n        elif x[mid] < n:\\n            s  = mid + 1\\n        else:\\n            e = mid - 1\\n    return e+1\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            intervals.append(newInterval)\\n            return intervals\\n        x = []\\n        for i in range(len(intervals)):\\n            x.append(intervals[i][1])\\n\\n        k = binary_search(x,newInterval[0])\\n        res = intervals[:k] #to store intervals till `k`th index\\n        while k < len(intervals) and intervals[k][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[k][0], newInterval[0])\\n            newInterval[1] = max(intervals[k][1], newInterval[1])\\n            k += 1\\n        res.append(newInterval)\\n        #adding remaining elements to the list\\n        res += intervals[k:]  \\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845908,
                "title": "java-solution-with-simple-explanation",
                "content": "### Simulation\\n\\nIdea: We just need to deal with the insert interval, the intervals outside the range of insert interval, we just put it in the list. For those intervals within the range of insert interval, we need to merge them together.\\n\\n```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ansList = new ArrayList<>();\\n        int i = 0;\\n\\n        // add all the intervals before newInterval starts\\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        // merge intervals with the insert interval\\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        ansList.add(newInterval);\\n\\n        // add the rest of intervals\\n        while (i < intervals.length) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        int[][] ans = new int[ansList.size()][2];\\n        for (int j = 0; j < ansList.size(); j++)\\n            ans[j] = ansList.get(j);\\n\\n        return ans;\\n    }\\n}\\n```\\n\\nComplexity Analysis:\\n\\n- Time Complexity: $O(n)$. $n$ is the length of intervals.\\n- Space Complexity: $O(1)$. We only use extra space for variables.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ansList = new ArrayList<>();\\n        int i = 0;\\n\\n        // add all the intervals before newInterval starts\\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        // merge intervals with the insert interval\\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        ansList.add(newInterval);\\n\\n        // add the rest of intervals\\n        while (i < intervals.length) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        int[][] ans = new int[ansList.size()][2];\\n        for (int j = 0; j < ansList.size(); j++)\\n            ans[j] = ansList.get(j);\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710112,
                "title": "java-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) for result array\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        int i=0;\\n        while(i<intervals.length && intervals[i][1]< newInterval[0]){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        while(i<intervals.length && newInterval[1] >= intervals[i][0] ){\\n            newInterval[0]= Math.min(newInterval[0],intervals[i][0]);\\n            newInterval[1]= Math.max(newInterval[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.add(newInterval);\\n        while(i<intervals.length){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        int i=0;\\n        while(i<intervals.length && intervals[i][1]< newInterval[0]){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        while(i<intervals.length && newInterval[1] >= intervals[i][0] ){\\n            newInterval[0]= Math.min(newInterval[0],intervals[i][0]);\\n            newInterval[1]= Math.max(newInterval[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.add(newInterval);\\n        while(i<intervals.length){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587472,
                "title": "c-clean-and-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/25238441-3aa0-4ea3-a549-39e8e6ae2ad3_1663422186.4353445.png)\\n\\n\\nThis solution is very easy and begginer friendly.\\n\\nExplanation :\\n\\nI have used two for loops one for inserting the newInterval and the second loop for merging intervals.\\n\\nI have also added 2 edge cases(it is self explanatory)\\n\\nThis is my Solution:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n         vector<vector<int>> output;\\n        if(intervals.size()==0){//edge case1\\n            output.push_back(newInterval);\\n        return output;\\n        }\\n        int flag=1;\\n        for (int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]>newInterval[0]){\\n                intervals.insert(intervals.begin() + i,newInterval);\\n                flag=0;\\n            break;\\n            }\\n        }\\n        if (flag==1)//edge case2\\n            intervals.push_back(newInterval);\\n        \\n        output.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(output.back()[1]>=intervals[i][0])\\n                output.back()[1]=max(output.back()[1],intervals[i][1]);\\n            else\\n                output.push_back(intervals[i]);\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\nIt takes only 1 sec to Upvote!!!\\nThanks in advance.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n         vector<vector<int>> output;\\n        if(intervals.size()==0){//edge case1\\n            output.push_back(newInterval);\\n        return output;\\n        }\\n        int flag=1;\\n        for (int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]>newInterval[0]){\\n                intervals.insert(intervals.begin() + i,newInterval);\\n                flag=0;\\n            break;\\n            }\\n        }\\n        if (flag==1)//edge case2\\n            intervals.push_back(newInterval);\\n        \\n        output.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(output.back()[1]>=intervals[i][0])\\n                output.back()[1]=max(output.back()[1],intervals[i][1]);\\n            else\\n                output.push_back(intervals[i]);\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576902,
                "title": "c-easiest-to-understand-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size()-1;\\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i < intervals.size(); i++){\\n            if(intervals[i][1] < newInterval[0]){\\n                res.push_back(intervals[i]);\\n            }\\n            \\n            else if(intervals[i][0] > newInterval[1]){\\n                res.push_back(newInterval);\\n                newInterval = intervals[i];\\n            }\\n            \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(intervals[i][1], newInterval[1]);\\n            }\\n        }\\n       res.push_back(newInterval);\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size()-1;\\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i < intervals.size(); i++){\\n            if(intervals[i][1] < newInterval[0]){\\n                res.push_back(intervals[i]);\\n            }\\n            \\n            else if(intervals[i][0] > newInterval[1]){\\n                res.push_back(newInterval);\\n                newInterval = intervals[i];\\n            }\\n            \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(intervals[i][1], newInterval[1]);\\n            }\\n        }\\n       res.push_back(newInterval);\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563315,
                "title": "python-2-different-solutions-with-explanation",
                "content": "# Approach 1: O(nlogn)\\nThis is exactly the same thing as the problem **[56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)**, except at the beginning of the we append the new interval into the list.\\n\\nIn the for loop, we check if the intervals are overlapping or not (whether the last interval in the resultant list\\'s end time is greater than the start time of the new interval). If they overlap, we merge them by setting the last interval in the resultant list\\'s end time to be the maximum of the 2 intervals.\\n```py\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        intervals.append(newInterval)\\n        intervals.sort()\\n        merged = []\\n        for interval in intervals:\\n            if merged and merged[-1][1] >= interval[0]:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n            else:\\n                merged.append(interval)\\n        return merged\\n```\\n\\n# Approach 2: O(n)\\nWe cover the 3 basic scenarios:\\n1. The current interval is before the interval we want to add (we just add the current interval)\\n2. The current interval is after the one we want to add (we add the new interval, and update the new interval since it\\'s now added already)\\n3. The intervals overlap (we merge them, and update the new interval. NO ADDING YET)\\n\\n\\n```py \\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        for interval in intervals:\\n            if interval[1] < newInterval[0]:\\n                res.append(interval)\\n            elif interval[0] > newInterval[1]:\\n                res.append(newInterval)\\n                newInterval = interval\\n            else:\\n                newInterval[0] = min(newInterval[0], interval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n        res.append(newInterval)\\n            \\n        return res\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```py\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        intervals.append(newInterval)\\n        intervals.sort()\\n        merged = []\\n        for interval in intervals:\\n            if merged and merged[-1][1] >= interval[0]:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n            else:\\n                merged.append(interval)\\n        return merged\\n```\n```py \\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        for interval in intervals:\\n            if interval[1] < newInterval[0]:\\n                res.append(interval)\\n            elif interval[0] > newInterval[1]:\\n                res.append(newInterval)\\n                newInterval = interval\\n            else:\\n                newInterval[0] = min(newInterval[0], interval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n        res.append(newInterval)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058154,
                "title": "java-simple-solution-with-explanation",
                "content": "Check below solution with explanation\\n\\n\\tclass Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\n\\t\\t\\t// base condition\\n\\t\\t\\tif(intervals.length == 0)\\n\\t\\t\\t\\treturn new int[][]{newInterval};\\n\\n\\t\\t\\t// define start and end\\n\\t\\t\\tint start  = newInterval[0];\\n\\t\\t\\tint end  = newInterval[1];\\n\\n\\t\\t\\tList<int[]> output = new ArrayList<>();\\n\\n\\t\\t\\t// to insert any interval in sorted array we need to find the place where it needs to be added\\n\\t\\t\\t// to do that we will first add all intervals in output list which has end less than new interval\\n\\t\\t\\tint i = 0;\\n\\t\\t\\twhile(i < intervals.length && intervals[i][1] < start){\\n\\t\\t\\t\\toutput.add(new int[]{intervals[i][0],intervals[i][1]});\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// once we found the place where new interval should be added using above while loop we will use same logic as merge interval\\n\\t\\t\\t// we will compare new interval and current interval. If merging needed we will merge and add it in the list. \\n\\t\\t\\twhile(i < intervals.length){\\n\\t\\t\\t\\tif(intervals[i][0] <= end){\\n\\t\\t\\t\\t\\tstart = Math.min(start, intervals[i][0]);\\n\\t\\t\\t\\t\\tend = Math.max(end, intervals[i][1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\toutput.add(new int[]{start,end});\\n\\t\\t\\t\\t\\tstart = intervals[i][0];\\n\\t\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add last remaining interval\\n\\t\\t\\toutput.add(new int[]{start, end});\\n\\n\\t\\t\\t// convert list to 2d array\\n\\t\\t\\tint[][] insertInterval = output.toArray(new int[output.size()][]);\\n\\n\\t\\t\\t// return\\n\\t\\t\\treturn insertInterval;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\n\\t\\t\\t// base condition\\n\\t\\t\\tif(intervals.length == 0)\\n\\t\\t\\t\\treturn new int[][]{newInterval}",
                "codeTag": "Java"
            },
            {
                "id": 1742085,
                "title": "c-easy-and-convivence",
                "content": "```\\nbool comp(vector<int>&a,vector<int>&b)\\n{\\n    return a[1]<b[1];\\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newIntervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        vector<vector<int>>ans;\\n        for(auto it:intervals)\\n        {\\n            if(it[1]<newIntervals[0]){\\n                ans.push_back(it);\\n            }\\n            else if(it[0]>newIntervals[1]){\\n                ans.push_back(newIntervals);\\n                newIntervals=it;\\n            }\\n            else{\\n                newIntervals[0]=min(it[0],newIntervals[0]);\\n                newIntervals[1]=max(it[1],newIntervals[1]);\\n            }\\n        }\\n        ans.push_back(newIntervals);\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool comp(vector<int>&a,vector<int>&b)\\n{\\n    return a[1]<b[1];\\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newIntervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        vector<vector<int>>ans;\\n        for(auto it:intervals)\\n        {\\n            if(it[1]<newIntervals[0]){\\n                ans.push_back(it);\\n            }\\n            else if(it[0]>newIntervals[1]){\\n                ans.push_back(newIntervals);\\n                newIntervals=it;\\n            }\\n            else{\\n                newIntervals[0]=min(it[0],newIntervals[0]);\\n                newIntervals[1]=max(it[1],newIntervals[1]);\\n            }\\n        }\\n        ans.push_back(newIntervals);\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721591,
                "title": "c-visualized-explanation-and-analytics-99-faster-and-clean",
                "content": "**Method 1: Straightforward**\\n\\n```\\n1. \\ninterval     |__|\\nnewInterval       |_____|\\n\\n2.\\ninterval       |__|\\nnewInterval       |_____|\\n\\n3.\\ninterval        |__|\\nnewInterval       |_____|\\n\\n4.\\ninterval          |__|\\nnewInterval       |_____|\\n\\n5.\\ninterval            |__|\\nnewInterval       |_____|\\n\\n6.\\ninterval             |__|\\nnewInterval       |_____|\\n\\n7.\\ninterval                |__|\\nnewInterval       |_____|\\n\\n8.\\ninterval                  |__|\\nnewInterval       |_____|\\n```\\n\\n\\nThere are 8 possible relationships between interval and newInterval.\\n\\n**Goal: \\n1 and 8 are easy, so we have to focus on overlapping (2-7)!**\\n\\n```plain\\ncase 1: \\t       if interval[END] is smaller than newInterval[START], just push_back to ans\\ncase 2-7: \\t       if interval[START] is smaller or equal newInterval[END], \\n(overlapping)        we keep the min and max value as start and end of the newInterval\\ncase 8:            if we encounter the first non-overlapping interval\\n\\t\\t\\t\\t\\t push back newInterval and keep the index, then break\\n\\t\\t\\t\\t\\t we will finish the remaining non-overlapping interval\\n```\\n\\nThe algorithm will fail if the newInterval is non-overlapping and last interval,\\nso if `index` is default value (-1), we push back newInterval.\\n\\n```cpp\\n#define START 0\\n#define END 1\\n\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    int index = -1;\\n    for (int i = 0; i < intervals.size(); i++) {\\n      if (intervals[i][END] < newInterval[START]) {\\n        ans.push_back(intervals[i]);\\n      } else if (intervals[i][START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(intervals[i][START], newInterval[START]);\\n        newInterval[END] = max(intervals[i][END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        index = i;\\n        break;\\n      }\\n    }\\n    if (index == -1) {\\n      // if newInterval is the last interval\\n      ans.push_back(newInterval);\\n    } else {\\n      // finish the non-overlapping interval\\n      for (int i = index; i < intervals.size(); i++)\\n        ans.push_back(intervals[i]);\\n    }\\n    return ans;\\n  }\\n};\\n```\\n\\nTime Complexity: O(n), where n is the size of intervals\\nSpace Complexity: O(n)\\nRuntime: 7 ms, faster than 99.17% of C++ online submissions for Insert Interval.\\nMemory Usage: 17.2 MB, less than 40.83% of C++ online submissions for Insert Interval.\\n\\n\\n**Method 2: Clean Version**\\nby reusing the newInterval but more runtime\\n\\n```cpp\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    for (vector<int>& interval: intervals) {\\n      if (interval[END] < newInterval[START]) {\\n        ans.push_back(interval);\\n      } else if (interval[START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(interval[START], newInterval[START]);\\n        newInterval[END] = max(interval[END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        newInterval = interval;\\n      }\\n    }\\n    ans.push_back(newInterval);\\n    return ans;\\n  }\\n};\\n```\\nRuntime: 8 ms, faster than 98.95% of C++ online submissions for Insert Interval.\\nMemory Usage: 16.9 MB, less than 99.47% of C++ online submissions for Insert Interval.\\n\\n**If you have any suggestion or advice, feel free to contact me!**\\n",
                "solutionTags": [],
                "code": "```\\n1. \\ninterval     |__|\\nnewInterval       |_____|\\n\\n2.\\ninterval       |__|\\nnewInterval       |_____|\\n\\n3.\\ninterval        |__|\\nnewInterval       |_____|\\n\\n4.\\ninterval          |__|\\nnewInterval       |_____|\\n\\n5.\\ninterval            |__|\\nnewInterval       |_____|\\n\\n6.\\ninterval             |__|\\nnewInterval       |_____|\\n\\n7.\\ninterval                |__|\\nnewInterval       |_____|\\n\\n8.\\ninterval                  |__|\\nnewInterval       |_____|\\n```\n```plain\\ncase 1: \\t       if interval[END] is smaller than newInterval[START], just push_back to ans\\ncase 2-7: \\t       if interval[START] is smaller or equal newInterval[END], \\n(overlapping)        we keep the min and max value as start and end of the newInterval\\ncase 8:            if we encounter the first non-overlapping interval\\n\\t\\t\\t\\t\\t push back newInterval and keep the index, then break\\n\\t\\t\\t\\t\\t we will finish the remaining non-overlapping interval\\n```\n```cpp\\n#define START 0\\n#define END 1\\n\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    int index = -1;\\n    for (int i = 0; i < intervals.size(); i++) {\\n      if (intervals[i][END] < newInterval[START]) {\\n        ans.push_back(intervals[i]);\\n      } else if (intervals[i][START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(intervals[i][START], newInterval[START]);\\n        newInterval[END] = max(intervals[i][END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        index = i;\\n        break;\\n      }\\n    }\\n    if (index == -1) {\\n      // if newInterval is the last interval\\n      ans.push_back(newInterval);\\n    } else {\\n      // finish the non-overlapping interval\\n      for (int i = index; i < intervals.size(); i++)\\n        ans.push_back(intervals[i]);\\n    }\\n    return ans;\\n  }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    for (vector<int>& interval: intervals) {\\n      if (interval[END] < newInterval[START]) {\\n        ans.push_back(interval);\\n      } else if (interval[START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(interval[START], newInterval[START]);\\n        newInterval[END] = max(interval[END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        newInterval = interval;\\n      }\\n    }\\n    ans.push_back(newInterval);\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515974,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i = 0, n = intervals.size();\\n        while(i < n && intervals[i][1] < newInterval[0]) result.push_back(intervals[i++]);\\n        \\n        vector<int> mI = newInterval;\\n        while(i < n && intervals[i][0] <= newInterval[1]){\\n            mI[0] = min(mI[0], intervals[i][0]);\\n            mI[1] = max(mI[1], intervals[i++][1]);\\n        }\\n        result.push_back(mI);\\n        \\n        while(i < n) result.push_back(intervals[i++]);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i = 0, n = intervals.size();\\n        while(i < n && intervals[i][1] < newInterval[0]) result.push_back(intervals[i++]);\\n        \\n        vector<int> mI = newInterval;\\n        while(i < n && intervals[i][0] <= newInterval[1]){\\n            mI[0] = min(mI[0], intervals[i][0]);\\n            mI[1] = max(mI[1], intervals[i++][1]);\\n        }\\n        result.push_back(mI);\\n        \\n        while(i < n) result.push_back(intervals[i++]);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451390,
                "title": "interval-simple-solution-o-n-time-c",
                "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] ni) {\\n        \\n        int i=0, n=intervals.length;\\n        \\n        LinkedList<int []> res=new LinkedList<>();\\n        \\n        while(i<n && ni[0]>intervals[i][1])\\n        {\\n            res.add(intervals[i++]);\\n        }\\n        \\n        while(i <n && intervals[i][0]<=ni[1])\\n        {\\n            ni[0]=Math.min(intervals[i][0],ni[0]);\\n            ni[1]=Math.max(intervals[i][1],ni[1]);\\n            i++;\\n        }\\n        \\n        res.add(ni);\\n        \\n        while(i<n)\\n        {\\n            res.add(intervals[i++]);\\n        }\\n        \\n        return res.toArray(new int[res.size()][2]);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] ni) {\\n        \\n        int i=0, n=intervals.length;\\n        \\n        LinkedList<int []> res=new LinkedList<>();\\n        \\n        while(i<n && ni[0]>intervals[i][1])\\n        {\\n            res.add(intervals[i++]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1441307,
                "title": "python3-o-n-concise-solution-99-9-binary-search-merge-intervals",
                "content": "**Explanation**\\nSince the given intervals is already in sorted order, we can use binary search to find the insertion point. Then, merge the interval if necessary.\\n\\nTime complexity: O(N)\\nSpace complexity: O(N)\\n\\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        i = bisect.bisect_left(intervals, newInterval)\\n        res = intervals[:i]\\n        for interval in [newInterval]+intervals[i:]:\\n            if res and res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        i = bisect.bisect_left(intervals, newInterval)\\n        res = intervals[:i]\\n        for interval in [newInterval]+intervals[i:]:\\n            if res and res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347799,
                "title": "java-solution-easy-to-understand",
                "content": "**Runtime: 1 ms\\nMemory Usage: 41.4 MB**\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        LinkedList<int[]> list = new LinkedList();\\n        \\n        int idx = 0;\\n        \\n        while(idx < intervals.length && intervals[idx][0] < newInterval[0]){\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        if(list.size() == 0 || list.getLast()[1] <  newInterval[0]){\\n            list.add(newInterval);\\n        }else{\\n            list.getLast()[1] = Math.max(list.getLast()[1],newInterval[1]);\\n        }\\n        \\n        while(idx < intervals.length){\\n            if(list.getLast()[1] < intervals[idx][0])list.add(intervals[idx]);\\n            else list.getLast()[1] = Math.max(list.getLast()[1],intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        return list.toArray(new int[list.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        LinkedList<int[]> list = new LinkedList();\\n        \\n        int idx = 0;\\n        \\n        while(idx < intervals.length && intervals[idx][0] < newInterval[0]){\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        if(list.size() == 0 || list.getLast()[1] <  newInterval[0]){\\n            list.add(newInterval);\\n        }else{\\n            list.getLast()[1] = Math.max(list.getLast()[1],newInterval[1]);\\n        }\\n        \\n        while(idx < intervals.length){\\n            if(list.getLast()[1] < intervals[idx][0])list.add(intervals[idx]);\\n            else list.getLast()[1] = Math.max(list.getLast()[1],intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        return list.toArray(new int[list.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295056,
                "title": "javascript-very-easy-to-understand",
                "content": "```\\nvar insert = function(intervals, newInterval) {\\n    const result = [newInterval];\\n    for (const interval of intervals) {\\n        const last = result.pop();\\n        if (last[1] < interval[0]) {\\n\\t\\t // last comes before current interval\\n            result.push(last);\\n            result.push(interval)\\n        } else if (last[0] > interval[1]) {\\n\\t\\t// last comes after current interval\\n            result.push(interval);\\n            result.push(last)\\n        } else {\\n\\t\\t// intersection\\n            result.push([Math.min(last[0], interval[0]), Math.max(last[1], interval[1])])\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insert = function(intervals, newInterval) {\\n    const result = [newInterval];\\n    for (const interval of intervals) {\\n        const last = result.pop();\\n        if (last[1] < interval[0]) {\\n\\t\\t // last comes before current interval\\n            result.push(last);\\n            result.push(interval)\\n        } else if (last[0] > interval[1]) {\\n\\t\\t// last comes after current interval\\n            result.push(interval);\\n            result.push(last)\\n        } else {\\n\\t\\t// intersection\\n            result.push([Math.min(last[0], interval[0]), Math.max(last[1], interval[1])])\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239530,
                "title": "first-attempt-efficient-solution",
                "content": "First Attempt, which is O(n)\\n```\\nvar insert = function(intervals, newInterval) {\\n    const size = intervals.length;\\n    const [start, end] = newInterval;\\n    \\n    const overlap = (interval) => {\\n        const [first, last] = interval;\\n        //3...5    <-first, last\\n        //  4....8 <-start, end\\n        if(start <= last &&  end >= last) return true;\\n        //1...5 <-first, last\\n        // 2.3  <-start, end\\n        return (first <= end && last >= end);\\n    }\\n    \\n    const overlaps = intervals.map(overlap);\\n    const result = [];\\n\\t\\n\\t//push left\\n    let i = 0;\\n    while(i < size && overlaps[i] === false && intervals[i][0] < end) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n\\t//merge overlaps\\n    let min = start;\\n    let max = end;\\n    while(i < size && overlaps[i]) {\\n        min = Math.min(min, intervals[i][0]);\\n        max = Math.max(max, intervals[i][1]);\\n        i++;\\n    }\\n    \\n    result.push([min, max]);\\n    \\n\\t//push right\\n    while(i < size) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n    return result;\\n};\\n```\\n\\nThis can be solved in one single pass\\n```\\nvar insert = function(intervals, newInterval) {\\n    const [start, end] = newInterval;\\n    const left = [];\\n    const right = [];\\n    let min = start;\\n    let max = end;\\n    \\n    for(const interval of intervals) {\\n        const [first, last] = interval;\\n        if(last < start) {\\n            left.push(interval);\\n        } else if(first > end) {\\n            right.push(interval);\\n        } else {\\n            min = Math.min(min, first);\\n            max = Math.max(max, last);\\n        }\\n    }\\n    \\n    return [...left, [min, max], ...right];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insert = function(intervals, newInterval) {\\n    const size = intervals.length;\\n    const [start, end] = newInterval;\\n    \\n    const overlap = (interval) => {\\n        const [first, last] = interval;\\n        //3...5    <-first, last\\n        //  4....8 <-start, end\\n        if(start <= last &&  end >= last) return true;\\n        //1...5 <-first, last\\n        // 2.3  <-start, end\\n        return (first <= end && last >= end);\\n    }\\n    \\n    const overlaps = intervals.map(overlap);\\n    const result = [];\\n\\t\\n\\t//push left\\n    let i = 0;\\n    while(i < size && overlaps[i] === false && intervals[i][0] < end) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n\\t//merge overlaps\\n    let min = start;\\n    let max = end;\\n    while(i < size && overlaps[i]) {\\n        min = Math.min(min, intervals[i][0]);\\n        max = Math.max(max, intervals[i][1]);\\n        i++;\\n    }\\n    \\n    result.push([min, max]);\\n    \\n\\t//push right\\n    while(i < size) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n    return result;\\n};\\n```\n```\\nvar insert = function(intervals, newInterval) {\\n    const [start, end] = newInterval;\\n    const left = [];\\n    const right = [];\\n    let min = start;\\n    let max = end;\\n    \\n    for(const interval of intervals) {\\n        const [first, last] = interval;\\n        if(last < start) {\\n            left.push(interval);\\n        } else if(first > end) {\\n            right.push(interval);\\n        } else {\\n            min = Math.min(min, first);\\n            max = Math.max(max, last);\\n        }\\n    }\\n    \\n    return [...left, [min, max], ...right];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166865,
                "title": "python-easy-o-n",
                "content": "```\\n        s, e = newInterval[0], newInterval[1]\\n        merge, left, right = [], [], []\\n        \\n        for i in intervals:\\n            if i[1] < s:\\n                left.append(i)\\n            elif e < i[0]:\\n                right.append(i)\\n            else:\\n                merge.append(i)\\n\\n        if merge:\\n            s = min(s, merge[0][0])\\n            e = max(e, merge[-1][1])\\n        return left + [[s,e]]+ right\\n```",
                "solutionTags": [],
                "code": "```\\n        s, e = newInterval[0], newInterval[1]\\n        merge, left, right = [], [], []\\n        \\n        for i in intervals:\\n            if i[1] < s:\\n                left.append(i)\\n            elif e < i[0]:\\n                right.append(i)\\n            else:\\n                merge.append(i)\\n\\n        if merge:\\n            s = min(s, merge[0][0])\\n            e = max(e, merge[-1][1])\\n        return left + [[s,e]]+ right\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140661,
                "title": "java-1ms-99-faster",
                "content": "```\\n public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        \\n        for(int[] interval: intervals){\\n            if(interval[1] < newInterval[0])\\n                list.add(interval);\\n            else if(interval[0] > newInterval[1]){\\n                list.add(newInterval);\\n                newInterval = interval;\\n            }else {\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        \\n        for(int[] interval: intervals){\\n            if(interval[1] < newInterval[0])\\n                list.add(interval);\\n            else if(interval[0] > newInterval[1]){\\n                list.add(newInterval);\\n                newInterval = interval;\\n            }else {\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947241,
                "title": "python3-simple-easy-solution",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals += [newInterval]\\n        intervals.sort()\\n        merge = []\\n        for interval in intervals:\\n            if not merge or merge[-1][1] < interval[0]:\\n                merge.append(interval)\\n            else:\\n                merge[-1][1] = max(merge[-1][1], interval[1])\\n        return merge\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals += [newInterval]\\n        intervals.sort()\\n        merge = []\\n        for interval in intervals:\\n            if not merge or merge[-1][1] < interval[0]:\\n                merge.append(interval)\\n            else:\\n                merge[-1][1] = max(merge[-1][1], interval[1])\\n        return merge\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844488,
                "title": "python-3-o-n-insert-intervals-easy-math-solution",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        leftList, rightList=[],[]\\n        START,END=0,1\\n        \\n        for currentInterval in intervals:\\n            if currentInterval[END]< newInterval[START]:\\n                leftList+= [currentInterval]\\n            \\n            elif currentInterval[START]> newInterval[END]:\\n                rightList+=[currentInterval]\\n            \\n            else:\\n                newInterval[START]= min(currentInterval[START],newInterval[START])\\n                newInterval[END]= max(currentInterval[END], newInterval[END])\\n        \\n        return leftList + [[newInterval[START], newInterval[END]]] + rightList\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        leftList, rightList=[],[]\\n        START,END=0,1\\n        \\n        for currentInterval in intervals:\\n            if currentInterval[END]< newInterval[START]:\\n                leftList+= [currentInterval]\\n            \\n            elif currentInterval[START]> newInterval[END]:\\n                rightList+=[currentInterval]\\n            \\n            else:\\n                newInterval[START]= min(currentInterval[START],newInterval[START])\\n                newInterval[END]= max(currentInterval[END], newInterval[END])\\n        \\n        return leftList + [[newInterval[START], newInterval[END]]] + rightList\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 790477,
                "title": "python-binary-search-o-n-time-o-1-space",
                "content": "Hello,\\n\\nHere are my two solutions. The analysis follows. \\n\\t- Solution 1: `\\u0398(n)`time and `O(1)` space\\n\\t- Solution 2: `O(logn)`best time,`O(n)`worst time and`O(n)`space: see Complexity Analsysis below.\\n\\n- **Intuition**:\\n\\t\\t\\t\\n\\t\\t\\t- Binary Search : find the intervals new_interval overlap with : insert_start=i, insert_end=j :\\n\\t\\t\\tIntervals :              |---0---| ... |--i-1--||---i---|  ... |---j---||--j+1--|  ... |---n---| \\n\\t\\t\\tnew_interval :                                     |--------------|\\n\\t\\t\\t\\n\\t\\t\\t- Update new_interval :\\n\\t\\t\\tIntervals :              |---0---| ... |--i-1--||---i---|  ... |---j---||--j+1--|  ... |---n---| \\n\\t\\t\\tnew_interval :                                  |----------------------|\\n\\t\\t\\t\\n\\t\\t\\t- Return [0 : i[ + new_interval + ]j : n] :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t |---0---| ... |--i-1--||----------------------||--j+1--|  ... |---n---| \\n\\n- **Implementation**:\\n\\n```\\ndef __init__(self):\\n\\tself._start, self._end = 0, 1 # interval start and end indexes\\n\\ndef _binary_search(self, intervals: List[List[int]], val, l=0, r=None):\\n\\tif r is None:\\n\\t\\tr = len(intervals) - 1\\n\\t\\n\\twhile l <= r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tif intervals[mid][self._start] <= val <= intervals[mid][self._end]:\\n\\t\\t\\treturn mid\\n            \\n\\t\\telif val > intervals[mid][self._end]:\\n\\t\\t\\tl = mid + 1\\n                \\n\\t\\telse:\\n\\t\\t\\tr = mid - 1\\n        \\n\\treturn l\\n\\n# Solution 1:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\n\\tintervals_count = len(intervals)\\n\\t\\n\\t# 1. Search the interval where new_interval.start fits in: O(logn) time\\n\\tval = new_interval[self._start]\\n\\tinsert_start = self._binary_search(intervals, val)\\n\\tif insert_start < intervals_count and intervals[insert_start][self._start] <= val <= intervals[insert_start][self._end]:\\n\\t\\tnew_interval[self._start] = intervals[insert_start][self._start]\\n\\t\\tnew_interval[self._end] = max(intervals[insert_start][self._end], new_interval[self._end])        \\n\\t\\n\\t# 2. Search the interval where new_interval.end fits in: O(logn) time\\n\\tval = new_interval[self._end]\\n\\tinsert_end = self._binary_search(intervals, val, insert_start)\\n\\tif insert_end < intervals_count and intervals[insert_end][self._start] <= val:\\n\\t\\tnew_interval[self._end] = max(intervals[insert_end][self._end], new_interval[self._end])\\n\\t\\tinsert_end += 1\\n\\t\\n\\t# 3. Replace overlapping intervals with new_interval: O(n) time and O(1) space\\n\\tintervals[insert_start:insert_end] = [new_interval]\\n\\t\\n\\treturn intervals\\n\\n```\\n\\n```\\n# Solution 2:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\t# Same as above\\n\\t# ...\\n\\t\\n\\t# 3. Create new merged_intervals list: O(n) time in worst case and O(n) space\\n\\tmerged_intervals = intervals[:insert_start]       # Insert all intervals before insert_start\\n    merged_intervals.append(new_interval)             # Insert new_interval\\n    merged_intervals.extend(intervals[insert_end:])   # Insert all intervals after insert_end\\n\\t\\n\\treturn merged_intervals\\n\\t\\n```\\n\\n- **Complexity Analysis**:\\n\\t- Let\\'s `n` be the length of the input list `intervals`\\n\\t- Let\\'s `m` be the length of the output list\\n\\t- Solution 1:\\n\\t\\t- The input is modified and returned\\n\\t\\t- Space Complexity: `O(1)` \\n\\t\\t- Time Complexity: `O(n)`\\n\\t\\t- It requires to delete from`intervals`all overlapping intervals\\n\\t- Solution 2:\\n\\t\\t- A new list is returned\\n\\t\\t- Space Complexity:`O(m)` \\n\\t\\t- Time Complexity:`\\u0398(max(logn, m)) = O(n)`(here `n` is an upper-bound only)\\n\\t\\t- The worst case time complexity is`O(n)`: happens for example when`new_interval`doesn\\'t overlap with`intervals`\\n\\t\\t- The best case time complexity is`O(logn)`: happens for example when`new_interval`overlaps whith the majority of`intervals`, more than`n - logn`\\n\\t\\t- In practice, this solution is faster than solution 1\\n\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef __init__(self):\\n\\tself._start, self._end = 0, 1 # interval start and end indexes\\n\\ndef _binary_search(self, intervals: List[List[int]], val, l=0, r=None):\\n\\tif r is None:\\n\\t\\tr = len(intervals) - 1\\n\\t\\n\\twhile l <= r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tif intervals[mid][self._start] <= val <= intervals[mid][self._end]:\\n\\t\\t\\treturn mid\\n            \\n\\t\\telif val > intervals[mid][self._end]:\\n\\t\\t\\tl = mid + 1\\n                \\n\\t\\telse:\\n\\t\\t\\tr = mid - 1\\n        \\n\\treturn l\\n\\n# Solution 1:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\n\\tintervals_count = len(intervals)\\n\\t\\n\\t# 1. Search the interval where new_interval.start fits in: O(logn) time\\n\\tval = new_interval[self._start]\\n\\tinsert_start = self._binary_search(intervals, val)\\n\\tif insert_start < intervals_count and intervals[insert_start][self._start] <= val <= intervals[insert_start][self._end]:\\n\\t\\tnew_interval[self._start] = intervals[insert_start][self._start]\\n\\t\\tnew_interval[self._end] = max(intervals[insert_start][self._end], new_interval[self._end])        \\n\\t\\n\\t# 2. Search the interval where new_interval.end fits in: O(logn) time\\n\\tval = new_interval[self._end]\\n\\tinsert_end = self._binary_search(intervals, val, insert_start)\\n\\tif insert_end < intervals_count and intervals[insert_end][self._start] <= val:\\n\\t\\tnew_interval[self._end] = max(intervals[insert_end][self._end], new_interval[self._end])\\n\\t\\tinsert_end += 1\\n\\t\\n\\t# 3. Replace overlapping intervals with new_interval: O(n) time and O(1) space\\n\\tintervals[insert_start:insert_end] = [new_interval]\\n\\t\\n\\treturn intervals\\n\\n```\n```\\n# Solution 2:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\t# Same as above\\n\\t# ...\\n\\t\\n\\t# 3. Create new merged_intervals list: O(n) time in worst case and O(n) space\\n\\tmerged_intervals = intervals[:insert_start]       # Insert all intervals before insert_start\\n    merged_intervals.append(new_interval)             # Insert new_interval\\n    merged_intervals.extend(intervals[insert_end:])   # Insert all intervals after insert_end\\n\\t\\n\\treturn merged_intervals\\n\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 637718,
                "title": "java-o-n-clean-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        int idx = 0;\\n        \\n        while (idx < intervals.length && intervals[idx][1] < newInterval[0]) {\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        int mn = newInterval[0];\\n        int mx = newInterval[1];\\n        \\n        while (idx < intervals.length && mx >= intervals[idx][0]) {\\n            mn = Math.min(mn, intervals[idx][0]);\\n            mx = Math.max(mx, intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        list.add(new int[] { mn, mx });\\n        list.addAll(Arrays.asList(intervals).subList(idx, intervals.length));\\n        \\n        return list.stream().toArray(int[][]::new);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        int idx = 0;\\n        \\n        while (idx < intervals.length && intervals[idx][1] < newInterval[0]) {\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        int mn = newInterval[0];\\n        int mx = newInterval[1];\\n        \\n        while (idx < intervals.length && mx >= intervals[idx][0]) {\\n            mn = Math.min(mn, intervals[idx][0]);\\n            mx = Math.max(mx, intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        list.add(new int[] { mn, mx });\\n        list.addAll(Arrays.asList(intervals).subList(idx, intervals.length));\\n        \\n        return list.stream().toArray(int[][]::new);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442034,
                "title": "clear-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        if (intervals == null || newInterval == null || newInterval.length == 0) return null;\\n        if (intervals.length == 0) return new int[][]{newInterval};\\n        \\n        List<int[]> result = new ArrayList<>();\\n        boolean alreadyDone = false;\\n        \\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][1] < newInterval[0]) {\\n                result.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                if (!alreadyDone) {\\n                    result.add(newInterval);\\n                    alreadyDone = true;\\n                }\\n                result.add(intervals[i]);\\n            } else {\\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        \\n        if (!alreadyDone) {\\n            result.add(newInterval);\\n        }\\n        \\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        if (intervals == null || newInterval == null || newInterval.length == 0) return null;\\n        if (intervals.length == 0) return new int[][]{newInterval};\\n        \\n        List<int[]> result = new ArrayList<>();\\n        boolean alreadyDone = false;\\n        \\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][1] < newInterval[0]) {\\n                result.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                if (!alreadyDone) {\\n                    result.add(newInterval);\\n                    alreadyDone = true;\\n                }\\n                result.add(intervals[i]);\\n            } else {\\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        \\n        if (!alreadyDone) {\\n            result.add(newInterval);\\n        }\\n        \\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369471,
                "title": "easy-python-solution-insert-and-merge-in-place",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        size = len(intervals)\\n        \\n\\t\\t#Insert newInterval into intervals to keep sorted order\\n        for i, interval in enumerate(intervals):\\n            if newInterval[0] <= interval[0]:\\n                intervals.insert(i, newInterval)\\n                break\\n        \\n        #If the interval hasn\\'t been added yet\\n        if size == len(intervals):\\n            intervals.append(newInterval)\\n        \\n        i = 1\\n        while i < len(intervals):\\n            #Merge if previous interval\\'s end is >= to current interval\\'s start\\n            if intervals[i-1][1] >= intervals[i][0]:\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n\\t\\t\\t\\t#Remove current because it was merged into previous\\n                intervals.pop(i) \\n                i -= 1\\n            i += 1\\n        \\n        return intervals\\n                \\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        size = len(intervals)\\n        \\n\\t\\t#Insert newInterval into intervals to keep sorted order\\n        for i, interval in enumerate(intervals):\\n            if newInterval[0] <= interval[0]:\\n                intervals.insert(i, newInterval)\\n                break\\n        \\n        #If the interval hasn\\'t been added yet\\n        if size == len(intervals):\\n            intervals.append(newInterval)\\n        \\n        i = 1\\n        while i < len(intervals):\\n            #Merge if previous interval\\'s end is >= to current interval\\'s start\\n            if intervals[i-1][1] >= intervals[i][0]:\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n\\t\\t\\t\\t#Remove current because it was merged into previous\\n                intervals.pop(i) \\n                i -= 1\\n            i += 1\\n        \\n        return intervals\\n                \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 304030,
                "title": "1ms-simple-java-solution-explained",
                "content": "The principle of this solution is to merge overlapping intervals inside the new one (if needed).\\nThen, the new interval is inserted inside the list only once at the right place.\\n\\n\\tclass Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tboolean added = false;\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif ((interval[1] < newInterval[0])) {      // Non-overlapping to the left\\n\\t\\t\\t\\t\\tresult.add(interval);                  // We can safely add the interval to the list\\n\\t\\t\\t\\t} else if (interval[0] > newInterval[1]) { // Non-overlapping to the right\\n\\t\\t\\t\\t\\tif (!added) {                          // Add the new interval only once\\n\\t\\t\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tresult.add(interval);\\n\\t\\t\\t\\t} else {                                   // Overlapping, update the new interval\\n\\t\\t\\t\\t\\tnewInterval[0] = Math.min(newInterval[0], interval[0]);\\n\\t\\t\\t\\t\\tnewInterval[1] = Math.max(newInterval[1], interval[1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!added) { // Only happens if newInterval is last\\n\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t}\\n\\t\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tboolean added = false;\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif ((interval[1] < newInterval[0])) {      // Non-overlapping to the left\\n\\t\\t\\t\\t\\tresult.add(interval);                  // We can safely add the interval to the list\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 245084,
                "title": "super-simple-golang-solution-8ms-beats-100",
                "content": "```\\nfunc insert(intervals []Interval, newInterval Interval) []Interval {\\n    var left,right []Interval\\n    for _,v := range intervals {\\n        if v.End < newInterval.Start {\\n            left =  append(left, v)\\n        } else if v.Start > newInterval.End {\\n            right = append(right, v)\\n        } else {\\n            newInterval.Start = min(newInterval.Start, v.Start)\\n            newInterval.End = max(newInterval.End, v.End)\\n        }\\n    }\\n    return append(append(left,newInterval),right...)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insert(intervals []Interval, newInterval Interval) []Interval {\\n    var left,right []Interval\\n    for _,v := range intervals {\\n        if v.End < newInterval.Start {\\n            left =  append(left, v)\\n        } else if v.Start > newInterval.End {\\n            right = append(right, v)\\n        } else {\\n            newInterval.Start = min(newInterval.Start, v.Start)\\n            newInterval.End = max(newInterval.End, v.End)\\n        }\\n    }\\n    return append(append(left,newInterval),right...)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21613,
                "title": "my-java-solution-pretty-simple-with-one-treemap",
                "content": "```\\npublic List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        TreeMap<Integer, Interval> treeMap = new TreeMap<>();\\n        for(Interval interval : intervals) {\\n            treeMap.put(interval.start, interval);\\n        }\\n        Interval cur = newInterval;\\n        \\n        while(treeMap.floorEntry(cur.end) != null && treeMap.floorEntry(cur.end).getValue().end >= cur.start) {\\n         \\n            if(treeMap.floorEntry(cur.start) != null && treeMap.floorEntry(cur.start).getValue().end >= cur.start) {\\n                Interval out = treeMap.floorEntry(cur.start).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.start));\\n                cur.start = out.start;\\n                cur.end = Math.max(cur.end, out.end);\\n            }else{\\n                Interval out = treeMap.floorEntry(cur.end).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.end));\\n                cur.end = Math.max(cur.end, out.end);\\n                cur.start = Math.min(cur.start, out.start);\\n            }\\n            \\n        }\\n        treeMap.put(cur.start, cur);\\n        return new ArrayList<>(treeMap.values());\\n    }",
                "solutionTags": [],
                "code": "```\\npublic List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        TreeMap<Integer, Interval> treeMap = new TreeMap<>();\\n        for(Interval interval : intervals) {\\n            treeMap.put(interval.start, interval);\\n        }\\n        Interval cur = newInterval;\\n        \\n        while(treeMap.floorEntry(cur.end) != null && treeMap.floorEntry(cur.end).getValue().end >= cur.start) {\\n         \\n            if(treeMap.floorEntry(cur.start) != null && treeMap.floorEntry(cur.start).getValue().end >= cur.start) {\\n                Interval out = treeMap.floorEntry(cur.start).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.start));\\n                cur.start = out.start;\\n                cur.end = Math.max(cur.end, out.end);\\n            }else{\\n                Interval out = treeMap.floorEntry(cur.end).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.end));\\n                cur.end = Math.max(cur.end, out.end);\\n                cur.start = Math.min(cur.start, out.start);\\n            }\\n            \\n        }\\n        treeMap.put(cur.start, cur);\\n        return new ArrayList<>(treeMap.values());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21733,
                "title": "a-very-short-c-solution-with-o-logn-search-is-it-clear-enough",
                "content": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        auto it1 = lower_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        auto it2 = upper_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        vector<Interval> r( intervals.begin(), it1 );\\n        auto it3 = ( it2 == intervals.begin() ) ? it2 : it2 - 1;\\n        Interval m( (it1 == it2) ? newInterval.start : min( it1->start, newInterval.start ),\\n                    (it1 == it2) ? newInterval.end   : max( it3->end, newInterval.end ) );\\n        r.push_back(m);\\n        r.insert(r.end(), it2, intervals.end());\\n        return r;\\n    }\\n\\nIs this C++ solution clear enough?",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        auto it1 = lower_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        auto it2 = upper_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        vector<Interval> r( intervals.begin(), it1 );\\n        auto it3 = ( it2 == intervals.begin() ) ? it2 : it2 - 1;\\n        Interval m( (it1 == it2) ? newInterval.start : min( it1->start, newInterval.start ),\\n                    (it1 == it2) ? newInterval.end   : max( it3->end, newInterval.end ) );\\n        r.push_back(m);\\n        r.insert(r.end(), it2, intervals.end());\\n        return r;\\n    }\\n\\nIs this C++ solution clear enough?",
                "codeTag": "Unknown"
            },
            {
                "id": 21793,
                "title": "easy-java-solution",
                "content": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        int ids = 0;\\n        while (ids < intervals.size() && newInterval.start > intervals.get(ids).start) ids++;\\n        intervals.add(ids, newInterval);\\n        for (int i = 0; i < intervals.size() - 1; ++i) {\\n            if (intervals.get(i).end < intervals.get(i + 1).start) continue;\\n            intervals.get(i).start = Math.min(intervals.get(i).start, intervals.get(i + 1).start);\\n            intervals.get(i).end = Math.max(intervals.get(i).end, intervals.get(i + 1).end);\\n            intervals.remove(i + 1);\\n            i--;\\n        }\\n        return intervals;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        int ids = 0;\\n        while (ids < intervals.size() && newInterval.start > intervals.get(ids).start) ids++;\\n        intervals.add(ids, newInterval);\\n        for (int i = 0; i < intervals.size() - 1; ++i) {\\n            if (intervals.get(i).end < intervals.get(i + 1).start) continue;\\n            intervals.get(i).start = Math.min(intervals.get(i).start, intervals.get(i + 1).start);\\n            intervals.get(i).end = Math.max(intervals.get(i).end, intervals.get(i + 1).end);\\n            intervals.remove(i + 1);\\n            i--;\\n        }\\n        return intervals;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21702,
                "title": "c-code-use-binary-search",
                "content": "        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        if(intervals.empty()) {\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        \\n        int first=0, piv=0, count=intervals.size(), step = 0;\\n        while(count > 0) {  // lower bound of ends\\n            step = count/2; piv = first + step;\\n            if(intervals[piv].end < newInterval.start) {\\n                first = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        int last = first;\\n        count = intervals.size() - first;\\n        while(count > 0) {  // upper bound of starts\\n            step = count/2; piv = last + step;\\n            if(intervals[piv].start <= newInterval.end) {\\n                last = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        if(last == first)\\n            intervals.insert(intervals.begin()+first, newInterval);\\n        else {\\n            intervals[first].start = min(newInterval.start, intervals[first].start);\\n            intervals[first].end   = max(newInterval.end,   intervals[last-1].end);\\n            intervals.erase(intervals.begin()+(first+1), intervals.begin()+last);\\n        }\\n        \\n        return intervals;\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        if(intervals.empty()) {\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        \\n        int first=0, piv=0, count=intervals.size(), step = 0;\\n        while(count > 0) {  // lower bound of ends\\n            step = count/2; piv = first + step;\\n            if(intervals[piv].end < newInterval.start) {\\n                first = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        int last = first;\\n        count = intervals.size() - first;\\n        while(count > 0) {  // upper bound of starts\\n            step = count/2; piv = last + step;\\n            if(intervals[piv].start <= newInterval.end) {\\n                last = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        if(last == first)\\n            intervals.insert(intervals.begin()+first, newInterval);\\n        else {\\n            intervals[first].start = min(newInterval.start, intervals[first].start);\\n            intervals[first].end   = max(newInterval.end,   intervals[last-1].end);\\n            intervals.erase(intervals.begin()+(first+1), intervals.begin()+last);\\n        }\\n        \\n        return intervals;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21810,
                "title": "in-place-solution-ask-for-suggestion",
                "content": "I have done non in place insertion. Just want to try in place version because it seems faster and more memory efficient. Would like to ask for suggestion to see whether I can further improve it. Pass OJ already. But not guarantee it's bug free :P\\n  \\n    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {\\n        //inplace solution for interval insertion\\n        if(intervals.empty()){intervals.insert(intervals.begin(),newInterval);return intervals;}\\n        int l=0,r=(int)intervals.size()-1;\\n        Interval& n=newInterval;\\n    \\n        //binary search for the first interval x, such that x.start is larger than n.start\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].start<=n.start)l=m+1;\\n            else r=m-1;\\n        }\\n        int left=l;\\n        l=0,r=(int)intervals.size()-1;\\n        //binary search for the first interval x such that x.end is smaller than n.end\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].end<n.end)l=m+1;\\n            else r=m-1;\\n        }\\n        int right=r;\\n    \\n        //check right boundary\\n        if(right+1<intervals.size()&&intervals[right+1].start<=n.end)\\n            n.end=max(n.end,intervals[++right].end);\\n    \\n        //check left boundary\\n        if(left-1>=0&&n.start<=intervals[left-1].end)\\n            n.start=min(n.start,intervals[--left].start);\\n    \\n        //check and update\\n        if(right+1>=left){\\n            intervals.insert(intervals.begin()+left,n);\\n            intervals.erase(intervals.begin()+left+1,intervals.begin()+right+2);\\n        }\\n        return intervals;\\n    }",
                "solutionTags": [],
                "code": "I have done non in place insertion. Just want to try in place version because it seems faster and more memory efficient. Would like to ask for suggestion to see whether I can further improve it. Pass OJ already. But not guarantee it's bug free :P\\n  \\n    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {\\n        //inplace solution for interval insertion\\n        if(intervals.empty()){intervals.insert(intervals.begin(),newInterval);return intervals;}\\n        int l=0,r=(int)intervals.size()-1;\\n        Interval& n=newInterval;\\n    \\n        //binary search for the first interval x, such that x.start is larger than n.start\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].start<=n.start)l=m+1;\\n            else r=m-1;\\n        }\\n        int left=l;\\n        l=0,r=(int)intervals.size()-1;\\n        //binary search for the first interval x such that x.end is smaller than n.end\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].end<n.end)l=m+1;\\n            else r=m-1;\\n        }\\n        int right=r;\\n    \\n        //check right boundary\\n        if(right+1<intervals.size()&&intervals[right+1].start<=n.end)\\n            n.end=max(n.end,intervals[++right].end);\\n    \\n        //check left boundary\\n        if(left-1>=0&&n.start<=intervals[left-1].end)\\n            n.start=min(n.start,intervals[--left].start);\\n    \\n        //check and update\\n        if(right+1>=left){\\n            intervals.insert(intervals.begin()+left,n);\\n            intervals.erase(intervals.begin()+left+1,intervals.begin()+right+2);\\n        }\\n        return intervals;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4018688,
                "title": "insert-interval-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());   \\n        vector<int> temp = intervals[0];\\n        vector<vector<int> > ans;\\n\\n\\n        for(auto it : intervals)\\n        {\\n            if(temp[1] >= it[0])\\n            {\\n                temp[1] = max(temp[1],it[1]);\\n              \\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp = it;\\n            }\\n        }ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());   \\n        vector<int> temp = intervals[0];\\n        vector<vector<int> > ans;\\n\\n\\n        for(auto it : intervals)\\n        {\\n            if(temp[1] >= it[0])\\n            {\\n                temp[1] = max(temp[1],it[1]);\\n              \\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp = it;\\n            }\\n        }ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795785,
                "title": "very-easy-brute-force-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval[0],newInterval[1]});\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> v;\\n        for(int i = 0 ; i < intervals.size() ; i++)\\n        {\\n            int start = intervals[i][0];\\n            int end = intervals[i][1];\\n            if(!v.empty() && v.back()[1] >= end)\\n            {\\n                continue;\\n            }\\n            for(int j = i+1 ; j < intervals.size() ; j++)\\n            {\\n                if(intervals[j][0] <= end)\\n                {\\n                    end = max(end , intervals[j][1]);\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            v.push_back({start,end});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval[0],newInterval[1]});\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> v;\\n        for(int i = 0 ; i < intervals.size() ; i++)\\n        {\\n            int start = intervals[i][0];\\n            int end = intervals[i][1];\\n            if(!v.empty() && v.back()[1] >= end)\\n            {\\n                continue;\\n            }\\n            for(int j = i+1 ; j < intervals.size() ; j++)\\n            {\\n                if(intervals[j][0] <= end)\\n                {\\n                    end = max(end , intervals[j][1]);\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            v.push_back({start,end});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781818,
                "title": "simple-python-solution-using-insort",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insort(intervals, newInterval)\\n        ans = [intervals[0]]\\n        for s, e in intervals[1:]:\\n            if ans[-1][-1] >= s:\\n                ans[-1][-1] = max(ans[-1][-1], e)\\n            else:\\n                ans.append([s, e])\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insort(intervals, newInterval)\\n        ans = [intervals[0]]\\n        for s, e in intervals[1:]:\\n            if ans[-1][-1] >= s:\\n                ans[-1][-1] = max(ans[-1][-1], e)\\n            else:\\n                ans.append([s, e])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766731,
                "title": "simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        Stack<int[]> st = new Stack<>();\\n        int i= 0;\\n        int s = intervals.length;\\n        while(i<s && intervals[i][1]<newInterval[0]) st.push(intervals[i++]);\\n        while(i<s && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        st.push(newInterval);\\n        while(i<s) st.push(intervals[i++]);\\n      int[][] output = new int[st.size()][2];\\n      for(int j = output.length-1; j>=0; j--){\\n          output[j] = st.pop();\\n      }\\n      return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        Stack<int[]> st = new Stack<>();\\n        int i= 0;\\n        int s = intervals.length;\\n        while(i<s && intervals[i][1]<newInterval[0]) st.push(intervals[i++]);\\n        while(i<s && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        st.push(newInterval);\\n        while(i<s) st.push(intervals[i++]);\\n      int[][] output = new int[st.size()][2];\\n      for(int j = output.length-1; j>=0; j--){\\n          output[j] = st.pop();\\n      }\\n      return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492665,
                "title": "simplest-solution-easy-to-understand-c-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbreak a problem into parts\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nvector processing\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int n=intervals.size();\\n        int i=0;\\n        while(i<n && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n        vector<int>mi=newInterval;\\n        while(i<n && intervals[i][0]<=newInterval[1])\\n        {\\n            mi[0]=min(mi[0],intervals[i][0]);\\n            mi[1]=max(mi[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.push_back(mi);\\n        while(i<n)\\n        {\\n            result.push_back(intervals[i++]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int n=intervals.size();\\n        int i=0;\\n        while(i<n && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n        vector<int>mi=newInterval;\\n        while(i<n && intervals[i][0]<=newInterval[1])\\n        {\\n            mi[0]=min(mi[0],intervals[i][0]);\\n            mi[1]=max(mi[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.push_back(mi);\\n        while(i<n)\\n        {\\n            result.push_back(intervals[i++]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434453,
                "title": "absolutely-clear-and-simple-python-solution-o-n-beats-over-than-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only need modify intervals when an old interval intersect with new interval, that say in this 2 situations:\\n1. left value of old interval <= right value of new interval\\n2. right value of old interval >= left value of new interval\\n\\nBesides upon 2 situation, we just put old intervals into solutions.\\nHowever, in other cases, we would expand new interval.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nA little thing we sholud pay attention, is whether we met the intersection or not. So I use a variable \\'meet\\' to record it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        #-1: never met\\n        # 0: already interted to result\\n        # 1: met, but not interted to result yet\\n        meet = -1 \\n\\n        left = newInterval[0]\\n        right = newInterval[1]\\n        for interval in intervals:    \\n            if interval[1] < left:\\n                result.append(interval)\\n            elif interval[0] > right:\\n                if meet != 0:\\n                    result.append([left, right])\\n                    meet = 0\\n                result.append(interval)\\n            else:\\n                left = min(interval[0], left)\\n                right = max(interval[1], right)\\n                meet = 1\\n        if meet != 0:\\n            result.append([left, right])\\n        return result\\n```\\n\\nIt\\'s my first post, UPVOTE this if you like :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        #-1: never met\\n        # 0: already interted to result\\n        # 1: met, but not interted to result yet\\n        meet = -1 \\n\\n        left = newInterval[0]\\n        right = newInterval[1]\\n        for interval in intervals:    \\n            if interval[1] < left:\\n                result.append(interval)\\n            elif interval[0] > right:\\n                if meet != 0:\\n                    result.append([left, right])\\n                    meet = 0\\n                result.append(interval)\\n            else:\\n                left = min(interval[0], left)\\n                right = max(interval[1], right)\\n                meet = 1\\n        if meet != 0:\\n            result.append([left, right])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429077,
                "title": "java-solution-beats-100-o-n",
                "content": "\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        int l = 0;\\n        int r = n - 1;\\n        while (l < n && newInterval[0] > intervals[l][1]) {\\n            l++;\\n        }\\n        while (r >= 0 && newInterval[1] < intervals[r][0]) {\\n            r--;\\n        }\\n        int[][] res = new int[l + n - r][2];\\n        for (int i = 0; i < l; i++) {\\n            res[i] = Arrays.copyOf(intervals[i], intervals[i].length);\\n        }\\n        res[l][0] = Math.min(newInterval[0], l == n ? newInterval[0] : intervals[l][0]);\\n        res[l][1] = Math.max(newInterval[1], r == -1 ? newInterval[1] : intervals[r][1]);\\n        for (int i = l + 1, j = r + 1; j < n; i++, j++) {\\n            res[i] = intervals[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        int l = 0;\\n        int r = n - 1;\\n        while (l < n && newInterval[0] > intervals[l][1]) {\\n            l++;\\n        }\\n        while (r >= 0 && newInterval[1] < intervals[r][0]) {\\n            r--;\\n        }\\n        int[][] res = new int[l + n - r][2];\\n        for (int i = 0; i < l; i++) {\\n            res[i] = Arrays.copyOf(intervals[i], intervals[i].length);\\n        }\\n        res[l][0] = Math.min(newInterval[0], l == n ? newInterval[0] : intervals[l][0]);\\n        res[l][1] = Math.max(newInterval[1], r == -1 ? newInterval[1] : intervals[r][1]);\\n        for (int i = l + 1, j = r + 1; j < n; i++, j++) {\\n            res[i] = intervals[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142437,
                "title": "easy-python-solution-with-linear-time-complexity-100-working",
                "content": "\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                res.append(newInterval)\\n                return res+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                res.append(intervals[i])\\n            else:\\n                newInterval=(min(intervals[i][0],newInterval[0]),max(intervals[i][1],newInterval[1]))\\n        res.append(newInterval)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                res.append(newInterval)\\n                return res+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                res.append(intervals[i])\\n            else:\\n                newInterval=(min(intervals[i][0],newInterval[0]),max(intervals[i][1],newInterval[1]))\\n        res.append(newInterval)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060958,
                "title": "linear-explained-python3-beats-92-javascript-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intervals are sorted.\\nThere are intervals coming strictly before, after, and intersecting the new interval\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Partition the input intervals into three categories:\\n   - preceeding the new interval\\n   - intersecting the new interval, thus merged into one interval\\n   - following the new interval\\n2. Return these joined interval categories\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$, the space for the resulting intervals is not counted\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Python 3\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        start, end = newInterval\\n        prefix, suffix = [], []\\n        for i in intervals:\\n            if i[1] < start:\\n                prefix.append(i)\\n            elif i[0] > end:\\n                suffix.append(i)\\n            else:\\n                start, end = min(start, i[0]), max(end, i[1])\\n        return prefix + [[start, end]] + suffix\\n```\\n## JavaScript\\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let [start, end] = newInterval;\\n    const [prefix, suffix] = [[], []];\\n    for (const i of intervals) {\\n        if (i[1] < start) {\\n            prefix.push(i);\\n        } else if (i[0] > end) {\\n            suffix.push(i);\\n        } else {\\n            start = Math.min(start, i[0]);\\n            end = Math.max(end, i[1]);\\n        }\\n    }\\n    return [...prefix, [start, end], ...suffix];\\n};\\n```",
                "solutionTags": [
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        start, end = newInterval\\n        prefix, suffix = [], []\\n        for i in intervals:\\n            if i[1] < start:\\n                prefix.append(i)\\n            elif i[0] > end:\\n                suffix.append(i)\\n            else:\\n                start, end = min(start, i[0]), max(end, i[1])\\n        return prefix + [[start, end]] + suffix\\n```\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let [start, end] = newInterval;\\n    const [prefix, suffix] = [[], []];\\n    for (const i of intervals) {\\n        if (i[1] < start) {\\n            prefix.push(i);\\n        } else if (i[0] > end) {\\n            suffix.push(i);\\n        } else {\\n            start = Math.min(start, i[0]);\\n            end = Math.max(end, i[1]);\\n        }\\n    }\\n    return [...prefix, [start, end], ...suffix];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060893,
                "title": "c-solution-easy-and-simple-explanation-o-n-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere Three cases we have to consider \\nCase 1. Insert all the intervals that are non overlapping with the gievn newinterval.\\nCase 2. On finding the overlapping interval merge all the overlappig intervals.\\nCase 3. Insert all the remaining intervals after the overlapping intervals. \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> v;\\n        int n = intervals.size(), i = 0;\\n        // push all the intervals till non overlapping interval\\n        while(i < n && newInterval[0] > intervals[i][1])\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        // merging all the overlapping intervals\\n        while(i < n && newInterval[1] >= intervals[i][0])\\n        {\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        v.push_back(newInterval);\\n        // psuh all the remaining intervals after merging \\n        while(i < n)\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> v;\\n        int n = intervals.size(), i = 0;\\n        // push all the intervals till non overlapping interval\\n        while(i < n && newInterval[0] > intervals[i][1])\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        // merging all the overlapping intervals\\n        while(i < n && newInterval[1] >= intervals[i][0])\\n        {\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        v.push_back(newInterval);\\n        // psuh all the remaining intervals after merging \\n        while(i < n)\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1759866,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760304,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759735,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1572656,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760461,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760366,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759762,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1567828,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1818723,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760226,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759866,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760304,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759735,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1572656,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760461,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760366,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759762,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1567828,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1818723,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760226,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760727,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1868788,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1762258,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1574365,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1948131,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1761687,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 2062287,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1760761,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1760076,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1568879,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1944081,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760929,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760840,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760409,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759971,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759916,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759732,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759731,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1571142,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760371,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 2069722,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2067271,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2051636,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2045374,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2042915,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2039965,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2033587,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2028140,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2011437,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 1963552,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 1957718,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1954453,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1947263,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1944702,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1941307,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1935767,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1933469,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1921887,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1919335,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1906710,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1905777,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1904235,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1863143,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1832801,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1820519,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1804316,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1801891,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1792060,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1778869,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1766824,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1761800,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1761074,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1761047,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1761039,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760766,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760764,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760746,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760741,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760739,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760738,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760706,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760696,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760675,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760640,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760615,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760579,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760572,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760503,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760476,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760462,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760439,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760396,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760374,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760368,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760298,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760264,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760221,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760218,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760194,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760172,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760159,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760145,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760138,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760100,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760049,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759898,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759890,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759840,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759803,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759802,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            }
        ]
    },
    {
        "title": "Read N Characters Given Read4",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566981,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1570390,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1711494,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1568437,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1781628,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1567532,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1778199,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1773425,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1566981,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1570390,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1711494,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1568437,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1781628,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1567532,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1778199,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1773425,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Paths",
        "question_content": "<p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,5]\n<strong>Output:</strong> [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [&quot;1&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 68258,
                "title": "accepted-java-simple-solution-in-8-lines",
                "content": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> answer = new ArrayList<String>();\\n        if (root != null) searchBT(root, \"\", answer);\\n        return answer;\\n    }\\n    private void searchBT(TreeNode root, String path, List<String> answer) {\\n        if (root.left == null && root.right == null) answer.add(path + root.val);\\n        if (root.left != null) searchBT(root.left, path + root.val + \"->\", answer);\\n        if (root.right != null) searchBT(root.right, path + root.val + \"->\", answer);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> answer = new ArrayList<String>();\\n        if (root != null) searchBT(root, \"\", answer);\\n        return answer;\\n    }\\n    private void searchBT(TreeNode root, String path, List<String> answer) {\\n        if (root.left == null && root.right == null) answer.add(path + root.val);\\n        if (root.left != null) searchBT(root.left, path + root.val + \"->\", answer);\\n        if (root.right != null) searchBT(root.right, path + root.val + \"->\", answer);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68270,
                "title": "c-simple-4ms-recursive-solution",
                "content": "    void binaryTreePaths(vector<string>& result, TreeNode* root, string t) {\\n        if(!root->left && !root->right) {\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        if(root->left) binaryTreePaths(result, root->left, t + \"->\" + to_string(root->left->val));\\n        if(root->right) binaryTreePaths(result, root->right, t + \"->\" + to_string(root->right->val));\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        if(!root) return result;\\n        \\n        binaryTreePaths(result, root, to_string(root->val));\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    void binaryTreePaths(vector<string>& result, TreeNode* root, string t) {\\n        if(!root->left && !root->right) {\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        if(root->left) binaryTreePaths(result, root->left, t + \"->\" + to_string(root->left->val));\\n        if(root->right) binaryTreePaths(result, root->right, t + \"->\" + to_string(root->right->val));\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        if(!root) return result;\\n        \\n        binaryTreePaths(result, root, to_string(root->val));\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68272,
                "title": "python-solutions-dfs-stack-bfs-queue-dfs-recursively",
                "content": "```\\n        \\n    # dfs + stack\\n    def binaryTreePaths1(self, root):\\n        if not root:\\n            return []\\n        res, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.right:\\n                stack.append((node.right, ls+str(node.val)+\"->\"))\\n            if node.left:\\n                stack.append((node.left, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    # bfs + queue\\n    def binaryTreePaths2(self, root):\\n        if not root:\\n            return []\\n        res, queue = [], collections.deque([(root, \"\")])\\n        while queue:\\n            node, ls = queue.popleft()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.left:\\n                queue.append((node.left, ls+str(node.val)+\"->\"))\\n            if node.right:\\n                queue.append((node.right, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    # dfs recursively\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        self.dfs(root, \"\", res)\\n        return res\\n    \\n    def dfs(self, root, ls, res):\\n        if not root.left and not root.right:\\n            res.append(ls+str(root.val))\\n        if root.left:\\n            self.dfs(root.left, ls+str(root.val)+\"->\", res)\\n        if root.right:\\n            self.dfs(root.right, ls+str(root.val)+\"->\", res)\\n\\t\\t\\t\\n    def binaryTreePaths1(self, root):\\n        return self.dfs(root, \"\")\\n    \\n    def dfs(self, root, path):\\n        if not root:\\n            return []\\n        path += str(root.val)\\n        if not root.left and not root.right:\\n            return [path]\\n        path += \"->\"\\n        return self.dfs(root.left, path) + self.dfs(root.right, path)\\n    \\n    def binaryTreePaths(self, root): # inorder\\n        stack, ret = [(root, \"\")], []\\n        while stack:\\n            node, path = stack.pop()\\n            if node:\\n                if not node.left and not node.right:\\n                    ret.append(path+str(node.val))\\n                s = path + str(node.val) + \"->\"\\n                stack.append((node.right, s))\\n                stack.append((node.left, s))    \\n        return ret\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n        \\n    # dfs + stack\\n    def binaryTreePaths1(self, root):\\n        if not root:\\n            return []\\n        res, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.right:\\n                stack.append((node.right, ls+str(node.val)+\"->\"))\\n            if node.left:\\n                stack.append((node.left, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    # bfs + queue\\n    def binaryTreePaths2(self, root):\\n        if not root:\\n            return []\\n        res, queue = [], collections.deque([(root, \"\")])\\n        while queue:\\n            node, ls = queue.popleft()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.left:\\n                queue.append((node.left, ls+str(node.val)+\"->\"))\\n            if node.right:\\n                queue.append((node.right, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    # dfs recursively\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        self.dfs(root, \"\", res)\\n        return res\\n    \\n    def dfs(self, root, ls, res):\\n        if not root.left and not root.right:\\n            res.append(ls+str(root.val))\\n        if root.left:\\n            self.dfs(root.left, ls+str(root.val)+\"->\", res)\\n        if root.right:\\n            self.dfs(root.right, ls+str(root.val)+\"->\", res)\\n\\t\\t\\t\\n    def binaryTreePaths1(self, root):\\n        return self.dfs(root, \"\")\\n    \\n    def dfs(self, root, path):\\n        if not root:\\n            return []\\n        path += str(root.val)\\n        if not root.left and not root.right:\\n            return [path]\\n        path += \"->\"\\n        return self.dfs(root.left, path) + self.dfs(root.right, path)\\n    \\n    def binaryTreePaths(self, root): # inorder\\n        stack, ret = [(root, \"\")], []\\n        while stack:\\n            node, path = stack.pop()\\n            if node:\\n                if not node.left and not node.right:\\n                    ret.append(path+str(node.val))\\n                s = path + str(node.val) + \"->\"\\n                stack.append((node.right, s))\\n                stack.append((node.left, s))    \\n        return ret\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 68278,
                "title": "my-java-solution-in-dfs-bfs-recursion",
                "content": "recursion:\\n\\n    public class Solution {\\n    //Recursion\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> sList=new LinkedList<String>();\\n        //String s=new String();\\n        if (root==null) return sList;\\n        if (root.left==null && root.right==null) {\\n            sList.add(Integer.toString(root.val));\\n            return sList;\\n        }\\n        \\n        for (String s: binaryTreePaths(root.left)) {\\n            sList.add(Integer.toString(root.val)+\"->\"+s);\\n        }\\n        for (String s: binaryTreePaths(root.right)) {\\n            sList.add(Integer.toString(root.val)+\"->\"+s);\\n        }\\n        return sList;\\n    }\\n}\\n\\nBFS  - queue\\n\\n    public class Solution {\\n    //BFS - Queue\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list=new ArrayList<String>();\\n        Queue<TreeNode> qNode=new LinkedList<TreeNode>();\\n        Queue<String> qStr=new LinkedList<String>();\\n        \\n        if (root==null) return list;\\n        qNode.add(root);\\n        qStr.add(\"\");\\n        while(!qNode.isEmpty()) {\\n            TreeNode curNode=qNode.remove();\\n            String curStr=qStr.remove();\\n            \\n            if (curNode.left==null && curNode.right==null) list.add(curStr+curNode.val);\\n            if (curNode.left!=null) {\\n                qNode.add(curNode.left);\\n                qStr.add(curStr+curNode.val+\"->\");\\n            }\\n            if (curNode.right!=null) {\\n                qNode.add(curNode.right);\\n                qStr.add(curStr+curNode.val+\"->\");\\n            }\\n        }\\n        return list;\\n    }\\n    \\nDFS - stack\\n\\n    public class Solution {\\n    //DFS - Stack\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list=new ArrayList<String>();\\n        Stack<TreeNode> sNode=new Stack<TreeNode>();\\n        Stack<String> sStr=new Stack<String>();\\n        \\n        if(root==null) return list;\\n        sNode.push(root);\\n        sStr.push(\"\");\\n        while(!sNode.isEmpty()) {\\n            TreeNode curNode=sNode.pop();\\n            String curStr=sStr.pop();\\n            \\n            if(curNode.left==null && curNode.right==null) list.add(curStr+curNode.val);\\n            if(curNode.left!=null) {\\n                sNode.push(curNode.left);\\n                sStr.push(curStr+curNode.val+\"->\");\\n            }\\n            if(curNode.right!=null) {\\n                sNode.push(curNode.right);\\n                sStr.push(curStr+curNode.val+\"->\");\\n            }\\n        }\\n        return list;\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    //Recursion\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> sList=new LinkedList<String>();\\n        //String s=new String();\\n        if (root==null) return sList;\\n        if (root.left==null && root.right==null) {\\n            sList.add(Integer.toString(root.val));\\n            return sList;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68282,
                "title": "clean-java-solution-accepted-without-any-helper-recursive-function",
                "content": "Lot of recursive solutions on this forum involves creating a helper recursive function with added parameters. The added parameter which usually is of the type List<String> , carries the supplementary path information. However, the approach below doesn't use such a helper function.\\n\\n\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n            \\n            List<String> paths = new LinkedList<>();\\n    \\n            if(root == null) return paths;\\n            \\n            if(root.left == null && root.right == null){\\n                paths.add(root.val+\"\");\\n                return paths;\\n            }\\n    \\n             for (String path : binaryTreePaths(root.left)) {\\n                 paths.add(root.val + \"->\" + path);\\n             }\\n    \\n             for (String path : binaryTreePaths(root.right)) {\\n                 paths.add(root.val + \"->\" + path);\\n             }\\n    \\n             return paths;\\n            \\n        }",
                "solutionTags": [],
                "code": "Lot of recursive solutions on this forum involves creating a helper recursive function with added parameters. The added parameter which usually is of the type List<String> , carries the supplementary path information. However, the approach below doesn't use such a helper function.\\n\\n\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n            \\n            List<String> paths = new LinkedList<>();\\n    \\n            if(root == null) return paths;\\n            \\n            if(root.left == null && root.right == null){\\n                paths.add(root.val+\"\");\\n                return paths;\\n            }\\n    \\n             for (String path : binaryTreePaths(root.left)) {\\n                 paths.add(root.val + \"->\" + path);\\n             }\\n    \\n             for (String path : binaryTreePaths(root.right)) {\\n                 paths.add(root.val + \"->\" + path);\\n             }\\n    \\n             return paths;\\n            \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 671194,
                "title": "c-using-recursion-short-and-easy-to-understand",
                "content": "***Pls upvote if you find this helpful  :)***\\nThe basic idea is to traverse the tree keeping the path in the string **curr** and when you find a leaf then substituting curr in the answer.We need vector **answer** to be same in all the calls in the call stack, therefore we use address operator while we need separate curr for each step,hence not using address operator.\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,vector<string>& answer,string curr){\\n        if(!root)return;\\n        if(root->left||root->right)curr+=(to_string(root->val)+\"->\");\\n        else{\\n            curr+=(to_string(root->val));\\n            answer.push_back(curr);\\n        }\\n        helper(root->left,answer,curr);\\n        helper(root->right,answer,curr);  \\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> answer;\\n        string curr=\"\";\\n        helper(root,answer,curr);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,vector<string>& answer,string curr){\\n        if(!root)return;\\n        if(root->left||root->right)curr+=(to_string(root->val)+\"->\");\\n        else{\\n            curr+=(to_string(root->val));\\n            answer.push_back(curr);\\n        }\\n        helper(root->left,answer,curr);\\n        helper(root->right,answer,curr);  \\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> answer;\\n        string curr=\"\";\\n        helper(root,answer,curr);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68287,
                "title": "5-lines-recursive-python",
                "content": "    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        return [str(root.val) + '->' + path\\n                for kid in (root.left, root.right) if kid\\n                for path in self.binaryTreePaths(kid)] or [str(root.val)]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        return [str(root.val) + '->' + path\\n                for kid in (root.left, root.right) if kid\\n                for path in self.binaryTreePaths(kid)] or [str(root.val)]",
                "codeTag": "Python3"
            },
            {
                "id": 68265,
                "title": "java-solution-using-stringbuilder-instead-of-string-manipulation",
                "content": "\\n\\n    public class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> rst = new ArrayList<String>();\\n            if(root == null) return rst;\\n            StringBuilder sb = new StringBuilder();\\n            helper(rst, sb, root);\\n            return rst;\\n        }\\n        \\n        public void helper(List<String> rst, StringBuilder sb, TreeNode root){\\n            if(root == null) return;\\n            int tmp = sb.length();\\n            if(root.left == null && root.right == null){\\n                sb.append(root.val);\\n                rst.add(sb.toString());\\n                sb.delete(tmp , sb.length());\\n                return;\\n            }\\n            sb.append(root.val + \"->\");\\n            helper(rst, sb, root.left);\\n            helper(rst, sb, root.right);\\n            sb.delete(tmp , sb.length());\\n            return;\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> rst = new ArrayList<String>();\\n            if(root == null) return rst;\\n            StringBuilder sb = new StringBuilder();\\n            helper(rst, sb, root);\\n            return rst;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68279,
                "title": "c-non-recursive-version-and-recursive-version",
                "content": "    /*\\n    follow up: non-recursive version\\n    */\\n    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            stack<TreeNode*> s;\\n            stack<string> pathStack;\\n            s.push(root);\\n            pathStack.push(to_string(root->val));\\n            \\n            while (!s.empty()) {\\n                TreeNode * curNode = s.top(); s.pop();\\n                string tmpPath = pathStack.top(); pathStack.pop();\\n                \\n                if (curNode->left == NULL && curNode->right == NULL) {\\n                    res.push_back(tmpPath); continue;\\n                }\\n                \\n                if (curNode->left != NULL) {\\n                    s.push(curNode->left);\\n                    pathStack.push(tmpPath + \"->\" + to_string(curNode->left->val));\\n                }\\n                \\n                if (curNode->right != NULL) {\\n                    s.push(curNode->right);\\n                    pathStack.push(tmpPath + \"->\" + to_string(curNode->right->val));\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    };\\n    \\n    //recursive version\\n    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            dfs(root, to_string(root->val), res);\\n            return res;\\n        }\\n        \\n        void dfs(TreeNode* root, string path, vector<string>& res) {\\n            if (root->left == NULL && root->right == NULL) {\\n                res.push_back(path);\\n            }\\n            \\n            if (root->left != NULL)\\n                dfs(root->left, path + \"->\" + to_string(root->left->val), res);\\n            \\n            if (root->right != NULL)\\n                dfs(root->right, path + \"->\" + to_string(root->right->val), res);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            stack<TreeNode*> s;\\n            stack<string> pathStack;\\n            s.push(root);\\n            pathStack.push(to_string(root->val));\\n            \\n            while (!s.empty()) {\\n                TreeNode * curNode = s.top(); s.pop();\\n                string tmpPath = pathStack.top(); pathStack.pop();\\n                \\n                if (curNode->left == NULL && curNode->right == NULL) {\\n                    res.push_back(tmpPath); continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 68507,
                "title": "8-lines-in-python-48ms",
                "content": "    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        if not root.left and not root.right:\\n            return [str(root.val)]\\n        treepaths = [str(root.val)+'->'+path for path in self.binaryTreePaths(root.left)]\\n        treepaths += [str(root.val)+'->'+path for path in self.binaryTreePaths(root.right)]\\n        return treepaths",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        if not root.left and not root.right:\\n            return [str(root.val)]\\n        treepaths = [str(root.val)+'->'+path for path in self.binaryTreePaths(root.left)]\\n        treepaths += [str(root.val)+'->'+path for path in self.binaryTreePaths(root.right)]\\n        return treepaths",
                "codeTag": "Python3"
            },
            {
                "id": 68477,
                "title": "my-concise-java-dfs-solution",
                "content": "**Explanation**\\n\\nThis is just a classic problem to use depth first search algorithm.\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ArrayList<String> res = new ArrayList<String>();        \\n        DFS(root, \"\", res);\\n        return res;        \\n    }\\n    \\t\\n    public void DFS(TreeNode root, String solution, ArrayList<String> res) {\\n    \\tif (root == null) return;    \\t\\n    \\tif (root.left==null && root.right==null) res.add(solution + root.val);\\n    \\tDFS(root.left, solution + root.val + \"->\", res);    \\t\\n    \\tDFS(root.right, solution + root.val + \"->\", res);    \\t    \\t\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThis is just a classic problem to use depth first search algorithm.\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ArrayList<String> res = new ArrayList<String>();        \\n        DFS(root, \"\", res);\\n        return res;        \\n    }\\n    \\t\\n    public void DFS(TreeNode root, String solution, ArrayList<String> res) {\\n    \\tif (root == null) return;    \\t\\n    \\tif (root.left==null && root.right==null) res.add(solution + root.val);\\n    \\tDFS(root.left, solution + root.val + \"->\", res);    \\t\\n    \\tDFS(root.right, solution + root.val + \"->\", res);    \\t    \\t\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 68424,
                "title": "java-2ms-solution-using-stringbuilder",
                "content": "The time complexity for the problem should be O(n), since we are basically visiting each node in the tree. Yet an interviewer might ask you for further optimization when he or she saw a string concatenation. A string concatenation is just too costly. A StringBuilder can be used although a bit tricky since it is not immutable like string is.\\n\\nWhen using StringBuilder, We can just keep track of the length of the StringBuilder before we append anything to it before recursion and afterwards set the length back. Another trick is when to append the \"->\", since we don't need the last arrow at the end of the string, we only append it before recurse to the next level of the tree. Hope the solution helps!\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        helper(res, root, sb);\\n        return res;\\n    }\\n\\n    private void helper(List<String> res, TreeNode root, StringBuilder sb) {\\n        if(root == null) {\\n            return;\\n        }\\n        int len = sb.length();\\n        sb.append(root.val);\\n        if(root.left == null && root.right == null) {\\n            res.add(sb.toString());\\n        } else {\\n            sb.append(\"->\");\\n            helper(res, root.left, sb);\\n            helper(res, root.right, sb);\\n        }\\n        sb.setLength(len);\\n    }",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "The time complexity for the problem should be O(n), since we are basically visiting each node in the tree. Yet an interviewer might ask you for further optimization when he or she saw a string concatenation. A string concatenation is just too costly. A StringBuilder can be used although a bit tricky since it is not immutable like string is.\\n\\nWhen using StringBuilder, We can just keep track of the length of the StringBuilder before we append anything to it before recursion and afterwards set the length back. Another trick is when to append the \"->\", since we don't need the last arrow at the end of the string, we only append it before recurse to the next level of the tree. Hope the solution helps!\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        helper(res, root, sb);\\n        return res;\\n    }\\n\\n    private void helper(List<String> res, TreeNode root, StringBuilder sb) {\\n        if(root == null) {\\n            return;\\n        }\\n        int len = sb.length();\\n        sb.append(root.val);\\n        if(root.left == null && root.right == null) {\\n            res.add(sb.toString());\\n        } else {\\n            sb.append(\"->\");\\n            helper(res, root.left, sb);\\n            helper(res, root.right, sb);\\n        }\\n        sb.setLength(len);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 328264,
                "title": "simple-javascript-solution-with-explanation",
                "content": "This code does not pass around data within function parameters and is recursive with no helper functions.\\n\\n```\\nvar binaryTreePaths = function(root) {\\n\\t// If null return an empty array\\n    if (root === null) return [];\\n\\t// If no children return the nodes value itself as a string within an array\\n    else if (root.left === null && root.right === null) return [`${root.val}`];\\n    else {\\n\\t\\t// For all child paths add the root to their head one by one.\\n        let left = binaryTreePaths(root.left).map(x => root.val + \\'->\\' + x);\\n        let right = binaryTreePaths(root.right).map(x => root.val + \\'->\\' + x);\\n\\t\\t\\n\\t\\t// return the array with the root value attached\\n        return [...left, ...right];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar binaryTreePaths = function(root) {\\n\\t// If null return an empty array\\n    if (root === null) return [];\\n\\t// If no children return the nodes value itself as a string within an array\\n    else if (root.left === null && root.right === null) return [`${root.val}`];\\n    else {\\n\\t\\t// For all child paths add the root to their head one by one.\\n        let left = binaryTreePaths(root.left).map(x => root.val + \\'->\\' + x);\\n        let right = binaryTreePaths(root.right).map(x => root.val + \\'->\\' + x);\\n\\t\\t\\n\\t\\t// return the array with the root value attached\\n        return [...left, ...right];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68443,
                "title": "my-java-and-c-solution-c-4ms",
                "content": " this is a simple dfs+tree question,using preorder to visit tree will be fine.\\n \\nc++:\\n\\n     class Solution {\\n        public:\\n        \\n                vector<string> binaryTreePaths(TreeNode* root) {\\n                    vector<string> v;\\n                    if(root)\\n                        preorder(v,root,\"\");\\n                    return v;\\n                }\\n                void preorder(vector<string>& v,TreeNode* r,string t){\\n                    if(!r)\\n                        return;\\n                    if(!t.empty())\\n                        t+=(\"->\"+to_string(r->val));\\n                    else t+=to_string(r->val);\\n                    if(r->left||r->right){\\n                        preorder(v,r->left,t);\\n                        preorder(v,r->right,t);\\n                    }else{\\n                        v.push_back(t);\\n                    }\\n                }\\n            };\\n\\nmy java:\\n\\n    public class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> l=new ArrayList<>();\\n            if(root!=null)\\n                pre(l,root,\"\");\\n            return l;\\n        }\\n         void pre(List<String> l,TreeNode r,String s){\\n             if(r==null)return;\\n             if(s.isEmpty())\\n                s+=r.val;\\n            else s+=(\"->\"+r.val);\\n            if(r.left!=null||r.right!=null){\\n                pre(l,r.left,s);\\n                pre(l,r.right,s);\\n            }else\\n                l.add(s);\\n         }\\n    }",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "class Solution {\\n        public:\\n        \\n                vector<string> binaryTreePaths(TreeNode* root) {\\n                    vector<string> v;\\n                    if(root)\\n                        preorder(v,root,\"\");\\n                    return v;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 928068,
                "title": "dfs-js-solution",
                "content": "```\\nUsing String:\\nvar binaryTreePaths = function(root) {\\n    let paths = [];\\n    \\n    function dfsTraversal(root, cur) {\\n        if (!root) return;\\n        if (!root.left && !root.right) {\\n            paths.push(cur + root.val);\\n            return;\\n        }\\n        dfsTraversal(root.left, cur + root.val + \"->\");\\n        dfsTraversal(root.right, cur + root.val + \"->\");\\n    }\\n    \\n    dfsTraversal(root, \"\");\\n    return paths;\\n    // Time Complexity: O(N), we always visit all nodes\\n    // Space Complexity: O(H) or O(N), height can be at most N (in case of a skewed tree)\\n};\\n```\\n\\n```\\nUsing Array:\\nconst binaryTreePaths = (root) => {\\n  let paths = [];\\n  function dfsTraversal(curPath, root) {\\n    if (root === null) {\\n      return;\\n    }\\n    if (root.left === null && root.right === null) {\\n      paths.push([...curPath, root.val]);\\n      return;\\n    }\\n    dfsTraversal([...curPath, root.val], root.left);\\n    dfsTraversal([...curPath, root.val], root.right);\\n  }\\n  dfsTraversal([], root);\\n  return paths.map(path => path.join(\"->\"));\\n};\\n```\\n```\\nUsing only one array:\\nvar binaryTreePaths = function(root) {\\n  let paths = [];\\n  function dfsTraversal(curPath, root) {\\n    if (!root) return;\\n    curPath.push(root.val);\\n    if (root.left === null && root.right === null) {\\n      paths.push(curPath.join(\"->\"));\\n    }\\n    dfsTraversal(curPath, root.left);\\n    dfsTraversal(curPath, root.right);\\n    curPath.pop();\\n  }\\n  dfsTraversal([], root);\\n  return paths;\\n  // T.C: O(N)\\n  // S.C: O(H)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nUsing String:\\nvar binaryTreePaths = function(root) {\\n    let paths = [];\\n    \\n    function dfsTraversal(root, cur) {\\n        if (!root) return;\\n        if (!root.left && !root.right) {\\n            paths.push(cur + root.val);\\n            return;\\n        }\\n        dfsTraversal(root.left, cur + root.val + \"->\");\\n        dfsTraversal(root.right, cur + root.val + \"->\");\\n    }\\n    \\n    dfsTraversal(root, \"\");\\n    return paths;\\n    // Time Complexity: O(N), we always visit all nodes\\n    // Space Complexity: O(H) or O(N), height can be at most N (in case of a skewed tree)\\n};\\n```\n```\\nUsing Array:\\nconst binaryTreePaths = (root) => {\\n  let paths = [];\\n  function dfsTraversal(curPath, root) {\\n    if (root === null) {\\n      return;\\n    }\\n    if (root.left === null && root.right === null) {\\n      paths.push([...curPath, root.val]);\\n      return;\\n    }\\n    dfsTraversal([...curPath, root.val], root.left);\\n    dfsTraversal([...curPath, root.val], root.right);\\n  }\\n  dfsTraversal([], root);\\n  return paths.map(path => path.join(\"->\"));\\n};\\n```\n```\\nUsing only one array:\\nvar binaryTreePaths = function(root) {\\n  let paths = [];\\n  function dfsTraversal(curPath, root) {\\n    if (!root) return;\\n    curPath.push(root.val);\\n    if (root.left === null && root.right === null) {\\n      paths.push(curPath.join(\"->\"));\\n    }\\n    dfsTraversal(curPath, root.left);\\n    dfsTraversal(curPath, root.right);\\n    curPath.pop();\\n  }\\n  dfsTraversal([], root);\\n  return paths;\\n  // T.C: O(N)\\n  // S.C: O(H)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68536,
                "title": "three-4ms-c-solutions-given-recursion-dfs-stack-based-bfs-queue-based",
                "content": "(1)Recursion, if root is empty, return, if root is a leaf, then return cur+root->val, if root has childrens, then do recursion on each child, with cur updated to cur + root->val +\"->\"\\n\\n    class Solution {\\n        void dfs(vector<string> &res, TreeNode *root, string cur)\\n        {\\n            if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n            else\\n            {\\n                if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n                if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n            }\\n        }\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            if(root)  dfs(res, root, \"\");\\n            return res;\\n        }\\n    };\\n\\n(2) DFS Version using a stack\\nUsing a stack (the element is a pair of the current node pointer and the string recording the path from root to the current node). The logic is the same as (1)\\n\\n    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            TreeNode *curNode;\\n            string curPath;\\n            stack<pair<TreeNode*, string>> liveNodes;\\n            if(root) liveNodes.push(make_pair(root, \"\"));\\n            while(!liveNodes.empty())\\n            {\\n                curNode = liveNodes.top().first;\\n                curPath    = liveNodes.top().second;\\n                liveNodes.pop();\\n                if(!curNode->left && !curNode->right)\\n                {\\n                    res.push_back(curPath + std::to_string(curNode->val));\\n                }\\n                else\\n                {\\n                    if(curNode->left)  liveNodes.push(make_pair(curNode->left, curPath + std::to_string(curNode->val)+ \"->\"));\\n                    if(curNode->right) liveNodes.push(make_pair(curNode->right, curPath + std::to_string(curNode->val)+ \"->\"));\\n                }\\n            }\\n            return res;\\n        }\\n    };\\n\\n(3) BFS queue based solution.\\nIt prints all the paths in an ascending order of the path length\\n\\n    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            queue<pair<TreeNode*, string>> liveNodes[2];\\n            int cur=0, next=1;\\n            TreeNode* curNode;\\n            string curPath;\\n            vector<string> res;\\n            \\n            if(root) liveNodes[cur].push(make_pair(root, \"\"));\\n            while(!liveNodes[cur].empty())\\n            {\\n                curNode = liveNodes[cur].front().first;\\n                curPath = liveNodes[cur].front().second;\\n                liveNodes[cur].pop();\\n                if(!curNode->left && !curNode->right) res.push_back(curPath + std::to_string(curNode->val));\\n                else{\\n                    if(curNode->left)  liveNodes[next].push(make_pair(curNode->left,  curPath + std::to_string(curNode->val) + \"->\"));\\n                    if(curNode->right) liveNodes[next].push(make_pair(curNode->right, curPath + std::to_string(curNode->val) + \"->\"));\\n                }\\n                if(liveNodes[cur].empty()) swap(cur, next);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        void dfs(vector<string> &res, TreeNode *root, string cur)\\n        {\\n            if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n            else\\n            {\\n                if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n                if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 68364,
                "title": "4-lines-python-dfs",
                "content": "```\\nclass Solution:\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        result= [ str(root.val)+\"->\" + path for path in self.binaryTreePaths(root.left)]\\n        result+= [ str(root.val)+\"->\" + path for path in self.binaryTreePaths(root.right)]\\n        return result or [str(root.val)]  # if empty return leaf itself\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        result= [ str(root.val)+\"->\" + path for path in self.binaryTreePaths(root.left)]\\n        result+= [ str(root.val)+\"->\" + path for path in self.binaryTreePaths(root.right)]\\n        return result or [str(root.val)]  # if empty return leaf itself\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 827629,
                "title": "python-o-n-2-by-dfs-w-comment",
                "content": "Python O(n^2) by DFS \\n\\n---\\n\\n**Implementation**:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        \\n        result = []\\n        \\n        # ----------------------------------------\\n        def helper(node, cur):\\n            \\n            if not node:\\n                # base case\\n                return\\n            \\n            \\n            if not node.left and not node.right:\\n                # stop condition\\n                result.append( cur + [str(node.val)] )\\n                \\n            else:\\n                # general case\\n                helper(node.left, cur + [str(node.val)] )\\n                helper(node.right, cur + [str(node.val)] )\\n            \\n            \\n        # ----------------------------------------\\n        \\n        helper(node=root, cur=[])\\n        return [ *map(\\'->\\'.join, result) ]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        \\n        result = []\\n        \\n        # ----------------------------------------\\n        def helper(node, cur):\\n            \\n            if not node:\\n                # base case\\n                return\\n            \\n            \\n            if not node.left and not node.right:\\n                # stop condition\\n                result.append( cur + [str(node.val)] )\\n                \\n            else:\\n                # general case\\n                helper(node.left, cur + [str(node.val)] )\\n                helper(node.right, cur + [str(node.val)] )\\n            \\n            \\n        # ----------------------------------------\\n        \\n        helper(node=root, cur=[])\\n        return [ *map(\\'->\\'.join, result) ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68410,
                "title": "short-and-clear-c-dfs-solution",
                "content": "    vector<string> binaryTreePaths(TreeNode* root) {\\n    \\tvector<string> res;\\n    \\thelp(res, root, \"\");\\n    \\treturn res;\\n    }\\n    void help(vector<string>& res, TreeNode* root, string pre) {\\n    \\tif (!root)\\n    \\t\\treturn;\\n    \\tif (!root->left && !root->right) {\\n    \\t\\tres.push_back(pre + to_string(root->val));\\n    \\t\\treturn;\\n    \\t}\\n    \\thelp(res, root->left, pre + to_string(root->val) + \"->\");\\n    \\thelp(res, root->right, pre + to_string(root->val) + \"->\");\\n    }",
                "solutionTags": [],
                "code": "    vector<string> binaryTreePaths(TreeNode* root) {\\n    \\tvector<string> res;\\n    \\thelp(res, root, \"\");\\n    \\treturn res;\\n    }\\n    void help(vector<string>& res, TreeNode* root, string pre) {\\n    \\tif (!root)\\n    \\t\\treturn;\\n    \\tif (!root->left && !root->right) {\\n    \\t\\tres.push_back(pre + to_string(root->val));\\n    \\t\\treturn;\\n    \\t}\\n    \\thelp(res, root->left, pre + to_string(root->val) + \"->\");\\n    \\thelp(res, root->right, pre + to_string(root->val) + \"->\");\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3164442,
                "title": "python-simple-recursive-solution-beats-100",
                "content": "## Upvote if it helps !\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We iterate through left and right nodes until we get to a leaf.\\n    - We construct the string in the recursion. \\n    - During the recursion, we add ```->``` before the value of the node **only if it\\'s not the root**.\\n    - We add the string to the result only when we get to a leaf.  \\n\\n# Code\\n```\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        res = []\\n        \\n        def dfs(node, s):\\n            if s != \"\":\\n                s += \"->\"\\n            s += str(node.val)\\n            if not node.left and not node.right: res.append(s)\\n            if node.left: dfs(node.left, s)\\n            if node.right: dfs(node.right, s)\\n        dfs(root, \"\") \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```->```\n```\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        res = []\\n        \\n        def dfs(node, s):\\n            if s != \"\":\\n                s += \"->\"\\n            s += str(node.val)\\n            if not node.left and not node.right: res.append(s)\\n            if node.left: dfs(node.left, s)\\n            if node.right: dfs(node.right, s)\\n        dfs(root, \"\") \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799051,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\n    void dfs(vector<string> &res, TreeNode *root, string cur)\\n    {\\n        if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n        else\\n        {\\n            if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n            if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if(root)  dfs(res, root, \"\");\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<string> &res, TreeNode *root, string cur)\\n    {\\n        if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n        else\\n        {\\n            if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n            if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if(root)  dfs(res, root, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234676,
                "title": "c-easy-100-faster",
                "content": "```\\n\\tclass Solution {\\npublic:\\n    vector<string>ans1;\\n    \\n   void recurs(TreeNode* root,string ans)\\n    {\\n       if(root==NULL)\\n       {\\n           return ;\\n       }\\n    \\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans+=to_string(root->val);\\n            ans1.push_back(ans);\\n            return ;\\n        }\\n\\n            ans+=to_string(root->val)+\"->\";\\n       \\n        recurs(root->left,ans);\\n        recurs(root->right,ans);\\n    }\\n    \\n    \\n    \\n    \\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        recurs(root,\"\");\\n        \\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    vector<string>ans1;\\n    \\n   void recurs(TreeNode* root,string ans)\\n    {\\n       if(root==NULL)\\n       {\\n           return ;\\n       }\\n    \\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans+=to_string(root->val);\\n            ans1.push_back(ans);\\n            return ;\\n        }\\n\\n            ans+=to_string(root->val)+\"->\";\\n       \\n        recurs(root->left,ans);\\n        recurs(root->right,ans);\\n    }\\n    \\n    \\n    \\n    \\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        recurs(root,\"\");\\n        \\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602321,
                "title": "time-o-n-h-beats-99-43-space-o-h-beats-99-39-python-simple-explanation",
                "content": "**Time Complexity Explanation:** For every path - in the worst case we have (n/2 + 1) paths which happens when the tree is perfect - we iterate through each node in the path once in order to stringify the path. At worst, we will have h nodes in the path - where h is the height of the tree, and n is the total number of nodes in the tree. Therefore we get a time complexity of O((n/2 + 1) * h) = O(n * h).\\n\\n**Space Complexity Explanation:** This is trivial, we are using Depth-First Search, and an extra list which can contain at most h nodes - where h is the height of the tree. Therefore we get a space complexity of O(h).\\n\\nBelow is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def _dfs(self, root: Optional[TreeNode], cur, res) -> None:\\n        \\n        # Base Case\\n        if not root:\\n            return\\n        \\n        # Append node to path\\n        cur.append(str(root.val))\\n        \\n        # If root is a leaf, append path to result\\n        if not root.left and not root.right:\\n            res.append(\\'->\\'.join(cur))\\n            \\n        # Recursive Step\\n        self._dfs(root.left, cur, res)\\n        self._dfs(root.right, cur, res)\\n        \\n        # Backtracking / Post-processing / pop node from path\\n        cur.pop()\\n        \\n        \\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        res = []\\n        self._dfs(root, [], res)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def _dfs(self, root: Optional[TreeNode], cur, res) -> None:\\n        \\n        # Base Case\\n        if not root:\\n            return\\n        \\n        # Append node to path\\n        cur.append(str(root.val))\\n        \\n        # If root is a leaf, append path to result\\n        if not root.left and not root.right:\\n            res.append(\\'->\\'.join(cur))\\n            \\n        # Recursive Step\\n        self._dfs(root.left, cur, res)\\n        self._dfs(root.right, cur, res)\\n        \\n        # Backtracking / Post-processing / pop node from path\\n        cur.pop()\\n        \\n        \\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        res = []\\n        self._dfs(root, [], res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111611,
                "title": "javascript-dfs-solution",
                "content": "```\\nvar binaryTreePaths = function(root) {\\n    if(!root) return [];\\n    var result = [];\\n    function path(root, str){\\n        if(!root.left && !root.right) result.push(str + root.val);\\n        if(root.left) path(root.left, str + root.val + \"->\");\\n        if(root.right) path(root.right, str + root.val + \"->\");\\n    }\\n    path(root, \"\");\\n    return result;\\n};",
                "solutionTags": [],
                "code": "```\\nvar binaryTreePaths = function(root) {\\n    if(!root) return [];\\n    var result = [];\\n    function path(root, str){\\n        if(!root.left && !root.right) result.push(str + root.val);\\n        if(root.left) path(root.left, str + root.val + \"->\");\\n        if(root.right) path(root.right, str + root.val + \"->\");\\n    }\\n    path(root, \"\");\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 68441,
                "title": "python-easy-dfs-recursive-iterative-solution",
                "content": "Recursive:\\n\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        self.dfs(root, \"\", res)\\n        return res\\n    \\n    def dfs(self, node, path, res):\\n        if not node:\\n            return\\n        if not node.left and not node.right:\\n            res.append(\"{}{}\".format(path, node.val))\\n        self.dfs(node.left, \"{}{}->\".format(path, node.val), res)\\n        self.dfs(node.right, \"{}{}->\".format(path, node.val), res)\\n\\nIterative:\\n\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        stack = [(root, \"\")]\\n        while stack:\\n            node, path = stack.pop()\\n            if not node:\\n                continue\\n            if not node.left and not node.right:\\n                res.append(\"{}{}\".format(path,node.val))\\n            stack.append((node.left, \"{}{}->\".format(path,node.val)))\\n            stack.append((node.right, \"{}{}->\".format(path,node.val)))\\n        return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "Recursive:\\n\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        self.dfs(root, \"\", res)\\n        return res\\n    \\n    def dfs(self, node, path, res):\\n        if not node:\\n            return\\n        if not node.left and not node.right:\\n            res.append(\"{}{}\".format(path, node.val))\\n        self.dfs(node.left, \"{}{}->\".format(path, node.val), res)\\n        self.dfs(node.right, \"{}{}->\".format(path, node.val), res)\\n\\nIterative:\\n\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        stack = [(root, \"\")]\\n        while stack:\\n            node, path = stack.pop()\\n            if not node:\\n                continue\\n            if not node.left and not node.right:\\n                res.append(\"{}{}\".format(path,node.val))\\n            stack.append((node.left, \"{}{}->\".format(path,node.val)))\\n            stack.append((node.right, \"{}{}->\".format(path,node.val)))\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3476527,
                "title": "easy-o-n-c-solution-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Inbuilt Stack for Recursive calls\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<string>v;\\n    \\n    void solve(TreeNode* root,string s){\\n        if(!root){\\n            if(s!=\"\")\\n            return;\\n            else\\n            v.push_back(s);\\n            return;\\n        }\\n\\n        s=s+to_string(root->val)+\"->\";\\n        if(!root->left and !root->right){\\n            s=s.substr(0,s.size()-2);\\n            v.push_back(s);\\n        }\\n        if(root->left)\\n        solve(root->left,s);\\n        if(root->right)\\n        solve(root->right,s);\\n        \\n       \\n        \\n}\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string s=\"\";\\n        solve(root,s);\\n        return v;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<string>v;\\n    \\n    void solve(TreeNode* root,string s){\\n        if(!root){\\n            if(s!=\"\")\\n            return;\\n            else\\n            v.push_back(s);\\n            return;\\n        }\\n\\n        s=s+to_string(root->val)+\"->\";\\n        if(!root->left and !root->right){\\n            s=s.substr(0,s.size()-2);\\n            v.push_back(s);\\n        }\\n        if(root->left)\\n        solve(root->left,s);\\n        if(root->right)\\n        solve(root->right,s);\\n        \\n       \\n        \\n}\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string s=\"\";\\n        solve(root,s);\\n        return v;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247162,
                "title": "c-recursive-backtracking-iterative",
                "content": "The recursive idea is to get the paths of the `left` and `right` subtrees and append the `root` to them.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<string> paths, left, right;\\n        left = binaryTreePaths(root -> left);\\n        right = binaryTreePaths(root -> right);\\n        for (string l : left) {\\n            paths.push_back(to_string(root -> val) + (l.empty() ? \"\" : \"->\" + l));\\n        }\\n        for (string r : right) {\\n            paths.push_back(to_string(root -> val) + (r.empty() ? \"\" : \"->\" + r));\\n        }\\n        if (paths.empty()) {\\n            paths.push_back(to_string(root -> val));\\n        }\\n        return paths;\\n    }\\n};\\n```\\n\\nBacktracking can also be applied, which is basically a template solution.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> paths;\\n        string path;\\n        binaryTreePaths(root, path, paths);\\n        return paths;\\n    }\\nprivate:\\n    void binaryTreePaths(TreeNode* root, string path, vector<string>& paths) {\\n        if (!root) {\\n            return;\\n        }\\n        path += (path.empty() ? \"\" : \"->\") + to_string(root -> val);\\n        if (!root -> left && !root -> right) {\\n            paths.push_back(path);\\n        } else {\\n            binaryTreePaths(root -> left, path, paths);\\n            binaryTreePaths(root -> right, path, paths);\\n        }\\n    }\\n};\\n```\\n\\nOr we may solve it iteratively by storing each node and the path to it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<string> paths;\\n        queue<pair<TreeNode*, string>> todo;\\n        todo.push({root, to_string(root -> val)});\\n        while (!todo.empty()) {\\n            pair<TreeNode*, string> p = todo.front();\\n            todo.pop();\\n            TreeNode* node = p.first;\\n            string path = p.second;\\n            if (!node -> left && !node -> right) {\\n                paths.push_back(path);\\n            } else {\\n                if (node -> left) {\\n                    todo.push({node -> left, path + \"->\" + to_string(node -> left -> val)});\\n                }\\n                if (node -> right) {\\n                    todo.push({node -> right, path + \"->\" + to_string(node -> right -> val)});\\n                }\\n            }\\n        }\\n        return paths;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<string> paths, left, right;\\n        left = binaryTreePaths(root -> left);\\n        right = binaryTreePaths(root -> right);\\n        for (string l : left) {\\n            paths.push_back(to_string(root -> val) + (l.empty() ? \"\" : \"->\" + l));\\n        }\\n        for (string r : right) {\\n            paths.push_back(to_string(root -> val) + (r.empty() ? \"\" : \"->\" + r));\\n        }\\n        if (paths.empty()) {\\n            paths.push_back(to_string(root -> val));\\n        }\\n        return paths;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> paths;\\n        string path;\\n        binaryTreePaths(root, path, paths);\\n        return paths;\\n    }\\nprivate:\\n    void binaryTreePaths(TreeNode* root, string path, vector<string>& paths) {\\n        if (!root) {\\n            return;\\n        }\\n        path += (path.empty() ? \"\" : \"->\") + to_string(root -> val);\\n        if (!root -> left && !root -> right) {\\n            paths.push_back(path);\\n        } else {\\n            binaryTreePaths(root -> left, path, paths);\\n            binaryTreePaths(root -> right, path, paths);\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<string> paths;\\n        queue<pair<TreeNode*, string>> todo;\\n        todo.push({root, to_string(root -> val)});\\n        while (!todo.empty()) {\\n            pair<TreeNode*, string> p = todo.front();\\n            todo.pop();\\n            TreeNode* node = p.first;\\n            string path = p.second;\\n            if (!node -> left && !node -> right) {\\n                paths.push_back(path);\\n            } else {\\n                if (node -> left) {\\n                    todo.push({node -> left, path + \"->\" + to_string(node -> left -> val)});\\n                }\\n                if (node -> right) {\\n                    todo.push({node -> right, path + \"->\" + to_string(node -> right -> val)});\\n                }\\n            }\\n        }\\n        return paths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68453,
                "title": "my-java-non-recursion-solution-using-stack-and-wrapper",
                "content": "    private class Wrapper {\\n    \\t\\tprivate TreeNode node;\\n    \\t\\tprivate String path;\\n    \\n    \\t\\tpublic Wrapper(TreeNode node, String path) {\\n    \\t\\t\\tthis.node = node;\\n    \\t\\t\\tthis.path = path;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\t// non-recursion-version\\n    \\tpublic List<String> binaryTreePaths(TreeNode root) {\\n    \\t\\tList<String> res = new LinkedList<>();\\n    \\t\\tif (root == null) {\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n    \\t\\tStack<Wrapper> stack = new Stack<>();\\n    \\t\\tstack.add(new Wrapper(root, \"\"+root.val));\\n    \\t\\twhile(!stack.isEmpty()){\\n    \\t\\t\\tWrapper wrapper = stack.pop();\\n    \\t\\t\\tif (wrapper.node.left == null && wrapper.node.right == null) {\\n    \\t\\t\\t\\tres.add(wrapper.path);\\n    \\t\\t\\t}\\n    \\t\\t\\tif (wrapper.node.left != null) {\\n    \\t\\t\\t\\tstack.add(new Wrapper(wrapper.node.left, wrapper.path + \"->\" + wrapper.node.left.val));\\n    \\t\\t\\t}\\n    \\t\\t\\tif (wrapper.node.right != null) {\\n    \\t\\t\\t\\tstack.add(new Wrapper(wrapper.node.right, wrapper.path + \"->\" + wrapper.node.right.val));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\n    \\t}",
                "solutionTags": [],
                "code": "    private class Wrapper {\\n    \\t\\tprivate TreeNode node;\\n    \\t\\tprivate String path;\\n    \\n    \\t\\tpublic Wrapper(TreeNode node, String path) {\\n    \\t\\t\\tthis.node = node;\\n    \\t\\t\\tthis.path = path;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\t// non-recursion-version\\n    \\tpublic List<String> binaryTreePaths(TreeNode root) {\\n    \\t\\tList<String> res = new LinkedList<>();\\n    \\t\\tif (root == null) {\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n    \\t\\tStack<Wrapper> stack = new Stack<>();\\n    \\t\\tstack.add(new Wrapper(root, \"\"+root.val));\\n    \\t\\twhile(!stack.isEmpty()){\\n    \\t\\t\\tWrapper wrapper = stack.pop();\\n    \\t\\t\\tif (wrapper.node.left == null && wrapper.node.right == null) {\\n    \\t\\t\\t\\tres.add(wrapper.path);\\n    \\t\\t\\t}\\n    \\t\\t\\tif (wrapper.node.left != null) {\\n    \\t\\t\\t\\tstack.add(new Wrapper(wrapper.node.left, wrapper.path + \"->\" + wrapper.node.left.val));\\n    \\t\\t\\t}\\n    \\t\\t\\tif (wrapper.node.right != null) {\\n    \\t\\t\\t\\tstack.add(new Wrapper(wrapper.node.right, wrapper.path + \"->\" + wrapper.node.right.val));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1066377,
                "title": "c-simple-0ms-recursive-solution",
                "content": "#### **Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Paths.\\n#### Memory Usage: 13.1 MB, less than 67.34% of C++ online submissions for Binary Tree Paths.**\\n\\n```\\nclass Solution {\\npublic:\\n    void binaryTreePaths(TreeNode* root,vector<string>& res,string str){\\n        if(!root->left && !root->right){\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(root->left)\\n            binaryTreePaths(root->left,res,str + \"->\" + to_string(root->left->val));\\n        if(root->right)\\n            binaryTreePaths(root->right,res,str + \"->\" + to_string(root->right->val));\\n        \\n    } \\n        \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if (!root) return res;\\n        \\n        binaryTreePaths(root,res,to_string(root->val));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void binaryTreePaths(TreeNode* root,vector<string>& res,string str){\\n        if(!root->left && !root->right){\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(root->left)\\n            binaryTreePaths(root->left,res,str + \"->\" + to_string(root->left->val));\\n        if(root->right)\\n            binaryTreePaths(root->right,res,str + \"->\" + to_string(root->right->val));\\n        \\n    } \\n        \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if (!root) return res;\\n        \\n        binaryTreePaths(root,res,to_string(root->val));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68420,
                "title": "simple-python-solution-using-dfs-recursion",
                "content": "this solution does not require defining a new helper function. \\n\\n    class Solution:\\n        def binaryTreePaths(self, root):\\n            if not root:\\n                return []\\n            \\n            if not root.left and not root.right:\\n                return [str(root.val)]\\n    \\n            leftPathToLeaf = self.binaryTreePaths(root.left) \\n            rightPathToLeaf = self.binaryTreePaths(root.right)\\n            \\n            left = [str(root.val)+ (\"->\"+lpath ) for lpath in leftPathToLeaf]\\n            right = [str(root.val)+ (\"->\"+rpath) for rpath in rightPathToLeaf]\\n            return left+right",
                "solutionTags": [
                    "Python"
                ],
                "code": "this solution does not require defining a new helper function. \\n\\n    class Solution:\\n        def binaryTreePaths(self, root):\\n            if not root:\\n                return []\\n            \\n            if not root.left and not root.right:\\n                return [str(root.val)]\\n    \\n            leftPathToLeaf = self.binaryTreePaths(root.left) \\n            rightPathToLeaf = self.binaryTreePaths(root.right)\\n            \\n            left = [str(root.val)+ (\"->\"+lpath ) for lpath in leftPathToLeaf]\\n            right = [str(root.val)+ (\"->\"+rpath) for rpath in rightPathToLeaf]\\n            return left+right",
                "codeTag": "Java"
            },
            {
                "id": 701765,
                "title": "c-simple-classic-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        string ans;\\n        printNodes(root, ans, result);\\n        return result;\\n    }\\n    void printNodes(TreeNode* root, string ans, vector<string>& result)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        ans += to_string(root->val) + \"->\";\\n        if(root->left == NULL && root->right ==NULL)\\n        {\\n            ans.erase(ans.length()-2, 2);\\n            result.push_back(ans);\\n        }\\n        printNodes(root->left, ans, result);\\n        printNodes(root->right, ans, result);\\n    }\\n};\\n```\\nUpvotes are encouraging!!\\nThank you :D",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        string ans;\\n        printNodes(root, ans, result);\\n        return result;\\n    }\\n    void printNodes(TreeNode* root, string ans, vector<string>& result)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        ans += to_string(root->val) + \"->\";\\n        if(root->left == NULL && root->right ==NULL)\\n        {\\n            ans.erase(ans.length()-2, 2);\\n            result.push_back(ans);\\n        }\\n        printNodes(root->left, ans, result);\\n        printNodes(root->right, ans, result);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68427,
                "title": "accepted-0ms-c-solution",
                "content": "    int pathsNum (struct TreeNode* root);\\n    void Traverse (struct TreeNode* root, char** array, char* spre, int* pindex);\\n    char* stringAdd (char* s, int val);\\n    \\n    char** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n      int index = 0;\\n      if (root == NULL)  return NULL;\\n      int paths = *returnSize = pathsNum(root);\\n      char** pathsArray = (char**) calloc (paths, sizeof (char*));\\n      Traverse (root, pathsArray, \"\", &index);\\n      return pathsArray;\\n    }\\n    \\n    int pathsNum (struct TreeNode* root)\\n    {\\n      if (root == NULL)\\n        return 0;\\n      if (root->left == NULL && root->right == NULL)\\n        return 1;\\n      return pathsNum(root->left) + pathsNum(root->right);\\n    }\\n    \\n    void Traverse (struct TreeNode* root, char** array, char* spre, int* pindex)\\n    {\\n      char* s;\\n      if (root->left == NULL && root->right == NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        array[(*pindex)++] = s;\\n      }\\n      if (root->left != NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        Traverse (root->left, array, s, pindex);\\n        free (s);\\n      }\\n      if (root->right != NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        Traverse (root->right, array, s, pindex);\\n        free (s);\\n      }\\n    }\\n    \\n    char* stringAdd (char* s, int val)\\n    {\\n      char temp[10];\\n      if (s == \"\")\\n        sprintf (temp,\"%d\", val);\\n      else\\n        sprintf (temp, \"->%d\", val);\\n      char* snew = (char*) calloc (strlen (s) + strlen (temp) + 1, sizeof (char));\\n      strcpy (snew, s);\\n      strcat (snew, temp);\\n      return snew;\\n    }",
                "solutionTags": [],
                "code": "    int pathsNum (struct TreeNode* root);\\n    void Traverse (struct TreeNode* root, char** array, char* spre, int* pindex);\\n    char* stringAdd (char* s, int val);\\n    \\n    char** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n      int index = 0;\\n      if (root == NULL)  return NULL;\\n      int paths = *returnSize = pathsNum(root);\\n      char** pathsArray = (char**) calloc (paths, sizeof (char*));\\n      Traverse (root, pathsArray, \"\", &index);\\n      return pathsArray;\\n    }\\n    \\n    int pathsNum (struct TreeNode* root)\\n    {\\n      if (root == NULL)\\n        return 0;\\n      if (root->left == NULL && root->right == NULL)\\n        return 1;\\n      return pathsNum(root->left) + pathsNum(root->right);\\n    }\\n    \\n    void Traverse (struct TreeNode* root, char** array, char* spre, int* pindex)\\n    {\\n      char* s;\\n      if (root->left == NULL && root->right == NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        array[(*pindex)++] = s;\\n      }\\n      if (root->left != NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        Traverse (root->left, array, s, pindex);\\n        free (s);\\n      }\\n      if (root->right != NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        Traverse (root->right, array, s, pindex);\\n        free (s);\\n      }\\n    }\\n    \\n    char* stringAdd (char* s, int val)\\n    {\\n      char temp[10];\\n      if (s == \"\")\\n        sprintf (temp,\"%d\", val);\\n      else\\n        sprintf (temp, \"->%d\", val);\\n      char* snew = (char*) calloc (strlen (s) + strlen (temp) + 1, sizeof (char));\\n      strcpy (snew, s);\\n      strcat (snew, temp);\\n      return snew;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68485,
                "title": "bfs-with-two-queue-java-solution",
                "content": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        if (root == null) {\\n            return res;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<String> path = new LinkedList<>();\\n        path.offer(root.val + \"\");\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            TreeNode cur = queue.poll();\\n            String item = path.poll();\\n            if (cur.left == null && cur.right == null) {\\n                res.add(item);\\n            }\\n            if (cur.left != null) {\\n                queue.offer(cur.left);\\n                path.offer(item + \"->\" + cur.left.val + \"\");\\n            }\\n            if (cur.right != null) {\\n                queue.offer(cur.right);\\n                path.offer(item + \"->\" + cur.right.val + \"\");\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        if (root == null) {\\n            return res;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<String> path = new LinkedList<>();\\n        path.offer(root.val + \"\");\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            TreeNode cur = queue.poll();\\n            String item = path.poll();\\n            if (cur.left == null && cur.right == null) {\\n                res.add(item);\\n            }\\n            if (cur.left != null) {\\n                queue.offer(cur.left);\\n                path.offer(item + \"->\" + cur.left.val + \"\");\\n            }\\n            if (cur.right != null) {\\n                queue.offer(cur.right);\\n                path.offer(item + \"->\" + cur.right.val + \"\");\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68461,
                "title": "simple-to-understand-python-solution",
                "content": "    class Solution(object):\\n        def binaryTreePaths(self, root):\\n            if root == None:\\n                return []\\n            return self.constructPaths(root, str(root.val), [])\\n\\n        def constructPaths(self, root, p, paths):\\n            if root.left == None and root.right == None:\\n                paths.append(p)\\n            if root.left:\\n                paths = self.constructPaths(root.left, p + \"->\" + str(root.left.val), paths)\\n            if root.right:\\n                paths = self.constructPaths(root.right, p + \"->\" + str(root.right.val), paths)\\n            return paths",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def binaryTreePaths(self, root):\\n            if root == None:\\n                return []\\n            return self.constructPaths(root, str(root.val), [])\\n\\n        def constructPaths(self, root, p, paths):\\n            if root.left == None and root.right == None:\\n                paths.append(p)\\n            if root.left:\\n                paths = self.constructPaths(root.left, p + \"->\" + str(root.left.val), paths)\\n            if root.right:\\n                paths = self.constructPaths(root.right, p + \"->\" + str(root.right.val), paths)\\n            return paths",
                "codeTag": "Java"
            },
            {
                "id": 68471,
                "title": "java-easy-to-understand-solution-3-line-dfs",
                "content": "Code in Java:\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>(); // stores the final output\\n        if(root==null) return res;\\n        helper(root, \"\", res);\\n        return res;\\n    }\\n    // DFS\\n    private void helper(TreeNode root, String str, List<String> res) {\\n        if(root.left==null && root.right==null) res.add(str + root.val); // reach a leaf node, completes a path\\n        if(root.left!=null)                     helper(root.left, str+root.val+\"->\", res); // recursively checks its left child\\n        if(root.right!=null)                    helper(root.right, str+root.val+\"->\", res); // recursively checks its right child\\n    }\\n\\nIf you are interested in my other posts, please feel free to check my Github page here: [https://github.com/F-L-A-G/Algorithms-in-Java][1]\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "Code in Java:\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>(); // stores the final output\\n        if(root==null) return res;\\n        helper(root, \"\", res);\\n        return res;\\n    }\\n    // DFS\\n    private void helper(TreeNode root, String str, List<String> res) {\\n        if(root.left==null && root.right==null) res.add(str + root.val); // reach a leaf node, completes a path\\n        if(root.left!=null)                     helper(root.left, str+root.val+\"->\", res); // recursively checks its left child\\n        if(root.right!=null)                    helper(root.right, str+root.val+\"->\", res); // recursively checks its right child\\n    }\\n\\nIf you are interested in my other posts, please feel free to check my Github page here: [https://github.com/F-L-A-G/Algorithms-in-Java][1]\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java",
                "codeTag": "Unknown"
            },
            {
                "id": 3640686,
                "title": "simple-dfs-in-python",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find all the root-to-leaf paths, we can use a depth-first search (DFS) algorithm. We\\'ll implement a recursive helper function `solve()` that takes two parameters: the current node and the current path string. The `solve()` function will traverse the tree in a depth-first manner and append the root-to-leaf paths to the `ans` list.\\n\\nIn the `solve()` function:\\n1. Append the string representation of the current node\\'s value to the path string (`s += str(root.val)`).\\n2. Check if the current node is a leaf node (i.e., it has no left or right child). If so, it means we have reached the end of a root-to-leaf path. In this case, append the current path string to the `ans` list and return.\\n3. If the current node has a right child, recursively call `solve()` with the right child and the updated path string (`solve(root.right, s + \"->\")`).\\n4. If the current node has a left child, recursively call `solve()` with the left child and the updated path string (`solve(root.left, s + \"->\")`).\\n\\nAfter defining the `solve()` function, we initialize an empty `ans` list. Then, we call `solve()` with the `root` node and an empty path string (`\"\"`). Finally, we return the `ans` list, which contains all the root-to-leaf paths.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n        def solve(root, s):\\n            s += str(root.val)\\n            if not root.right and not root.left:\\n                ans.append(s)\\n                return\\n            if root.right:\\n                solve(root.right, s+\"->\")\\n            if root.left:\\n                solve(root.left, s+\"->\")\\n        solve(root, \"\")\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n        def solve(root, s):\\n            s += str(root.val)\\n            if not root.right and not root.left:\\n                ans.append(s)\\n                return\\n            if root.right:\\n                solve(root.right, s+\"->\")\\n            if root.left:\\n                solve(root.left, s+\"->\")\\n        solve(root, \"\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323006,
                "title": "simple-c-4ms-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void abc(vector<string>& ans,string s,TreeNode* root){\\n        s+=to_string(root->val);\\n        if(root->left==NULL && root->right==NULL){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(root->left){\\n            abc(ans,s+\"->\",root->left);\\n        }\\n        if(root->right){\\n            // s+=\"->\";\\n            abc(ans,s+\"->\",root->right);\\n        }\\n        return;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        string s=\"\";\\n        abc(ans,s,root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void abc(vector<string>& ans,string s,TreeNode* root){\\n        s+=to_string(root->val);\\n        if(root->left==NULL && root->right==NULL){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(root->left){\\n            abc(ans,s+\"->\",root->left);\\n        }\\n        if(root->right){\\n            // s+=\"->\";\\n            abc(ans,s+\"->\",root->right);\\n        }\\n        return;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        string s=\"\";\\n        abc(ans,s,root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059553,
                "title": "java-recursive-dfs-explained",
                "content": "# Intuition\\nWe will begin by **Adding values in String ans** (Sublist).And If our LeafNode Condition hits that means **add current SubList In Main** and continue the procedure of Traversing.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<String> list=new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String ans=\"\";\\n        path(root,ans);\\n        return list;\\n    }\\n    void path(TreeNode root, String ans) {\\n        if(root==null) return;\\n        ans=ans+root.val;\\n        if(root.left==null && root.right==null){\\n            list.add(ans);\\n            return;\\n        }\\n        ans=ans+\"->\";\\n        path(root.left,ans);\\n        path(root.right,ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<String> list=new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String ans=\"\";\\n        path(root,ans);\\n        return list;\\n    }\\n    void path(TreeNode root, String ans) {\\n        if(root==null) return;\\n        ans=ans+root.val;\\n        if(root.left==null && root.right==null){\\n            list.add(ans);\\n            return;\\n        }\\n        ans=ans+\"->\";\\n        path(root.left,ans);\\n        path(root.right,ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484118,
                "title": "python-3-beats-100-nine-lines-dfs",
                "content": "```\\nclass Solution:\\n    def binaryTreePaths(self, R: TreeNode) -> List[str]:\\n        A, P = [], []\\n        def dfs(N):\\n            if N == None: return\\n            P.append(N.val)\\n            if (N.left,N.right) == (None,None): A.append(\\'->\\'.join(map(str,P)))\\n            else: dfs(N.left), dfs(N.right)\\n            P.pop()\\n        dfs(R)\\n        return A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, R: TreeNode) -> List[str]:\\n        A, P = [], []\\n        def dfs(N):\\n            if N == None: return\\n            P.append(N.val)\\n            if (N.left,N.right) == (None,None): A.append(\\'->\\'.join(map(str,P)))\\n            else: dfs(N.left), dfs(N.right)\\n            P.pop()\\n        dfs(R)\\n        return A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 433961,
                "title": "python-solution-dfs-path",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if not root:\\n            return []\\n        self.res = []\\n        self.dfs(root, str(root.val))\\n        return self.res\\n    \\n    def dfs(self, root, path):\\n        if not root.left and not root.right:\\n            self.res.append(path)\\n        if root.left:\\n            self.dfs(root.left, path + \"->\" + str(root.left.val))\\n        if root.right:\\n            self.dfs(root.right, path + \"->\" + str(root.right.val))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if not root:\\n            return []\\n        self.res = []\\n        self.dfs(root, str(root.val))\\n        return self.res\\n    \\n    def dfs(self, root, path):\\n        if not root.left and not root.right:\\n            self.res.append(path)\\n        if root.left:\\n            self.dfs(root.left, path + \"->\" + str(root.left.val))\\n        if root.right:\\n            self.dfs(root.right, path + \"->\" + str(root.right.val))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68423,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // import javafx.util.Pair;\\n    // dfs recursively \\n    public List<String> binaryTreePaths1(TreeNode root) {\\n        List<String> ret = new LinkedList<>();\\n        dfs(new Pair(root, \"\"), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(Pair<TreeNode, String> p, List<String> ret) {\\n        TreeNode n = p.getKey();\\n        String str = p.getValue();\\n        if (n != null) {\\n            if (n.left == null && n.right == null) {\\n                str += n.val;\\n                ret.add(str);\\n                //return;\\n            } \\n            dfs(new Pair(n.left, str+n.val+\"->\"), ret);\\n            dfs(new Pair(n.right, str+n.val+\"->\"), ret);\\n        }\\n    }\\n    \\n    // dfs iteratively\\n    public List<String> binaryTreePaths2(TreeNode root) {\\n        Stack<Pair<TreeNode, String>> stack = new Stack<>();\\n        stack.push(new Pair(root, \"\"));\\n        List<String> ret = new ArrayList<>();\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, String> p = stack.pop();\\n            TreeNode n = p.getKey();\\n            String str = p.getValue();\\n            if (n != null) {\\n                if (n.left == null && n.right == null) {\\n                    str += Integer.toString(n.val);\\n                    ret.add(str);\\n                }\\n                stack.push(new Pair(n.right, str+n.val+\"->\"));\\n                stack.push(new Pair(n.left, str+n.val+\"->\"));\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        Queue<Pair<TreeNode, String>> queue = new LinkedList<>();\\n        queue.add(new Pair(root, \"\"));\\n        List<String> ret = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            Pair<TreeNode, String> p = queue.poll();\\n            TreeNode n = p.getKey();\\n            String str = p.getValue();\\n            if (n != null) {\\n                if (n.left == null && n.right == null) {\\n                    str += n.val;\\n                    ret.add(str);\\n                    //continue;\\n                }\\n                queue.add(new Pair(n.left, str+n.val+\"->\"));\\n                queue.add(new Pair(n.right, str+n.val+\"->\"));\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // import javafx.util.Pair;\\n    // dfs recursively \\n    public List<String> binaryTreePaths1(TreeNode root) {\\n        List<String> ret = new LinkedList<>();\\n        dfs(new Pair(root, \"\"), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(Pair<TreeNode, String> p, List<String> ret) {\\n        TreeNode n = p.getKey();\\n        String str = p.getValue();\\n        if (n != null) {\\n            if (n.left == null && n.right == null) {\\n                str += n.val;\\n                ret.add(str);\\n                //return;\\n            } \\n            dfs(new Pair(n.left, str+n.val+\"->\"), ret);\\n            dfs(new Pair(n.right, str+n.val+\"->\"), ret);\\n        }\\n    }\\n    \\n    // dfs iteratively\\n    public List<String> binaryTreePaths2(TreeNode root) {\\n        Stack<Pair<TreeNode, String>> stack = new Stack<>();\\n        stack.push(new Pair(root, \"\"));\\n        List<String> ret = new ArrayList<>();\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, String> p = stack.pop();\\n            TreeNode n = p.getKey();\\n            String str = p.getValue();\\n            if (n != null) {\\n                if (n.left == null && n.right == null) {\\n                    str += Integer.toString(n.val);\\n                    ret.add(str);\\n                }\\n                stack.push(new Pair(n.right, str+n.val+\"->\"));\\n                stack.push(new Pair(n.left, str+n.val+\"->\"));\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        Queue<Pair<TreeNode, String>> queue = new LinkedList<>();\\n        queue.add(new Pair(root, \"\"));\\n        List<String> ret = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            Pair<TreeNode, String> p = queue.poll();\\n            TreeNode n = p.getKey();\\n            String str = p.getValue();\\n            if (n != null) {\\n                if (n.left == null && n.right == null) {\\n                    str += n.val;\\n                    ret.add(str);\\n                    //continue;\\n                }\\n                queue.add(new Pair(n.left, str+n.val+\"->\"));\\n                queue.add(new Pair(n.right, str+n.val+\"->\"));\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 3448270,
                "title": "python-3-bfs-getting-list-of-all-paths-and-then-return-in-needed-format",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        paths = []\\n        def dfs(node, path):\\n            if not node: return\\n            path = path + [node.val]\\n            if not (node.left or node.right):\\n                return paths.append(path)\\n            dfs(node.left, path)\\n            dfs(node.right, path)\\n        dfs(root, [])\\n\\n        return [\\'->\\'.join(map(str, path)) for path in paths]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        paths = []\\n        def dfs(node, path):\\n            if not node: return\\n            path = path + [node.val]\\n            if not (node.left or node.right):\\n                return paths.append(path)\\n            dfs(node.left, path)\\n            dfs(node.right, path)\\n        dfs(root, [])\\n\\n        return [\\'->\\'.join(map(str, path)) for path in paths]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231860,
                "title": "257-time-96-78-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Here\\'s a step-by-step explanation:\\n```\\nclass Solution:\\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n    ans = []\\n```\\nThe solution defines a class Solution with a method binaryTreePaths. It takes in the root node of a binary tree, represented as a TreeNode object, and returns a list of strings representing all possible paths from root to leaf nodes.\\n\\nThe variable ans is initialized as an empty list, which will store the answer.\\n\\n```\\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\\n      if not root:\\n        return\\n```\\nA depth-first search (DFS) helper function dfs is defined, which takes in a node root and a path represented as a list of strings. If the node root is None, the function returns and does nothing.\\n```\\n      if not root.left and not root.right:\\n        ans.append(\\'\\'.join(path) + str(root.val))\\n        return\\n```\\nIf root is a leaf node (i.e. has no left or right child), the function appends the current path joined by -> and the value of the leaf node to ans. Then, the function returns and does nothing.\\n\\n```   path.append(str(root.val) + \\'->\\')\\n      dfs(root.left, path)\\n      dfs(root.right, path)\\n      path.pop()\\n```\\nIf root is not a leaf node, the function appends the current node value followed by -> to the path. It then recursively calls dfs on the left and right children of the node. After these recursive calls are complete, the current node value is popped from the path.\\n\\n```\\n    dfs(root, [])\\n    return ans\\n```\\n\\nFinally, the dfs function is called on the root node with an empty path list, and ans is returned as the answer to the problem.\\n\\n# Complexity\\n- Time complexity:\\n96.78%\\n\\n- Space complexity:\\n63.68%\\n\\n# Code\\n```\\nclass Solution:\\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n    ans = []\\n\\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\\n      if not root:\\n        return\\n      if not root.left and not root.right:\\n        ans.append(\\'\\'.join(path) + str(root.val))\\n        return\\n\\n      path.append(str(root.val) + \\'->\\')\\n      dfs(root.left, path)\\n      dfs(root.right, path)\\n      path.pop()\\n\\n    dfs(root, [])\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n    ans = []\\n```\n```\\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\\n      if not root:\\n        return\\n```\n```\\n      if not root.left and not root.right:\\n        ans.append(\\'\\'.join(path) + str(root.val))\\n        return\\n```\n```   path.append(str(root.val) + \\'->\\')\\n      dfs(root.left, path)\\n      dfs(root.right, path)\\n      path.pop()\\n```\n```\\n    dfs(root, [])\\n    return ans\\n```\n```\\nclass Solution:\\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n    ans = []\\n\\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\\n      if not root:\\n        return\\n      if not root.left and not root.right:\\n        ans.append(\\'\\'.join(path) + str(root.val))\\n        return\\n\\n      path.append(str(root.val) + \\'->\\')\\n      dfs(root.left, path)\\n      dfs(root.right, path)\\n      path.pop()\\n\\n    dfs(root, [])\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051305,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(TreeNode* node, string path) {\\n        if(node->left == NULL and node->right == NULL) ans.push_back(path + to_string(node->val));\\n        if(node->left) dfs(node->left, path + to_string(node->val) + \"->\");\\n        if(node->right) dfs(node->right, path + to_string(node->val) + \"->\");\\n    }\\n     \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        dfs(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(TreeNode* node, string path) {\\n        if(node->left == NULL and node->right == NULL) ans.push_back(path + to_string(node->val));\\n        if(node->left) dfs(node->left, path + to_string(node->val) + \"->\");\\n        if(node->right) dfs(node->right, path + to_string(node->val) + \"->\");\\n    }\\n     \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        dfs(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783039,
                "title": "java-backtracking-solution",
                "content": "```\\nRuntime: 5 ms, faster than 70.04% of Java online submissions for Binary Tree Paths.\\nMemory Usage: 43 MB, less than 25.59% of Java online submissions for Binary Tree Paths.\\n```\\n\\n        \\n        public List<String> binaryTreePaths(TreeNode root) {\\n\\t\\t List<String> ans = new ArrayList<>();\\n        List<String> path = new ArrayList<>();\\n        \\n        reserve(root, ans, path);\\n        return ans;\\n    }\\n    \\n    public void reserve(TreeNode root, List<String> ans , List<String> path){\\n        if(root == null) return;\\n        \\n        path.add(root.val + \"\");\\n        if(root.left == null && root.right == null){\\n            ans.add(String.join(\"->\",path));\\n        }\\n        reserve(root.left, ans, path);\\n        reserve(root.right, ans, path);\\n        \\n        path.remove(path.size()-1);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nRuntime: 5 ms, faster than 70.04% of Java online submissions for Binary Tree Paths.\\nMemory Usage: 43 MB, less than 25.59% of Java online submissions for Binary Tree Paths.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1438679,
                "title": "99-80-faster-easy-solution",
                "content": "if you found the solution easy, please **Upvote**\\n\\n\\tclass Solution {\\n    List<String> result = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) \\n    {\\n        helper(root, new StringBuilder());\\n        return result;\\n    }\\n    \\n    \\n    void helper(TreeNode node, StringBuilder slate)\\n    {\\n        if(node==null) return;\\n        \\n        int length = slate.length();\\n        slate.append(node.val);\\n        \\n        if(node.left == null && node.right == null)\\n            result.add(slate.toString()); \\n        \\n        else\\n        {\\n           slate.append(\"->\");\\n           helper(node.left, slate);\\n           helper(node.right, slate);\\n        }\\n        slate.setLength(length);\\n    }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    List<String> result = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) \\n    {\\n        helper(root, new StringBuilder());\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1188771,
                "title": "c-simple-dfs-solution-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>V;\\n    \\n    void dfs(TreeNode* root, string s)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        if(root->left == NULL and root->right==NULL)\\n        {\\n            V.push_back(s+to_string(root->val));\\n        }\\n        dfs(root->left, s+to_string(root->val)+\"->\");\\n        \\n        dfs(root->right, s+to_string(root->val)+\"->\");\\n        \\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n     \\n        dfs(root, \"\");\\n        return V;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>V;\\n    \\n    void dfs(TreeNode* root, string s)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        if(root->left == NULL and root->right==NULL)\\n        {\\n            V.push_back(s+to_string(root->val));\\n        }\\n        dfs(root->left, s+to_string(root->val)+\"->\");\\n        \\n        dfs(root->right, s+to_string(root->val)+\"->\");\\n        \\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n     \\n        dfs(root, \"\");\\n        return V;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760438,
                "title": "time-complexity-analysis-string-vs-stringbuilder",
                "content": "Time Complexity: number of paths * time complexity for each path.\\n\\n**Using Strings:**\\n```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null)\\n            return res;\\n        binaryTreePaths(root,\"\");\\n        return res;\\n    }\\n    \\n    public void binaryTreePaths(TreeNode root, String str){\\n        str+= (str.length()==0) ? String.valueOf(root.val): \"->\"+String.valueOf(root.val);\\n        if(root.left==null && root.right==null) res.add(str);\\n        if(root.left!=null) binaryTreePaths(root.left,str);\\n        if(root.right!=null) binaryTreePaths(root.right,str);\\n    }\\n    \\n}\\n```\\n\\nWell balanced tree Case:\\n\\nThere will N/2 leaf nodes and max path length would be O(logn).\\nIn every path we traverse, we are adding a char to string, in every such operation a string is allocated (and copied, due to String immutability) for each node in this path, not just the leaves.\\nHence the complexity for a single path would be 1+ 2+ .....+ logn = O((logN)^2).\\nTotal complexity is O(N/2)*O(logN)^2) =  **O(N x (logN)^2).**\\n\\nNodes in Straight Line Case:\\n\\nHere there would be a single leaf path, which is of length N.\\nHence time complexity for this path: 1+2+3+..n = O(N^2).\\nSince we have a single path here, Total Complexity is =  **O(N^2).**\\n\\n**Using String Builder:**\\n\\n```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null)\\n            return res;\\n        binaryTreePaths(root,new StringBuilder());\\n        return res;\\n    }\\n    \\n    public void binaryTreePaths(TreeNode root, StringBuilder sb){        \\n        if(root==null) return;\\n        \\n        int len = sb.length();\\n        sb.append(root.val);\\n        \\n        if(root.left==null && root.right==null) \\n            res.add(sb.toString());\\n        else{\\n            sb.append(\"->\");\\n            binaryTreePaths(root.left,sb);\\n            binaryTreePaths(root.right,sb);\\n        }\\n       sb.setLength(len);\\n    }\\n}\\n```\\n\\nIn this above approach using stringBuilder i\\'m reusing the char array and unlike with string approach, the whole string will not be copied at each node. \\n\\nWell balanced tree Case:\\n\\nThere will N/2 leaf nodes and max path length would be O(logn).\\nIn a single path at every node we would only take O(1) time, so time complexity for a single path would be: O(logn)\\nHence total complexity is O(N/2)*O(logN)) = **O(N x (logN)).**\\n\\nNodes in Straight Line Case:\\n\\nSo here there would be a single leaf path, which is of length N.\\nSo time complexity for this path: O(N)\\nSince we have a single path here, total complexity = **O(N).**\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null)\\n            return res;\\n        binaryTreePaths(root,\"\");\\n        return res;\\n    }\\n    \\n    public void binaryTreePaths(TreeNode root, String str){\\n        str+= (str.length()==0) ? String.valueOf(root.val): \"->\"+String.valueOf(root.val);\\n        if(root.left==null && root.right==null) res.add(str);\\n        if(root.left!=null) binaryTreePaths(root.left,str);\\n        if(root.right!=null) binaryTreePaths(root.right,str);\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null)\\n            return res;\\n        binaryTreePaths(root,new StringBuilder());\\n        return res;\\n    }\\n    \\n    public void binaryTreePaths(TreeNode root, StringBuilder sb){        \\n        if(root==null) return;\\n        \\n        int len = sb.length();\\n        sb.append(root.val);\\n        \\n        if(root.left==null && root.right==null) \\n            res.add(sb.toString());\\n        else{\\n            sb.append(\"->\");\\n            binaryTreePaths(root.left,sb);\\n            binaryTreePaths(root.right,sb);\\n        }\\n       sb.setLength(len);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589072,
                "title": "clear-and-simple-c-solution-100-faster-100-memory",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        insertPaths(root, \"\", &result);\\n        return result;\\n    }\\nprivate:\\n\\t// simple recursive pre-order traversal\\n    void insertPaths(TreeNode* node, string str, vector<string>* res) {\\n        if (!node) return;  // base-case\\n        \\n        str += to_string(node->val);\\n        if (!node->left && !node->right) {\\n\\t\\t\\t// if the current node is a leaf, add string to result\\n            res->emplace_back(str);\\n        }\\n        \\n        insertPaths(node->left, str + \"->\", res);\\n        insertPaths(node->right, str + \"->\", res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        insertPaths(root, \"\", &result);\\n        return result;\\n    }\\nprivate:\\n\\t// simple recursive pre-order traversal\\n    void insertPaths(TreeNode* node, string str, vector<string>* res) {\\n        if (!node) return;  // base-case\\n        \\n        str += to_string(node->val);\\n        if (!node->left && !node->right) {\\n\\t\\t\\t// if the current node is a leaf, add string to result\\n            res->emplace_back(str);\\n        }\\n        \\n        insertPaths(node->left, str + \"->\", res);\\n        insertPaths(node->right, str + \"->\", res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556028,
                "title": "go-recursion-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Binary Tree Paths.\\nMemory Usage: 2.3 MB, less than 100.00% of Go online submissions for Binary Tree Paths.\\n```\\nvar arrow string = \"->\"\\n\\nfunc binaryTreePaths(root *TreeNode) []string {\\n    ans := make([]string, 0)\\n    \\n    paths(root, \"\", &ans)\\n    \\n    return ans\\n}\\n\\nfunc paths(root *TreeNode, prefix string, ans *[]string) {\\n    if root == nil {\\n        return\\n    }\\n    \\n    if len(prefix) == 0 {\\n        prefix += strconv.Itoa(root.Val)\\n    } else {\\n        prefix += \"->\" + strconv.Itoa(root.Val)\\n    }\\n    \\n    if root.Left == nil && root.Right == nil {\\n        *ans = append(*ans, prefix)\\n        return\\n    }\\n    \\n    paths(root.Left, prefix, ans)\\n    paths(root.Right, prefix, ans)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nvar arrow string = \"->\"\\n\\nfunc binaryTreePaths(root *TreeNode) []string {\\n    ans := make([]string, 0)\\n    \\n    paths(root, \"\", &ans)\\n    \\n    return ans\\n}\\n\\nfunc paths(root *TreeNode, prefix string, ans *[]string) {\\n    if root == nil {\\n        return\\n    }\\n    \\n    if len(prefix) == 0 {\\n        prefix += strconv.Itoa(root.Val)\\n    } else {\\n        prefix += \"->\" + strconv.Itoa(root.Val)\\n    }\\n    \\n    if root.Left == nil && root.Right == nil {\\n        *ans = append(*ans, prefix)\\n        return\\n    }\\n    \\n    paths(root.Left, prefix, ans)\\n    paths(root.Right, prefix, ans)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68378,
                "title": "4ms-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n\\n        if(!root) return res;\\n        else if(!root->left && !root->right) res.push_back(to_string(root->val));\\n        \\n        string head = to_string(root->val) + \"->\";\\n        \\n        for(auto item: binaryTreePaths(root->left)) res.push_back(head + item);\\n        for(auto item: binaryTreePaths(root->right)) res.push_back(head + item);\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n\\n        if(!root) return res;\\n        else if(!root->left && !root->right) res.push_back(to_string(root->val));\\n        \\n        string head = to_string(root->val) + \"->\";\\n        \\n        for(auto item: binaryTreePaths(root->left)) res.push_back(head + item);\\n        for(auto item: binaryTreePaths(root->right)) res.push_back(head + item);\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68499,
                "title": "c-a-clean-one-function-approach",
                "content": "    vector<string> binaryTreePaths(TreeNode* root) {\\n      if (root == nullptr)\\n        return {};\\n      if (root->left == nullptr && root->right == nullptr)\\n        return {to_string(root->val)};\\n    \\n      vector<string> left  = binaryTreePaths(root->left);\\n      vector<string> right = binaryTreePaths(root->right);\\n      left.insert(left.end(), begin(right), end(right));\\n      for (auto &e : left)\\n        e = to_string(root->val) + \"->\" + e;\\n      return left;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> binaryTreePaths(TreeNode* root) {\\n      if (root == nullptr)\\n        return {};\\n      if (root->left == nullptr && root->right == nullptr)\\n        return {to_string(root->val)};\\n    \\n      vector<string> left  = binaryTreePaths(root->left);\\n      vector<string> right = binaryTreePaths(root->right);\\n      left.insert(left.end(), begin(right), end(right));\\n      for (auto &e : left)\\n        e = to_string(root->val) + \"->\" + e;\\n      return left;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68526,
                "title": "c-recursive-and-iterative-solutions-with-detailed-comments",
                "content": "The recursive solution is trivial.\\n\\n    class Solution \\n    {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) \\n        {\\n            vector<string> paths;\\n            // If root is NULL, return an empty path vector.\\n            if (root == nullptr)\\n            {\\n                return paths;\\n            }\\n            \\n            // Get the path vector starting from the left child.\\n            vector<string> leftPaths = binaryTreePaths(root->left);\\n            // Concatenate root with the left paths to generate \\n            // the paths starting from root.\\n            for (auto& lp : leftPaths)\\n            {\\n                paths.push_back(to_string(root->val) + \"->\" + lp);\\n            }\\n            \\n            // Get the path vector starting from the right child.\\n            vector<string> rightPaths = binaryTreePaths(root->right);\\n            // Concatenate root with the right paths to generate \\n            // the paths starting from root.\\n            for (auto& rp : rightPaths)\\n            {\\n                paths.push_back(to_string(root->val) + \"->\" + rp);\\n            }\\n            \\n            // In case that both leftPaths and rightPaths are empty, \\n            // i.e., root is a leaf, root itself is a path.\\n            if (paths.empty())\\n            {\\n                paths.push_back(to_string(root->val));\\n            }\\n            \\n            return paths;\\n        }\\n    };\\n\\nThe iterative solution essentially uses the depth-first search to find all the paths from root to leaves. Compared with the breadth-first search approach, this approach doesn't need to have a vector of vectors to keep the paths from root to the nodes at the current level. Besides the result vector of strings, this approach just needs one vector which keeps one path from root to the current node and one unordered set which keeps all the nodes that have been visited during the depth-first search. Thus, with respect the space complexity, the depth-first search is more efficient than the breadth-first search.\\n\\n    class Solution \\n    {\\n        // Generate the path string from the TreeNode val vector.\\n        string GetPathStringFromNums(vector<int> &pathVal)\\n        {\\n            int n = pathVal.size();\\n            string res;\\n            // For the nodes except the last node, we need to \\n            // append \"->\" to the node values.\\n            for (int i = 0; i < n - 1; i++)\\n            {\\n                res += (to_string(pathVal[i]) + \"->\");\\n            }\\n            \\n            if (n > 0)\\n            {\\n                res += to_string(pathVal[n - 1]);\\n            }\\n            \\n            return res;\\n        }\\n        \\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) \\n        {\\n            vector<string> paths;\\n            // If root is NULL, return an empty path vector immediately.\\n            if (root == nullptr)\\n            {\\n                return paths;\\n            }\\n            \\n            // pathVal is a vector of TreeNode values along a path \\n            // starting from root.\\n            vector<int> pathVal({root->val});\\n            \\n            // st is the stack used for the depth-first search.\\n            stack<TreeNode*> st;\\n            st.push(root);\\n            \\n            // visitedNodes keeps all the nodes which have been visited \\n            // during the depth-first search. In other words, it keeps \\n            // all the nodes which have ever been pushed into the stack.\\n            unordered_set<TreeNode*> visitedNodes({root});\\n            \\n            // Do the depth-first search until the stack is empty.\\n            while (!st.empty())\\n            {\\n                TreeNode *curr = st.top();\\n    \\n                if ((curr->left == nullptr) && (curr->right == nullptr))\\n                {\\n                    // curr is a leaf, so the current path is a path from \\n                    // root to a leaf and add it to paths.\\n                    paths.push_back(GetPathStringFromNums(pathVal));\\n                    \\n                    // Remove the leaf node from pathVal which will end at \\n                    // the parent node of curr.\\n                    pathVal.pop_back();\\n                    \\n                    st.pop();\\n                }\\n                else \\n                {\\n                    // curr is not leaf, so we need to go down at least one \\n                    // level.\\n                    \\n                    // First we try pushing the left child if it hasn't \\n                    // been visited.\\n                    if (curr->left != nullptr)\\n                    {\\n                        auto itLeft = visitedNodes.find(curr->left);\\n                        if (itLeft == visitedNodes.end())\\n                        {\\n                            st.push(curr->left);\\n                            pathVal.push_back(curr->left->val);\\n                            \\n                            visitedNodes.insert(curr->left);\\n                            continue;\\n                        }\\n                    }\\n                    \\n                    // We reach here because either the left child doesn't \\n                    // exist or the left child has been visited. Then we try \\n                    // pushing the right child if it hasn't been visited.\\n                    if (curr->right != nullptr)\\n                    {\\n                        auto itRight = visitedNodes.find(curr->right);\\n                        if (itRight == visitedNodes.end())\\n                        {\\n                            st.push(curr->right);\\n                            pathVal.push_back(curr->right->val);\\n                            \\n                            visitedNodes.insert(curr->right);\\n                            continue;\\n                        }\\n                    }\\n                    \\n                    // The nodes in the subtree below curr have all been \\n                    // visited, so remove curr from pathVal which will end \\n                    // at the parent node of curr.\\n                    pathVal.pop_back();\\n                    st.pop();\\n                }\\n            }\\n            \\n            return paths;\\n        }\\n    };",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution \\n    {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) \\n        {\\n            vector<string> paths;\\n            // If root is NULL, return an empty path vector.\\n            if (root == nullptr)\\n            {\\n                return paths;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2781823,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        def backtrack(node, path, rst):\\n            children = (node.left, node.right)\\n            \\n            path.append(str(node.val))\\n\\n            if not any(children): # leaf\\n                rst.append(\\'->\\'.join(path))\\n                \\n            for child in filter(None, children):\\n                backtrack(child, path, rst)\\n                \\n            path.pop()\\n                    \\n            return rst\\n        \\n        return backtrack(root, [], [])\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        def backtrack(node, path, rst):\\n            children = (node.left, node.right)\\n            \\n            path.append(str(node.val))\\n\\n            if not any(children): # leaf\\n                rst.append(\\'->\\'.join(path))\\n                \\n            for child in filter(None, children):\\n                backtrack(child, path, rst)\\n                \\n            path.pop()\\n                    \\n            return rst\\n        \\n        return backtrack(root, [], [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509320,
                "title": "java-recursive-solution-dfs",
                "content": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        \\n        List<String>res = new ArrayList<>();\\n        fillPaths(root,\"\",res);\\n        return res;\\n    }\\n    \\n    \\n   public void fillPaths(TreeNode node,String str,List<String> res)\\n    {\\n        if (node == null)\\n            return;\\n        \\n        if(node.left == null && node.right == null)\\n        {\\n            res.add(str+node.val); \\n            return;\\n        }\\n          fillPaths(node.left, str+node.val+\"->\", res); \\n          fillPaths(node.right, str+node.val+\"->\", res); \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        \\n        List<String>res = new ArrayList<>();\\n        fillPaths(root,\"\",res);\\n        return res;\\n    }\\n    \\n    \\n   public void fillPaths(TreeNode node,String str,List<String> res)\\n    {\\n        if (node == null)\\n            return;\\n        \\n        if(node.left == null && node.right == null)\\n        {\\n            res.add(str+node.val); \\n            return;\\n        }\\n          fillPaths(node.left, str+node.val+\"->\", res); \\n          fillPaths(node.right, str+node.val+\"->\", res); \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583284,
                "title": "javascript-solution",
                "content": "```\\n\\nvar binaryTreePaths = function(root) {\\n    let result = [];\\n    traverse(root, \"\");\\n    \\n    function traverse(node, path) {\\n        if (!node) \\n            return;\\n \\n        if (!node.left  && !node.right) {\\n            result.push(path + node.val);\\n            return;\\n        }\\n        traverse(node.left, path + node.val + \"->\");\\n        traverse(node.right, path + node.val + \"->\");\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nvar binaryTreePaths = function(root) {\\n    let result = [];\\n    traverse(root, \"\");\\n    \\n    function traverse(node, path) {\\n        if (!node) \\n            return;\\n \\n        if (!node.left  && !node.right) {\\n            result.push(path + node.val);\\n            return;\\n        }\\n        traverse(node.left, path + node.val + \"->\");\\n        traverse(node.right, path + node.val + \"->\");\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237550,
                "title": "python-solution",
                "content": "Time complexity: `O(n + h*m)`, where `n` = # of nodes in the tree, `h` = height of the tree, and `m` = # of leaf nodes of the tree. In worse case, this is `O(n log n)`. Space complexity: `O(h*m)`. In worst case, this is `O(n log n)`.  \\n\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: \\'TreeNode\\') -> \\'List[str]\\':\\n        def dfs(root):\\n            if not root:\\n                return\\n            if not root.left and not root.right:\\n                tmp.append(str(root.val))\\n                res.append(\"->\".join(tmp))\\n                tmp.pop()\\n                return\\n            tmp.append(str(root.val))\\n            dfs(root.left)\\n            dfs(root.right)\\n            tmp.pop()\\n        tmp = []\\n        res = []\\n        dfs(root)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: \\'TreeNode\\') -> \\'List[str]\\':\\n        def dfs(root):\\n            if not root:\\n                return\\n            if not root.left and not root.right:\\n                tmp.append(str(root.val))\\n                res.append(\"->\".join(tmp))\\n                tmp.pop()\\n                return\\n            tmp.append(str(root.val))\\n            dfs(root.left)\\n            dfs(root.right)\\n            tmp.pop()\\n        tmp = []\\n        res = []\\n        dfs(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68463,
                "title": "2ms-java-recursive-solution-with-explaination",
                "content": "The idea is to perform a dfs, for every node we visit the path up till that node is path + currentNode.val and when we see that a node has no children we know this is one of the valid path.\\n\\n     public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> result = new ArrayList<String>();\\n        helper(root, result, \"\");\\n        return result;\\n    }\\n    public void helper(TreeNode root, List<String> result, String path){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.left == null && root.right == null){\\n            result.add(path+root.val);\\n            return;\\n        }\\n        \\n        helper(root.left, result, path+root.val+\"->\");\\n        helper(root.right, result, path+root.val+\"->\");\\n        return;\\n    }",
                "solutionTags": [],
                "code": "The idea is to perform a dfs, for every node we visit the path up till that node is path + currentNode.val and when we see that a node has no children we know this is one of the valid path.\\n\\n     public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> result = new ArrayList<String>();\\n        helper(root, result, \"\");\\n        return result;\\n    }\\n    public void helper(TreeNode root, List<String> result, String path){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.left == null && root.right == null){\\n            result.add(path+root.val);\\n            return;\\n        }\\n        \\n        helper(root.left, result, path+root.val+\"->\");\\n        helper(root.right, result, path+root.val+\"->\");\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68260,
                "title": "my-java-solution",
                "content": "    public class Solution {\\n     public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null){\\n            return new ArrayList<>();\\n        }\\n        List<String> returnList = new ArrayList<>();\\n        getBinaryTreePaths(returnList,root,\"\");\\n        return returnList;\\n\\n    }\\n\\n    private void getBinaryTreePaths(List<String> returnList, TreeNode node,String base) {\\n        String current = base.length()==0?node.val+\"\":base+\"->\"+node.val;\\n        if(node.left == null && node.right == null){\\n            returnList.add(current);\\n        }\\n        if (node.left != null){\\n            getBinaryTreePaths(returnList,node.left,current);\\n        }\\n        if (node.right != null){\\n            getBinaryTreePaths(returnList,node.right,current);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null){\\n            return new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3447521,
                "title": "c-accepted-using-recursion-and-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<string> binaryPaths(TreeNode* root) {\\n      vector<string> ans;\\n     // base condition   \\n      if(root==NULL){\\n       return ans;\\n      }\\n        if(root->left ==NULL && root->right ==NULL){\\n          ans.push_back(to_string(root->val));\\n       return ans;\\n      }\\n// recursion for triversing on all node\\n     vector<string> leftt =  binaryPaths(root->left); \\n     vector<string> rightt =  binaryPaths(root->right); \\n //to add root data and -> on all solution under that node    \\n     for(int i=0;i<leftt.size();i++){\\n      ans.push_back (to_string(root->val)+\"->\"+leftt[i]);\\n     }\\n     for(int j=0;j<rightt.size();j++){\\n      ans.push_back (to_string(root->val)+\"->\"+rightt[j]);\\n     }\\n   \\n     return ans;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n    vector<string> ans;   \\n    ans = binaryPaths(root) ;\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<string> binaryPaths(TreeNode* root) {\\n      vector<string> ans;\\n     // base condition   \\n      if(root==NULL){\\n       return ans;\\n      }\\n        if(root->left ==NULL && root->right ==NULL){\\n          ans.push_back(to_string(root->val));\\n       return ans;\\n      }\\n// recursion for triversing on all node\\n     vector<string> leftt =  binaryPaths(root->left); \\n     vector<string> rightt =  binaryPaths(root->right); \\n //to add root data and -> on all solution under that node    \\n     for(int i=0;i<leftt.size();i++){\\n      ans.push_back (to_string(root->val)+\"->\"+leftt[i]);\\n     }\\n     for(int j=0;j<rightt.size();j++){\\n      ans.push_back (to_string(root->val)+\"->\"+rightt[j]);\\n     }\\n   \\n     return ans;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n    vector<string> ans;   \\n    ans = binaryPaths(root) ;\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072837,
                "title": "back-tracking-4ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void BackTrack(TreeNode* root,string s,vector<string> &v)\\n    {\\n        if(root->left==NULL && root->right==NULL)\\n            s=s+to_string(root->val);\\n            v.push_back(s);\\n            return ;\\n        s=s+to_string(root->val)+\"->\";\\n        if(root->left!=NULL)\\n            BackTrack(root->left,s,v);\\n        if(root->right!=NULL)\\n            BackTrack(root->right,s,v);\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> v;\\n        BackTrack(root,\"\",v);\\n        return v;\\n    }\\n};// UPVOTE PLEASE\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void BackTrack(TreeNode* root,string s,vector<string> &v)\\n    {\\n        if(root->left==NULL && root->right==NULL)\\n            s=s+to_string(root->val);\\n            v.push_back(s);\\n            return ;\\n        s=s+to_string(root->val)+\"->\";\\n        if(root->left!=NULL)\\n            BackTrack(root->left,s,v);\\n        if(root->right!=NULL)\\n            BackTrack(root->right,s,v);\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> v;\\n        BackTrack(root,\"\",v);\\n        return v;\\n    }\\n};// UPVOTE PLEASE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597790,
                "title": "c-dfs-easy-commented-and-readable",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        void solve(TreeNode *root, vector<string> &ans, string s)\\n        {\\n           \\t// if the current node is not having either a left or a right then we are \\n           \\t// done with one root to leaf path so we push it into the answer\\n            if (!root->left && !root->right)\\n            {\\n                ans.push_back(s);\\n                return;\\n            }\\n\\n           \\t// we move towards either left of the root or right of the root, whichever\\n           \\t// suitable adding the current node\\'s value to the string and moving ahead\\n           \\t// this addition to our string goes on until we find our base condition break\\n            if (root->left) solve(root->left, ans, s + \"->\" + to_string(root->left->val));\\n            if (root->right) solve(root->right, ans, s + \"->\" + to_string(root->right->val));\\n        }\\n\\n    vector<string> binaryTreePaths(TreeNode *root)\\n    {\\n        vector<string> ans;\\n        if (!root) return ans;\\n       \\t// we make the value of our root node as a string\\n        string s = to_string(root->val);\\n        solve(root, ans, to_string(root->val));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        void solve(TreeNode *root, vector<string> &ans, string s)\\n        {\\n           \\t// if the current node is not having either a left or a right then we are \\n           \\t// done with one root to leaf path so we push it into the answer\\n            if (!root->left && !root->right)\\n            {\\n                ans.push_back(s);\\n                return;\\n            }\\n\\n           \\t// we move towards either left of the root or right of the root, whichever\\n           \\t// suitable adding the current node\\'s value to the string and moving ahead\\n           \\t// this addition to our string goes on until we find our base condition break\\n            if (root->left) solve(root->left, ans, s + \"->\" + to_string(root->left->val));\\n            if (root->right) solve(root->right, ans, s + \"->\" + to_string(root->right->val));\\n        }\\n\\n    vector<string> binaryTreePaths(TreeNode *root)\\n    {\\n        vector<string> ans;\\n        if (!root) return ans;\\n       \\t// we make the value of our root node as a string\\n        string s = to_string(root->val);\\n        solve(root, ans, to_string(root->val));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981927,
                "title": "simple-python-recursive-solution-using-preorder-traversal-with-explanation",
                "content": "**VOTE  UP  IF  YOU  LIKE  AND  UNDERSTAND  THE  SOLUTION**\\n\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans=[]           # resultant list containing all paths.\\n        def preorder(root,s):\\n            if not root.left and not root.right:        # If leaf node occurs then path ends here so append the string in \\'ans\\'.\\n                ans.append(s+str(root.val))\\n                return\\n            s+=str(root.val)        # concatenate value of root in the path \\n            if root.left:                # If there is any node in left to traverse\\n                preorder(root.left,s+\"->\")\\n            if root.right:             # If there is any node in right to traverse\\n                preorder(root.right,s+\"->\")\\n            return\\n\\t\\t\\t\\n        preorder(root,\"\")         # main calling of preOrder with empty string\\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/9143281d-9a54-419f-84a4-f00740fd4567_1650906957.1431794.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans=[]           # resultant list containing all paths.\\n        def preorder(root,s):\\n            if not root.left and not root.right:        # If leaf node occurs then path ends here so append the string in \\'ans\\'.\\n                ans.append(s+str(root.val))\\n                return\\n            s+=str(root.val)        # concatenate value of root in the path \\n            if root.left:                # If there is any node in left to traverse\\n                preorder(root.left,s+\"->\")\\n            if root.right:             # If there is any node in right to traverse\\n                preorder(root.right,s+\"->\")\\n            return\\n\\t\\t\\t\\n        preorder(root,\"\")         # main calling of preOrder with empty string\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706552,
                "title": "c-simple-using-preorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void preorder(TreeNode* root, string str){\\n        \\n        if(root == NULL){\\n            return;\\n        }\\n        if(root -> right == NULL and root -> left  == NULL){\\n            string x = to_string(root -> val);\\n            str.append(x);\\n            ans.push_back(str);\\n        }\\n        string x = to_string(root -> val);\\n        str.append(x);\\n        str.append(\"->\");\\n        preorder(root-> left, str);\\n        preorder(root -> right, str);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string str;\\n        preorder(root,str);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void preorder(TreeNode* root, string str){\\n        \\n        if(root == NULL){\\n            return;\\n        }\\n        if(root -> right == NULL and root -> left  == NULL){\\n            string x = to_string(root -> val);\\n            str.append(x);\\n            ans.push_back(str);\\n        }\\n        string x = to_string(root -> val);\\n        str.append(x);\\n        str.append(\"->\");\\n        preorder(root-> left, str);\\n        preorder(root -> right, str);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string str;\\n        preorder(root,str);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157075,
                "title": "java-clean-code-backtracking-1ms-99-86-38-7mb-96-85",
                "content": "With `List<Integer> tmp`:\\n```\\npublic List<String> binaryTreePaths(TreeNode root) {\\n\\tList<String> res = new LinkedList<>();\\n\\tbackTracking(root, res, new ArrayList<>(), new StringBuilder());\\n\\treturn res;\\n}\\nprivate void backTracking(TreeNode node, List<String> collector, List<Integer> tmp, StringBuilder sb) {\\n\\tif (node.left == null && node.right == null) {\\n\\t\\tfor (int val : tmp) {\\n\\t\\t\\tsb.append(val).append(\"->\");\\n\\t\\t}\\n\\t\\tsb.append(node.val);\\n\\t\\tcollector.add(sb.toString());\\n\\t\\tsb.setLength(0);\\n\\t\\treturn;\\n\\t}\\n\\ttmp.add(node.val);\\n\\tif (node.left != null) backTracking(node.left, collector, tmp, sb);\\n\\tif (node.right != null) backTracking(node.right, collector, tmp, sb);\\n\\ttmp.remove(tmp.size()-1);\\n}\\n```\\n\\n\\n---\\nWithout `List<Integer> tmp`:\\n```\\npublic List<String> binaryTreePaths(TreeNode root) {\\n\\tList<String> res = new LinkedList<>();\\n\\tbackTracking(root, res, new StringBuilder());\\n\\treturn res;\\n}\\nprivate void backTracking(TreeNode node, List<String> collector, StringBuilder sb) {\\n\\tint len = sb.length();\\n\\tsb.append(node.val);\\n\\tif (node.left == null && node.right == null) {\\n\\t\\tcollector.add(sb.toString());\\n\\t} else {\\n\\t\\tsb.append(\"->\");\\n\\t\\tif (node.left != null) backTracking(node.left, collector, sb);\\n\\t\\tif (node.right != null) backTracking(node.right, collector, sb);\\n\\t}\\n\\tsb.setLength(len);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic List<String> binaryTreePaths(TreeNode root) {\\n\\tList<String> res = new LinkedList<>();\\n\\tbackTracking(root, res, new ArrayList<>(), new StringBuilder());\\n\\treturn res;\\n}\\nprivate void backTracking(TreeNode node, List<String> collector, List<Integer> tmp, StringBuilder sb) {\\n\\tif (node.left == null && node.right == null) {\\n\\t\\tfor (int val : tmp) {\\n\\t\\t\\tsb.append(val).append(\"->\");\\n\\t\\t}\\n\\t\\tsb.append(node.val);\\n\\t\\tcollector.add(sb.toString());\\n\\t\\tsb.setLength(0);\\n\\t\\treturn;\\n\\t}\\n\\ttmp.add(node.val);\\n\\tif (node.left != null) backTracking(node.left, collector, tmp, sb);\\n\\tif (node.right != null) backTracking(node.right, collector, tmp, sb);\\n\\ttmp.remove(tmp.size()-1);\\n}\\n```\n```\\npublic List<String> binaryTreePaths(TreeNode root) {\\n\\tList<String> res = new LinkedList<>();\\n\\tbackTracking(root, res, new StringBuilder());\\n\\treturn res;\\n}\\nprivate void backTracking(TreeNode node, List<String> collector, StringBuilder sb) {\\n\\tint len = sb.length();\\n\\tsb.append(node.val);\\n\\tif (node.left == null && node.right == null) {\\n\\t\\tcollector.add(sb.toString());\\n\\t} else {\\n\\t\\tsb.append(\"->\");\\n\\t\\tif (node.left != null) backTracking(node.left, collector, sb);\\n\\t\\tif (node.right != null) backTracking(node.right, collector, sb);\\n\\t}\\n\\tsb.setLength(len);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520487,
                "title": "c-faster-than-97-10-less-than-16-67-mem-o-n",
                "content": "Runtime: 236 ms\\nMemory Usage: 31.6 MB\\n\\n```\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        IList<string> result = new List<string>();\\n        StringBuilder st = new StringBuilder();\\n        BuildPath(root, st, result);\\n        return result;\\n    }\\n    \\n    private void BuildPath(TreeNode root, StringBuilder st, IList<string> result)\\n    {\\n        if (root == null) { return; }\\n        \\n        int len = st.Length; \\n        \\n        st.Append(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            result.Add(st.ToString());\\n        }\\n        else\\n        {\\n            st.Append(\"->\");\\n            BuildPath(root.left, st, result);\\n            BuildPath(root.right, st, result);\\n        }\\n        \\n        st.Length = len;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "Runtime: 236 ms\\nMemory Usage: 31.6 MB\\n\\n```\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        IList<string> result = new List<string>();\\n        StringBuilder st = new StringBuilder();\\n        BuildPath(root, st, result);\\n        return result;\\n    }\\n    \\n    private void BuildPath(TreeNode root, StringBuilder st, IList<string> result)\\n    {\\n        if (root == null) { return; }\\n        \\n        int len = st.Length; \\n        \\n        st.Append(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            result.Add(st.ToString());\\n        }\\n        else\\n        {\\n            st.Append(\"->\");\\n            BuildPath(root.left, st, result);\\n            BuildPath(root.right, st, result);\\n        }\\n        \\n        st.Length = len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68437,
                "title": "my-java-solution-with-stringbuilder-may-help-u",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public void help(List<String> list, TreeNode node, StringBuilder sb) {\\n    \\t\\tif (node == null)\\n    \\t\\t\\treturn;\\n    \\t\\tint len=sb.length();\\n    \\t\\tsb.append(node.val);\\n    \\t\\tif (node.left == null && node.right == null) {\\t\\t\\t\\t\\n    \\t\\t\\tlist.add(sb.toString());\\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tsb.append(\"->\");\\n    \\t\\thelp(list, node.left, sb);\\n    \\t\\thelp(list, node.right, sb);\\n    \\t\\tsb.setLength(len);\\n    \\t}\\n    \\n    \\tpublic List<String> binaryTreePaths(TreeNode root) {\\n    \\t\\tList<String> res = new ArrayList<String>();\\n    \\t\\thelp(res, root, new StringBuilder());\\n    \\t\\treturn res;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void help(List<String> list, TreeNode node, StringBuilder sb) {\\n    \\t\\tif (node == null)\\n    \\t\\t\\treturn;\\n    \\t\\tint len=sb.length();\\n    \\t\\tsb.append(node.val);\\n    \\t\\tif (node.left == null && node.right == null) {\\t\\t\\t\\t\\n    \\t\\t\\tlist.add(sb.toString());\\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\treturn;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 68489,
                "title": "my-recursive-javascript-solution",
                "content": "     /**\\n     * Definition for a binary tree node.\\n     * function TreeNode(val) {\\n     *     this.val = val;\\n     *     this.left = this.right = null;\\n     * }\\n     */\\n    /**\\n     * @param {TreeNode} root\\n     * @return {string[]}\\n     */\\n    var binaryTreePaths = function(root) {\\n        var result = [];\\n    \\n        var findPath = function(node, path) {\\n            if(!node) {\\n                return;\\n            } else {\\n                path += node.val;\\n            }\\n            \\n            if(!node.left && !node.right) {\\n                return result.push(path);\\n            } else {\\n                path += \"->\";\\n            }\\n            \\n            if(node.left) {\\n                findPath(node.left, path);\\n            }\\n            \\n            if(node.right) {\\n                findPath(node.right, path);\\n            }\\n        }\\n        \\n        findPath(root, \"\");\\n        return result;\\n    };",
                "solutionTags": [],
                "code": "     /**\\n     * Definition for a binary tree node.\\n     * function TreeNode(val) {\\n     *     this.val = val;\\n     *     this.left = this.right = null;\\n     * }\\n     */\\n    /**\\n     * @param {TreeNode} root\\n     * @return {string[]}\\n     */\\n    var binaryTreePaths = function(root) {\\n        var result = [];\\n    \\n        var findPath = function(node, path) {\\n            if(!node) {\\n                return;\\n            } else {\\n                path += node.val;\\n            }\\n            \\n            if(!node.left && !node.right) {\\n                return result.push(path);\\n            } else {\\n                path += \"->\";\\n            }\\n            \\n            if(node.left) {\\n                findPath(node.left, path);\\n            }\\n            \\n            if(node.right) {\\n                findPath(node.right, path);\\n            }\\n        }\\n        \\n        findPath(root, \"\");\\n        return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 68520,
                "title": "myjavaeasysolution",
                "content": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<String>();\\n        if(root != null){\\n            res.addAll(binaryTreePaths(root.left));\\n            res.addAll(binaryTreePaths(root.right));\\n            for(int i=0; i < res.size();i++){\\n                String path = root.val+\"->\"+res.get(i);\\n                res.set(i,path);\\n            }\\n            \\n            if(res.size()==0) res.add(String.valueOf(root.val));\\n        }\\n        return res;\\n         \\n    }",
                "solutionTags": [],
                "code": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<String>();\\n        if(root != null){\\n            res.addAll(binaryTreePaths(root.left));\\n            res.addAll(binaryTreePaths(root.right));\\n            for(int i=0; i < res.size();i++){\\n                String path = root.val+\"->\"+res.get(i);\\n                res.set(i,path);\\n            }\\n            \\n            if(res.size()==0) res.add(String.valueOf(root.val));\\n        }\\n        return res;\\n         \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3654265,
                "title": "easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    void dfs(vector<string> &res, TreeNode *root, string cur)\\n    {\\n        if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n        else\\n        {\\n            if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n            if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if(root)  dfs(res, root, \"\");\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<string> &res, TreeNode *root, string cur)\\n    {\\n        if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n        else\\n        {\\n            if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n            if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if(root)  dfs(res, root, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520019,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode * root, vector<string>&ans, string s)\\n    {\\n        if(!root)return;\\n        if(!root->left && !root->right)\\n        {\\n            s += to_string(root->val);\\n            ans.push_back(s);\\n        }\\n        s += to_string(root->val);\\n        solve(root->left, ans, s+\"->\");\\n        solve(root->right, ans, s+\"->\");\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) \\n    {\\n        string s = \"\";\\n        vector<string>ans;\\n        solve(root, ans, s);    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode * root, vector<string>&ans, string s)\\n    {\\n        if(!root)return;\\n        if(!root->left && !root->right)\\n        {\\n            s += to_string(root->val);\\n            ans.push_back(s);\\n        }\\n        s += to_string(root->val);\\n        solve(root->left, ans, s+\"->\");\\n        solve(root->right, ans, s+\"->\");\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) \\n    {\\n        string s = \"\";\\n        vector<string>ans;\\n        solve(root, ans, s);    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168127,
                "title": "binary-tree-path-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPre-order traversal\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n0. Do the pre-order traversal.\\n1. Kepp collecting the node values in an array.\\n2. As soon as get the leaf child, push the current collection of nodes in the answer array.\\n3. At end just convert all the paths as per output requirement\\n4. Return you final collection of paths\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(no. of nodes in widest level)$$\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {string[]}\\n */\\nvar binaryTreePaths = function(root) {\\n    let paths = [];\\n\\n    function preOrder(node,currPath){\\n        if(node){\\n            currPath.push(node.val);\\n            if(node.left==null && node.right==null){\\n                paths.push([...currPath]);\\n            }\\n            preOrder(node.left,[...currPath]);\\n            preOrder(node.right,[...currPath]);\\n        }\\n    }\\n    preOrder(root,[]);\\n    let ans = paths.map(path => path.join(\"->\"))\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {string[]}\\n */\\nvar binaryTreePaths = function(root) {\\n    let paths = [];\\n\\n    function preOrder(node,currPath){\\n        if(node){\\n            currPath.push(node.val);\\n            if(node.left==null && node.right==null){\\n                paths.push([...currPath]);\\n            }\\n            preOrder(node.left,[...currPath]);\\n            preOrder(node.right,[...currPath]);\\n        }\\n    }\\n    preOrder(root,[]);\\n    let ans = paths.map(path => path.join(\"->\"))\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2642914,
                "title": "python-recursive-approach-easy-to-understand",
                "content": "**Approach 1:**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        result = []\\n        def dfs(temp, root):\\n            if root:\\n                temp = temp + str(root.val) + \\'->\\'\\n                if not root.left and not root.right:\\n                    result.append(temp[:-2])\\n                dfs(temp, root.left)\\n                dfs(temp, root.right)\\n        dfs(\\'\\', root)\\n        return result\\n```\\n**Approach 2:**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root:\\n            return []\\n        result, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.right and not node.left:\\n                result.append(ls+str(node.val))\\n            if node.right:\\n                stack.append([node.right, ls + str(node.val) + \\'->\\'])\\n            if node.left:\\n                stack.append([node.left, ls + str(node.val) + \\'->\\'])\\n        return result\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        result = []\\n        def dfs(temp, root):\\n            if root:\\n                temp = temp + str(root.val) + \\'->\\'\\n                if not root.left and not root.right:\\n                    result.append(temp[:-2])\\n                dfs(temp, root.left)\\n                dfs(temp, root.right)\\n        dfs(\\'\\', root)\\n        return result\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root:\\n            return []\\n        result, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.right and not node.left:\\n                result.append(ls+str(node.val))\\n            if node.right:\\n                stack.append([node.right, ls + str(node.val) + \\'->\\'])\\n            if node.left:\\n                stack.append([node.left, ls + str(node.val) + \\'->\\'])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584597,
                "title": "java-easy-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> list = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String s=\"\";\\n        dfs(root,s);\\n        return list;\\n    }\\n    public void dfs(TreeNode root, String s){\\n        if(root!=null){\\n            if(root.left==null && root.right==null){\\n                list.add(s+root.val);\\n            }\\n            dfs(root.left,s+root.val+\"->\");\\n            dfs(root.right,s+root.val+\"->\");\\n        }\\n    }\\n}\\n```\\n# upvote if u found it useful",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> list = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String s=\"\";\\n        dfs(root,s);\\n        return list;\\n    }\\n    public void dfs(TreeNode root, String s){\\n        if(root!=null){\\n            if(root.left==null && root.right==null){\\n                list.add(s+root.val);\\n            }\\n            dfs(root.left,s+root.val+\"->\");\\n            dfs(root.right,s+root.val+\"->\");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523403,
                "title": "python-solutions-using-dfs-and-bfs",
                "content": "## DFS with Recursion\\n\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root: return None\\n    \\n        res = []\\n        def paths(root, path):\\n            if not any([root.left, root.right]):\\n                res.append(path)\\n                \\n            paths(root.left, path + \\'->\\' + str(root.left.val)) if root.left else None\\n            paths(root.right, path + \\'->\\' + str(root.right.val)) if root.right else None\\n        \\n        paths(root, str(root.val))\\n        return res\\n```\\n\\n## BFS Iterative Solution\\n\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root: return None\\n        \\n        q=[(root, str(root.val))]\\n        res = []\\n        \\n        while q:\\n            \\n            node, path_upto_node = q.pop()\\n            \\n            if not any([node.left, node.right]):\\n                res.append(path_upto_node)\\n            \\n            else:\\n                q.append((node.left, path_upto_node + \\'->\\' + str(node.left.val))) if node.left else None\\n                q.append((node.right, path_upto_node + \\'->\\' + str(node.right.val))) if node.right else None\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root: return None\\n    \\n        res = []\\n        def paths(root, path):\\n            if not any([root.left, root.right]):\\n                res.append(path)\\n                \\n            paths(root.left, path + \\'->\\' + str(root.left.val)) if root.left else None\\n            paths(root.right, path + \\'->\\' + str(root.right.val)) if root.right else None\\n        \\n        paths(root, str(root.val))\\n        return res\\n```\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root: return None\\n        \\n        q=[(root, str(root.val))]\\n        res = []\\n        \\n        while q:\\n            \\n            node, path_upto_node = q.pop()\\n            \\n            if not any([node.left, node.right]):\\n                res.append(path_upto_node)\\n            \\n            else:\\n                q.append((node.left, path_upto_node + \\'->\\' + str(node.left.val))) if node.left else None\\n                q.append((node.right, path_upto_node + \\'->\\' + str(node.right.val))) if node.right else None\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335365,
                "title": "c-easy-beats-100",
                "content": "\\n    vector<string> ans; \\n    \\n    void treePath(TreeNode* root, string s){\\n        if(!root) return; // Base case\\n        s += to_string(root->val); // Adding the current node\\'s value to string\\n\\t\\t\\n\\t\\t// if root has any of the the child present then only add \"->\" to current string\\n        if(root->left || root->right){ \\n            s += \"->\";\\n        }\\n\\t\\t\\n\\t\\t// if current node has no children then push the current string to ans vector\\n        if(!root->left && !root->right){\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t// recursive call\\n        treePath(root->left,s);\\n        treePath(root->right,s);\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        treePath(root,\"\");\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "\\n    vector<string> ans; \\n    \\n    void treePath(TreeNode* root, string s){\\n        if(!root) return; // Base case\\n        s += to_string(root->val); // Adding the current node\\'s value to string\\n\\t\\t\\n\\t\\t// if root has any of the the child present then only add \"->\" to current string\\n        if(root->left || root->right){ \\n            s += \"->\";\\n        }\\n\\t\\t\\n\\t\\t// if current node has no children then push the current string to ans vector\\n        if(!root->left && !root->right){\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t// recursive call\\n        treePath(root->left,s);\\n        treePath(root->right,s);\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        treePath(root,\"\");\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1650763,
                "title": "java-dfs-short-simple-100-faster",
                "content": "```\\nclass Solution {\\n    List<String> ans;\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ans = new LinkedList<>();\\n        paths(root,\"\");\\n        return ans;\\n    }\\n    void paths(TreeNode root, String s){\\n        if(root==null){\\n            return;\\n        }\\n        if(root.left==null && root.right==null){\\n            ans.add(s.concat(String.valueOf(root.val)));\\n        }\\n        paths(root.left, s.concat(String.valueOf(root.val).concat(\"->\")));\\n        paths(root.right, s.concat(String.valueOf(root.val).concat(\"->\")));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    List<String> ans;\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ans = new LinkedList<>();\\n        paths(root,\"\");\\n        return ans;\\n    }\\n    void paths(TreeNode root, String s){\\n        if(root==null){\\n            return;\\n        }\\n        if(root.left==null && root.right==null){\\n            ans.add(s.concat(String.valueOf(root.val)));\\n        }\\n        paths(root.left, s.concat(String.valueOf(root.val).concat(\"->\")));\\n        paths(root.right, s.concat(String.valueOf(root.val).concat(\"->\")));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625427,
                "title": "c-understanble-recursion",
                "content": "**_Upvote if you found solution useful_**\\n\\n---\\n```C++\\nclass Solution\\n{\\npublic:\\n    void solve(TreeNode *root, vector<string> &res, string curr)\\n    {\\n        if (root->left == NULL and root->right == NULL)\\n        {\\n            curr += to_string(root->val);\\n            res.push_back(curr);\\n            return;\\n        }\\n        string s = to_string(root->val) + \"->\";\\n        if (root->left and !root->right)\\n        {\\n            curr += s;\\n            solve(root->left, res, curr);\\n        }\\n        else if (root->right and !root->left)\\n        {\\n            curr += s;\\n            solve(root->right, res, curr);\\n        }\\n        else\\n        {\\n            curr += s;\\n            solve(root->left, res, curr);\\n            solve(root->right, res, curr);\\n        }\\n    }\\n    vector<string> binaryTreePaths(TreeNode *root)\\n    {\\n        vector<string> res;\\n        solve(root, res, \"\");\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n    void solve(TreeNode *root, vector<string> &res, string curr)\\n    {\\n        if (root->left == NULL and root->right == NULL)\\n        {\\n            curr += to_string(root->val);\\n            res.push_back(curr);\\n            return;\\n        }\\n        string s = to_string(root->val) + \"->\";\\n        if (root->left and !root->right)\\n        {\\n            curr += s;\\n            solve(root->left, res, curr);\\n        }\\n        else if (root->right and !root->left)\\n        {\\n            curr += s;\\n            solve(root->right, res, curr);\\n        }\\n        else\\n        {\\n            curr += s;\\n            solve(root->left, res, curr);\\n            solve(root->right, res, curr);\\n        }\\n    }\\n    vector<string> binaryTreePaths(TreeNode *root)\\n    {\\n        vector<string> res;\\n        solve(root, res, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590704,
                "title": "simple-c-soln-using-preorder-traversal",
                "content": "Please upvote if found useful! :))\\nNew suggestions are welcome!\\n```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    void preorder(TreeNode *root,string temp){       \\n        if(!root)\\n            return;\\n        //add the current node value\\n        if(temp == \"\") temp += to_string(root->val);\\n        else temp += \"->\"+to_string(root->val);\\n        //if the current node is leaf, then add it to the answer array\\n        if(root->left==NULL && root->right==NULL)\\n            ans.push_back(temp);\\n        //perform preorder traversal\\n        preorder(root->left,temp);\\n        preorder(root->right,temp);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(!root) return ans;\\n        preorder(root,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    void preorder(TreeNode *root,string temp){       \\n        if(!root)\\n            return;\\n        //add the current node value\\n        if(temp == \"\") temp += to_string(root->val);\\n        else temp += \"->\"+to_string(root->val);\\n        //if the current node is leaf, then add it to the answer array\\n        if(root->left==NULL && root->right==NULL)\\n            ans.push_back(temp);\\n        //perform preorder traversal\\n        preorder(root->left,temp);\\n        preorder(root->right,temp);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(!root) return ans;\\n        preorder(root,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470608,
                "title": "c-0ms-100-beats",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void fun(TreeNode* root,string s)\\n    {\\n        if(!root->left && !root->right) ans.push_back(s);\\n        if(root->left) fun(root->left,s+\"->\"+to_string(root->left->val));\\n        if(root->right) fun(root->right,s+\"->\"+to_string(root->right->val));\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string s=\"\";\\n        s+=to_string(root->val);\\n        fun(root,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void fun(TreeNode* root,string s)\\n    {\\n        if(!root->left && !root->right) ans.push_back(s);\\n        if(root->left) fun(root->left,s+\"->\"+to_string(root->left->val));\\n        if(root->right) fun(root->right,s+\"->\"+to_string(root->right->val));\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string s=\"\";\\n        s+=to_string(root->val);\\n        fun(root,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367748,
                "title": "java-stringbuilder-recursion-preorder-easy-1ms-solution",
                "content": "Create a String or StringBuilder(mutable) traverse the tree in preOrder, add node Values until you find a null & at leaf add the node and return.\\n```\\n List<String> ans;\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ans = new ArrayList<>();\\n        solve(root, new StringBuilder());\\n        return ans;\\n    }\\n    public void solve(TreeNode root, StringBuilder res){\\n        if(root == null)\\n            return;\\n        \\n        int len = res.length();\\n        res.append(root.val);\\n        if(root.left == null && root.right == null){\\n            ans.add(res.toString());\\n        }\\n        else{\\n            res.append(\"->\");\\n            if(root.left != null)\\n                solve(root.left, res);\\n            if(root.right != null)\\n                solve(root.right, res);\\n        }\\n        res.setLength(len);\\n    }\\n```\\nTime Complexity : `O(N)`\\nN number of nodes\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n List<String> ans;\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ans = new ArrayList<>();\\n        solve(root, new StringBuilder());\\n        return ans;\\n    }\\n    public void solve(TreeNode root, StringBuilder res){\\n        if(root == null)\\n            return;\\n        \\n        int len = res.length();\\n        res.append(root.val);\\n        if(root.left == null && root.right == null){\\n            ans.add(res.toString());\\n        }\\n        else{\\n            res.append(\"->\");\\n            if(root.left != null)\\n                solve(root.left, res);\\n            if(root.right != null)\\n                solve(root.right, res);\\n        }\\n        res.setLength(len);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 574735,
                "title": "java-dfs-recursive-easy-to-understand-with-explaination",
                "content": "The template function is quite straightforward.\\nIn the recursive function, we first check if the root is null, then it will return without doing anything (this covers the original test case of root being null, as the empty res will be returned). Now, we add the value of the root to the current path string value.\\nbecause we need the path with arrows, pass the string with arrows in the dfs recursion calls.\\nNo need to check for empty root.left or root.right, because it is taken care of at the start of the recursive function.\\nAt the end, check if both children are null. If so, add the current string to the res list.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        writePaths(root, res, \"\");\\n        return res;\\n    }\\n    public void writePaths(TreeNode root, List<String> res, String curr){\\n        if(root == null) return;\\n        curr += root.val;\\n        writePaths(root.left, res, curr+\"->\");\\n        writePaths(root.right, res, curr+\"->\");\\n        if(root.left == null && root.right == null) res.add(curr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        writePaths(root, res, \"\");\\n        return res;\\n    }\\n    public void writePaths(TreeNode root, List<String> res, String curr){\\n        if(root == null) return;\\n        curr += root.val;\\n        writePaths(root.left, res, curr+\"->\");\\n        writePaths(root.right, res, curr+\"->\");\\n        if(root.left == null && root.right == null) res.add(curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299070,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        var result = new List<string>();\\n        DFS(root, new List<string>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(TreeNode root, IList<string> oneResult, IList<string> result) {\\n        if (root == null) return;\\n        oneResult.Add($\"{root.val}\");\\n        if (root.left == null && root.right == null) {\\n            // leaf\\n            result.Add(string.Join(\"->\", oneResult));\\n        } else {\\n            DFS(root.left, oneResult, result);\\n            DFS(root.right, oneResult, result);\\n        }\\n        oneResult.RemoveAt(oneResult.Count - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        var result = new List<string>();\\n        DFS(root, new List<string>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(TreeNode root, IList<string> oneResult, IList<string> result) {\\n        if (root == null) return;\\n        oneResult.Add($\"{root.val}\");\\n        if (root.left == null && root.right == null) {\\n            // leaf\\n            result.Add(string.Join(\"->\", oneResult));\\n        } else {\\n            DFS(root.left, oneResult, result);\\n            DFS(root.right, oneResult, result);\\n        }\\n        oneResult.RemoveAt(oneResult.Count - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131174,
                "title": "7-lines-in-kotlin-easy-to-understand",
                "content": "```\\nfun binaryTreePaths(root: TreeNode?): List<String> {\\n        if (root == null)\\n            return emptyList()\\n\\n        if (root.left == null && root.right == null)\\n            return listOf(root.`val`.toString())\\n\\n        val left = binaryTreePaths(root.left)\\n        val right = binaryTreePaths(root.right)\\n\\n        return (left + right).map { root.`val`.toString() + \"->\" + it }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun binaryTreePaths(root: TreeNode?): List<String> {\\n        if (root == null)\\n            return emptyList()\\n\\n        if (root.left == null && root.right == null)\\n            return listOf(root.`val`.toString())\\n\\n        val left = binaryTreePaths(root.left)\\n        val right = binaryTreePaths(root.right)\\n\\n        return (left + right).map { root.`val`.toString() + \"->\" + it }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68333,
                "title": "c-solution-0ms-using-asprintf-to-dynamically-grow-the-path-buffer",
                "content": "```\\nvoid binaryTreePathsHelper(struct TreeNode *node, char ***result, int *resultSize, char *path) {\\n    if (!node) return;\\n    char *newPath = NULL;\\n    if (node->left == NULL && node->right == NULL) {\\n        asprintf(&newPath, \"%s%d\", path, node->val);\\n        *result = realloc(*result, ++(*resultSize) * sizeof(char **));\\n        (*result)[*resultSize - 1] = newPath;\\n        return;   \\n    }\\n    asprintf(&newPath, \"%s%d->\", path, node->val);\\n    binaryTreePathsHelper(node->left, result, resultSize, newPath);\\n    binaryTreePathsHelper(node->right, result, resultSize, newPath);\\n    free(newPath);\\n}\\n\\nchar** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n    if (!root) return NULL;\\n    char **result = NULL;\\n    binaryTreePathsHelper(root, &result, returnSize, \"\");\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid binaryTreePathsHelper(struct TreeNode *node, char ***result, int *resultSize, char *path) {\\n    if (!node) return;\\n    char *newPath = NULL;\\n    if (node->left == NULL && node->right == NULL) {\\n        asprintf(&newPath, \"%s%d\", path, node->val);\\n        *result = realloc(*result, ++(*resultSize) * sizeof(char **));\\n        (*result)[*resultSize - 1] = newPath;\\n        return;   \\n    }\\n    asprintf(&newPath, \"%s%d->\", path, node->val);\\n    binaryTreePathsHelper(node->left, result, resultSize, newPath);\\n    binaryTreePathsHelper(node->right, result, resultSize, newPath);\\n    free(newPath);\\n}\\n\\nchar** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n    if (!root) return NULL;\\n    char **result = NULL;\\n    binaryTreePathsHelper(root, &result, returnSize, \"\");\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68466,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> vecRet;\\n            if (root == NULL) return vecRet;\\n            string s = \"\";\\n            getTreePaths(vecRet, s, root);\\n            \\n            return vecRet;\\n        }\\n        void getTreePaths(vector<string> &vecRet, string s, TreeNode *root) {\\n            if (root == NULL) return;\\n            \\n            s += to_string(root->val);\\n            if (root->left == NULL && root->right == NULL)//the current node is leaf,then put s into vecRet\\n                vecRet.push_back(s);\\n            else\\n                s += \"->\";\\n    \\n            getTreePaths(vecRet, s, root->left);//recur in left subtree\\n            getTreePaths(vecRet, s, root->right);//recur in right subtree\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> vecRet;\\n            if (root == NULL) return vecRet;\\n            string s = \"\";\\n            getTreePaths(vecRet, s, root);\\n            \\n            return vecRet;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68398,
                "title": "binary-tree-paths-dfs-java-solution",
                "content": "\\npublic class Solution {\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n\\n        List<String> ret = new ArrayList<String>();\\n        \\n        if(root == null){\\n            return ret;\\n        }\\n        \\n        dfs(root, new StringBuilder(), ret);\\n        \\n        return ret;\\n    }\\n    \\n    public void dfs(TreeNode root, StringBuilder sb, List<String> ret){\\n\\n       if(root.left == null && root.right == null){\\n           sb.append(root.val);\\n           ret.add(sb.toString());\\n           return;\\n       }\\n        \\n       sb.append(root.val);\\n       sb.append(\"->\");\\n       \\n       if(root.left != null){\\n           dfs(root.left, new StringBuilder(sb), ret);\\n       }\\n       \\n       if(root.right != null){\\n           dfs(root.right, new StringBuilder(sb), ret);\\n       }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n\\n        List<String> ret = new ArrayList<String>();\\n        \\n        if(root == null){\\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3832627,
                "title": "java-short-easy-recursive-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) stack space in memory\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n      List<String> ans = new ArrayList<>();\\n      if(root != null) dfs(root, \"\", ans);\\n      return ans;   \\n    }\\n    public void dfs(TreeNode root, String path, List<String> ans) {\\n        if(root.left == null && root.right == null) ans.add(path + root.val);\\n        if(root.left != null) dfs(root.left, path + root.val + \"->\", ans);\\n        if(root.right != null) dfs(root.right, path + root.val + \"->\", ans);\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n      List<String> ans = new ArrayList<>();\\n      if(root != null) dfs(root, \"\", ans);\\n      return ans;   \\n    }\\n    public void dfs(TreeNode root, String path, List<String> ans) {\\n        if(root.left == null && root.right == null) ans.add(path + root.val);\\n        if(root.left != null) dfs(root.left, path + root.val + \"->\", ans);\\n        if(root.right != null) dfs(root.right, path + root.val + \"->\", ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619326,
                "title": "java-program-to-get-all-possible-path-of-tree",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The `binaryTreePath` method takes three parameters: `root` (the current node in the binary tree), `path` (a string representing the path from the root to the current node), and `list` (a list to store all the paths).\\n   \\n2. The first condition checks if the `root` is null, which means we have reached the end of a path. In this case, it simply returns the `list` as it is.\\n\\n3. The second condition checks if the current node is a leaf node (i.e., it doesn\\'t have any left or right child). If it is a leaf node, it means we have reached the end of a path, so we add the current path (`path + root.val`) to the `list` and return the updated `list`.\\n\\n4. If the above conditions are not met, it means we are still traversing the tree. We recursively call the `binaryTreePath` method for the left child of the current node, passing the updated `path` (including the current node value and an arrow \"->\") and the same `list`.\\n\\n5. Similarly, we recursively call the `binaryTreePath` method for the right child of the current node, passing the updated `path` and the same `list`.\\n\\n6. Finally, after traversing all the paths, we return the `list` containing all the paths.\\n\\n7. The `binaryTreePaths` method is the public interface for this functionality. It initializes an empty list (`list`) and calls the `binaryTreePath` method with the `root` of the binary tree, an empty string as the initial path, and the `list`.\\n\\n8. It returns the `list` containing all the paths from the root to the leaf nodes in the binary tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePath(TreeNode root,String path,List<String> list){\\n        if(root == null){\\n            return list;\\n        }\\n        if(root.left == null && root.right == null){\\n            list.add(path + root.val);\\n            return list;\\n        }\\n        binaryTreePath(root.left,(path + root.val + \"->\"),list);\\n        binaryTreePath(root.right,(path + root.val + \"->\"),list);\\n        return list;\\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        binaryTreePath(root,\"\",list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePath(TreeNode root,String path,List<String> list){\\n        if(root == null){\\n            return list;\\n        }\\n        if(root.left == null && root.right == null){\\n            list.add(path + root.val);\\n            return list;\\n        }\\n        binaryTreePath(root.left,(path + root.val + \"->\"),list);\\n        binaryTreePath(root.right,(path + root.val + \"->\"),list);\\n        return list;\\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        binaryTreePath(root,\"\",list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432756,
                "title": "binbin-s-another-brilliant-idea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if root.left is None and root.right is None:\\n            return [str(root.val)]\\n        def findpath(node,l,L):\\n            if node.left is None and node.right is None:\\n                l += str(node.val)\\n                L.append(l)\\n            if node.left is not None:\\n                findpath(node.left,l+str(node.val)+\"->\",L)\\n            if node.right is not None:\\n                findpath(node.right,l+str(node.val)+\"->\",L)\\n            return L      \\n       \\n        return findpath(root,\"\",[])\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if root.left is None and root.right is None:\\n            return [str(root.val)]\\n        def findpath(node,l,L):\\n            if node.left is None and node.right is None:\\n                l += str(node.val)\\n                L.append(l)\\n            if node.left is not None:\\n                findpath(node.left,l+str(node.val)+\"->\",L)\\n            if node.right is not None:\\n                findpath(node.right,l+str(node.val)+\"->\",L)\\n            return L      \\n       \\n        return findpath(root,\"\",[])\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338140,
                "title": "most-simple-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String s=\"\";\\n        List l=new ArrayList<>();\\n        return solve(root,l,s);\\n    }\\n    public List<String> solve(TreeNode root,List l, String s){\\n        if(root==null) return l;\\n        if(root.left==null && root.right==null){    //if it is a leaf node\\n            l.add(s+root.val);\\n            return l;\\n        }\\n        s= s+root.val+\"->\";\\n        solve(root.left, l, s);\\n        solve(root.right, l, s);\\n        return l;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String s=\"\";\\n        List l=new ArrayList<>();\\n        return solve(root,l,s);\\n    }\\n    public List<String> solve(TreeNode root,List l, String s){\\n        if(root==null) return l;\\n        if(root.left==null && root.right==null){    //if it is a leaf node\\n            l.add(s+root.val);\\n            return l;\\n        }\\n        s= s+root.val+\"->\";\\n        solve(root.left, l, s);\\n        solve(root.right, l, s);\\n        return l;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296439,
                "title": "java-recursive-solution",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    List<String> li = new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        \\n        helper(root, \"\");\\n        for(int i=0;i<li.size();i++)\\n        li.set(i, li.get(i).substring(2));\\n        return li;\\n    }\\n    void helper(TreeNode root , String curr)\\n    {\\n        if(root == null)\\n        return;\\n\\n        if(root.left == null && root.right == null)\\n        li.add(curr + \"->\" + root.val );\\n        \\n        helper(root.left, curr + \"->\" + root.val);\\n        helper(root.right, curr + \"->\" + root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<String> li = new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        \\n        helper(root, \"\");\\n        for(int i=0;i<li.size();i++)\\n        li.set(i, li.get(i).substring(2));\\n        return li;\\n    }\\n    void helper(TreeNode root , String curr)\\n    {\\n        if(root == null)\\n        return;\\n\\n        if(root.left == null && root.right == null)\\n        li.add(curr + \"->\" + root.val );\\n        \\n        helper(root.left, curr + \"->\" + root.val);\\n        helper(root.right, curr + \"->\" + root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042190,
                "title": "c-easy-and-fast-solution-recursion",
                "content": "TC:O(N)\\nSC: Auxilairy Stack Space O(N)\\n```\\nclass Solution {\\npublic:\\n    vector<string> solve(TreeNode* &root){\\n        //base case\\n        if(root==NULL)return {};\\n        \\n        vector<string>ans;\\n        string root_val = to_string(root->val);\\n        vector<string>left  = solve(root->left);\\n        vector<string>right = solve(root->right);\\n        for(auto it:left)ans.push_back(root_val + \"->\" + it);\\n        for(auto it:right)ans.push_back(root_val + \"->\" + it);\\n        \\n        if(ans.size()==0)return{root_val};\\n        return ans;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        \\n        return solve(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> solve(TreeNode* &root){\\n        //base case\\n        if(root==NULL)return {};\\n        \\n        vector<string>ans;\\n        string root_val = to_string(root->val);\\n        vector<string>left  = solve(root->left);\\n        vector<string>right = solve(root->right);\\n        for(auto it:left)ans.push_back(root_val + \"->\" + it);\\n        for(auto it:right)ans.push_back(root_val + \"->\" + it);\\n        \\n        if(ans.size()==0)return{root_val};\\n        return ans;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        \\n        return solve(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042042,
                "title": "java-simple-easy-and-fast-solution",
                "content": "\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<>();\\n        DFS(root,\"\",list);\\n        return list ;\\n    }\\n    \\n    public void DFS(TreeNode root , String ans , List<String> list){\\n        if(root == null){\\n            return ;\\n        }\\n        if(root.left==null && root.right==null){\\n            list.add(ans+root.val);\\n            return ;\\n        }\\n        \\n        DFS(root.left,ans+root.val+\"->\",list);\\n        DFS(root.right,ans+root.val+\"->\",list);\\n    }\\n\\n",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<>();\\n        DFS(root,\"\",list);\\n        return list ;\\n    }\\n    \\n    public void DFS(TreeNode root , String ans , List<String> list){\\n        if(root == null){\\n            return ;\\n        }\\n        if(root.left==null && root.right==null){\\n            list.add(ans+root.val);\\n            return ;\\n        }\\n        \\n        DFS(root.left,ans+root.val+\"->\",list);\\n        DFS(root.right,ans+root.val+\"->\",list);\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3013848,
                "title": "using-reccursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n         List<string> paths = new List<string>();\\n        string s = \"\";\\n        FindPath(root, s);\\n        void FindPath(TreeNode root,string s1)\\n        {\\n            if (root != null)\\n            {\\n                if (root.left == null && root.right == null)\\n                {\\n                    s1 = s1 + root.val;\\n                    paths.Add(s1);\\n                }\\n                else\\n                {\\n                    s1 = s1 + root.val + \"->\";\\n                    FindPath(root.left, s1);\\n                    FindPath(root.right, s1);\\n\\n                }\\n            }\\n        }\\n        return paths;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n         List<string> paths = new List<string>();\\n        string s = \"\";\\n        FindPath(root, s);\\n        void FindPath(TreeNode root,string s1)\\n        {\\n            if (root != null)\\n            {\\n                if (root.left == null && root.right == null)\\n                {\\n                    s1 = s1 + root.val;\\n                    paths.Add(s1);\\n                }\\n                else\\n                {\\n                    s1 = s1 + root.val + \"->\";\\n                    FindPath(root.left, s1);\\n                    FindPath(root.right, s1);\\n\\n                }\\n            }\\n        }\\n        return paths;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680229,
                "title": "python-dfs-easy-to-understand-faster-than-81",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        \\n        res = []\\n        \\n        def dfs(root,s):\\n            \\n            if not root.left and not root.right:\\n                s = s + str(root.val)\\n                res.append(s)\\n                \\n            s = s+ str(root.val)+\"->\"    \\n            \\n            if root.left:\\n                left = dfs(root.left,s)\\n            \\n            if root.right:\\n                right = dfs(root.right,s)\\n            \\n            \\n        dfs(root,\"\")\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        \\n        res = []\\n        \\n        def dfs(root,s):\\n            \\n            if not root.left and not root.right:\\n                s = s + str(root.val)\\n                res.append(s)\\n                \\n            s = s+ str(root.val)+\"->\"    \\n            \\n            if root.left:\\n                left = dfs(root.left,s)\\n            \\n            if root.right:\\n                right = dfs(root.right,s)\\n            \\n            \\n        dfs(root,\"\")\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662822,
                "title": "java-easy-recursive-solution",
                "content": "```\\nclass Solution {\\n    void traverse(TreeNode root,String str,List<String> list ){\\n        if(root!=null){\\n            str+= (root.val+\"\");\\n            if(root.left==null && root.right==null){\\n                list.add(str);\\n            }\\n            str+=\"->\";\\n            traverse(root.left,str,list);\\n            traverse(root.right,str,list);\\n        }\\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        String str = \"\";\\n        traverse(root,\"\",list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void traverse(TreeNode root,String str,List<String> list ){\\n        if(root!=null){\\n            str+= (root.val+\"\");\\n            if(root.left==null && root.right==null){\\n                list.add(str);\\n            }\\n            str+=\"->\";\\n            traverse(root.left,str,list);\\n            traverse(root.right,str,list);\\n        }\\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        String str = \"\";\\n        traverse(root,\"\",list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581377,
                "title": "super-simple-dfs-c-solution",
                "content": "```\\nclass Solution {\\npublic:    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root)\\n            return {};\\n        if (!root->left && !root->right)\\n            return {to_string(root->val)};\\n\\n        vector<string> output;\\n        for (auto node : binaryTreePaths(root->left))\\n            output.push_back(to_string(root->val) + \"->\" + node);\\n        for (auto node : binaryTreePaths(root->right))\\n            output.push_back(to_string(root->val) + \"->\" + node);\\n\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root)\\n            return {};\\n        if (!root->left && !root->right)\\n            return {to_string(root->val)};\\n\\n        vector<string> output;\\n        for (auto node : binaryTreePaths(root->left))\\n            output.push_back(to_string(root->val) + \"->\" + node);\\n        for (auto node : binaryTreePaths(root->right))\\n            output.push_back(to_string(root->val) + \"->\" + node);\\n\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455753,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n```\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<>();\\n        dfs(root, \"\", ans);\\n        return ans;\\n    }\\n\\n    private void dfs(TreeNode root, String s, List<String> ans){\\n        \\n        if (root == null) return;\\n\\n        if (root.left == null && root.right == null){\\n            s += root.val;\\n            ans.add(s);\\n        }\\n\\n        s += \"\" + root.val + \"->\";\\n\\n        dfs(root.left, s, ans);\\n        dfs(root.right, s,ans);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2449587,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q257. Binary Tree Paths***\\nGiven the `root` of a binary tree, return all root-to-leaf paths in **any order.**\\n\\nA **leaf**  is a node with no children.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root:\\n            return\\n        res =[]\\n        self.preorder(root,\"\",res)\\n        return res\\n    def preorder(self,node,path,res):\\n        if not node:\\n            return\\n        if not node.left and not node.right:\\n            res.append(\"{}{}\".format(path,node.val))\\n        self.preorder(node.left,\"{}{}->\".format(path,node.val),res)\\n        self.preorder(node.right,\"{}{}->\".format(path,node.val),res)\\n        \\n```\\n**Runtime:**  54 ms\\t\\n**Memory Usage:**  13.8 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n     List<String> v=new ArrayList<>();\\n        if(root!=null)\\n            preorder(root,v,\"\");\\n        return v;\\n    }\\n    void preorder(TreeNode r,List<String> v,String s)\\n    {\\n        if(r==null)\\n            return;\\n        if(s.isEmpty())\\n            s+=r.val;\\n        else s+=(\"->\"+r.val);\\n        if(r.left!=null||r.right!=null)\\n        {\\n            preorder(r.left,v,s);\\n            preorder(r.right,v,s);\\n        }\\n        else\\n            v.add(s);\\n    }\\n}\\n```\\n**Runtime:**  12 ms\\t4\\n**Memory Usage:**  43.3 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nlass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> v;\\n        if(root)\\n         preorder(root,v,\"\");\\n        return v;\\n    }\\n    void preorder(TreeNode* r,vector<string>&v,string s)\\n    {\\n        if (!r)\\n            return ;\\n        if(!s.empty())\\n            s+=(\"->\"+to_string(r->val));\\n        else s+=to_string(r->val);\\n        if(r->left||r->right)\\n        {\\n            preorder(r->left,v,s);\\n            preorder(r->right,v,s);\\n        }\\n        else\\n            v.push_back(s);\\n        \\n    }\\n};\\n```\\n**Runtime:** 3 ms\\t\\t\\n**Memory Usage:**  13.3 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root:\\n            return\\n        res =[]\\n        self.preorder(root,\"\",res)\\n        return res\\n    def preorder(self,node,path,res):\\n        if not node:\\n            return\\n        if not node.left and not node.right:\\n            res.append(\"{}{}\".format(path,node.val))\\n        self.preorder(node.left,\"{}{}->\".format(path,node.val),res)\\n        self.preorder(node.right,\"{}{}->\".format(path,node.val),res)\\n        \\n```\n```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n     List<String> v=new ArrayList<>();\\n        if(root!=null)\\n            preorder(root,v,\"\");\\n        return v;\\n    }\\n    void preorder(TreeNode r,List<String> v,String s)\\n    {\\n        if(r==null)\\n            return;\\n        if(s.isEmpty())\\n            s+=r.val;\\n        else s+=(\"->\"+r.val);\\n        if(r.left!=null||r.right!=null)\\n        {\\n            preorder(r.left,v,s);\\n            preorder(r.right,v,s);\\n        }\\n        else\\n            v.add(s);\\n    }\\n}\\n```\n```\\nlass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> v;\\n        if(root)\\n         preorder(root,v,\"\");\\n        return v;\\n    }\\n    void preorder(TreeNode* r,vector<string>&v,string s)\\n    {\\n        if (!r)\\n            return ;\\n        if(!s.empty())\\n            s+=(\"->\"+to_string(r->val));\\n        else s+=to_string(r->val);\\n        if(r->left||r->right)\\n        {\\n            preorder(r->left,v,s);\\n            preorder(r->right,v,s);\\n        }\\n        else\\n            v.push_back(s);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253948,
                "title": "java-100-faster-solution-1ms-easy",
                "content": "# Please Upvote Bro \\uD83E\\uDD7A\\n\\n```\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Binary Tree Paths.\\nMemory Usage: 42.2 MB, less than 96.55% of Java online submissions for Binary Tree Paths.\\n```\\n\\n```\\nList<String> result = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        helper(root, new StringBuilder());\\n        return result;\\n    }\\n    void helper(TreeNode node, StringBuilder slate){\\n        if(node==null) return;\\n        int length = slate.length();\\n        slate.append(node.val);\\n        if(node.left == null && node.right == null)\\n            result.add(slate.toString()); \\n        else{\\n           slate.append(\"->\");\\n           helper(node.left, slate);\\n           helper(node.right, slate);\\n        }\\n        slate.setLength(length);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Binary Tree Paths.\\nMemory Usage: 42.2 MB, less than 96.55% of Java online submissions for Binary Tree Paths.\\n```\n```\\nList<String> result = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        helper(root, new StringBuilder());\\n        return result;\\n    }\\n    void helper(TreeNode node, StringBuilder slate){\\n        if(node==null) return;\\n        int length = slate.length();\\n        slate.append(node.val);\\n        if(node.left == null && node.right == null)\\n            result.add(slate.toString()); \\n        else{\\n           slate.append(\"->\");\\n           helper(node.left, slate);\\n           helper(node.right, slate);\\n        }\\n        slate.setLength(length);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192255,
                "title": "c-dfs-recursion-100-faster-easy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,string s,vector<string>&ans)\\n    {\\n        if(!root)\\n            return;\\n        s+=to_string(root->val);\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans.push_back(s);\\n            return ;\\n        }\\n        s+=\"->\";\\n        dfs(root->left,s,ans);\\n        dfs(root->right,s,ans);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string>ans;\\n        dfs(root,\"\",ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,string s,vector<string>&ans)\\n    {\\n        if(!root)\\n            return;\\n        s+=to_string(root->val);\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans.push_back(s);\\n            return ;\\n        }\\n        s+=\"->\";\\n        dfs(root->left,s,ans);\\n        dfs(root->right,s,ans);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string>ans;\\n        dfs(root,\"\",ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138269,
                "title": "c-easy-to-understand-3ms-solution-recursion-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void TreePaths(TreeNode* root, string path, vector<string> &ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            path += to_string(root->val);\\n            ans.push_back(path);\\n            return;\\n            \\n        }\\n        path += (to_string(root->val)) + \"->\";\\n        TreePaths(root->left,path,ans);\\n        TreePaths(root->right,path,ans);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        \\n        vector<string> ans;\\n        TreePaths(root,\"\", ans);\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void TreePaths(TreeNode* root, string path, vector<string> &ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            path += to_string(root->val);\\n            ans.push_back(path);\\n            return;\\n            \\n        }\\n        path += (to_string(root->val)) + \"->\";\\n        TreePaths(root->left,path,ans);\\n        TreePaths(root->right,path,ans);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        \\n        vector<string> ans;\\n        TreePaths(root,\"\", ans);\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778386,
                "title": "c-backtracking",
                "content": "My answer for this problem.\\n\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<string> vs; \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root == nullptr) return vs;\\n        string rootStr = to_string(root->val); \\n        btp(root, rootStr);\\n        return vs;\\n    }\\n    void btp(TreeNode* root, string &str) {\\n        if(root->left == nullptr && root->right == nullptr) { \\n            vs.push_back(str);\\n        }\\n        if(root->left != nullptr) {\\n            string newstr=str + \"->\" + to_string(root->left->val);\\n            btp(root->left, newstr);\\n        } \\n        if(root->right != nullptr) {\\n            string newstr=str + \"->\" + to_string(root->right->val);\\n            btp(root->right, newstr);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<string> vs; \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root == nullptr) return vs;\\n        string rootStr = to_string(root->val); \\n        btp(root, rootStr);\\n        return vs;\\n    }\\n    void btp(TreeNode* root, string &str) {\\n        if(root->left == nullptr && root->right == nullptr) { \\n            vs.push_back(str);\\n        }\\n        if(root->left != nullptr) {\\n            string newstr=str + \"->\" + to_string(root->left->val);\\n            btp(root->left, newstr);\\n        } \\n        if(root->right != nullptr) {\\n            string newstr=str + \"->\" + to_string(root->right->val);\\n            btp(root->right, newstr);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630587,
                "title": "82-runtime-99-92-memory-a-simple-way-to-improve-the-memory-usage",
                "content": "C formatting functions (`printf`, `snprintf`, `fprintf`) are still widely used in production codes over the C++ streams. In anycase, the idea below generalizes to any programming language. \\n\\n- Allocate a static character buffer\\n- Keep a variable to track the number of characters written to the buffer during tree-traversal\\n\\n```\\nstatic char buffer[1000];\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\n        \\nclass Solution {\\npublic:\\n    \\n    vector<string> ret;        \\n    void iter(TreeNode* root, int len) {\\n        if(!root) { return; }\\n        if(root && !root->left && !root->right) {\\n            snprintf(&buffer[len], sizeof(buffer)-len, \"%d\", root->val);\\n            ret.emplace_back(buffer);\\n            return;\\n        }\\n\\n        int n = snprintf(&buffer[len], sizeof(buffer)-len, \"%d->\", root->val);\\n        iter(root->left, len+n);\\n        iter(root->right, len+n);            \\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {        \\n        iter(root, 0);        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic char buffer[1000];\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\n        \\nclass Solution {\\npublic:\\n    \\n    vector<string> ret;        \\n    void iter(TreeNode* root, int len) {\\n        if(!root) { return; }\\n        if(root && !root->left && !root->right) {\\n            snprintf(&buffer[len], sizeof(buffer)-len, \"%d\", root->val);\\n            ret.emplace_back(buffer);\\n            return;\\n        }\\n\\n        int n = snprintf(&buffer[len], sizeof(buffer)-len, \"%d->\", root->val);\\n        iter(root->left, len+n);\\n        iter(root->right, len+n);            \\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {        \\n        iter(root, 0);        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560520,
                "title": "c-100-faster-solution-binary-tree-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n         if(root == nullptr){\\n            vector<string> v;    return v;\\n        } else if(root->left == nullptr && root->right == nullptr){\\n            vector<string> v;\\n            v.push_back(to_string(root->val));        return v;\\n        }\\n        \\n        vector<string> left = binaryTreePaths(root->left);\\n        for(int i = 0; i < left.size(); ++i){\\n            left[i] = to_string(root->val) + \"->\" + left[i];\\n        }\\n        \\n        vector<string> right = binaryTreePaths(root->right);\\n        for(int i = 0; i < right.size(); ++i){\\n            right[i] = to_string(root->val) + \"->\" + right[i];  \\n        }\\n        \\n        vector<string> res;\\n        for(auto x: left)       res.push_back(x);\\n        for(auto x: right)       res.push_back(x);\\n        return res;\\n    }\\n};\\n```\\n\\n**Result-**\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Paths.\\nMemory Usage: 13.8 MB, less than 17.49% of C++ online submissions for Binary Tree Paths.\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n         if(root == nullptr){\\n            vector<string> v;    return v;\\n        } else if(root->left == nullptr && root->right == nullptr){\\n            vector<string> v;\\n            v.push_back(to_string(root->val));        return v;\\n        }\\n        \\n        vector<string> left = binaryTreePaths(root->left);\\n        for(int i = 0; i < left.size(); ++i){\\n            left[i] = to_string(root->val) + \"->\" + left[i];\\n        }\\n        \\n        vector<string> right = binaryTreePaths(root->right);\\n        for(int i = 0; i < right.size(); ++i){\\n            right[i] = to_string(root->val) + \"->\" + right[i];  \\n        }\\n        \\n        vector<string> res;\\n        for(auto x: left)       res.push_back(x);\\n        for(auto x: right)       res.push_back(x);\\n        return res;\\n    }\\n};\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Paths.\\nMemory Usage: 13.8 MB, less than 17.49% of C++ online submissions for Binary Tree Paths.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528336,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<>();\\n        if(root != null)    path(root,\"\",list);\\n        return list;\\n    }\\n    private void path(TreeNode root, String pth, List<String> list){\\n        if(root.left == null && root.right == null)     list.add(pth+root.val);\\n        if(root.left != null)   path(root.left, pth+root.val+\"->\", list);\\n        if(root.right != null)   path(root.right, pth+root.val+\"->\", list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<>();\\n        if(root != null)    path(root,\"\",list);\\n        return list;\\n    }\\n    private void path(TreeNode root, String pth, List<String> list){\\n        if(root.left == null && root.right == null)     list.add(pth+root.val);\\n        if(root.left != null)   path(root.left, pth+root.val+\"->\", list);\\n        if(root.right != null)   path(root.right, pth+root.val+\"->\", list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516595,
                "title": "javascript-100-simple-dfs-backtracking-solution",
                "content": "```\\nconst binaryTreePaths = (root, paths = [], path = []) => {\\n  path.push(root.val);\\n  if (!root.right && !root.left) paths.push(path.join(\\'->\\'));\\n  root.left && binaryTreePaths(root.left, paths, path);\\n  root.right && binaryTreePaths(root.right, paths, path);\\n  path.pop();\\n  return paths;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst binaryTreePaths = (root, paths = [], path = []) => {\\n  path.push(root.val);\\n  if (!root.right && !root.left) paths.push(path.join(\\'->\\'));\\n  root.left && binaryTreePaths(root.left, paths, path);\\n  root.right && binaryTreePaths(root.right, paths, path);\\n  path.pop();\\n  return paths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277191,
                "title": "c-easy-solution-recursive",
                "content": "``` \\n void helper(TreeNode* root ,string c,vector<string> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else if(!root->left&&!root->right){\\n            c+=to_string(root->val);\\n            v.push_back(c);\\n            return;\\n        }\\n        c+=to_string(root->val);\\n        c+=\"->\";\\n        helper(root->left,c,v);\\n        helper(root->right,c,v);\\n       \\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n       vector<string> v;\\n        \\n        helper(root,\"\",v);\\n        \\n        return v;\\n    }\\n\\t\\n\\t``` \\n\\n",
                "solutionTags": [],
                "code": "``` \\n void helper(TreeNode* root ,string c,vector<string> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else if(!root->left&&!root->right){\\n            c+=to_string(root->val);\\n            v.push_back(c);\\n            return;\\n        }\\n        c+=to_string(root->val);\\n        c+=\"->\";\\n        helper(root->left,c,v);\\n        helper(root->right,c,v);\\n       \\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n       vector<string> v;\\n        \\n        helper(root,\"\",v);\\n        \\n        return v;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167548,
                "title": "javascript-recursion-stack-easy-understand",
                "content": "Recursion\\n```\\nvar binaryTreePaths = function(root) {\\n    var result = [];\\n    var travel = function(node, path) {\\n        if(!node.left && !node.right) result.push(path.join(\\'->\\')); //reach leaf\\n        if(node.left) travel(node.left, [...path, node.left.val]); // left child exists, keep going\\n        if(node.right) travel(node.right, [...path, node.right.val]); //right child exists, keep going\\n    }\\n    travel(root, [root.val]);\\n    return result;\\n};\\n```\\n\\nStack\\n```\\nvar binaryTreePaths = function(root) {\\n    var result = [];\\n    var stack = [[root, [root.val]]];\\n    while(stack.length) {\\n        var element = stack.pop();\\n        var node = element[0];\\n        if(!node.left && !node.right) result.push(element[1].join(\\'->\\'));\\n        if(node.left) stack.push([node.left, [...element[1], node.left.val]]);\\n        if(node.right) stack.push([node.right, [...element[1], node.right.val]]);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nvar binaryTreePaths = function(root) {\\n    var result = [];\\n    var travel = function(node, path) {\\n        if(!node.left && !node.right) result.push(path.join(\\'->\\')); //reach leaf\\n        if(node.left) travel(node.left, [...path, node.left.val]); // left child exists, keep going\\n        if(node.right) travel(node.right, [...path, node.right.val]); //right child exists, keep going\\n    }\\n    travel(root, [root.val]);\\n    return result;\\n};\\n```\n```\\nvar binaryTreePaths = function(root) {\\n    var result = [];\\n    var stack = [[root, [root.val]]];\\n    while(stack.length) {\\n        var element = stack.pop();\\n        var node = element[0];\\n        if(!node.left && !node.right) result.push(element[1].join(\\'->\\'));\\n        if(node.left) stack.push([node.left, [...element[1], node.left.val]]);\\n        if(node.right) stack.push([node.right, [...element[1], node.right.val]]);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114192,
                "title": "python-solutions-dfs-recursive-and-iterative",
                "content": "dfs recursive:\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #\\n        ## dfs recursive\\n        res = []\\n        def dfs(root,string):\\n            if not root: return\\n            if not (root.left or root.right):\\n                res.append(string+str(root.val))\\n            if root.left:\\n                dfs(root.left,string+str(root.val)+\"->\")\\n            if root.right:\\n                dfs(root.right,string+str(root.val)+\"->\")\\n        dfs(root,\"\")\\n        return res\\n```\\n\\ndfs iterative:\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #\\n        ## dfs iterative\\n        stack,res = [(root,\"\")],[]\\n        while stack:\\n            node,path = stack.pop()\\n            if not (node.left or node.right):\\n                res.append(path+str(node.val))\\n            if node.left:\\n                stack.append((node.left,path+str(node.val)+\"->\"))\\n            if node.right:\\n                stack.append((node.right,path+str(node.val)+\"->\"))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #\\n        ## dfs recursive\\n        res = []\\n        def dfs(root,string):\\n            if not root: return\\n            if not (root.left or root.right):\\n                res.append(string+str(root.val))\\n            if root.left:\\n                dfs(root.left,string+str(root.val)+\"->\")\\n            if root.right:\\n                dfs(root.right,string+str(root.val)+\"->\")\\n        dfs(root,\"\")\\n        return res\\n```\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #\\n        ## dfs iterative\\n        stack,res = [(root,\"\")],[]\\n        while stack:\\n            node,path = stack.pop()\\n            if not (node.left or node.right):\\n                res.append(path+str(node.val))\\n            if node.left:\\n                stack.append((node.left,path+str(node.val)+\"->\"))\\n            if node.right:\\n                stack.append((node.right,path+str(node.val)+\"->\"))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931366,
                "title": "backtrack-beat-99-58-and-100",
                "content": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #backtracking\\n        path,values = [], []\\n        if not root:\\n            return path\\n        self.backtracking(root, values, path)\\n        return path\\n    \\n    def isLeaf(self, node):    #determine if leaf node\\n        return not node.left and not node.right\\n    \\n    def buildPath(self, values):\\n        string = \\'\\'\\n        for i in range(len(values)):\\n            string += str(values[i])\\n            if i != len(values)-1:\\n                string += \\'->\\'    #add -> beteween 2 numbers\\n        return string\\n    \\n    def backtracking(self, node, values, path):\\n        if not node:\\n            return \\n        values.append(node.val)\\n        if self.isLeaf(node):\\n            path.append(self.buildPath(values))     #find a path, add it to the answer\\n        else:\\n            self.backtracking(node.left, values, path)    #goto left  leaf\\n            self.backtracking(node.right, values, path)  #goto right leaf\\n        values.pop()    #backtrack to the origin to find another solution\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #backtracking\\n        path,values = [], []\\n        if not root:\\n            return path\\n        self.backtracking(root, values, path)\\n        return path\\n    \\n    def isLeaf(self, node):    #determine if leaf node\\n        return not node.left and not node.right\\n    \\n    def buildPath(self, values):\\n        string = \\'\\'\\n        for i in range(len(values)):\\n            string += str(values[i])\\n            if i != len(values)-1:\\n                string += \\'->\\'    #add -> beteween 2 numbers\\n        return string\\n    \\n    def backtracking(self, node, values, path):\\n        if not node:\\n            return \\n        values.append(node.val)\\n        if self.isLeaf(node):\\n            path.append(self.buildPath(values))     #find a path, add it to the answer\\n        else:\\n            self.backtracking(node.left, values, path)    #goto left  leaf\\n            self.backtracking(node.right, values, path)  #goto right leaf\\n        values.pop()    #backtrack to the origin to find another solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900188,
                "title": "best-easiest-solution-for-python",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if root is None:return \\n        paths = []\\n        \\n        if root.left is not None:\\n            paths += [f\"{root.val}->{i}\" for i in self.binaryTreePaths(root.left)]\\n        \\n        if root.right is not None:\\n            paths += [f\"{root.val}->{i}\" for i in self.binaryTreePaths(root.right)]\\n    \\n        \\n        return paths if paths != [] else [str(root.val)]\\n        \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if root is None:return \\n        paths = []\\n        \\n        if root.left is not None:\\n            paths += [f\"{root.val}->{i}\" for i in self.binaryTreePaths(root.left)]\\n        \\n        if root.right is not None:\\n            paths += [f\"{root.val}->{i}\" for i in self.binaryTreePaths(root.right)]\\n    \\n        \\n        return paths if paths != [] else [str(root.val)]\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 887855,
                "title": "rust-0ms-100",
                "content": "```rust\\n/*\\nlearn a lot from\\nhttps://leetcode.com/problems/binary-tree-paths/discuss/733347/Rust-cheapest-and-best\\n */\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn binary_tree_paths(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<String> {\\n        fn dfs(root: &Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\\n            let mut ans = vec![];\\n            if let Some(node) = root {\\n                let node = node.borrow();\\n                let (left, right) = (&node.left, &node.right);\\n                if left.is_none() && right.is_none() {\\n                    ans.push(vec![node.val]);\\n                } else {\\n                    [left, right].iter().for_each(|&branch| {\\n                        ans.extend(dfs(branch).into_iter().map(|mut p| {\\n                            p.push(node.val);\\n                            p\\n                        }))\\n                    });\\n                }\\n            }\\n            ans\\n        }\\n\\n        dfs(&root)\\n            .iter()\\n            .map(|v| {\\n                v.iter()\\n                    .rev()\\n                    .map(|i| i.to_string())\\n                    .collect::<Vec<String>>()\\n                    .join(\"->\")\\n            })\\n            .collect()\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_binary_tree_paths() {\\n        let root = Some(Rc::new(RefCell::new(TreeNode {\\n            val: 1,\\n            left: Some(Rc::new(RefCell::new(TreeNode {\\n                val: 2,\\n                left: None,\\n                right: Some(Rc::new(RefCell::new(TreeNode::new(5)))),\\n            }))),\\n            right: Some(Rc::new(RefCell::new(TreeNode::new(3)))),\\n        })));\\n        assert_eq!(\\n            Solution::binary_tree_paths(root),\\n            vec![\"1->2->5\".to_owned(), \"1->3\".to_owned()]\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\n/*\\nlearn a lot from\\nhttps://leetcode.com/problems/binary-tree-paths/discuss/733347/Rust-cheapest-and-best\\n */\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn binary_tree_paths(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<String> {\\n        fn dfs(root: &Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\\n            let mut ans = vec![];\\n            if let Some(node) = root {\\n                let node = node.borrow();\\n                let (left, right) = (&node.left, &node.right);\\n                if left.is_none() && right.is_none() {\\n                    ans.push(vec![node.val]);\\n                } else {\\n                    [left, right].iter().for_each(|&branch| {\\n                        ans.extend(dfs(branch).into_iter().map(|mut p| {\\n                            p.push(node.val);\\n                            p\\n                        }))\\n                    });\\n                }\\n            }\\n            ans\\n        }\\n\\n        dfs(&root)\\n            .iter()\\n            .map(|v| {\\n                v.iter()\\n                    .rev()\\n                    .map(|i| i.to_string())\\n                    .collect::<Vec<String>>()\\n                    .join(\"->\")\\n            })\\n            .collect()\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_binary_tree_paths() {\\n        let root = Some(Rc::new(RefCell::new(TreeNode {\\n            val: 1,\\n            left: Some(Rc::new(RefCell::new(TreeNode {\\n                val: 2,\\n                left: None,\\n                right: Some(Rc::new(RefCell::new(TreeNode::new(5)))),\\n            }))),\\n            right: Some(Rc::new(RefCell::new(TreeNode::new(3)))),\\n        })));\\n        assert_eq!(\\n            Solution::binary_tree_paths(root),\\n            vec![\"1->2->5\".to_owned(), \"1->3\".to_owned()]\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765151,
                "title": "c-faster-than-100-preorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    \\n    void preorder(TreeNode* root, string add)\\n    {\\n        if(!root)\\n            return;\\n        if(add.size() != 0)\\n            add += \"->\";\\n        add += to_string(root -> val);\\n        if(root -> left == nullptr and root -> right == nullptr)\\n            ans.push_back(add);\\n        preorder(root -> left, add);\\n        preorder(root -> right, add);\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        preorder(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    \\n    void preorder(TreeNode* root, string add)\\n    {\\n        if(!root)\\n            return;\\n        if(add.size() != 0)\\n            add += \"->\";\\n        add += to_string(root -> val);\\n        if(root -> left == nullptr and root -> right == nullptr)\\n            ans.push_back(add);\\n        preorder(root -> left, add);\\n        preorder(root -> right, add);\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        preorder(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677005,
                "title": "java-recursion-2ms-top-99-94-memory-solution-based-on-strignbuilder",
                "content": "```\\n\\tpublic List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null) {\\n            return Collections.emptyList();\\n        }\\n        final List<String> result = new ArrayList<>();\\n        binaryTreePathsRec(root, new StringBuilder(), result);\\n        return result;\\n    }\\n    \\n    private void binaryTreePathsRec(TreeNode root, StringBuilder currentPath, List<String> output) {\\n        if (root.left == null && root.right == null) {\\n            output.add(new StringBuilder(currentPath).append(root.val).toString());\\n            return;\\n        }\\n        \\n        if (root.left != null) {\\n            binaryTreePathsRec(root.left, new StringBuilder(currentPath).append(root.val).append(\"->\"), output);\\n        }\\n        \\n        if (root.right != null) {\\n            binaryTreePathsRec(root.right, new StringBuilder(currentPath).append(root.val).append(\"->\"), output);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\tpublic List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null) {\\n            return Collections.emptyList();\\n        }\\n        final List<String> result = new ArrayList<>();\\n        binaryTreePathsRec(root, new StringBuilder(), result);\\n        return result;\\n    }\\n    \\n    private void binaryTreePathsRec(TreeNode root, StringBuilder currentPath, List<String> output) {\\n        if (root.left == null && root.right == null) {\\n            output.add(new StringBuilder(currentPath).append(root.val).toString());\\n            return;\\n        }\\n        \\n        if (root.left != null) {\\n            binaryTreePathsRec(root.left, new StringBuilder(currentPath).append(root.val).append(\"->\"), output);\\n        }\\n        \\n        if (root.right != null) {\\n            binaryTreePathsRec(root.right, new StringBuilder(currentPath).append(root.val).append(\"->\"), output);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566039,
                "title": "python-dfs-recursive-and-bfs-queue",
                "content": "DFS Recursive \\n\\n```\\n   def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        self.paths = []\\n        \\n        def dfs(root, path):\\n            path += str(root.val)\\n            if not root.left and not root.right:\\n                self.paths.append(path)\\n            \\n            if root.left:\\n                dfs(root.left, path + \\'->\\')\\n            if root.right:\\n                dfs(root.right, path + \\'->\\')\\n            return\\n        \\n        if root:\\n            dfs(root, \\'\\')\\n        return self.paths\\n\\n```\\n\\nBFS + Queue\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if not root:\\n            return []\\n        \\n        paths, start = [str(root.val)], 0\\n        layer = [root]  # queue\\n        \\n        while layer:\\n            root = layer.pop(0)\\n            if root.left:\\n                paths.append(paths[start] + \\'->\\' + str(root.left.val))\\n                layer.append(root.left)\\n            if root.right:\\n                paths.append(paths[start] + \\'->\\' +  str(root.right.val))\\n                layer.append(root.right)\\n            if not root.left and not root.right:\\n                start += 1\\n            else:\\n                paths.pop(start)\\n        \\n        return paths\\n```\\n",
                "solutionTags": [],
                "code": "```\\n   def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        self.paths = []\\n        \\n        def dfs(root, path):\\n            path += str(root.val)\\n            if not root.left and not root.right:\\n                self.paths.append(path)\\n            \\n            if root.left:\\n                dfs(root.left, path + \\'->\\')\\n            if root.right:\\n                dfs(root.right, path + \\'->\\')\\n            return\\n        \\n        if root:\\n            dfs(root, \\'\\')\\n        return self.paths\\n\\n```\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if not root:\\n            return []\\n        \\n        paths, start = [str(root.val)], 0\\n        layer = [root]  # queue\\n        \\n        while layer:\\n            root = layer.pop(0)\\n            if root.left:\\n                paths.append(paths[start] + \\'->\\' + str(root.left.val))\\n                layer.append(root.left)\\n            if root.right:\\n                paths.append(paths[start] + \\'->\\' +  str(root.right.val))\\n                layer.append(root.right)\\n            if not root.left and not root.right:\\n                start += 1\\n            else:\\n                paths.pop(start)\\n        \\n        return paths\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 550969,
                "title": "go",
                "content": "```\\nfunc binaryTreePaths(root *TreeNode) []string {\\n    if root == nil {\\n        return nil\\n    }\\n    result := []string{}\\n    helper(root, strconv.Itoa(root.Val), &result)\\n    return result\\n}\\n\\nfunc helper(root *TreeNode, str string, result *[]string) {\\n    if root.Left == nil && root.Right == nil {\\n        *result = append(*result, str)\\n        return\\n    }\\n    if root.Left != nil {\\n        helper(root.Left, str +\"->\" + strconv.Itoa(root.Left.Val), result)\\n    }\\n    if root.Right != nil {\\n        helper(root.Right, str +\"->\" + strconv.Itoa(root.Right.Val), result)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc binaryTreePaths(root *TreeNode) []string {\\n    if root == nil {\\n        return nil\\n    }\\n    result := []string{}\\n    helper(root, strconv.Itoa(root.Val), &result)\\n    return result\\n}\\n\\nfunc helper(root *TreeNode, str string, result *[]string) {\\n    if root.Left == nil && root.Right == nil {\\n        *result = append(*result, str)\\n        return\\n    }\\n    if root.Left != nil {\\n        helper(root.Left, str +\"->\" + strconv.Itoa(root.Left.Val), result)\\n    }\\n    if root.Right != nil {\\n        helper(root.Right, str +\"->\" + strconv.Itoa(root.Right.Val), result)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535561,
                "title": "simple-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<String>();\\n        helper(root, \"\", ans);\\n        return ans;\\n    }\\n    \\n    private void helper(TreeNode root, String temp, List<String> ans) {\\n        if(root == null) return;\\n        else if(root.left == null && root.right == null) {\\n            ans.add(temp + root.val);\\n            return;\\n        } else {\\n            helper(root.left, temp + root.val + \"->\", ans);\\n            helper(root.right, temp + root.val + \"->\", ans);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<String>();\\n        helper(root, \"\", ans);\\n        return ans;\\n    }\\n    \\n    private void helper(TreeNode root, String temp, List<String> ans) {\\n        if(root == null) return;\\n        else if(root.left == null && root.right == null) {\\n            ans.add(temp + root.val);\\n            return;\\n        } else {\\n            helper(root.left, temp + root.val + \"->\", ans);\\n            helper(root.right, temp + root.val + \"->\", ans);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432674,
                "title": "very-simple-and-easy-ruby-solution-using-stack-beats-100",
                "content": "```\\ndef binary_tree_paths(root)\\n  @stack = []\\n  @result = []\\n  preorder(root)\\n  @result\\nend\\n\\ndef preorder(node)\\n  return if node.nil?\\n  @stack.push(node.val)\\n  preorder(node.left)\\n  preorder(node.right)\\n  @result << @stack.join(\"->\") if !node.left && !node.right\\n  @stack.pop\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\ndef binary_tree_paths(root)\\n  @stack = []\\n  @result = []\\n  preorder(root)\\n  @result\\nend\\n\\ndef preorder(node)\\n  return if node.nil?\\n  @stack.push(node.val)\\n  preorder(node.left)\\n  preorder(node.right)\\n  @result << @stack.join(\"->\") if !node.left && !node.right\\n  @stack.pop\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 426760,
                "title": "simple-dfs-javascript-readable-code-for-humans-both-recursive-iterative",
                "content": "simpler recursive code\\n```js\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    function recurse(root, path) {\\n        path += root.val\\n        if(!root.left && !root.right) { \\n            paths.push(path) \\n            return \\n        }        \\n        path += \\'->\\'\\n        root.left && recurse(root.left, path)\\n        root.right && recurse(root.right, path)\\n    }\\n    recurse(root, \"\")\\n    return paths\\n};\\n```\\nIterative\\n```js\\n// iterative\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    let stack = [root]\\n    let pathStack = [\"\"]\\n    while(stack.length !== 0) {\\n        let node = stack.pop()\\n        let path = pathStack.pop()\\n        path += node.val\\n        if(!node.left && !node.right) {\\n            paths.push(path)            \\n        }\\n        path += \\'->\\'\\n        if(node.left) {\\n            stack.push(node.left) \\n            pathStack.push(path)\\n        }\\n        if(node.right) {\\n            stack.push(node.right) \\n            pathStack.push(path)\\n        }\\n    }\\n    return paths\\n};\\n```\\nless simple recursive\\n```js\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    function recurse(root, path) {\\n        path += root.val\\n        if(!root.left && !root.right) { \\n            paths.push(path) \\n            return \\n        }        \\n        path += \\'->\\'\\n        root.left && recurse(root.left, path)\\n        root.right && recurse(root.right, path)\\n    }\\n    recurse(root, \"\")\\n    return paths\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    function recurse(root, path) {\\n        path += root.val\\n        if(!root.left && !root.right) { \\n            paths.push(path) \\n            return \\n        }        \\n        path += \\'->\\'\\n        root.left && recurse(root.left, path)\\n        root.right && recurse(root.right, path)\\n    }\\n    recurse(root, \"\")\\n    return paths\\n};\\n```\n```js\\n// iterative\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    let stack = [root]\\n    let pathStack = [\"\"]\\n    while(stack.length !== 0) {\\n        let node = stack.pop()\\n        let path = pathStack.pop()\\n        path += node.val\\n        if(!node.left && !node.right) {\\n            paths.push(path)            \\n        }\\n        path += \\'->\\'\\n        if(node.left) {\\n            stack.push(node.left) \\n            pathStack.push(path)\\n        }\\n        if(node.right) {\\n            stack.push(node.right) \\n            pathStack.push(path)\\n        }\\n    }\\n    return paths\\n};\\n```\n```js\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    function recurse(root, path) {\\n        path += root.val\\n        if(!root.left && !root.right) { \\n            paths.push(path) \\n            return \\n        }        \\n        path += \\'->\\'\\n        root.left && recurse(root.left, path)\\n        root.right && recurse(root.right, path)\\n    }\\n    recurse(root, \"\")\\n    return paths\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158022,
                "title": "python-dfs",
                "content": "### 257. Binary Tree Paths\\n```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u904D\\u5386 | \\u5206\\u5236\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\\n\\n#### DFS\\u904D\\u5386\\n\\n\\u8FD9\\u91CC\\u5229\\u7528str\\u662Fimmutable\\u7684\\u7279\\u6027\\uFF0C\\u4E0D\\u9700\\u8981\\u8003\\u8651\\u6BCF\\u6B21backtrack\\u65F6\\u5019\\u5BF9temp\\u6570\\u7EC4\\u7684\\u66F4\\u6539\\u3002\\n\\u9012\\u5F52\\u601D\\u8DEF\\u4E09\\u79CD\\uFF1A\\n1. \\u5982\\u679C\\u6CA1\\u6709\\u5DE6\\u53F3\\u5B69\\u5B50\\uFF1A\\u5C06`temp`\\u5B58\\u5165\\u8FD4\\u56DE\\u6570\\u7EC4`res`\\n2/3: \\u5982\\u679C\\u6709\\u5DE6\\u6216\\u8005\\u53F3\\uFF0C\\u9012\\u5F52\\u5E76\\u4E14\\u66F4\\u65B0`temp`\\n\\n```python\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        res = []\\n        self.dfs(root, res, \\'\\')\\n        return res\\n    \\n    def dfs(self, root, res, temp):\\n        temp += str(root.val)\\n        if not root.left and not root.right:\\n            res.append(temp)\\n        if root.left:\\n            self.dfs(root.left, res, temp + \\'->\\')\\n        if root.right:\\n            self.dfs(root.right, res, temp + \\'->\\')\\n```\\n\\n#### DFS\\u5206\\u5236\\n\\n\\u8FD9\\u91CC\\u6BD4\\u8F83Tricky\\uFF0C\\u5148\\u904D\\u5386\\u5230\\u6700\\u4E0B\\u7AEF\\uFF0C\\u6BCF\\u6B21\\u5F80\\u4E0A\\u8FD4\\u56DE\\u7684\\u662F\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C\\u6570\\u7EC4\\u91CC\\u9762\\u5305\\u542B\\u4E86\\u6240\\u6709\\u5DE6\\u8FB9\\u6216\\u8005\\u53F3\\u8FB9\\u4F20\\u4E0A\\u53BB\\u7684\\u5404\\u79CD`path`\\uFF0C\\u5728\\u4E0A\\u4F20\\u5230parent\\u8282\\u70B9\\u7684\\u65F6\\u5019\\uFF0Cparent\\u5728\\u6240\\u6709\\u7684`path`\\u91CC\\u9762\\u8FED\\u4EE3\\u4E00\\u6B21\\uFF0C\\u53CD\\u5411\\u52A0\\u4E0A\\u5F53\\u524D`root.val`\\uFF0C\\u7136\\u540E\\u7EE7\\u7EED\\u5F80\\u4E0A\\u53CD\\u3002\\u56E0\\u4E3A\\u8FD9\\u91CC\\u6CA1\\u6709\\u7528\\u5168\\u5C40\\u7684return value\\uFF0C\\u6BCF\\u6B21\\u5728\\u5411\\u4E0A\\u4F20\\u9012\\u7684\\u65F6\\u5019\\uFF0C\\u8981\\u91CD\\u65B0\\u518D\\u5BF9return value\\u8FDB\\u884Cappend\\u3002\\n\\n```\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        res = []\\n        left_path = self.binaryTreePaths(root.left)\\n        right_path = self.binaryTreePaths(root.right)\\n        \\n        if not root.left and not root.right:\\n            res.append(str(root.val))\\n        \\n        if root.left:\\n            for path in left_path:\\n                path = str(root.val) + \\'->\\' + path \\n                res.append(path)\\n        if root.right:\\n            for path in right_path:\\n                path = str(root.val) + \\'->\\' + path \\n                res.append(path)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u904D\\u5386 | \\u5206\\u5236\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\n```python\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        res = []\\n        self.dfs(root, res, \\'\\')\\n        return res\\n    \\n    def dfs(self, root, res, temp):\\n        temp += str(root.val)\\n        if not root.left and not root.right:\\n            res.append(temp)\\n        if root.left:\\n            self.dfs(root.left, res, temp + \\'->\\')\\n        if root.right:\\n            self.dfs(root.right, res, temp + \\'->\\')\\n```\n```\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        res = []\\n        left_path = self.binaryTreePaths(root.left)\\n        right_path = self.binaryTreePaths(root.right)\\n        \\n        if not root.left and not root.right:\\n            res.append(str(root.val))\\n        \\n        if root.left:\\n            for path in left_path:\\n                path = str(root.val) + \\'->\\' + path \\n                res.append(path)\\n        if root.right:\\n            for path in right_path:\\n                path = str(root.val) + \\'->\\' + path \\n                res.append(path)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68261,
                "title": "accepted-javascript-stack-solution",
                "content": "#### Approach Vertical Tree Walk\\n\\n**Intuition**\\n\\nTo avoid stack overflow problems on big datasets we will use stack data structure for saving state and walking through a tree.\\n\\n**Algorithm**\\n\\n* Initialize stack with *root* node and empty *path*;\\n* Iterate while *stack* has at least one element;\\n* Take last element from *stack*;\\n* Ensure element is not null;\\n* Initialize *children* with non-null right and left nodes;\\n* Concatenate stack item *path* and current node *path* and put it to *path*;\\n* Add result row if *children* is empty;\\n* Add each *child* with *path* to the *stack*.\\n\\n**Javascript**\\n\\n```javascript\\nvar binaryTreePaths = function(root) {\\n    let result = [];    \\n    let stack = [{node: root, path: []}];\\n    \\n    while (stack.length > 0) {\\n        let item = stack.pop();\\n        if (item.node === null) {\\n            continue;\\n        }\\n        \\n        let children = [item.node.right, item.node.left].filter(child => child !== null);\\n        let path = item.path.concat([item.node.val]);\\n\\n        if (children.length === 0) {\\n            result.push(path.join(\"->\"));\\n        }\\n\\n        children.forEach(child => stack.push({node: child, path: path}));\\n    }\\n    \\n    return result;\\n};\\n```\\n\\n**Complexity Analysis**\\n\\n* Time complexity : *O(n)*.\\n\\nTo find all necessary paths we need to visit each node only once.\\n\\n* Space complexity : *O(m * 2)*\\n\\nWe need *O(m * 2)* space in worst case, where *m* is the depth of the tree.",
                "solutionTags": [],
                "code": "```javascript\\nvar binaryTreePaths = function(root) {\\n    let result = [];    \\n    let stack = [{node: root, path: []}];\\n    \\n    while (stack.length > 0) {\\n        let item = stack.pop();\\n        if (item.node === null) {\\n            continue;\\n        }\\n        \\n        let children = [item.node.right, item.node.left].filter(child => child !== null);\\n        let path = item.path.concat([item.node.val]);\\n\\n        if (children.length === 0) {\\n            result.push(path.join(\"->\"));\\n        }\\n\\n        children.forEach(child => stack.push({node: child, path: path}));\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68263,
                "title": "a-simple-c-solution-accepted",
                "content": "```\\nvoid copy(int *a,char *b,int temp)\\n{\\n    int j=0;\\n    for(int i=0;i<temp;i++)\\n    {j+=sprintf(b+j,\"%d->\",a[i]);}\\n    b[j-2]='\\\\0';\\n}\\nvoid order(struct TreeNode* root,int* returnSize,char** result,int *a,int *temp)\\n{\\n    if(root==NULL)\\n    {return ;}\\n    a[(*temp)++]=root->val;  \\n    if(root->left==NULL&&root->right==NULL)\\n    {\\n        result[*returnSize]=(char*)malloc(sizeof(char)*100);\\n        copy(a,result[*returnSize],*temp);\\n        (*returnSize)++;   \\n        (*temp)--;\\n        return;\\n    }\\n    order(root->left,returnSize,result,a,temp);\\n    order(root->right,returnSize,result,a,temp);\\n    (*temp)--;\\n}\\nchar** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n    int *temp=(int*)malloc(sizeof(int));\\n    *temp=0;\\n    int *a=(int*)malloc(sizeof(int)*100);\\n    char** result=(char**)malloc(sizeof(char*)*100);\\n    *returnSize=0;\\n    if(root==NULL)\\n    {return NULL;}\\n    order(root,returnSize,result,a,temp);  \\n    return result;   \\n}\\n````",
                "solutionTags": [],
                "code": "```\\nvoid copy(int *a,char *b,int temp)\\n{\\n    int j=0;\\n    for(int i=0;i<temp;i++)\\n    {j+=sprintf(b+j,\"%d->\",a[i]);}\\n    b[j-2]='\\\\0';\\n}\\nvoid order(struct TreeNode* root,int* returnSize,char** result,int *a,int *temp)\\n{\\n    if(root==NULL)\\n    {return ;}\\n    a[(*temp)++]=root->val;  \\n    if(root->left==NULL&&root->right==NULL)\\n    {\\n        result[*returnSize]=(char*)malloc(sizeof(char)*100);\\n        copy(a,result[*returnSize],*temp);\\n        (*returnSize)++;   \\n        (*temp)--;\\n        return;\\n    }\\n    order(root->left,returnSize,result,a,temp);\\n    order(root->right,returnSize,result,a,temp);\\n    (*temp)--;\\n}\\nchar** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n    int *temp=(int*)malloc(sizeof(int));\\n    *temp=0;\\n    int *a=(int*)malloc(sizeof(int)*100);\\n    char** result=(char**)malloc(sizeof(char*)*100);\\n    *returnSize=0;\\n    if(root==NULL)\\n    {return NULL;}\\n    order(root,returnSize,result,a,temp);  \\n    return result;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68407,
                "title": "java-solution-with-recursive-easy-to-understand",
                "content": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res=new ArrayList<String>();\\n        if(root==null)  return res;\\n        String s=root.val+\"\";\\n        getPaths(res,root,s);\\n        return res;\\n    }\\n    private void getPaths(List<String> res,TreeNode root,String s){\\n        if(root.left==null&&root.right==null){\\n               res.add(s);\\n               return;\\n        }\\n        if(root.left!=null)\\n            getPaths(res,root.left,s+\"->\"+root.left.val);\\n        if(root.right!=null)\\n            getPaths(res,root.right,s+\"->\"+root.right.val);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res=new ArrayList<String>();\\n        if(root==null)  return res;\\n        String s=root.val+\"\";\\n        getPaths(res,root,s);\\n        return res;\\n    }\\n    private void getPaths(List<String> res,TreeNode root,String s){\\n        if(root.left==null&&root.right==null){\\n               res.add(s);\\n               return;\\n        }\\n        if(root.left!=null)\\n            getPaths(res,root.left,s+\"->\"+root.left.val);\\n        if(root.right!=null)\\n            getPaths(res,root.right,s+\"->\"+root.right.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68415,
                "title": "dfs-python-solution-very-easy-to-understand",
                "content": "    class Solution:\\n    # @param {TreeNode} root\\n    # @return {string[]}\\n    def binaryTreePaths(self, root):\\n        if not root:return []\\n        stack,res=[(root,[str(root.val)])],[]\\n        while stack:\\n            temp,val=stack.pop()\\n            if not temp.left and not temp.right:\\n                res.append('->'.join(val))\\n            if temp.left:\\n                stack.append((temp.left,val+[str(temp.left.val)]))\\n            if temp.right:\\n                stack.append((temp.right,val+[str(temp.right.val)]))\\n        return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 68369,
                "title": "binary-tree-paths-bfs-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            // Write your code here\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            queue<pair<string, TreeNode*>> Q;\\n            Q.push({to_string(root->val), root});\\n            \\n            while (!Q.empty()) {\\n                string curStr = Q.front().first;\\n                TreeNode* curNode = Q.front().second;\\n                Q.pop();\\n                \\n                if (curNode->left == NULL && curNode->right == NULL) {\\n                    res.push_back(curStr);\\n                } else {\\n                    if (curNode->left != NULL)\\n                        Q.push({curStr + \"->\" + to_string(curNode->left->val), curNode->left});\\n                    if (curNode->right != NULL)\\n                        Q.push({curStr + \"->\" + to_string(curNode->right->val), curNode->right});\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            // Write your code here\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            queue<pair<string, TreeNode*>> Q;\\n            Q.push({to_string(root->val), root}",
                "codeTag": "Java"
            },
            {
                "id": 68465,
                "title": "share-my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> ret;\\n            if(root) dfs(ret, \"\", root);\\n            return ret;\\n        }\\n        \\n        void dfs(vector<string> &ret, string path, TreeNode* root){\\n            path += to_string(root->val);\\n            if(!root->left && !root->right){\\n                ret.push_back(path);\\n            }else{\\n                if(root->left) dfs(ret, path + \"->\", root->left);\\n                if(root->right) dfs(ret, path + \"->\", root->right);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> ret;\\n            if(root) dfs(ret, \"\", root);\\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68474,
                "title": "my-concise-c-solution-neat-and-short",
                "content": "    \\n\\n    class Solution {\\n            void treeHelper(vector<string>& result, string temp, TreeNode* root){\\n                if(!root) return;\\n                if(!root -> left && !root -> right){\\n                    temp += to_string(root -> val);\\n                    result.push_back(temp);\\n                    return ;\\n                }\\n                temp += to_string(root -> val);\\n                treeHelper(result, temp + \"->\", root -> left);\\n                treeHelper(result, temp + \"->\", root -> right);\\n            }\\n        public:\\n            vector<string> binaryTreePaths(TreeNode* root) {\\n                vector<string> result;\\n                string temp = \"\";\\n                treeHelper(result, temp, root);\\n                return result;\\n            }\\n        };",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n            void treeHelper(vector<string>& result, string temp, TreeNode* root){\\n                if(!root) return;\\n                if(!root -> left && !root -> right){\\n                    temp += to_string(root -> val);\\n                    result.push_back(temp);\\n                    return ;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 68500,
                "title": "java-solution-dfs",
                "content": "\\n    public class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> rootLeafPath = new ArrayList<String>();\\n            if (root == null) return rootLeafPath;\\n            \\n            List<TreeNode> path = new LinkedList<TreeNode>();\\n            DFS(root, path , rootLeafPath);\\n            return rootLeafPath;\\n        }\\n        \\n        private void DFS(TreeNode root, List<TreeNode> path,   List<String> rootLeafPath){\\n            path.add(root);\\n            if (root.left != null) DFS(root.left, path, rootLeafPath);\\n            if (root.right != null) DFS(root.right, path, rootLeafPath);\\n            if (root.left == null && root.right == null) {\\n                StringBuilder sb = new StringBuilder();\\n                // print all value in current path\\n                for (int i = 0; i < path.size(); i++){\\n                    sb.append(path.get(i).val);\\n                    if (i != path.size()-1) sb.append(\"->\");\\n                }\\n                rootLeafPath.add(sb.toString());\\n            }\\n            path.remove(path.size()-1);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> rootLeafPath = new ArrayList<String>();\\n            if (root == null) return rootLeafPath;\\n            \\n            List<TreeNode> path = new LinkedList<TreeNode>();\\n            DFS(root, path , rootLeafPath);\\n            return rootLeafPath;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68530,
                "title": "simple-binary-tree-paths-solution",
                "content": "    class Solution {\\n    public:\\n    \\n        using Elem = pair<TreeNode*, string>;\\n        using Stack = stack<Elem>;\\n    \\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            \\n            vector<string> paths;\\n            \\n            if(root)\\n            {\\n                Stack pool;\\n                pool.push(Elem(root, to_string(root->val)));\\n                \\n                while(!pool.empty())\\n                {\\n                    auto p = pool.top();\\n                    pool.pop();\\n                    \\n                    if(!p.first->left && !p.first->right)\\n                        paths.push_back(p.second);\\n                    \\n                    if(p.first->left)\\n                    {\\n                        string nstring = p.second + \"->\" + to_string(p.first->left->val);\\n                        pool.push(Elem(p.first->left, nstring));\\n                    }\\n                    \\n                    if(p.first->right)\\n                    {\\n                        string nstring = p.second + \"->\" + to_string(p.first->right->val);\\n                        pool.push(Elem(p.first->right, nstring));\\n                    }\\n                }\\n            }\\n            \\n            return paths;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        using Elem = pair<TreeNode*, string>;\\n        using Stack = stack<Elem>;\\n    \\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            \\n            vector<string> paths;\\n            \\n            if(root)\\n            {\\n                Stack pool;\\n                pool.push(Elem(root, to_string(root->val)));\\n                \\n                while(!pool.empty())\\n                {\\n                    auto p = pool.top();\\n                    pool.pop();\\n                    \\n                    if(!p.first->left && !p.first->right)\\n                        paths.push_back(p.second);\\n                    \\n                    if(p.first->left)\\n                    {\\n                        string nstring = p.second + \"->\" + to_string(p.first->left->val);\\n                        pool.push(Elem(p.first->left, nstring));\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3941880,
                "title": "c-clean-and-modular-code-using-backtracking-detailed-comments",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H) due to path string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector <string> res; //store result\\n\\n    void addToPath(int val, string &path){\\n        path += \"->\" + to_string(val);\\n    }\\n\\n    void removeFromPath(int val, string &path){\\n        int len = to_string(val).length() + 2; // +2 due to \"->\"\\n        while(len--) path.pop_back(); \\n    }\\n\\n    void traverse(TreeNode* root, string &path){\\n        if(!root) return;\\n        if(!root->left && !root->right){ //reached leaf node\\n            addToPath(root->val, path); //do\\n            res.push_back(path); //add path \\n            removeFromPath(root->val, path); //undo\\n            return;\\n        }\\n\\n        addToPath(root->val, path); //do\\n        traverse(root->left, path); //recurse\\n        traverse(root->right, path);\\n        removeFromPath(root->val, path); //undo \\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        res.clear(); // clear result first\\n        string path = to_string(root->val); initialise path with root\\n        if(!root->left && !root->right) return {path};\\n        //check wether head itself is not a root if yes then return head value as only path\\n\\n        traverse(root->left, path); //recurse left subtree\\n        traverse(root->right, path); //recurse right subtree\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector <string> res; //store result\\n\\n    void addToPath(int val, string &path){\\n        path += \"->\" + to_string(val);\\n    }\\n\\n    void removeFromPath(int val, string &path){\\n        int len = to_string(val).length() + 2; // +2 due to \"->\"\\n        while(len--) path.pop_back(); \\n    }\\n\\n    void traverse(TreeNode* root, string &path){\\n        if(!root) return;\\n        if(!root->left && !root->right){ //reached leaf node\\n            addToPath(root->val, path); //do\\n            res.push_back(path); //add path \\n            removeFromPath(root->val, path); //undo\\n            return;\\n        }\\n\\n        addToPath(root->val, path); //do\\n        traverse(root->left, path); //recurse\\n        traverse(root->right, path);\\n        removeFromPath(root->val, path); //undo \\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        res.clear(); // clear result first\\n        string path = to_string(root->val); initialise path with root\\n        if(!root->left && !root->right) return {path};\\n        //check wether head itself is not a root if yes then return head value as only path\\n\\n        traverse(root->left, path); //recurse left subtree\\n        traverse(root->right, path); //recurse right subtree\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917896,
                "title": "python-easy-solution-100-recursion-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.res=[]\\n\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        arr=\\'\\'\\n        if not root:\\n            return []\\n        self.checkSm(root, arr)\\n        return self.res\\n    \\n    def checkSm(self, node, arr):\\n        newarr=arr+str(node.val)\\n        if not node.left and not node.right:\\n            self.res.append(newarr)\\n            return\\n        else:\\n            newarr=newarr+\\'->\\'\\n            if node.left:\\n                self.checkSm(node.left, newarr)\\n            if node.right:\\n                self.checkSm(node.right, newarr)\\n        return\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.res=[]\\n\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        arr=\\'\\'\\n        if not root:\\n            return []\\n        self.checkSm(root, arr)\\n        return self.res\\n    \\n    def checkSm(self, node, arr):\\n        newarr=arr+str(node.val)\\n        if not node.left and not node.right:\\n            self.res.append(newarr)\\n            return\\n        else:\\n            newarr=newarr+\\'->\\'\\n            if node.left:\\n                self.checkSm(node.left, newarr)\\n            if node.right:\\n                self.checkSm(node.right, newarr)\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879045,
                "title": "accepted-java-simple-solution-recursive-dfs",
                "content": "# Intuition\\n\\n# Approach\\nWe simply create a helper function and simply perform inorder traversal while adding the values to a string and add the string to the arraylist as soon as we encounter a leaf node and empty the string for the next path.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n     List<String> s=new ArrayList<>();\\n     String ss=\"\";\\n     helper(root,s,ss);\\n    return s;\\n    }\\n    public static void helper(TreeNode root , List<String> s,String ss)\\n    {   \\n        if(root==null)\\n        {return ;}\\n        if(root.left==null && root.right==null)\\n        {\\n            ss+=root.val;\\n            s.add(ss);\\n            ss=\"\";\\n            return ;\\n        }\\n        ss+=root.val+\"->\";\\n        helper(root.left,s,ss);\\n        helper(root.right,s,ss);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n     List<String> s=new ArrayList<>();\\n     String ss=\"\";\\n     helper(root,s,ss);\\n    return s;\\n    }\\n    public static void helper(TreeNode root , List<String> s,String ss)\\n    {   \\n        if(root==null)\\n        {return ;}\\n        if(root.left==null && root.right==null)\\n        {\\n            ss+=root.val;\\n            s.add(ss);\\n            ss=\"\";\\n            return ;\\n        }\\n        ss+=root.val+\"->\";\\n        helper(root.left,s,ss);\\n        helper(root.right,s,ss);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863269,
                "title": "preorder-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<>();\\n        helper(root,\"\",ans);\\n        return ans;\\n        \\n    }\\n    private void helper(TreeNode root,String up,List<String> ans){\\n        if(root == null)\\n         return;\\n\\n        if (root.left == null && root.right == null){\\n            ans.add(up+Integer.toString(root.val));\\n            return;\\n        }\\n\\n        helper(root.left,up + Integer.toString(root.val)+\"->\",ans);\\n        helper(root.right,up +Integer.toString(root.val)+\"->\",ans);\\n\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<>();\\n        helper(root,\"\",ans);\\n        return ans;\\n        \\n    }\\n    private void helper(TreeNode root,String up,List<String> ans){\\n        if(root == null)\\n         return;\\n\\n        if (root.left == null && root.right == null){\\n            ans.add(up+Integer.toString(root.val));\\n            return;\\n        }\\n\\n        helper(root.left,up + Integer.toString(root.val)+\"->\",ans);\\n        helper(root.right,up +Integer.toString(root.val)+\"->\",ans);\\n\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820624,
                "title": "simple-and-easy-traversal-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        solve(root,arr);\\n        return ans;\\n    }\\n    public Boolean solve(TreeNode root,ArrayList<Integer> arr){\\n        if(root==null) {\\n            return false;\\n        }\\n\\n        arr.add(root.val);\\n        Boolean left = solve(root.left,arr);\\n        Boolean right = solve(root.right,arr);\\n        if(left==true || right== true){\\n            arr.remove(arr.size()-1);\\n            return true;\\n        }\\n        if(left==false && right==false){\\n            String s = \"\";\\n            for(int i=0;i<arr.size();i++){\\n                s+= arr.get(i)+\"\";\\n                if(i<arr.size()-1){\\n                    s+= \"->\";\\n                }\\n            }\\n            ans.add(s);\\n            arr.remove(arr.size()-1);\\n            return true;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        solve(root,arr);\\n        return ans;\\n    }\\n    public Boolean solve(TreeNode root,ArrayList<Integer> arr){\\n        if(root==null) {\\n            return false;\\n        }\\n\\n        arr.add(root.val);\\n        Boolean left = solve(root.left,arr);\\n        Boolean right = solve(root.right,arr);\\n        if(left==true || right== true){\\n            arr.remove(arr.size()-1);\\n            return true;\\n        }\\n        if(left==false && right==false){\\n            String s = \"\";\\n            for(int i=0;i<arr.size();i++){\\n                s+= arr.get(i)+\"\";\\n                if(i<arr.size()-1){\\n                    s+= \"->\";\\n                }\\n            }\\n            ans.add(s);\\n            arr.remove(arr.size()-1);\\n            return true;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788869,
                "title": "easiest-way-to-solve-to-solve-binary-tree-path-java",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> lis = new ArrayList<>();\\n        dfs(root, lis, \"\");\\n        for(int i = 0; i < lis.size(); i++)\\n            lis.set(i, lis.get(i).substring(2));\\n        return lis;\\n    }\\n    public void dfs(TreeNode node, List<String> lis, String s){\\n        if(node == null) return;\\n        if(node.left == null && node.right == null)\\n            lis.add(s + \"->\" + node.val);\\n        s += \"->\" + node.val;\\n        dfs(node.left, lis, s);\\n        dfs(node.right, lis, s);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> lis = new ArrayList<>();\\n        dfs(root, lis, \"\");\\n        for(int i = 0; i < lis.size(); i++)\\n            lis.set(i, lis.get(i).substring(2));\\n        return lis;\\n    }\\n    public void dfs(TreeNode node, List<String> lis, String s){\\n        if(node == null) return;\\n        if(node.left == null && node.right == null)\\n            lis.add(s + \"->\" + node.val);\\n        s += \"->\" + node.val;\\n        dfs(node.left, lis, s);\\n        dfs(node.right, lis, s);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677320,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode* root) {\\n        if(!root->left && !root->right) return true;\\n\\n        return false;\\n    }\\n\\n    void getPath(TreeNode* root, vector<int>& temp, vector<string>& ans) {\\n        if(root == NULL) return ;\\n\\n        temp.push_back(root -> val);\\n\\n        if(isLeaf(root)) {\\n            string s = \"\";\\n            for(int i : temp) {\\n                s += to_string(i) + \"->\";\\n            }\\n            s = s.substr(0, s.length()-2);\\n            ans.push_back(s);\\n        }\\n\\n        getPath(root->left, temp, ans);\\n        getPath(root->right, temp, ans);\\n\\n        temp.pop_back();\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        if(root == NULL) return ans;\\n\\n        vector<int> temp;\\n        getPath(root, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode* root) {\\n        if(!root->left && !root->right) return true;\\n\\n        return false;\\n    }\\n\\n    void getPath(TreeNode* root, vector<int>& temp, vector<string>& ans) {\\n        if(root == NULL) return ;\\n\\n        temp.push_back(root -> val);\\n\\n        if(isLeaf(root)) {\\n            string s = \"\";\\n            for(int i : temp) {\\n                s += to_string(i) + \"->\";\\n            }\\n            s = s.substr(0, s.length()-2);\\n            ans.push_back(s);\\n        }\\n\\n        getPath(root->left, temp, ans);\\n        getPath(root->right, temp, ans);\\n\\n        temp.pop_back();\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        if(root == NULL) return ans;\\n\\n        vector<int> temp;\\n        getPath(root, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597335,
                "title": "c-recursive-dfs-beats-100",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        string path = \"\";\\n        backtrack(result, path, root); \\n        return result;\\n    }\\n\\nprivate:\\n    void backtrack(vector<string>& result, string path, TreeNode*& root) {\\n        if (!root) return;\\n\\n        if (!root->left && !root->right) {\\n            path += to_string(root->val);\\n            result.emplace_back(path);\\n            return;\\n        }\\n\\n        path += to_string(root->val) + \"->\";\\n        backtrack(result, path, root->left);\\n        backtrack(result, path, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        string path = \"\";\\n        backtrack(result, path, root); \\n        return result;\\n    }\\n\\nprivate:\\n    void backtrack(vector<string>& result, string path, TreeNode*& root) {\\n        if (!root) return;\\n\\n        if (!root->left && !root->right) {\\n            path += to_string(root->val);\\n            result.emplace_back(path);\\n            return;\\n        }\\n\\n        path += to_string(root->val) + \"->\";\\n        backtrack(result, path, root->left);\\n        backtrack(result, path, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584312,
                "title": "recursive-solution-by-leo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n\\n        if not root.left and not root.right:\\n            return [str(root.val)]\\n\\n        paths = []\\n        if root.left:\\n            paths += [str(root.val) + \\'->\\' + path for path in self.binaryTreePaths(root.left)]\\n        if root.right:\\n            paths += [str(root.val) + \\'->\\' + path for path in self.binaryTreePaths(root.right)]\\n\\n        return paths\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n\\n        if not root.left and not root.right:\\n            return [str(root.val)]\\n\\n        paths = []\\n        if root.left:\\n            paths += [str(root.val) + \\'->\\' + path for path in self.binaryTreePaths(root.left)]\\n        if root.right:\\n            paths += [str(root.val) + \\'->\\' + path for path in self.binaryTreePaths(root.right)]\\n\\n        return paths\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576001,
                "title": "100-accepted-c-solution-easy-dfs",
                "content": "\\n```\\nclass Solution {\\n    private:\\n    vector<string>ans;\\n    void fun(TreeNode *root,string str)\\n    {\\n        if(root == NULL)\\n            return;\\n        str += to_string(root->val)+\"->\";\\n        if(root->left == NULL && root->right == NULL)\\n        {\\n            str.pop_back();\\n            str.pop_back();\\n            ans.push_back(str);\\n        }\\n        fun(root->left,str);\\n        fun(root->right,str);\\n        str.pop_back();\\n        \\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) \\n    {\\n        string str =  \"\";\\n        fun(root,str);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    vector<string>ans;\\n    void fun(TreeNode *root,string str)\\n    {\\n        if(root == NULL)\\n            return;\\n        str += to_string(root->val)+\"->\";\\n        if(root->left == NULL && root->right == NULL)\\n        {\\n            str.pop_back();\\n            str.pop_back();\\n            ans.push_back(str);\\n        }\\n        fun(root->left,str);\\n        fun(root->right,str);\\n        str.pop_back();\\n        \\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) \\n    {\\n        string str =  \"\";\\n        fun(root,str);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480135,
                "title": "binary-tree-paths-c-java-recursive-and-iterative-approach",
                "content": "# **Recursive: (faster)**\\nC++\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void getAllPaths(TreeNode* node,vector<int> &path,vector<vector<int>> &allPaths){\\n        if(node->left==NULL && node->right==NULL){\\n            path.push_back(node->val);\\n            allPaths.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        path.push_back(node->val);\\n        if(node->left!=NULL) getAllPaths(node->left,path,allPaths);\\n        if(node->right!=NULL) getAllPaths(node->right,path,allPaths);\\n        path.pop_back();\\n        \\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) return {to_string(root->val)};\\n        vector<int> path;\\n        vector<vector<int>> allPaths;\\n        getAllPaths(root,path,allPaths);\\n        vector<string> ans;\\n        for(auto vec:allPaths){\\n            string s=\"\";\\n            int vec_size=vec.size();\\n            for(int i=0;i<vec_size-1;i++){\\n                s.append(to_string(vec[i])+\"->\");\\n            }     \\n            s.append(to_string(vec[vec_size-1]));\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nJava\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private void getAllPaths(TreeNode node,List<Integer> path,List<List<Integer>> allPaths){\\n        if(node.left==null && node.right==null){\\n            path.add(node.val);\\n            allPaths.add(new ArrayList<>(path));\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        path.add(node.val);\\n        if(node.left!=null) getAllPaths(node.left,path,allPaths);\\n        if(node.right!=null) getAllPaths(node.right,path,allPaths);\\n        path.remove(path.size()-1);\\n        \\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<Integer> path = new ArrayList<>();\\n        List<List<Integer>> allPaths= new ArrayList<>();\\n        List<String> ans= new ArrayList<>();\\n        getAllPaths(root,path,allPaths);\\n        for(List<Integer> arr:allPaths){\\n            StringBuffer str= new StringBuffer();\\n            for(int i=0;i<arr.size()-1;i++){\\n                str.append(String.valueOf(arr.get(i))+\"->\");\\n            }\\n            str.append(String.valueOf(arr.get(arr.size()-1)));\\n            ans.add(str.toString());\\n                       \\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# **Iterative**\\n\\nc++\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void getAllPaths(TreeNode* node,vector<int> &path,vector<vector<int>> &allPaths){\\n        if(node->left==NULL && node->right==NULL){\\n            path.push_back(node->val);\\n            allPaths.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        path.push_back(node->val);\\n        if(node->left!=NULL) getAllPaths(node->left,path,allPaths);\\n        if(node->right!=NULL) getAllPaths(node->right,path,allPaths);\\n        path.pop_back();\\n        \\n    }\\n    void lvlOrder(TreeNode* node,vector<vector<int>> &allPaths){\\n        queue<pair<TreeNode*,vector<int>>>q;\\n        q.push({node,{}});\\n        while(!q.empty()){\\n            auto ele=q.front();\\n            q.pop();\\n            node=ele.first;\\n            if(node->left==NULL && node->right==NULL){\\n                ele.second.push_back(node->val);\\n                allPaths.push_back(ele.second);\\n            }\\n            ele.second.push_back(node->val);\\n            if(node->left!=NULL) q.push({node->left,ele.second});\\n            if(node->right!=NULL) q.push({node->right,ele.second});\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) return {to_string(root->val)};\\n        // vector<int> path;\\n        vector<vector<int>> allPaths;\\n        lvlOrder(root,allPaths);\\n        vector<string> ans;\\n        for(auto vec:allPaths){\\n            string s=\"\";\\n            int vec_size=vec.size();\\n            for(int i=0;i<vec_size-1;i++){\\n                s.append(to_string(vec[i])+\"->\");\\n            }     \\n            s.append(to_string(vec[vec_size-1]));\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nJava\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Pair{\\n    TreeNode node;\\n    List<Integer> list;\\n    public Pair(TreeNode node,List<Integer> list){\\n        this.node=node;\\n        this.list=list;\\n    }\\n}\\nclass Solution {\\n    private void getAllPaths(TreeNode node,List<Integer> path,List<List<Integer>> allPaths){\\n        if(node.left==null && node.right==null){\\n            path.add(node.val);\\n            allPaths.add(new ArrayList<>(path));\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        path.add(node.val);\\n        if(node.left!=null) getAllPaths(node.left,path,allPaths);\\n        if(node.right!=null) getAllPaths(node.right,path,allPaths);\\n        path.remove(path.size()-1);\\n        \\n    }\\n    private void lvlOrder(TreeNode node,List<List<Integer>> allPaths){\\n        Queue<Pair>q= new LinkedList<>();\\n        q.add(new Pair(node,new ArrayList<>()));\\n        while(!q.isEmpty()){\\n            Pair ele=q.peek();\\n            q.remove();\\n            node=ele.node;\\n            if(node.left==null && node.right==null){\\n                ele.list.add(node.val);\\n                allPaths.add(new ArrayList<>(ele.list));\\n            }\\n            ele.list.add(node.val);\\n            if(node.left!=null) q.add(new Pair(node.left,new ArrayList<>(ele.list)));\\n            if(node.right!=null) q.add(new Pair(node.right,new ArrayList<>(ele.list)));\\n        }\\n    }\\n        \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        // List<Integer> path = new ArrayList<>();\\n        List<List<Integer>> allPaths= new ArrayList<>();\\n        List<String> ans= new ArrayList<>();\\n        lvlOrder(root,allPaths);\\n        for(List<Integer> arr:allPaths){\\n            StringBuffer str= new StringBuffer();\\n            for(int i=0;i<arr.size()-1;i++){\\n                str.append(String.valueOf(arr.get(i))+\"->\");\\n            }\\n            str.append(String.valueOf(arr.get(arr.size()-1)));\\n            ans.add(str.toString());\\n                       \\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void getAllPaths(TreeNode* node,vector<int> &path,vector<vector<int>> &allPaths){\\n        if(node->left==NULL && node->right==NULL){\\n            path.push_back(node->val);\\n            allPaths.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        path.push_back(node->val);\\n        if(node->left!=NULL) getAllPaths(node->left,path,allPaths);\\n        if(node->right!=NULL) getAllPaths(node->right,path,allPaths);\\n        path.pop_back();\\n        \\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) return {to_string(root->val)};\\n        vector<int> path;\\n        vector<vector<int>> allPaths;\\n        getAllPaths(root,path,allPaths);\\n        vector<string> ans;\\n        for(auto vec:allPaths){\\n            string s=\"\";\\n            int vec_size=vec.size();\\n            for(int i=0;i<vec_size-1;i++){\\n                s.append(to_string(vec[i])+\"->\");\\n            }     \\n            s.append(to_string(vec[vec_size-1]));\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private void getAllPaths(TreeNode node,List<Integer> path,List<List<Integer>> allPaths){\\n        if(node.left==null && node.right==null){\\n            path.add(node.val);\\n            allPaths.add(new ArrayList<>(path));\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        path.add(node.val);\\n        if(node.left!=null) getAllPaths(node.left,path,allPaths);\\n        if(node.right!=null) getAllPaths(node.right,path,allPaths);\\n        path.remove(path.size()-1);\\n        \\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<Integer> path = new ArrayList<>();\\n        List<List<Integer>> allPaths= new ArrayList<>();\\n        List<String> ans= new ArrayList<>();\\n        getAllPaths(root,path,allPaths);\\n        for(List<Integer> arr:allPaths){\\n            StringBuffer str= new StringBuffer();\\n            for(int i=0;i<arr.size()-1;i++){\\n                str.append(String.valueOf(arr.get(i))+\"->\");\\n            }\\n            str.append(String.valueOf(arr.get(arr.size()-1)));\\n            ans.add(str.toString());\\n                       \\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void getAllPaths(TreeNode* node,vector<int> &path,vector<vector<int>> &allPaths){\\n        if(node->left==NULL && node->right==NULL){\\n            path.push_back(node->val);\\n            allPaths.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        path.push_back(node->val);\\n        if(node->left!=NULL) getAllPaths(node->left,path,allPaths);\\n        if(node->right!=NULL) getAllPaths(node->right,path,allPaths);\\n        path.pop_back();\\n        \\n    }\\n    void lvlOrder(TreeNode* node,vector<vector<int>> &allPaths){\\n        queue<pair<TreeNode*,vector<int>>>q;\\n        q.push({node,{}});\\n        while(!q.empty()){\\n            auto ele=q.front();\\n            q.pop();\\n            node=ele.first;\\n            if(node->left==NULL && node->right==NULL){\\n                ele.second.push_back(node->val);\\n                allPaths.push_back(ele.second);\\n            }\\n            ele.second.push_back(node->val);\\n            if(node->left!=NULL) q.push({node->left,ele.second});\\n            if(node->right!=NULL) q.push({node->right,ele.second});\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) return {to_string(root->val)};\\n        // vector<int> path;\\n        vector<vector<int>> allPaths;\\n        lvlOrder(root,allPaths);\\n        vector<string> ans;\\n        for(auto vec:allPaths){\\n            string s=\"\";\\n            int vec_size=vec.size();\\n            for(int i=0;i<vec_size-1;i++){\\n                s.append(to_string(vec[i])+\"->\");\\n            }     \\n            s.append(to_string(vec[vec_size-1]));\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Pair{\\n    TreeNode node;\\n    List<Integer> list;\\n    public Pair(TreeNode node,List<Integer> list){\\n        this.node=node;\\n        this.list=list;\\n    }\\n}\\nclass Solution {\\n    private void getAllPaths(TreeNode node,List<Integer> path,List<List<Integer>> allPaths){\\n        if(node.left==null && node.right==null){\\n            path.add(node.val);\\n            allPaths.add(new ArrayList<>(path));\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        path.add(node.val);\\n        if(node.left!=null) getAllPaths(node.left,path,allPaths);\\n        if(node.right!=null) getAllPaths(node.right,path,allPaths);\\n        path.remove(path.size()-1);\\n        \\n    }\\n    private void lvlOrder(TreeNode node,List<List<Integer>> allPaths){\\n        Queue<Pair>q= new LinkedList<>();\\n        q.add(new Pair(node,new ArrayList<>()));\\n        while(!q.isEmpty()){\\n            Pair ele=q.peek();\\n            q.remove();\\n            node=ele.node;\\n            if(node.left==null && node.right==null){\\n                ele.list.add(node.val);\\n                allPaths.add(new ArrayList<>(ele.list));\\n            }\\n            ele.list.add(node.val);\\n            if(node.left!=null) q.add(new Pair(node.left,new ArrayList<>(ele.list)));\\n            if(node.right!=null) q.add(new Pair(node.right,new ArrayList<>(ele.list)));\\n        }\\n    }\\n        \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        // List<Integer> path = new ArrayList<>();\\n        List<List<Integer>> allPaths= new ArrayList<>();\\n        List<String> ans= new ArrayList<>();\\n        lvlOrder(root,allPaths);\\n        for(List<Integer> arr:allPaths){\\n            StringBuffer str= new StringBuffer();\\n            for(int i=0;i<arr.size()-1;i++){\\n                str.append(String.valueOf(arr.get(i))+\"->\");\\n            }\\n            str.append(String.valueOf(arr.get(arr.size()-1)));\\n            ans.add(str.toString());\\n                       \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432558,
                "title": "this-is-the-shortest-ans-for-the-this-question",
                "content": "# Intuition\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(TreeNode* node, string str) {\\n        if(node->left == NULL &&  node->right == NULL) ans.push_back(str + to_string(node->val));\\n        if(node->left) dfs(node->left, str + to_string(node->val) + \"->\");\\n        if(node->right) dfs(node->right, str + to_string(node->val) + \"->\");\\n    }\\n     \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        dfs(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(TreeNode* node, string str) {\\n        if(node->left == NULL &&  node->right == NULL) ans.push_back(str + to_string(node->val));\\n        if(node->left) dfs(node->left, str + to_string(node->val) + \"->\");\\n        if(node->right) dfs(node->right, str + to_string(node->val) + \"->\");\\n    }\\n     \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        dfs(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393713,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, vector<string>& ans, string temp){\\n        if (root==NULL)return;\\n        string node= to_string(root->val);\\n        temp+= node;\\n        if (root->left==NULL && root->right==NULL){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        else temp+= \"->\";\\n        if (root->left) dfs(root->left,ans,temp);\\n        if (root->right) dfs(root->right,ans,temp);\\n        //temp.pop_back();\\n        //temp.pop_back();\\n        //temp.pop_back();\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        string temp=\"\";\\n        dfs(root,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, vector<string>& ans, string temp){\\n        if (root==NULL)return;\\n        string node= to_string(root->val);\\n        temp+= node;\\n        if (root->left==NULL && root->right==NULL){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        else temp+= \"->\";\\n        if (root->left) dfs(root->left,ans,temp);\\n        if (root->right) dfs(root->right,ans,temp);\\n        //temp.pop_back();\\n        //temp.pop_back();\\n        //temp.pop_back();\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        string temp=\"\";\\n        dfs(root,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188529,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void helper(TreeNode* root , vector<int> &temp , vector<vector<int> > &ans){\\n        if(root == NULL){\\n            // ans.push_back(s);\\n            return ;\\n        }\\n        if(root -> left == NULL && root -> right == NULL){\\n           temp.push_back(root -> val);\\n           ans.push_back(temp);\\n           temp.pop_back();\\n           return;\\n        }\\n        // cout << root -> val << endl;\\n        temp.push_back(root->val);\\n        helper(root->left, temp,ans);\\n        helper(root->right, temp,ans);\\n        temp.pop_back();\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        helper(root, temp, ans);\\n        vector<string> sol;\\n        for(auto v:ans){\\n            string t = \"\";\\n            for(int i=0;i<v.size()-1;i++){\\n                t += to_string(v[i]);\\n                t += \"->\";\\n            }\\n            t += to_string(v[v.size()-1]);\\n            sol.push_back(t);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void helper(TreeNode* root , vector<int> &temp , vector<vector<int> > &ans){\\n        if(root == NULL){\\n            // ans.push_back(s);\\n            return ;\\n        }\\n        if(root -> left == NULL && root -> right == NULL){\\n           temp.push_back(root -> val);\\n           ans.push_back(temp);\\n           temp.pop_back();\\n           return;\\n        }\\n        // cout << root -> val << endl;\\n        temp.push_back(root->val);\\n        helper(root->left, temp,ans);\\n        helper(root->right, temp,ans);\\n        temp.pop_back();\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        helper(root, temp, ans);\\n        vector<string> sol;\\n        for(auto v:ans){\\n            string t = \"\";\\n            for(int i=0;i<v.size()-1;i++){\\n                t += to_string(v[i]);\\n                t += \"->\";\\n            }\\n            t += to_string(v[v.size()-1]);\\n            sol.push_back(t);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3184409,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public List<string> ans;\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        ans=new();\\n        if(root.left==null&&root.right==null){\\n                ans.Add(root.val.ToString());\\n                return ans;\\n            }\\n        StringBuilder sb=new();\\n        dfs(root,sb);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root,StringBuilder sb){\\n        if(root!=null){\\n            sb.Append(root.val);\\n            if(root.left==null&&root.right==null){\\n                ans.Add(sb.ToString());\\n            }\\n            else{\\n            sb.Append(\"->\");\\n            }\\n            StringBuilder sbl=new();\\n            StringBuilder sbr=new();\\n            sbl.Append(sb.ToString());\\n            sbr.Append(sb.ToString());\\n            dfs(root.left,sbl);\\n            dfs(root.right,sbr);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<string> ans;\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        ans=new();\\n        if(root.left==null&&root.right==null){\\n                ans.Add(root.val.ToString());\\n                return ans;\\n            }\\n        StringBuilder sb=new();\\n        dfs(root,sb);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root,StringBuilder sb){\\n        if(root!=null){\\n            sb.Append(root.val);\\n            if(root.left==null&&root.right==null){\\n                ans.Add(sb.ToString());\\n            }\\n            else{\\n            sb.Append(\"->\");\\n            }\\n            StringBuilder sbl=new();\\n            StringBuilder sbr=new();\\n            sbl.Append(sb.ToString());\\n            sbr.Append(sb.ToString());\\n            dfs(root.left,sbl);\\n            dfs(root.right,sbr);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823810,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n public List<String> binaryTreePaths(TreeNode root) {\\n  List<String> paths = new ArrayList<>();\\n  if (root == null) return paths;\\n\\n  Stack<TreeNode> stackNode = new Stack<>();\\n  Stack<String> stackInt = new Stack<>();\\n  stackNode.push(root);\\n  stackInt.push(Integer.toString(root.val));\\n\\n  while (!stackNode.empty()) {\\n   TreeNode node = stackNode.pop();\\n   String num = stackInt.pop();\\n\\n   if (node.left == null && node.right == null) {\\n    paths.add(num);\\n   }\\n\\n   if (node.left != null) {\\n    stackNode.push(node.left);\\n    stackInt.push(num + \"->\" + node.left.val);\\n   }\\n\\n   if (node.right != null) {\\n    stackNode.push(node.right);\\n    stackInt.push(num + \"->\" + node.right.val);\\n   }\\n  }\\n\\n  return paths;\\n }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\n public List<String> binaryTreePaths(TreeNode root) {\\n  List<String> paths = new ArrayList<>();\\n  if (root == null) return paths;\\n\\n  Stack<TreeNode> stackNode = new Stack<>();\\n  Stack<String> stackInt = new Stack<>();\\n  stackNode.push(root);\\n  stackInt.push(Integer.toString(root.val));\\n\\n  while (!stackNode.empty()) {\\n   TreeNode node = stackNode.pop();\\n   String num = stackInt.pop();\\n\\n   if (node.left == null && node.right == null) {\\n    paths.add(num);\\n   }\\n\\n   if (node.left != null) {\\n    stackNode.push(node.left);\\n    stackInt.push(num + \"->\" + node.left.val);\\n   }\\n\\n   if (node.right != null) {\\n    stackNode.push(node.right);\\n    stackInt.push(num + \"->\" + node.right.val);\\n   }\\n  }\\n\\n  return paths;\\n }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2823001,
                "title": "python3-using-queue-level-order-traversal",
                "content": "```\\nclass Node:\\n    def __init__(self, value):\\n        self.value = value\\n        self.next = None\\n    \\nclass LinkedList:\\n    def __init__(self):\\n        self.head = None\\n        self.tail = None\\n        self.length = 0\\n\\n    def __len__(self):\\n        return self.length\\n\\n    def add(self, value):\\n        node = Node(value)\\n        if self.head:\\n            self.tail.next = node\\n            self.tail = node\\n        else:\\n            self.head = node\\n            self.tail = node\\n        self.length += 1\\n\\n    def remove_first(self):\\n        if self.head:\\n            value = self.head.value\\n            self.head = self.head.next\\n            self.length -= 1\\n            return value\\n\\nclass Queue:\\n    def __init__(self, size = 0):\\n        self.list = LinkedList()\\n        self.size = size\\n\\n    def enqueue(self, value):\\n        self.list.add(value)\\n\\n    def dequeue(self):\\n        return self.list.remove_first()\\n    \\n    def is_empty(self):\\n        return self.list.head == None\\n\\nclass Solution:\\n    def binaryTreePaths(self, rootNode: Optional[TreeNode]) -> List[str]:\\n        if not rootNode:\\n            return\\n        else:\\n            queue = Queue()\\n            queue.enqueue(rootNode)\\n            paths = {\\n                f\"0-{rootNode.val}\": str(rootNode.val)\\n            }\\n            next_counter = 0\\n            current_counter = 0\\n            while not queue.is_empty():\\n                current = queue.dequeue()\\n                current_parent = paths[f\"{current_counter}-{current.val}\"]\\n                if current.left:\\n                    next_counter += 1\\n                    paths[f\\'{next_counter}-{current.left.val}\\'] = f\\'{current_parent}->{current.left.val}\\'\\n                    queue.enqueue(current.left)\\n                if current.right:\\n                    next_counter += 1\\n                    paths[f\\'{next_counter}-{current.right.val}\\'] = f\\'{current_parent}->{current.right.val}\\'\\n                    queue.enqueue(current.right)\\n                if current.right or current.left:    \\n                    del paths[f\"{current_counter}-{current.val}\"]\\n                current_counter += 1\\n            return list(paths.values())\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, value):\\n        self.value = value\\n        self.next = None\\n    \\nclass LinkedList:\\n    def __init__(self):\\n        self.head = None\\n        self.tail = None\\n        self.length = 0\\n\\n    def __len__(self):\\n        return self.length\\n\\n    def add(self, value):\\n        node = Node(value)\\n        if self.head:\\n            self.tail.next = node\\n            self.tail = node\\n        else:\\n            self.head = node\\n            self.tail = node\\n        self.length += 1\\n\\n    def remove_first(self):\\n        if self.head:\\n            value = self.head.value\\n            self.head = self.head.next\\n            self.length -= 1\\n            return value\\n\\nclass Queue:\\n    def __init__(self, size = 0):\\n        self.list = LinkedList()\\n        self.size = size\\n\\n    def enqueue(self, value):\\n        self.list.add(value)\\n\\n    def dequeue(self):\\n        return self.list.remove_first()\\n    \\n    def is_empty(self):\\n        return self.list.head == None\\n\\nclass Solution:\\n    def binaryTreePaths(self, rootNode: Optional[TreeNode]) -> List[str]:\\n        if not rootNode:\\n            return\\n        else:\\n            queue = Queue()\\n            queue.enqueue(rootNode)\\n            paths = {\\n                f\"0-{rootNode.val}\": str(rootNode.val)\\n            }\\n            next_counter = 0\\n            current_counter = 0\\n            while not queue.is_empty():\\n                current = queue.dequeue()\\n                current_parent = paths[f\"{current_counter}-{current.val}\"]\\n                if current.left:\\n                    next_counter += 1\\n                    paths[f\\'{next_counter}-{current.left.val}\\'] = f\\'{current_parent}->{current.left.val}\\'\\n                    queue.enqueue(current.left)\\n                if current.right:\\n                    next_counter += 1\\n                    paths[f\\'{next_counter}-{current.right.val}\\'] = f\\'{current_parent}->{current.right.val}\\'\\n                    queue.enqueue(current.right)\\n                if current.right or current.left:    \\n                    del paths[f\"{current_counter}-{current.val}\"]\\n                current_counter += 1\\n            return list(paths.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816197,
                "title": "java-dfs-solution-in-6-ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        goDFS(root, list, result);\\n        StringBuilder sb = new StringBuilder();\\n        List<String> strings = new ArrayList<>();\\n        for (List<Integer> l : result) {\\n            for (int i = 0; i < l.size() - 1; i++) {\\n                sb.append(l.get(i)).append(\"->\");\\n            }\\n            sb.append(l.get(l.size() - 1));\\n            strings.add(sb.toString());\\n            sb.setLength(0);\\n        }\\n        return strings;\\n    }\\n\\n    private void goDFS(TreeNode node, List<Integer> list, List<List<Integer>> result) {\\n        if (node == null) return;\\n        list.add(node.val);\\n        if (node.left == null && node.right == null) {\\n            result.add(new ArrayList<>(list));\\n        }\\n        goDFS(node.left, list, result);\\n        goDFS(node.right, list, result);\\n        list.remove(list.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        goDFS(root, list, result);\\n        StringBuilder sb = new StringBuilder();\\n        List<String> strings = new ArrayList<>();\\n        for (List<Integer> l : result) {\\n            for (int i = 0; i < l.size() - 1; i++) {\\n                sb.append(l.get(i)).append(\"->\");\\n            }\\n            sb.append(l.get(l.size() - 1));\\n            strings.add(sb.toString());\\n            sb.setLength(0);\\n        }\\n        return strings;\\n    }\\n\\n    private void goDFS(TreeNode node, List<Integer> list, List<List<Integer>> result) {\\n        if (node == null) return;\\n        list.add(node.val);\\n        if (node.left == null && node.right == null) {\\n            result.add(new ArrayList<>(list));\\n        }\\n        goDFS(node.left, list, result);\\n        goDFS(node.right, list, result);\\n        list.remove(list.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812095,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isleaf(TreeNode* root){\\n\\t\\t\\treturn (!root->left && !root->right);\\n\\t\\t}\\n\\t\\tvoid chk(vector<vector<int>>&v, vector<int>&a, TreeNode* root){\\n\\t\\t\\tif(!root){return;}\\n\\t\\t\\ta.push_back(root->val);\\n\\t\\t\\tif(isleaf(root)){v.push_back(a);}\\n\\t\\t\\tchk(v, a, root->left);\\n\\t\\t\\tchk(v, a, root->right);\\n\\t\\t\\ta.pop_back();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvector<string> binaryTreePaths(TreeNode* root) {\\n\\t\\t\\tvector<vector<int>>v;\\n\\t\\t\\tvector<int>a;\\n\\t\\t\\tchk(v, a, root);\\n\\t\\t\\t// for(int i=0; i<v.size(); i++){\\n\\t\\t\\t//     for(int j=0; j<v[i].size(); j++){\\n\\t\\t\\t//         cout<<v[i][j]<<\" \";\\n\\t\\t\\t//     }cout<<endl;\\n\\t\\t\\t// }\\n\\t\\t\\tvector<string>ans;\\n\\t\\t\\tfor(int i=0; i<v.size(); i++){\\n\\t\\t\\t\\tstring x=\"\";\\n\\t\\t\\t\\tfor(int j=0; j<v[i].size(); j++){\\n\\t\\t\\t\\t\\tx+=to_string(v[i][j]);\\n\\t\\t\\t\\t\\tx+=\\'-\\'; x+=\\'>\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx.pop_back();\\n\\t\\t\\t\\tx.pop_back();\\n\\t\\t\\t\\tans.push_back(x);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isleaf(TreeNode* root){\\n\\t\\t\\treturn (!root->left && !root->right);\\n\\t\\t}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1863853,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1738339,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1866733,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1573978,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1950610,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1934897,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1785347,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1728220,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1571497,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 2066813,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1863853,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1738339,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1866733,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1573978,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1950610,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1934897,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1785347,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1728220,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1571497,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 2066813,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Numbers with Unique Digits",
        "question_content": "<p>Given an integer <code>n</code>, return the count of all numbers with unique digits, <code>x</code>, where <code>0 &lt;= x &lt; 10<sup>n</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 91\n<strong>Explanation:</strong> The answer should be the total numbers in the range of 0 &le; x &lt; 100, excluding 11,22,33,44,55,66,77,88,99\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 83041,
                "title": "java-dp-o-1-solution",
                "content": " Following the hint. Let f(n) = count of number with unique digits of length n.\\n\\nf(1) = 10.  (0, 1, 2, 3, ...., 9)\\n\\nf(2) = 9 * 9. Because for each number i from 1, ..., 9, we can pick j to form a 2-digit number ij and there are 9 numbers that are different from i for j to choose from.  \\n\\nf(3) = f(2) * 8 = 9 * 9 * 8. Because for each number with unique digits of length 2, say ij, we can pick k to form a 3 digit number ijk and there are 8 numbers that are different from i and j  for k to choose from.\\n\\nSimilarly f(4) = f(3) * 7 = 9 * 9 * 8 * 7....\\n\\n...\\n\\nf(10) = 9 * 9 * 8 * 7 * 6 * ... * 1\\n\\nf(11) = 0 = f(12) = f(13)....\\n\\nany number with length > 10  couldn't be unique digits number.\\n\\nThe problem is asking for numbers from 0 to 10^n. Hence return f(1) + f(2) + .. + f(n)\\n\\n\\nAs @4acreg suggests,  There are only 11 different ans. You can create a lookup table for it. This problem is O(1) in essence.\\n\\n      public int countNumbersWithUniqueDigits(int n) {\\n            if (n == 0)     return 1;\\n            \\n            int res = 10;\\n            int uniqueDigits = 9;\\n            int availableNumber = 9;\\n            while (n-- > 1 && availableNumber > 0) {\\n                uniqueDigits = uniqueDigits * availableNumber;\\n                res += uniqueDigits;\\n                availableNumber--;\\n            }\\n            return res;\\n        }",
                "solutionTags": [],
                "code": " Following the hint. Let f(n) = count of number with unique digits of length n.\\n\\nf(1) = 10.  (0, 1, 2, 3, ...., 9)\\n\\nf(2) = 9 * 9. Because for each number i from 1, ..., 9, we can pick j to form a 2-digit number ij and there are 9 numbers that are different from i for j to choose from.  \\n\\nf(3) = f(2) * 8 = 9 * 9 * 8. Because for each number with unique digits of length 2, say ij, we can pick k to form a 3 digit number ijk and there are 8 numbers that are different from i and j  for k to choose from.\\n\\nSimilarly f(4) = f(3) * 7 = 9 * 9 * 8 * 7....\\n\\n...\\n\\nf(10) = 9 * 9 * 8 * 7 * 6 * ... * 1\\n\\nf(11) = 0 = f(12) = f(13)....\\n\\nany number with length > 10  couldn't be unique digits number.\\n\\nThe problem is asking for numbers from 0 to 10^n. Hence return f(1) + f(2) + .. + f(n)\\n\\n\\nAs @4acreg suggests,  There are only 11 different ans. You can create a lookup table for it. This problem is O(1) in essence.\\n\\n      public int countNumbersWithUniqueDigits(int n) {\\n            if (n == 0)     return 1;\\n            \\n            int res = 10;\\n            int uniqueDigits = 9;\\n            int availableNumber = 9;\\n            while (n-- > 1 && availableNumber > 0) {\\n                uniqueDigits = uniqueDigits * availableNumber;\\n                res += uniqueDigits;\\n                availableNumber--;\\n            }\\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 83061,
                "title": "java-o-1-with-explanation",
                "content": "This is a digit combination problem. Can be solved in at most 10 loops.\\n\\nWhen n == 0, return 1. I got this answer from the test case.\\n\\nWhen n == 1, _ can put 10 digit in the only position. [0, ... , 10]. Answer is 10.\\n\\nWhen n == 2, _ _ first digit has 9 choices [1, ..., 9], second one has 9 choices excluding the already chosen one. So totally 9 * 9 = 81. answer should be 10 + 81 = 91\\n\\nWhen n == 3, _ _ _ total choice is 9 * 9 * 8 = 684. answer is 10 + 81 + 648 = 739\\n\\nWhen n == 4, _ _ _ _ total choice is 9 * 9 * 8 * 7.\\n\\n...\\n\\nWhen n == 10, _ _ _ _ _ _ _ _ _ _ total choice is 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1\\n\\nWhen n == 11,  _ _ _ _ _ _ _ _ _ _ _ total choice is 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 * 0 = 0\\n\\n    public static int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        int ans = 10, base = 9;\\n        for (int i = 2; i <= n && i <= 10; i++) {\\n            base = base * (9 - i + 2);\\n            ans += base;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "This is a digit combination problem. Can be solved in at most 10 loops.\\n\\nWhen n == 0, return 1. I got this answer from the test case.\\n\\nWhen n == 1, _ can put 10 digit in the only position. [0, ... , 10]. Answer is 10.\\n\\nWhen n == 2, _ _ first digit has 9 choices [1, ..., 9], second one has 9 choices excluding the already chosen one. So totally 9 * 9 = 81. answer should be 10 + 81 = 91\\n\\nWhen n == 3, _ _ _ total choice is 9 * 9 * 8 = 684. answer is 10 + 81 + 648 = 739\\n\\nWhen n == 4, _ _ _ _ total choice is 9 * 9 * 8 * 7.\\n\\n...\\n\\nWhen n == 10, _ _ _ _ _ _ _ _ _ _ total choice is 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1\\n\\nWhen n == 11,  _ _ _ _ _ _ _ _ _ _ _ total choice is 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 * 0 = 0\\n\\n    public static int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        int ans = 10, base = 9;\\n        for (int i = 2; i <= n && i <= 10; i++) {\\n            base = base * (9 - i + 2);\\n            ans += base;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 83056,
                "title": "share-my-0ms-c-solution-with-proof-and-explanation",
                "content": "Q: Given a **non-negative** integer n, count all numbers with **unique digits**, x, where 0 \\u2264 x < 10^n\\n\\nA: Here I choose a math solution based on **permutation**:\\n\\n - **P(n, r) = n * (n - 1) * (n - 2) * ... * (n - r + 1)**\\n\\n----------\\n## Just take a try\\n\\n 1. When **n = 0**, ***0 \\u2264 x < 1*** with **unique digits** is 0, ***A(0) = 1***\\n\\n 2. When **n = 1**, ***0 \\u2264 x < 10*** can be divided into \\n\\n      - ***0 \\u2264 x < 1*** (calculated in 1): ***A(0) = 1***\\n\\n      - ***1 \\u2264 x < 10*** (all numbers with **ONLY 1** digit)\\n\\n      As they are **all unique**: ***A(1) = P(10,1) - 1***\\n\\n 3. When **n = 2**, ***0 \\u2264 x < 100*** with **unique digits** can be divided into\\n\\n      - ***0 \\u2264 x < 1*** (calculated in 1): ***A(0) = 1***\\n\\n      - ***1 \\u2264 x < 10*** (all numbers with **ONLY 1** digit): ***A(1) = P(10,1) - 1***\\n\\n      - ***10 \\u2264 x < 100*** (all numbers with **ONLY 2** digits)\\n\\n      As the numbers have **ONLY 2** digits, if they are with **unique digits**:\\n\\n      We need to choose **2 different digits** from **{1,2,3,4,5,6,7,8,9,0}**: ***P(10,2)***\\n\\n      And we must **filter out** the permutations **started by 0**: ***P(9,1)***\\n\\n     ***A(2) = P(10,2) - P(9,1)***\\n\\n----------\\n## Think about A(n)\\n\\n 1. When **n > 10**, ***10^(n-1) \\u2264 x < 10^n*** **MUST** have **MORE THAN 10** digits.\\n\\n  As the [Pigeonhole principle][1] says, there **MUST** be **AT LEAST N - 9** repeating numbers.\\n\\n  All numbers should be ignored, which means ***A(n) = 0 (n  > 10)***.\\n\\n 2. When **n \\u2264 10**, ***10^(n-1) \\u2264 x < 10^n*** (all numbers with **ONLY n** digits) have **unique digits** :\\n\\n - **Choose n different digits** from **{1,2,3,4,5,6,7,8,9,0}**: ***P(10,n)***\\n\\n - **Filter out** the permutations **started by 0**: ***P(9,n-1)***\\n\\n - Get **A(n) = P(10,n) - P(9,n-1) = 9 * P(9,n-1)**\\n\\n----------\\n## Combine all Intervals\\n\\n - As\\n\\n    - ***A(n) = 1 (n = 0)***\\n\\n    - ***A(n) = 9 * P(9,n-1) (0 < n \\u2264 10)***\\n\\n    -  ***A(n) = 0 (n > 10)***\\n\\n - Since we need to count all **x (0 \\u2264 x < 10^n)** with **unique digits** , we can just combine all Intervals:\\n\\n    - ***S(n) = A(0) + A(1) + A(2) + .....+ A(n)***\\n\\n - S(n) is the final answer.\\n\\n----------\\n## Code\\n\\n    class Solution {\\n    public:\\n        int permutation(int n, int r)\\n        {\\n            if(r == 0)\\n            {\\n                return 1;\\n            }else{\\n                return n * permutation(n - 1, r - 1);\\n            }\\n        }\\n        int countNumbersWithUniqueDigits(int n) {\\n            int sum = 1;\\n            if(n > 0)\\n            {\\n               int end = (n > 10)? 10 : n;\\n               for(int i = 0; i < end; i++)\\n               {\\n                   sum += 9 * permutation(9, i);\\n               }\\n            }\\n            return sum;\\n        }\\n    };\\n\\n----------\\n  [1]: https://en.wikipedia.org/wiki/Pigeonhole_principle",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\n    public:\\n        int permutation(int n, int r)\\n        {\\n            if(r == 0)\\n            {\\n                return 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 83040,
                "title": "simple-python-solution-90",
                "content": "```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        choices = [9, 9, 8, 7, 6, 5, 4, 3, 2, 1]\\n        ans, product = 1, 1\\n        \\n        for i in range(n if n <= 10 else 10):\\n            product *= choices[i]\\n            ans += product\\n            \\n        return ans\\n```\\n\\nFor the first (most left) digit, we have 9 options (no zero); for the second digit we used one but we can use 0 now, so 9 options; and we have 1 less option for each following digits. Number can not be longer than 10 digits.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        choices = [9, 9, 8, 7, 6, 5, 4, 3, 2, 1]\\n        ans, product = 1, 1\\n        \\n        for i in range(n if n <= 10 else 10):\\n            product *= choices[i]\\n            ans += product\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83054,
                "title": "backtracking-solution",
                "content": "The idea is to append one digit at a time recursively (only append digits that has not been appended before). Number zero is a special case, because we don't want to deal with the leading zero, so it is counted separately at the beginning of the program. The running time for this program is O(10!) worst case, or O(n!) if n < 10.\\n\\nThe OJ gives wrong answer when n = 0 and n = 1. The correct answer should be:\\n\\n> 0, 1 \\n\\n> 1, 10\\n\\n> 2, 91\\n\\n> 3, 739\\n\\n>4, 5275\\n\\n>5, 32491\\n\\n> 6, 168571\\n\\n> 7, 712891\\n\\n> 8, 2345851\\n\\n> 9, 5611771\\n\\n> 10 and beyond, 8877691\\n\\n\\n----------\\n\\n\\n    public class Solution {\\n    \\tpublic static int countNumbersWithUniqueDigits(int n) {\\n    \\t\\tif (n > 10) {\\n    \\t\\t\\treturn countNumbersWithUniqueDigits(10);\\n    \\t\\t}\\n    \\t\\tint count = 1; // x == 0\\n    \\t\\tlong max = (long) Math.pow(10, n);\\n    \\n    \\t\\tboolean[] used = new boolean[10];\\n    \\n    \\t\\tfor (int i = 1; i < 10; i++) {\\n    \\t\\t\\tused[i] = true;\\n    \\t\\t\\tcount += search(i, max, used);\\n    \\t\\t\\tused[i] = false;\\n    \\t\\t}\\n    \\n    \\t\\treturn count;\\n    \\t}\\n    \\n    \\tprivate static int search(long prev, long max, boolean[] used) {\\n    \\t\\tint count = 0;\\n    \\t\\tif (prev < max) {\\n    \\t\\t\\tcount += 1;\\n    \\t\\t} else {\\n    \\t\\t\\treturn count;\\n    \\t\\t}\\n    \\n    \\t\\tfor (int i = 0; i < 10; i++) {\\n    \\t\\t\\tif (!used[i]) {\\n    \\t\\t\\t\\tused[i] = true;\\n    \\t\\t\\t\\tlong cur = 10 * prev + i;\\n    \\t\\t\\t\\tcount += search(cur, max, used);\\n    \\t\\t\\t\\tused[i] = false;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\treturn count;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    \\tpublic static int countNumbersWithUniqueDigits(int n) {\\n    \\t\\tif (n > 10) {\\n    \\t\\t\\treturn countNumbersWithUniqueDigits(10);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1210498,
                "title": "simple-c-solution-with-comments-beats-100-dp-permutations-and-combinations",
                "content": "```\\n/*\\nFor n = 0, ans = 1\\nFor n = 1, ans = 10\\nIf we take 2 digit number, we have 9 options for first digit (1 - 9)\\nand 9 options for second digit(0 & all other digits except the one taken as first digit (to keep digits unique)) therefore ans += (9 * 9)\\nSimilarly if we take 3 digit number we have 8 options for third digit, therefore ans += (9 * 9 * 8)\\n*/\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0)\\n            return 1;\\n        int ans = 10, calc = 9, temp = 9;\\n        for(int i = 0; i < n - 1; i++) {\\n            calc *= temp;\\n            ans += calc;\\n            temp--;\\n        }\\n        return ans;\\n    }\\n};\\n//Do upvote if you are helped by the solution to help others\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nFor n = 0, ans = 1\\nFor n = 1, ans = 10\\nIf we take 2 digit number, we have 9 options for first digit (1 - 9)\\nand 9 options for second digit(0 & all other digits except the one taken as first digit (to keep digits unique)) therefore ans += (9 * 9)\\nSimilarly if we take 3 digit number we have 8 options for third digit, therefore ans += (9 * 9 * 8)\\n*/\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0)\\n            return 1;\\n        int ans = 10, calc = 9, temp = 9;\\n        for(int i = 0; i < n - 1; i++) {\\n            calc *= temp;\\n            ans += calc;\\n            temp--;\\n        }\\n        return ans;\\n    }\\n};\\n//Do upvote if you are helped by the solution to help others\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83052,
                "title": "clear-c-explanation-of-combinatorics-using-dp-method",
                "content": "when n is 0, it is clear that there is just one number 0.\\n\\nwhen n is 1, it is trivial that there are 10 numbers: 0,1,2...9.\\n\\nwhen n is 2, the range is [0, 99]. The total unique digits is divided to two part: just one digit or two digit.\\n\\n              **dp[2]  = dp[1] + the combination with  two digits.** \\n\\n'0' could only be at unit digit. so when '0' is at unit digit, there are 9 kinds of. when there is no '0', there are 9 kinds of numbers at tens digit, and 8 kinds of numbers at unit digit. So the combination with two digits are: 9 + 9*8  is equal to \\n\\n                                       9 * (1+8) = 9 * 9.\\n\\nwhen n is 3, the range is [0, 999]. The total unique digits is divided to two part: less than 3 digit or 3 digit.\\n\\n              **dp[3]  = dp[2] + the combination with  3 digits.** \\n\\n'0' could only be at unit digit and ten's digit.\\n\\nWhen '0' is at unit digit, there are 9 * 8 kind of numbers(9 is the kind of numbers at hundred's digit, 8 is the kind of numbers at ten's digit);\\n\\nWhen '0' is at ten's digit, there are 9 * 8 kind of numbers(9 is the kind of numbers at hundred's digit, 8 is the kind of numbers at unit digit);\\n\\nWhen there is no '0', there are 9 * 8 * 7 kinds of numbers(9 is the kind of numbers at hundred's digit, 8 is the kind of numbers at ten's digit, 7 is the kind of numbers at unit digit).\\n\\nSo there are:\\n\\n                 9 * 8  + 9 * 8 + 9 * 8 * 7  = 9 * 8 * (1 + 1 + 8 ) = 9 * 9 * 8 \\n\\nkinds of combinations with three digits.\\n\\n.........\\n\\nThan it is easy to understand the DP solution of this problem.\\n\\n\\n    class Solution {\\n    public:\\n        int countNumbersWithUniqueDigits(int n) {\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            dp[1] = 10;\\n            for(int i = 2;i<=n;i++){\\n                dp[i] = 9;\\n                int k = 9;\\n                int count = 1;\\n                while( count <i){\\n                    dp[i] *= k;\\n                    k--;\\n                    count++;\\n                }\\n                dp[i] +=dp[i-1];\\n            }\\n            return dp[n];\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int countNumbersWithUniqueDigits(int n) {\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            dp[1] = 10;\\n            for(int i = 2;i<=n;i++){\\n                dp[i] = 9;\\n                int k = 9;\\n                int count = 1;\\n                while( count <i){\\n                    dp[i] *= k;\\n                    k--;\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 374777,
                "title": "python-o-1-99-80-math-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def count(k):\\n            if k == max(10 - n, 0):\\n                return 0\\n            return k*(1 + count(k - 1))\\n        if n == 0:\\n            return 1\\n        return 9*count(9) + 10\\n```\\n![image](https://assets.leetcode.com/users/denyscoder/image_1567948498.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def count(k):\\n            if k == max(10 - n, 0):\\n                return 0\\n            return k*(1 + count(k - 1))\\n        if n == 0:\\n            return 1\\n        return 9*count(9) + 10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83037,
                "title": "very-simple-15-line-backtrack-solution",
                "content": "Re: [Backtracking solution](/topic/48001/backtracking-solution)\\n\\nThanks for sharing. I think it could be simplified further. This problem is kind of like permutation + subset, so we start from 0 every recursion and count through the path. Forgive me if anything unclear, here is the code:\\n\\n```java\\n    public int countNumbersWithUniqueDigits(int n) {\\n        return doCount(n, new boolean[10], 0);\\n    }\\n    \\n    private int doCount(int n, boolean[] used, int d) {\\n        if (d == n) return 1;\\n        int total = 1;\\n        for (int i = (d == 0) ? 1 : 0; i <= 9; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                total += doCount(n, used, d + 1);\\n                used[i] = false;\\n            }\\n        }\\n        return total;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int countNumbersWithUniqueDigits(int n) {\\n        return doCount(n, new boolean[10], 0);\\n    }\\n    \\n    private int doCount(int n, boolean[] used, int d) {\\n        if (d == n) return 1;\\n        int total = 1;\\n        for (int i = (d == 0) ? 1 : 0; i <= 9; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                total += doCount(n, used, d + 1);\\n                used[i] = false;\\n            }\\n        }\\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201226,
                "title": "what-s-the-point-of-this",
                "content": "I can list all possible results using simple arithmetics...\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        if n>10:\\n            n=10\\n        l = [1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691]\\n        return l[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        if n>10:\\n            n=10\\n        l = [1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691]\\n        return l[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83094,
                "title": "simple-java-solution-with-explanation",
                "content": "The problem is a simple Math problem:\\n\\nLet res[i] represents the number of unique numbers among i-digit numbers.\\nFor example:\\n\\n* res[0] = 1, since there is only 0.\\n* res[1] = 9, because all one-digit numbers are unique : 1,2,3,4,5,6,7,8,9.\\n* res[2] = 81, \\nBecause among all two-digit numbers (10 - 99), the number with unique digits = 9 * 9.\\nThe first digit is chosen from (1,2,3,4,5,6,7,8,9), so there are 9 choices,\\nThe second digit is chosen from (0,1,2,3,4,5,6,7,8,9) except the one has been chosen as the first digit, so there are 9 choices.\\n\\n* res[3] = 9 * 9 * 8 = 648.\\n\\n* res[4] = 9 * 9 * 8 * 7.\\n\\nAnd so on so forth.\\nThe result is the sum from res[0] to res[n].\\n\\nWe can notice that:\\nres[0] = 1,\\nres[1] = 9,\\nres[2] = 9 * 9           = 9 * res[1],\\nres[3] = 9 * 9 * 8      = 8 * res[2],\\nres[4] = 9 * 9 * 8 * 7 = 7 * res[3].\\n\\nApparently, we can compute the latter one using DP.\\n\\nCode:\\n\\n```\\npublic class Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int res[] = new int[n + 1];\\n        res[0] = 1;\\n        int sum = 1;\\n        int k = 9;\\n        for(int i = 1; i <= n && k > 0; i++){\\n               if(i == 1) res[i] += res[i - 1] * 9;\\n               else res[i] += res[i - 1] * k--;\\n               sum += res[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int res[] = new int[n + 1];\\n        res[0] = 1;\\n        int sum = 1;\\n        int k = 9;\\n        for(int i = 1; i <= n && k > 0; i++){\\n               if(i == 1) res[i] += res[i - 1] * 9;\\n               else res[i] += res[i - 1] * k--;\\n               sum += res[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440515,
                "title": "100-faster-c-just-use-common-sense",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int dp[10];\\n        memset(dp,0,sizeof(dp));\\n        dp[0] = 1;\\n        dp[1] = 9;\\n        dp[2] = 9*9;\\n        dp[3] = 9*9*8;\\n        dp[4] = 9*9*8*7;\\n        dp[5] = 9*9*8*7*6;\\n        dp[6] = 9*9*8*7*6*5;\\n        dp[7] = 9*9*8*7*6*5*4;\\n        dp[8] = 9*9*8*7*6*5*4*3;\\n        int ans = 0;\\n        for(int i=0;i<=n;i++)\\n            ans += dp[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int dp[10];\\n        memset(dp,0,sizeof(dp));\\n        dp[0] = 1;\\n        dp[1] = 9;\\n        dp[2] = 9*9;\\n        dp[3] = 9*9*8;\\n        dp[4] = 9*9*8*7;\\n        dp[5] = 9*9*8*7*6;\\n        dp[6] = 9*9*8*7*6*5;\\n        dp[7] = 9*9*8*7*6*5*4;\\n        dp[8] = 9*9*8*7*6*5*4*3;\\n        int ans = 0;\\n        for(int i=0;i<=n;i++)\\n            ans += dp[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83065,
                "title": "two-c-solutions-backtracking-and-dp-4-lines-only",
                "content": "DP solution:\\n\\n    class Solution {\\n    public:\\n        int countNumbersWithUniqueDigits(int n) {\\n            vector<int> tbl(min(n,10)+1, 1);\\n            for (int i = 1; i <= min(n,10); i++)\\n                tbl[i] = tbl[i-1] * (i == 1? 9: (9-i+2));\\n            return accumulate(tbl.begin(), tbl.end(), 0);\\n        }\\n    };\\n\\nBacktracking solution\\n\\n    class Solution {\\n    public:\\n        int countNumbersWithUniqueDigits(int n) {\\n            bool visit[10] = {false};\\n            int count = 0;\\n            for (int i = 0; i <= min(10,n); i++)\\n                count += DFS(i, 0, visit);\\n            return count;\\n        }\\n    private:\\n        int DFS(int target, int idx, bool* visit) {\\n            if (idx == target)\\n                return 1;\\n    \\n            int count = 0;\\n            for (int i = idx?0:1; i < 10; i++) {\\n                if (!visit[i]) {\\n                    visit[i] = true;\\n                    count += DFS(target, idx+1, visit);\\n                    visit[i] = false;\\n                }\\n            }\\n            return count;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        int countNumbersWithUniqueDigits(int n) {\\n            vector<int> tbl(min(n,10)+1, 1);\\n            for (int i = 1; i <= min(n,10); i++)\\n                tbl[i] = tbl[i-1] * (i == 1? 9: (9-i+2));\\n            return accumulate(tbl.begin(), tbl.end(), 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 83167,
                "title": "11-lines-c-solution-with-detailed-explanation",
                "content": " It's a statistical solution.\\n\\nSay we have an i-bit-number, the MSB is not 0. \\n\\nFor the MSB, we can put 1 ~ 9, that is **9** options. \\n\\nAnd for the second MSB, we can put 0 ~ 9 exclude the digit we already used for the MSB, so that should be **9** options.\\n\\nThen, the third MSB, put 0 ~ 9 exclude the digits we used for the left two bits. That's **8** options.\\n\\n...\\n\\nTotally, we have **9 * 9 * 8 * 7 * ...** till the LSB.\\n\\nConsider numbers with 1 to n digits. Then I came into the following solution.\\n\\n\\n\\n       int countNumbersWithUniqueDigits(int n) \\n            {\\n                int num = 0;\\n                for(int i = n; i >= 1; --i)\\n                {\\n                    int part = 9;\\n                    for(int j = 0; j < i - 1; ++j)\\n                    {\\n                        part *= 9 - j;\\n                    }\\n                    num += part; \\n                }\\n                return num + 1;  //Include 0.\\n            }",
                "solutionTags": [],
                "code": " It's a statistical solution.\\n\\nSay we have an i-bit-number, the MSB is not 0. \\n\\nFor the MSB, we can put 1 ~ 9, that is **9** options. \\n\\nAnd for the second MSB, we can put 0 ~ 9 exclude the digit we already used for the MSB, so that should be **9** options.\\n\\nThen, the third MSB, put 0 ~ 9 exclude the digits we used for the left two bits. That's **8** options.\\n\\n...\\n\\nTotally, we have **9 * 9 * 8 * 7 * ...** till the LSB.\\n\\nConsider numbers with 1 to n digits. Then I came into the following solution.\\n\\n\\n\\n       int countNumbersWithUniqueDigits(int n) \\n            {\\n                int num = 0;\\n                for(int i = n; i >= 1; --i)\\n                {\\n                    int part = 9;\\n                    for(int j = 0; j < i - 1; ++j)\\n                    {\\n                        part *= 9 - j;\\n                    }\\n                    num += part; \\n                }\\n                return num + 1;  //Include 0.\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 83072,
                "title": "java-simple-code-o-1-space-o-n-time-with-combinatorics-knowledge",
                "content": "test case is wrong when n==1, it should be 11 instead of 10, from 0 to 10 inclusively \\n\\nn=2  10+9 * 9\\n\\nn=3  10+9 * 9+9 * 9 * 8 \\n\\nn=4  10+9 * 9+9 * 9 * 8+9 * 9 * 8 * 7\\n\\n...\\n\\nwhen n > 10, the total number won't increase any more, so we set n=10 in that case \\n\\n    public class Solution {\\n        public int countNumbersWithUniqueDigits(int n) {\\n            if (n == 0) {\\n                return 2;\\n            }\\n            if (n == 1) {\\n                return 10; // should be 11\\n            }\\n            n = Math.min(n, 10);\\n            int sum = 10;\\n            int tmp = 9;\\n            for (int i = 1; i < n; i++) {\\n                tmp *= 10 - i;\\n                sum += tmp;\\n            }\\n            return sum;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int countNumbersWithUniqueDigits(int n) {\\n            if (n == 0) {\\n                return 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2582540,
                "title": "java-0ms-fastest-solution",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) \\n    {\\n\\t/*\\n\\t    9 * 9 + 10 for n = 2\\n        9 * 9 * 8 + 10 for n = 3\\n        9 * 9 * 8 * 7 + 10 for n = 4\\n        9 * 9 * 8 * 7 * 6 + 10 for n = 5\\n\\t*/\\t\\n        if(n == 0)\\n            return 1;\\n        \\n        if(n == 1)\\n            return 10;\\n        \\n        int product =9;\\n        int result = 10;\\n        \\n        for(int i=2; i<=n; i++)\\n        {\\n            product = product * (11-i);\\n            result += product;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) \\n    {\\n\\t/*\\n\\t    9 * 9 + 10 for n = 2\\n        9 * 9 * 8 + 10 for n = 3\\n        9 * 9 * 8 * 7 + 10 for n = 4\\n        9 * 9 * 8 * 7 * 6 + 10 for n = 5\\n\\t*/\\t\\n        if(n == 0)\\n            return 1;\\n        \\n        if(n == 1)\\n            return 10;\\n        \\n        int product =9;\\n        int result = 10;\\n        \\n        for(int i=2; i<=n; i++)\\n        {\\n            product = product * (11-i);\\n            result += product;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897117,
                "title": "o-1-space-the-most-easy-and-intuitive-solution-for-this-problem-guarenteed",
                "content": "We need to find out the count of unique digit numbers. Let\\'s first go through some cases and try to build some relation if it exists.\\n\\n**Case 1:** if (n == 0) then we will only have 1 unique digit number that is 0 itself so the answer is 1\\n\\n![image](https://assets.leetcode.com/users/images/69cd40d9-3596-4648-9bab-bfec5d7bdfb1_1648633516.4528067.png)\\n\\n**Case 2:** if (n == 1) that is we need to find the count of all the single digit unique numbers which obviously will be equal to 9 {1, 2, 3, 4, 5, 6, 7, 8, 9}. However the final answer will be 10[Since we have 1 unique number when n = 0]\\n\\n![image](https://assets.leetcode.com/users/images/d5ae7ee3-d5b2-4508-b575-47af0c2a82d0_1648633494.3350484.png)\\n\\n**Case 3:** For n = 2 let\\'s first find the duplicate digits numbers because now we can have duplicates in digits. \\n\\n![image](https://assets.leetcode.com/users/images/3816d6a9-77d5-428b-b278-dcf569832242_1648634038.8533676.png)\\n\\n![image](https://assets.leetcode.com/users/images/41148bbc-4844-499e-9b06-a186d4dd7621_1648634103.517041.png)\\n\\nSimilarly For n = 3:\\n\\n![image](https://assets.leetcode.com/users/images/d8b473fe-9c99-40c6-a20c-6b7fd3438a99_1648633651.0510612.png)\\n\\nNow we can code it up very easily we just need to keep track of the previous size duplicate and non duplicate count and first calculate current duplicate and then non duplicate count and then add the non duplicate count to our answer.\\n\\nThe code for c++ and java will be the same except the class declaration part. \\n\\n**Code C++:**\\n\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int d = 0, nd = 1, tot = 9, ans = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            d = nd * (i - 1) + d * 10;\\n            nd = tot - d;\\n            ans += nd;\\n            tot *= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time complexity:** O(n)\\n**Space complexity:** O(4) which is constant space",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int d = 0, nd = 1, tot = 9, ans = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            d = nd * (i - 1) + d * 10;\\n            nd = tot - d;\\n            ans += nd;\\n            tot *= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174608,
                "title": "using-permutations-and-combinations-simple-o-n-solution",
                "content": "\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        dp=[9]*(n+1) #always avoiding 0 at start for every value of i.\\n        dp[0]=1 # we know for n=0, x=1\\n        for i in range(1,n+1): # this is to calculate for every i the posibilities, that is for i digit number,\\n\\t\\t                                  #how many  possibilities are there for non repeaing digits\\n            for j in range(9,9-i+1,-1): \\n                dp[i]*=j\\n        for i in range(0,n):\\n            dp[n]+=dp[i] #to get value for n, we will add all i\\'s before n to n.\\n        return dp[n]\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        dp=[9]*(n+1) #always avoiding 0 at start for every value of i.\\n        dp[0]=1 # we know for n=0, x=1\\n        for i in range(1,n+1): # this is to calculate for every i the posibilities, that is for i digit number,\\n\\t\\t                                  #how many  possibilities are there for non repeaing digits\\n            for j in range(9,9-i+1,-1): \\n                dp[i]*=j\\n        for i in range(0,n):\\n            dp[n]+=dp[i] #to get value for n, we will add all i\\'s before n to n.\\n        return dp[n]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1319594,
                "title": "java-pure-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n         return recursion(n,0,new boolean[10]);\\n    }\\n    int recursion(int n,int curr,boolean[] vis)\\n    {\\n        if(curr == n)\\n            return 1;\\n        int res = 1;\\n        for(int i=(curr == 0 ? 1 : 0);i<=9;i++)\\n        {\\n            if(vis[i])\\n                continue;\\n            vis[i] = true;\\n            res+=recursion(n,curr+1,vis);\\n            vis[i] = false;\\n        }\\n        return res;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n         return recursion(n,0,new boolean[10]);\\n    }\\n    int recursion(int n,int curr,boolean[] vis)\\n    {\\n        if(curr == n)\\n            return 1;\\n        int res = 1;\\n        for(int i=(curr == 0 ? 1 : 0);i<=9;i++)\\n        {\\n            if(vis[i])\\n                continue;\\n            vis[i] = true;\\n            res+=recursion(n,curr+1,vis);\\n            vis[i] = false;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898568,
                "title": "c-simple-solution-faster-than-100-without-using-extra-memory-10-lines",
                "content": "Lets explain code with some example,lets take n==3\\nWe will have range [0,1000),or we can say we have all numbers with 1,2 and 3 digits.\\nSo we will split it in those categories.\\nIf you have numbers with 3 digits,to describe unique number,we can make pattern:\\n* First,or most left or highes digit can be 1,2,3,...,9 (we can not start number with 0),so we have **9** options\\n* Second digit can be 0,1,2,3,...,9,but we must exclude **first** chosen digit,so have **9** options\\n* Third digit can be 0,1,2,3,...,9,but we must exclude **first** and **second** chosen digits,so we have **8** options\\n* If we have four digits,fourth digit will have **7** options.\\nSo we can figure out that we can choose 9x9x8 3-digit number\\nThat pattern can be applied for any n>=1\\nIf n==0,than only number we can choose is 0,and if we have n==1,we have 9 digits,and also 0\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n<=1) return pow(10,n);\\n        int n1 = n-1;\\n        int product = 9;\\n        int curr = 9;\\n        while (n>1) {\\n            product*=curr;\\n            n--;\\n            curr--;\\n        }\\n        return product+countNumbersWithUniqueDigits(n1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n<=1) return pow(10,n);\\n        int n1 = n-1;\\n        int product = 9;\\n        int curr = 9;\\n        while (n>1) {\\n            product*=curr;\\n            n--;\\n            curr--;\\n        }\\n        return product+countNumbersWithUniqueDigits(n1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883424,
                "title": "c-0ms-clean-solution-with-explanation",
                "content": "For a given number n, we have to find all i-digit numbers where ```0 <= i <= n``` . For example for n = 3, final answer = 0-digit unique numbers + 1-digit unique numbers + 2-digit unique numbers + 3-digit unique numbers.\\nAnd i-digit unique numbers = ```9x9x8x7x...i-places``` using combinatrics because for 1st position we have 9 choices ( except 0 ) and then subsequently 9 , 8 , 7 for 1st, 2nd and 3rd positions.\\n\\nHere is the code.\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int ans = 1;\\n        for(int i = 1;i <= n;i++){\\n            int iDigitNumbers = 9;\\n            for(int j = 9; j>= 10 - i + 1;j--){\\n                iDigitNumbers *= j;\\n            }\\n            ans += iDigitNumbers;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```0 <= i <= n```\n```9x9x8x7x...i-places```\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int ans = 1;\\n        for(int i = 1;i <= n;i++){\\n            int iDigitNumbers = 9;\\n            for(int j = 9; j>= 10 - i + 1;j--){\\n                iDigitNumbers *= j;\\n            }\\n            ans += iDigitNumbers;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248582,
                "title": "357-time-95-29-and-space-94-84-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if n is equal to 0. If it is, then there is only 1 possible number with unique digits, which is 0. Return 1 as the result.\\n2. If n is greater than 10, then the count will be the same as countNumbersWithUniqueDigits(10) because for n > 10, there will be repetition, and the count will not change anymore. Therefore, set n to min(n, 10).\\n3. Start with a base count of 10, since we can always have 0 to 9 as the first digit. We will add more numbers to this count as we go along.\\n4. For the second digit, we can have 9 choices, since 0 is already used. For the third digit, we can have 9 choices again, since we cannot repeat the first or second digit. For the fourth digit, we can have 8 choices, and so on. The total count is the product of the number of choices for each digit.\\n5. Therefore, for i from 2 to n, compute the number of choices for each digit and add it to the count.\\n6. Return the count as the result.\\n\\n# Complexity\\n- Time complexity:\\n95.29%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        \\n        # The maximum number of unique digits we can have is 10, since we have 10 digits in base 10\\n        # For n > 10, there will be repetition, so the count will be the same as countNumbersWithUniqueDigits(10)\\n        n = min(n, 10)\\n        \\n        # Start with a base count of 10, since we can always have 0 to 9 as the first digit\\n        count = 10\\n        \\n        # For the second digit, we can have 9 choices, since 0 is already used\\n        # For the third digit, we can have 9 choices again, since we cannot repeat the first or second digit\\n        # For the fourth digit, we can have 8 choices, and so on\\n        # The total count is the product of the number of choices for each digit\\n        for i in range(2, n + 1):\\n            choices = 9\\n            for j in range(i - 1):\\n                choices *= 9 - j\\n            count += choices\\n        \\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        \\n        # The maximum number of unique digits we can have is 10, since we have 10 digits in base 10\\n        # For n > 10, there will be repetition, so the count will be the same as countNumbersWithUniqueDigits(10)\\n        n = min(n, 10)\\n        \\n        # Start with a base count of 10, since we can always have 0 to 9 as the first digit\\n        count = 10\\n        \\n        # For the second digit, we can have 9 choices, since 0 is already used\\n        # For the third digit, we can have 9 choices again, since we cannot repeat the first or second digit\\n        # For the fourth digit, we can have 8 choices, and so on\\n        # The total count is the product of the number of choices for each digit\\n        for i in range(2, n + 1):\\n            choices = 9\\n            for j in range(i - 1):\\n                choices *= 9 - j\\n            count += choices\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582326,
                "title": "dp-solution-c-beats-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int sum=1,c=9;\\n        vector<int> dp(n+2);\\n        dp[0]=1,dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]*c+sum;\\n            sum+=dp[i-1];\\n            c--;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int sum=1,c=9;\\n        vector<int> dp(n+2);\\n        dp[0]=1,dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]*c+sum;\\n            sum+=dp[i-1];\\n            c--;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172040,
                "title": "python-solution",
                "content": "The variable `tmp` at iteration `i` denotes the number of i-digit integers with unique digits. It\\'s easy to see that `tmp = 9` when `i = 1` (excluding 0), `tmp = 9 * 9` when `i = 2`, `tmp = 9 * 9 * 8` when `i = 3`, ..., `tmp = 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1` when `i = 10`. When `i > 10`, every integer with `i` digits must have duplicated digits. The solution `res` can be constructed iteratively by adding up the `tmp` from each iteration. Finally we return `res + 1` to include 0.\\n```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        tmp = 1\\n        for i in range(1,min(n,10)+1):\\n            if i == 1:\\n                tmp *= 9\\n            else:\\n                tmp *= 10-i+1\\n            res += tmp\\n        return res+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        tmp = 1\\n        for i in range(1,min(n,10)+1):\\n            if i == 1:\\n                tmp *= 9\\n            else:\\n                tmp *= 10-i+1\\n            res += tmp\\n        return res+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910861,
                "title": "c-dp-math-derived-o-1-time-solution-for-arbitrary-base",
                "content": "\\n# Approach 1: Backtracking\\n\\nLet\\'s first think about the nature of the problem. For simplicity, suppose $n = 3$. Then we\\'re searching for the amount of numbers in the range $[0, 10^3) = [0, 999]$ with distinct digits. Let\\'s call any number with distinct digits a \"unique number\". Notice that all $3$-digit unique numbers are of the form $d_3d_2d_1$ ($3$ digit slots to place a distinct digit). For example, for the unique number $123$, $d_3 = 1$, $d_2 = 2$, and $d_1 = 3$. So for any $d_i$, $d_i$ is in the range $[0, 9]$. However, $d_3$ cannot be $0$ because then our number does not have $3$ digits (e.g. $023 = 23$ is a $2$-digit number). So to be more specific, $d_n \\\\in \\\\{1,..., 9\\\\}$ and $d_i \\\\in \\\\{0,..., 9\\\\}$ where $i \\\\in \\\\{1, ...,n - 1\\\\}$. With this in mind, let\\'s think about how we might construct a $3$-digit unique number in the range $[0, 999]$ from left to right. If we fix $d_3$ as some integer $k \\\\in \\\\{1,..., 9\\\\}$, then our options for $d_2$ are limited to $\\\\{0,...,9\\\\} \\\\setminus\\\\{k\\\\}$. And if we fix $d_2$ as some integer $m \\\\in \\\\{0,...,9\\\\} \\\\setminus\\\\{k\\\\}$, then our options for $d_1$ are limited to $\\\\{0,...,9\\\\} \\\\setminus \\\\{k, m\\\\}$. \\n\\nNow let\\'s generalize this to an $n$-digit unique number. Suppose we\\'re choosing the digit to fill $d_i$ ($i \\\\in \\\\{1,...,n - 1\\\\}$). Then we must choose some $k \\\\in \\\\{0,...,9\\\\} \\\\setminus \\\\{d_n,...,d_{i + 1}\\\\}$ and set $d_i = k$. After fixing $d_i$, note that the possible choices for any of the digits to the right of $d_i$ is limited to $\\\\{1,...,9\\\\} \\\\setminus \\\\{d_{n}, ..., d_{i}\\\\}$. So if we track which digits we\\'ve added to our unique number we can construct and count all possible unique numbers.\\n\\nThus, to count all possible unique numbers in the range $[0, 10^n)$, we will individually construct and count all $i$-digit unique numbers for all $i \\\\in \\\\{0,...,n\\\\}$. (We consider $0$ as the only $0$-digit number).\\n\\nSomething else we can notice is that the count of unique numbers is bounded. It turns out that for all $i > 10$, $countNumberWithUniqueDigits(i) = countNumberWithUniqueDigits(10)$. This is because for any $i$-digit number where $i > 10$, there are $11$ or more slots for digits in the number, however, we only have $10$ distinct digits ($\\\\{0,...,9\\\\}$) to incorporate into our unique number, so we could never create an $i$-digit unique number. This is why in all implementations, we set `n = min(10, n)`, however, this is not necessary to pass the test cases as `n` is bounded by $8$ for the test cases.\\n\\n## Algorithm\\n1. Initialize a boolean array `chosen` of length `10` to `false`. `chosen[j]` denotes that `j` already occupies a digit slot $d_i$ ($i \\\\in \\\\{n, ...,i + 1\\\\}$) in our unique number.\\n2. Set $n = min(10, n)$ since we\\'ve established that the number of unique numbers is bounded.\\n3. Create a `backtrack` function that takes `chosen`, `n`, and`k` as arguments. `backtrack` counts the number of $n$-digit unique numbers less than $10^n$ and `k` denotes the digit slot currently being fixed in our unique number:\\n    - If `k == 0`, then return `1` because there are no digits left to fix, and we have a unique number.\\n    - Maintain a variable `numUnique` that counts how many unique numbers exist such that $d_{n},...,d_{k + 1}$ are fixed according to `chosen`.\\n    - Iterate over `chosen`. For each `chosen[i]`, if `chosen[i] == false`, then `i` can occupy slot $d_k$, and we set `chosen[i] = true` and add the result of `backtrack(chosen, k - 1)` to `numUnique`. After, we set `chosen[i] = false` for future calls to `backtrack`. Note that we cannot choose `0` if `k == n` as explained previously. \\n    - Return `numUnique`\\n4. Maintain a variable `count` initialized to `0` that tracks the total count of unique numbers less than $10^n$. Iterate from $0$ to $n$ and add the result of `backtrack(chosen, i)` to `count`.\\n5. Return `count`.\\n\\n## Complexity\\n- Time Complexity: $O(10 * 10!)$ \\n\\n- Space Complexity: $O(10)$ \\n\\n## Code\\n```\\nclass Solution { \\nprivate:\\n    int backtrack(vector<bool>& chosen, int k, int n) {\\n        \\n        if (k < 1)\\n            return 1;\\n\\n        int numUnique = 0;\\n\\n        for (int j = 0; j <= 9; ++j)\\n        {\\n            if ((chosen[j] == false) && (j != 0 || k != n))\\n            {\\n                chosen[j] = true;\\n                numUnique += backtrack(chosen, k - 1, n);\\n                chosen[j] = false;\\n            }\\n        }\\n\\n        return numUnique;\\n    }\\n\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int count = 0;\\n        vector<bool> chosen(10, false);\\n\\n        for (int i = 0; i <= n; ++i)\\n            count += backtrack(chosen, i, i);\\n\\n        return count;\\n    }\\n};\\n```\\n\\n# Approach 2: Math + Dynamic Programming\\n\\nWhile the backtracking algorithm technically has constant time complexity, the time complexity constant is very large. There are two observations we can make to improve the time complexity:\\n\\n1. Optimal substructure: one important thing to notice is that we\\'re performing a lot of redundant computations. When we count the number of $i$-digit unique numbers, we end up reconstructing many of the ($i - 1$)-digit unique numbers, as well as the ($i - 2$)-digit unique numbers and so forth. For example, $4321$\\u2014a $4$-digit unique number\\u2014can be constructed by prepending $4$ to the $3$-digit unique number $321$, and we ended up constructing the unique number $321$ in both the call to `backtrack(chosen, 3, 3)` and `backtrack(chosen, 4, 4)`. This suggests that we can use the result of a previous call like $countNumberWithUniqueDigits(i - 1)$ to solve the current problem $countNumberWithUniqueDigits(i)$.\\n2. The illusion of distinct subproblems: another thing that may be a bit more difficult to notice is that some subproblems appear as distinct in our backtracking solution, but in reality, they\\'re not. For example, suppose $n = 3$ and we fix $d_n = 3$. Then our options for all other digit slots are limited to $\\\\{1,2,4,...,9\\\\}$. Now suppose we fix $d_n = 2$. Then our options for all other digit slots are limited to $\\\\{1,3,4,...,9\\\\}$. While $\\\\{1,2,4,...,9\\\\} \\\\neq \\\\{1,3,4,...,9\\\\}$, the number of ways we can choose the remaining two digits for our unique number from either set and arrange the chosen digits is ultimately the same. This realization will allow us to use combinatorial techniques in deriving a more efficient solution.\\n\\nLet $f(n) = countNumberWithUniqueDigits(n)$. Note that $f(0) = 1$ because the only unique number less than $10^0 = 1$ is $0$. We\\'re going to try to define $f(n)$. \\n\\nFor right now, suppose $g(n)$ is a function that counts how many $n$-digit unique numbers less than $10^n$ exist. Notice the difference between $g$ and $f$. $g(n)$ only counts the number of $n$-digit numbers less than $10^n$ whereas $f(n)$ counts the number of $i$-digit unique numbers less than $10^n$ ***for all*** $$i \\\\in \\\\{0,...,n\\\\}$$. Can you compute $f(n)$ using just $g$ and $f$? Well the formula actually follows the approach we were using before. We still want to count all $i$-digit unique numbers for all $i \\\\in \\\\{0,...,n\\\\}$, so we can just merge the two functions to get:\\n\\n> $f(n) = g(n) + f(n - 1)$\\n\\nNow the main trouble comes with defining $g(n)$\\n\\n\\nBefore we get into some math, let\\'s think intuitively how we could define $g(n)$. Well, remember that for each digit slot we can choose from a set of $10$ digits. We have $n$ digit slots, so we\\'re really focused on choosing $n$ distinct digits from the $10$ available digits. Additionally, we can order the chosen distint digits in any order to form a unique number. So if $waysToChoose_n$ is the number of ways to choose $n$ distinct digits from the $10$ available digits and $waysToOrder_n$ is the number of ways we can order the $n$ chosen digits, the total number of $n$-digit unique numbers that we can form should be $waysToChoose_n \\\\cdot waysToOrder_n$. But there\\'s one slight problem: what if we choose $0$ as one of the $n$ distinct digits. Can you think of how this might become a problem? The issue is that one of the possible ways we can order our distinct digits is by setting $d_{n} = 0$ followed by some ordering of our other $n - 1$ digits. For example, if $n = 4$ and we choose $1$, $0$, $3$, and $4$, one possible ordering is $0123$. But this isn\\'t a $4$-digit unique number but rather a $3$-digit unique number so we need to account for this. Notice that because $0$ is fixed in slot $d_{n}$, the following digits form an $(n - 1)$-digit unique number that doesn\\'t contain a $0$. So it turns out that if $withoutZero_{n - 1}$ denotes the number of $(n - 1)$-digit unique numbers that don\\'t contain a $0$, \\n\\n> $g(n) = (waysToChoose_n \\\\cdot waysToOrder_n) - withoutZero_{n - 1}$\\n\\nNow to mathematically define these variables. Remember that $waysToChoose_n$ is just the number of ways to choose $n$ distinct digits from the $10$ available digits, so $waysToChoose_n = {10 \\\\choose n}$. Additionally, $waysToOrder_n$ is simply the number of ways to order the $n$ distinct digits (i.e. number of permutations), which is $n!$. \\n\\nSo far, we have \\n\\n> $g(n) = \\\\displaystyle\\\\left(n! \\\\cdot {10 \\\\choose n}\\\\right) - withoutZero_{n - 1}$\\n\\nRemember that $withoutZero_{n - 1}$ denotes the number of $(n - 1)$-digit numbers that don\\'t contain a $0$. Since the unique number can\\'t contain $0$, we construct a number of this form by choosing $(n - 1)$ digits from the following $9$ non-zero digits: $\\\\{1,...,9\\\\}$ and order the chosen $n - 1$ digits in any way. So if $waysToChooseNoZero_{n - 1}$ denotes the number of ways to choose $n - 1$ distinct digits from the $9$ available non-zero digits and $waysToOrderNoZero_{n - 1}$ denotes the number of ways to order the chosen distinct digits, \\n\\n$withoutZero_{n - 1} = waysToChooseNoZero_{n - 1} \\\\cdot waysToOrderNoZero_{n - 1}$\\n\\nOnce again, $waysToChooseNoZero_{n - 1}$ is just the number of ways to chose $n - 1$ distinct digits from the $9$ available non-zero digits, so $waysToChooseNoZero_{n - 1} = {9 \\\\choose n - 1}$. And $waysToOrderNoZero_{n - 1}$ is simply the number of ways to order the $n - 1$ distinct digits, which is $(n - 1)!$.\\n\\nPutting this altogether, we get\\n> $g(n) = \\\\displaystyle\\\\left(n! \\\\cdot {10 \\\\choose n}\\\\right) - \\\\left((n - 1)! \\\\cdot {9 \\\\choose n - 1}\\\\right)$\\n\\n> $f(n) = \\\\displaystyle\\\\left(n! \\\\cdot {10 \\\\choose n}\\\\right) - \\\\left((n - 1)! \\\\cdot {9 \\\\choose n - 1}\\\\right) + f(n - 1)$\\n\\nTo avoid computing these binomial coefficients, we can simplify our expression\\n\\n$$f(n) = \\\\displaystyle\\\\left(n! \\\\cdot {10 \\\\choose n}\\\\right) - \\\\left((n - 1)! \\\\cdot {9 \\\\choose n - 1}\\\\right) + f(n - 1)$$\\n\\n$$ f(n) = \\\\dfrac{n! \\\\cdot 10!}{n! \\\\cdot (10 - n!)} - \\\\dfrac{(n - 1)! \\\\cdot 9!}{(n - 1)! \\\\cdot (9 - (n - 1))!} + f(n - 1)$$\\n\\n$$ f(n) = \\\\dfrac{10!}{(10 - n)!} - \\\\dfrac{9!}{(10 - n)!} + f(n - 1)$$\\n\\n$$ f(n) = \\\\dfrac{(10 - 1) \\\\cdot 9!}{(10 - n)!} + f(n - 1)$$\\n\\n$$ f(n) = \\\\dfrac{9 \\\\cdot 9!}{(10 - n)!} + f(n - 1)$$\\n\\n$$ f(n) = \\\\dfrac{9 \\\\cdot 9!}{(10 - n)!} + f(n - 1)$$\\n\\n$$ f(n) = \\\\displaystyle\\\\left(9 \\\\cdot \\\\prod_{j = 10 - n + 1}^{9} j\\\\right) + f(n - 1)$$\\n\\n$$ f(n) = \\\\displaystyle\\\\left(9 \\\\cdot \\\\prod_{j = 11 - n}^{9} j\\\\right) + f(n - 1)$$\\n\\nWe now have a much simpler recurrence that can be implemented using constant space dynamic programming since we need only save the result of $f(n - 1)$.\\n\\n## Algorithm\\n1. Initialize `dpOneBack = 1` as $1$. `dpOneBack` represents $f(n - 1)$. Recall that $f(0) = 1$.\\n2. Iterate from `i = 1` to `i = n` and initialize `prod = 1` at the start of the iteration. At any point in the iteration, `prod` $= \\\\displaystyle\\\\prod_{j = 11 - i}^{9} j$. \\n    - At each step of the iteration, we compute $f(i)$ by simply applying the formula: $f(i) = \\\\displaystyle\\\\left(9 \\\\cdot \\\\prod_{j = 11 - i}^{9} j\\\\right) + f(i - 1)$, which is realized as `dpOneBack = (9 * prod) + dpOneBack` since the current $f(i)$ will be $f(i - 1)$ in the next iteration.\\n3. Return `dpOneBack`.\\n\\n## Complexity\\n- Time Complexity: $O(10)$\\n- Space Complexity: $O(1)$\\n\\n## Code\\n```\\nclass Solution { \\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int dpOneBack;\\n        \\n        n = min(n, 10);\\n        dpOneBack = 1;\\n\\n        for (int i = 1, prod = 1; i <= n; ++i, prod *= (11 - i))\\n            dpOneBack += (9 * prod);\\n\\n        return dpOneBack;\\n    }\\n};\\n```\\n\\nNote that small changes in the combinatorial expression can not only reduce runtime, but completely change the ease and clarity of your implementation. For example, here is a different implementation with the same runtime but utilizes a different expression:\\n\\n$$ f(n) = \\\\dfrac{9 \\\\cdot 9!}{(10 - n)!} + f(n - 1) = \\\\dfrac{3,265,920}{(10 - n)!} + f(n - 1)$$\\n\\n## Alternate Solution 1\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        long long factorial;\\n        int dpOneBack;\\n        \\n        n = min(n, 10);\\n        factorial = 1;\\n        dpOneBack = 1;\\n\\n        for (int i = 2; i <= 9; ++i)\\n            factorial *= i;\\n        \\n        for (int i = 1, j = 9; i <= n; ++i)\\n        {\\n            dpOneBack += (3265920 / factorial);\\n            if (factorial > 1)\\n            {\\n                factorial /= j;\\n                --j;\\n            }\\n        }\\n\\n        return dpOneBack;\\n    }\\n};\\n```\\n\\nHere\\'s another solution utilizing our original formula that runs in $O(10^2)$ time:\\n\\n$f(n) = \\\\displaystyle\\\\left(n! \\\\cdot {10 \\\\choose n}\\\\right) - \\\\left((n - 1)! \\\\cdot {9 \\\\choose n - 1}\\\\right) + f(n - 1)$\\n\\n## Alternate Solution 2\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n\\n        long long prevFactorial, curFactorial;\\n        vector<vector<int>> nCk(11, vector<int>(11));\\n        int dpOneBack;\\n\\n        dpOneBack = 1;\\n        curFactorial = 1;\\n        nCk[0][0] = 1;\\n\\n        for (int i = 1; i < 11; ++i)\\n            for (int k = 0; k <= i; ++k)\\n                nCk[i][k] = ((k == 0 || k >= i) ? 1 : nCk[i - 1][k - 1] + nCk[i - 1][k]);\\n        \\n        for (int i = 1; i <= n; ++i)\\n        {\\n            prevFactorial = curFactorial;\\n            curFactorial = i * prevFactorial;\\n            dpOneBack = (((curFactorial * nCk[10][i]) - (prevFactorial * nCk[9][i - 1])) + dpOneBack);\\n        }\\n\\n        return dpOneBack;\\n    }\\n};\\n```\\n---\\n# Further Thoughts\\n\\nTry the following problem:\\n\\nGiven an integer $n$ and an integer $k$, return the count of all numbers, $x$, in base $k$ with unique digits where $0 \\\\leq x < k^n$.\\n\\n### Example 1\\n**Input:** `n = 2`, `k = 8`\\n**Output:** `57`\\n**Explanation:** There are $57$ numbers with distinct digits in base $8$ less than $8^2 = 64$. Written in base $8$, they are `0, 1, 2, 3, 4, 5, 6, 7, 10, 12, 13, 14, 15, 16, 17, 20, 21, 23, 24, 25, 26, 27, 30, 31, 32, 34, 35, 36, 37, 40, 41, 42, 43, 45, 46, 47, 50, 51, 52, 53, 54, 56, 57, 60, 61, 62, 63, 64, 65, 67, 70, 71, 72, 73, 74, 75, 76`.\\n\\n### Example 2\\n\\n**Input:** `n = 3`, `k = 4`\\n**Output:** `31` \\n**Explanation:** There are $31$ numbers with distinct digits in base $4$ less than $4^3 = 64$. Written in base $4$, they are `0, 1, 2, 3, 10, 12, 13, 20, 21, 23, 30, 31, 32, 102, 103, 120, 123, 130, 132, 201, 203, 210, 213, 230, 231, 301, 302, 310, 312, 320, 321`.\\n\\n### Solution:\\n\\nIf you follow the same reasoning that we did previously, you\\'ll get\\n> $f(0, k) = 1$\\n$f(n, k) = \\\\displaystyle\\\\left(n! \\\\cdot {k \\\\choose n}\\\\right) - \\\\left((n - 1)! \\\\cdot {k - 1 \\\\choose n - 1}\\\\right) + f(n - 1, k)$\\n\\nwhich we can ultimately simplify to $f(n, k) =\\\\displaystyle\\\\left((k - 1) \\\\cdot \\\\prod_{j = k - n + 1}^{k - 1} j\\\\right) + f(n - 1, k)$\\n\\n## Complexity \\n- Time Complexity: $O(k)$\\n- Space Complexity: $O(1)$\\n## Code \\n```\\nunsigned long long countNumbersWithUniqueDigits(int n, int k) {\\n        \\n        unsigned long long dpOneBack;\\n        \\n        n = min(n, k);\\n        dpOneBack = 1;\\n\\n        for (int i = 1, prod = 1; i <= n; ++i, prod *= (k - i + 1))\\n            dpOneBack += ((k - 1) * prod);\\n\\n        return dpOneBack;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution { \\nprivate:\\n    int backtrack(vector<bool>& chosen, int k, int n) {\\n        \\n        if (k < 1)\\n            return 1;\\n\\n        int numUnique = 0;\\n\\n        for (int j = 0; j <= 9; ++j)\\n        {\\n            if ((chosen[j] == false) && (j != 0 || k != n))\\n            {\\n                chosen[j] = true;\\n                numUnique += backtrack(chosen, k - 1, n);\\n                chosen[j] = false;\\n            }\\n        }\\n\\n        return numUnique;\\n    }\\n\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int count = 0;\\n        vector<bool> chosen(10, false);\\n\\n        for (int i = 0; i <= n; ++i)\\n            count += backtrack(chosen, i, i);\\n\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution { \\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int dpOneBack;\\n        \\n        n = min(n, 10);\\n        dpOneBack = 1;\\n\\n        for (int i = 1, prod = 1; i <= n; ++i, prod *= (11 - i))\\n            dpOneBack += (9 * prod);\\n\\n        return dpOneBack;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        long long factorial;\\n        int dpOneBack;\\n        \\n        n = min(n, 10);\\n        factorial = 1;\\n        dpOneBack = 1;\\n\\n        for (int i = 2; i <= 9; ++i)\\n            factorial *= i;\\n        \\n        for (int i = 1, j = 9; i <= n; ++i)\\n        {\\n            dpOneBack += (3265920 / factorial);\\n            if (factorial > 1)\\n            {\\n                factorial /= j;\\n                --j;\\n            }\\n        }\\n\\n        return dpOneBack;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n\\n        long long prevFactorial, curFactorial;\\n        vector<vector<int>> nCk(11, vector<int>(11));\\n        int dpOneBack;\\n\\n        dpOneBack = 1;\\n        curFactorial = 1;\\n        nCk[0][0] = 1;\\n\\n        for (int i = 1; i < 11; ++i)\\n            for (int k = 0; k <= i; ++k)\\n                nCk[i][k] = ((k == 0 || k >= i) ? 1 : nCk[i - 1][k - 1] + nCk[i - 1][k]);\\n        \\n        for (int i = 1; i <= n; ++i)\\n        {\\n            prevFactorial = curFactorial;\\n            curFactorial = i * prevFactorial;\\n            dpOneBack = (((curFactorial * nCk[10][i]) - (prevFactorial * nCk[9][i - 1])) + dpOneBack);\\n        }\\n\\n        return dpOneBack;\\n    }\\n};\\n```\n```\\nunsigned long long countNumbersWithUniqueDigits(int n, int k) {\\n        \\n        unsigned long long dpOneBack;\\n        \\n        n = min(n, k);\\n        dpOneBack = 1;\\n\\n        for (int i = 1, prod = 1; i <= n; ++i, prod *= (k - i + 1))\\n            dpOneBack += ((k - 1) * prod);\\n\\n        return dpOneBack;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591981,
                "title": "pure-math-o-1-detail-explanation",
                "content": "Let me ask you a question: \\n\\n**How many 4 digit numbers are there with all unique digit (No digit repeated) ?**\\n\\n* **First digit** can be among **[(1\\u20139)]**, 0 can\\u2019t be there at the first place, as it will become a 3 digit number.Thus,total possibilities=9, for e.g., say 5 is at the first place.\\n\\n* **Second digit** can be among **[(0\\u20139) excluding 5]** (as 5 is taken at the first place(assuming)).Thus total possibilities=9. Say, 0 is placed at second place.\\n\\n* **Third digit** can be among **[(0\\u20139) excluding 0 and 5]** (since 0 and 5 has already been taken). Thus, total possibilities=8. Say, 3 is placed at third place.\\n\\n* Similarly,  **Fourth digit** can be among **[(0\\u20139) excluding 0, 3 and 5]** (since 0, 3 and 5 has already been taken). Thus, total possibilities=7.\\n\\n**Thus, total possibilities= 9\\xD79\\xD78\\xD77=4536 [4 digit number with all unique digit]**\\n\\n------------------------------------------------------------------------------------------------------------------------------------------------\\nNow, coming back to the actual question:\\n\\n**Let ```n=5```, that means give me the count of all numbers in range 0 <= x < 100000 with all unique digit**\\n* So, our probable answer set will contain 1 digit, 2 digit, 3 digit, 4 digit and 5 digit numbers.\\n* So, we will ask the question : \"**How many \\'d\\' digit number are there with all unique digit**\" in a loop which runs from d=1 to d=5. \\n* Add the count of every iteration and get the actual answer.\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    long long uniqueDigitNum(int digit){ // How many \\'d\\' digit number are there with all unique digit\\n        int totalNum=1; int temp=9;\\n        for(int i=1; i<=digit; i++){\\n            if(i==1){ totalNum*=9; } // [1-9] possibility\\n            else{ totalNum*=temp; temp--; }\\n        }\\n        return totalNum;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0){ return 1; } // only 0\\n        if(n==1){ return 10; } // all num in range [0-9] are unique digit num\\n        \\n        long long total=10; // every one digit number is unique\\n        for(int i=2; i<=n; i++){\\n            total+=uniqueDigitNum(i);\\n        }\\n        return (int)total;\\n    }\\n};\\n```\\nWorst case time complexity: O(8*8) OR  [O(1)]\\n\\nThanks. Hope it helps !",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```n=5```\n```\\nclass Solution {\\npublic:\\n    long long uniqueDigitNum(int digit){ // How many \\'d\\' digit number are there with all unique digit\\n        int totalNum=1; int temp=9;\\n        for(int i=1; i<=digit; i++){\\n            if(i==1){ totalNum*=9; } // [1-9] possibility\\n            else{ totalNum*=temp; temp--; }\\n        }\\n        return totalNum;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0){ return 1; } // only 0\\n        if(n==1){ return 10; } // all num in range [0-9] are unique digit num\\n        \\n        long long total=10; // every one digit number is unique\\n        for(int i=2; i<=n; i++){\\n            total+=uniqueDigitNum(i);\\n        }\\n        return (int)total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067399,
                "title": "simple-compact-fast-and-recursive",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n        return 1;\\n        int p=9,q=9,r=n;\\n        while(n-->1)\\n        p*=q--;     \\n        return p+countNumbersWithUniqueDigits(r-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n        return 1;\\n        int p=9,q=9,r=n;\\n        while(n-->1)\\n        p*=q--;     \\n        return p+countNumbersWithUniqueDigits(r-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636422,
                "title": "easy-to-understand-in-c-math-d-p",
                "content": "class Solution {\\npublic:\\n\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 10;\\n        }\\n        vector<int>dp(9,0);\\n        int sum=1;\\n        dp[0]=1;\\n        dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]*(10-i+1)+sum;\\n            sum+=dp[i-1];\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 830173,
                "title": "c-digit-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int digitDp(int pos,string visited,unordered_map<int,unordered_map<string,int>>& dp, int n,bool tight){\\n        if(n==pos)\\n            return 1;\\n        if(dp.count(pos) && dp[pos].count(visited))\\n                return dp[pos][visited];\\n        int count=0;\\n        for(int i=0;i<=9;i++){\\n            if(i==0 && tight)\\n                count+=digitDp(pos+1,visited,dp,n,true);\\n            else if(visited[i]==\\'0\\'){\\n                visited[i]=\\'1\\';\\n                count+=digitDp(pos+1,visited,dp,n,false);\\n                visited[i]=\\'0\\';\\n            }\\n        } \\n        return dp[pos][visited]=count;\\n            \\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n         unordered_map<int,unordered_map<string,int>> dp; // pos,visited,count\\n        //tight parameter is for handling cases like 0031,0002,00.. these numbers won\\'t be counted if tight isn\\'t used \\n        string visited=\"0000000000\";\\n        int ans=digitDp(0,visited,dp,n,true); // if tight\\'s true then we consider our current number has only zeros till pos-1 so we still have an option to choose zero after pos\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digitDp(int pos,string visited,unordered_map<int,unordered_map<string,int>>& dp, int n,bool tight){\\n        if(n==pos)\\n            return 1;\\n        if(dp.count(pos) && dp[pos].count(visited))\\n                return dp[pos][visited];\\n        int count=0;\\n        for(int i=0;i<=9;i++){\\n            if(i==0 && tight)\\n                count+=digitDp(pos+1,visited,dp,n,true);\\n            else if(visited[i]==\\'0\\'){\\n                visited[i]=\\'1\\';\\n                count+=digitDp(pos+1,visited,dp,n,false);\\n                visited[i]=\\'0\\';\\n            }\\n        } \\n        return dp[pos][visited]=count;\\n            \\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n         unordered_map<int,unordered_map<string,int>> dp; // pos,visited,count\\n        //tight parameter is for handling cases like 0031,0002,00.. these numbers won\\'t be counted if tight isn\\'t used \\n        string visited=\"0000000000\";\\n        int ans=digitDp(0,visited,dp,n,true); // if tight\\'s true then we consider our current number has only zeros till pos-1 so we still have an option to choose zero after pos\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700854,
                "title": "python3-math-solution-count-numbers-with-unique-digits",
                "content": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if not n: return 1\\n        ans, start = 10, 9\\n        for i in range(1, min(10, n)):\\n            start *= (10 - i)\\n            ans += start\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if not n: return 1\\n        ans, start = 10, 9\\n        for i in range(1, min(10, n)):\\n            start *= (10 - i)\\n            ans += start\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508367,
                "title": "deatiled-easy-understand-fastest-solution-beats-100-0-ms-dp-c",
                "content": "# Intuition\\nCalculate all possible combinations with intially 9 digits and for all values of n store it in the dp table\\n\\n# Approach\\nKeeping the base case dp[0] = 0; as for 0 we can have only digit as unique;\\n\\nWe cannot have 0 as the starting digit in any of the numbers\\nso initially we can have 9 digits out of then and then we will have 9 digits , then 8 digits and so on .\\n\\nFor example , if start with 1 then i can combine 2,3,4,5,6,7,8,9,0 with 1 as 12 13 14 15 16 17 18 19 10.\\n\\n\\nThis way I have 9 options to combine with 9 numbers (1,2,3,4,5,6,7,8,9) .\\n\\nThen for n = 3 \\nif start with 17 i can i combine it with all the other digits excluding 1 and 7 i,e with 2,3,4,5,6,8,9 so i have 8 options and so on ..\\n\\n# Complexity\\n- Time complexity:\\nO(n * n) --> O(1) as the maximum value of n is 8\\n- Space complexity:\\nO(9) --> O(1) for storing all possible answers\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0)\\n            return 1;\\n        vector<int> dp(9);\\n        dp[0] = 1;\\n        vector<int> temp = {9, 9, 8, 7, 6, 5, 4, 3, 2, 1};\\n        for(int i = 1; i <= n; i++)\\n        {\\n            dp[i] = dp[i - 1];\\n            int prod = 1;\\n            for(int j = 0; j < i; j++)\\n                prod = prod * temp[j];\\n            dp[i] += prod; \\n        }\\n        return dp[n]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0)\\n            return 1;\\n        vector<int> dp(9);\\n        dp[0] = 1;\\n        vector<int> temp = {9, 9, 8, 7, 6, 5, 4, 3, 2, 1};\\n        for(int i = 1; i <= n; i++)\\n        {\\n            dp[i] = dp[i - 1];\\n            int prod = 1;\\n            for(int j = 0; j < i; j++)\\n                prod = prod * temp[j];\\n            dp[i] += prod; \\n        }\\n        return dp[n]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146694,
                "title": "very-simple-maths-c",
                "content": "# Intuition\\nArrangements of digits\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        if(n==0) return 1;\\n        vector<int> dp(n+1);\\n        dp[0]=1;\\n        dp[1]=10;\\n        int p=9;\\n        int i=9;\\n        for(int x=2; x<=n; x++)\\n        {\\n            p*=i;\\n            dp[x]=dp[x-1]+p;\\n            i--;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        if(n==0) return 1;\\n        vector<int> dp(n+1);\\n        dp[0]=1;\\n        dp[1]=10;\\n        int p=9;\\n        int i=9;\\n        for(int x=2; x<=n; x++)\\n        {\\n            p*=i;\\n            dp[x]=dp[x-1]+p;\\n            i--;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012058,
                "title": "python-o-1-solution-both-math-dp-explained",
                "content": "n = 2\\nFrom 11 -> 20 => 11,22,33,..99 excluded. \\nso ans = 10(for 1->10) + 9*9(as 1 element excluded in each 10 range). = 10 + 81 = 91\\n\\nn = 3\\nfor 1 -> 100 => ans = 91\\nFrom 101 -> 200 => (100,101), (110,112,113...119), (121,122),..(191,199) excluded.\\nans(100, 199) = 8*9\\nFrom 201 -> 300 => (200,202), (211,212), (220,221,222...229),..(292,299) excluded.\\nans(200, 299) = 8*9\\n.\\n.\\nans(100, 1000) = 8*9*9\\nTotal ans = 10 + 8*9*9 = 739\\n\\nSo Pattern = ans + 9*(11-i) ans i = [2,n]\\n\\n```python\\n# Math \\n\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        if n == 0: return 1\\n        if n == 1: return 10\\n        \\n        ans = 10\\n        tmp = 9\\n        for i in range(2, n+1):\\n            tmp *= (11 - i)\\n            ans += tmp\\n            \\n        return ans\\n```\\n\\n```python\\n# Dynamic Programming\\n\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        dp = [1, 10]\\n        for i in range(2, n+1):\\n            tmp = 81\\n            for j in range(1, i-1):\\n                tmp *= (9 - j)\\n            ans = dp[i-1] + tmp\\n            dp.append(ans)\\n        \\n        return dp[n]\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```python\\n# Math \\n\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        if n == 0: return 1\\n        if n == 1: return 10\\n        \\n        ans = 10\\n        tmp = 9\\n        for i in range(2, n+1):\\n            tmp *= (11 - i)\\n            ans += tmp\\n            \\n        return ans\\n```\n```python\\n# Dynamic Programming\\n\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        dp = [1, 10]\\n        for i in range(2, n+1):\\n            tmp = 81\\n            for j in range(1, i-1):\\n                tmp *= (9 - j)\\n            ans = dp[i-1] + tmp\\n            dp.append(ans)\\n        \\n        return dp[n]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609586,
                "title": "scam-solution-python-o-1",
                "content": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n==0:\\n            return 1\\n        elif n == 1 :\\n            return 10\\n        elif n == 2 :\\n            return 91\\n        elif n== 3:\\n            return 739\\n        elif n == 4 :\\n            return 5275\\n        elif n==5 :\\n            return 32491\\n        elif n==6:\\n            return 168571\\n        elif n==7 :\\n            return 712891\\n        else :\\n            return 2345851\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n==0:\\n            return 1\\n        elif n == 1 :\\n            return 10\\n        elif n == 2 :\\n            return 91\\n        elif n== 3:\\n            return 739\\n        elif n == 4 :\\n            return 5275\\n        elif n==5 :\\n            return 32491\\n        elif n==6:\\n            return 168571\\n        elif n==7 :\\n            return 712891\\n        else :\\n            return 2345851\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528511,
                "title": "python-simple-solution-permutation",
                "content": "\\tdef countNumbersWithUniqueDigits(self, n: int) -> int:\\n        ans = 1\\n        temp = 1\\n        for i in range(1,n+1):\\n            ans = 9*temp + ans\\n            temp = temp*(10-i)\\n            \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef countNumbersWithUniqueDigits(self, n: int) -> int:\\n        ans = 1\\n        temp = 1\\n        for i in range(1,n+1):\\n            ans = 9*temp + ans\\n            temp = temp*(10-i)\\n            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2403235,
                "title": "python-o-n-tc-o-1-sc-fastest-solution-simple-code",
                "content": "The efficient solution is based on combinatorics, but don\\'t worry as it\\'s very easy to understand =).\\n\\nLet\\'s look at a few examples based on different values of `n`:\\n`n = 0` => possible numbers are `[0]` => answer is `1` - this will be a degenerate case\\n`n = 1` => possible numbers are `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]` => answer is `10`\\n\\nFor every value of `n` greater than `1` the numbers will have a varying number of digits, going from 1 to `n`. Let\\'s define `f(x)` as a function that takes in the value of `n` and returns the answer to the problem, the amount of unique numbers from `[0, 10 ** n)`.\\n\\nAs an example, let\\'s assume `n = 2`. The numbers that belong to the range `[0, 10 ** 2)` can have either one or two digits. It\\'s easy to see that all the single digit numbers are the ones that were counted by `f(1)`:\\n```\\nf(2) = f(1) + len([all numbers with exactly two non-matching digits])\\n```\\nIn fact, it\\'s easy to see that a general statement is true:\\n```\\nf(n) = f(n-1) + len([all the numbers with exactly n unique digits])\\n```\\nTo count those unique digit numbers of length `n` we can use a bit of combinatorics.\\nIndeed, all the digits from `0` to `9` form a set of length 10. For the 1st digit we have `10` options to pick from, for the 2nd digit we have `9` (minus the previously picked option), and so on:\\n```\\nNumber of unique digit numbers of length n = 10! / (10 - n)! = 10 * 9 * ... * (10 - n + 1)\\n```\\nHowever, it\\'s slightly more tricky than that. Because, when we pick the 1st digit, we can\\'t really pick `0`, since prefix zeros don\\'t count and we\\'d in fact end up with a number of length `n-1`, which was already counted by `f(n-1)`. So for the 1st digit we only have nine options, however for the 2nd digit we have *nine options again* (because `0` is now allowed), for the 3rd digit eight options and so on:\\n```\\nNumber of unique digit numbers of length n = 9 * 9! / (10 - n)!\\nexcept for n = 0 and n = 1, for which we have special answers\\n```\\nThis concludes the explanation of the algo itself. Now, to implement it efficiently, we can reuse the previously calculated product of `9 * 8 * ... * (10 - n + 1)` and only grow it by performing a single multiplication by `10 - n` on the next iteration:\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        res = 1  # will be used if n = 0, equals to sum(f(i) for i in range(n))\\n        product_accum = 1  # will be used to accumulate the product of 9 * 8 * ...\\n\\n        for i in range(n):\\n            res += product_accum * 9\\n            product_accum *= (10 - i - 1)\\n        \\n        return res\\n```\\nPlease upvote this post if you found it useful \\uD83D\\uDE04",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nf(2) = f(1) + len([all numbers with exactly two non-matching digits])\\n```\n```\\nf(n) = f(n-1) + len([all the numbers with exactly n unique digits])\\n```\n```\\nNumber of unique digit numbers of length n = 10! / (10 - n)! = 10 * 9 * ... * (10 - n + 1)\\n```\n```\\nNumber of unique digit numbers of length n = 9 * 9! / (10 - n)!\\nexcept for n = 0 and n = 1, for which we have special answers\\n```\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        res = 1  # will be used if n = 0, equals to sum(f(i) for i in range(n))\\n        product_accum = 1  # will be used to accumulate the product of 9 * 8 * ...\\n\\n        for i in range(n):\\n            res += product_accum * 9\\n            product_accum *= (10 - i - 1)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001725,
                "title": "solution-using-basic-maths-explained-beats-100",
                "content": "**IDEA** basic idea behind the solution is permutations. \\n1. Ask yourself how many unique numbers we can form with a single digit number ? answer is 9 as` _` can be filled with digits 1 to 9. (0 is not valid here)\\n2. Ask yourself how many unique numbers we can form with a two digit number ? answer is 81. two digit number like ` _ _ ` - first place can be filled with 9 digits(1-9) and second place can also be filled with 9 digits(including 0 this time and excluding the digit used previously) , so `9*9=81`\\n3. Ask yourself how many unique numbers we can form with a three digit number ? answer is 648. three digit number like `_ _ _ ` - first place can be filled with 9 digits(1-9) and second place can also be filled with 9 digits(including 0 this time and excluding the digit used previously) and third place can be filled with 8 digits (0-9 excluding the last two digits used), so `9*9*8=648`\\n\\ni hope you can see the pattern here. we can clearly see that with 4 digits, we will have `9*9*8*7` total unique numbers.\\n```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n       \\n\\t   int[] counts = new int[n+1];\\n        counts[0]=1; // only 0\\n        counts[1]=9; // digits 1-9\\n        int multiplier=9;\\n        for(int i=2;i<=n;i++){\\n            counts[i]=counts[i-1]*multiplier; // counts[2]=9*9 / counts[3]=9*9*8 / counts[4]=9*9*8*7 and so on\\n            multiplier--;\\n        }\\n        \\n        int res=0; // now we gotta add em all up(one digit, two digit...nth digit unique numbers) and return\\n        for(int i:counts)\\n            res+=i;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n       \\n\\t   int[] counts = new int[n+1];\\n        counts[0]=1; // only 0\\n        counts[1]=9; // digits 1-9\\n        int multiplier=9;\\n        for(int i=2;i<=n;i++){\\n            counts[i]=counts[i-1]*multiplier; // counts[2]=9*9 / counts[3]=9*9*8 / counts[4]=9*9*8*7 and so on\\n            multiplier--;\\n        }\\n        \\n        int res=0; // now we gotta add em all up(one digit, two digit...nth digit unique numbers) and return\\n        for(int i:counts)\\n            res+=i;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701638,
                "title": "c-recursive-solution",
                "content": "* **F** is a flag variable for recursion to know whether number made till now has leading zeroes beacuse if it has leading zeroes it means we can use zero at ith index otherwise we can\\'t . Dis is a kind of visited array made using nits , it states if jth bit is set means jth digit is already used.And recursion is called for next index.\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\t\\n\\tint rec(int i,int n,int dis,int f)\\n    {\\n        if(i>n)\\n            return 1;\\n        \\n        int cnt=0;\\n        for(int j=0;j<=9;j++)\\n        {\\n            if((1<<j) & dis)\\n                continue;\\n            if(i==1 && j==0)\\n            {\\n                cnt+=rec(i+1,n,dis,1);\\n            }\\n            else if(f==1 && j==0)\\n                cnt+=rec(i+1,n,dis,f);\\n            else\\n            cnt+=rec(i+1,n,dis | (1<<j),0);\\n        }\\n        \\n        return cnt;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        return rec(1,n,0,0);\\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\t\\n\\tint rec(int i,int n,int dis,int f)\\n    {\\n        if(i>n)\\n            return 1;\\n        \\n        int cnt=0;\\n        for(int j=0;j<=9;j++)\\n        {\\n            if((1<<j) & dis)\\n                continue;\\n            if(i==1 && j==0)\\n            {\\n                cnt+=rec(i+1,n,dis,1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1691130,
                "title": "c-maths-p-c-0-ms-faster-than-100-00",
                "content": "*Please **upvote** if you find it helpful :)*\\n```\\nclass Solution {\\npublic:\\n    int totalUnique(int n) {\\n        if(n==1)\\n            return 10;\\n        int ans=9,k=9;\\n        for(int i=2;i<=n;i++) {\\n            ans*=k;\\n            k--;\\n        }\\n        return ans;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        int sum = 0;\\n        for(int i=1;i<=n;i++) {\\n            sum += totalUnique(i);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalUnique(int n) {\\n        if(n==1)\\n            return 10;\\n        int ans=9,k=9;\\n        for(int i=2;i<=n;i++) {\\n            ans*=k;\\n            k--;\\n        }\\n        return ans;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        int sum = 0;\\n        for(int i=1;i<=n;i++) {\\n            sum += totalUnique(i);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354910,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        int res=10,temp=9;\\n        for(int i=2;i<=n;++i){\\n            temp=temp*(11-i);   \\n            res+=temp;\\n        }    \\n     return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        int res=10,temp=9;\\n        for(int i=2;i<=n;++i){\\n            temp=temp*(11-i);   \\n            res+=temp;\\n        }    \\n     return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309489,
                "title": "dp-top-down-approach",
                "content": "\\n\\t\\t// THE possibilties of a 3 digit number with all digitis unique is 9*9*8\\n\\t\\t// for 4 digits it is 9*9*8*7  .. for 5 digit 9*9*8*7*6 and so on .. construct a dp table by using this logic//\\n        int countNumbersWithUniqueDigits(int n) {\\n      if(n ==1){return 10;}\\n        if(n ==0){return 1;}\\n        if(n ==2){return 91;}\\n        vector<int>dp(n-1);\\n        dp[0] =91;\\n        int x = 81 , y= 8;\\n        for(int i=1;i<=n-2;i++){\\n              x = x*y;\\n            dp[i] = dp[i-1] +x;\\n            y--;\\n                \\n            \\n        }\\n        return dp[n-2];\\n        \\n        \\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "\\n\\t\\t// THE possibilties of a 3 digit number with all digitis unique is 9*9*8\\n\\t\\t// for 4 digits it is 9*9*8*7  .. for 5 digit 9*9*8*7*6 and so on .. construct a dp table by using this logic//\\n        int countNumbersWithUniqueDigits(int n) {\\n      if(n ==1){return 10;}\\n        if(n ==0){return 1;}\\n        if(n ==2){return 91;}\\n        vector<int>dp(n-1);\\n        dp[0] =91;\\n        int x = 81 , y= 8;\\n        for(int i=1;i<=n-2;i++){\\n              x = x*y;\\n            dp[i] = dp[i-1] +x;\\n            y--;\\n                \\n            \\n        }\\n        return dp[n-2];\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1277883,
                "title": "c-dynamic-programming-o-n-space-time-100-faster-than-other-c",
                "content": "Explaination:\\ndp for this question can be traced trying out some example\\nf(0) = 1;\\nf(1) = 10;\\nf(2)= 91;\\n\\nf(3) = (10 -3 + 1)* f(2) + f(1) + f(0);\\nf(4) = (10-4+1)*f(3) + f(2) + f(1)+f(0);\\n\\n\\nsimilarly f(i) = (10 - i + 1) * f(i-1) + f(i-2)..............+f(0);\\nbelow is the implementation:\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 10;\\n        \\n        vector<int> dp(9,0);\\n            int sum = 1;\\n        dp[0]= 1;\\n        dp[1] = 10;\\n            \\n            for(int i =2;i<=n;i++)\\n            {\\n                dp[i] = (10-i+1)*dp[i-1] + sum;\\n                sum+=dp[i-1];\\n            }\\n      return dp[n];  \\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 10;\\n        \\n        vector<int> dp(9,0);\\n            int sum = 1;\\n        dp[0]= 1;\\n        dp[1] = 10;\\n            \\n            for(int i =2;i<=n;i++)\\n            {\\n                dp[i] = (10-i+1)*dp[i-1] + sum;\\n                sum+=dp[i-1];\\n            }\\n      return dp[n];  \\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131381,
                "title": "python-solution-using-combinations",
                "content": "Here we can choose prev = 9, because we have 9 choices for first place from the left beacause we do not use 0 at first place e.g 01, 02, 03, 04, etc. and ans = 10 because if we have only 1 digit then we have 10 choices.\\nWe have 9 choices for the first place and 9 choices for the second place beacause if we use any no from (1,9) then we have 9 choices left, E.g if we choose 1 then we have choices (0, 2, 3, 4, 5, 6, 7, 8, 9).\\nAfterwards, choices are decreasing at every level like 9 x 9 x 8 x 7 x 6 x ........ and so on.  \\n\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:        \\n        prev, ans = 9, 10\\n        for i in range(1, n):\\n            prev *= 10-i\\n            ans += prev\\n        \\n        return ans if n else 1\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:        \\n        prev, ans = 9, 10\\n        for i in range(1, n):\\n            prev *= 10-i\\n            ans += prev\\n        \\n        return ans if n else 1\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001549,
                "title": "java-very-easy-0ms-faster-than-100-o-1-time-and-space-7-lines-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countNumbersWithUniqueDigits(int n) {\\n\\t\\t\\tif(n==0)    return 1;\\n\\t\\t\\tint ans=10,t=9;\\n\\t\\t\\tfor(int i=0;i<n-1;i++){\\n\\t\\t\\t\\tt*=(9-i);\\n\\t\\t\\t\\tans+=t;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int countNumbersWithUniqueDigits(int n) {\\n\\t\\t\\tif(n==0)    return 1;\\n\\t\\t\\tint ans=10,t=9;\\n\\t\\t\\tfor(int i=0;i<n-1;i++){\\n\\t\\t\\t\\tt*=(9-i);\\n\\t\\t\\t\\tans+=t;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 993375,
                "title": "python-only-simple-math-pattern",
                "content": "```\\n# Written by : Dhruv Vavliya\\ndef cnwud(n):\\n    if n==0:\\n        return 1\\n    if n==1:\\n        return 10\\n\\n    ans = 10\\n\\ttemp =9\\n\\tfor i in range(2,n+1):\\n\\t\\ttemp *=(11-i)\\n\\t\\tans+=temp\\n    return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\n# Written by : Dhruv Vavliya\\ndef cnwud(n):\\n    if n==0:\\n        return 1\\n    if n==1:\\n        return 10\\n\\n    ans = 10\\n\\ttemp =9\\n\\tfor i in range(2,n+1):\\n\\t\\ttemp *=(11-i)\\n\\t\\tans+=temp\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 292916,
                "title": "python3-dp-with-explanation",
                "content": "This question is how to change the 0 to the number[0-9]\\n2 situation:\\n1. first is 0\\n\\tthis situation is same as n - 1\\n2. first not 0\\n\\tfirst select 1 - 9 -----> have 9 ways (10 - 1)\\n\\tsecond select 0 - 9 exclude first -------> have 9 ways (10 - 1)\\n\\tthen select 0-9 exclude first and second ----------> 10 - 2\\n\\tuntil all the 0 fixed with 0 - 9\\n\\t\\n\\t\\n\\t\\n\\tn = 0     |    just 0       |  1\\n\\tn = 1     |    0            |   10 (select from 0 - 9 )\\n\\tn = 2     |    00           |   10 + 9 * 9 (1 situation: if first 0 fixed with 0, this is same as n - 1. 2 situation: first select from 1-9 ,then 0 - 9 exclude first ,then the rest ..... \\n\\tn = 3     |    000          | 10 + 9 * 9 + 9 * 9 * 8\\n\\n```python3\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n         dp = [1, 10]\\n         for i in range(2, n+1):\\n             res = 81\\n             for j in range(1, i-1):\\n                 res = res * (9 - j)\\n             dp.append(dp[i - 1] + res)\\n        \\n         return dp[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python3\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n         dp = [1, 10]\\n         for i in range(2, n+1):\\n             res = 81\\n             for j in range(1, i-1):\\n                 res = res * (9 - j)\\n             dp.append(dp[i - 1] + res)\\n        \\n         return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209719,
                "title": "python-backtracking",
                "content": "```\\nclass Solution(object):    \\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        self.counter = 0\\n        self.n = n\\n        ran = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return len(ran)\\n        self.helper(n, ran, [])\\n        return self.counter + 10\\n\\n    def helper(self, n, r, c):\\n        if len(c) > 1 and c[0] != 0:\\n            self.counter += 1\\n        if n == 0:\\n            return\\n        for j in range(len(r)):\\n            self.helper(n-1, r[:j]+r[j+1:], c+[r[j]])\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):    \\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        self.counter = 0\\n        self.n = n\\n        ran = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return len(ran)\\n        self.helper(n, ran, [])\\n        return self.counter + 10\\n\\n    def helper(self, n, r, c):\\n        if len(c) > 1 and c[0] != 0:\\n            self.counter += 1\\n        if n == 0:\\n            return\\n        for j in range(len(r)):\\n            self.helper(n-1, r[:j]+r[j+1:], c+[r[j]])\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 207792,
                "title": "java-9-lines-beats-100-with-explanation",
                "content": "1. if n = 0, then return 1 = 1;\\n2. if n = 1, then return 1 + 9 = 10;\\n3. if n = 2, then return 1 + 9 + (9 * 8 + 9 * 1) = 91;\\n4. So we can use the mathematical way of arranging combinations. if the length of number is n, then we can get two case:\\n\\ta. the number does not include char \\'0\\'\\uFF0Ctotal number of combinations is \\n\\t\\t ----A(9, n) = 9 * \\xB7\\xB7\\xB7 * (9 - n + 1);\\n\\tb. the number includes char \\'0\\', total number of combinations is \\n\\t\\t----A(9, n - 1) * (n - 1) = 9 * \\xB7\\xB7\\xB7 * (9 - n + 2) * (n - 1);\\n\\tso the total of two case is 9 * A(9, n - 1).\\n5. So we can get the transfer equation\\uFF0Cdp[i] = dp[i - 1] + 9 * A(9, n - 1).\\n```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            int product = 9;\\n            for (int j = 0; j < i - 1; j++) {\\n                product *= (9 - j);\\n            }\\n            dp[i] = dp[i - 1] + product;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            int product = 9;\\n            for (int j = 0; j < i - 1; j++) {\\n                product *= (9 - j);\\n            }\\n            dp[i] = dp[i - 1] + product;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83122,
                "title": "python-solution-with-explanation-in-comment",
                "content": "```\\n    def countNumbersWithUniqueDigits(self, n):\\n        # n can not be greater than 10 as it must exist two of the digit share same number\\n        # f(n) = 1-digits unique num combination + 2-digits unique num combination + ...\\n        # f(n) = 10 + 9 * 9 + 9 * 9 * 8 + ...\\n        # f(n) = g(0) + g(1) + g(2) + ... + g(n)\\n        # g(0) = 10\\n        # g(1) = 9 * 9\\n        # g(2) = 9 * 9 * 8\\n        # g(k) = 9 * (10 - 1) * (10 - 2) * ... * (10 - k)\\n        if n == 0: return 1\\n        if n == 1: return 10\\n        n = min(10, n)\\n        res = 10\\n        for n in range(1, n):\\n            g = 9\\n            for i in range(1, n+1):\\n                g *= (10 - i)\\n            res += g\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def countNumbersWithUniqueDigits(self, n):\\n        # n can not be greater than 10 as it must exist two of the digit share same number\\n        # f(n) = 1-digits unique num combination + 2-digits unique num combination + ...\\n        # f(n) = 10 + 9 * 9 + 9 * 9 * 8 + ...\\n        # f(n) = g(0) + g(1) + g(2) + ... + g(n)\\n        # g(0) = 10\\n        # g(1) = 9 * 9\\n        # g(2) = 9 * 9 * 8\\n        # g(k) = 9 * (10 - 1) * (10 - 2) * ... * (10 - k)\\n        if n == 0: return 1\\n        if n == 1: return 10\\n        n = min(10, n)\\n        res = 10\\n        for n in range(1, n):\\n            g = 9\\n            for i in range(1, n+1):\\n                g *= (10 - i)\\n            res += g\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 83146,
                "title": "simple-c-recursive-solution-using-combinatorics",
                "content": "**Idea:** \\n\\nWithin range [1 ... 10), there are totally 9 numbers with unique digits.\\n\\nWithin range [10 ... 100), there are totally 9 * 9 numbers with unique digits.\\n\\nWithin range [100 ... 1000), there are totally 9 * 9 * 8 numbers with unique digits.\\n\\n\\n**Pattern:**\\n\\nWithin range [10^(n-1) ... 10^n) where n>=2, there are totally 9 * (9 - 0) * (9 - 1) * (9 - 2) ... * (9 - (n - 2)) numbers with unique digits\\n\\n    // top-down recursive\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0)\\n            return 1;\\n    \\n        int sum = 9;\\n        for (int i = 0; i <= n - 2; ++i)\\n            sum *= (9 - i);\\n        \\n        return sum + countNumbersWithUniqueDigits(n - 1);\\n    }\\n\\n    // bottom-up DP\\n    int countNumbersWithUniqueDigits(int n) {\\n        vector<int> dp (n + 1);\\n        dp[0] = 1;\\n        dp[1] = 10;\\n\\n        for (int i = 2; i <= n; ++i)\\n        {\\n            int sum = 9;\\n            for (int j = 0; j <= i - 2; ++j)\\n                sum *= (9 - j);\\n            dp[i] = sum + dp[i - 1];\\n        }       \\n        return dp[n];\\n    }",
                "solutionTags": [],
                "code": "**Idea:** \\n\\nWithin range [1 ... 10), there are totally 9 numbers with unique digits.\\n\\nWithin range [10 ... 100), there are totally 9 * 9 numbers with unique digits.\\n\\nWithin range [100 ... 1000), there are totally 9 * 9 * 8 numbers with unique digits.\\n\\n\\n**Pattern:**\\n\\nWithin range [10^(n-1) ... 10^n) where n>=2, there are totally 9 * (9 - 0) * (9 - 1) * (9 - 2) ... * (9 - (n - 2)) numbers with unique digits\\n\\n    // top-down recursive\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0)\\n            return 1;\\n    \\n        int sum = 9;\\n        for (int i = 0; i <= n - 2; ++i)\\n            sum *= (9 - i);\\n        \\n        return sum + countNumbersWithUniqueDigits(n - 1);\\n    }\\n\\n    // bottom-up DP\\n    int countNumbersWithUniqueDigits(int n) {\\n        vector<int> dp (n + 1);\\n        dp[0] = 1;\\n        dp[1] = 10;\\n\\n        for (int i = 2; i <= n; ++i)\\n        {\\n            int sum = 9;\\n            for (int j = 0; j <= i - 2; ++j)\\n                sum *= (9 - j);\\n            dp[i] = sum + dp[i - 1];\\n        }       \\n        return dp[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 83148,
                "title": "combination-java-solution",
                "content": "    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)    return 1;\\n        int total = 10;\\n        while(n>1){\\n            int r=9;\\n            for(int i=1;i<n;i++)\\n                r*=10-i;\\n            total+=r;\\n            n--;\\n        }\\n        return total;\\n    }",
                "solutionTags": [],
                "code": "    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)    return 1;\\n        int total = 10;\\n        while(n>1){\\n            int r=9;\\n            for(int i=1;i<n;i++)\\n                r*=10-i;\\n            total+=r;\\n            n--;\\n        }\\n        return total;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3559666,
                "title": "357-count-numbers-with-unique-digits-java",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        int sta=9,cur=9,ans=10;\\n        while(sta>0&&n>1)\\n        {\\n            cur*=sta;\\n            sta--;\\n            ans+=cur;\\n            n--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        int sta=9,cur=9,ans=10;\\n        while(sta>0&&n>1)\\n        {\\n            cur*=sta;\\n            sta--;\\n            ans+=cur;\\n            n--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957098,
                "title": "java-100-faster-solution",
                "content": "# Approach\\nI noted the following pattern when took a pen and paper.\\n\\n1. n = 0 => 1\\n2. n = 1 => 10. Since 10 unique numbers 0-9.\\n3. n = 2 => 9 * 9 + 10 => 91. Since first num can be 1-9, second num can be 0-9, but except one. And plus previuos unique nums.\\n4. n = 3 => 9 * 9 * 8 + 91 = 648 + 91 = 739 and so on.\\n\\nAnd I used static array as a cache for optimization purposes.\\n\\n# Code\\n```\\nclass Solution {\\n    static int[] res;\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (res == null) initArray();\\n        return res[n];\\n    }\\n\\n    private static void initArray() {\\n        res = new int[9];\\n        res[0] = 1;\\n        res[1] = 10;\\n        for (int i = 2; i < res.length; i++) {\\n            int mult = 9;\\n            for (int j = 9; j > 9 - i + 1; j--) {\\n                mult *= j;\\n            }\\n            res[i] = mult + res[i - 1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[] res;\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (res == null) initArray();\\n        return res[n];\\n    }\\n\\n    private static void initArray() {\\n        res = new int[9];\\n        res[0] = 1;\\n        res[1] = 10;\\n        for (int i = 2; i < res.length; i++) {\\n            int mult = 9;\\n            for (int j = 9; j > 9 - i + 1; j--) {\\n                mult *= j;\\n            }\\n            res[i] = mult + res[i - 1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956193,
                "title": "max-test-case-n-is-8-then-o-1-would-work",
                "content": "Have fun :)\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countNumbersWithUniqueDigits = function(n) {\\n    return [1,10,91,739,5275,32491,168571,712891,2345851][n]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countNumbersWithUniqueDigits = function(n) {\\n    return [1,10,91,739,5275,32491,168571,712891,2345851][n]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2860452,
                "title": "cheating-java-solution-0ms-100-fast",
                "content": "```\\nclass Solution \\n{\\n    \\n    public int countNumbersWithUniqueDigits(int n) \\n    {\\n      if(n==0)\\n          return 1;\\n        int a1=10;\\n        int a2=9*9;\\n        int a3=a2*8;\\n        int a4=a3*7;\\n        int a5=a4*6;\\n        int a6=a5*5;\\n        int a7=a6*4;\\n        int a8=a7*3;\\n        int a9=a8*2;\\n        int arr[]={a1,a2,a3,a4,a5,a6,a7,a8,a9};\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           sum+=arr[i]; \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution \\n{\\n    \\n    public int countNumbersWithUniqueDigits(int n) \\n    {\\n      if(n==0)\\n          return 1;\\n        int a1=10;\\n        int a2=9*9;\\n        int a3=a2*8;\\n        int a4=a3*7;\\n        int a5=a4*6;\\n        int a6=a5*5;\\n        int a7=a6*4;\\n        int a8=a7*3;\\n        int a9=a8*2;\\n        int arr[]={a1,a2,a3,a4,a5,a6,a7,a8,a9};\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           sum+=arr[i]; \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763119,
                "title": "100-simple-loop-one-line-c",
                "content": "**\\nafter 2 digits it\\'s just (10-number of digits used) to be added at the end\\nEX-\\n\\tif u got a 2 digit number 12\\n\\tYou can add digits 3,4,5.......9,0 at end to create new 3 digit number \\n**\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        if(n==2) return 91;\\n        \\n        int count=91,digits=81;\\n        \\n        for(int i=3;i<=n;i++){\\n            count+=(digits*=(10-i+1));\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        if(n==2) return 91;\\n        \\n        int count=91,digits=81;\\n        \\n        for(int i=3;i<=n;i++){\\n            count+=(digits*=(10-i+1));\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726133,
                "title": "java-0-1-100-bettter-runtime-solution",
                "content": "java solution without using extra space:\\n\\nclass Solution {\\n\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0)return 1;\\n        int count = 0;\\n        int prev2 = 1;\\n        int prev1 = 10;\\n        int freq = 9;\\n        for(int i=2; i<=n; i++){\\n            int temp = prev1;\\n            prev1 = prev1+(prev1 - prev2)*freq;\\n            prev2 = temp;\\n            freq--;\\n        }\\n        return prev1;\\n    }\\n}\\nplz upvote if u like it->",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0)return 1;\\n        int count = 0;\\n        int prev2 = 1;\\n        int prev1 = 10;\\n        int freq = 9;\\n        for(int i=2; i<=n; i++){\\n            int temp = prev1;\\n            prev1 = prev1+(prev1 - prev2)*freq;\\n            prev2 = temp;\\n            freq--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2684811,
                "title": "faster-than-100-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n==0)\\n            return 1;\\n        \\n        int p=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i==1||i==2)\\n                p=p*9;\\n            else\\n                p=p*(9+2-i);\\n        }\\n        int ans=p+countNumbersWithUniqueDigits(n-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n==0)\\n            return 1;\\n        \\n        int p=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i==1||i==2)\\n                p=p*9;\\n            else\\n                p=p*(9+2-i);\\n        }\\n        int ans=p+countNumbersWithUniqueDigits(n-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424333,
                "title": "faster-than-100-cpp-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        long long int ans=10;\\n        \\n        for(int i=2;i<=n;i++){\\n            long long int ct=9,t=i-1,j=9;\\n            while(t--){\\n                ct*=j;\\n                j--;\\n            }\\n            ans+=ct;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        long long int ans=10;\\n        \\n        for(int i=2;i<=n;i++){\\n            long long int ct=9,t=i-1,j=9;\\n            while(t--){\\n                ct*=j;\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2121045,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 10;\\n        int ans=9;\\n        int d=9;\\n        int k=n-1;\\n        while(k--)\\n        {\\n            ans*=d;\\n            d--;\\n        }\\n        return ans + countNumbersWithUniqueDigits(n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 10;\\n        int ans=9;\\n        int d=9;\\n        int k=n-1;\\n        while(k--)\\n        {\\n            ans*=d;\\n            d--;\\n        }\\n        return ans + countNumbersWithUniqueDigits(n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962969,
                "title": "count-numbers-with-unique-digits-c-0ms-100-faster-easy-to-understand",
                "content": "This question is quite simple if you know some basic maths topic \\'Permutations\\' and basic dp\\nIn this question we have to find out the 10^n unqiue digits generate, break this question as\\nwe have to find the solution for \\n**10^1 + 10^2  +  10^3 +  ....., +  10^n;**\\nthat\\'s it. Your questions is solve HaHa\\nBut here come a part how we solve **10^2, 10^3**, or so on\\n**For that you can convert the question as you have to find out the permutation generated having 10 different digits(0, 1, 2, 3, ... , 9) without repetation.**\\ne.g:\\nSo for three digits number we have  (_ _ _ ) three different positon and for first position i.e unit digit we have 10 options and for second digits we have 9 options and for third digit we have 8 and so on..  so this process gives a total number generated into 10^3 with repetation but their is edge case we can\\'t fix zero at the last position. \\nTo solve this edge case we simply find out the numbers of permutation generated when we fix the last position i.e (0, _ , _) after that we have only 9 option for unit digit and 8 option of the second digit and so on..\\nand to get the answer we substract the **(totat number generated without repeation - total number generated with fixing the last postion with zero)**\\n\\n```\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans = 1;\\n        for(int i  = 1; i<=n; i++)\\n        {\\n            // first find the number which is generated by 0-9\\n            int ctn = 1;\\n            int temp = i;\\n            for(int j = 10; temp!=0; j--)\\n            {\\n                ctn*=j;\\n                temp--;\\n            }\\n            // number which is genrated when we fix 0 at the last position\\n            temp = i-1;\\n            int ctn2 = 1;\\n            for(int j = 9; temp!=0; j--)\\n            {\\n                ctn2*=j;\\n                temp--;\\n            }\\n            ans+=(ctn - ctn2);\\n        }\\n\\t\\t\\treturn ans;```\\n\\n}\\n\\nIf you able to understand the solution hit the upvote button",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans = 1;\\n        for(int i  = 1; i<=n; i++)\\n        {\\n            // first find the number which is generated by 0-9\\n            int ctn = 1;\\n            int temp = i;\\n            for(int j = 10; temp!=0; j--)\\n            {\\n                ctn*=j;\\n                temp--;\\n            }\\n            // number which is genrated when we fix 0 at the last position\\n            temp = i-1;\\n            int ctn2 = 1;\\n            for(int j = 9; temp!=0; j--)\\n            {\\n                ctn2*=j;\\n                temp--;\\n            }\\n            ans+=(ctn - ctn2);\\n        }\\n\\t\\t\\treturn ans;```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753716,
                "title": "0-ms-faster-than-100-00-c",
                "content": "1. n = 1\\nall possible numbers are 0 to 9, the answer will be 10  \\n\\n2. n = 4, consider our number is look like \"ABCD\"\\n\\tthere are 9 choices for digit A (since the first digit cannot be 0)\\n\\tthere are 9 choices for B (since it should be different from A, but we may use 0)\\n\\tthe same way for C are 8 choices and 7 choices for D\\n\\n\\tSo in total there are 9\\u22179\\u22178\\u22177=4536  possible numbers.\\n\\nI calculate all possible combinations for each number of digits (starting from 1 to n) and sum them together\\n\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0)\\n            return 1;\\n        \\n        int sum = 10;\\n        int curr = 9;\\n        int count = 9;\\n        \\n        while(n > 1)\\n        {\\n            curr *= count--;\\n            sum += curr;\\n            n--;\\n        } \\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0)\\n            return 1;\\n        \\n        int sum = 10;\\n        int curr = 9;\\n        int count = 9;\\n        \\n        while(n > 1)\\n        {\\n            curr *= count--;\\n            sum += curr;\\n            n--;\\n        } \\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739148,
                "title": "super-simple-python-solution-with-explanation",
                "content": "```py\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n\\n        ans, choices, k = 10, 9, 9\\n\\n        for m in range(2, n + 1):\\n            choices *= k\\n            ans += choices\\n            k -= 1\\n\\n        return ans\\n```\\n\\nThe problem is just simple combinatorics. It\\'s basic counting with the only slight modification being that the first digit cannot be a zero, except for 1 digit numbers where the number of choices is 10.\\n\\nSo for the first digit we have 9 choices (1-9), for the second we have 9 choices again (0-9 excluding the first digit choice), for the third we have 8 choices and so on.\\n\\nWe need to compute the number of choices for an `m` digit number for all `m` from 1 to `n` and return their sum as the result.\\n\\nHowever, the number of choices for an `m + 1` digit number builds up on the number of choices for an `m` digit number so we can store the previous result to speed things up.",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```py\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n\\n        ans, choices, k = 10, 9, 9\\n\\n        for m in range(2, n + 1):\\n            choices *= k\\n            ans += choices\\n            k -= 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701861,
                "title": "easiest-c-solution-simple-maths-0ms-explained",
                "content": "This problem is a simple Permutaions and COmbinations sum. We know that from 0-9 there are 10 numbers with unique digits. When n>1 we can calcualte the numbers with unique digits through this :\\n![image](https://assets.leetcode.com/users/images/e6da6106-dcc0-41cb-85a8-6f165c3e0b62_1642584666.9986122.jpeg)\\n\\nOnce we get the factorials, We just keep finding the sum.\\n\\n```\\nclass Solution {\\npublic:\\n    int count(int n)\\n    {\\n        int ans=1,k=9;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans*=k;\\n            if(i!=1)\\n                k--;\\n        }\\n        return ans;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 10;\\n        int ans=10;\\n        for(int i=2;i<=n;i++)        \\n            ans+=count(i);\\n        return ans;        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(int n)\\n    {\\n        int ans=1,k=9;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans*=k;\\n            if(i!=1)\\n                k--;\\n        }\\n        return ans;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 10;\\n        int ans=10;\\n        for(int i=2;i<=n;i++)        \\n            ans+=count(i);\\n        return ans;        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665664,
                "title": "c-clean-solution-recursive-to-dp-optimal-solution",
                "content": "**\\uD83D\\uDE4FPlease Upvote\\uD83D\\uDE4F**\\n- Solution approach explanation link [CLICK HERE](https://hjweds.gitbooks.io/leetcode/content/count-numbers-with-unique-digits.html)\\n<br>\\n**RECURSIVE APPROACH**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isDuplicate(int n){\\n        unordered_set<int> digits;\\n        while(n>0){\\n            int d = n%10;\\n            if(digits.find(d) != digits.end()){\\n                return true;\\n            }\\n            digits.insert(d);\\n            n = n/10;\\n        }\\n        \\n        return false;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        if(n==1)return 10;\\n        \\n        n = pow(10,n);\\n        int countDuplicate = 0;\\n        for(int i=0; i<n; ++i){\\n            if(isDuplicate(i)){\\n                countDuplicate++;\\n            }\\n        }\\n        return ((n - countDuplicate));\\n    }\\n};\\n```\\n\\n**DP SOLUTION**\\n- Space :O(n)\\n```\\nclass Solution {\\npublic:\\n    int countNumberHelper(int n){\\n        int ans = 9;// first postion 9 choices always\\n        int choices = 9;// second position 9 choices always\\n\\n        for(int pos = 2; pos<=n; ++pos){\\n            ans = ans * choices;\\n            choices--;\\n        }\\n        \\n        return ans;\\n    }\\n   \\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        int totalNumbersOfZeroChoices = 1;\\n        int totalNumbersOfTenChoices = 10;\\n        vector<int> computedNumbers(n+1, 0);\\n        \\n        // base case\\n        computedNumbers[0] = totalNumbersOfZeroChoices;\\n        computedNumbers[1] = totalNumbersOfTenChoices;\\n        \\n        for(int i=2; i<=n; ++i){\\n            computedNumbers[i] = computedNumbers[i-1] + countNumberHelper(i);\\n        } \\n        return computedNumbers[n];\\n    }\\n};\\n```\\n\\n**DP SOLUTION**\\n- Space: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int countNumberHelper(int n){\\n        int ans = 9;// first postion 9 choices always\\n        int choices = 9;// second position 9 choices always\\n\\n        for(int pos = 2; pos<=n; ++pos){\\n            ans = ans * choices;\\n            choices--;\\n        }\\n        \\n        return ans;\\n    }\\n   \\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        int totalNumbersOfZeroChoices = 1;\\n        int totalNumbersOfTenChoices = 10;\\n        \\n        // case for n==1\\n        int prevComputedNumbers = totalNumbersOfTenChoices; \\n        \\n        for(int i=2; i<=n; ++i){\\n            prevComputedNumbers = prevComputedNumbers + countNumberHelper(i);\\n        } \\n        \\n        return prevComputedNumbers;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isDuplicate(int n){\\n        unordered_set<int> digits;\\n        while(n>0){\\n            int d = n%10;\\n            if(digits.find(d) != digits.end()){\\n                return true;\\n            }\\n            digits.insert(d);\\n            n = n/10;\\n        }\\n        \\n        return false;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        if(n==1)return 10;\\n        \\n        n = pow(10,n);\\n        int countDuplicate = 0;\\n        for(int i=0; i<n; ++i){\\n            if(isDuplicate(i)){\\n                countDuplicate++;\\n            }\\n        }\\n        return ((n - countDuplicate));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNumberHelper(int n){\\n        int ans = 9;// first postion 9 choices always\\n        int choices = 9;// second position 9 choices always\\n\\n        for(int pos = 2; pos<=n; ++pos){\\n            ans = ans * choices;\\n            choices--;\\n        }\\n        \\n        return ans;\\n    }\\n   \\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        int totalNumbersOfZeroChoices = 1;\\n        int totalNumbersOfTenChoices = 10;\\n        vector<int> computedNumbers(n+1, 0);\\n        \\n        // base case\\n        computedNumbers[0] = totalNumbersOfZeroChoices;\\n        computedNumbers[1] = totalNumbersOfTenChoices;\\n        \\n        for(int i=2; i<=n; ++i){\\n            computedNumbers[i] = computedNumbers[i-1] + countNumberHelper(i);\\n        } \\n        return computedNumbers[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNumberHelper(int n){\\n        int ans = 9;// first postion 9 choices always\\n        int choices = 9;// second position 9 choices always\\n\\n        for(int pos = 2; pos<=n; ++pos){\\n            ans = ans * choices;\\n            choices--;\\n        }\\n        \\n        return ans;\\n    }\\n   \\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        int totalNumbersOfZeroChoices = 1;\\n        int totalNumbersOfTenChoices = 10;\\n        \\n        // case for n==1\\n        int prevComputedNumbers = totalNumbersOfTenChoices; \\n        \\n        for(int i=2; i<=n; ++i){\\n            prevComputedNumbers = prevComputedNumbers + countNumberHelper(i);\\n        } \\n        \\n        return prevComputedNumbers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663543,
                "title": "cpp-mathematical-explanation",
                "content": "the trick is that suppose u need to from number of 4 digit with all being unique \\n\\n\\t1.   for the first digit u have 9 choices (1<=choice_1<=9) (0 is not included ,coz any 4 digit number starting with zero will be considered as 3 digit coz 0\\'s at front don\\'t add any value for example like [0345==345])\\n\\t\\n\\t2.   for the second digit u still have 9 choices (0<=choice_2<=9 and choice_2!=choice_1) ( except for the previously choosen digit all others can come and no ambiguity for 0 here coz [90!=9] as trailing zero\\'s before decimal is important)\\n\\n\\t3.   for the third digit u  have 8 choices (0<=choice_3<=9 and choice_3!=choice_1 and choice_3!=choice_2) ( except for the previously chosen digits all others can come )\\n\\n\\t4.   *similar explanation to 3rd now u have 7 choices*\\n\\nso in short all_unique _four digits_numbers(4)=9x9x8x7 \\n\\nbut in this question we need to tell numbers till n digits which means \\n```\\n\\ncountNumbersWithUniqueDigits(n) = all_unique _ digits_numbers(n) + all_unique _ digits_numbers(n-1) + all_unique _ digits_numbers(n-2) + ..........+  all_unique _ digits_numbers(1) +1\\n\\n```\\n+1 because our algo will never consider 0 at most significant digit but just 0 is a valid case so include that\\n\\nnow below is the code for general (n) digits num\\n\\n\\n\\n```\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans=0;\\n        while(n){\\n            int t=(n--),start=9,nans=0;\\n            while(t--){\\n                if(nans==0)nans=9;\\n                else nans*=(start--);\\n            }\\n            ans+=nans;\\n        }\\n        \\n        return ans+1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\n\\ncountNumbersWithUniqueDigits(n) = all_unique _ digits_numbers(n) + all_unique _ digits_numbers(n-1) + all_unique _ digits_numbers(n-2) + ..........+  all_unique _ digits_numbers(1) +1\\n\\n```\n```\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans=0;\\n        while(n){\\n            int t=(n--),start=9,nans=0;\\n            while(t--){\\n                if(nans==0)nans=9;\\n                else nans*=(start--);\\n            }\\n            ans+=nans;\\n        }\\n        \\n        return ans+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527995,
                "title": "java-easy-with-explaination",
                "content": "![image](https://assets.leetcode.com/users/images/ae18fb1b-f882-43a3-af38-e144e5957baf_1634559536.799327.png)\\n\\n```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        \\n        if(n==1){\\n            return 10;\\n        }else{\\n            //calculating for n digit number\\n            int current=9;\\n            int temp=9;\\n            for(int i=1;i<n;i++){\\n                current*=temp;\\n                temp--;\\n            }\\n            return current+countNumbersWithUniqueDigits(n-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        \\n        if(n==1){\\n            return 10;\\n        }else{\\n            //calculating for n digit number\\n            int current=9;\\n            int temp=9;\\n            for(int i=1;i<n;i++){\\n                current*=temp;\\n                temp--;\\n            }\\n            return current+countNumbersWithUniqueDigits(n-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401825,
                "title": "scala-one-liner-100",
                "content": "```\\nobject Solution {\\n    def countNumbersWithUniqueDigits(d: Int): Int = {\\n        if (d==0) return 1\\n        1.to(d-1).map(10 - _).scanLeft(9)(_ * _).reduce(_ + _) + 1\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def countNumbersWithUniqueDigits(d: Int): Int = {\\n        if (d==0) return 1\\n        1.to(d-1).map(10 - _).scanLeft(9)(_ * _).reduce(_ + _) + 1\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1392244,
                "title": "0-ms-100-faster-solution",
                "content": "* if (n>10) it is impossible to have all digits unique\\n* f(1) =10 ,i.e, all numbers from 0 to 9\\n* f(2) =f(1) + 9*9 (as first digit can be anything between 1 and 9, 2nd digit anything between 0 and 9 except first digit)\\n* f(3)= f(2) +9*(9)*8 (as first digit can be anything between 1 and 9, 2nd digit anything between 0 and 9 except first digit, 3rd digit anything between 0 and 9 except 1st and 2nd digit)\\n* therfeore f(n)=f(n-1)+9*(9*8*....(10-i+1))\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n>10)\\n            return 0;\\n        int dp[11],x=9;\\n        dp[0]=1;dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            x*=(10-i+1);\\n            dp[i]=dp[i-1]+x;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n>10)\\n            return 0;\\n        int dp[11],x=9;\\n        dp[0]=1;dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            x*=(10-i+1);\\n            dp[i]=dp[i-1]+x;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343206,
                "title": "faster-than-100-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        //9 * 9 + 10 for n = 2\\n        //9 * 9 * 8 + 10 for n = 3\\n        //9 * 9 * 8 * 7 + 10 for n = 4\\n        //9 * 9 * 8 * 7 * 6 + 10 for n = 5\\n        \\n        int ans = 10;\\n        if(n == 0){\\n            return 1;\\n        }else if(n == 1){\\n            return 10;\\n        }else{\\n            int product = 9;\\n            for(int i = 2; i <= n; i++){\\n                product = product * (11 - i);\\n                ans += product;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        //9 * 9 + 10 for n = 2\\n        //9 * 9 * 8 + 10 for n = 3\\n        //9 * 9 * 8 * 7 + 10 for n = 4\\n        //9 * 9 * 8 * 7 * 6 + 10 for n = 5\\n        \\n        int ans = 10;\\n        if(n == 0){\\n            return 1;\\n        }else if(n == 1){\\n            return 10;\\n        }else{\\n            int product = 9;\\n            for(int i = 2; i <= n; i++){\\n                product = product * (11 - i);\\n                ans += product;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324440,
                "title": "for-better-visualization-i-made-all-the-cases",
                "content": "class Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 10;\\n        }\\n        if(n==2){\\n            return 91;\\n        }\\n        if(n==3){\\n            return 9*9*8 + 91;\\n        }\\n        if(n==4){\\n            return 9*9*8*7 + 9*9*8 + 91;\\n        }\\n        if(n==5){\\n            return 9*9*8*7*6 + 9*9*8*7 + 9*9*8 + 91;\\n        }\\n        if(n==6){\\n            return 9*9*8*7*6*5+ 9*9*8*7*6 + 9*9*8*7 + 9*9*8 + 91;            \\n        }\\n        if(n==7){\\n            return 9*9*8*7*6*5*4 + 9*9*8*7*6*5+ 9*9*8*7*6 + 9*9*8*7 + 9*9*8 + 91;               \\n        }\\n        if(n==8){\\n            return 9*9*8*7*6*5*4*3 + 9*9*8*7*6*5*4 + 9*9*8*7*6*5+ 9*9*8*7*6 + 9*9*8*7 + 9*9*8 + 91;\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1102403,
                "title": "java-easy-to-understand-solution-with-comments",
                "content": "I Was having tough time to understand any solution, after spending lot of time I got to know about the soultion.\\nHear is my approach:\\n\\n```\\n    public static int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        if (n > 10) return countNumbersWithUniqueDigits(10);\\n//        Now calculate the possible ways a number can be formed with n digits.\\n        int poss = 9, count = 1;\\n        for (int digit = 0; digit < n; digit++) {\\n//            You start with 9 possibilities (0 cannot be placed, because 01 is not a number with 2 digit it is number with 1 digit),\\n//              After get the number of possibilities you can place a number, you need to keep reducing a possibility,\\n//              because the number that was used in in current position should not be used again.\\n            if (digit == 0) count *= 9;\\n            else count *= poss--;\\n//            Other key thing to consider, is that first digit and second digit can have 9, possibilities.\\n//              Because 0 is not a valid number for first digit,\\n//              But 0 is a valid number for all digits after 1 to n.\\n        }\\n        System.out.println(\"Count at \" + n + \" digits is : \" + count);\\n//        Now, count will have the number of ways to form n digit, add that to number of ways we can form an (n-1)  digit.\\n        return count + countNumbersWithUniqueDigits(n - 1);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public static int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        if (n > 10) return countNumbersWithUniqueDigits(10);\\n//        Now calculate the possible ways a number can be formed with n digits.\\n        int poss = 9, count = 1;\\n        for (int digit = 0; digit < n; digit++) {\\n//            You start with 9 possibilities (0 cannot be placed, because 01 is not a number with 2 digit it is number with 1 digit),\\n//              After get the number of possibilities you can place a number, you need to keep reducing a possibility,\\n//              because the number that was used in in current position should not be used again.\\n            if (digit == 0) count *= 9;\\n            else count *= poss--;\\n//            Other key thing to consider, is that first digit and second digit can have 9, possibilities.\\n//              Because 0 is not a valid number for first digit,\\n//              But 0 is a valid number for all digits after 1 to n.\\n        }\\n        System.out.println(\"Count at \" + n + \" digits is : \" + count);\\n//        Now, count will have the number of ways to form n digit, add that to number of ways we can form an (n-1)  digit.\\n        return count + countNumbersWithUniqueDigits(n - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1063446,
                "title": "basic-maths-solution-o-1-space-and-time",
                "content": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        \\n        # Use basic permutation\\n        # for 0 <= x < 10 : Nos. with unique digits = 9\\n        # for 10 <= x < 100 : Nos. with unique digits = 9 x 9\\n        # for 100 <= x < 1000 : Nos. with unique digits = 9 x 9 x 8\\n        # for 1000 <= x < 10000 : Nos. with unique digits = 9 x 9 x 8 x 7\\n        # for 10000 <= x < 100000 : Nos. with unique digits = 9 x 9 x 8 x 7 x 6\\n        # for 100000 <= x < 1000000 : Nos. with unique digits = 9 x 9 x 8 x 7 x 6 x 5\\n        \\n        # And so on ...\\n        # Then add all the values and make the following dictionary\\n\\t\\t\\n\\t\\t# While calculating 0 <= x < 10 the case of n = 0 is already covered in it so no need to add n = 0 when adding all other values\\n            \\n        dic = {\\n            0 : 1,\\n            1 : 10,\\n            2 : 91,\\n            3 : 739,\\n            4 : 5275,\\n            5 : 32491,\\n            6 : 168571,\\n            7 : 712891,\\n            8 : 2345851\\n        }\\n        \\n        return dic[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        \\n        # Use basic permutation\\n        # for 0 <= x < 10 : Nos. with unique digits = 9\\n        # for 10 <= x < 100 : Nos. with unique digits = 9 x 9\\n        # for 100 <= x < 1000 : Nos. with unique digits = 9 x 9 x 8\\n        # for 1000 <= x < 10000 : Nos. with unique digits = 9 x 9 x 8 x 7\\n        # for 10000 <= x < 100000 : Nos. with unique digits = 9 x 9 x 8 x 7 x 6\\n        # for 100000 <= x < 1000000 : Nos. with unique digits = 9 x 9 x 8 x 7 x 6 x 5\\n        \\n        # And so on ...\\n        # Then add all the values and make the following dictionary\\n\\t\\t\\n\\t\\t# While calculating 0 <= x < 10 the case of n = 0 is already covered in it so no need to add n = 0 when adding all other values\\n            \\n        dic = {\\n            0 : 1,\\n            1 : 10,\\n            2 : 91,\\n            3 : 739,\\n            4 : 5275,\\n            5 : 32491,\\n            6 : 168571,\\n            7 : 712891,\\n            8 : 2345851\\n        }\\n        \\n        return dic[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995001,
                "title": "100-faster-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    //its a permutation problem we all solved in our schools\\n    //here we need all the unique digit number \\n    // the idea is to store the unique digit numbers for that size of digits\\n    // the first digit of a say 3 digit number can not be 0\\n    // so for filling first didgit of three digit number we havve 9 options\\n    //for the second digit also we have 9 options to fill it as 0 is now included\\n    // for the third digit we have only 8 options to fill as we can not use same digit twice\\n    int dp[];\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n>9) n=8;\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        dp= new int[n+1];\\n        dp[0]=1;\\n        dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            int prod=1;\\n            int counter=9;\\n            for(int j=i;j>1;j--){\\n                prod = prod*counter;\\n                counter--;\\n            }\\n            prod= 9*prod;\\n            dp[i]=dp[i-1]+prod;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //its a permutation problem we all solved in our schools\\n    //here we need all the unique digit number \\n    // the idea is to store the unique digit numbers for that size of digits\\n    // the first digit of a say 3 digit number can not be 0\\n    // so for filling first didgit of three digit number we havve 9 options\\n    //for the second digit also we have 9 options to fill it as 0 is now included\\n    // for the third digit we have only 8 options to fill as we can not use same digit twice\\n    int dp[];\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n>9) n=8;\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        dp= new int[n+1];\\n        dp[0]=1;\\n        dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            int prod=1;\\n            int counter=9;\\n            for(int j=i;j>1;j--){\\n                prod = prod*counter;\\n                counter--;\\n            }\\n            prod= 9*prod;\\n            dp[i]=dp[i-1]+prod;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 658564,
                "title": "most-detailed-explanation-c-100-time-space",
                "content": "**Problem Solution Approach**\\n \\n*  If number of digits is 0, then unique numbers that can be formed is 0\\n*  If number of digits is 1, then unique numbers that can be formed is 10 ->  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\n*  If number of digits is 2,\\n   Then for the first digit (from left), we have 9 choices (excluding 0) [1 to 9]\\n   And for second digit we have 9 choices (0 to 10 except the previous digit) \\n   So basically, the number is:\\n   ij where i=[1,9] and j=[0,9]and i\\u2260j\\n   So, total number possible are 9*9=81\\n*  If number of digits is 3,\\n   Then for first digit (from left), we have 9 choices (excluding 0) [1 to 9]\\n   And for second digit we have 9 choices (0 to 10 except the previous digit)\\n  And for third digit we have 8 choices (0 to 10 except the previous two digits)\\n  So basically, the number is:\\n  ijk where i=[1,9] and j,k=[0,9]and i\\u2260j & j\\u2260k,i\\n  So, total number possible are 9*9*8=648\\n* So, if number of digits is i, then the ith digit will have (10-i+1) choices\\n\\n**Implementation**\\n```\\nint countNumbersWithUniqueDigits(int n)\\n{\\n    //base cases\\n    if (n == 0)\\n        return 0;\\n    if (n == 1)\\n        return 10;\\n    if (n == 2)\\n        return 91;\\n\\n    //base value\\n    long long int DP[n + 1];\\n    DP[0] = 0;\\n    DP[1] = 10;\\n    DP[2] = 81;\\n    long long int res = 91;\\n\\n    for (int i = 3; i <= n; i++) {\\n        //compute f(i)\\n        DP[i] = DP[i - 1] * (10 - i + 1);\\n        res += DP[i]; //add f(i)\\n    }\\n    //result\\n    return res;\\n}\\n```\\n[References]\\n(https://www.includehelp.com/icp/count-numbers-with-unique-digits.aspx)",
                "solutionTags": [],
                "code": "```\\nint countNumbersWithUniqueDigits(int n)\\n{\\n    //base cases\\n    if (n == 0)\\n        return 0;\\n    if (n == 1)\\n        return 10;\\n    if (n == 2)\\n        return 91;\\n\\n    //base value\\n    long long int DP[n + 1];\\n    DP[0] = 0;\\n    DP[1] = 10;\\n    DP[2] = 81;\\n    long long int res = 91;\\n\\n    for (int i = 3; i <= n; i++) {\\n        //compute f(i)\\n        DP[i] = DP[i - 1] * (10 - i + 1);\\n        res += DP[i]; //add f(i)\\n    }\\n    //result\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 616503,
                "title": "javascript-easy-understand-dynamic-programming-solution",
                "content": "```js\\n/*\\n * @lc app=leetcode id=357 lang=javascript\\n *\\n * [357] Count Numbers with Unique Digits\\n */\\n\\n// @lc code=start\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countNumbersWithUniqueDigits = function(n) {\\n    var dp = [1, 10];\\n    var sum = [1, 11];\\n    for (var i = 2; i <= n; i++) {\\n        dp[i] = sum[i - 1] + (10 - i) * (dp[i - 1]);\\n        sum[i] = sum[i - 1] + dp[i];\\n    }\\n    return dp[n];\\n};\\n// @lc code=end\\n\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```js\\n/*\\n * @lc app=leetcode id=357 lang=javascript\\n *\\n * [357] Count Numbers with Unique Digits\\n */\\n\\n// @lc code=start\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countNumbersWithUniqueDigits = function(n) {\\n    var dp = [1, 10];\\n    var sum = [1, 11];\\n    for (var i = 2; i <= n; i++) {\\n        dp[i] = sum[i - 1] + (10 - i) * (dp[i - 1]);\\n        sum[i] = sum[i - 1] + dp[i];\\n    }\\n    return dp[n];\\n};\\n// @lc code=end\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612428,
                "title": "c-o-1",
                "content": "There is one thing we should know, since the integer has unique digits, so, the number has at most **10 digits**, so n is at most 10, so, the running time of algorithm is O(1).\\n```\\nclass Solution {\\npublic:\\n    \\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        if(n == 0)\\n            return 1;\\n\\t\\t\\t\\n        int res = 10, tmp = 9;\\n        for(int i = 1; i < n; i++)\\n            res += (tmp *= (10 - i));\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        if(n == 0)\\n            return 1;\\n\\t\\t\\t\\n        int res = 10, tmp = 9;\\n        for(int i = 1; i < n; i++)\\n            res += (tmp *= (10 - i));\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281367,
                "title": "java-o-1-clean-solution-beat-100",
                "content": "\\n\\'\\'\\'\\n\\n    public int countNumbersWithUniqueDigits(int n) {\\n\\t  \\n        if (n == 0) return 1;\\n\\t\\t\\n        int uniqueDigits = 9;\\n        int res = 10;\\n        int digitNumber = 1;\\n        \\n        while(digitNumber<n){\\n            uniqueDigits = uniqueDigits*(10-digitNumber);\\n            res += uniqueDigits;\\n            digitNumber++;\\n        }\\n        return res;\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\n\\n    public int countNumbersWithUniqueDigits(int n) {\\n\\t  \\n        if (n == 0) return 1;\\n\\t\\t\\n        int uniqueDigits = 9;\\n        int res = 10;\\n        int digitNumber = 1;\\n        \\n        while(digitNumber<n){\\n            uniqueDigits = uniqueDigits*(10-digitNumber);\\n            res += uniqueDigits;\\n            digitNumber++;\\n        }\\n        return res;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 262907,
                "title": "java-iterative-solution",
                "content": "```java\\nclass Solution {\\n    \\n    // Let F(n) be count of numbers with unique digits such that 0 <= x < 10^n\\n    \\n    // n = 0\\n    // numbers = 0\\n    // F(n) = 1\\n    \\n    // n = 1\\n    // numbers = 0 1 2 ... 9\\n    // F(n) = 10\\n    \\n    // n = 2, \\n    // numbers = 0 1 2 ..9 ... 98\\n    // For each of the number other than 0 from n = 1, we append a differnt number, also add number from n = 2\\n    // F(n) = F(n-1) + 9 * 9\\n    \\n    // n = 3\\n    // F(n) = F(n-1) + 9 * 9 * 8\\n    \\n    // n = 4\\n    // F(n) = F(n-1) + 9*9*8*...*(10-n + 1)\\n    \\n    \\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        \\n        if (n == 1) {\\n            return 10;\\n        }\\n        \\n        if (n > 10) {\\n            n = 10;\\n        }\\n        int answer = 10;\\n        int product = 9;\\n        for (int i = 2; i <= n; i++) {\\n            product = product * (10 - i + 1);\\n            answer = answer + product;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    // Let F(n) be count of numbers with unique digits such that 0 <= x < 10^n\\n    \\n    // n = 0\\n    // numbers = 0\\n    // F(n) = 1\\n    \\n    // n = 1\\n    // numbers = 0 1 2 ... 9\\n    // F(n) = 10\\n    \\n    // n = 2, \\n    // numbers = 0 1 2 ..9 ... 98\\n    // For each of the number other than 0 from n = 1, we append a differnt number, also add number from n = 2\\n    // F(n) = F(n-1) + 9 * 9\\n    \\n    // n = 3\\n    // F(n) = F(n-1) + 9 * 9 * 8\\n    \\n    // n = 4\\n    // F(n) = F(n-1) + 9*9*8*...*(10-n + 1)\\n    \\n    \\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        \\n        if (n == 1) {\\n            return 10;\\n        }\\n        \\n        if (n > 10) {\\n            n = 10;\\n        }\\n        int answer = 10;\\n        int product = 9;\\n        for (int i = 2; i <= n; i++) {\\n            product = product * (10 - i + 1);\\n            answer = answer + product;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190630,
                "title": "why-my-solution-is-not-the-fastest",
                "content": "as we can know, when the lengthen of an integer is larger than 10, the num must have at least two locations who have the same digit,so the total posibilities is  finite,then we can list all the posibilitise in a list,while the list is:\n[1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691]\nif the n is larger than 10,then we only return the last element in the list;\nelse get the corresponding element.\nthe time complexity is o(1), very very small,but why this solution takes 32 ms ,too slow.\n```\nclass Solution:\n    def countNumbersWithUniqueDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        results = [1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691]\n        if n >= 11:\n            return results[-1]\n        return results[n]\n\n```\n",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def countNumbersWithUniqueDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        results = [1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691]\n        if n >= 11:\n            return results[-1]\n        return results[n]\n\n```",
                "codeTag": "Java"
            },
            {
                "id": 83067,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Count Numbers with Unique Digits** https://leetcode.com/problems/count-numbers-with-unique-digits/?tab=Description\\n\\n**Brute Force**\\n* Brute force will be to generate each number and test whether it has unique digits or not.\\n* Boundary Condition: What happens when n is more than 10? Unique numbers are limited to the case of n = 10.\\n* Split the problem in this view. Say N = 4. 0<=x<=9999. \\n* This means that: [0, 1 to 9, 10 to 99, 100 to 999, 1000 to 9999].\\n* Now implement backtracking for each of these ranges and keep adding to count.\\n```\\nclass Solution(object):\\n    def helper(self, i, dedup, n):\\n        if i == n:\\n            return 1\\n        else:\\n            count = 0\\n            start = 1 if i == 0 else 0\\n            for x in range(start,10):\\n                if x not in dedup:\\n                    dedup.add(x)\\n                    count = count + self.helper(i+1, dedup, n)\\n                    dedup.remove(x)\\n        return count\\n    \\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for j in range(0, n+1):\\n            count = count + self.helper(0, set([]), j)\\n        return count\\n```\\n\\n**Dynamic Programming**\\n* Next you can improve backtracking by dynamic programming. Assume you want to know all unique digit numbers from 100 to 999. First place can take 9 (1 to 9). Second place can take 9 (0 to 9 but not what we took in first place). Last place can take only 8.\\nhttps://goo.gl/photos/oLz3dmPimXBgWWsDA\\n\\nExample: n=4\\n* n = 1  temp = 9\\n* n = 2  temp = 9 * 9\\n* n=3 temp = 9 * 9 * 8\\n* n=4 temp = 9 * 9 * 8 * 7\\n\\n```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        soln, temp, factor = 1, 1, 9\\n        for i in range(n):\\n            temp = temp * factor\\n            soln = soln + temp\\n            factor = factor-1 if i!=0 else factor\\n        return soln\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, i, dedup, n):\\n        if i == n:\\n            return 1\\n        else:\\n            count = 0\\n            start = 1 if i == 0 else 0\\n            for x in range(start,10):\\n                if x not in dedup:\\n                    dedup.add(x)\\n                    count = count + self.helper(i+1, dedup, n)\\n                    dedup.remove(x)\\n        return count\\n    \\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for j in range(0, n+1):\\n            count = count + self.helper(0, set([]), j)\\n        return count\\n```\n```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        soln, temp, factor = 1, 1, 9\\n        for i in range(n):\\n            temp = temp * factor\\n            soln = soln + temp\\n            factor = factor-1 if i!=0 else factor\\n        return soln\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83108,
                "title": "super-short-simple-c-0ms-solution",
                "content": "```\\nint countNumbersWithUniqueDigits(int n)\\n{\\n  if (n<1) return 1;\\n  // For single digit, we have 10 numbers with unique digits\\n  int totalUnique = 10;\\n  //After first digit, the choice for first digit is only 9 digits,\\n  int prevMultiplier = 9;\\n  for (int i = 1; i < n; i++)\\n  {\\n    prevMultiplier *= (10-i);\\n    totalUnique += prevMultiplier;\\n  }\\n  return totalUnique;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint countNumbersWithUniqueDigits(int n)\\n{\\n  if (n<1) return 1;\\n  // For single digit, we have 10 numbers with unique digits\\n  int totalUnique = 10;\\n  //After first digit, the choice for first digit is only 9 digits,\\n  int prevMultiplier = 9;\\n  for (int i = 1; i < n; i++)\\n  {\\n    prevMultiplier *= (10-i);\\n    totalUnique += prevMultiplier;\\n  }\\n  return totalUnique;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 83139,
                "title": "my-simple-c-math-solution-nothing-fancy",
                "content": "    class Solution {\\n    public:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        if(n==1)return 10;\\n        if(n==2)return 91;\\n        \\n        int base=81, count=91;\\n        for(int i=3; i <=min(10,n); i++){\\n            base=base * (10-i+1);\\n            count+=base;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        if(n==1)return 10;\\n        if(n==2)return 91;\\n        \\n        int base=81, count=91;\\n        for(int i=3; i <=min(10,n); i++){\\n            base=base * (10-i+1);\\n            count+=base;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 83159,
                "title": "dp-python-solution",
                "content": "    def countNumbersWithUniqueDigits(self, n):\\n        if not n:\\n            return 1\\n        dp = [0]*(n)\\n        dp[0] = 9\\n        for i in range(1,n):\\n            dp[i] = dp[i-1]*(10-i)\\n        return sum(dp)+1\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    def countNumbersWithUniqueDigits(self, n):\\n        if not n:\\n            return 1\\n        dp = [0]*(n)\\n        dp[0] = 9\\n        for i in range(1,n):\\n            dp[i] = dp[i-1]*(10-i)\\n        return sum(dp)+1\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"",
                "codeTag": "Python3"
            },
            {
                "id": 83176,
                "title": "java-concise-dp-solution",
                "content": "        \\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        } \\n        int ret = 10, count = 9;\\n        for (int i = 2; i <= n; i++) {\\n            count *= 9-i+2;\\n            ret += count;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "        \\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        } \\n        int ret = 10, count = 9;\\n        for (int i = 2; i <= n; i++) {\\n            count *= 9-i+2;\\n            ret += count;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 83179,
                "title": "dp-solution-using-hint",
                "content": "\\n    class Solution {\\n    public:\\n    \\tint countNumbersWithUniqueDigits(int n) {\\n    \\t\\tvector<int> f(11, 0);\\n    \\t\\tfor (int k = 1; k <= 10; ++k) {\\n    \\t\\t\\tif (k == 1)\\n    \\t\\t\\t\\tf[k] = 10;\\n    \\t\\t\\telse if (k == 2)\\n    \\t\\t\\t\\tf[k] = 9 * 9;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tf[k] = f[k - 1] * (9 - k + 2);\\n    \\t\\t}\\n    \\t\\tvector<int> s(11, 0);\\n    \\t\\tfor (int j = 1; j < 11; ++j)\\n    \\t\\t\\ts[j] = s[j - 1] + f[j];\\n    \\t\\tif (n <= 0) return 1;\\n    \\t\\tif (n >= 1 && n <= 10) return s[n];\\n    \\t\\treturn s[10];\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n    \\tint countNumbersWithUniqueDigits(int n) {\\n    \\t\\tvector<int> f(11, 0);\\n    \\t\\tfor (int k = 1; k <= 10; ++k) {\\n    \\t\\t\\tif (k == 1)\\n    \\t\\t\\t\\tf[k] = 10;\\n    \\t\\t\\telse if (k == 2)\\n    \\t\\t\\t\\tf[k] = 9 * 9;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tf[k] = f[k - 1] * (9 - k + 2);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4014692,
                "title": "0ms-maths-rust-solution",
                "content": "# Expression\\nLet $f:\\\\mathbb{N}\\\\rightarrow\\\\mathbb{N}$, where $n\\\\in\\\\mathbb{N}$ $f(n)$ gives the count of the number with unique digits less than equals to $10^n$. Expression for $f(n)$ is,\\n\\n$$\\\\displaystyle f(n):=1+9\\\\sum_{k=1}^{\\\\min\\\\{n,9\\\\}}\\\\frac{9!}{(10-k)!}$$\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_numbers_with_unique_digits(n: i32) -> i32 {\\n        let mut fact: [i32; 10] = [1; 10];\\n\\n        for i in 0..9 {\\n            fact[i+1] = ((i+1) as i32) * fact[i];\\n        }\\n\\n        let mut total: i32 = 1;\\n\\n        for k in 1..=n {\\n            total += 9 * fact[9] / fact[(10-k) as usize];\\n        }\\n\\n        total\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_numbers_with_unique_digits(n: i32) -> i32 {\\n        let mut fact: [i32; 10] = [1; 10];\\n\\n        for i in 0..9 {\\n            fact[i+1] = ((i+1) as i32) * fact[i];\\n        }\\n\\n        let mut total: i32 = 1;\\n\\n        for k in 1..=n {\\n            total += 9 * fact[9] / fact[(10-k) as usize];\\n        }\\n\\n        total\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985886,
                "title": "python-backtracking-slow-but-mine",
                "content": "\\n\\n# Approach\\nUse backtracking and search for all possible results and increment count whenever we find the legal number.\\nTip : look out for numbers involving 0\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        self.count = 0\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return 10\\n        \\n        searchSpace = [0,1,2,3,4,5,6,7,8,9]\\n\\n        def backTrack(path):\\n            if len(path) <= n:\\n                if path:\\n                    if path[0] != 0:\\n                        self.count += 1\\n            else:\\n                return\\n            for num in searchSpace:\\n                if num not in path:\\n                    path.append(num)\\n                    backTrack(path)\\n                    path.pop()\\n\\n        backTrack([])\\n        return self.count + 1\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        self.count = 0\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return 10\\n        \\n        searchSpace = [0,1,2,3,4,5,6,7,8,9]\\n\\n        def backTrack(path):\\n            if len(path) <= n:\\n                if path:\\n                    if path[0] != 0:\\n                        self.count += 1\\n            else:\\n                return\\n            for num in searchSpace:\\n                if num not in path:\\n                    path.append(num)\\n                    backTrack(path)\\n                    path.pop()\\n\\n        backTrack([])\\n        return self.count + 1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362293,
                "title": "simple-using-permutation-mathematics-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        int count=10;\\n        for(int i=2 ;i<=n ;i++){\\n           int ch=i-1;\\n           int y=9;\\n           int u=9;\\n           while(ch>0){\\n               y=y*u;\\n               ch--;\\n               u--;\\n           }\\n           count+=y;\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        int count=10;\\n        for(int i=2 ;i<=n ;i++){\\n           int ch=i-1;\\n           int y=9;\\n           int u=9;\\n           while(ch>0){\\n               y=y*u;\\n               ch--;\\n               u--;\\n           }\\n           count+=y;\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266788,
                "title": "100-faster-then-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n == 0)\\n           return 1;\\n\\n        int ans= 10;\\n        int start = 9;\\n        int current = 9;\\n\\n        for(int i = 2;i<=n;i++){\\n            current *= (start--);\\n            ans += current;\\n        }   \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n == 0)\\n           return 1;\\n\\n        int ans= 10;\\n        int start = 9;\\n        int current = 9;\\n\\n        for(int i = 2;i<=n;i++){\\n            current *= (start--);\\n            ans += current;\\n        }   \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201128,
                "title": "solution-with-dynamic-programming-t-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n\\n        vector<int> dp(n+1);\\n\\n        dp[0] = 1;\\n        dp[1] = 10;\\n\\n        int i = 9;\\n        int prod = 9;\\n\\n        for(int x = 2;x<=n;x++){\\n            prod *=i;\\n            dp[x] = dp[x-1]+prod;\\n            i--;\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n\\n        vector<int> dp(n+1);\\n\\n        dp[0] = 1;\\n        dp[1] = 10;\\n\\n        int i = 9;\\n        int prod = 9;\\n\\n        for(int x = 2;x<=n;x++){\\n            prod *=i;\\n            dp[x] = dp[x-1]+prod;\\n            i--;\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165079,
                "title": "simple-for-loop-with-step-by-step-explanation",
                "content": "for i=0 as 10^0 = 1 -> for 1 it has 1 number\\nfor i=1 -> 10 it has 9+1 numbers\\nfor i=2 -> 100 has (9 * 9) + 9 + 1 numbers\\nfor i=3 -> 1000 has (9 * 9 * 8) + (9 * 9) + 9 + 1 numbers\\n```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n       \\n        if(n == 0)\\n            return 1;\\n        \\n        int count = 9;\\n        int ans = 9;\\n        \\n        int prev = ans;\\n        \\n        for(int i = 2; i <= n; i++){\\n            ans += prev*count;  // prev = 9*9 * count = 8\\n            prev = prev*count;\\n            count--;\\n        } \\n        \\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n       \\n        if(n == 0)\\n            return 1;\\n        \\n        int count = 9;\\n        int ans = 9;\\n        \\n        int prev = ans;\\n        \\n        for(int i = 2; i <= n; i++){\\n            ans += prev*count;  // prev = 9*9 * count = 8\\n            prev = prev*count;\\n            count--;\\n        } \\n        \\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030269,
                "title": "python-solution-easy-to-understand-no-backtracking-dp-permutation-and-combinations",
                "content": "* how many numbers will be there if n==1 that is 10 (0-9)\\n* how many numbers will be there if n==2 that is 81 but we need all numbers from 0 so that are previous result + current i.e. 81+10 = 91\\n* Now suppose we are forming a 5 digit number using permutation we have numbers from 0 to 9 to fill the place and the point to remember is we can\\'t have a duplicate entry i.e. each number can be used at most 1 time.\\n* since we can\\'t use digit 0 as first digit we have 9 entries to fill up for the first position. i.e. (1 to 9)\\n* now we have to fill the second digit which can be filled up with any digit between 0 to 9 except the number \\nwhich we\\'ve filled at first place. we have 9 entries to do the job.\\n* for third place we have 8 entries, for fourth place we have 7 and for fifth place we have 6 entries and so on.\\n* Total 5 digit number which have unique digits are:- 9\\\\*9\\\\*8\\\\*7\\\\*6.\\n* Now use the concept and built an algorithm :-)\\n\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        ans = 0\\n        if n == 0:\\n            return 1\\n        if n>=1:\\n            ans += 10\\n        while n>1:\\n            c = 9\\n            built = c\\n            for i in range(n-1):\\n                built *= c\\n                c -= 1\\n            ans += built\\n            n -= 1\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        ans = 0\\n        if n == 0:\\n            return 1\\n        if n>=1:\\n            ans += 10\\n        while n>1:\\n            c = 9\\n            built = c\\n            for i in range(n-1):\\n                built *= c\\n                c -= 1\\n            ans += built\\n            n -= 1\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755817,
                "title": "javascript-solution-with-recursion",
                "content": "```\\nconst countNumbersWithUniqueDigits = function (n) {\\n  if (n == 0) return 1;\\n  if (n == 1) return 10;\\n  let k = 9;\\n  for (let i = 0; i < n - 1; i++) {\\n    k *= (9 - i);\\n  }\\n  return k + countNumbersWithUniqueDigits(n - 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nconst countNumbersWithUniqueDigits = function (n) {\\n  if (n == 0) return 1;\\n  if (n == 1) return 10;\\n  let k = 9;\\n  for (let i = 0; i < n - 1; i++) {\\n    k *= (9 - i);\\n  }\\n  return k + countNumbersWithUniqueDigits(n - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2752980,
                "title": "c-recursion-observation-based-math-problem-full-explanation",
                "content": "```\\n/*\\nThis problem is completely based on combinatorics.\\nFor n=1, the ans is clearly all one digit no.s.\\nFor n=2, we have 9 options (exclude 0) for the first place and another 9 options for the second.\\nSo, for n=2 -> ans(1) + 9*9.\\nFor n=3, we have 9 options (exclude 0) for the place and another 9 and 8 options for the second and third place respectively.\\nSo, for n=3 -> ans(2) + 9*9*8.\\nTherefore, it goes like ans(n-1) + 9*9*8*...*(9-n+2) which can be convert by the property \\nof factorial into further simplified expression.\\n*/\\nint f(int n) {  //Calculates factorial\\n        if(n<=1) return 1;\\n        else return n*f(n-1);\\n    }\\n    int call(int n) {\\n        if(n==0) return 1;\\n        else return (call(n-1) + (9* (f(9)/f(10-n))));\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        return call(n);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\n/*\\nThis problem is completely based on combinatorics.\\nFor n=1, the ans is clearly all one digit no.s.\\nFor n=2, we have 9 options (exclude 0) for the first place and another 9 options for the second.\\nSo, for n=2 -> ans(1) + 9*9.\\nFor n=3, we have 9 options (exclude 0) for the place and another 9 and 8 options for the second and third place respectively.\\nSo, for n=3 -> ans(2) + 9*9*8.\\nTherefore, it goes like ans(n-1) + 9*9*8*...*(9-n+2) which can be convert by the property \\nof factorial into further simplified expression.\\n*/\\nint f(int n) {  //Calculates factorial\\n        if(n<=1) return 1;\\n        else return n*f(n-1);\\n    }\\n    int call(int n) {\\n        if(n==0) return 1;\\n        else return (call(n-1) + (9* (f(9)/f(10-n))));\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        return call(n);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2730443,
                "title": "my-java-solution-recursion-bottom-up-approach-beats-100-in-tc-readable-clean-code",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0) return 1;\\n        if(n == 1) return 10;\\n        \\n        int curr = 1, k = 8;\\n        for(int i = 1; i <= n; ++i) {\\n            if(i <= 2) {\\n                curr = curr * 9;\\n            }\\n            else {\\n                curr = curr * (k--);\\n            }\\n        }\\n\\n        return curr + countNumbersWithUniqueDigits(n - 1);\\n    }\\n}\\n```\\n\\n```\\nPlease up vote if you find my code helpful.\\nThanks \\uD83D\\uDC4D\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0) return 1;\\n        if(n == 1) return 10;\\n        \\n        int curr = 1, k = 8;\\n        for(int i = 1; i <= n; ++i) {\\n            if(i <= 2) {\\n                curr = curr * 9;\\n            }\\n            else {\\n                curr = curr * (k--);\\n            }\\n        }\\n\\n        return curr + countNumbersWithUniqueDigits(n - 1);\\n    }\\n}\\n```\n```\\nPlease up vote if you find my code helpful.\\nThanks \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546571,
                "title": "cpp-solution-using-maths-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n == 0) return 1;\\n        int ans = 10;\\n        int start = 9;\\n        int cur = 9;\\n        while(n-->1 and start){\\n            cur = cur * (start--);\\n            ans += cur;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n/*\\n\\nLet\\'s take exp : n = 3;\\n\\nNow for n = 0 ans would be 1 same , for n = 1 ans would be 10 How ?\\nfor n = 1 we need to check from 0 to n so it will be 10 now\\n\\nfor n = 2 there are two place _ _ , in first we have choice [1,9] and for second we have choice from [0,9] - {first choice} for 2 digits ubique number would be 9*9 and we know for n = 1 we have 10 so in totale we have 91 unique numbers.\\n\\nfor n=3 , we have _ _ _ place and in first place we have choice [1,9] means 9 for second we have 9 choice and for 3 we have 8 choice so it will be 9*9*8 , in total 1 + 9 + 9*9 + 9*9*8.\\n\\n*/",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n == 0) return 1;\\n        int ans = 10;\\n        int start = 9;\\n        int cur = 9;\\n        while(n-->1 and start){\\n            cur = cur * (start--);\\n            ans += cur;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541777,
                "title": "5-line-code",
                "content": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if(n==0):\\n            return 1\\n        s,st=10,9\\n        for i in range(0,n-1):\\n            st*=9-i\\n            s+=st\\n        return(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if(n==0):\\n            return 1\\n        s,st=10,9\\n        for i in range(0,n-1):\\n            st*=9-i\\n            s+=st\\n        return(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452906,
                "title": "python-simple-recursive-solution",
                "content": "```\\ndef countNumbersWithUniqueDigits(self, n: int) -> int:\\n\\n        def solve(n):\\n            if n == 0: return 1\\n            if n == 1: return 9\\n            if n == 2: return 81\\n            \\n            return (10 - n + 1) * solve(n - 1)\\n \\n        ans = 0 \\n        for i in range(n + 1):\\n            ans += solve(i)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef countNumbersWithUniqueDigits(self, n: int) -> int:\\n\\n        def solve(n):\\n            if n == 0: return 1\\n            if n == 1: return 9\\n            if n == 2: return 81\\n            \\n            return (10 - n + 1) * solve(n - 1)\\n \\n        ans = 0 \\n        for i in range(n + 1):\\n            ans += solve(i)\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2424195,
                "title": "c-linear-time-solution-tabulation-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n     \\n          vector<long long int>dp(n+1);\\n          if(n==0)\\n          {\\n              return 1;\\n          }\\n          if(n==1)\\n          {\\n              return 1+9;   \\n          }\\n          dp[0]=1;\\n          dp[1]=dp[0]+9;\\n        \\n          int val=9;\\n          int counter=9;\\n        \\n          for(int i=2;i<=n;i++)\\n          {\\n              dp[i]=(dp[i-1]+0LL+(val*counter));\\n              val=val*counter;\\n              counter--;\\n          }\\n          return dp[n];\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n     \\n          vector<long long int>dp(n+1);\\n          if(n==0)\\n          {\\n              return 1;\\n          }\\n          if(n==1)\\n          {\\n              return 1+9;   \\n          }\\n          dp[0]=1;\\n          dp[1]=dp[0]+9;\\n        \\n          int val=9;\\n          int counter=9;\\n        \\n          for(int i=2;i<=n;i++)\\n          {\\n              dp[i]=(dp[i-1]+0LL+(val*counter));\\n              val=val*counter;\\n              counter--;\\n          }\\n          return dp[n];\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378407,
                "title": "all-4-solutions-recursion-memoization-dynamic-programming",
                "content": "```\\n// Recursion \\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if (n==0)  return 1; \\n        int tmp =9 ; \\n        int ans = 9 ;\\n        for ( int i =1 ; i<n ; i++)\\n            ans*=tmp--; \\n        return dp[n]=ans + solve(n-1); \\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        return solve(n); \\n    }\\n};\\n\\n//Memoization\\nclass Solution {\\npublic:\\n    int dp[9]={1};\\n    int solve(int n){\\n        if ( n==0 || dp[n]!=0) return dp[n]; \\n        int tmp =9 ; \\n        int ans = 9 ;\\n        for ( int i =1 ; i<n ; i++)\\n            ans*=tmp--; \\n        return dp[n]=ans + solve(n-1); \\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        return solve(n); \\n    }\\n};\\n//Dynamic Programming\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int sum=1,c=9;\\n        vector<int> dp(n+2);\\n        dp[0]=1,dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]*c+sum;\\n            sum+=dp[i-1];\\n            c--;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Recursion \\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if (n==0)  return 1; \\n        int tmp =9 ; \\n        int ans = 9 ;\\n        for ( int i =1 ; i<n ; i++)\\n            ans*=tmp--; \\n        return dp[n]=ans + solve(n-1); \\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        return solve(n); \\n    }\\n};\\n\\n//Memoization\\nclass Solution {\\npublic:\\n    int dp[9]={1};\\n    int solve(int n){\\n        if ( n==0 || dp[n]!=0) return dp[n]; \\n        int tmp =9 ; \\n        int ans = 9 ;\\n        for ( int i =1 ; i<n ; i++)\\n            ans*=tmp--; \\n        return dp[n]=ans + solve(n-1); \\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        return solve(n); \\n    }\\n};\\n//Dynamic Programming\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int sum=1,c=9;\\n        vector<int> dp(n+2);\\n        dp[0]=1,dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]*c+sum;\\n            sum+=dp[i-1];\\n            c--;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336932,
                "title": "0-ms-faster-than-100-00-using-simple-iteration-and-permutations-logic",
                "content": "```\\n\\t/*\\n\\t\\t Consider numbers with  some length say strictly 4 e.g.  i.e. their range would be 1000-9999\\n\\t\\t consider 1st Digit is left most difit\\n\\t\\t 1st digit can take 9 possible values ( 1-9) since there are no leading 0s \\n\\t\\t 2nd digit can take 9 possible values (0-9 except the one taken in 1st digit) \\n\\t\\t 3rd digit can take 8 possible values \\n\\t\\t 4th digit can take 7 possible values \\n\\t\\t so total number of unique numbers in this range would be 9*9*8*7 \\n\\t\\t use this approach to calculate the final value in the problem statement \\n\\t\\t * \\t\\t0 -> 1 \\n\\t\\t *  1-9 -> 9\\n\\t\\t *  10-99-> 9*9 = 81\\n\\t\\t    100-999 -> 9 * 9 * 8 + 9 * 9 + 9 + 1\\n\\t\\t    1000-9999 -> 9 * 9 * 8 * 7 +  9 * 9 * 8 + 9 * 9 + 9 + 1\\n\\t\\t*/\\n\\t\\t\\n\\t\\t\\n\\t\\tint t=1;\\n\\t\\twhile(n>0){\\n\\t\\t\\tint s=9;\\n\\t\\t\\tint x=9;\\n\\t\\t\\tint k=n;\\n\\t\\t\\twhile(k>1){\\n\\t\\t\\t\\ts= s* x;\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t\\tx--;\\n\\t\\t\\t}\\n\\t\\t\\tt=t+s;\\n\\t\\t\\tn--;\\n\\t\\t}\\n\\t\\treturn t;\\n\\t }",
                "solutionTags": [],
                "code": "```\\n\\t/*\\n\\t\\t Consider numbers with  some length say strictly 4 e.g.  i.e. their range would be 1000-9999\\n\\t\\t consider 1st Digit is left most difit\\n\\t\\t 1st digit can take 9 possible values ( 1-9) since there are no leading 0s \\n\\t\\t 2nd digit can take 9 possible values (0-9 except the one taken in 1st digit) \\n\\t\\t 3rd digit can take 8 possible values \\n\\t\\t 4th digit can take 7 possible values \\n\\t\\t so total number of unique numbers in this range would be 9*9*8*7 \\n\\t\\t use this approach to calculate the final value in the problem statement \\n\\t\\t * \\t\\t0 -> 1 \\n\\t\\t *  1-9 -> 9\\n\\t\\t *  10-99-> 9*9 = 81\\n\\t\\t    100-999 -> 9 * 9 * 8 + 9 * 9 + 9 + 1\\n\\t\\t    1000-9999 -> 9 * 9 * 8 * 7 +  9 * 9 * 8 + 9 * 9 + 9 + 1\\n\\t\\t*/\\n\\t\\t\\n\\t\\t\\n\\t\\tint t=1;\\n\\t\\twhile(n>0){\\n\\t\\t\\tint s=9;\\n\\t\\t\\tint x=9;\\n\\t\\t\\tint k=n;\\n\\t\\t\\twhile(k>1){\\n\\t\\t\\t\\ts= s* x;\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t\\tx--;\\n\\t\\t\\t}\\n\\t\\t\\tt=t+s;\\n\\t\\t\\tn--;\\n\\t\\t}\\n\\t\\treturn t;\\n\\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 2316654,
                "title": "c-100-dp-math-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        vector<int> dp(n+2);\\n        dp[0]=1;\\n        dp[1]=10;\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i]=9;\\n            int k=9;\\n            int count=1;\\n            while(count<i)\\n            {\\n                dp[i]*=k;\\n                k--;\\n                count++;\\n            }\\n            dp[i]+=dp[i-1];\\n        }\\n        return dp[n];\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        vector<int> dp(n+2);\\n        dp[0]=1;\\n        dp[1]=10;\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i]=9;\\n            int k=9;\\n            int count=1;\\n            while(count<i)\\n            {\\n                dp[i]*=k;\\n                k--;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2249198,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int count=1;\\n        while(n-- > 0)\\n        {\\n            count=count*(min(9,10-n))+1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int count=1;\\n        while(n-- > 0)\\n        {\\n            count=count*(min(9,10-n))+1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139982,
                "title": "c-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][1 << 10];\\n    int solve(int pos, bool bound,  int mask, string s) {\\n        if (pos == s.length()) return 1;\\n        if (dp[pos][bound][mask] != -1) return dp[pos][bound][mask];\\n\\n        int ans = 0;\\n        int maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n        for (int digit = 0; digit <= maxDigit; digit++) {\\n            if (mask == 0 && digit == 0) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), mask, s);\\n            else if (!(mask & (1 << digit))) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), mask | (1 << digit), s);\\n        }\\n\\n        return dp[pos][bound][mask] = ans;\\n\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        // string s = to_string(pow(10, n) - 1);\\n        int num = 1;\\n        for (int i = 0; i < n; i++) num *= 10;\\n\\n        num--;\\n        string s = to_string(num);\\n        return solve(0, true, 0, s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][1 << 10];\\n    int solve(int pos, bool bound,  int mask, string s) {\\n        if (pos == s.length()) return 1;\\n        if (dp[pos][bound][mask] != -1) return dp[pos][bound][mask];\\n\\n        int ans = 0;\\n        int maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n        for (int digit = 0; digit <= maxDigit; digit++) {\\n            if (mask == 0 && digit == 0) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), mask, s);\\n            else if (!(mask & (1 << digit))) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), mask | (1 << digit), s);\\n        }\\n\\n        return dp[pos][bound][mask] = ans;\\n\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        // string s = to_string(pow(10, n) - 1);\\n        int num = 1;\\n        for (int i = 0; i < n; i++) num *= 10;\\n\\n        num--;\\n        string s = to_string(num);\\n        return solve(0, true, 0, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134770,
                "title": "java-dp-beats-1000",
                "content": "class Solution {\\n    \\n    public int fac(int nn,int i){\\n        int u=9;\\n        for(int j=1;j<=i;j++)\\n            nn=nn*(u-j);\\n        return nn;\\n    }\\n    public int countNumbersWithUniqueDigits(int n) {\\n          int[] dp=new int[9];\\n    dp[0]=1;\\n    dp[1]=10;\\n    \\n        \\n        int sum=1;\\n    for(int i=2;i<9;i++){\\n        sum=1;\\n        dp[i]=dp[i-1]+81*fac(sum,i-2);\\n    }\\n    return dp[n];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int fac(int nn,int i){\\n        int u=9;\\n        for(int j=1;j<=i;j++)\\n            nn=nn*(u-j);\\n        return nn;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2119091,
                "title": "using-maths-dp",
                "content": "Upvote if it helps :)\\n\\nGenerate 1,2,3..  n digit number using the permutation method, and add them together.\\n1 digit number (0-9) -> 10\\n2 digit number (1-9)(0-9 expect the previous one) -> 9 * 9 = 81\\n3 digit number (1-9) (0-9 unique)(0-9, unique) -> 9 * 9 * 8 = 648 \\nand so on .... \\n..\\nn digit number -> 9 * 9 * 8 * 7 * 6 * 5.....* 1  \\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        vector<int> dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i]=fun(i)+dp[i-1];\\n        }\\n        return dp[n];\\n    }\\n    int fun(int i)\\n    {\\n        int res=9;\\n        i--;\\n        int n=9;\\n        while(i--)\\n        {\\n            res*=n;\\n            n--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        vector<int> dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i]=fun(i)+dp[i-1];\\n        }\\n        return dp[n];\\n    }\\n    int fun(int i)\\n    {\\n        int res=9;\\n        i--;\\n        int n=9;\\n        while(i--)\\n        {\\n            res*=n;\\n            n--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117164,
                "title": "c-faster-than-100-using-formula",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int n){\\n\\t\\t\\t\\tint res = 1;\\n\\t\\t\\t\\tfor(int i=1; i<=n; i++){\\n\\t\\t\\t\\t\\tres = res*i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint countNumbersWithUniqueDigits(int n) {\\n\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\tfor(int i=1; i<=n; i++){\\n\\t\\t\\t\\t\\tres += (9*f(9))/f(10-i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res+1;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int n){\\n\\t\\t\\t\\tint res = 1;\\n\\t\\t\\t\\tfor(int i=1; i<=n; i++){\\n\\t\\t\\t\\t\\tres = res*i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2059209,
                "title": "c-o-1-direct-formula",
                "content": "Total count of n digit number with all unique digits=9 * 9!/(10-n)!\\nclass Solution {\\npublic:\\n    int factorial(int n){\\n        int i,p=1;\\n        for(i=1;i<=n;i++){\\n          p*=i;  \\n        }\\n        return p;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        int i,ans=0;\\n        for(i=1;i<=n;i++){\\n        ans+=(9*factorial(9)/(factorial(10-i)));\\n        }\\n        return ans+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int factorial(int n){\\n        int i,p=1;\\n        for(i=1;i<=n;i++){\\n          p*=i;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1933890,
                "title": "python3-math-solution",
                "content": "```\\n\\n@cache\\ndef fact(n):\\n    if n == 0:\\n        return 1\\n    else:\\n        return n * fact(n-1)\\n\\n@cache\\ndef P(a, b):\\n    return (int) (fact(a) / fact(a-b))\\n\\nclass Solution:    \\n        \\n    @cache\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        else:\\n            return P(10, n) - P(9, n-1) + self.countNumbersWithUniqueDigits(n-1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\n@cache\\ndef fact(n):\\n    if n == 0:\\n        return 1\\n    else:\\n        return n * fact(n-1)\\n\\n@cache\\ndef P(a, b):\\n    return (int) (fact(a) / fact(a-b))\\n\\nclass Solution:    \\n        \\n    @cache\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        else:\\n            return P(10, n) - P(9, n-1) + self.countNumbersWithUniqueDigits(n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928818,
                "title": "easy-dp-solution-time-o-n-and-space-o-1",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    \\n    int countNumbersWithUniqueDigits(int n)\\n    {\\n        int dp[9][2] = {0};\\n        dp[0][0] = 0;\\n        dp[0][1] = 1;\\n        for (int i = 1; i < 9; i++)\\n        {\\n            int x = 10 * dp[i - 1][0];\\n            int y = (i - 1) * dp[i - 1][1];\\n            dp[i][0] = x + y;\\n            dp[i][1] = pow(10, i) - pow(10, i - 1) - dp[i][0];\\n        }\\n        for (int i = 1; i < 9; i++)\\n            dp[i][1] += dp[i - 1][1];\\n        return dp[n][1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    \\n    int countNumbersWithUniqueDigits(int n)\\n    {\\n        int dp[9][2] = {0};\\n        dp[0][0] = 0;\\n        dp[0][1] = 1;\\n        for (int i = 1; i < 9; i++)\\n        {\\n            int x = 10 * dp[i - 1][0];\\n            int y = (i - 1) * dp[i - 1][1];\\n            dp[i][0] = x + y;\\n            dp[i][1] = pow(10, i) - pow(10, i - 1) - dp[i][0];\\n        }\\n        for (int i = 1; i < 9; i++)\\n            dp[i][1] += dp[i - 1][1];\\n        return dp[n][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778411,
                "title": "c-solution-100-fast-0ms-using-probability-concepts",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans=0;\\n        if(n==0)\\n            return 1;\\n        else if(n==1)\\n            return 10;\\n        else if(n==2)\\n            return 91;\\n        else\\n        {\\n            int dp[9];\\n            dp[0]=1;\\n            dp[1]=10;\\n            dp[2]=91;\\n            \\n            int cnt=0;\\n            int i,j;\\n            int co=9;\\n            for(i=3;i<=n;i++)\\n            {\\n                cnt=9;\\n                j=i-1;\\n                co=9;\\n                for(;j>=1;j--)\\n                {\\n                    cnt=cnt*co;\\n                    co--;\\n                }\\n                dp[i]=cnt+dp[i-1];\\n            }\\n            ans=dp[n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans=0;\\n        if(n==0)\\n            return 1;\\n        else if(n==1)\\n            return 10;\\n        else if(n==2)\\n            return 91;\\n        else\\n        {\\n            int dp[9];\\n            dp[0]=1;\\n            dp[1]=10;\\n            dp[2]=91;\\n            \\n            int cnt=0;\\n            int i,j;\\n            int co=9;\\n            for(i=3;i<=n;i++)\\n            {\\n                cnt=9;\\n                j=i-1;\\n                co=9;\\n                for(;j>=1;j--)\\n                {\\n                    cnt=cnt*co;\\n                    co--;\\n                }\\n                dp[i]=cnt+dp[i-1];\\n            }\\n            ans=dp[n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725620,
                "title": "java-dp-solution-explained",
                "content": "```\\n/*\\n\\tif n =1 , then we have 10 choices to fill the answer, ( 0 can be used here at the most significant place)\\n\\tbut for n = 2,3,4.... , we have only 9 choices out of 10 at the largest place , \\n\\t9 on the 2nd largest ( 0 was not included in first so we still have 9 more ), \\n\\tthen 8 choices for the 3rd place ans so on\\n\\t\\n\\tn=1  , ans =10\\n\\tn=2  , ans = 9*9+10 = 91\\n\\tn=3  , ans(3) = 9*9*8+ 91 = 739\\n\\tn=4  , ans(4)= 9*9*8*7 + 739\\n\\t\\n\\tand so on\\n*/\\n\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n==0) return 1;\\n        int []dp = new int[n+1];\\n        \\n        dp[1]=10;\\n        int prod =9;\\n        \\n        for(int i=2;i<=n;i++){\\n            dp[i]=prod*(11-i)+dp[i-1];\\n            prod*=(11-i);\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\n/*\\n\\tif n =1 , then we have 10 choices to fill the answer, ( 0 can be used here at the most significant place)\\n\\tbut for n = 2,3,4.... , we have only 9 choices out of 10 at the largest place , \\n\\t9 on the 2nd largest ( 0 was not included in first so we still have 9 more ), \\n\\tthen 8 choices for the 3rd place ans so on\\n\\t\\n\\tn=1  , ans =10\\n\\tn=2  , ans = 9*9+10 = 91\\n\\tn=3  , ans(3) = 9*9*8+ 91 = 739\\n\\tn=4  , ans(4)= 9*9*8*7 + 739\\n\\t\\n\\tand so on\\n*/\\n\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n==0) return 1;\\n        int []dp = new int[n+1];\\n        \\n        dp[1]=10;\\n        int prod =9;\\n        \\n        for(int i=2;i<=n;i++){\\n            dp[i]=prod*(11-i)+dp[i-1];\\n            prod*=(11-i);\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701610,
                "title": "simple-solution-using-factorials",
                "content": "A key to this problem is to know what kind of digits do we have:\\n1. Single digit numbers: can be `0..9` \\n2. Double digits numbers: first digit can not be `0` and number of second unique digits numbers would be 9 i.e. we use `0..9` digits. \\n\\nSo, `[ ] [ ]` In the first digits, we have 9 digits to fill `1..9` but in the 2nd also we have 9 to fill i.e. `0..9` (because zero is valid as a non 1st digit), so `[9 digits][9 digits]` i.e. 9*9 = 81 total numbers with two digits but total combined would be `10 + 81`\\n\\n3. Three digits numbers can build on the same logic.. however now in the 3rd digit we can not repeat the previous digits so our number of available digits will be one less than the previous digit.. i.e. `[9 digits][9 digits][8 digits]`\\n\\nTo generalize further the rest of the digits can just be a factorial up to digit depth. In the above case, it would be `10*9` and then add the first digit numbers so, `10 + 9*9 + 9*9*8 = 739`.\\n\\n\\n\\n```\\nclass Solution {\\n\\n    private int factorial(int n, int depth) {\\n        int f = 1;\\n        while(depth-- > 0) {\\n            f *= n--;\\n        }\\n        return f;\\n    }\\n\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int ans = 0;\\n\\n        if(n==0) return 1;\\n\\n        for(int i=1; i<=n; i++) {\\n            if(i==1) ans += 10; // digits 0..9 (single digit number) \\n            else {  \\n                // more than 1 digits, first can\\'t be zero so, 9 * factorial(9, <remaining number of digits>)\\n                ans += 9 * factorial(9, i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    private int factorial(int n, int depth) {\\n        int f = 1;\\n        while(depth-- > 0) {\\n            f *= n--;\\n        }\\n        return f;\\n    }\\n\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int ans = 0;\\n\\n        if(n==0) return 1;\\n\\n        for(int i=1; i<=n; i++) {\\n            if(i==1) ans += 10; // digits 0..9 (single digit number) \\n            else {  \\n                // more than 1 digits, first can\\'t be zero so, 9 * factorial(9, <remaining number of digits>)\\n                ans += 9 * factorial(9, i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691055,
                "title": "c-backtracking-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<bool>generateCandForZero(){\\n        vector<bool>ans(10,false);\\n        ans[0]=true;\\n        return ans;\\n    }\\n    vector<bool>generate(string &num){\\n        vector<bool>ans(10,false);\\n        for(int i=0;i<num.size();i++){\\n            ans[num[i]-\\'0\\']=true;\\n        }\\n        return ans;\\n    }\\n    void backtrack(int &ans,string &num,int n){\\n        if(num.size()==n){\\n            return;\\n        } else {\\n            vector<bool>cnds;\\n            if(num==\"\"){\\n                cnds=generateCandForZero();\\n            } else {\\n                cnds=generate(num);\\n            }\\n            for(int i=0;i<10;i++){\\n                if(!cnds[i]){\\n                    num.push_back(i+\\'0\\');\\n                    ans++;\\n                    backtrack(ans,num,n);\\n                    num.pop_back();\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans=0;\\n        string num=\"\";\\n        backtrack(ans,num,n);\\n        return ans+1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\nprivate:\\n    vector<bool>generateCandForZero(){\\n        vector<bool>ans(10,false);\\n        ans[0]=true;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1669639,
                "title": "python-c-2-solutions-dp",
                "content": "1)Python Recursion (2945 ms)\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n==0: return 1\\n        if n==1: return 10\\n        def dp(no):\\n            if len(no)==n: return 0\\n            ans=0\\n            for i in range(10):\\n                s=no\\n                if str(i) not in no: \\n                    s+=str(i)\\n                    ans+=dp(s)+1\\n            return ans\\n        res=10\\n        for i in range(1,10):\\n            res+=dp(str(i))\\n        return res\\n        \\n        \\n                \\n```\\n2)C++  Combinatorial (0 ms)\\n\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL);\\n        int x=9,y=9,ans=1;\\n        for (int i=0;i<n;i++){\\n            ans+=x;\\n            x*=(y-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n==0: return 1\\n        if n==1: return 10\\n        def dp(no):\\n            if len(no)==n: return 0\\n            ans=0\\n            for i in range(10):\\n                s=no\\n                if str(i) not in no: \\n                    s+=str(i)\\n                    ans+=dp(s)+1\\n            return ans\\n        res=10\\n        for i in range(1,10):\\n            res+=dp(str(i))\\n        return res\\n        \\n        \\n                \\n```\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL);\\n        int x=9,y=9,ans=1;\\n        for (int i=0;i<n;i++){\\n            ans+=x;\\n            x*=(y-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596253,
                "title": "c-back-tracking-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n   int steps;\\n    int dp[10];\\n\\n   int count(int n , unordered_map<int ,int>& map)\\n   {\\n       \\n       if(n == 0 ) return 1;\\n       \\n       if(dp[n] != -1) return dp[n];\\n       \\n       int ans = 0 ;\\n       \\n       for(int i = 0 ; i < 10; i++)\\n       {\\n           if(i == 0 && n == steps) continue ; //leading 0\\'s in  _Steps_ | _step - 1_| \\n           \\n           if(map[i] ==  1)\\n           {\\n               map[i] = 0;\\n               ans += count(n-1 , map);\\n               map[i] = 1;\\n           }\\n            \\n       }\\n\\n       return dp[n] = ans;\\n   }\\n   \\n    \\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        unordered_map<int ,int> map;\\n        for(int i = 0 ; i < 10; i++)\\n        {\\n            map[i] = 1;\\n        }\\n       \\n        int ans = 0;\\n        for(int i = 1; i <= n ; i++)\\n        {\\n            steps = i;\\n            memset(dp , -1 , sizeof(dp));\\n            ans += count(i,map);\\n        }\\n        \\n        return ans+1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int steps;\\n    int dp[10];\\n\\n   int count(int n , unordered_map<int ,int>& map)\\n   {\\n       \\n       if(n == 0 ) return 1;\\n       \\n       if(dp[n] != -1) return dp[n];\\n       \\n       int ans = 0 ;\\n       \\n       for(int i = 0 ; i < 10; i++)\\n       {\\n           if(i == 0 && n == steps) continue ; //leading 0\\'s in  _Steps_ | _step - 1_| \\n           \\n           if(map[i] ==  1)\\n           {\\n               map[i] = 0;\\n               ans += count(n-1 , map);\\n               map[i] = 1;\\n           }\\n            \\n       }\\n\\n       return dp[n] = ans;\\n   }\\n   \\n    \\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        unordered_map<int ,int> map;\\n        for(int i = 0 ; i < 10; i++)\\n        {\\n            map[i] = 1;\\n        }\\n       \\n        int ans = 0;\\n        for(int i = 1; i <= n ; i++)\\n        {\\n            steps = i;\\n            memset(dp , -1 , sizeof(dp));\\n            ans += count(i,map);\\n        }\\n        \\n        return ans+1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592967,
                "title": "o-n-python",
                "content": "\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        result = 1\\n        k = 9\\n        m = 9  # The number of unique n-digit numbers will be recorded here\\n        for i in range(n):\\n            result += m\\n            m *= (k - i)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        result = 1\\n        k = 9\\n        m = 9  # The number of unique n-digit numbers will be recorded here\\n        for i in range(n):\\n            result += m\\n            m *= (k - i)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590214,
                "title": "java-dp-approach",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        \\n        return countUnique(n);\\n        \\n    }\\n    \\n    public int countUnique(int n)\\n    {\\n        if(n==0)\\n            return 1;\\n        \\n        if(n==1)\\n        {\\n            return 10;//0 to 9 \\n        }\\n        \\n        \\n        int dp[]=new int[n+1];\\n        dp[0]=0;\\n        dp[1]=9;\\n        \\n        int res=10;//for n=1 10 combinations \\n        \\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i]=dp[i-1]*(10-i+1);\\n            res=res+dp[i];\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        \\n        return countUnique(n);\\n        \\n    }\\n    \\n    public int countUnique(int n)\\n    {\\n        if(n==0)\\n            return 1;\\n        \\n        if(n==1)\\n        {\\n            return 10;//0 to 9 \\n        }\\n        \\n        \\n        int dp[]=new int[n+1];\\n        dp[0]=0;\\n        dp[1]=9;\\n        \\n        int res=10;//for n=1 10 combinations \\n        \\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i]=dp[i-1]*(10-i+1);\\n            res=res+dp[i];\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488469,
                "title": "python3-easy-o-1-solution-with-permutation",
                "content": "If n=1 then 0-9 total digits will be there so answer is 10, if n=0 then only 0 will be there so the answer is 1. For any value of n more than 1 the following rule will be applied. \\n\\nFor example if n=3 then all n=1, n=2 and n=3 digits will be counted. \\nSo far we know for one digit numbers total digits are 10, \\nfor two digit numbers: we can pick the first digit from 1-9 in total 9 ways(cause 0 cannot be the first digit), for every first digit total number of available digits where two digits are not similar are (10-1)=9 so the total permutation is 9*9\\n\\nfor three digit numbers the first digit can be picked in 9 ways as previously mentioned way, for each of the 9 first digits the second digits will be picked in 9 ways(exclusive of the first digit and inclusive of 0), for each of 9 second digits the third digits will be picked in 9-1=8 ways so the total ways are=9x9x8\\n\\nSo the answer for n=3 is : 10+ 9x9 +9x9x8 = 10+9x(9+9x8)\\nfor n=4 it will be : 10+ 9x(9+9x8+9x8x7)\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef countNumbersWithUniqueDigits(self, n: int) -> int:\\n\\t\\t\\tif not n:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif n==1:\\n\\t\\t\\t\\treturn 10\\n\\n\\t\\t\\tmyList=[9]\\n\\t\\t\\tfor i in range(1,n-1):\\n\\t\\t\\t\\tmyList.append(myList[-1]*(9-i))\\n\\t\\t\\treturn 10+ 9*sum(myList)",
                "solutionTags": [],
                "code": "If n=1 then 0-9 total digits will be there so answer is 10, if n=0 then only 0 will be there so the answer is 1. For any value of n more than 1 the following rule will be applied. \\n\\nFor example if n=3 then all n=1, n=2 and n=3 digits will be counted. \\nSo far we know for one digit numbers total digits are 10, \\nfor two digit numbers: we can pick the first digit from 1-9 in total 9 ways(cause 0 cannot be the first digit), for every first digit total number of available digits where two digits are not similar are (10-1)=9 so the total permutation is 9*9\\n\\nfor three digit numbers the first digit can be picked in 9 ways as previously mentioned way, for each of the 9 first digits the second digits will be picked in 9 ways(exclusive of the first digit and inclusive of 0), for each of 9 second digits the third digits will be picked in 9-1=8 ways so the total ways are=9x9x8\\n\\nSo the answer for n=3 is : 10+ 9x9 +9x9x8 = 10+9x(9+9x8)\\nfor n=4 it will be : 10+ 9x(9+9x8+9x8x7)\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef countNumbersWithUniqueDigits(self, n: int) -> int:\\n\\t\\t\\tif not n:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif n==1:\\n\\t\\t\\t\\treturn 10\\n\\n\\t\\t\\tmyList=[9]\\n\\t\\t\\tfor i in range(1,n-1):\\n\\t\\t\\t\\tmyList.append(myList[-1]*(9-i))\\n\\t\\t\\treturn 10+ 9*sum(myList)",
                "codeTag": "Java"
            },
            {
                "id": 1482842,
                "title": "simplest-c-solution-0ms-fastest-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int nonDup[n+1];\\n        nonDup[0]=1;\\n        int dpPrev=0;\\n        int powerof10=10;\\n        for(int i=1;i<=n;i++)\\n        { dpPrev=dpPrev*10 +(i-1)*nonDup[i-1];\\n          nonDup[i]= powerof10 -(powerof10/10)-dpPrev;\\n         powerof10*=10;\\n            \\n        }\\n         \\n        int total[n+1];\\n        total[0]=1;\\n        for(int i=1;i<=n;i++)\\n        { total[i]=total[i-1]+nonDup[i];\\n            \\n        }\\n        return total[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int nonDup[n+1];\\n        nonDup[0]=1;\\n        int dpPrev=0;\\n        int powerof10=10;\\n        for(int i=1;i<=n;i++)\\n        { dpPrev=dpPrev*10 +(i-1)*nonDup[i-1];\\n          nonDup[i]= powerof10 -(powerof10/10)-dpPrev;\\n         powerof10*=10;\\n            \\n        }\\n         \\n        int total[n+1];\\n        total[0]=1;\\n        for(int i=1;i<=n;i++)\\n        { total[i]=total[i-1]+nonDup[i];\\n            \\n        }\\n        return total[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480320,
                "title": "easy-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        if (n == 1) return 10;\\n        vector<int> dp(n+1, 0);\\n        dp[0] = 1; dp[1] = 10;\\n        \\n        for (int i = 2; i <= n; ++i) {\\n            int a = dp[i-1] - dp[i-2]; // count of nums with unique digits having i-1 total digits\\n            dp[i] = a * (10 - i + 1) + dp[i-1];\\n        }\\n        \\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        if (n == 1) return 10;\\n        vector<int> dp(n+1, 0);\\n        dp[0] = 1; dp[1] = 10;\\n        \\n        for (int i = 2; i <= n; ++i) {\\n            int a = dp[i-1] - dp[i-2]; // count of nums with unique digits having i-1 total digits\\n            dp[i] = a * (10 - i + 1) + dp[i-1];\\n        }\\n        \\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416500,
                "title": "python-3-math-dp-explanation",
                "content": "### Explanation\\n- `f(0) = 1`\\n- `f(1) = 9 + f(0) = 10`\\n- `f(2) = 9 * 9 + f(1) = 91`\\n- `f(3) = 9 * 9 * 8 + f(2) = 739`\\n- `...`\\n- You got the idea \\n### Implementation\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        ans = [1]\\n        for k in range(1, n+1):\\n            base = available = 9\\n            for _ in range(k-1):\\n                base *= available \\n                available -= 1\\n            ans.append(base+ans[-1])    \\n        return ans[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        ans = [1]\\n        for k in range(1, n+1):\\n            base = available = 9\\n            for _ in range(k-1):\\n                base *= available \\n                available -= 1\\n            ans.append(base+ans[-1])    \\n        return ans[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351199,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n>10)\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        int ans=10;\\n        int digitAvailable=9;\\n        int count=9;\\n        while(n>1 && digitAvailable>0){\\n            count=count*digitAvailable;\\n            ans+=count;\\n            digitAvailable--;\\n            n--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n>10)\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        int ans=10;\\n        int digitAvailable=9;\\n        int count=9;\\n        while(n>1 && digitAvailable>0){\\n            count=count*digitAvailable;\\n            ans+=count;\\n            digitAvailable--;\\n            n--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337070,
                "title": "faster-than-100-00-of-c-online-submissions",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n\\t\\t//9 * 9 + 10 for n = 2\\n        //9 * 9 * 8 + 10 for n = 3\\n        //9 * 9 * 8 * 7 + 10 for n = 4\\n        //9 * 9 * 8 * 7 * 6 + 10 for n = 5\\n\\t\\t\\n\\t\\t\\n        int ans = 10;\\n        if(n==0){\\n            return 1;\\n        }else if(n==1){\\n            return 10;\\n        }else{\\n            int sum =9;\\n            for(int i =2;i<=n;i++){\\n                sum*=(11-i);\\n                ans=ans+sum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n\\t\\t//9 * 9 + 10 for n = 2\\n        //9 * 9 * 8 + 10 for n = 3\\n        //9 * 9 * 8 * 7 + 10 for n = 4\\n        //9 * 9 * 8 * 7 * 6 + 10 for n = 5\\n\\t\\t\\n\\t\\t\\n        int ans = 10;\\n        if(n==0){\\n            return 1;\\n        }else if(n==1){\\n            return 10;\\n        }else{\\n            int sum =9;\\n            for(int i =2;i<=n;i++){\\n                sum*=(11-i);\\n                ans=ans+sum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279712,
                "title": "java-o-1-100",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        int prod=9;\\n        int i=1;\\n        int total=10;\\n        while(n>=2){\\n            prod=prod*(10-i);\\n            total+=prod;\\n            i++;\\n            n--;\\n        }\\n        return total;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        int prod=9;\\n        int i=1;\\n        int total=10;\\n        while(n>=2){\\n            prod=prod*(10-i);\\n            total+=prod;\\n            i++;\\n            n--;\\n        }\\n        return total;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276638,
                "title": "c-100-faster-o-n-tc-0ms",
                "content": "Using Combination\\n\\n```\\nclass Solution {\\npublic:\\n    //In this problem, for 1st position we have 9 option(1,2,...,8,9)( becoz we cann\\'t use 0 at 1st position)\\n    //for 2nd position again we have 9 option(0,1,2...,8,9 excluding that digit which we have used in previous position)\\n    //for 3rd --> 8 option and so on........\\n    //so answer is 9*9*8*...*(9-k+2);\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans = 1;\\n        int k = 9,res = 1;\\n        for(int i = 1;i <= n;i++){\\n            res *= k;\\n            ans += res;\\n            if(i != 1){\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //In this problem, for 1st position we have 9 option(1,2,...,8,9)( becoz we cann\\'t use 0 at 1st position)\\n    //for 2nd position again we have 9 option(0,1,2...,8,9 excluding that digit which we have used in previous position)\\n    //for 3rd --> 8 option and so on........\\n    //so answer is 9*9*8*...*(9-k+2);\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans = 1;\\n        int k = 9,res = 1;\\n        for(int i = 1;i <= n;i++){\\n            res *= k;\\n            ans += res;\\n            if(i != 1){\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270104,
                "title": "c-faster-than-100-solns",
                "content": "```\\nclass Solution {\\npublic:\\n    int binomialCoeff(int n, int k)\\n    {\\n        int C[n + 1][k + 1];\\n        int i, j;\\n\\n        for (i = 0; i <= n; i++) {\\n            for (j = 0; j <= min(i, k); j++) {\\n                \\n                if (j == 0 || j == i)\\n                    C[i][j] = 1;\\n\\n                else\\n                    C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\\n            }\\n        }\\n\\n        return C[n][k];\\n    }\\n    \\n    \\n    \\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        vector<int> dp(n+5,0);\\n        dp[0] = 1;\\n        vector<int> fact(n+3);\\n        \\n        fact[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            fact[i] = i*fact[i-1];\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = (binomialCoeff(10,i)*fact[i]-binomialCoeff(9,i-1)*fact[i-1]);\\n            dp[i] += dp[i-1];\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binomialCoeff(int n, int k)\\n    {\\n        int C[n + 1][k + 1];\\n        int i, j;\\n\\n        for (i = 0; i <= n; i++) {\\n            for (j = 0; j <= min(i, k); j++) {\\n                \\n                if (j == 0 || j == i)\\n                    C[i][j] = 1;\\n\\n                else\\n                    C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\\n            }\\n        }\\n\\n        return C[n][k];\\n    }\\n    \\n    \\n    \\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        vector<int> dp(n+5,0);\\n        dp[0] = 1;\\n        vector<int> fact(n+3);\\n        \\n        fact[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            fact[i] = i*fact[i-1];\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = (binomialCoeff(10,i)*fact[i]-binomialCoeff(9,i-1)*fact[i-1]);\\n            dp[i] += dp[i-1];\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266900,
                "title": "oops",
                "content": "* class Solution {\\npublic:\\n    \\n    int countNumbersWithUniqueDigits(int n) {\\n        int dp[10];\\n        int ans = 0;\\n        int sum[10];\\n        sum[0] = 1;\\n        sum[1] = 10;\\n        for(int i = 0;i <= n;i++)\\n        {\\n            if(i == 0)\\n            {\\n              dp[i] = 1;\\n              \\n            }\\n            else if(i == 1)\\n            {\\n              dp[i] = 9;\\n            }\\n            else\\n            {\\n                dp[i] = dp[i-1]*(10-i+1);\\n                sum[i] = sum[i-1]+dp[i];\\n            }\\n        }\\n        return sum[n];\\n    }\\n    \\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int countNumbersWithUniqueDigits(int n) {\\n        int dp[10];\\n        int ans = 0;\\n        int sum[10];\\n        sum[0] = 1;\\n        sum[1] = 10;\\n        for(int i = 0;i <= n;i++)\\n        {\\n            if(i == 0)\\n            {\\n              dp[i] = 1;\\n              \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1232009,
                "title": "simple-python-o-1-with-explaination",
                "content": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        def val(x):\\n            \"\"\"\\n            1 digit : 10\\n            2 digit : 9*9\\n            3 digit : 9*9*8\\n            4 digit : 9*9*8*7\\n            ....\\n            n digit : 9*9*8......\\n                      --n times--\\n            \"\"\"\\n            if x == 1:\\n                return 10\\n            s=9\\n            for i in range(0, x-1):\\n                s *= (9-i)\\n            return s\\n        res=0\\n        for i in range(1, n+1):\\n            res += val(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        def val(x):\\n            \"\"\"\\n            1 digit : 10\\n            2 digit : 9*9\\n            3 digit : 9*9*8\\n            4 digit : 9*9*8*7\\n            ....\\n            n digit : 9*9*8......\\n                      --n times--\\n            \"\"\"\\n            if x == 1:\\n                return 10\\n            s=9\\n            for i in range(0, x-1):\\n                s *= (9-i)\\n            return s\\n        res=0\\n        for i in range(1, n+1):\\n            res += val(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225640,
                "title": "c-combinatorics-o-n-runtime-o-1-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        int sum = 10;\\n        int unique = 9;\\n        for (int i = 1, m = 9; i < n && m > 0; i++, m--) {\\n            unique *= m;\\n            sum += unique;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        int sum = 10;\\n        int unique = 9;\\n        for (int i = 1, m = 9; i < n && m > 0; i++, m--) {\\n            unique *= m;\\n            sum += unique;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164782,
                "title": "java-0ms-100-95-space-no-dp-no-backtracking-pure-math-no-extra-space",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int duplicate=0;\\n        int nonduplicate=1;\\n        if(n==0){\\n            return 1;\\n        }\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            duplicate=10*duplicate+(i-1)*nonduplicate;\\n            nonduplicate=((int)(Math.pow(10,i)))-((int)(Math.pow(10,i-1)))-duplicate;\\n            sum+=nonduplicate;\\n        }\\n        return sum+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int duplicate=0;\\n        int nonduplicate=1;\\n        if(n==0){\\n            return 1;\\n        }\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            duplicate=10*duplicate+(i-1)*nonduplicate;\\n            nonduplicate=((int)(Math.pow(10,i)))-((int)(Math.pow(10,i-1)))-duplicate;\\n            sum+=nonduplicate;\\n        }\\n        return sum+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133879,
                "title": "c-dp-0-ms-faster-than-100-00-5-8-mb-less-than-95-50",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        if(n==1) return 10;\\n        \\n        int prev=9;\\n         int sum=10;\\n        for(int i=2;i<=n;i++){\\n            prev = prev*(10-i+1);\\n            sum+= prev;\\n        }\\n        return sum;\\n    }\\n};\\n```\\nDo upvote if you liked the code :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        if(n==1) return 10;\\n        \\n        int prev=9;\\n         int sum=10;\\n        for(int i=2;i<=n;i++){\\n            prev = prev*(10-i+1);\\n            sum+= prev;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080087,
                "title": "java-math-solution-beats-100-w-commented-explanation",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        // edge cases\\n        if (n == 0) return 1;\\n        else if (n == 1) return 10;\\n        else {\\n            // final digit place we can choose from 1-9 excluding 0\\n            int res = 9;\\n            int nums_taken = 0;\\n            \\n            // for each subsequent digit place, we can choose 0-9, but\\n            // each time we remove a number to ensure uniqueness\\n            for (int i = 1; i < n; i++) {\\n                res *= 9 - nums_taken;\\n                nums_taken += 1;\\n            }\\n            \\n            // return total number of unique number digits of length n + what is returned from \\n            // making a recursive call for n - 1\\n            return res + countNumbersWithUniqueDigits(n - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        // edge cases\\n        if (n == 0) return 1;\\n        else if (n == 1) return 10;\\n        else {\\n            // final digit place we can choose from 1-9 excluding 0\\n            int res = 9;\\n            int nums_taken = 0;\\n            \\n            // for each subsequent digit place, we can choose 0-9, but\\n            // each time we remove a number to ensure uniqueness\\n            for (int i = 1; i < n; i++) {\\n                res *= 9 - nums_taken;\\n                nums_taken += 1;\\n            }\\n            \\n            // return total number of unique number digits of length n + what is returned from \\n            // making a recursive call for n - 1\\n            return res + countNumbersWithUniqueDigits(n - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068103,
                "title": "faster-than-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n        {\\n        \\treturn 1;\\n        }\\n        int sum=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n        \\tint prod=1;\\n        \\tint num=9;\\n        \\tfor(int j=0;j<i;j++)\\n        \\t{\\n        \\t\\tprod=prod*num;\\n        \\t\\tif(j==0)\\n        \\t\\t{\\n        \\t\\t\\tnum++;\\n        \\t\\t}\\n        \\t\\tnum--;\\n        \\t}\\n        \\tsum=sum+prod;\\n        }\\n        return sum;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n        {\\n        \\treturn 1;\\n        }\\n        int sum=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n        \\tint prod=1;\\n        \\tint num=9;\\n        \\tfor(int j=0;j<i;j++)\\n        \\t{\\n        \\t\\tprod=prod*num;\\n        \\t\\tif(j==0)\\n        \\t\\t{\\n        \\t\\t\\tnum++;\\n        \\t\\t}\\n        \\t\\tnum--;\\n        \\t}\\n        \\tsum=sum+prod;\\n        }\\n        return sum;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050551,
                "title": "c",
                "content": "```\\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        if (n<=1) return pow(10,n);\\n        int sum=9;\\n        int cn=sum;\\n        for (int i=0;i<n-1;i++) sum*=(cn-i);\\n        return sum+countNumbersWithUniqueDigits(n-1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        if (n<=1) return pow(10,n);\\n        int sum=9;\\n        int cn=sum;\\n        for (int i=0;i<n-1;i++) sum*=(cn-i);\\n        return sum+countNumbersWithUniqueDigits(n-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047757,
                "title": "java-combinatorics-dp",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n){\\n        if(n==0) return 1;\\n        int[]dp = new int[n+1];\\n        dp[1] = 10; //for n==1 there are 10 unique numbes {0 to 9}\\n        int[]prefix = new int[10];\\n        prefix[0] = 9;\\n        int curr = 9;\\n        for(int i=1;i<prefix.length;i++){\\n            prefix[i] = prefix[i-1] * curr--;\\n        }\\n        for(int i=2;i<=n;i++){\\n            dp[i] = dp[i-1] + prefix[i-1];   \\n        }\\n        return dp[n];\\n    }\\n}\\n\\n/**\\n1 -> {_} 1st-slot 10 possibilities (0-9) \\n2 -> {1} + {9(0 cant be 1st) * 9(0 can be used here)} \\n3 -> {1} + {9 * 9} + {9 * 9 * 8}\\n4 -> {1} + {9 * 9} + {9 * 9 * 8} + {9 * 9 * 8 * 7}\\n5 -> (n==4) + {9*9*8*7*6}\\n6 -> (n==5) + {9*9*8.......5}\\n7 -> (n==6) + {9*9*8.......4}\\n.\\n.\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n){\\n        if(n==0) return 1;\\n        int[]dp = new int[n+1];\\n        dp[1] = 10; //for n==1 there are 10 unique numbes {0 to 9}\\n        int[]prefix = new int[10];\\n        prefix[0] = 9;\\n        int curr = 9;\\n        for(int i=1;i<prefix.length;i++){\\n            prefix[i] = prefix[i-1] * curr--;\\n        }\\n        for(int i=2;i<=n;i++){\\n            dp[i] = dp[i-1] + prefix[i-1];   \\n        }\\n        return dp[n];\\n    }\\n}\\n\\n/**\\n1 -> {_} 1st-slot 10 possibilities (0-9) \\n2 -> {1} + {9(0 cant be 1st) * 9(0 can be used here)} \\n3 -> {1} + {9 * 9} + {9 * 9 * 8}\\n4 -> {1} + {9 * 9} + {9 * 9 * 8} + {9 * 9 * 8 * 7}\\n5 -> (n==4) + {9*9*8*7*6}\\n6 -> (n==5) + {9*9*8.......5}\\n7 -> (n==6) + {9*9*8.......4}\\n.\\n.\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031785,
                "title": "solution-with-basic-combinatorics-and-fast-computation-beats-100",
                "content": "The requirements of this problem is that we need to exclude the numbers having repeated digits. There are two ways to do this:\\n\\n1. Calculate total possible numbers having digits *less than or equal to* 10<sup>n</sup> and subtract the number of numbers having repeated digits. This is a tedious process because we need to count the numbers by keeping two same digits, then three same digits and so on.\\n2. Build the number by filling each digit place. For instance, consider in a 5 digit number. First position (ten thousands place) can be taken by 9 digits (1-9, can\\'t include 0 here). Fill it and continue for next place. This place can be taken by 9 digits (excluding the digit we placed in previous position, including 0). And continue doing this unitl all positions are filled. Total number of such numbers are 9 * 9 * 8 * 7 * 6 = 9 * (9!) / (10-5)! In general for **i** digit number, total count of numbers having unique digits = **9 * (9!)/ (10-i)!**. But for the solution of this problem, we also need to add such (i-1) digit numbers, (i-2) digit numbers and so on. To do that, we will use a table ```nums``` to store the numbers with unique digits. ```nums[i]``` will represent number of \\'i\\' digit numbers having unique digits. Hence, ```nums[i] = nums[i-1] + (9 * fact(9)/fact(10-i));``` fact(x) = x! where x >= 0 and x is an integer.\\n\\nA prime aspect of this solution is the necessity of factorial values. If we exclude the factorial values, we will have to recompute the product for every test case and iteration. So we will keep the factorials precomputed and we will just refer to them when needed.\\n\\nFollowing is the code:\\n\\n```\\nclass Solution {\\n    private int[] factorials = null; // array to store factorials\\n    private void computeFactorials(){\\n        if(this.factorials == null){\\n            this.factorials = new int[11];\\n            factorials[0] = 1;\\n            for(int i = 1; i < 11; i++){\\n                factorials[i] = i * factorials[i-1];\\n            }\\n        }else{\\n            return;\\n        }\\n    }\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0){\\n            return 1;\\n        }\\n        computeFactorials(); // Computes the factorials only once\\n        int[] nums = new int[n+1];\\n        nums[0] = 1;\\n        nums[1] = 10; // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 -> 10\\n        for(int i = 2; i <= n; i++){\\n            nums[i] = nums[i-1] + (9 * factorials[9]/factorials[10-i]);\\n        }\\n        return nums[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```nums```\n```nums[i]```\n```nums[i] = nums[i-1] + (9 * fact(9)/fact(10-i));```\n```\\nclass Solution {\\n    private int[] factorials = null; // array to store factorials\\n    private void computeFactorials(){\\n        if(this.factorials == null){\\n            this.factorials = new int[11];\\n            factorials[0] = 1;\\n            for(int i = 1; i < 11; i++){\\n                factorials[i] = i * factorials[i-1];\\n            }\\n        }else{\\n            return;\\n        }\\n    }\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0){\\n            return 1;\\n        }\\n        computeFactorials(); // Computes the factorials only once\\n        int[] nums = new int[n+1];\\n        nums[0] = 1;\\n        nums[1] = 10; // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 -> 10\\n        for(int i = 2; i <= n; i++){\\n            nums[i] = nums[i-1] + (9 * factorials[9]/factorials[10-i]);\\n        }\\n        return nums[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017024,
                "title": "100-faster-c-sol",
                "content": "class Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        //using permutation concept for finding unique digits for 2, 3, 4 ... digits characters\\n\\t\\t// eg. for 2 digit numbers we have 2 spaces _ _ . for 1st space we have choices 1...9 -> total 9 ans for         //second we have 0...9 excluding the digit we would have used for first place -> 10 - 1 = 9\\n\\t\\t//therfore total 2 digit numbers are 9X9 \\n\\t\\t//similarly for 3 _ _ _ we have 9 X 9 X 8 ans so on ...\\n\\t\\t\\n        int dp[n+1];\\n        if(n==0){\\n            return 1 ;\\n        }\\n        dp[1] = 10 ;\\n        int t = 9  ;\\n        for(int i=2 ; i<=n ; i++){\\n            for(int j=0 ; j<i-1 ; j++){\\n                t = t*(9-j);\\n            }\\n            dp[i] = dp[i-1] + t ;\\n            t = 9 ;\\n        }\\n        \\n        return dp[n];\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        //using permutation concept for finding unique digits for 2, 3, 4 ... digits characters\\n\\t\\t// eg. for 2 digit numbers we have 2 spaces _ _ . for 1st space we have choices 1...9 -> total 9 ans for         //second we have 0...9 excluding the digit we would have used for first place -> 10 - 1 = 9\\n\\t\\t//therfore total 2 digit numbers are 9X9 \\n\\t\\t//similarly for 3 _ _ _ we have 9 X 9 X 8 ans so on ...\\n\\t\\t\\n        int dp[n+1];\\n        if(n==0){\\n            return 1 ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1006302,
                "title": "js-o-n-analytical-solution",
                "content": "The general Idea is behind the probstat  math. So, when n === 0, then we have only one number 0. If n === 1, then we have 10 unique values. When we have n > 1, then simple combinatorics go into the game:\\n\\n2 digit number with unique digits can be created by 9 * 9 possible ways:\\n1-9 - first digit, because 2 digit number cannot start with 0, and 10 - first number => 9 second digit.\\n\\n3 digit number with unique digits can be created by 9 * 9 * 8 ways.\\n4 digit number with unique digits can be created by 9 * 9 * 8 * 7 ways.\\n\\nand so on.\\n\\nSo, we calculate the result value recursively from n to 1. Also, solution can be easily rewritten in non-recursive style.\\n\\n```\\nvar countNumbersWithUniqueDigits = function func(n) {\\n    if (n === 0) {\\n        return 1;\\n    }\\n    \\n    if (n === 1) {\\n        return 10;\\n    }\\n    \\n    let res = 9;\\n    for (let i = 0; i < n - 1; i++) {\\n        res *= 9 - i;\\n    }\\n    \\n    return res + func(n - 1);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countNumbersWithUniqueDigits = function func(n) {\\n    if (n === 0) {\\n        return 1;\\n    }\\n    \\n    if (n === 1) {\\n        return 10;\\n    }\\n    \\n    let res = 9;\\n    for (let i = 0; i < n - 1; i++) {\\n        res *= 9 - i;\\n    }\\n    \\n    return res + func(n - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979398,
                "title": "math",
                "content": "Base case: there is only one valid number when n == 0.\\nGeneral case: At the first step you can choose one of the digits 1-9. Then, at each following step you can choose one of the digits 0-9 that is not in the set of digits you have already chosen.\\n\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        int sum = 10, c = 9, t = 9;\\n        for (int i = 2; i <= n; i++) {\\n            sum += (c *= t--);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        int sum = 10, c = 9, t = 9;\\n        for (int i = 2; i <= n; i++) {\\n            sum += (c *= t--);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940231,
                "title": "java-100-hopefully-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        \\n        \\n        int result = 1;\\n        for(int i=1;i<=n;i++) {\\n            int value = 9;\\n            for(int j=1;j<i;j++) {\\n                value = value * (10-j);\\n            }\\n            result = result + value;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        \\n        \\n        int result = 1;\\n        for(int i=1;i<=n;i++) {\\n            int value = 9;\\n            for(int j=1;j<i;j++) {\\n                value = value * (10-j);\\n            }\\n            result = result + value;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 932009,
                "title": "c-0ms-just-few-lines",
                "content": "```\\nclass Solution {\\n   \\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int cur = 9, res = 1;\\n        for(int i = 0; i < n; i ++) {\\n            res += cur;\\n            cur *= (9 - i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int cur = 9, res = 1;\\n        for(int i = 0; i < n; i ++) {\\n            res += cur;\\n            cur *= (9 - i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921072,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        self.res = 0\\n        str_num = [str(i) for i in range(10)]\\n        def backtrack(n, path):\\n            if n == 0:\\n                self.res += 1\\n                return\\n            for num in str_num:\\n                # try to get rid of leading zero\\n                nlz_path = str(int(path))\\n                if num not in nlz_path or nlz_path==\"0\":\\n                    backtrack(n-1, nlz_path+num)\\n        backtrack(n, \"0\")\\n        return self.res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        self.res = 0\\n        str_num = [str(i) for i in range(10)]\\n        def backtrack(n, path):\\n            if n == 0:\\n                self.res += 1\\n                return\\n            for num in str_num:\\n                # try to get rid of leading zero\\n                nlz_path = str(int(path))\\n                if num not in nlz_path or nlz_path==\"0\":\\n                    backtrack(n-1, nlz_path+num)\\n        backtrack(n, \"0\")\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916907,
                "title": "python-java-backtracking",
                "content": "\\tclass Solution:\\n\\t\\tdef countNumbersWithUniqueDigits(self, n: int) -> int:\\n\\t\\t\\tif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tself.res = 0\\n\\t\\t\\tseen = set()\\n\\t\\t\\tdef helper(s):\\n\\t\\t\\t\\tif len(s) > n or (len(s) > 1 and s[0] == \"0\"):\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif s:\\n\\t\\t\\t\\t\\tself.res += 1\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tif i not in seen:\\n\\t\\t\\t\\t\\t\\tseen.add(i)\\n\\t\\t\\t\\t\\t\\thelper(s + str(i))\\n\\t\\t\\t\\t\\t\\tseen.remove(i)\\n\\t\\t\\thelper(\"\")\\n\\t\\t\\treturn self.res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tint res = 0;\\n\\t\\tpublic int countNumbersWithUniqueDigits(int n) {\\n\\t\\t\\tif (n == 0) return 1;\\n\\t\\t\\tSet<Integer> seen = new HashSet<>();\\n\\t\\t\\thelper(n, \"\", seen);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tprivate void helper(int n, String s, Set<Integer> seen){        \\n\\t\\t\\tif (s.length() > n || (s.length() > 1 && s.charAt(0) == \\'0\\')) return;\\n\\t\\t\\tif (s != \"\") res ++;\\n\\t\\t\\tfor (int i = 0; i < 10; i ++){\\n\\t\\t\\t\\tif (!seen.contains(i)){\\n\\t\\t\\t\\t\\tseen.add(i);\\n\\t\\t\\t\\t\\thelper(n, s + String.valueOf(i), seen);\\n\\t\\t\\t\\t\\tseen.remove(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef countNumbersWithUniqueDigits(self, n: int) -> int:\\n\\t\\t\\tif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tself.res = 0\\n\\t\\t\\tseen = set()\\n\\t\\t\\tdef helper(s):\\n\\t\\t\\t\\tif len(s) > n or (len(s) > 1 and s[0] == \"0\"):\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif s:\\n\\t\\t\\t\\t\\tself.res += 1\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tif i not in seen:\\n\\t\\t\\t\\t\\t\\tseen.add(i)\\n\\t\\t\\t\\t\\t\\thelper(s + str(i))\\n\\t\\t\\t\\t\\t\\tseen.remove(i)\\n\\t\\t\\thelper(\"\")\\n\\t\\t\\treturn self.res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tint res = 0;\\n\\t\\tpublic int countNumbersWithUniqueDigits(int n) {\\n\\t\\t\\tif (n == 0) return 1;\\n\\t\\t\\tSet<Integer> seen = new HashSet<>();\\n\\t\\t\\thelper(n, \"\", seen);\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 916559,
                "title": "scala-solution-with-explanation",
                "content": "First let\\'s set the mental map. What the question is asking is how many nums with unique digits we can construct if we are givin n digit position to play with. So in our head we can imagine something like this:\\n\\nFor n = 1: _\\nFor n = 2: _ _\\nfor n = 3: _ _ _ and so on.\\n\\nLet\\'s first consider the case where n is 1: _\\n\\nThe range of digits to choose from 0 <= x <= 10 ^ 1 so 10 ways 0 to 9\\n\\nNow let\\'s consider the case where n is 2: _ _\\n\\n0 <= x <= 10 ^ 2, so 10 ways to do 1 digit number + y ways to do 2 digit numbers\\n\\n_ _ we can do the first digit 9 ways (can\\'t be 0) we can do the second digit 9 ways (0 + remaining 8 numbers)\\n\\nso 10 + (9 * 9) = 10 + 81 = 91 ways\\n\\nNow let\\'s consider hte case where n is 3: _ _ _ \\n\\n0 <= x <= 10 ^ 3, so 10 ways to do 1 digit number + 81 ways to do 2 digit numbers + y ways to do a 3 digit number\\n\\n_ _  _ we can do the first digit 9 ways (can\\'t be 0) we can do the second digit 9 ways (0 + remaining 8 numbers) and the third can only be 8 digits (to keep the digits unique once one is chosen it cannot be chosen again)\\n\\nso 91 + (9 * 9 * 8) = 91 + 648 = 739\\n\\nYou can figure out the rest on your own.\\n\\n```\\nobject Solution {\\n  def countNumbersWithUniqueDigits(n: Int): Int = {\\n    if (n == 0) 1 // special case\\n    else {\\n      val sum_ = (9 until 10 - n by -1).foldLeft((10, 9)) { // max we can have ever is 9 digits see expl above\\n        case ((count, product), digit) => {\\n          val cCount = product * digit\\n          (count + cCount, cCount)\\n        }\\n      }\\n\\n      sum_._1\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n  def countNumbersWithUniqueDigits(n: Int): Int = {\\n    if (n == 0) 1 // special case\\n    else {\\n      val sum_ = (9 until 10 - n by -1).foldLeft((10, 9)) { // max we can have ever is 9 digits see expl above\\n        case ((count, product), digit) => {\\n          val cCount = product * digit\\n          (count + cCount, cCount)\\n        }\\n      }\\n\\n      sum_._1\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 913145,
                "title": "recursive-solution-using-concept-of-combination",
                "content": "\\tpublic int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        // first digit can have 9 possibilities excluding 0\\n        // second digit will also have 9 possibilities excluding first digit\\n        int number = 9, comp = 9;\\n        for(int i = n-1; i>0 ;i--) {\\n            comp = comp * number;\\n            number--;\\n        }\\n        return comp+countNumbersWithUniqueDigits(n-1);\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        // first digit can have 9 possibilities excluding 0\\n        // second digit will also have 9 possibilities excluding first digit\\n        int number = 9, comp = 9;\\n        for(int i = n-1; i>0 ;i--) {\\n            comp = comp * number;\\n            number--;\\n        }\\n        return comp+countNumbersWithUniqueDigits(n-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 897879,
                "title": "combinatorics-solution-explained-faster-than-100-no-extra-memory",
                "content": "**Understanding the basic combinatorics approch**\\nSuppose we want to create a 3-digit number with unique digits   _ _ _\\nFor the first _ i have 9 options out of the 10 valid digits (0 cannot be used as the number must have strictly 3 digits). For the second _ I have 9 options again(0+ remaining 8 unique digits after filling first _) \\nFor the last _ we have 8 options.\\nhence for n=3 _ _ _ : 9*9*8\\nfor n=4 _ _ _ _: 9*9*8*7=>(value for3)*7\\nand so on for bigger n.\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        int ans=1;\\n        int place=9;\\n            int temp=place;\\n        ans+=temp;\\n        for(int i=2;i<=n;i++)\\n        {  \\n            temp*=place;\\n            ans+=temp;\\n            place--;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        int ans=1;\\n        int place=9;\\n            int temp=place;\\n        ans+=temp;\\n        for(int i=2;i<=n;i++)\\n        {  \\n            temp*=place;\\n            ans+=temp;\\n            place--;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854141,
                "title": "c-solution-combinatorics-math-beats-time-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Count Numbers with Unique Digits.\\nMemory Usage: 5.9 MB, less than 90.84% of C++ online submissions for Count Numbers with Unique Digits.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int arr[] = {1,9,9,8,7,6,5,4,3,2,1};\\n        int num = 1;\\n        int result = 0;    \\n        for(int i=0;i<=n;i++)\\n        {\\n            num = num * arr[i];\\n            result += num;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int arr[] = {1,9,9,8,7,6,5,4,3,2,1};\\n        int num = 1;\\n        int result = 0;    \\n        for(int i=0;i<=n;i++)\\n        {\\n            num = num * arr[i];\\n            result += num;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822555,
                "title": "dynamic-programming-intuition-explanation",
                "content": "First question you might ask yourself is how/why is this problems even dynamic programming?\\n\\n**Intuition:**\\nGenerally speaking if there\\'s any problem which asks for count/number of ways, there\\'s a high chance the problem can be solved by dynamic programming. While definitely there are exceptions, however, the former statement at least gives you a direction to think if you\\'re completely blanked out.\\n\\nNow that we feel that the problem might be solved by DP, let\\'s go ahead and think about what the dp table would store.\\n\\n```Let dp[i] be the count of unique digits from 0 to i digits.```\\n\\nWhere would the answer lie? \\n```Ans: dp[n]```\\n\\nWhat would the base case be?\\n* ``` if i = 0, dp[0] = 1.```\\n* ```if i = 1, dp[1] = 10.```\\n\\nNow that we\\'ve got most of the things out of the way, let\\'s go ahead and take a look at the recurrence relation:\\nIf you\\'re little bit familiar with DP, you can kind of guess that for i > 1, it would be:\\n```dp[i] = dp[i - 1] + solve(i);```\\n\\nNow the important part is the ```solve(i) ``` function.\\nLet\\'s run through a couple of examples to figure out how ```solve(i)``` would work.\\n\\n```\\nsolve(i):\\n\\tif i = 2, what would be the count for unique 2 digits numbers\\n\\n\\t[pos1] [pos2] \\n\\t______ _______\\n\\n\\tSince [pos1] is MSB, we can have only digits from 1 to 9, thus there are 9 digits we can fill in [pos1]\\n\\tFor [pos2] we can ideally have 10 digits from 0 to 9 but since it has to be unique we can \\n\\thave 10 - (j - 1) digits, where j > 1 and j <= i in this case.\\n\\tThus for i = 2, we get [pos1] x [pos2] = 9 x 9 = 81.\\n\\n\\tHomework, Try i = 3 on your own, ans should be : 9 x 9 x 8. Why?\\n\\n```\\n\\nNow that we know what solve(i = 2) returns, plug it in ```dp[i] = dp[i - 1] + solve(i);``` and voila you\\'re done!\\n\\n```\\nC++ code:\\n\\nint solve(int n) {\\n int prod = 1;\\n for(int i = 1; i <= n; ++i) {\\n\\tif(i == 1)\\n\\t\\tprod *= 9;\\n\\telse\\n\\t\\tprod *= (10 - (i - 1));\\n  }\\n  return prod;\\n}\\n\\nint countNumbersWithUniqueDigits(int n) {\\n\\tvector < int > dp(n + 1);\\n\\tdp[0] = 1;\\n\\tif(n == 0)\\n\\t\\treturn dp[0];\\n\\tdp[1] = 10;\\n\\tfor(int i = 2; i <= n; ++i) {\\n\\t  int curr_sum = solve(i);\\n\\t  dp[i] = curr_sum + dp[i - 1];\\n\\t}\\n\\treturn dp[n];\\n}\\n```",
                "solutionTags": [],
                "code": "```Let dp[i] be the count of unique digits from 0 to i digits.```\n```Ans: dp[n]```\n``` if i = 0, dp[0] = 1.```\n```if i = 1, dp[1] = 10.```\n```dp[i] = dp[i - 1] + solve(i);```\n```solve(i) ```\n```solve(i)```\n```\\nsolve(i):\\n\\tif i = 2, what would be the count for unique 2 digits numbers\\n\\n\\t[pos1] [pos2] \\n\\t______ _______\\n\\n\\tSince [pos1] is MSB, we can have only digits from 1 to 9, thus there are 9 digits we can fill in [pos1]\\n\\tFor [pos2] we can ideally have 10 digits from 0 to 9 but since it has to be unique we can \\n\\thave 10 - (j - 1) digits, where j > 1 and j <= i in this case.\\n\\tThus for i = 2, we get [pos1] x [pos2] = 9 x 9 = 81.\\n\\n\\tHomework, Try i = 3 on your own, ans should be : 9 x 9 x 8. Why?\\n\\n```\n```dp[i] = dp[i - 1] + solve(i);```\n```\\nC++ code:\\n\\nint solve(int n) {\\n int prod = 1;\\n for(int i = 1; i <= n; ++i) {\\n\\tif(i == 1)\\n\\t\\tprod *= 9;\\n\\telse\\n\\t\\tprod *= (10 - (i - 1));\\n  }\\n  return prod;\\n}\\n\\nint countNumbersWithUniqueDigits(int n) {\\n\\tvector < int > dp(n + 1);\\n\\tdp[0] = 1;\\n\\tif(n == 0)\\n\\t\\treturn dp[0];\\n\\tdp[1] = 10;\\n\\tfor(int i = 2; i <= n; ++i) {\\n\\t  int curr_sum = solve(i);\\n\\t  dp[i] = curr_sum + dp[i - 1];\\n\\t}\\n\\treturn dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1833875,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1725454,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1825571,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1818030,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1571632,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 2075658,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 2014809,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1977316,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1953104,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 2038376,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1833875,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1725454,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1825571,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1818030,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1571632,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 2075658,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 2014809,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1977316,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1953104,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 2038376,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            }
        ]
    }
]