[
    {
        "title": "Swap Nodes in Pairs",
        "question_content": "Given a&nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&nbsp;modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\n\nExample 2:\n\nInput: head = []\nOutput: []\n\nExample 3:\n\nInput: head = [1]\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the&nbsp;list&nbsp;is in the range [0, 100].\n\t0 <= Node.val <= 100",
        "solutions": [
            {
                "id": 1775033,
                "title": "swapping-nodes-not-just-the-values-visual-explanation-well-explained-c",
                "content": "As mentioned in the question we have to **exchange the nodes itself (and not just their values)**, and this solution follows this constraint.\\n\\nI will be placing a `dummy node` before the head node so that the code we write can also be applicable to the head node also, and we don\\'t have to specifically write different conditions for the head node.\\n\\n#### Example:\\n***Given Linked List***\\n\\n![image](https://assets.leetcode.com/users/images/d4219c57-0fa8-4d02-8c75-e437d1613be0_1644993781.493073.jpeg)\\n\\n ***Final Linked List***\\n\\n![image](https://assets.leetcode.com/users/images/88cece9e-8fff-4f5f-807f-dcabecebe71e_1644993901.1494746.jpeg)\\n\\n\\nLet\\'s now understand the **approach**\\n\\n1. As mentioned earlier, we will place a `dummyNode` before the head node.\\n\\n![image](https://assets.leetcode.com/users/images/b06f77f0-507a-42ac-af35-04ebbd4a71b0_1644993113.5176115.jpeg)\\n\\n\\n2. Now, let the head be our `currNode`. That means the `node with value 1` is the currNode, and we have to swap it with the `node with value 2`. So for this, we will also have to keep track of the node previous to the currNode, let it be `prevNode`, as it\\'s next pointer value will have to change after we swap the currNode and the node next to currNode.\\n\\n![image](https://assets.leetcode.com/users/images/00a5d82c-ce1f-4d73-afb2-0ce20d23fb26_1644993239.638449.jpeg)\\n\\n3. Now the very first thing to do is change the `next pointer of prevNode to point to currNode->next`. Why?? Because in the answer we want the `node with value 2` after the dummyNode. Right? So we will have to connect `dummyNode` (prevNode) to the `node with value  2` (currNode->next). This means\\n```cpp\\nprevNode->next = currNode->next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5a4ce313-4f60-48f4-857d-ca141e48c103_1644993309.3371558.jpeg)\\n\\n\\n4. Now, in our finl answer `node with value 1` should be at the place of `node with value 2`. So the next pointer of `node with value 1` should point to whatever the `node with value 2` is pointing to originally. That means we will have to change `currNode->next` to the `next of next of prevNode`, as currently prevNode is dummyNode, prevNode->next is node with value 2 and prevNode->next->next = next of node with value 2. This means\\n```cpp\\ncurrNode->next = prevNode->next->next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e531a190-a0cd-4117-ab66-4c5ed08047d9_1644993389.8530746.jpeg)\\n\\n\\n5. Now, as in the answer the `node with value 2` should point to `node with value 1`. That means\\n```cpp\\nprevNode->next->next = currNode\\n```\\n\\n![image](https://assets.leetcode.com/users/images/11fda637-3c1c-4f41-82a5-598f41540429_1644993447.1567922.jpeg)\\n\\n\\n6. After this iteration, nodes 1 and 2 will get swapped and our linked list will look like this.\\n\\n![image](https://assets.leetcode.com/users/images/eba94308-ed4a-4542-aed6-ef8f4eb1f807_1644993522.337313.jpeg)\\n\\n\\n7. Now for the next iteration, we have to swap `nodes with values 3 and 4`. For that the `prevNode` should point to `node with value 1` and the `currNode` should point to `node with value 3`. This means\\n```cpp\\nprevNode = currNode\\ncurrNode = currNode->next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e73873b6-a236-4171-ac89-52f0c5d63164_1645010559.588748.jpeg)\\n\\n\\n\\n\\n8. We should stop this procedure when either there is no nodes left to swap or there is only one node left which cannot be swapped with any node.\\n\\n9. At the end, as we can see that our head of the list has been misplaced in the procedure of swapping, so we can return `dummyNode->next` to return the swapped linked list.\\n\\n\\n#### Code\\n```cpp\\nListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head; //If there are less than 2 nodes in the given nodes, then no need to do anything just return the list as it is.\\n\\t\\t\\n        ListNode* dummyNode = new ListNode();\\n        \\n        ListNode* prevNode=dummyNode;\\n        ListNode* currNode=head;\\n        \\n        while(currNode && currNode->next){\\n            prevNode->next = currNode->next;\\n            currNode->next = prevNode->next->next;\\n            prevNode->next->next = currNode;\\n            \\n            prevNode = currNode;\\n            currNode = currNode->next;\\n        }\\n        \\n        return dummyNode->next;\\n    }\\n\\n```\\n\\n#### Complexity:\\n***TC*** **= O(n)**\\n***SC*** **= O(1)**\\n\\n***Plz upvote if you liked the post***\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```cpp\\nprevNode->next = currNode->next\\n```\n```cpp\\ncurrNode->next = prevNode->next->next\\n```\n```cpp\\nprevNode->next->next = currNode\\n```\n```cpp\\nprevNode = currNode\\ncurrNode = currNode->next\\n```\n```cpp\\nListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head; //If there are less than 2 nodes in the given nodes, then no need to do anything just return the list as it is.\\n\\t\\t\\n        ListNode* dummyNode = new ListNode();\\n        \\n        ListNode* prevNode=dummyNode;\\n        ListNode* currNode=head;\\n        \\n        while(currNode && currNode->next){\\n            prevNode->next = currNode->next;\\n            currNode->next = prevNode->next->next;\\n            prevNode->next->next = currNode;\\n            \\n            prevNode = currNode;\\n            currNode = currNode->next;\\n        }\\n        \\n        return dummyNode->next;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774708,
                "title": "c-visual-image-how-links-change-explained-every-step-commented-code",
                "content": "***Brief note about Question-***\\n* We have to *swap every two adjacent nodes and return its head*.\\n```\\nLet\\'s take an example not given in question -\\nSuppose our head pointer given to us as [1,9,2,8,3,7]\\n\\nSo, we have to swap every two adjcant nodes,\\nthe answer should be [9,1,8,2,7,3]\\n```\\n_______________\\n***Solution - I (using recursion, Accepted)-***\\n* The very basic thing that is given to us is, **it is given in form of linked list**.\\n* We have a advantage by having linked list, How?\\n* For swapping every two adjcant nodes, we will be able to just change the link of nodes.\\n* See how we change links on the first example.\\n![image](https://assets.leetcode.com/users/images/53a7a769-ce39-4d7d-9e37-cd0420f72bf0_1644988593.5987253.jpeg)\\n\\n\\n* I have mention everything in image itself, and also add comment in code also, but if u have still doubt or suggestion,please put that in comment part.\\n ____________\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if head is NULL OR just having a single node, then no need to change anything \\n        if(head == NULL || head -> next == NULL) \\n        {\\n            return head;\\n        }\\n            \\n        ListNode* temp; // temporary pointer to store head -> next\\n        temp = head->next; // give temp what he want\\n        \\n        head->next = swapPairs(head->next->next); // changing links\\n        temp->next = head; // put temp -> next to head\\n        \\n        return temp; // now after changing links, temp act as our head\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our head pointer given to us as [1,9,2,8,3,7]\\n\\nSo, we have to swap every two adjcant nodes,\\nthe answer should be [9,1,8,2,7,3]\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if head is NULL OR just having a single node, then no need to change anything \\n        if(head == NULL || head -> next == NULL) \\n        {\\n            return head;\\n        }\\n            \\n        ListNode* temp; // temporary pointer to store head -> next\\n        temp = head->next; // give temp what he want\\n        \\n        head->next = swapPairs(head->next->next); // changing links\\n        temp->next = head; // put temp -> next to head\\n        \\n        return temp; // now after changing links, temp act as our head\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774318,
                "title": "python3-i-hate-linked-lists-not-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38-_-\\'), If you have any question, feel free to ask.**\\n\\nJust a bunch of placeholders, edge cases, and strange errors about a cycle meanwhile :(\\n\\nprev cur cur porev next cur prev pasdfaslfjgnzdsf;ljgfsdaz;lkjkfgn\\n\\nTime: **O(n)** - iterate\\nSpace: **O(1)**\\n\\n```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38-_-\\'), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 11030,
                "title": "my-accepted-java-code-used-recursion",
                "content": "    public class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if ((head == null)||(head.next == null))\\n                return head;\\n            ListNode n = head.next;\\n            head.next = swapPairs(head.next.next);\\n            n.next = head;\\n            return n;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if ((head == null)||(head.next == null))\\n                return head;\\n            ListNode n = head.next;\\n            head.next = swapPairs(head.next.next);\\n            n.next = head;\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11019,
                "title": "7-8-lines-c-python-ruby",
                "content": "Three different implementations of the same algorithm, taking advantage of different strengths of the three languages. I suggest reading all three, even if you don't know all three languages.\\n\\nAll three of course work swap the current node with the next node by rearranging pointers, then move on to the next pair, and repeat until the end of the list.\\n\\n---\\n\\n**C++**\\n\\nPointer-pointer `pp`  points to the pointer to the current node. So at first, `pp` points to `head`, and later it points to the `next` field of ListNodes. Additionally, for convenience and clarity, pointers `a` and `b` point to the current node and the next node.\\n\\nWe need to go from `*pp == a -> b -> (b->next)` to `*pp == b -> a -> (b->next)`. The first three lines inside the loop do that, setting those three pointers (from right to left). The fourth line moves `pp` to the next pair.\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode **pp = &head, *a, *b;\\n        while ((a = *pp) && (b = a->next)) {\\n            a->next = b->next;\\n            b->next = a;\\n            *pp = b;\\n            pp = &(a->next);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\n**Python**\\n\\nHere, `pre` is the previous node. Since the head doesn't have a previous node, I just use `self` instead. Again, `a` is the current node and `b` is the next node.\\n\\nTo go from `pre -> a -> b -> b.next` to `pre -> b -> a -> b.next`, we need to change those three references. Instead of thinking about in what order I change them, I just change all three at once.\\n\\n    def swapPairs(self, head):\\n        pre, pre.next = self, head\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return self.next\\n\\n---\\n\\n**Ruby**\\n\\nAgain, `pre` is the previous node, but here I create a dummy as previous node of the head. And again, `a` is the current node and `b` is the next node. This time I go one node further and call it `c`.\\n\\nTo go from `pre -> a -> b -> c` to `pre -> b -> a -> c`, we need to change those three references. Here I chain the assignments, pretty much directly saying \"`pre` points to `b`, which points to `a`, which points to `c`\".\\n\\n    def swap_pairs(head)\\n        pre = dummy = ListNode.new 0\\n        pre.next = head\\n        while a = pre.next and b = a.next\\n            c = b.next\\n            ((pre.next = b).next = a).next = c\\n            pre = a\\n        end\\n        dummy.next\\n    end",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Ruby"
                ],
                "code": "Three different implementations of the same algorithm, taking advantage of different strengths of the three languages. I suggest reading all three, even if you don't know all three languages.\\n\\nAll three of course work swap the current node with the next node by rearranging pointers, then move on to the next pair, and repeat until the end of the list.\\n\\n---\\n\\n**C++**\\n\\nPointer-pointer `pp`  points to the pointer to the current node. So at first, `pp` points to `head`, and later it points to the `next` field of ListNodes. Additionally, for convenience and clarity, pointers `a` and `b` point to the current node and the next node.\\n\\nWe need to go from `*pp == a -> b -> (b->next)` to `*pp == b -> a -> (b->next)`. The first three lines inside the loop do that, setting those three pointers (from right to left). The fourth line moves `pp` to the next pair.\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode **pp = &head, *a, *b;\\n        while ((a = *pp) && (b = a->next)) {\\n            a->next = b->next;\\n            b->next = a;\\n            *pp = b;\\n            pp = &(a->next);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\n**Python**\\n\\nHere, `pre` is the previous node. Since the head doesn't have a previous node, I just use `self` instead. Again, `a` is the current node and `b` is the next node.\\n\\nTo go from `pre -> a -> b -> b.next` to `pre -> b -> a -> b.next`, we need to change those three references. Instead of thinking about in what order I change them, I just change all three at once.\\n\\n    def swapPairs(self, head):\\n        pre, pre.next = self, head\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return self.next\\n\\n---\\n\\n**Ruby**\\n\\nAgain, `pre` is the previous node, but here I create a dummy as previous node of the head. And again, `a` is the current node and `b` is the next node. This time I go one node further and call it `c`.\\n\\nTo go from `pre -> a -> b -> c` to `pre -> b -> a -> c`, we need to change those three references. Here I chain the assignments, pretty much directly saying \"`pre` points to `b`, which points to `a`, which points to `c`\".\\n\\n    def swap_pairs(head)\\n        pre = dummy = ListNode.new 0\\n        pre.next = head\\n        while a = pre.next and b = a.next\\n            c = b.next\\n            ((pre.next = b).next = a).next = c\\n            pre = a\\n        end\\n        dummy.next\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 11046,
                "title": "my-simple-java-solution-for-share",
                "content": "    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode current = dummy;\\n        while (current.next != null && current.next.next != null) {\\n            ListNode first = current.next;\\n            ListNode second = current.next.next;\\n            first.next = second.next;\\n            current.next = second;\\n            current.next.next = first;\\n            current = current.next.next;\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode current = dummy;\\n        while (current.next != null && current.next.next != null) {\\n            ListNode first = current.next;\\n            ListNode second = current.next.next;\\n            first.next = second.next;\\n            current.next = second;\\n            current.next.next = first;\\n            current = current.next.next;\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 171788,
                "title": "python-dummynode",
                "content": "### 24. Swap Nodes in Pairs\\n\\n```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        cur = dummy\\n        \\n        while cur.next and cur.next.next:\\n            first = cur.next\\n            sec = cur.next.next\\n            cur.next = sec\\n            first.next = sec.next\\n            sec.next = first\\n            cur = cur.next.next\\n        return dummy.next       \\n```\\n![](https://raw.githubusercontent.com/yuzhoujr/spazzatura/master/img_box/24.jpg)\\n\\n#### Recursive\\n```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        new_start = head.next.next\\n        head, head.next = head.next, head\\n        head.next.next = self.swapPairs(new_start)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        cur = dummy\\n        \\n        while cur.next and cur.next.next:\\n            first = cur.next\\n            sec = cur.next.next\\n            cur.next = sec\\n            first.next = sec.next\\n            sec.next = first\\n            cur = cur.next.next\\n        return dummy.next       \\n```\n```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        new_start = head.next.next\\n        head, head.next = head.next, head\\n        head.next.next = self.swapPairs(new_start)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11271,
                "title": "simple-implementation-with-c",
                "content": "    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(head == NULL)\\n                return NULL;\\n            if(head->next == NULL)\\n                return head;\\n            \\n            ListNode* next = head->next;\\n            head->next = swapPairs(next->next);\\n            next->next = head;\\n            \\n            return next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(head == NULL)\\n                return NULL;\\n            if(head->next == NULL)\\n                return head;\\n            \\n            ListNode* next = head->next;\\n            head->next = swapPairs(next->next);\\n            next->next = head;\\n            \\n            return next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11183,
                "title": "c-solution-with-graph-explanation",
                "content": "    /*\\n           #---->@---->@---->@---->@---->@---->@\\n                       ^     ^\\n                       pre   cur\\n\\n          1. pre->next = cur->next\\n                        __________\\n                       /          \\\\\\n           #---->@---->@     @---->@---->@---->@\\n                       ^     ^\\n                       pre   cur\\n\\n          2. pre = pre->next\\n                        __________\\n                       /          \\\\\\n          #---->@---->@      @---->@---->@---->@\\n                             ^     ^\\n                             cur   pre\\n\\n          3. cur->next = pre->next\\n                        __________\\n                       /          \\\\\\n           #---->@---->@     @     @---->@---->@\\n                              \\\\_________/\\n                             ^     ^\\n                             cur   pre\\n\\n          4. pre->next = cur\\n                       __________\\n                      /          \\\\\\n          #---->@---->@     @<----@     @---->@\\n                             \\\\_________/\\n                            ^     ^\\n                            cur   pre\\n        \\n          5. pre = cur; cur = cur->next\\n                       __________\\n                      /          \\\\\\n          #---->@---->@     @<----@     @---->@\\n                             \\\\_________/\\n                            ^           ^\\n                            pre         cur\\n     */\\n    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(!head) return NULL;\\n            ListNode tmp(0);\\n            tmp.next = head;\\n            ListNode *pre = &tmp, *cur = head;\\n            while(cur && cur->next){\\n                pre->next = cur->next;\\n                pre = pre->next;\\n                cur->next = pre->next;\\n                pre->next = cur;\\n                pre = cur;\\n                cur = cur->next;\\n            }\\n            return tmp.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(!head) return NULL;\\n            ListNode tmp(0);\\n            tmp.next = head;\\n            ListNode *pre = &tmp, *cur = head;\\n            while(cur && cur->next){\\n                pre->next = cur->next;\\n                pre = pre->next;\\n                cur->next = pre->next;\\n                pre->next = cur;\\n                pre = cur;\\n                cur = cur->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 11312,
                "title": "python-concise-iterative-and-recursive-solutions",
                "content": "    # Iteratively\\n    def swapPairs1(self, head):\\n        dummy = p = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            tmp = head.next\\n            head.next = tmp.next\\n            tmp.next = head\\n            p.next = tmp\\n            head = head.next\\n            p = tmp.next\\n        return dummy.next\\n     \\n    # Recursively    \\n    def swapPairs(self, head):\\n        if head and head.next:\\n            tmp = head.next\\n            head.next = self.swapPairs(tmp.next)\\n            tmp.next = head\\n            return tmp\\n        return head",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "    # Iteratively\\n    def swapPairs1(self, head):\\n        dummy = p = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            tmp = head.next\\n            head.next = tmp.next\\n            tmp.next = head\\n            p.next = tmp\\n            head = head.next\\n            p = tmp.next\\n        return dummy.next\\n     \\n    # Recursively    \\n    def swapPairs(self, head):\\n        if head and head.next:\\n            tmp = head.next\\n            head.next = self.swapPairs(tmp.next)\\n            tmp.next = head\\n            return tmp\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 11111,
                "title": "java-simple-recursive-solution",
                "content": "Starting to see that recursion is the perfect tool for (many) linked list problems (this one + merging list problem).\\n\\n    /**\\n     * Definition for singly-linked list.\\n     * public class ListNode {\\n     *     int val;\\n     *     ListNode next;\\n     *     ListNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) return head;\\n            ListNode second = head.next;\\n            ListNode third = second.next;\\n            \\n            second.next = head;\\n            head.next = swapPairs(third);\\n            \\n            return second;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) return head;\\n            ListNode second = head.next;\\n            ListNode third = second.next;\\n            \\n            second.next = head;\\n            head.next = swapPairs(third);\\n            \\n            return second;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 344445,
                "title": "c-recursive-solution-faster-than-100-of-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp;\\n        temp = head->next;\\n        head->next = swapPairs(head->next->next);\\n        temp->next = head;\\n        \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp;\\n        temp = head->next;\\n        head->next = swapPairs(head->next->next);\\n        temp->next = head;\\n        \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11223,
                "title": "javascript-solution-beats-94-44-of-all-submissions",
                "content": "    var swapPairs = function(head) {\\n        if(!head || !head.next) return head;\\n        var v1 = head, v2 = head.next, v3 = v2.next;\\n        v2.next = v1;\\n        v1.next = swapPairs(v3);\\n        return v2;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var swapPairs = function(head) {\\n        if(!head || !head.next) return head;\\n        var v1 = head, v2 = head.next, v3 = v2.next;\\n        v2.next = v1;\\n        v1.next = swapPairs(v3);\\n        return v2;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3528791,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for first 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# Video Solution\\n\\n# Search \\uD83D\\uDC49 `Swap Nodes in Pairs by Tech Wired`\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\nThe approach used in the code is to traverse the linked list and swap adjacent pairs of nodes. This is done iteratively by maintaining a current pointer that points to the previous node before the pair to be swapped. The swapping is done by modifying the next pointers of the nodes.\\n\\n# Intuition:\\nThe intuition behind the code is to break down the problem into smaller subproblems. By swapping two nodes at a time, we can gradually swap adjacent pairs throughout the linked list. This is achieved by manipulating the next pointers of the nodes.\\n\\nThe use of a dummy node helps in handling the edge case where the head of the list needs to be swapped. It serves as a placeholder for the new head of the modified list.\\n\\nThe while loop iterates as long as there are at least two nodes remaining in the list. In each iteration, the current pair of nodes is swapped by adjusting the next pointers accordingly.\\n\\n\\n\\n```Python []\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not head or not head.next: return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        curr = dummy\\n\\n        while curr.next and curr.next.next:\\n            first = curr.next\\n            second = curr.next.next\\n            curr.next = second\\n            first.next = second.next\\n            second.next = first\\n            curr = curr.next.next\\n        \\n        return dummy.next\\n```\\n```Java []\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode curr = dummy;\\n        \\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode first = curr.next;\\n            ListNode second = curr.next.next;\\n            curr.next = second;\\n            first.next = second.next;\\n            second.next = first;\\n            curr = curr.next.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = dummy;\\n        \\n        while (curr->next != nullptr && curr->next->next != nullptr) {\\n            ListNode* first = curr->next;\\n            ListNode* second = curr->next->next;\\n            curr->next = second;\\n            first->next = second->next;\\n            second->next = first;\\n            curr = curr->next->next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List"
                ],
                "code": "```Python []\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not head or not head.next: return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        curr = dummy\\n\\n        while curr.next and curr.next.next:\\n            first = curr.next\\n            second = curr.next.next\\n            curr.next = second\\n            first.next = second.next\\n            second.next = first\\n            curr = curr.next.next\\n        \\n        return dummy.next\\n```\n```Java []\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode curr = dummy;\\n        \\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode first = curr.next;\\n            ListNode second = curr.next.next;\\n            curr.next = second;\\n            first.next = second.next;\\n            second.next = first;\\n            curr = curr.next.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = dummy;\\n        \\n        while (curr->next != nullptr && curr->next->next != nullptr) {\\n            ListNode* first = curr->next;\\n            ListNode* second = curr->next->next;\\n            curr->next = second;\\n            first->next = second->next;\\n            second->next = first;\\n            curr = curr->next->next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11028,
                "title": "my-straight-forward-java-solution-without-recursion-or-dummy-nodes-0ms",
                "content": "- The idea is straightforward: use two pointers and swap\\n - `a.next = b.next`, `b.next = a`.\\n - Then continue the next pair, `b = a.next.next`, `a=a.next`\\n - Remember to check `null`\\n - Remember to track new `head`\\n - Remember to link the new pair after the prior nodes. \\n\\nAttached is the accepted code.\\n\\n\\n    public class Solution {\\n      public ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode newHead = head.next, a=head,b=a.next,pre = null;\\n        while(a!=null && b!=null){\\n          a.next = b.next;\\n          b.next = a;\\n          if(pre!=null) pre.next = b;\\n          if(a.next==null) break;\\n          b = a.next.next;\\n          pre = a;\\n          a = a.next;\\n        }\\n        return newHead;\\n      }\\n    }\\n\\n- AC, 0ms",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode newHead = head.next, a=head,b=a.next,pre = null;\\n        while(a!=null && b!=null){\\n          a.next = b.next;\\n          b.next = a;\\n          if(pre!=null) pre.next = b;\\n          if(a.next==null) break;\\n          b = a.next.next;\\n          pre = a;\\n          a = a.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 486804,
                "title": "python-simple-solution-memory-usage-less-than-100",
                "content": "Given:\\n**prev->a->b->c**\\n\\nChange it to:\\n**prev->b->a->c**\\n\\nSince the first node does not have any previous node, we create a dummy node at the beginning.\\n\\n```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n\\t\\t\\n        while prev.next and prev.next.next:\\n            a = prev.next\\n            b = prev.next.next\\n            c = prev.next.next.next\\n            prev.next = b\\n            prev.next.next = a\\n            prev.next.next.next = c\\n            prev = prev.next.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n\\t\\t\\n        while prev.next and prev.next.next:\\n            a = prev.next\\n            b = prev.next.next\\n            c = prev.next.next.next\\n            prev.next = b\\n            prev.next.next = a\\n            prev.next.next.next = c\\n            prev = prev.next.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11320,
                "title": "my-simple-recursive-solution",
                "content": "My solution is quite simple. Just find the reverse job is the same for every 2 nodes.\\n\\n    public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }\\n            \\n            ListNode newhd = head.next;\\n            head.next = swapPairs(newhd.next);\\n            newhd.next = head;\\n            return newhd;\\n    }",
                "solutionTags": [],
                "code": "My solution is quite simple. Just find the reverse job is the same for every 2 nodes.\\n\\n    public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }\\n            \\n            ListNode newhd = head.next;\\n            head.next = swapPairs(newhd.next);\\n            newhd.next = head;\\n            return newhd;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 265325,
                "title": "java-recursive-solution-beats-100-with-explanation",
                "content": "The idea is simple:\\neach we take two first elements of (sub)sequence, swap them using two additional variables, and call the function recursively from the tail. For example:\\n![image](https://assets.leetcode.com/users/olsh/image_1553979740.png)\\n\\nThe code of this solution:\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next==null)return head;\\n        ListNode tempNext = head.next.next;\\n        ListNode tempFirst = head.next;\\n        ListNode tempSecond = head;\\n        head = tempFirst;\\n        head.next = tempSecond;\\n        head.next.next = swapPairs(tempNext);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next==null)return head;\\n        ListNode tempNext = head.next.next;\\n        ListNode tempFirst = head.next;\\n        ListNode tempSecond = head;\\n        head = tempFirst;\\n        head.next = tempSecond;\\n        head.next.next = swapPairs(tempNext);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11331,
                "title": "4ms-easy-c-iterative-solution",
                "content": "Well, since the `head` pointer may also been modified, we create a `new_head` that points to it to facilitate the swapping process.\\n\\nFor the example list `1 -> 2 -> 3 -> 4` in the problem statement, it will become `0 -> 1 -> 2 -> 3 -> 4` (we init `new_head -> val` to be `0`). Then we set a pointer `pre` to `new_head` and another `cur` to `head`. Each time, we will swap `pre -> next` and `cur -> next` using the following piece of code.\\n\\n    pre -> next = cur -> next;\\n    cur -> next = cur -> next -> next;\\n    pre -> next -> next = cur;\\n\\nAfter swapping them, we update as follows:\\n\\n    pre = cur; \\n    cur = pre -> next; \\n\\nto swap the next two nodes.\\n\\nFinally, we return `new_head -> next`.\\n\\nThe complete code is as follows.\\n\\n    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) { \\n            if (!head || !(head -> next)) return head;\\n            ListNode* new_head = new ListNode(0);\\n            new_head -> next = head;\\n            ListNode* pre = new_head; \\n            ListNode* cur = head;\\n            while (pre -> next && cur -> next) {\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = cur;\\n                pre = cur;\\n                cur = pre -> next;\\n            }\\n            return new_head -> next;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) { \\n            if (!head || !(head -> next)) return head;\\n            ListNode* new_head = new ListNode(0);\\n            new_head -> next = head;\\n            ListNode* pre = new_head; \\n            ListNode* cur = head;\\n            while (pre -> next && cur -> next) {\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = cur;\\n                pre = cur;\\n                cur = pre -> next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 486026,
                "title": "java-0-ms-beating-100-simple-iterative-solution-with-diagram-and-explanation",
                "content": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        ListNode prevNode = new ListNode(0);    //Node situated before the two to-be-swapped nodes\\n        prevNode.next = head;                   //Starting before head\\n        ListNode newHead = prevNode;            //Storing a reference for returning\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null){\\n            \\n            //Declare                                           // ...[prev]-->[node1]-->[node2]-->[next]...\\n            ListNode node1 = prevNode.next;                     \\n            ListNode node2 = node1.next;\\n            ListNode nextNode = node2.next;\\n            \\n            //Swap\\n            prevNode.next = node2;                              // ...[prev]-->[node2]<--[node1]   [next]...\\n            node2.next = node1;                                 // ...[prev]-->[node2]<-->[node1]  [next]...\\n            node1.next = nextNode;                              // ...[prev]-->[node2]-->[node1]-->[next]...\\n            \\n            //Move \\n            prevNode = node1;                                   // ...[...]-->[node2]-->[node1/prev]-->[next]...\\n        }\\n        \\n        return newHead.next;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        ListNode prevNode = new ListNode(0);    //Node situated before the two to-be-swapped nodes\\n        prevNode.next = head;                   //Starting before head\\n        ListNode newHead = prevNode;            //Storing a reference for returning\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null){\\n            \\n            //Declare                                           // ...[prev]-->[node1]-->[node2]-->[next]...\\n            ListNode node1 = prevNode.next;                     \\n            ListNode node2 = node1.next;\\n            ListNode nextNode = node2.next;\\n            \\n            //Swap\\n            prevNode.next = node2;                              // ...[prev]-->[node2]<--[node1]   [next]...\\n            node2.next = node1;                                 // ...[prev]-->[node2]<-->[node1]  [next]...\\n            node1.next = nextNode;                              // ...[prev]-->[node2]-->[node1]-->[next]...\\n            \\n            //Move \\n            prevNode = node1;                                   // ...[...]-->[node2]-->[node1/prev]-->[next]...\\n        }\\n        \\n        return newHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11175,
                "title": "c-recursive-and-iterative-solutions",
                "content": "    \\n    // recursively\\n    ListNode* swapPairs1(ListNode* head) {\\n        if (!head || !(head->next))\\n            return head;\\n        ListNode *res = head->next;\\n        head->next = swapPairs(res->next);\\n        res->next = head;\\n        return res;\\n    }\\n    \\n    // iteratively\\n    ListNode *swapPairs(ListNode *head) {\\n        ListNode *dummy = new ListNode(0), *node;\\n        node = dummy;\\n        dummy->next = head;\\n        while (head && head->next) {\\n            ListNode *nxt = head->next;\\n            head->next = nxt->next;\\n            nxt->next = head;\\n            node->next = nxt;\\n            node = head;\\n            head = node->next;\\n        }\\n        return dummy->next;\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Iterator"
                ],
                "code": "    \\n    // recursively\\n    ListNode* swapPairs1(ListNode* head) {\\n        if (!head || !(head->next))\\n            return head;\\n        ListNode *res = head->next;\\n        head->next = swapPairs(res->next);\\n        res->next = head;\\n        return res;\\n    }\\n    \\n    // iteratively\\n    ListNode *swapPairs(ListNode *head) {\\n        ListNode *dummy = new ListNode(0), *node;\\n        node = dummy;\\n        dummy->next = head;\\n        while (head && head->next) {\\n            ListNode *nxt = head->next;\\n            head->next = nxt->next;\\n            nxt->next = head;\\n            node->next = nxt;\\n            node = head;\\n            head = node->next;\\n        }\\n        return dummy->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3529293,
                "title": "c-easy-recursion",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp=swapPairs(head->next->next);\\n        ListNode* t=head;\\n        head=head->next;\\n        head->next=t;\\n        head->next->next=temp;\\n        return head;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/425d38ef-1ecd-4fe2-966c-1df715fb51d0_1684210746.862829.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp=swapPairs(head->next->next);\\n        ListNode* t=head;\\n        head=head->next;\\n        head->next=t;\\n        head->next->next=temp;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529474,
                "title": "easy-solution-beginner-friendly-easy-to-understand-beats-100-java-python-3-c-js-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the list and swap pairs of nodes one by one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The node \"ans\" is to point to the head of the original list. It then uses a \"curr\" node to traverse the list and swap pairs of nodes. The loop continues as long as there are at least two more nodes to swap.\\n\\n- Inside the loop, the solution uses two temporary nodes, \"t1\" and \"t2\", to hold the first and second nodes of the pair. Then, it updates the pointers to swap the nodes, and moves \"curr\" two nodes ahead. At the end, it returns the modified list starting from the next node of the  \"ans\" node.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n          if (head == null || head.next == null) {\\n            return head;\\n        }\\n    ListNode ans =new ListNode(0);\\n    ans.next=head;\\n    ListNode curr=ans;\\n   while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }  \\n      return ans.next;\\n    }\\n}\\n```\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        \\n        ans = ListNode(0)\\n        ans.next = head\\n        curr = ans\\n        \\n        while curr.next and curr.next.next:\\n            t1 = curr.next\\n            t2 = curr.next.next\\n            curr.next = t2\\n            t1.next = t2.next\\n            t2.next = t1\\n            curr = curr.next.next\\n        \\n        return ans.next\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n    }\\n};\\n```\\n```Javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    let ans = new ListNode(0);\\n    ans.next = head;\\n    let curr = ans;\\n    while (curr.next != null && curr.next.next != null) {\\n        let t1 = curr.next;\\n        let t2 = curr.next.next;\\n        curr.next = t2;\\n        t1.next = t2.next;\\n        t2.next = t1;\\n        curr = curr.next.next;\\n    }\\n    return ans.next;\\n};\\n```\\n```C# []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode ans = new ListNode(0);\\n        ans.next = head;\\n        ListNode curr = ans;\\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }\\n        return ans.next;    \\n    }\\n}\\n```\\n```Kotlin []\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n         if (head == null || head.next == null) {\\n            return head\\n        }\\n        val ans = ListNode(0)\\n        ans.next = head\\n        var curr: ListNode? = ans\\n        while (curr?.next != null && curr.next?.next != null) {\\n            val t1 = curr.next\\n            val t2 = curr.next?.next\\n            curr.next = t2\\n            t1.next = t2?.next\\n            t2?.next = t1\\n            curr = curr.next?.next\\n        }\\n        return ans.next\\n    }\\n}\\n```\\n```C []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n}\\n```\\n\\nUPVOTES ARE ENCOURAGING!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n          if (head == null || head.next == null) {\\n            return head;\\n        }\\n    ListNode ans =new ListNode(0);\\n    ans.next=head;\\n    ListNode curr=ans;\\n   while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }  \\n      return ans.next;\\n    }\\n}\\n```\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        \\n        ans = ListNode(0)\\n        ans.next = head\\n        curr = ans\\n        \\n        while curr.next and curr.next.next:\\n            t1 = curr.next\\n            t2 = curr.next.next\\n            curr.next = t2\\n            t1.next = t2.next\\n            t2.next = t1\\n            curr = curr.next.next\\n        \\n        return ans.next\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n    }\\n};\\n```\n```Javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    let ans = new ListNode(0);\\n    ans.next = head;\\n    let curr = ans;\\n    while (curr.next != null && curr.next.next != null) {\\n        let t1 = curr.next;\\n        let t2 = curr.next.next;\\n        curr.next = t2;\\n        t1.next = t2.next;\\n        t2.next = t1;\\n        curr = curr.next.next;\\n    }\\n    return ans.next;\\n};\\n```\n```C# []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode ans = new ListNode(0);\\n        ans.next = head;\\n        ListNode curr = ans;\\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }\\n        return ans.next;    \\n    }\\n}\\n```\n```Kotlin []\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n         if (head == null || head.next == null) {\\n            return head\\n        }\\n        val ans = ListNode(0)\\n        ans.next = head\\n        var curr: ListNode? = ans\\n        while (curr?.next != null && curr.next?.next != null) {\\n            val t1 = curr.next\\n            val t2 = curr.next?.next\\n            curr.next = t2\\n            t1.next = t2?.next\\n            t2?.next = t1\\n            curr = curr.next?.next\\n        }\\n        return ans.next\\n    }\\n}\\n```\n```C []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656816,
                "title": "solution-swift-swap-nodes-in-pairs-test-cases",
                "content": "```swift\\nclass Solution {\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        var head = head, node = head, pre: ListNode?\\n        \\n        while node != nil, let next = node!.next {\\n            let cur = next, tmp = cur.next\\n            pre == nil ? (head = cur) : (pre!.next = cur)\\n            cur.next = node\\n            node!.next = tmp\\n            pre = node\\n            node = tmp\\n        }\\n        return head\\n    }\\n}\\n```\\n\\n---\\n\\n<p><details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.swapPairs(ListNode([1,2,3,4]))\\n        XCTAssertEqual(value?.val, ListNode([2,1,4,3])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.swapPairs(ListNode([]))\\n        XCTAssertEqual(value?.val, ListNode([])?.val)\\n    }\\n    \\n    func test2() {\\n        let value = solution.swapPairs(ListNode([1]))\\n        XCTAssertEqual(value?.val, ListNode([1])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>\\n\\n<p><details>\\n<summary>\\n<b>ListNode</b>\\n</summary>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n\\n\\tpublic init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        var head = head, node = head, pre: ListNode?\\n        \\n        while node != nil, let next = node!.next {\\n            let cur = next, tmp = cur.next\\n            pre == nil ? (head = cur) : (pre!.next = cur)\\n            cur.next = node\\n            node!.next = tmp\\n            pre = node\\n            node = tmp\\n        }\\n        return head\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.swapPairs(ListNode([1,2,3,4]))\\n        XCTAssertEqual(value?.val, ListNode([2,1,4,3])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.swapPairs(ListNode([]))\\n        XCTAssertEqual(value?.val, ListNode([])?.val)\\n    }\\n    \\n    func test2() {\\n        let value = solution.swapPairs(ListNode([1]))\\n        XCTAssertEqual(value?.val, ListNode([1])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n\\n\\tpublic init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984266,
                "title": "c-c-simple-short-and-easy-recursive-solution-0ms-faster-than-100",
                "content": "```\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if ((!head) || (!head->next))\\n        return head;\\n    \\n    struct ListNode* tmp = head;\\n    head = head->next;\\n    tmp->next = head->next;\\n    head->next = tmp;\\n    \\n    head->next->next = swapPairs(head->next->next);\\n    return head;\\n}\\n```\\n**Like it? please upvote!\\nHave any comments? I\\'d love to hear...**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if ((!head) || (!head->next))\\n        return head;\\n    \\n    struct ListNode* tmp = head;\\n    head = head->next;\\n    tmp->next = head->next;\\n    head->next = tmp;\\n    \\n    head->next->next = swapPairs(head->next->next);\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1163702,
                "title": "python3-simple-recursive-solution-beats-95-00-easily-understandable-with-figure-explanation",
                "content": "## Idea\\n**Recursion**\\n- Base case: list is empty or contains only one node. (In this case there\\'s no need to swap anything)\\n- Recursive case: If the nodes after the first two nodes are already done swapping in pairs,  we just need to swap the first two nodes and then we\\'re done!\\n\\n## Implementation\\n\\n```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # recursive case\\n        _next = head.next\\n        head.next = self.swapPairs(_next.next)\\n        _next.next = head\\n        \\n        return _next\\n```\\n\\n## Visualization\\n\\n![image](https://assets.leetcode.com/users/images/399f06f6-0361-4b86-a29d-823f0d42a04a_1618696569.132693.png)\\n\\n## Complexity\\n- Time: O(n)\\n- Space: O(n)\\n\\n\\nIf you think this is helpful, please give it a vote.\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # recursive case\\n        _next = head.next\\n        head.next = self.swapPairs(_next.next)\\n        _next.next = head\\n        \\n        return _next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984392,
                "title": "python-o-n-solution-explained",
                "content": "As with a lot of other linked lists, it is good idea to add dummy node before list to avoid cases. Imagine, we have list `1, 2, 3, 4, 5, 6`, let us add `0` node in the beginning, so we have `0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6` now.\\n\\nNow, let us look at the main step of algorithm (for simplicity I will call nodes by its values)\\n1. `pre = 0`, whe check if `pre.next` and `pre.next.next` exists, they are, so define `a = 1` and `b = 2`.\\n2. Now, we need to rewrite links: `0 -> 2`, `2 -> 1` and `1 -> 3`. Note, that we do it all in one step.\\n3. Finally, we say, that `pre = 1`. Also, our list now looks like `0 -> 2 -> 1 -> 3 -> 4 -> 5 -> 6` and as I said `pre = 1` now, so we swapped first two elements and now we on element number 2, which is exaclty what we have previously for smaller list.\\n4. On next step we have `0 -> 2 -> 1 -> 4 -> 3 -> 5 -> 6` and finally `0 -> 2 -> 1 -> 4 -> 3 -> 6 -> 5`, this is exaclty what we need to return.\\n\\n**Complexity**: time complexity is `O(n)`: we iterate over our list once, space complexity is `O(1)`: we did not add any new space and reused already existing nodes.\\n\\n```\\nclass Solution:\\n    def swapPairs(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        pre = dummy\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        pre = dummy\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774508,
                "title": "c-easy-to-understand-short-simple-10-lines",
                "content": "# 24. Swap Nodes in Pairs\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n         ListNode* p = head;   // p pointing to head\\n        ListNode* res = head->next; // res is pointed to head -> next\\n        ListNode* q; ListNode* temp; // temporary nodes for links updation\\n        \\n        while(true)\\n        {\\n\\t\\t// for eg 1 2 3 4\\n\\t\\t//this iteration temp is point to 3 and 2 -> 1 will be acheived \\n\\t\\t// more explanation read after end of code\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n\\t\\t// if statement of temp won\\'t execute \\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n       \\n    }\\n};\\n```\\n\\n```\\n{\\n// 1\\'s link with 4 will extablished & value of temp i.e 3 will be stored in p.\\n\\n// now p contains 3 that points to 4.\\n\\n// Same way 2nd iteration will execute and 3->4 will turn into 4->3\\n\\n// if statement inside while loop will execute as temp has become null, \\n\\n// p->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n\\n// return res , which will give 2 -> 1 -> 4 -> 3 -> NULL\\n}\\n```\\n\\n**ANOTHER APPROACH BY SWAPPING VALUES**\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n        ListNode* temp = head;    // temporary pointer so that we don\\'t loose reference to head\\n        \\n        while(temp)        // while temp != NULL\\n        {\\n            if(temp->next != NULL)       \\n            {\\n\\t\\t\\t   // if list contain odd no of nodes than at last node the temp->next,\\n\\t\\t\\t   //will be pointing to null and the code crashes, as there is no other node,\\n\\t\\t\\t   // to perform swap opearation\\n                swap(temp->val, temp->next->val);    // swap with the adjacent node\\n                temp = temp->next->next;                 //incrementing pointer with 2 step\\n            }\\n\\t\\t\\t\\telse    // break because last pair of list is odd \\n\\t\\t\\t\\t\\tbreak;\\n        }\\n        \\n        return head;    // return head\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n         ListNode* p = head;   // p pointing to head\\n        ListNode* res = head->next; // res is pointed to head -> next\\n        ListNode* q; ListNode* temp; // temporary nodes for links updation\\n        \\n        while(true)\\n        {\\n\\t\\t// for eg 1 2 3 4\\n\\t\\t//this iteration temp is point to 3 and 2 -> 1 will be acheived \\n\\t\\t// more explanation read after end of code\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n\\t\\t// if statement of temp won\\'t execute \\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n       \\n    }\\n};\\n```\n```\\n{\\n// 1\\'s link with 4 will extablished & value of temp i.e 3 will be stored in p.\\n\\n// now p contains 3 that points to 4.\\n\\n// Same way 2nd iteration will execute and 3->4 will turn into 4->3\\n\\n// if statement inside while loop will execute as temp has become null, \\n\\n// p->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n\\n// return res , which will give 2 -> 1 -> 4 -> 3 -> NULL\\n}\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n        ListNode* temp = head;    // temporary pointer so that we don\\'t loose reference to head\\n        \\n        while(temp)        // while temp != NULL\\n        {\\n            if(temp->next != NULL)       \\n            {\\n\\t\\t\\t   // if list contain odd no of nodes than at last node the temp->next,\\n\\t\\t\\t   //will be pointing to null and the code crashes, as there is no other node,\\n\\t\\t\\t   // to perform swap opearation\\n                swap(temp->val, temp->next->val);    // swap with the adjacent node\\n                temp = temp->next->next;                 //incrementing pointer with 2 step\\n            }\\n\\t\\t\\t\\telse    // break because last pair of list is odd \\n\\t\\t\\t\\t\\tbreak;\\n        }\\n        \\n        return head;    // return head\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751194,
                "title": "javascript-iterative-time-o-n-space-o-1-explanation",
                "content": "```\\nvar swapPairs = function(head) {\\n    // Store head to return list, Only instance of new data so space is O(1)\\n    let dummy = new ListNode(-1);\\n    dummy.next = head;\\n    \\n    let prev = dummy\\n    \\n    // Traverse list\\n    while (head && head.next) {\\n        \\n    // Declare\\n    let n1 = head\\n    let n2 = head.next\\n        \\n        // Swap\\n        prev.next = n2\\n        n1.next = n2.next\\n        n2.next = n1\\n        \\n        // Assign\\n        prev = n1\\n        head = n1.next\\n    }\\n    \\n    // The variable prev has been used to create the dummy list. dummy.next is still the head of new list\\n    return dummy.next;\\n};\\n```\\ntime: O(n)\\nspace: O(1)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar swapPairs = function(head) {\\n    // Store head to return list, Only instance of new data so space is O(1)\\n    let dummy = new ListNode(-1);\\n    dummy.next = head;\\n    \\n    let prev = dummy\\n    \\n    // Traverse list\\n    while (head && head.next) {\\n        \\n    // Declare\\n    let n1 = head\\n    let n2 = head.next\\n        \\n        // Swap\\n        prev.next = n2\\n        n1.next = n2.next\\n        n2.next = n1\\n        \\n        // Assign\\n        prev = n1\\n        head = n1.next\\n    }\\n    \\n    // The variable prev has been used to create the dummy list. dummy.next is still the head of new list\\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 233501,
                "title": "rust-0ms-100",
                "content": "```\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        head.and_then(|mut n| {\\n            match n.next {\\n                Some(mut m) => {\\n                    n.next = Solution::swap_pairs(m.next);\\n                    m.next = Some(n);\\n                    Some(m)\\n                },\\n                None => Some(n)\\n            }\\n        })\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        head.and_then(|mut n| {\\n            match n.next {\\n                Some(mut m) => {\\n                    n.next = Solution::swap_pairs(m.next);\\n                    m.next = Some(n);\\n                    Some(m)\\n                },\\n                None => Some(n)\\n            }\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481145,
                "title": "go-many-clean-solutions-with-images-in-go-golang-0ms-100",
                "content": "Hello Gophers!\\n\\nStart:\\n![swap-nodes-start.png](https://assets.leetcode.com/users/images/f5bbe08e-42e8-42ce-9977-d5f2a58bc653_1690834893.7782896.png)\\n\\nSwap:\\n\\n![swap-nodes-swap.png](https://assets.leetcode.com/users/images/7085cfe8-e298-435b-bc12-739668f3580f_1690834907.7661934.png)\\n\\nEnd:\\n![swap-nodes-end.png](https://assets.leetcode.com/users/images/78c9effb-98e4-4594-b2ff-b91bce480211_1690834920.5882404.png)\\n\\n\\n## Solution 1: Recursive (Easy-Medium)\\n\\nCleaner, but worst space complexity.\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(n)` (recursion)\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\thead, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n\\n\\treturn head\\n}\\n\\n```\\n\\nor\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head != nil && head.Next != nil {\\n        head, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n    }\\n    return head\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fb93b1d2-41f9-44b6-a05d-f24d58f76c8f_1661481740.6021497.jpeg)\\n![image](https://assets.leetcode.com/users/images/edacf671-cf94-4da0-8569-d55c1d682b51_1661481740.3160453.jpeg)\\n\\n\\n## Solution 2: Iterative (Medium-Hard)\\n\\n\\nIteration (`for` loop) instead of recursivity (function calling itself).  \\nUglier (imo), but better space complexity.\\n\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(1)`\\n\\n### Solution 2.1: with temp nodes (Medium)\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\n### Solution 2.2: Without temp nodes (Hard)\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nHow did I get to solution 2.2?\\n\\nStart:\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nRemove \"temp nodes\" `firstNode` and `secondNode`:\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tprev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nBut because `prev` can be nil:\\n\\n```go\\nif prev != nil {\\n    prev.Next = secondNode\\n}\\n```\\n\\nWe need a \"first step\":\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n    // Start\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\n    // Firtst Step (prev is nil)\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\n    // All Next Steps\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nIt works \\uD83E\\uDD2F\\n\\nStart:\\n![swap-nodes-1.png](https://assets.leetcode.com/users/images/d5342873-a9b1-4b5e-938d-7294231bcf9e_1690831346.3609188.png)\\n\\nFirst iteration:\\n![swap-nodes-2.png](https://assets.leetcode.com/users/images/6f6aa2b9-35b1-48eb-abd2-06e701276bca_1690831364.0310698.png)\\n\\nTODO: Finish this\\n\\nI hope it helped!",
                "solutionTags": [
                    "Go",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\thead, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n\\n\\treturn head\\n}\\n\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head != nil && head.Next != nil {\\n        head, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n    }\\n    return head\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tprev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nif prev != nil {\\n    prev.Next = secondNode\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n    // Start\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\n    // Firtst Step (prev is nil)\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\n    // All Next Steps\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3517577,
                "title": "c-java-python-javascript-swapping-nodes-fully-explained",
                "content": "# Approach\\n\\n1. Check if the list is empty or contains only one node. If so, there is no need to perform any swaps, so the original head is returned.\\n2. Initialize three pointers: `newHead` to store the new head after swapping, `prev` to keep track of the previous node, and `curr` to iterate through the list.\\n3. Enter a loop that continues as long as both `curr` and `curr->next` are not null.\\n4. Inside the loop, create a pointer `next` to store the next node after `curr`.\\n5. Update the next pointers of `curr` and `next` to perform the swap. Set `curr->next` to `next->next` to connect `curr` with the next pair of nodes.\\n6. Set `next->next` to `curr` to swap the positions of `curr` and `next`.\\n7. If `prev` is not null, update its `next` pointer to `next` to connect the previous pair with the swapped pair.\\n8. Update `prev` to `curr` and `curr` to `curr->next` to move forward in the list.\\n9. After the loop ends, return `newHead`, which stores the new head of the swapped list.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the linked list. This is because the algorithm iterates through the list once. The space complexity is O(1) because it uses a constant amount of additional space to store the pointers.\\n\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (!head || !head->next) {\\n            return head;\\n        }\\n        ListNode* newHead = head->next;\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        \\n        while (curr && curr->next) {\\n            ListNode* next = curr->next;\\n            curr->next = next->next;\\n            next->next = curr;\\n            \\n            if (prev) {\\n                prev->next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n```\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode newHead = head.next;\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while (curr != null && curr.next != null) {\\n            ListNode next = curr.next;\\n            curr.next = next.next;\\n            next.next = curr;\\n            \\n            if (prev != null) {\\n                prev.next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        \\n        return newHead;\\n    }\\n}\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        new_head = head.next\\n        prev = None\\n        curr = head\\n        \\n        while curr and curr.next:\\n            next = curr.next\\n            curr.next = next.next\\n            next.next = curr\\n            \\n            if prev:\\n                prev.next = next\\n            \\n            prev = curr\\n            curr = curr.next\\n        \\n        return new_head\\n```\\n---\\n# JavaScript\\n```\\nvar swapPairs = function(head) {\\n    if (!head || !head.next) {\\n        return head;\\n    }\\n    \\n    var newHead = head.next;\\n    var prev = null;\\n    var curr = head;\\n    \\n    while (curr && curr.next) {\\n        var next = curr.next;\\n        curr.next = next.next;\\n        next.next = curr;\\n        \\n        if (prev) {\\n            prev.next = next;\\n        }\\n        \\n        prev = curr;\\n        curr = curr.next;\\n    }\\n    \\n    return newHead;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (!head || !head->next) {\\n            return head;\\n        }\\n        ListNode* newHead = head->next;\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        \\n        while (curr && curr->next) {\\n            ListNode* next = curr->next;\\n            curr->next = next->next;\\n            next->next = curr;\\n            \\n            if (prev) {\\n                prev->next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode newHead = head.next;\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while (curr != null && curr.next != null) {\\n            ListNode next = curr.next;\\n            curr.next = next.next;\\n            next.next = curr;\\n            \\n            if (prev != null) {\\n                prev.next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        \\n        return newHead;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        new_head = head.next\\n        prev = None\\n        curr = head\\n        \\n        while curr and curr.next:\\n            next = curr.next\\n            curr.next = next.next\\n            next.next = curr\\n            \\n            if prev:\\n                prev.next = next\\n            \\n            prev = curr\\n            curr = curr.next\\n        \\n        return new_head\\n```\n```\\nvar swapPairs = function(head) {\\n    if (!head || !head.next) {\\n        return head;\\n    }\\n    \\n    var newHead = head.next;\\n    var prev = null;\\n    var curr = head;\\n    \\n    while (curr && curr.next) {\\n        var next = curr.next;\\n        curr.next = next.next;\\n        next.next = curr;\\n        \\n        if (prev) {\\n            prev.next = next;\\n        }\\n        \\n        prev = curr;\\n        curr = curr.next;\\n    }\\n    \\n    return newHead;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774796,
                "title": "java-0ms-recursive-code-faster-than-100-of-the-solutions-with-comments",
                "content": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        /**\\n        * The base condition will be triggered when there is no node left or there is just 1 node.\\n        * If there is just 1 node left, there is nothing that can be swapped, hence we return the node\\n        * itself.\\n        */\\n        if(head == null || head.next == null) return head;\\n        \\n        /**\\n        * If there are more than 1 nodes remaining, we would recursively call the method by passing the\\n        * next.next element.\\n        * This is because we would be swapping the head and the head.next element.\\n        * So, to call the method we would pass the head.next.next element.\\n        * This call will return a head which we would have to attach it to the current head.next element,\\n        AFTER SWAPPING.\\n        */\\n        ListNode tHead = swapPairs(head.next.next);\\n        \\n        /**\\n        * Here, we would write the swapping logic.\\n        * The node which is returned from the above line of code, will be connected with the nodes after\\n        * swapping here.\\n        */\\n        \\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        /**\\n        * The base condition will be triggered when there is no node left or there is just 1 node.\\n        * If there is just 1 node left, there is nothing that can be swapped, hence we return the node\\n        * itself.\\n        */\\n        if(head == null || head.next == null) return head;\\n        \\n        /**\\n        * If there are more than 1 nodes remaining, we would recursively call the method by passing the\\n        * next.next element.\\n        * This is because we would be swapping the head and the head.next element.\\n        * So, to call the method we would pass the head.next.next element.\\n        * This call will return a head which we would have to attach it to the current head.next element,\\n        AFTER SWAPPING.\\n        */\\n        ListNode tHead = swapPairs(head.next.next);\\n        \\n        /**\\n        * Here, we would write the swapping logic.\\n        * The node which is returned from the above line of code, will be connected with the nodes after\\n        * swapping here.\\n        */\\n        \\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 830851,
                "title": "swift-recursive-iterative",
                "content": "**Simple recursion**\\nTime: O(n), Space: O(n)\\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tif let next = head.next {\\n\\t\\thead.next = swapPairs(next.next)\\n\\t\\tnext.next = head\\n\\t\\treturn next\\n\\t} else {\\n\\t   return head \\n\\t}\\n}\\n```\\n---\\nHow about iterative?\\n**Iterative**\\nTime: O(n), Space: O(n)\\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tif head == nil || head?.next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlet newHead = head!.next\\n\\n\\tvar stack = [ListNode]()\\n\\tvar node = head\\n\\twhile let cur = node, let next = cur.next { // 2 at a time\\n\\t\\tstack.append(cur)\\n\\t\\tstack.append(next)\\n\\t\\tnode = next.next\\n\\t}\\n\\n\\twhile !stack.isEmpty {\\n\\t\\tlet next = stack.popLast()!\\n\\t\\tlet cur = stack.popLast()!\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tif let prev = stack.last {\\n\\t\\t\\tprev.next = next\\n\\t\\t}\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\n**Iterative without a stack**\\nTime: O(n), Space: O(1)\\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tvar dummy = ListNode()\\n\\tvar prev = dummy\\n\\tprev.next = head\\n\\twhile let cur = prev.next, let next = cur.next {\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tprev.next = next\\n\\t\\tprev = cur\\n\\t}\\n\\n\\treturn dummy.next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tif let next = head.next {\\n\\t\\thead.next = swapPairs(next.next)\\n\\t\\tnext.next = head\\n\\t\\treturn next\\n\\t} else {\\n\\t   return head \\n\\t}\\n}\\n```\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tif head == nil || head?.next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlet newHead = head!.next\\n\\n\\tvar stack = [ListNode]()\\n\\tvar node = head\\n\\twhile let cur = node, let next = cur.next { // 2 at a time\\n\\t\\tstack.append(cur)\\n\\t\\tstack.append(next)\\n\\t\\tnode = next.next\\n\\t}\\n\\n\\twhile !stack.isEmpty {\\n\\t\\tlet next = stack.popLast()!\\n\\t\\tlet cur = stack.popLast()!\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tif let prev = stack.last {\\n\\t\\t\\tprev.next = next\\n\\t\\t}\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tvar dummy = ListNode()\\n\\tvar prev = dummy\\n\\tprev.next = head\\n\\twhile let cur = prev.next, let next = cur.next {\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tprev.next = next\\n\\t\\tprev = cur\\n\\t}\\n\\n\\treturn dummy.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557411,
                "title": "python-recursive-solution-faster-than-99-72",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head:                                           # first (head) node exists\\n            h = head.next                                  # second node\\n            if h:                                          # second node exists => a pair exists\\n                h.next, head.next = head, h.next           # swap node pair, first node with second => \\'h\\' is new head\\n                h.next.next = self.swapPairs(h.next.next)  # recurse on next pair head\\n                return h              # returns the new head of a swapped node pair\\n        return head                   # returns when a node pair doesn\\'t exist\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head:                                           # first (head) node exists\\n            h = head.next                                  # second node\\n            if h:                                          # second node exists => a pair exists\\n                h.next, head.next = head, h.next           # swap node pair, first node with second => \\'h\\' is new head\\n                h.next.next = self.swapPairs(h.next.next)  # recurse on next pair head\\n                return h              # returns the new head of a swapped node pair\\n        return head                   # returns when a node pair doesn\\'t exist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529642,
                "title": "c-beats-100-image-explanation-using-dummy-head-and-dummy-tail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will convert the list into the list with dummy head and dummy tail. It will help us to maintain pointer and will save us from writing edge cases for null pointers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEg. Given list is `1 -> 2 -> 3 -> 4`. We will convert it to `-1 -> 1 -> 2 -> 3 -> 4 -> -1`. Now our head will point to dummy head.\\n\\nWe will keep track of three pointer and will reverse every pair of elements,\\n1. prev - which will link the reversed element (from a pair of elements), this pointer is immediate left of the current pair\\n2. cur - first element of current pair\\n3. next - second element of current pair\\n\\nIf we look at this example `-1 -> 1 -> 2 -> 3 -> 4 -> -1`, then in the first iteration prev would be -1, cur would be 1 and next would be 2.\\n\\nAfter swapping a pair list will look like this `-1 -> 2 -> 1 -> 3 -> 4 -> -1`. Now we will have our next pair which is `3 -> 4`. So prev would be 1, curr would be at 3 and next would be at 4. \\n\\nAfter second iteration list will look like `-1 -> 2 -> 1 -> 4 -> 3 -> -1`.\\n\\nNow, The list is swapped in pairs of two elements. We just have to remove dummy head and dummy tail.\\n\\nFinal answer: `2 -> 1 -> 4 -> 3`\\n\\n**NOTE 1:** ***Odd size list handled in the code. Just emit the last element from being swapped with dummy tail.***\\n**NOTE 2:** ***Code is self explanatory.***\\n\\n### Iteration Steps Explanation\\n![image.png](https://assets.leetcode.com/users/images/2deeb1b9-a52a-4694-9bbd-6e681c855146_1684217143.7158692.png)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n    - As we are traversing list only once (ignore adding and deleting dummy head and dummy tail)\\n\\n- Space complexity: $$O(1)$$\\n    - As we have not used any space (containers) except the pointers.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if list is null or contains one element then return the list itself (null => null & `1` => `1`)\\n        if (!head or !head->next)\\n            return head;\\n\\n        // Adding dummy head\\n        ListNode *dummyHead = new ListNode(-1);\\n        dummyHead->next = head;\\n        head = dummyHead;\\n\\n        // Adding dummy tail\\n        ListNode *dummyTail = new ListNode(-1);\\n        ListNode *ptr = head;\\n        while (ptr->next)\\n            ptr = ptr->next;\\n        ptr->next = dummyTail;\\n\\n        // assigning prev, cur and next for first iteration\\n        ListNode *prev = head, *cur = head->next, *next = head->next->next;\\n        while (next and next->val != -1)\\n        {\\n            // Check above image\\n            ListNode *nextCur = next->next; // 1\\n            prev->next = next; // 2\\n            cur->next = next->next; // 3\\n            next->next = cur; // 4\\n\\n            prev = cur; // 5\\n            cur = nextCur; // 6\\n            next = cur->next; // 7\\n        }   \\n\\n        // Remove dummy tail\\n        ListNode *remove = head;\\n        while(remove->next->val != -1)\\n            remove = remove->next;\\n        remove->next = NULL;\\n\\n        // remove dummy head\\n        return head = head->next;\\n    }\\n};\\n```\\n### Upvote if it helped you !!!\\n![image.png](https://assets.leetcode.com/users/images/58838411-f6e7-4acb-b98b-a8427e7453da_1684217764.5259085.png)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if list is null or contains one element then return the list itself (null => null & `1` => `1`)\\n        if (!head or !head->next)\\n            return head;\\n\\n        // Adding dummy head\\n        ListNode *dummyHead = new ListNode(-1);\\n        dummyHead->next = head;\\n        head = dummyHead;\\n\\n        // Adding dummy tail\\n        ListNode *dummyTail = new ListNode(-1);\\n        ListNode *ptr = head;\\n        while (ptr->next)\\n            ptr = ptr->next;\\n        ptr->next = dummyTail;\\n\\n        // assigning prev, cur and next for first iteration\\n        ListNode *prev = head, *cur = head->next, *next = head->next->next;\\n        while (next and next->val != -1)\\n        {\\n            // Check above image\\n            ListNode *nextCur = next->next; // 1\\n            prev->next = next; // 2\\n            cur->next = next->next; // 3\\n            next->next = cur; // 4\\n\\n            prev = cur; // 5\\n            cur = nextCur; // 6\\n            next = cur->next; // 7\\n        }   \\n\\n        // Remove dummy tail\\n        ListNode *remove = head;\\n        while(remove->next->val != -1)\\n            remove = remove->next;\\n        remove->next = NULL;\\n\\n        // remove dummy head\\n        return head = head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528838,
                "title": "easy-solution-of-java-100-faster-code-beginner-friendly",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n\\n```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n        ListNode d = new ListNode(0), a;\\n        d.next = head;\\n        a=d;\\n        while(head!=null&&head.next!=null) {\\n            a.next = head.next;\\n            head.next = head.next.next;\\n            a.next.next = head;\\n            a = a.next.next;\\n            head =  head.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n        ListNode d = new ListNode(0), a;\\n        d.next = head;\\n        a=d;\\n        while(head!=null&&head.next!=null) {\\n            a.next = head.next;\\n            head.next = head.next.next;\\n            a.next.next = head;\\n            a = a.next.next;\\n            head =  head.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477540,
                "title": "python-recursive-solution-w-step-by-step-thought-process",
                "content": "Is the point of Leetcode to come up with intensely technical and condensed code, or is it to help us practice systematically solving problems and showing our thought process? Its the latter. This may not be the most condensed solution, but the thought process is clear and sequential.\\n\\n**Overall Thought Process**\\n1. Write out ideally how the algorithm would execute. It\\'ll be easier to see the pattern this way\\n2. Then, I look at pairs and try to come up with a pseudocode\\n3. From that, I can come up with a rough recursive algorithm. To simplify this, I\\'m not thinking of edge cases \\n4. Add in conditionals to account for edge cases\\n5. Convert algorithm into code\\n\\n<br>\\n\\n\\n**Walking through each Step**\\n\\n\\n**1. Write out ideally how the algorithm would execute. It\\'ll be easier to see the pattern this way**\\n\\n```\\nFor linked list -> 1 - 2\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4\\n4.next = 3\\n3.next = None\\n2.next = 1\\n1.next = 4\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4 - 5\\n4.next = 3\\n3.next = 5\\n2.next = 1\\n1.next = 4\\nreturn 2\\n```\\n\\n\\n**2. Then, I look at pairs and try to come up with a pseudocode**\\n```\\nfor each pair (a, b):\\n    a.next = whatever is the first of next pair\\n    b.next = a\\n    return b\\n```\\n\\n**3. From that, I can come up with a rough recursive algorithm. To simplify this, I\\'m not thinking of edge cases yet**\\n```\\nswap_pair(head):\\n    first = head\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\\n\\n**4. Add in conditionals to account for edge cases**\\n```\\nswap_pair(head):\\n    if not head:\\n        return None\\n\\n    first = head\\n    \\n    if not first.next:\\n        return first\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\\n\\n**5. Convert algorithm into code**\\n```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n\\n        first = head\\n        if not first.next:\\n            return first\\n        second = first.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        return second\\n```",
                "solutionTags": [],
                "code": "```\\nFor linked list -> 1 - 2\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4\\n4.next = 3\\n3.next = None\\n2.next = 1\\n1.next = 4\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4 - 5\\n4.next = 3\\n3.next = 5\\n2.next = 1\\n1.next = 4\\nreturn 2\\n```\n```\\nfor each pair (a, b):\\n    a.next = whatever is the first of next pair\\n    b.next = a\\n    return b\\n```\n```\\nswap_pair(head):\\n    first = head\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\n```\\nswap_pair(head):\\n    if not head:\\n        return None\\n\\n    first = head\\n    \\n    if not first.next:\\n        return first\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\n```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n\\n        first = head\\n        if not first.next:\\n            return first\\n        second = first.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        return second\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529141,
                "title": "day-411-brute-better-optimal-100-python-java-c-explained",
                "content": "\\n\\n\\n\\n# BRUTE\\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n        List<ListNode> list = new ArrayList<>();\\n        ListNode temNode = head;\\n        while (temNode != null) {\\n            list.add(temNode);\\n            temNode = temNode.next;\\n        }\\n        for (int i = 0; i < list.size() - 1; i += 2) {\\n            int swapElement = list.get(i).val;\\n            list.get(i).val = list.get(i + 1).val;\\n            list.get(i + 1).val = swapElement;\\n        }\\n        return head;\\n}\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe first check if the input head is null or has only one node. If so, we return the head as it is. Otherwise, we create two nodes first and second and set them to the first and second nodes of the linked list, respectively. We then recursively call the swapPairs function on the next of the second node and set the next of the first node to the result. We then swap the next pointers of the first and second nodes and return the second node.\\n\\n# BETTER\\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode first = head;\\n    ListNode second = head.next;\\n    first.next = swapPairs(second.next);\\n    second.next = first;\\n    return second;\\n}\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(LOG(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# OPTIMAL\\nWe create a dummy node and set its next to the head. We then create a current node and initialize it to the dummy node. We use a single loop to swap every two adjacent nodes. We do this by creating two nodes first and second and swapping their next pointers. We then update the current node to point to the second node and continue the loop. Finally, we return the next of the dummy node.The time complexity of this solution is O(n) as we need to traverse the entire linked list once.\\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n    ListNode current = dummy;\\n    while (current.next != null && current.next.next != null) {\\n        ListNode first = current.next;\\n        ListNode second = current.next.next;\\n        first.next = second.next;\\n        second.next = first;\\n        current.next = second;\\n        current = current.next.next;\\n    }\\n    return dummy.next;\\n}\\n```\\n```c++ []\\nListNode* swapPairs(ListNode* head) {\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    ListNode* current = dummy;\\n    while (current->next != NULL && current->next->next != NULL) {\\n        ListNode* first = current->next;\\n        ListNode* second = current->next->next;\\n        first->next = second->next;\\n        second->next = first;\\n        current->next = second;\\n        current = current->next->next;\\n    }\\n    return dummy->next;\\n}\\n```\\n```python []\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    dummy = ListNode(0)\\n    dummy.next = head\\n    current = dummy\\n    while current.next and current.next.next:\\n        first = current.next\\n        second = current.next.next\\n        first.next = second.next\\n        second.next = first\\n        current.next = second\\n        current = current.next.next\\n    return dummy.next\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06 \\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n        List<ListNode> list = new ArrayList<>();\\n        ListNode temNode = head;\\n        while (temNode != null) {\\n            list.add(temNode);\\n            temNode = temNode.next;\\n        }\\n        for (int i = 0; i < list.size() - 1; i += 2) {\\n            int swapElement = list.get(i).val;\\n            list.get(i).val = list.get(i + 1).val;\\n            list.get(i + 1).val = swapElement;\\n        }\\n        return head;\\n}\\n```\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode first = head;\\n    ListNode second = head.next;\\n    first.next = swapPairs(second.next);\\n    second.next = first;\\n    return second;\\n}\\n```\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n    ListNode current = dummy;\\n    while (current.next != null && current.next.next != null) {\\n        ListNode first = current.next;\\n        ListNode second = current.next.next;\\n        first.next = second.next;\\n        second.next = first;\\n        current.next = second;\\n        current = current.next.next;\\n    }\\n    return dummy.next;\\n}\\n```\n```c++ []\\nListNode* swapPairs(ListNode* head) {\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    ListNode* current = dummy;\\n    while (current->next != NULL && current->next->next != NULL) {\\n        ListNode* first = current->next;\\n        ListNode* second = current->next->next;\\n        first->next = second->next;\\n        second->next = first;\\n        current->next = second;\\n        current = current->next->next;\\n    }\\n    return dummy->next;\\n}\\n```\n```python []\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    dummy = ListNode(0)\\n    dummy.next = head\\n    current = dummy\\n    while current.next and current.next.next:\\n        first = current.next\\n        second = current.next.next\\n        first.next = second.next\\n        second.next = first\\n        current.next = second\\n        current = current.next.next\\n    return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1902446,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11236,
                "title": "very-easy-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            ListNode *l=head;\\n            if(head&&head->next){\\n                l=head->next;\\n                head->next=swapPairs(l->next);\\n                l->next=head;\\n            }\\n            return l;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            ListNode *l=head;\\n            if(head&&head->next){\\n                l=head->next;\\n                head->next=swapPairs(l->next);\\n                l->next=head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 300006,
                "title": "go-0-ms-faster-than-100-00-easy-code-recursion",
                "content": "```\\ntype ListNode struct {\\n\\tVal  int\\n\\tNext *ListNode\\n}\\n\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tresult := head.Next\\n\\thead.Next = swapPairs(head.Next.Next)\\n\\tresult.Next = head\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\ntype ListNode struct {\\n\\tVal  int\\n\\tNext *ListNode\\n}\\n\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tresult := head.Next\\n\\thead.Next = swapPairs(head.Next.Next)\\n\\tresult.Next = head\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 298168,
                "title": "java-clean-recursive-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode newHead = head.next;\\n        head.next = swapPairs(newHead.next);\\n        newHead.next = head;\\n        return newHead;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode newHead = head.next;\\n        head.next = swapPairs(newHead.next);\\n        newHead.next = head;\\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278452,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        first = head.next\\n        second = head\\n        second.next = self.swapPairs(first.next)\\n        first.next = second\\n        return first\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        first = head.next\\n        second = head\\n        second.next = self.swapPairs(first.next)\\n        first.next = second\\n        return first\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11361,
                "title": "share-my-accepted-java-solution",
                "content": "    public class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }\\n            ListNode first = head, last = head.next;\\n            first.next = swapPairs(last.next);\\n            last.next = first;\\n            return last;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 11216,
                "title": "my-accepted-solution-in-python-quite-fast",
                "content": "    class Solution:\\n        # @param a ListNode\\n        # @return a ListNode\\n        def swapPairs(self, head):\\n            p1 = guard = ListNode(0)\\n            guard.next = head\\n            \\n            try:\\n                while True:\\n                    p0, p1, p2 = p1, p1.next, p1.next.next\\n                    p0.next, p1.next, p2.next = p2, p2.next, p1\\n            except:\\n                return guard.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param a ListNode\\n        # @return a ListNode\\n        def swapPairs(self, head):\\n            p1 = guard = ListNode(0)\\n            guard.next = head\\n            \\n            try:\\n                while True:\\n                    p0, p1, p2 = p1, p1.next, p1.next.next\\n                    p0.next, p1.next, p2.next = p2, p2.next, p1\\n            except:\\n                return guard.next",
                "codeTag": "Java"
            },
            {
                "id": 11254,
                "title": "seeking-for-a-better-solution",
                "content": "Is someone has a better solution? My code can get AC, but I don't think it's good enough. Thanks~~\\n \\n   \\n\\n    public class Solution {\\n            public ListNode swapPairs(ListNode head) {\\n                ListNode cur = head, next1, next2;\\n                if(head == null) return null;\\n                if(head.next == null) return head;\\n                \\n                //head change with next is a special case, so we deal with it first\\n                ListNode temp = cur.next;\\n                cur.next = temp.next;\\n                temp.next = cur;\\n                head = temp;\\n                \\n            \\twhile(cur.next != null && cur.next.next != null) {\\n            \\t\\tnext1 = cur.next;\\n            \\t\\tnext2 = cur.next.next;\\n            \\t\\tswap(cur,next1,next2);\\n            \\t\\tcur = cur.next.next;\\n            \\t}\\n            \\treturn head;\\n            }\\n            \\n            private void swap(ListNode cur, ListNode next1, ListNode next2) {\\n            \\tcur.next = next2;\\n            \\tnext1.next = next2.next;\\n            \\tnext2.next = next1;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public ListNode swapPairs(ListNode head) {\\n                ListNode cur = head, next1, next2;\\n                if(head == null) return null;\\n                if(head.next == null) return head;\\n                \\n                //head change with next is a special case, so we deal with it first\\n                ListNode temp = cur.next;\\n                cur.next = temp.next;\\n                temp.next = cur;\\n                head = temp;\\n                \\n            \\twhile(cur.next != null && cur.next.next != null) {\\n            \\t\\tnext1 = cur.next;\\n            \\t\\tnext2 = cur.next.next;\\n            \\t\\tswap(cur,next1,next2);\\n            \\t\\tcur = cur.next.next;\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 2596746,
                "title": "straightforward-0ms-iterative-solution-with-comments",
                "content": "Introduced 2 macros to make the algo more clear: one taking .next node as reference, and one as mutable\\n\\n```\\nmacro_rules! next_node_as_ref {\\n    ($a: expr) => {\\n        $a.as_ref().unwrap().next\\n    };\\n}\\nmacro_rules! next_node_as_mut {\\n    ($a: expr) => {\\n        $a.as_mut().unwrap().next\\n    };\\n}\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut cur_node = &mut head;\\n\\n        // while we have something to work with (.next has something)\\n        while cur_node.is_some() && next_node_as_ref!(cur_node).is_some() {\\n            // .take() Takes the value out of the option, leaving a None in its place.\\n            let mut even_node = next_node_as_mut!(cur_node).take();\\n\\n            // taking next odd node\\'s value\\n            let next_odd_node = next_node_as_mut!(even_node).take();\\n            // cur_node\\'s .next points to next odd node\\n            next_node_as_mut!(cur_node) = next_odd_node;\\n            // even node\\'s .next points to cur_node\\n            next_node_as_mut!(even_node) = cur_node.take();\\n            // switching cur_node with even node\\n            cur_node.replace(even_node.unwrap());\\n            // point cursor to .next.next\\n            cur_node = &mut next_node_as_mut!(next_node_as_mut!(cur_node));\\n        }\\n        head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nmacro_rules! next_node_as_ref {\\n    ($a: expr) => {\\n        $a.as_ref().unwrap().next\\n    };\\n}\\nmacro_rules! next_node_as_mut {\\n    ($a: expr) => {\\n        $a.as_mut().unwrap().next\\n    };\\n}\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut cur_node = &mut head;\\n\\n        // while we have something to work with (.next has something)\\n        while cur_node.is_some() && next_node_as_ref!(cur_node).is_some() {\\n            // .take() Takes the value out of the option, leaving a None in its place.\\n            let mut even_node = next_node_as_mut!(cur_node).take();\\n\\n            // taking next odd node\\'s value\\n            let next_odd_node = next_node_as_mut!(even_node).take();\\n            // cur_node\\'s .next points to next odd node\\n            next_node_as_mut!(cur_node) = next_odd_node;\\n            // even node\\'s .next points to cur_node\\n            next_node_as_mut!(even_node) = cur_node.take();\\n            // switching cur_node with even node\\n            cur_node.replace(even_node.unwrap());\\n            // point cursor to .next.next\\n            cur_node = &mut next_node_as_mut!(next_node_as_mut!(cur_node));\\n        }\\n        head\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11132,
                "title": "very-simple-c-recursive-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if (head == NULL || head->next == NULL) return head;\\n            ListNode *grandChild = swapPairs(head->next->next);\\n            ListNode *child = head->next;\\n            child->next = head;\\n            head->next = grandChild;\\n            return child;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if (head == NULL || head->next == NULL) return head;\\n            ListNode *grandChild = swapPairs(head->next->next);\\n            ListNode *child = head->next;\\n            child->next = head;\\n            head->next = grandChild;\\n            return child;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1788868,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode tHead = swapPairs(head.next.next);\\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode tHead = swapPairs(head.next.next);\\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776487,
                "title": "javascript-time-o-n-space-o-1-simple-approach-with-explanation",
                "content": "1. Check if we have current and next Node or not.\\n2. Do simple swapping using temp variable.\\n3. Take a temporary variable and store value of first node into that.\\n4. Take value of second node and store in first node\\n5. Move to second node and replace value of second node by temp.\\n6. repeat the swapping till end of linked list.\\n\\n```\\nvar swapPairs = function(head) {\\n    let start = new ListNode();  // Taking a pointer for keeping head of linked list safe with us\\n    start = head;  // storing head into result as we\\'ll be updating head further.\\n    while(head != undefined && head.next != undefined){  //loop for itterating through linked list\\n        let temp = head.val;                              // swapping\\n        head.val = head.next.val;                     // swapping\\n        head = head.next;                               // swapping\\n        head.val = temp;                                // swapping\\n        head = head.next;                            // increasing the pointer to next element\\n    }\\n    return start;       // return the starting point of linked list as we modified the same linked list.\\n};\\n```\\n\\nFeel free to comment down if doubts on any steps.\\n\\n**Upvote** if helped.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar swapPairs = function(head) {\\n    let start = new ListNode();  // Taking a pointer for keeping head of linked list safe with us\\n    start = head;  // storing head into result as we\\'ll be updating head further.\\n    while(head != undefined && head.next != undefined){  //loop for itterating through linked list\\n        let temp = head.val;                              // swapping\\n        head.val = head.next.val;                     // swapping\\n        head = head.next;                               // swapping\\n        head.val = temp;                                // swapping\\n        head = head.next;                            // increasing the pointer to next element\\n    }\\n    return start;       // return the starting point of linked list as we modified the same linked list.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517929,
                "title": "c-two-soltn-0-ms-faster-than-100-00",
                "content": "**Soln 1**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(head==0)\\n            return NULL;\\n        if(head->next==0)\\n            return head;\\n        \\n        \\n        ListNode *first=head;\\n        ListNode *second=first->next;\\n        ListNode *newhead=second;\\n        ListNode *prev=first;\\n        while(first && second)\\n        {\\n            prev=first;\\n            first->next=second->next;\\n            second->next=prev;\\n            \\n            first=first->next;\\n            if(first!=0 && first->next!=0)\\n             second=first->next;\\n            else\\n                break;\\n            prev->next=second;\\n            \\n        }\\n        return newhead;\\n        \\n    }\\n};\\n```\\n\\n**Soln 2**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        ListNode *temp=new ListNode(0);\\n        temp->next=head;\\n        ListNode *curr=temp;\\n        \\n        while(curr->next && curr->next->next)\\n        {\\n            ListNode *first=curr->next;\\n            ListNode *second=curr->next->next;\\n            first->next=second->next;\\n            second->next=first;\\n            curr->next=second;\\n            curr=curr->next->next;\\n        }\\n        return temp->next;\\n        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(head==0)\\n            return NULL;\\n        if(head->next==0)\\n            return head;\\n        \\n        \\n        ListNode *first=head;\\n        ListNode *second=first->next;\\n        ListNode *newhead=second;\\n        ListNode *prev=first;\\n        while(first && second)\\n        {\\n            prev=first;\\n            first->next=second->next;\\n            second->next=prev;\\n            \\n            first=first->next;\\n            if(first!=0 && first->next!=0)\\n             second=first->next;\\n            else\\n                break;\\n            prev->next=second;\\n            \\n        }\\n        return newhead;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        ListNode *temp=new ListNode(0);\\n        temp->next=head;\\n        ListNode *curr=temp;\\n        \\n        while(curr->next && curr->next->next)\\n        {\\n            ListNode *first=curr->next;\\n            ListNode *second=curr->next->next;\\n            first->next=second->next;\\n            second->next=first;\\n            curr->next=second;\\n            curr=curr->next->next;\\n        }\\n        return temp->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549794,
                "title": "3-solutions-easy-to-understand-faster-2-iterative-and-1-recursive-python",
                "content": "```\\ndef recursive(self, head):\\n        def rec(head):\\n            if head and head.next:\\n                rep = rec(head.next.next)\\n                second = head.next\\n                first = head\\n                if second:\\n                    first.next = rep\\n                    second.next = first\\n                    return second\\n                return first\\n            elif head: return head\\n            \\n        return rec(head)\\n    \\n    def in_place_nodes(self, head):\\n        if not head: return head\\n        prev = None\\n        first = head\\n        second = head.next\\n        while first and second:\\n            if prev:\\n                prev.next = second\\n            else:\\n                head = second\\n            forward = second.next\\n            first.next = second.next\\n            second.next = first\\n            prev = first\\n            first = forward\\n            if not first: break\\n            second = first.next\\n        return head\\n    \\n        \\n    def in_place_value(self, head):\\n        if not head: return head\\n        first = head\\n        second = head.next\\n        while first and second:\\n            first.val, second.val = second.val, first.val\\n            first = second.next\\n            if not first: break\\n            second = second.next.next\\n        return head\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef recursive(self, head):\\n        def rec(head):\\n            if head and head.next:\\n                rep = rec(head.next.next)\\n                second = head.next\\n                first = head\\n                if second:\\n                    first.next = rep\\n                    second.next = first\\n                    return second\\n                return first\\n            elif head: return head\\n            \\n        return rec(head)\\n    \\n    def in_place_nodes(self, head):\\n        if not head: return head\\n        prev = None\\n        first = head\\n        second = head.next\\n        while first and second:\\n            if prev:\\n                prev.next = second\\n            else:\\n                head = second\\n            forward = second.next\\n            first.next = second.next\\n            second.next = first\\n            prev = first\\n            first = forward\\n            if not first: break\\n            second = first.next\\n        return head\\n    \\n        \\n    def in_place_value(self, head):\\n        if not head: return head\\n        first = head\\n        second = head.next\\n        while first and second:\\n            first.val, second.val = second.val, first.val\\n            first = second.next\\n            if not first: break\\n            second = second.next.next\\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 11078,
                "title": "easy-understand-3-lines-solutions-with-comments",
                "content": "before '=': the first node, the second and  the third node\\nafter '='   : the second node, the first  and  the third node returned by recursion.\\n\\n```\\ndef swapPairs(self, head):\\n        if head and head.next:\\n            head, head.next, head.next.next = head.next, head, self.swapPairs(head.next.next)\\n        return head",
                "solutionTags": [],
                "code": "before '=': the first node, the second and  the third node\\nafter '='   : the second node, the first  and  the third node returned by recursion.\\n\\n```\\ndef swapPairs(self, head):\\n        if head and head.next:\\n            head, head.next, head.next.next = head.next, head, self.swapPairs(head.next.next)\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 11204,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // recursively \\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode nxt = head.next;\\n        head.next = swapPairs(nxt.next);\\n        nxt.next = head;\\n        return nxt;\\n    }\\n    \\n    // iteratively\\n    public ListNode swapPairs1(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode pre = new ListNode(0), p = head, ret = head.next;\\n        while (p != null && p.next != null) {\\n            ListNode nxt = p.next;\\n            p.next = nxt.next;\\n            nxt.next = p;\\n            pre.next = nxt;\\n            pre = p;\\n            p = p.next;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // recursively \\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode nxt = head.next;\\n        head.next = swapPairs(nxt.next);\\n        nxt.next = head;\\n        return nxt;\\n    }\\n    \\n    // iteratively\\n    public ListNode swapPairs1(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode pre = new ListNode(0), p = head, ret = head.next;\\n        while (p != null && p.next != null) {\\n            ListNode nxt = p.next;\\n            p.next = nxt.next;\\n            nxt.next = p;\\n            pre.next = nxt;\\n            pre = p;\\n            p = p.next;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2774348,
                "title": "in-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n    return head;\\n    struct ListNode*x,*y,*z=NULL;\\n    x=head;\\n    y=head->next;\\n    if(head->next->next!=NULL)\\n    {\\n        z=head->next->next;\\n    }\\n    head=y;\\n    while(z!=NULL && z->next!=NULL)\\n    {\\n        y->next=x;\\n        x->next=z->next;\\n        x=z;\\n        y=x->next;\\n        z=y->next;\\n    }\\n    y->next=x;\\n    x->next=z;\\n    return head;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n    return head;\\n    struct ListNode*x,*y,*z=NULL;\\n    x=head;\\n    y=head->next;\\n    if(head->next->next!=NULL)\\n    {\\n        z=head->next->next;\\n    }\\n    head=y;\\n    while(z!=NULL && z->next!=NULL)\\n    {\\n        y->next=x;\\n        x->next=z->next;\\n        x=z;\\n        y=x->next;\\n        z=y->next;\\n    }\\n    y->next=x;\\n    x->next=z;\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775417,
                "title": "iterative-solution-with-tuples-and-no-recursion",
                "content": "Pointer swapping can be done in a modern way using tuples:\\n```csharp\\npublic class Solution\\n{\\n    public ListNode SwapPairs(ListNode head)\\n    {\\n        ListNode prev = new();\\n        var a = head;\\n        var b = head?.next;\\n\\n        head = b ?? a;\\n\\n        while (a != null && b != null)\\n        {\\n            (prev.next, a.next, b.next) = (b, b.next, a); //swap the nodes\\n            (prev, a, b) = (a, a.next, a.next?.next); //move on\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Iterator"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public ListNode SwapPairs(ListNode head)\\n    {\\n        ListNode prev = new();\\n        var a = head;\\n        var b = head?.next;\\n\\n        head = b ?? a;\\n\\n        while (a != null && b != null)\\n        {\\n            (prev.next, a.next, b.next) = (b, b.next, a); //swap the nodes\\n            (prev, a, b) = (a, a.next, a.next?.next); //move on\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233188,
                "title": "my-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head)return head;\\n        if(!head->next)return head;\\n        ListNode temp(0);\\n        temp.next = head;\\n        ListNode* current = &temp;\\n        while(current->next!=NULL && current->next->next!=NULL){\\n            ListNode* first = current->next;\\n            ListNode* second = current->next->next;\\n            first->next = second->next;\\n            current->next = second;\\n            current->next->next = first;\\n            current = current->next->next;\\n        }\\n        return temp.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head)return head;\\n        if(!head->next)return head;\\n        ListNode temp(0);\\n        temp.next = head;\\n        ListNode* current = &temp;\\n        while(current->next!=NULL && current->next->next!=NULL){\\n            ListNode* first = current->next;\\n            ListNode* second = current->next->next;\\n            first->next = second->next;\\n            current->next = second;\\n            current->next->next = first;\\n            current = current->next->next;\\n        }\\n        return temp.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231784,
                "title": "javascript-recursion-solution",
                "content": "```\\nvar swapPairs = function(head) {\\n  // base case\\n  if (head === null || head.next === null) return head;\\n  let temp = head.next;\\n  head.next = temp.next;\\n  temp.next = head;\\n  head.next = swapPairs(head.next);\\n  return temp;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar swapPairs = function(head) {\\n  // base case\\n  if (head === null || head.next === null) return head;\\n  let temp = head.next;\\n  head.next = temp.next;\\n  temp.next = head;\\n  head.next = swapPairs(head.next);\\n  return temp;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11094,
                "title": "simple-0ms-c-solution-beats-98-08",
                "content": "All we need to do is rearrange the links in the list.If <b>prev </b> is the pevious node,<b> head </b> is the current node,at every alternate node perform operations such that <br>\\nInitial:           prev | head | head->next|head->next->next\\nAfter swap:prev|head->next|head|head->next->next\\n\\n```\\n ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        while(head &&head->next)\\n        {\\n            ListNode* nn=head->next->next;\\n            prev->next=head->next;\\n            head->next->next=head;\\n            head->next=nn;\\n            prev=head;\\n            head=nn;\\n           \\n        }\\n        return dummy->next;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        while(head &&head->next)\\n        {\\n            ListNode* nn=head->next->next;\\n            prev->next=head->next;\\n            head->next->next=head;\\n            head->next=nn;\\n            prev=head;\\n            head=nn;\\n           \\n        }\\n        return dummy->next;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11266,
                "title": "python-solution-using-36ms-with-simple-method",
                "content": "\\nclass Solution(object):\\n\\n    def swapPairs(self, head):\\n\\n        if not head or not head.next:\\n            return head\\n      \\n        first,second = head, head.next\\n        third = second.next\\n        head = second\\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        \\n        return head",
                "solutionTags": [],
                "code": "\\nclass Solution(object):\\n\\n    def swapPairs(self, head):\\n\\n        if not head or not head.next:\\n            return head\\n      \\n        first,second = head, head.next\\n        third = second.next\\n        head = second\\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        \\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 3532106,
                "title": "5-lines-0ms-easy-approach-beasts-100-stepped-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are using a very simple and easy ***recursive*** approach to solve this\\n\\n\\n**Steps:**\\n\\n1. At first we will check, if head value is null we will return null.\\n\\n    `if(head==null) return null;`\\n2. Then we check, if next head value is null we will return current head.\\n\\n    `if (head.next == null) return head;`\\n3. Later we will swap the 2 value of by creating a temp variable & recursively swapping the values.\\n    \\n    - Storing the next head to a temp ListNode that we will return at last. `ListNode temp = head.next;`\\n    - Then we  get the call the function recursively for next head. \\n     `head.next = swapPairs(temp.next);`\\n    - Then we swap value next temp with the head.\\n     `temp.next = head;`\\n4. At last we will return the temp ListNode we created .\\n \\n    `return temp;`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if (head.next == null) return head;\\n\\n        ListNode temp = head.next;\\n        head.next = swapPairs(temp.next);\\n        temp.next = head;\\n\\n        return temp;\\n    }\\n}\\n```\\n\\n<!-- ---\\n**Iterative** \\n```\\npublic ListNode swapPairs1(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode pre = new ListNode(0), p = head, ret = head.next;\\n    while (p != null && p.next != null) {\\n        ListNode nxt = p.next;\\n        p.next = nxt.next;\\n        nxt.next = p;\\n        pre.next = nxt;\\n        pre = p;\\n        p = p.next;\\n    }\\n    return ret;\\n}\\n``` -->\\n\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e835e6d0-5193-493a-9394-e4e90c90e1b0_1684266894.6208477.jpeg)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if (head.next == null) return head;\\n\\n        ListNode temp = head.next;\\n        head.next = swapPairs(temp.next);\\n        temp.next = head;\\n\\n        return temp;\\n    }\\n}\\n```\n```\\npublic ListNode swapPairs1(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode pre = new ListNode(0), p = head, ret = head.next;\\n    while (p != null && p.next != null) {\\n        ListNode nxt = p.next;\\n        p.next = nxt.next;\\n        nxt.next = p;\\n        pre.next = nxt;\\n        pre = p;\\n        p = p.next;\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530416,
                "title": "c-recursive-solution-to-swap-nodes-in-pairs-dlc-16-05-2023-all-testcases-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst intuition that comes to mind is that swap the pairs of nodes and modify the next pointers for each pair of nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe basic ideology of recursion\\n\"Solve the first case, other cases will be handled by Recursion.\"\\n\\nHere, solve for the first pair of nodes, i.e., swap the first two nodes and modify their next pointers. First node will now point to the node where second node was pointing to and second node will point to the first node.\\n\\nCall the function recursively and store the head (first) node of the remaining part of the linked list in the next pointer of the first node.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next==NULL){\\n            return head;\\n        }\\n\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head->next;\\n\\n        temp1->next = temp2->next;\\n        temp2->next = temp1;\\n\\n        if (temp1->next!=NULL){\\n            temp1->next = swapPairs(temp1->next);\\n        }\\n\\n        return temp2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next==NULL){\\n            return head;\\n        }\\n\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head->next;\\n\\n        temp1->next = temp2->next;\\n        temp2->next = temp1;\\n\\n        if (temp1->next!=NULL){\\n            temp1->next = swapPairs(temp1->next);\\n        }\\n\\n        return temp2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471758,
                "title": "c-very-easy-solution-100-beat",
                "content": "\\nclass Solution {\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case \\n        if(head == NULL){\\n            return NULL;\\n        }\\n        \\n        ListNode* forward = NULL;\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n        while(curr != NULL && count < 2){\\n             forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        \\n        if(forward != NULL){\\n            head->next = swapPairs(forward);\\n        }\\n        //sb hogya abb return krde \\n        return prev;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case \\n        if(head == NULL){\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3310367,
                "title": "java-three-line-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ni have used basic concept of linkedlist and recursive call\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode prv=head;\\n        ListNode curr=head.next;\\n        ListNode next=head.next.next;\\n        head=curr;\\n        head.next=prv;\\n        head.next.next=swapPairs(next);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode prv=head;\\n        ListNode curr=head.next;\\n        ListNode next=head.next.next;\\n        head=curr;\\n        head.next=prv;\\n        head.next.next=swapPairs(next);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430680,
                "title": "c-code-without-finding-length-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* hp = head;\\n        int x = 0;\\n        while(hp!=nullptr && hp->next!=nullptr){\\n            if(x%2==0){\\n              swap(hp->val , hp->next->val);\\n            }\\n            x++;\\n            hp = hp->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* hp = head;\\n        int x = 0;\\n        while(hp!=nullptr && hp->next!=nullptr){\\n            if(x%2==0){\\n              swap(hp->val , hp->next->val);\\n            }\\n            x++;\\n            hp = hp->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795879,
                "title": "simple-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode *prev = dummy, *cur = head;\\n\\n        while(cur && cur->next) {\\n        \\t// save pointers\\n        \\tListNode* nxtPair = cur->next->next;\\n        \\tListNode* second = cur->next;\\n\\n        \\t// reverse this pair\\n        \\tsecond->next = cur;\\n        \\tcur->next = nxtPair;\\n        \\tprev->next = second;\\n\\n        \\t// update pointers\\n        \\tprev = cur;\\n        \\tcur = nxtPair;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode *prev = dummy, *cur = head;\\n\\n        while(cur && cur->next) {\\n        \\t// save pointers\\n        \\tListNode* nxtPair = cur->next->next;\\n        \\tListNode* second = cur->next;\\n\\n        \\t// reverse this pair\\n        \\tsecond->next = cur;\\n        \\tcur->next = nxtPair;\\n        \\tprev->next = second;\\n\\n        \\t// update pointers\\n        \\tprev = cur;\\n        \\tcur = nxtPair;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774481,
                "title": "c-recursive-solutions-faster-than-100-00-of-submissions",
                "content": "class Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n      if(head==NULL || head->next == NULL)\\n            return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next);\\n        temp->next = head;\\n        return temp;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n      if(head==NULL || head->next == NULL)\\n            return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next);\\n        temp->next = head;\\n        return temp;  \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1133526,
                "title": "js-iterative-and-recursive-w-explanation",
                "content": "Iterative Method\\n```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    // create a dummy to keep track of the new linked list\\n    let dummy = new ListNode(0, null)\\n    // tail would keep track of the dummy and move as it link more nodes\\n    let tail = dummy\\n    \\n    while (head != null && head.next != null) {\\n        let currHead = head\\n        let nextHead = head.next\\n        let skipHead = head.next.next    \\n        \\n        // reverse the second node with the first node\\n        nextHead.next = currHead\\n        currHead.next = null\\n        \\n        // nextHead = [2,1]\\n        tail.next = nextHead\\n        // dummy = [0,2,1] so tail = [1]\\n        tail = tail.next.next\\n        // point the head to the next part so it can reverse and repeat again\\n        head = skipHead\\n    }\\n    \\n    // this is for odd amount of nodes\\n    // since previous is tail.next = nextHead, which skips 2\\n    // for even, it won\\'t affect it\\n    tail.next = head\\n    \\n    // dummy.next holds the newly reversed linked list\\n    return dummy.next\\n};\\n```\\n\\n\\nRecursive Method\\n```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    let currHead = head\\n    let nextHead = head.next\\n    let skipHead = head.next.next\\n    \\n    // relink the second node to the first node\\n    nextHead.next = currHead\\n    \\n    // the firstNode\\'s next would be the result of the swap\\n    currHead.next = swapPairs(skipHead)\\n    \\n    // nextHead targets the 2nd node, which would be the first node if it reversed\\n    return nextHead\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    // create a dummy to keep track of the new linked list\\n    let dummy = new ListNode(0, null)\\n    // tail would keep track of the dummy and move as it link more nodes\\n    let tail = dummy\\n    \\n    while (head != null && head.next != null) {\\n        let currHead = head\\n        let nextHead = head.next\\n        let skipHead = head.next.next    \\n        \\n        // reverse the second node with the first node\\n        nextHead.next = currHead\\n        currHead.next = null\\n        \\n        // nextHead = [2,1]\\n        tail.next = nextHead\\n        // dummy = [0,2,1] so tail = [1]\\n        tail = tail.next.next\\n        // point the head to the next part so it can reverse and repeat again\\n        head = skipHead\\n    }\\n    \\n    // this is for odd amount of nodes\\n    // since previous is tail.next = nextHead, which skips 2\\n    // for even, it won\\'t affect it\\n    tail.next = head\\n    \\n    // dummy.next holds the newly reversed linked list\\n    return dummy.next\\n};\\n```\n```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    let currHead = head\\n    let nextHead = head.next\\n    let skipHead = head.next.next\\n    \\n    // relink the second node to the first node\\n    nextHead.next = currHead\\n    \\n    // the firstNode\\'s next would be the result of the swap\\n    currHead.next = swapPairs(skipHead)\\n    \\n    // nextHead targets the 2nd node, which would be the first node if it reversed\\n    return nextHead\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717219,
                "title": "go-golang-two-solutions",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Swap Nodes in Pairs.\\nMemory Usage: 2.1 MB, less than 13.25% of Go online submissions for Swap Nodes in Pairs.\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    ans := &ListNode{0, head}\\n    dummy := ans\\n    for dummy.Next != nil && dummy.Next.Next != nil {\\n        a := dummy.Next\\n        b := dummy.Next.Next\\n        a.Next = b.Next\\n        dummy.Next = b\\n        dummy.Next.Next = a\\n        dummy = dummy.Next.Next\\n    }\\n    return ans.Next\\n}\\n```\\n\\n>Runtime: 0 ms, faster than 100.00% of Go online submissions for Swap Nodes in Pairs.\\nMemory Usage: 2.1 MB, less than 99.40% of Go online submissions for Swap Nodes in Pairs.\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil { return head }\\n    tmp := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    tmp.Next = head\\n    return tmp\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    ans := &ListNode{0, head}\\n    dummy := ans\\n    for dummy.Next != nil && dummy.Next.Next != nil {\\n        a := dummy.Next\\n        b := dummy.Next.Next\\n        a.Next = b.Next\\n        dummy.Next = b\\n        dummy.Next.Next = a\\n        dummy = dummy.Next.Next\\n    }\\n    return ans.Next\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil { return head }\\n    tmp := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    tmp.Next = head\\n    return tmp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 580838,
                "title": "python-js-java-c-o-n-recursive-sol-w-visualization",
                "content": "Python/Java/JS/C++ O(n) recusrion sol.\\n\\n[Tutorial video to Swap nodes in pairs [ Chinese \\u4E2D\\u6587\\u8B1B\\u89E3\\u5F71\\u7247]](https://youtu.be/DIHuNQ-PQZg)\\n\\n---\\n\\n**Visualization**\\n\\n1. Reverse next node linkage\\n```\\nnext_node.next = node\\n```\\n  \\n2. Update node linkage to next pair\\n```\\nnode.next = helper( next_pair)\\n```\\n![image.png](https://assets.leetcode.com/users/images/b903dd7c-983c-44c2-8166-289928c97fff_1684213084.129816.png)\\n\\n\\n---\\n\\n**Hint**:\\n\\nRecurvisely reverse each pair and build new linkage between reversed pairs.\\n\\n---\\n\\n**Implementation** by Python:\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        cur = head\\n               \\n        try:\\n            \\n            # locate head of next pair\\n            next_pair = cur.next.next\\n            \\n            # reverse next pair\\n            junction = self.swapPairs( next_pair )\\n            \\n            # reverse current pair\\n            original_next = cur.next\\n            \\n            original_next.next = cur\\n            \\n            # build new linkage from current pair to next pair\\n            cur.next = junction\\n            \\n            return original_next\\n            \\n        except:\\n            \\n            # Base case:\\n            # Either one node or None remaining\\n            return cur\\n\\n```\\n\\n---\\n\\nShare another implementation:\\n\\n```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def helper( node ):\\n\\n            # Base case: empty node, or only one node\\n            if not node or not node.next:\\n                return node\\n\\n\\n            # General case:\\n            next_node = node.next\\n            next_pair = next_node.next\\n\\n            # Reverse next node linkage\\n            next_node.next = node\\n\\n            # Update node linkage to next pair\\n            node.next = helper( next_pair)\\n\\n            # return new head after swap\\n            return next_node\\n        \\n        # ------------------------------\\n\\n        return helper( head )\\n```\\n\\n---\\n\\n**Implementation** by Java:\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if( head == null || head.next == null){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original pointer\\n        ListNode right = head.next;\\n        ListNode nextHop = right.next;\\n        \\n        // reverse linkage of current pair\\n        right.next = head;\\n            \\n        // reverse next pair and get the node of current head\\'s next node\\n        head.next = swapPairs( nextHop );\\n            \\n        return right;\\n        \\n    }\\n}\\n```\\n\\n---\\n\\n**Implementation** by C++\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if( head == nullptr || head->next == nullptr ){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original node\\n        ListNode *right = head->next, *nextPair = head->next->next;\\n        \\n        // reverse current pair\\n        right->next = head;\\n        \\n        // swap next pair recursively\\n        head->next = swapPairs( nextPair );\\n        \\n        return right;\\n        \\n    }\\n};\\n```\\n\\n---\\n\\n**Implementation** by Javascript:\\n\\n```\\nvar swapPairs = function(head) {\\n    \\n    if( head == null || head.next == null ){\\n        \\n        // Base case aka stop condition\\n        return head;\\n    }\\n    \\n    // General cases:\\n    let [right, nextPair] = [head.next, head.next.next];\\n    \\n    // Reverse current pair\\n    right.next = head;\\n    \\n    // Reverse next pair recursively\\n    head.next = swapPairs( nextPair );\\n    \\n    return right;\\n    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nnext_node.next = node\\n```\n```\\nnode.next = helper( next_pair)\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        cur = head\\n               \\n        try:\\n            \\n            # locate head of next pair\\n            next_pair = cur.next.next\\n            \\n            # reverse next pair\\n            junction = self.swapPairs( next_pair )\\n            \\n            # reverse current pair\\n            original_next = cur.next\\n            \\n            original_next.next = cur\\n            \\n            # build new linkage from current pair to next pair\\n            cur.next = junction\\n            \\n            return original_next\\n            \\n        except:\\n            \\n            # Base case:\\n            # Either one node or None remaining\\n            return cur\\n\\n```\n```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def helper( node ):\\n\\n            # Base case: empty node, or only one node\\n            if not node or not node.next:\\n                return node\\n\\n\\n            # General case:\\n            next_node = node.next\\n            next_pair = next_node.next\\n\\n            # Reverse next node linkage\\n            next_node.next = node\\n\\n            # Update node linkage to next pair\\n            node.next = helper( next_pair)\\n\\n            # return new head after swap\\n            return next_node\\n        \\n        # ------------------------------\\n\\n        return helper( head )\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if( head == null || head.next == null){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original pointer\\n        ListNode right = head.next;\\n        ListNode nextHop = right.next;\\n        \\n        // reverse linkage of current pair\\n        right.next = head;\\n            \\n        // reverse next pair and get the node of current head\\'s next node\\n        head.next = swapPairs( nextHop );\\n            \\n        return right;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if( head == nullptr || head->next == nullptr ){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original node\\n        ListNode *right = head->next, *nextPair = head->next->next;\\n        \\n        // reverse current pair\\n        right->next = head;\\n        \\n        // swap next pair recursively\\n        head->next = swapPairs( nextPair );\\n        \\n        return right;\\n        \\n    }\\n};\\n```\n```\\nvar swapPairs = function(head) {\\n    \\n    if( head == null || head.next == null ){\\n        \\n        // Base case aka stop condition\\n        return head;\\n    }\\n    \\n    // General cases:\\n    let [right, nextPair] = [head.next, head.next.next];\\n    \\n    // Reverse current pair\\n    right.next = head;\\n    \\n    // Reverse next pair recursively\\n    head.next = swapPairs( nextPair );\\n    \\n    return right;\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273702,
                "title": "python-solution-in-place",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head and head.next:\\n            dummy = head\\n            head = head.next\\n            dummy.next = head.next\\n            head.next = dummy\\n            head.next.next = self.swapPairs(head.next.next)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head and head.next:\\n            dummy = head\\n            head = head.next\\n            dummy.next = head.next\\n            head.next = dummy\\n            head.next.next = self.swapPairs(head.next.next)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11194,
                "title": "java-recursive-and-iterative-solutions-both-cost-0ms",
                "content": "Recursive:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null) \\n    \\t\\t\\treturn head;\\n    \\t\\tListNode p1 = head, p2 = head.next, p3 = p2.next;\\n    \\t\\tp1.next = p3;\\n    \\t\\tp2.next = p1;\\n    \\t\\t\\n    \\t\\tif (p3 != null) {\\n    \\t\\t\\tp1.next = swapPairs(p3);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn p2;\\n    \\t}\\n\\nIterative:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null)\\n    \\t\\t\\treturn head;\\n    \\t\\tListNode curr = head;\\n    \\t\\tListNode next = head.next;\\n    \\t\\tListNode newHead = next;\\n    \\t\\t\\n    \\t\\tcurr.next = next.next;\\n    \\t\\tnext.next = curr;\\n    \\t\\t\\n    \\t\\tif (curr.next == null)\\n    \\t\\t\\treturn newHead;\\n    \\t\\t\\n    \\t\\twhile (curr.next.next != null) {\\n    \\t\\t\\tListNode prev = curr;\\n    \\t\\t\\tcurr = curr.next;\\n    \\t\\t\\tnext = curr.next;\\n    \\t\\t\\n    \\t\\t\\tprev.next = next;\\n    \\t\\t\\tcurr.next = next.next;\\n    \\t\\t\\tnext.next = curr;\\n    \\t\\t\\t\\n    \\t\\t\\tif (curr.next == null || curr.next.next == null)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn newHead;\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "Recursive:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null) \\n    \\t\\t\\treturn head;\\n    \\t\\tListNode p1 = head, p2 = head.next, p3 = p2.next;\\n    \\t\\tp1.next = p3;\\n    \\t\\tp2.next = p1;\\n    \\t\\t\\n    \\t\\tif (p3 != null) {\\n    \\t\\t\\tp1.next = swapPairs(p3);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn p2;\\n    \\t}\\n\\nIterative:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null)\\n    \\t\\t\\treturn head;\\n    \\t\\tListNode curr = head;\\n    \\t\\tListNode next = head.next;\\n    \\t\\tListNode newHead = next;\\n    \\t\\t\\n    \\t\\tcurr.next = next.next;\\n    \\t\\tnext.next = curr;\\n    \\t\\t\\n    \\t\\tif (curr.next == null)\\n    \\t\\t\\treturn newHead;\\n    \\t\\t\\n    \\t\\twhile (curr.next.next != null) {\\n    \\t\\t\\tListNode prev = curr;\\n    \\t\\t\\tcurr = curr.next;\\n    \\t\\t\\tnext = curr.next;\\n    \\t\\t\\n    \\t\\t\\tprev.next = next;\\n    \\t\\t\\tcurr.next = next.next;\\n    \\t\\t\\tnext.next = curr;\\n    \\t\\t\\t\\n    \\t\\t\\tif (curr.next == null || curr.next.next == null)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn newHead;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 11267,
                "title": "c-solution-easy-to-understand-with-comments-and-explanations",
                "content": "<h1>Renewed Solution</h1>\\n\\nThe main point is that if there are 2 more nodes (which is a pair) following, then swap them, otherwise, end the process.\\n\\n    bool SwapHelper(ListNode *p)\\n    {\\n        if (p->next and p->next->next)\\n        {\\n            ListNode *n1 = p->next;\\n            ListNode *n2 = p->next->next;\\n            \\n            p->next = n2;\\n            n1->next = n2->next;\\n            n2->next = n1;\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    ListNode *swapPairs(ListNode *head) \\n    {\\n        if (!head) \\n            return nullptr;\\n        \\n        // Create a head Node\\n        ListNode new_head(-1);\\n        new_head.next = head;\\n        \\n        ListNode *p = &new_head;\\n        \\n        // While has two more node and swap succeeded\\n        while (SwapHelper(p)) \\n            p = p->next->next;\\n        \\n        return new_head.next;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "<h1>Renewed Solution</h1>\\n\\nThe main point is that if there are 2 more nodes (which is a pair) following, then swap them, otherwise, end the process.\\n\\n    bool SwapHelper(ListNode *p)\\n    {\\n        if (p->next and p->next->next)\\n        {\\n            ListNode *n1 = p->next;\\n            ListNode *n2 = p->next->next;\\n            \\n            p->next = n2;\\n            n1->next = n2->next;\\n            n2->next = n1;\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    ListNode *swapPairs(ListNode *head) \\n    {\\n        if (!head) \\n            return nullptr;\\n        \\n        // Create a head Node\\n        ListNode new_head(-1);\\n        new_head.next = head;\\n        \\n        ListNode *p = &new_head;\\n        \\n        // While has two more node and swap succeeded\\n        while (SwapHelper(p)) \\n            p = p->next->next;\\n        \\n        return new_head.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3529195,
                "title": "easy-java-solution-with-explanation-beating-100-in-tc",
                "content": "# Please Upvote!!!\\n\\n\\n![Screenshot 2023-05-16 at 09.08.07.png](https://assets.leetcode.com/users/images/6223796e-4c86-4b23-8b51-880f70453355_1684208465.7977593.png)\\n\\n\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo swap every two adjacent nodes in a linked list without modifying the node values, you can manipulate the pointers of the nodes. Here\\'s an algorithm to solve the problem:\\n\\nInitialize a dummy node and set its next pointer to the head of the given linked list. This dummy node will be useful as the new head of the modified list.\\nInitialize three pointers: prev, curr, and next. Set prev to the dummy node and curr to the head of the list.\\nIterate through the list while curr and curr.next are not null:\\nSet next to curr.next.\\nPoint curr.next to next.next.\\nPoint next.next to curr.\\nPoint prev.next to next.\\nMove prev to curr.\\nMove curr to curr.next.\\nReturn the modified list\\'s head, which is the dummy node\\'s next node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode nodeSlow = null, nodeFast = head.next;\\n        ListNode temp = head;\\n        temp.next = nodeFast.next;\\n        nodeFast.next = temp;\\n        head = nodeFast;\\n        nodeFast = nodeFast.next;\\n        nodeSlow = head;\\n        while(nodeFast.next!=null){\\n            nodeSlow = nodeSlow.next;\\n            nodeFast = nodeFast.next;\\n\\n            if(nodeFast.next!=null) {\\n                nodeSlow.next = nodeFast.next;\\n                temp = nodeFast.next.next;\\n                nodeSlow.next.next = nodeFast;\\n                nodeFast.next = temp;\\n                nodeSlow = nodeSlow.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode nodeSlow = null, nodeFast = head.next;\\n        ListNode temp = head;\\n        temp.next = nodeFast.next;\\n        nodeFast.next = temp;\\n        head = nodeFast;\\n        nodeFast = nodeFast.next;\\n        nodeSlow = head;\\n        while(nodeFast.next!=null){\\n            nodeSlow = nodeSlow.next;\\n            nodeFast = nodeFast.next;\\n\\n            if(nodeFast.next!=null) {\\n                nodeSlow.next = nodeFast.next;\\n                temp = nodeFast.next.next;\\n                nodeSlow.next.next = nodeFast;\\n                nodeFast.next = temp;\\n                nodeSlow = nodeSlow.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528787,
                "title": "c-best-shortest-3-lines-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck if the linked list is empty or has only one node. If so, return the head of the linked list. \\n\\nOtherwise, create a pointer next to the second node in the linked list.\\n\\nSet the next pointer of the first node to the result of recursively calling swapPairs on the third node (if it exists) and beyond.\\n\\nSet the next pointer of the next node to the first node.\\nReturn the next node as the new head of the linked list.\\nDone !!!!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if (!head || !head->next) {\\n        return head;\\n    }\\n    ListNode* next = head->next;\\n    head->next = swapPairs(next->next);\\n    next->next = head;\\n    return next;\\n}\\n\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/ab237660-fad0-4f6c-b23d-642be5c4aa75_1684195692.93272.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion",
                    "Doubly-Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if (!head || !head->next) {\\n        return head;\\n    }\\n    ListNode* next = head->next;\\n    head->next = swapPairs(next->next);\\n    next->next = head;\\n    return next;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528782,
                "title": "java-recursion-beats-100-12-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Recursively traverse the list to the end.\\n2. On the way back return every node at an even number position.\\n3. Update the `next` pointers for nodes at odd and even positions with their own logic.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int cnt = 0;\\n\\n  public ListNode swapPairs(ListNode node) {\\n    if (node == null) return null;\\n\\n    cnt++;\\n    var ret = swapPairs(node.next);\\n\\n    if (cnt % 2 == 1 && ret != null) {\\n      // node -> the first (left) node in each pair\\n      node.next = ret.next;\\n      ret.next = node;\\n    } else {\\n      // node -> the second (right) node in each pair\\n      node.next = ret;\\n      ret = node;\\n    }\\n    cnt--;\\n    return ret;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  int cnt = 0;\\n\\n  public ListNode swapPairs(ListNode node) {\\n    if (node == null) return null;\\n\\n    cnt++;\\n    var ret = swapPairs(node.next);\\n\\n    if (cnt % 2 == 1 && ret != null) {\\n      // node -> the first (left) node in each pair\\n      node.next = ret.next;\\n      ret.next = node;\\n    } else {\\n      // node -> the second (right) node in each pair\\n      node.next = ret;\\n      ret = node;\\n    }\\n    cnt--;\\n    return ret;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142432,
                "title": "c-solution-easy-to-understand-recursion",
                "content": "# Intuition\\nA pretty simple approach using recursion\\n\\n# Approach\\n1. We have to keep in mind that while swapping, we are only working with two nodes at a time.\\n2. I have written the swapping steps under the comment in the code. Take a piece of paper and try to dry run it on two nodes, You will get it.\\n3. Now we know how I am swapping them, One case is solved, rest will be done by recursion.\\n4. After swapping the first two nodes, we will attach the result of swapping after the recursion has done it\\'s work.\\n5. we will have to return the temp as it will be pointing to the first node of the swapping result.\\n6. and we\\'re DONE !!\\n\\nMy solution is not the best, but is easy to understand for the beginners. \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL)\\n            return NULL;\\n\\n        if(head->next == NULL)\\n            return head;\\n\\n        ListNode* tempHead = head;\\n\\n        //swapping\\n        ListNode* temp = tempHead->next;\\n        tempHead->next = tempHead->next->next;\\n        temp->next = tempHead;\\n        //tempHead = tempHead->next;\\n\\n        tempHead->next = swapPairs(tempHead->next);\\n\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL)\\n            return NULL;\\n\\n        if(head->next == NULL)\\n            return head;\\n\\n        ListNode* tempHead = head;\\n\\n        //swapping\\n        ListNode* temp = tempHead->next;\\n        tempHead->next = tempHead->next->next;\\n        temp->next = tempHead;\\n        //tempHead = tempHead->next;\\n\\n        tempHead->next = swapPairs(tempHead->next);\\n\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774660,
                "title": "easy-c-100-faster-solution",
                "content": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL or head->next==NULL) return head;\\n        ListNode* a = NULL;\\n        ListNode* b = head;\\n        ListNode* c = head->next;\\n        \\n        while(b!=NULL && c!=NULL){\\n            if(a==NULL){\\n                b->next = c->next;\\n                c->next = b;\\n                head = c;\\n            }else{\\n                a->next = c;\\n                b->next = c->next;\\n                c->next = b;\\n            }\\n            a = b;\\n            b = b->next;\\n            if(b) c = b->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL or head->next==NULL) return head;\\n        ListNode* a = NULL;\\n        ListNode* b = head;\\n        ListNode* c = head->next;\\n        \\n        while(b!=NULL && c!=NULL){\\n            if(a==NULL){\\n                b->next = c->next;\\n                c->next = b;\\n                head = c;\\n            }else{\\n                a->next = c;\\n                b->next = c->next;\\n                c->next = b;\\n            }\\n            a = b;\\n            b = b->next;\\n            if(b) c = b->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487511,
                "title": "python-easy-with-dummy-head-clean-concise",
                "content": "```python\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        \\n        def addNode(node):\\n            nonlocal curHead\\n            curHead.next = node\\n            curHead = curHead.next\\n        \\n        while head != None and head.next != None:\\n            nxt = head.next\\n            nxt2 = nxt.next\\n            \\n            addNode(nxt)  # Add nxt node\\n            addNode(head) # Add cur node\\n            \\n            head = nxt2\\n            \\n        if head != None:  # If there is a left node -> Add that node\\n            addNode(head)\\n        curHead.next = None\\n        \\n        return dummyHead.next\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 100` is number of nodes in the linked list.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        \\n        def addNode(node):\\n            nonlocal curHead\\n            curHead.next = node\\n            curHead = curHead.next\\n        \\n        while head != None and head.next != None:\\n            nxt = head.next\\n            nxt2 = nxt.next\\n            \\n            addNode(nxt)  # Add nxt node\\n            addNode(head) # Add cur node\\n            \\n            head = nxt2\\n            \\n        if head != None:  # If there is a left node -> Add that node\\n            addNode(head)\\n        curHead.next = None\\n        \\n        return dummyHead.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485546,
                "title": "c-easytounderstand-recursion-faster-than-100-less-memory-than-99-88",
                "content": "If you have any queries, be sure to ask \\u270C.\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next == NULL){  // If List is empty otr has only 1 node return;\\n            return head;\\n        }\\n        \\n        ListNode* first = head; // first pointer to List\\'s first node\\n        ListNode* second = head->next; // second pointer to List\\'s second node\\n        ListNode* third = head->next->next; // third pointer to List\\'s third node\\n        \\n        second->next = first; // Made second\\'s next point to first instead of third. So, it\\'s like first\\'s next and second\\'s next are pointing to second and first respectively.\\n\\t\\t\\n        first->next = swapPairs(third); // made first\\'s next point to swapPairs(third), because we assume, recursion will swap the rest of the pairs and whatever it will return first\\'s next will point to that node.\\n        \\n        return second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next == NULL){  // If List is empty otr has only 1 node return;\\n            return head;\\n        }\\n        \\n        ListNode* first = head; // first pointer to List\\'s first node\\n        ListNode* second = head->next; // second pointer to List\\'s second node\\n        ListNode* third = head->next->next; // third pointer to List\\'s third node\\n        \\n        second->next = first; // Made second\\'s next point to first instead of third. So, it\\'s like first\\'s next and second\\'s next are pointing to second and first respectively.\\n\\t\\t\\n        first->next = swapPairs(third); // made first\\'s next point to swapPairs(third), because we assume, recursion will swap the rest of the pairs and whatever it will return first\\'s next will point to that node.\\n        \\n        return second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430366,
                "title": "c-well-commented",
                "content": "```\\nLets take an example : 1 2 3 4\\nBase condition at top is if linked list has no element or 1 element just return the head itself .\\nNow we have 2 pointers p pointing to head i.e. 1 and res pointing to head->next i.e. 2\\nTwo more pointers q and temp of ListNode type.\\nWhile(true)\\n{\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n\\t\\t\\t\\nthis above statements simply means in first iteration :  temp will point to 3 and 2->1 will be achieved , if statement of temp wont execute \\n\\n            p->next = temp->next;\\n            p = temp;\\n\\t\\t\\t\\nAbove 2 statements means : 1\\'s link with 4 will be established and value of temp i.e 3 will be stored in p, so now p contains 3 that points to 4.\\nSame way 2nd iteration will execute and 3->4 will turn into 4->3 and this time if statement inside while loop will execute as temp has become null, \\np->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n}\\nWe are returning res as it points to 2 which can give us entire linked list i.e : 2 -> 1 -> 4 -> 3 -> NULL\\nupvote if u like it .\\n```\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) \\n            return head;\\n        \\n        ListNode* p = head;\\n        ListNode* res = head->next;\\n        ListNode* q; ListNode* temp;\\n        \\n        while(true)\\n        {\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nLets take an example : 1 2 3 4\\nBase condition at top is if linked list has no element or 1 element just return the head itself .\\nNow we have 2 pointers p pointing to head i.e. 1 and res pointing to head->next i.e. 2\\nTwo more pointers q and temp of ListNode type.\\nWhile(true)\\n{\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n\\t\\t\\t\\nthis above statements simply means in first iteration :  temp will point to 3 and 2->1 will be achieved , if statement of temp wont execute \\n\\n            p->next = temp->next;\\n            p = temp;\\n\\t\\t\\t\\nAbove 2 statements means : 1\\'s link with 4 will be established and value of temp i.e 3 will be stored in p, so now p contains 3 that points to 4.\\nSame way 2nd iteration will execute and 3->4 will turn into 4->3 and this time if statement inside while loop will execute as temp has become null, \\np->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n}\\nWe are returning res as it points to 2 which can give us entire linked list i.e : 2 -> 1 -> 4 -> 3 -> NULL\\nupvote if u like it .\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) \\n            return head;\\n        \\n        ListNode* p = head;\\n        ListNode* res = head->next;\\n        ListNode* q; ListNode* temp;\\n        \\n        while(true)\\n        {\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422154,
                "title": "c-easy-to-understand-swap-nodes-two-methods",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Iterative**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if(head==NULL)\\n    return NULL;\\n    if(head->next==NULL)\\n    return head;\\n    ListNode *dummy=new ListNode(-1);\\n    ListNode* curr=head;\\n    ListNode* prev=dummy;    \\n    prev->next=curr;\\n    while(curr&&curr->next)\\n    {\\n    prev->next=curr->next;\\n    curr->next=curr->next->next;\\n    prev->next->next=curr;\\n    prev=prev->next->next;\\n    curr=curr->next;\\n    }   \\n return dummy->next;   \\n}\\n};\\n```\\n**Recursive**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        //base case\\n        if(!head || !head->next) return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next); \\n        temp->next = head;\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if(head==NULL)\\n    return NULL;\\n    if(head->next==NULL)\\n    return head;\\n    ListNode *dummy=new ListNode(-1);\\n    ListNode* curr=head;\\n    ListNode* prev=dummy;    \\n    prev->next=curr;\\n    while(curr&&curr->next)\\n    {\\n    prev->next=curr->next;\\n    curr->next=curr->next->next;\\n    prev->next->next=curr;\\n    prev=prev->next->next;\\n    curr=curr->next;\\n    }   \\n return dummy->next;   \\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        //base case\\n        if(!head || !head->next) return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next); \\n        temp->next = head;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301987,
                "title": "c-solution",
                "content": "**Intuition**\\nSwap the node pairs is not difficult, but link node paris after swapping is tricky. We need to use ```prev``` to record the first node ```s1``` of the previous node pair, and then link it to the next node pair.\\n\\n![image](https://assets.leetcode.com/users/images/773756a7-225c-41cb-895b-aecc89dddfa2_1634282202.369622.png)\\n\\n**complexity**\\n- time: O(N)\\n- space: O(1)\\n\\n**implementation**\\n```\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode s1 = null;\\n        ListNode s2 = null;\\n        \\n        while(prev != null && prev.next != null && prev.next.next != null)\\n        {\\n            s1 = prev.next;\\n            s2 = prev.next.next;\\n            prev.next = s2;\\n            s1.next = s2.next;\\n            s2.next = s1;\\n            prev = s1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```prev```\n```s1```\n```\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode s1 = null;\\n        ListNode s2 = null;\\n        \\n        while(prev != null && prev.next != null && prev.next.next != null)\\n        {\\n            s1 = prev.next;\\n            s2 = prev.next.next;\\n            prev.next = s2;\\n            s1.next = s2.next;\\n            s2.next = s1;\\n            prev = s1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683353,
                "title": "javascript",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let cur = head;\\n    let newHead = head && head.next ? head.next : head;\\n        \\n    while (cur && cur.next) {\\n        let next = cur.next;\\n        let temp = next.next;\\n        \\n        next.next = cur;\\n        cur.next = temp && temp.next ? temp.next : temp;\\n        \\n        cur = temp;\\n    }\\n\\n    \\n    return newHead;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let cur = head;\\n    let newHead = head && head.next ? head.next : head;\\n        \\n    while (cur && cur.next) {\\n        let next = cur.next;\\n        let temp = next.next;\\n        \\n        next.next = cur;\\n        cur.next = temp && temp.next ? temp.next : temp;\\n        \\n        cur = temp;\\n    }\\n\\n    \\n    return newHead;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674270,
                "title": "c-o-n-solution-beats-100-in-time-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/swap-nodes-in-pairs/\\n    \\n    Idea is to take 2 ndoes at a time and swap them, then make the\\n    2st node connected to the 3rd node if there and continue with the 3rd node.\\n    TC: O(N), SC:O(1)\\n*/\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // We use a dummy head node to make handling head operations simpler\\n        ListNode *dummy = new ListNode(-1), *tail = dummy;\\n        // add the dummy node to list\\n        tail->next = head;\\n        \\n        while(head && head->next) {\\n            ListNode *nextptr = head->next->next;\\n            // swap the adjacent nodes\\n            // 2nd node comes to 1st pos \\n            tail->next = head->next;\\n            // connecting 2nd node to 1st node\\n            (head->next)->next = head;\\n            // make the 1st node connected to next node on list\\n            tail = head;\\n            tail->next = nextptr;\\n            head = nextptr;\\n        }\\n        \\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/swap-nodes-in-pairs/\\n    \\n    Idea is to take 2 ndoes at a time and swap them, then make the\\n    2st node connected to the 3rd node if there and continue with the 3rd node.\\n    TC: O(N), SC:O(1)\\n*/\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // We use a dummy head node to make handling head operations simpler\\n        ListNode *dummy = new ListNode(-1), *tail = dummy;\\n        // add the dummy node to list\\n        tail->next = head;\\n        \\n        while(head && head->next) {\\n            ListNode *nextptr = head->next->next;\\n            // swap the adjacent nodes\\n            // 2nd node comes to 1st pos \\n            tail->next = head->next;\\n            // connecting 2nd node to 1st node\\n            (head->next)->next = head;\\n            // make the 1st node connected to next node on list\\n            tail = head;\\n            tail->next = nextptr;\\n            head = nextptr;\\n        }\\n        \\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501576,
                "title": "java-100-and-only-11-lines",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null){\\n            return head;\\n        }\\n        ListNode l = head.next;\\n        head.next = swapPairs(head.next.next);\\n        l.next = head;\\n        return l;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null){\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11241,
                "title": "my-simple-recursive-c-solution-in-6-lines-4ms",
                "content": "    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL) { return NULL; }\\n        if (head ->next == NULL) { return head; }\\n        \\n        ListNode *newHead = head->next;\\n        head->next = swapPairs(head->next->next);\\n        newHead->next = head;\\n        return newHead;\\n    }",
                "solutionTags": [
                    "Linked List",
                    "Recursion"
                ],
                "code": "    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL) { return NULL; }\\n        if (head ->next == NULL) { return head; }\\n        \\n        ListNode *newHead = head->next;\\n        head->next = swapPairs(head->next->next);\\n        newHead->next = head;\\n        return newHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11278,
                "title": "ac-java-solution",
                "content": "    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode n1 = head;\\n        ListNode n2 = head.next;\\n        \\n        n1.next = n2.next;\\n        n2.next = n1;\\n        \\n        n1.next = swapPairs(n1.next);\\n        \\n        return n2;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode n1 = head;\\n        ListNode n2 = head.next;\\n        \\n        n1.next = n2.next;\\n        n2.next = n1;\\n        \\n        n1.next = swapPairs(n1.next);\\n        \\n        return n2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3531484,
                "title": "think-recursive-python-c-golang",
                "content": "# Intuition\\nLet\\'s solve a very basic problem, like if we have only two nodes in linked list something like this\\n![Screenshot from 2023-05-16 21-18-05.png](https://assets.leetcode.com/users/images/1d8eaf14-3512-4e3d-bc46-57e3dd6746f0_1684253393.1944199.png)\\n\\nThen, our approach is divided into 3 steps\\n* ***Step1*** Set CurrNode\\'s next to NextNode\\'s next\\n![Screenshot from 2023-05-16 21-21-08.png](https://assets.leetcode.com/users/images/0409e8be-a0f4-49de-8ca8-7cf14ba869be_1684253489.2341714.png)\\n\\n* ***Step2*** Set NextNode\\'s next to CurrNode\\n![Screenshot from 2023-05-16 21-25-06.png](https://assets.leetcode.com/users/images/362d02de-00fc-4e49-a1c2-2c80404593c9_1684253531.1400237.png)\\n\\n* ***Step3*** We are done with swapping now, we have to return the NextNode as our new head.\\n![Screenshot from 2023-05-16 21-28-32.png](https://assets.leetcode.com/users/images/dc72258a-ac45-4dfe-8045-4d4cb40b279a_1684253573.5092244.png)\\n\\nWe have solved our problem, now we have to implement this logic\\n\\n# Approach\\n* If Head node is empty or Head\\'s next is empty, return Head ecause we don\\'t have anything to perform our logic\\n\\n* Set NextNode to Head->next\\n\\n* Now, Set recursion result to Head->next\\n\\n* Now, Set NextNode->next to head\\n\\n* Finally, return the NextNode which is our ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nWhere n is the length of the linked list.\\n`Note: We have traversed only half linked list.`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\nBecause we haven\\'t consumed any extra space.\\n`Note: We consumed some auxiliary space for recursion stack.`\\n\\n# Code\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        nextNode = head.next\\n        head.next = self.swapPairs(head.next.next)\\n        nextNode.next = head\\n\\n        return nextNode\\n\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head or !head->next) return head;\\n\\n        ListNode* nextNode = head->next;\\n        head->next = swapPairs(head->next->next);\\n        nextNode->next = head;\\n\\n        return nextNode;\\n    }\\n};\\n```\\n```Go []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil {\\n        return head\\n    }\\n\\n    nextNode := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    nextNode.Next = head\\n\\n    return nextNode    \\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Go",
                    "Recursion"
                ],
                "code": "```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        nextNode = head.next\\n        head.next = self.swapPairs(head.next.next)\\n        nextNode.next = head\\n\\n        return nextNode\\n\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head or !head->next) return head;\\n\\n        ListNode* nextNode = head->next;\\n        head->next = swapPairs(head->next->next);\\n        nextNode->next = head;\\n\\n        return nextNode;\\n    }\\n};\\n```\n```Go []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil {\\n        return head\\n    }\\n\\n    nextNode := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    nextNode.Next = head\\n\\n    return nextNode    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528845,
                "title": "python-3-4-lines-t-m-98-65",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```\\n[https://leetcode.com/submissions/detail/582543531/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151844,
                "title": "beats-100-java-recursive-approach-swapping-nodes-simple-solution",
                "content": "# Intuition\\nWe can solve it by doing simple swapping of nodes!\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\n0(n) [Recursion stack]\\n# Code\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode temp = head.next;\\n        swapper(head);\\n        return temp;\\n    }\\n    void swapper(ListNode head)\\n    {\\n        if(head == null || head.next == null) return;\\n        ListNode temp = head.next;\\n        head.next = head.next.next;\\n        temp.next = head;\\n        ListNode temp2 = null;\\n        if(head.next != null)\\n         temp2 = head.next.next;\\n        swapper(head.next);\\n        if(temp2 != null)\\n        head.next = temp2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode temp = head.next;\\n        swapper(head);\\n        return temp;\\n    }\\n    void swapper(ListNode head)\\n    {\\n        if(head == null || head.next == null) return;\\n        ListNode temp = head.next;\\n        head.next = head.next.next;\\n        temp.next = head;\\n        ListNode temp2 = null;\\n        if(head.next != null)\\n         temp2 = head.next.next;\\n        swapper(head.next);\\n        if(temp2 != null)\\n        head.next = temp2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044431,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* temp=head->next;\\n        head->next=swapPairs(head->next->next);\\n        temp->next=head;\\n        return temp;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* temp=head->next;\\n        head->next=swapPairs(head->next->next);\\n        temp->next=head;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014145,
                "title": "100-beats-java-solution-executed-in-0ms-using-three-pointer-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Three Pointer Iterative Approach where the swapping is done with help of Three Pointers**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to solve this problem is the three pointer approach, where I have taken the three pointers and with the help of that the swapping of nodes is done, The programming language used is Java. Here the three nodes p for previous, c for current and cn for current_next is taken and also the d node is taken at the starting which will act as p in the first iteration. \\n\\nSuppose the linked list is given\\n1-->2-->3-->4-->null\\nthen first we have declared the d node such that it\\'s next pointer points to the head of the linked list hence\\nD-->1-->2-->3-->4-->null\\nNow During the first Iteration\\n![Untitled.jpg](https://assets.leetcode.com/users/images/036ca02f-24e3-4523-8a2e-61e7b6676f0a_1673101141.142306.jpeg)\\nAfter First Iteration \\n![Untitled.jpg](https://assets.leetcode.com/users/images/78144949-1a21-4c30-837d-297959ae7f54_1673101304.5513315.jpeg)\\nHence as the processing of swapping will be done the pointers will be moved as \\n![Untitled.jpg](https://assets.leetcode.com/users/images/ae9c0caf-c34e-41f3-8162-a6104bce1311_1673101484.9050355.jpeg)\\nAnd again the processing of swapping will be done\\nTill the c and cn is null.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**Time Complexity - O(n)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**Space Compleixty - O(1)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode d = new ListNode(0);\\n        d.next = head;\\n        ListNode p = d;\\n        ListNode c = d.next;\\n        while(c!=null){\\n            ListNode cn = c.next;\\n            if(cn==null){\\n                break;\\n            }\\n            c.next = cn.next;\\n            cn.next=p.next;\\n            p.next = cn;\\n            p = c;\\n            c = c.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode d = new ListNode(0);\\n        d.next = head;\\n        ListNode p = d;\\n        ListNode c = d.next;\\n        while(c!=null){\\n            ListNode cn = c.next;\\n            if(cn==null){\\n                break;\\n            }\\n            c.next = cn.next;\\n            cn.next=p.next;\\n            p.next = cn;\\n            p = c;\\n            c = c.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882193,
                "title": "simple-rust-recursive-solution",
                "content": "# Approach\\nSwaps the first pair, then recurses to handle the rest of the list\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ additional space\\n\\n# Code\\n```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        match head {\\n            Some(mut h) => {\\n                match h.next {\\n                    Some(mut n) => {\\n                        h.next = Solution::swap_pairs(n.next);\\n                        n.next = Some(h);\\n                        Some(n)\\n                    },\\n                    _ => Some(h),\\n                }\\n            },\\n            _ => head,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        match head {\\n            Some(mut h) => {\\n                match h.next {\\n                    Some(mut n) => {\\n                        h.next = Solution::swap_pairs(n.next);\\n                        n.next = Some(h);\\n                        Some(n)\\n                    },\\n                    _ => Some(h),\\n                }\\n            },\\n            _ => head,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2374316,
                "title": "easy-to-understand-simple-java-0ms-100-faster-solution-singlylinkedlist-space",
                "content": "**Please  \\uD83D\\uDC4D this.solution if(you understood == true)**\\n\\n```\\n// Best Approach : Recursive\\n// Space Complexity : O(n)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if ((head == null)||(head.next == null))\\n            return head;\\n        ListNode n = head.next;\\n        head.next = swapPairs(head.next.next);\\n        n.next = head;\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// Best Approach : Recursive\\n// Space Complexity : O(n)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if ((head == null)||(head.next == null))\\n            return head;\\n        ListNode n = head.next;\\n        head.next = swapPairs(head.next.next);\\n        n.next = head;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303855,
                "title": "easy-0-ms-100-faster-fully-explained-c-java-c-language-js",
                "content": "# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        //Base condition\\n        if(!head || !head->next)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode* tmp = new ListNode(0);\\n        tmp->next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode* curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr->next && curr->next->next){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode* n1 = curr->next;\\n            ListNode* n2 = curr->next->next;\\n            \\n            n1->next = n2->next;              // Point the next of n1 to the node after n2\\n            curr->next = n2;                 // Now n2 node should be the curr.next node.\\n            curr->next->next = n1;            // Linking n2 to the n1 node.\\n            curr = curr->next->next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp->next;    //at last return the tmp.next\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        //Base condition\\n        if(head == null || head.next == null)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode tmp = new ListNode(0);\\n        tmp.next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr.next != null && curr.next.next != null){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode n1 = curr.next;\\n            ListNode n2 = curr.next.next;\\n            \\n            n1.next = n2.next;              // Point the next of n1 to the node after n2\\n            curr.next = n2;                 // Now n2 node should be the curr.next node.\\n            curr.next.next = n1;            // Linking n2 to the n1 node.\\n            curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp.next;    //at last return the tmp.next\\n    }\\n}\\n```\\n\\n# **C Language:**\\n```\\n//Another approach is here...\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n        return head;\\n    struct ListNode* temp = head->next;\\n    head->next = swapPairs(temp->next);  //call recursively.\\n    temp->next = head;\\n    return temp;\\n}\\n```\\n\\n# **Javascript Solution:**\\n```\\nvar swapPairs = function(head) {\\n    \\n    //Base condition\\n    if(head == null || head.next == null)   \\n    return head;\\n        \\n    //Create a tmp node whose next pointer will point to the current head\\n    const tmp = new ListNode(0);\\n    tmp.next = head;\\n        \\n    //Now take a curr node which will be used to traverse the list\\n    let curr = tmp;\\n        \\n    // Loop until we reach to the second last node...\\n    while(curr.next != null && curr.next.next != null){\\n            \\n        //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n        let n1 = curr.next;\\n        let n2 = curr.next.next;\\n            \\n        n1.next = n2.next;              // Point the next of n1 to the node after n2\\n        curr.next = n2;                 // Now n2 node should be the curr.next node.\\n        curr.next.next = n1;            // Linking n2 to the n1 node.\\n        curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n    return tmp.next;    //at last return the tmp.next\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        //Base condition\\n        if(!head || !head->next)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode* tmp = new ListNode(0);\\n        tmp->next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode* curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr->next && curr->next->next){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode* n1 = curr->next;\\n            ListNode* n2 = curr->next->next;\\n            \\n            n1->next = n2->next;              // Point the next of n1 to the node after n2\\n            curr->next = n2;                 // Now n2 node should be the curr.next node.\\n            curr->next->next = n1;            // Linking n2 to the n1 node.\\n            curr = curr->next->next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp->next;    //at last return the tmp.next\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        //Base condition\\n        if(head == null || head.next == null)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode tmp = new ListNode(0);\\n        tmp.next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr.next != null && curr.next.next != null){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode n1 = curr.next;\\n            ListNode n2 = curr.next.next;\\n            \\n            n1.next = n2.next;              // Point the next of n1 to the node after n2\\n            curr.next = n2;                 // Now n2 node should be the curr.next node.\\n            curr.next.next = n1;            // Linking n2 to the n1 node.\\n            curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp.next;    //at last return the tmp.next\\n    }\\n}\\n```\n```\\n//Another approach is here...\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n        return head;\\n    struct ListNode* temp = head->next;\\n    head->next = swapPairs(temp->next);  //call recursively.\\n    temp->next = head;\\n    return temp;\\n}\\n```\n```\\nvar swapPairs = function(head) {\\n    \\n    //Base condition\\n    if(head == null || head.next == null)   \\n    return head;\\n        \\n    //Create a tmp node whose next pointer will point to the current head\\n    const tmp = new ListNode(0);\\n    tmp.next = head;\\n        \\n    //Now take a curr node which will be used to traverse the list\\n    let curr = tmp;\\n        \\n    // Loop until we reach to the second last node...\\n    while(curr.next != null && curr.next.next != null){\\n            \\n        //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n        let n1 = curr.next;\\n        let n2 = curr.next.next;\\n            \\n        n1.next = n2.next;              // Point the next of n1 to the node after n2\\n        curr.next = n2;                 // Now n2 node should be the curr.next node.\\n        curr.next.next = n1;            // Linking n2 to the n1 node.\\n        curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n    return tmp.next;    //at last return the tmp.next\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260102,
                "title": "2-pointer-approach-with-diagram-in-c",
                "content": "![image](https://assets.leetcode.com/users/images/61041d00-400c-4eaf-b071-a8a9355894cf_1657454552.3188987.png)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        ListNode* prev = dummy;\\n        \\n        ListNode* curr = head;\\n        ListNode *second, *nextPair;\\n        \\n        if(head == NULL || head -> next == NULL)\\n            return head;\\n        \\n        while(curr && curr -> next){\\n            second = curr -> next;\\n            nextPair = curr -> next -> next;\\n            \\n            second -> next = curr;\\n            curr -> next = nextPair;\\n            prev -> next = second;\\n            \\n            prev = curr;\\n            curr = nextPair;\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n[Further Explanation : NeetCode](https://youtu.be/o811TZLAWOo)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        ListNode* prev = dummy;\\n        \\n        ListNode* curr = head;\\n        ListNode *second, *nextPair;\\n        \\n        if(head == NULL || head -> next == NULL)\\n            return head;\\n        \\n        while(curr && curr -> next){\\n            second = curr -> next;\\n            nextPair = curr -> next -> next;\\n            \\n            second -> next = curr;\\n            curr -> next = nextPair;\\n            prev -> next = second;\\n            \\n            prev = curr;\\n            curr = nextPair;\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150670,
                "title": "fastest-100-faster-0ms-java-solution",
                "content": "ListNode cur=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        ListNode first=head;\\n        int c=1;\\n        while(cur!=null&&c<3){\\n            next=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=next;\\n            if(c==2)\\n                first.next=swapPairs(cur);\\n            c++;\\n        }\\n        return prev;",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "ListNode cur=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        ListNode first=head;\\n        int c=1;\\n        while(cur!=null&&c<3){\\n            next=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=next;\\n            if(c==2)\\n                first.next=swapPairs(cur);\\n            c++;\\n        }\\n        return prev;",
                "codeTag": "Unknown"
            },
            {
                "id": 2037031,
                "title": "java-0ms-100-faster-2-methods",
                "content": "*1. First way using iteration :-*\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n      if(head == null || head.next == null)\\n        return head;\\n       ListNode curr = head.next;\\n      ListNode prev = head;\\n      ListNode next = null;\\n      ListNode newHead = curr;\\n      while(curr != null)\\n      {\\n        next = curr.next;\\n        curr.next = prev;\\n        if(next == null || next.next == null)\\n        {\\n          prev.next = next;\\n          curr = null;\\n        }\\n        else\\n        {\\n          curr = next.next;\\n          prev.next = curr;\\n          prev = next;\\n        }\\n      }\\n      return newHead;\\n    }\\n}\\n```\\n\\n*2. Second way using recursion :-*\\n\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n      if(head == null || head.next == null)\\n        return head;\\n\\t\\tListNode second = head.next;\\n\\t\\tListNode third = second.next;\\n\\t\\tsecond.next = head;\\n\\t\\thead.next = swapPairs(third);\\n\\t\\treturn second;\\n\\t}\\n}\\n\\t\\t",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n      if(head == null || head.next == null)\\n        return head;\\n       ListNode curr = head.next;\\n      ListNode prev = head;\\n      ListNode next = null;\\n      ListNode newHead = curr;\\n      while(curr != null)\\n      {\\n        next = curr.next;\\n        curr.next = prev;\\n        if(next == null || next.next == null)\\n        {\\n          prev.next = next;\\n          curr = null;\\n        }\\n        else\\n        {\\n          curr = next.next;\\n          prev.next = curr;\\n          prev = next;\\n        }\\n      }\\n      return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775381,
                "title": "my-java-code-faster-than-100-without-recursion",
                "content": "```\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null){\\n            return null;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        \\n        \\n        ListNode current = head;\\n        ListNode dummy = new ListNode(-1); // dummy node\\n        ListNode prev =dummy;\\n        while(current != null && current.next != null){\\n            prev.next = current.next;\\n            current.next = current.next.next;\\n            prev.next.next = current;\\n            \\n            // now update the current and prev \\n            current = current.next;\\n            prev = prev.next.next;\\n        }\\n        return dummy.next;\\n    }\\n```\\nFor solving any linked list problem like this, it will be good to use the help of dummy node\\nSo we will create a dummy node with any value (let suppose -1 ) and we will return dummy.next because its gonna be our new head.\\n\\nDry Run - 1-->2-->3-->4 ,      dummy node ->  -1 \\ncurrent = head   ->  current is at 1 \\nprev = dummy  -> prev is at -1\\n\\nrun a for loop and check if current node and its next node not be equal to null\\n```prev.next = current.next;```  ->   -1 (prev)  --> 2(next node of current)\\n```current.next = current.next.next;```  ->   1  --> 3 \\n```prev.next.next = current;``` -> -1-->2-->1 (prev is -1, prev.next is 2 and next of 2 is set to 1)\\n\\nnow update the pointers position\\n```current = current.next;``` -> current = 3 \\n```prev = prev.next.next``` -> prev = 1\\n\\nrun all the steps again for current and prev until condition satisfy. \\nI am sharing the code for the first time. If i did any mistake in this post then please forgive me\\uD83D\\uDE42. \\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null){\\n            return null;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        \\n        \\n        ListNode current = head;\\n        ListNode dummy = new ListNode(-1); // dummy node\\n        ListNode prev =dummy;\\n        while(current != null && current.next != null){\\n            prev.next = current.next;\\n            current.next = current.next.next;\\n            prev.next.next = current;\\n            \\n            // now update the current and prev \\n            current = current.next;\\n            prev = prev.next.next;\\n        }\\n        return dummy.next;\\n    }\\n```\n```prev.next = current.next;```\n```current.next = current.next.next;```\n```prev.next.next = current;```\n```current = current.next;```\n```prev = prev.next.next```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775317,
                "title": "c-c-simplest-recursive-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if ((!head) || (!head->next))\\n            return head;\\n\\n        struct ListNode* tmp = head;\\n        head = head->next;\\n        tmp->next = head->next;\\n        head->next = tmp;\\n\\n        head->next->next = swapPairs(head->next->next);\\n        return head;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if ((!head) || (!head->next))\\n            return head;\\n\\n        struct ListNode* tmp = head;\\n        head = head->next;\\n        tmp->next = head->next;\\n        head->next = tmp;\\n\\n        head->next->next = swapPairs(head->next->next);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775223,
                "title": "java-simple-recursion-faster-than-100",
                "content": "**Solution 1**\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode temp=head;\\n        while(temp!=null && temp.next!=null){\\n            int x=temp.val;\\n            temp.val=temp.next.val;\\n            temp.next.val=x;\\n            temp=temp.next.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\n**Solution 2 (without changing values)**\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null)\\n            return null;\\n        return swapPairs(head,head.next);\\n    }\\n    public ListNode swapPairs(ListNode n1,ListNode n2){\\n        if(n1==null || n2==null){\\n            return n1;\\n        }\\n        n1.next=swapPairs(n1.next!=null?n1.next.next:null,n2.next!=null?n2.next.next:null);\\n        n2.next=n1;\\n        return n2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode temp=head;\\n        while(temp!=null && temp.next!=null){\\n            int x=temp.val;\\n            temp.val=temp.next.val;\\n            temp.next.val=x;\\n            temp=temp.next.next;\\n        }\\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null)\\n            return null;\\n        return swapPairs(head,head.next);\\n    }\\n    public ListNode swapPairs(ListNode n1,ListNode n2){\\n        if(n1==null || n2==null){\\n            return n1;\\n        }\\n        n1.next=swapPairs(n1.next!=null?n1.next.next:null,n2.next!=null?n2.next.next:null);\\n        n2.next=n1;\\n        return n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774872,
                "title": "beginner-friendly-python-solution-with-comments",
                "content": "The main logic used is the swapping of values\\n```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        \\n        node=head\\n        c=0\\n        while node:  #loop to check the length of linkedlist\\n            c+=1\\n            node=node.next\\n            \\n        node=head\\n        if c%2!=0:    #If the length of linkedlist is odd then this loop will be executed\\n            while node.next is not None:\\n                node.next.val, node.val=node.val, node.next.val  #swapping the values\\n                node=node.next.next\\n        else:\\n            while node is not None:\\n                node.val, node.next.val=node.next.val, node.val #swapping the values\\n                node=node.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        \\n        node=head\\n        c=0\\n        while node:  #loop to check the length of linkedlist\\n            c+=1\\n            node=node.next\\n            \\n        node=head\\n        if c%2!=0:    #If the length of linkedlist is odd then this loop will be executed\\n            while node.next is not None:\\n                node.next.val, node.val=node.val, node.next.val  #swapping the values\\n                node=node.next.next\\n        else:\\n            while node is not None:\\n                node.val, node.next.val=node.next.val, node.val #swapping the values\\n                node=node.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703662,
                "title": "c-iteration",
                "content": "C# solution by iteration \\n**Runtime: 84 ms, faster than 70.48% of C# online submissions for Swap Nodes in Pairs.\\nMemory Usage: 37.3 MB, less than 48.11% of C# online submissions for Swap Nodes in Pairs.**\\n\\n```\\npublic ListNode SwapPairs(ListNode head) {\\n       \\n\\t\\tListNode tempNode = new ListNode(-1, head);\\n        ListNode prevNode = tempNode;\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null)\\n        {\\n            ListNode firstNode = prevNode.next;\\n            ListNode secondNode= prevNode.next.next;\\n            \\n            firstNode.next = secondNode.next;\\n            secondNode.next = firstNode;\\n            \\n            prevNode.next = secondNode;\\n            \\n            /*resetting the value for prevNode for iteraton*/\\n            prevNode = firstNode;\\n        }\\n        return tempNode.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode SwapPairs(ListNode head) {\\n       \\n\\t\\tListNode tempNode = new ListNode(-1, head);\\n        ListNode prevNode = tempNode;\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null)\\n        {\\n            ListNode firstNode = prevNode.next;\\n            ListNode secondNode= prevNode.next.next;\\n            \\n            firstNode.next = secondNode.next;\\n            secondNode.next = firstNode;\\n            \\n            prevNode.next = secondNode;\\n            \\n            /*resetting the value for prevNode for iteraton*/\\n            prevNode = firstNode;\\n        }\\n        return tempNode.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534508,
                "title": "iterative-easy-soln-runtime-0-ms-faster-than-100-00-of-c",
                "content": "\\n\\n        \\n\\tListNode* swapPairs(ListNode* head)\\n\\t{\\n\\t\\tListNode* dummy = new ListNode(-1);\\n\\t\\tdummy->next = head;\\n\\t\\tListNode* prev = dummy;\\n        while(prev->next !=NULL && prev->next->next !=NULL)\\n        {\\n            ListNode* curr = prev->next;\\n            ListNode* forw = curr->next;\\n            ListNode* temp = forw->next;\\n            \\n            prev->next = forw;\\n            forw->next = curr;\\n            curr->next = temp;\\n            \\n            prev = curr;\\n        }\\n        return dummy->next;\\n        \\n    }\\n\\t",
                "solutionTags": [],
                "code": "\\n\\n        \\n\\tListNode* swapPairs(ListNode* head)\\n\\t{\\n\\t\\tListNode* dummy = new ListNode(-1);\\n\\t\\tdummy->next = head;\\n\\t\\tListNode* prev = dummy;\\n        while(prev->next !=NULL && prev->next->next !=NULL)\\n        {\\n            ListNode* curr = prev->next;\\n            ListNode* forw = curr->next;\\n            ListNode* temp = forw->next;\\n            \\n            prev->next = forw;\\n            forw->next = curr;\\n            curr->next = temp;\\n            \\n            prev = curr;\\n        }\\n        return dummy->next;\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1101344,
                "title": "python-recursion",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # recursion\\n        if not head or not head.next: return head\\n        new_head = head.next\\n        head.next = self.swapPairs(new_head.next)\\n        new_head.next = head\\n        return new_head\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # recursion\\n        if not head or not head.next: return head\\n        new_head = head.next\\n        head.next = self.swapPairs(new_head.next)\\n        new_head.next = head\\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910322,
                "title": "javascript-solution-24",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nlet swapPairs = function(head) {\\n    let dummy=new ListNode();\\n    dummy.next = head;\\n    let result = dummy;\\n    while(dummy.next && dummy.next.next){\\n        let p=dummy.next,q = dummy.next.next;\\n        dummy.next = q;\\n        p.next = q.next;\\n        q.next = p;\\n        dummy = p\\n    }\\n    return result.next\\n};\\n```\\n\\n**Runtime: 72 ms, faster than 87.88% of JavaScript online submissions for Swap Nodes in Pairs.**\\n\\n**Memory Usage: 38.8 MB, less than 40.76% of JavaScript online submissions for Swap Nodes in Pairs.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nlet swapPairs = function(head) {\\n    let dummy=new ListNode();\\n    dummy.next = head;\\n    let result = dummy;\\n    while(dummy.next && dummy.next.next){\\n        let p=dummy.next,q = dummy.next.next;\\n        dummy.next = q;\\n        p.next = q.next;\\n        q.next = p;\\n        dummy = p\\n    }\\n    return result.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748467,
                "title": "python-clean-recursive-and-iterative-solution",
                "content": "Variable names should help understand the solutions easily.\\nRecursive:\\n```\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    if head is None or head.next is None:\\n        return head\\n    newHead = head.next\\n    head.next = self.swapPairs(newHead.next)\\n    newHead.next = head\\n    return newHead\\n```\\nE.g: [1,2,3,4] -> [2,1,4,3]\\nThere will be 3 calls to swapPairs ( 1 normal call + 2 recursive calls)\\n```\\nswapPairs(1)\\n         swapPairs(3)\\n                  swapPairs(None):\\n                  returns None # swapPairs(None)\\n         returns 4 #swapPairs(3)\\nreturns 2 #swapPairs(1)\\n```\\n\\nIterative:\\n```\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n\\tif head is None or head.next is None:\\n\\t\\treturn head\\n\\tfirst, newHead, previous = head, head.next, None\\n\\twhile first and first.next:\\n\\t\\tif previous:\\n\\t\\t\\tprevious.next = first.next\\n\\t\\tsecond = first.next\\n\\t\\tfirst.next = second.next\\n\\t\\tsecond.next = first\\n\\t\\tprevious = first\\n\\t\\tfirst = first.next\\n\\treturn newHead\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    if head is None or head.next is None:\\n        return head\\n    newHead = head.next\\n    head.next = self.swapPairs(newHead.next)\\n    newHead.next = head\\n    return newHead\\n```\n```\\nswapPairs(1)\\n         swapPairs(3)\\n                  swapPairs(None):\\n                  returns None # swapPairs(None)\\n         returns 4 #swapPairs(3)\\nreturns 2 #swapPairs(1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 655218,
                "title": "c-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) return head;\\n        \\n        // get length \\n        ListNode* cur = head; int len=0;\\n        while(cur) {\\n            cur=cur->next; ++len;\\n        }\\n        \\n        ListNode* cur1 = head;   ListNode* cur2 = head->next;  ListNode* head2 = cur2;\\n        ListNode* cur3=NULL;\\n        \\n        while (cur2->next!=NULL) {\\n            \\n            cur1->next = cur2->next;\\n            cur2->next = cur1;\\n            \\n            cur3 = cur1;\\n            \\n            if(cur1->next->next!=NULL) { // so that cur2 is not NULL\\n                cur1 = cur1->next;\\n                cur2 = cur1->next;\\n          \\n                cur3->next = cur2;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        if(len%2==0) {\\n            cur2->next = cur1;\\n            cur1->next = NULL;\\n        }\\n        \\n        return head2;\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/duttaani/image_1590587889.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) return head;\\n        \\n        // get length \\n        ListNode* cur = head; int len=0;\\n        while(cur) {\\n            cur=cur->next; ++len;\\n        }\\n        \\n        ListNode* cur1 = head;   ListNode* cur2 = head->next;  ListNode* head2 = cur2;\\n        ListNode* cur3=NULL;\\n        \\n        while (cur2->next!=NULL) {\\n            \\n            cur1->next = cur2->next;\\n            cur2->next = cur1;\\n            \\n            cur3 = cur1;\\n            \\n            if(cur1->next->next!=NULL) { // so that cur2 is not NULL\\n                cur1 = cur1->next;\\n                cur2 = cur1->next;\\n          \\n                cur3->next = cur2;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        if(len%2==0) {\\n            cur2->next = cur1;\\n            cur1->next = NULL;\\n        }\\n        \\n        return head2;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284762,
                "title": "js-solution-faster-than-100",
                "content": "```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function (head) {\\n    //dummy node\\n    dummy = new ListNode(0)\\n    dummy.next = head\\n\\n    current = dummy\\n    while (current.next && current.next.next) {\\n        temp1 = current.next\\n        temp2 = current.next.next\\n\\n        current.next.next = current.next.next.next\\n        current.next = temp2\\n        current.next.next = temp1\\n\\n        //current move to next 2 pos\\n        current = current.next.next\\n    }\\n\\n    return dummy.next\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function (head) {\\n    //dummy node\\n    dummy = new ListNode(0)\\n    dummy.next = head\\n\\n    current = dummy\\n    while (current.next && current.next.next) {\\n        temp1 = current.next\\n        temp2 = current.next.next\\n\\n        current.next.next = current.next.next.next\\n        current.next = temp2\\n        current.next.next = temp1\\n\\n        //current move to next 2 pos\\n        current = current.next.next\\n    }\\n\\n    return dummy.next\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176015,
                "title": "simple-go-solution",
                "content": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n        list := &ListNode{Next: head}\\n        for prev, node := list, list.Next; node != nil; node = node.Next {\\n                if node.Next != nil {\\n                        swapNode(prev, node, node.Next)\\n                        prev = node\\n                }\\n        }\\n        return list.Next\\n}\\n\\nfunc swapNode(prev, node, next *ListNode) {\\n        prev.Next = next\\n        node.Next = next.Next\\n        next.Next = node\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n        list := &ListNode{Next: head}\\n        for prev, node := list, list.Next; node != nil; node = node.Next {\\n                if node.Next != nil {\\n                        swapNode(prev, node, node.Next)\\n                        prev = node\\n                }\\n        }\\n        return list.Next\\n}\\n\\nfunc swapNode(prev, node, next *ListNode) {\\n        prev.Next = next\\n        node.Next = next.Next\\n        next.Next = node\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11195,
                "title": "java-0ms-using-recusion",
                "content": "    public ListNode swapPairs(ListNode head) {\\n\\t\\tif(head == null || head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n\\t\\tListNode p1 = head, p2 = head.next, p3 = null;\\n\\t\\tp3 = p2.next;\\n\\t\\tp2.next = null;\\n\\t\\tp1.next.next = p1;\\n\\t\\tp1.next = p3;\\n\\t\\t\\n\\t\\tif(p3 != null)\\n\\t\\t\\tp1.next = swapPairs(p3);\\n\\t\\t\\n\\t\\treturn p2;\\n\\t}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    public ListNode swapPairs(ListNode head) {\\n\\t\\tif(head == null || head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n\\t\\tListNode p1 = head, p2 = head.next, p3 = null;\\n\\t\\tp3 = p2.next;\\n\\t\\tp2.next = null;\\n\\t\\tp1.next.next = p1;\\n\\t\\tp1.next = p3;\\n\\t\\t\\n\\t\\tif(p3 != null)\\n\\t\\t\\tp1.next = swapPairs(p3);\\n\\t\\t\\n\\t\\treturn p2;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 11222,
                "title": "my-solution-c",
                "content": "        ListNode* swapPairs(ListNode* head) {\\n            ListNode* p1;       \\n            if(head && head->next){  \\n                p1 = head->next; \\n                head->next = swapPairs(head->next->next);\\n                p1->next = head;\\n                head = p1; \\n           }\\n           return head;\\n    }",
                "solutionTags": [],
                "code": "        ListNode* swapPairs(ListNode* head) {\\n            ListNode* p1;       \\n            if(head && head->next){  \\n                p1 = head->next; \\n                head->next = swapPairs(head->next->next);\\n                p1->next = head;\\n                head = p1; \\n           }\\n           return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11343,
                "title": "runtime-0ms-in-c",
                "content": "struct ListNode* swapPairs(struct ListNode* head) {\\n    \\n    struct ListNode* dummy=head;\\n    struct ListNode* prev=NULL;\\n    struct ListNode* Nextnode=NULL;\\n\\n\\n    if(!dummy)\\n          return head;\\n    \\n    while(dummy!=NULL && dummy->next!=NULL){\\n        \\n        Nextnode=dummy->next;\\n        dummy->next=Nextnode->next;\\n        \\n        if(prev)\\n          prev->next=Nextnode;\\n        else\\n          head=Nextnode;\\n          \\n        Nextnode->next=dummy;\\n        \\n        prev=dummy;\\n\\n        dummy=dummy->next;\\n           \\n           \\n    }\\n    \\n    return head;\\n}",
                "solutionTags": [],
                "code": "struct ListNode* swapPairs(struct ListNode* head) {\\n    \\n    struct ListNode* dummy=head;\\n    struct ListNode* prev=NULL;\\n    struct ListNode* Nextnode=NULL;\\n\\n\\n    if(!dummy)\\n          return head;\\n    \\n    while(dummy!=NULL && dummy->next!=NULL){\\n        \\n        Nextnode=dummy->next;\\n        dummy->next=Nextnode->next;\\n        \\n        if(prev)\\n          prev->next=Nextnode;\\n        else\\n          head=Nextnode;\\n          \\n        Nextnode->next=dummy;\\n        \\n        prev=dummy;\\n\\n        dummy=dummy->next;\\n           \\n           \\n    }\\n    \\n    return head;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3585152,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        while (head != NULL && head->next != NULL) {\\n            ListNode* cur = head->next->next;\\n            temp->next = head->next;\\n            temp = head;\\n            head->next->next = head;\\n            head->next = cur;\\n            head = cur;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        while (head != NULL && head->next != NULL) {\\n            ListNode* cur = head->next->next;\\n            temp->next = head->next;\\n            temp = head;\\n            head->next->next = head;\\n            head->next = cur;\\n            head = cur;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534681,
                "title": "100-beats-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n        ListNode* p = head,*q=head->next;\\n        while(true){\\n            swap(p->val,q->val);\\n            if(!(q->next && q->next->next))break;\\n            p = p->next->next;\\n            q = q->next->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n        ListNode* p = head,*q=head->next;\\n        while(true){\\n            swap(p->val,q->val);\\n            if(!(q->next && q->next->next))break;\\n            p = p->next->next;\\n            q = q->next->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531446,
                "title": "c-by-swapping-the-values-of-the-adjacent-nodes-t-c-o-n",
                "content": "# Intuition\\nTraverse the list and swap pairs of nodes one by one.\\n# Approach\\n![53a7a769-ce39-4d7d-9e37-cd0420f72bf0_1644988593.5987253.jpeg](https://assets.leetcode.com/users/images/1c079065-d5e5-478f-80bb-c20f4881d340_1684253393.321737.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)(where n is number of nodes in the linked list)\\n\\n- Space complexity:\\nO(1)-> since we are just changing the value of the nodes by swapping so no extra space is used.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n    class Solution {\\n\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n\\n        if(head==NULL)return head;\\n\\n        if(head->next==NULL)return head;\\n\\n        \\n\\n        ListNode*curr=head->next;\\n\\n        ListNode*prev=head;\\n\\n        swap(curr->val,prev->val);\\n\\n        while(prev->next->next!=NULL&&curr->next->next!=NULL){\\n\\n            prev=prev->next->next;\\n\\n            curr=curr->next->next;\\n\\n            swap(curr->val,prev->val);\\n\\n        }\\n\\n        return head;\\n\\n        \\n\\n    }\\n\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n    class Solution {\\n\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n\\n        if(head==NULL)return head;\\n\\n        if(head->next==NULL)return head;\\n\\n        \\n\\n        ListNode*curr=head->next;\\n\\n        ListNode*prev=head;\\n\\n        swap(curr->val,prev->val);\\n\\n        while(prev->next->next!=NULL&&curr->next->next!=NULL){\\n\\n            prev=prev->next->next;\\n\\n            curr=curr->next->next;\\n\\n            swap(curr->val,prev->val);\\n\\n        }\\n\\n        return head;\\n\\n        \\n\\n    }\\n\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531230,
                "title": "python-3-4-lines-recursion-t-m-98-65",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head):\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```\\n[https://leetcode.com/submissions/detail/582543531/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head):\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531172,
                "title": "easy-solution-java-iterative-swap",
                "content": "# Approach\\nThe provided code implements a method called `swapPairs` in a class. This method swaps adjacent pairs of nodes in a singly linked list. Here\\'s the breakdown of the approach used:\\n\\n1. The method takes a parameter `head`, which represents the head node of the linked list.\\n\\n2. The first step is to check if the `head` is `null` or if there is only one node in the list (`head.next == null`). In either case, there is no need to swap any nodes, so the method returns the `head` as it is.\\n\\n3. If there are at least two nodes in the list, a new dummy node called `ans` is created with a value of 0. The `ans.next` is set to the original `head` of the list. This dummy node serves as the new head of the modified list, which will make it easier to handle the edge case of swapping the first two nodes.\\n\\n4. Two pointers, `temp` and `temp1`, are initialized with `head` and `ans` respectively. These pointers will be used to traverse the list and perform the node swaps.\\n\\n5. The main loop runs as long as `temp` is not `null` and `temp.next` is not `null`. This loop processes pairs of nodes in the list until there are no more pairs left to swap.\\n\\n6. Inside the loop, a new node `forw` is assigned as the next node after `temp`. This node represents the second node of the current pair.\\n\\n7. The following steps perform the swapping:\\n   - `temp.next` is updated to skip the second node (`forw`).\\n   - `forw.next` is set to `temp`, making `temp` the second node in the pair.\\n   - `temp1.next` is set to `forw`, connecting the swapped pair to the modified list.\\n   - `temp1` is updated to `temp`, so it now represents the last node that was swapped.\\n   - `temp` is updated to `temp.next` to move to the next pair of nodes.\\n\\n8. Once the loop is completed, the modified list is obtained by accessing `ans.next`. This returns the head of the modified linked list.\\n\\n9. Finally, the modified list is returned as the result.\\n\\nOverall, this approach uses iterative traversal and manipulation of the linked list to swap adjacent pairs of nodes. It employs a dummy node to simplify the handling of the first pair.\\n\\n# Complexity\\n- Time complexity:\\n    - The time complexity of the swapPairs method is O(n).\\n- Space complexity:\\n    - The space complexity of the method is O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }        \\n        ListNode ans = new ListNode(0);\\n        ans.next = head;       \\n        ListNode temp = head;\\n        ListNode temp1 = ans;\\n        \\n        while (temp != null && temp.next != null) {\\n            ListNode forw = temp.next;\\n            temp.next = forw.next;\\n            forw.next = temp;\\n            temp1.next = forw;\\n            temp1 = temp;\\n            temp = temp.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }        \\n        ListNode ans = new ListNode(0);\\n        ans.next = head;       \\n        ListNode temp = head;\\n        ListNode temp1 = ans;\\n        \\n        while (temp != null && temp.next != null) {\\n            ListNode forw = temp.next;\\n            temp.next = forw.next;\\n            forw.next = temp;\\n            temp1.next = forw;\\n            temp1 = temp;\\n            temp = temp.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529795,
                "title": "beats-100-time-ands-90-space",
                "content": "**Italic**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ans(ListNode*&temp,ListNode*&curr,ListNode*a){\\n        a=curr;\\n        if(temp==NULL || temp->next==NULL)return;\\n        temp->next=NULL;\\n        temp->next=curr->next;\\n        curr->next=temp;\\n        ListNode*prev = temp;\\n\\n        temp=temp->next;\\n        if(temp==NULL || temp->next==NULL)return;\\n        curr=temp->next;\\n        prev->next=curr;\\n        ans(temp,curr,a);\\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)return head;\\n        ListNode*temp=head;\\n        ListNode*curr = head->next;\\n        ListNode*a=curr;\\n        ans(temp,curr,a);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ans(ListNode*&temp,ListNode*&curr,ListNode*a){\\n        a=curr;\\n        if(temp==NULL || temp->next==NULL)return;\\n        temp->next=NULL;\\n        temp->next=curr->next;\\n        curr->next=temp;\\n        ListNode*prev = temp;\\n\\n        temp=temp->next;\\n        if(temp==NULL || temp->next==NULL)return;\\n        curr=temp->next;\\n        prev->next=curr;\\n        ans(temp,curr,a);\\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)return head;\\n        ListNode*temp=head;\\n        ListNode*curr = head->next;\\n        ListNode*a=curr;\\n        ans(temp,curr,a);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529774,
                "title": "easy-java-solution-detailed-explanation-two-pointers-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question by two ways that are Two Pointers and Recursion.\\nHere I have use two pointer approach, Folks who does not wanted recursive space can go through my approach.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere I have taken dummy Node which next will points to head of LikedList. Use of this dummy node is that we have to return head of LinkedList and if we swap then head will change, so we can return dummy.next (new head).\\n1. I have taken two pointers that are pre and curr, pre will points to dummy node and curr will points head of LinkedList\\n![WhatsApp Image 2023-05-16 at 11.29.57 AM.jpeg](https://assets.leetcode.com/users/images/05ec86d4-6fc7-4c8b-80b2-17d9c22e173b_1684219328.4818847.jpeg)\\n\\n2. Here I have done connetion of pre\\'s next node to curr\\'s node next node.\\n```java []\\npre.next=curr.next;\\n```\\n\\n![WhatsApp Image 2023-05-16 at 11.38.00 AM.jpeg](https://assets.leetcode.com/users/images/af90cb2b-1003-4027-ae43-3e67f2a59cca_1684219425.2694046.jpeg)\\n\\n3. After this, I break curr\\'s next node (node 2) connection and establish it\\'s next connection to pre\\'s next of next node (node 3).\\n```java []\\ncurr.next=pre.next.next;\\n```\\n\\n![WhatsApp Image 2023-05-16 at 11.45.00 AM.jpeg](https://assets.leetcode.com/users/images/f62f9709-1fa5-42bc-8523-07cb507f1e42_1684219589.7843626.jpeg)\\n\\n4. This is the main step, here the swapping of node are done by doing pre\\'s next of next node to curr node.\\n```java []\\npre.next.next=curr;\\n```\\n![WhatsApp Image 2023-05-16 at 11.53.43 AM.jpeg](https://assets.leetcode.com/users/images/43ca3fc2-d1ec-47a5-85d9-bd6eddc3ce47_1684219689.5950298.jpeg)\\n\\n5. Here we simply update our pre node (node 0) to curr node (node 1) and curr node (node 1) to pre next node (node 3).\\n```java []\\npre=curr;\\ncurr=pre.next;\\n```\\n![WhatsApp Image 2023-05-16 at 12.00.35 PM.jpeg](https://assets.leetcode.com/users/images/a4910cb9-5d0c-45bd-a08e-b181626953cf_1684219778.19854.jpeg)\\n\\n6. While loop will get false when either curr will become null of curr next node will beacome null, and last dummy\\'s next node will return.\\n```java []\\nreturn dummy.next;\\n```\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next=head;\\n        ListNode pre=dummy;\\n        ListNode curr=pre.next;\\n\\n        while(curr!=null && curr.next!=null){\\n            pre.next=curr.next;\\n            curr.next=pre.next.next;\\n            pre.next.next=curr;\\n\\n            pre=curr;\\n            curr=pre.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java []\\npre.next=curr.next;\\n```\n```java []\\ncurr.next=pre.next.next;\\n```\n```java []\\npre.next.next=curr;\\n```\n```java []\\npre=curr;\\ncurr=pre.next;\\n```\n```java []\\nreturn dummy.next;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next=head;\\n        ListNode pre=dummy;\\n        ListNode curr=pre.next;\\n\\n        while(curr!=null && curr.next!=null){\\n            pre.next=curr.next;\\n            curr.next=pre.next.next;\\n            pre.next.next=curr;\\n\\n            pre=curr;\\n            curr=pre.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529173,
                "title": "very-easy-c-soln-beats-100-beginner-friendly",
                "content": "**Please upVote if it helps.**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* prev=head,*curr=head->next,*ans=head->next;\\n        \\n        while(1)\\n        {\\n            prev->next = curr->next;\\n            curr->next=prev;\\n            ListNode* temp=prev->next;\\n            if(temp==NULL)\\n                break;\\n            curr=temp->next;\\n            if(curr==NULL)\\n                break;\\n            prev->next=curr;\\n            prev=temp;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* prev=head,*curr=head->next,*ans=head->next;\\n        \\n        while(1)\\n        {\\n            prev->next = curr->next;\\n            curr->next=prev;\\n            ListNode* temp=prev->next;\\n            if(temp==NULL)\\n                break;\\n            curr=temp->next;\\n            if(curr==NULL)\\n                break;\\n            prev->next=curr;\\n            prev=temp;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132394,
                "title": "easy-python-solution-using-lists-runtime-97",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst=[]\\n        while head:\\n            lst.append(head.val)\\n            head=head.next\\n        ans=[]\\n        for i in range(0,len(lst),2):\\n            val=lst[i:i+2]\\n            ans+=val[::-1]\\n        final=ListNode(0)\\n        tmp=final\\n        for i in ans:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return final.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst=[]\\n        while head:\\n            lst.append(head.val)\\n            head=head.next\\n        ans=[]\\n        for i in range(0,len(lst),2):\\n            val=lst[i:i+2]\\n            ans+=val[::-1]\\n        final=ListNode(0)\\n        tmp=final\\n        for i in ans:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return final.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070647,
                "title": "95-javascript-very-easy-to-understand-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/p8x7qjD1wEM\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    let len = arr.length % 2 ==0 ? arr.length : arr.length-1;\\n    \\n    for(let i =0; i <len; i++){\\n        if(i % 2 == 0) copy.next = new ListNode(arr[i+1])\\n        else copy.next = new ListNode(arr[i-1])\\n        copy = copy.next;\\n    }\\n    if(arr.length % 2 ==1){\\n        copy.next = new ListNode(arr[arr.length-1])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    let len = arr.length % 2 ==0 ? arr.length : arr.length-1;\\n    \\n    for(let i =0; i <len; i++){\\n        if(i % 2 == 0) copy.next = new ListNode(arr[i+1])\\n        else copy.next = new ListNode(arr[i-1])\\n        copy = copy.next;\\n    }\\n    if(arr.length % 2 ==1){\\n        copy.next = new ListNode(arr[arr.length-1])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2955805,
                "title": "c-easy-recursive-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* node1 = head;\\n        ListNode* node2 = head->next;\\n        node1->next = swapPairs(node2->next);\\n        node2->next = node1;\\n        return node2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* node1 = head;\\n        ListNode* node2 = head->next;\\n        node1->next = swapPairs(node2->next);\\n        node2->next = node1;\\n        return node2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654022,
                "title": "24-super-easy-connection",
                "content": "**time complexity - O(n) space-O(1)**\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # MAKE a dummy node\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n        \\n        # prev-a-b-c-d-e\\n        # prev-b-a-c\\n        while head and head.next:\\n            a = head \\n            b = a.next \\n            c = b.next \\n            \\n            prev.next = b \\n            b.next = a \\n            a.next = c\\n            \\n            prev= a\\n            head= c\\n        \\n        \\n        return dummy.next\\n\\t\\t\\n\\t\\t\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # MAKE a dummy node\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n        \\n        # prev-a-b-c-d-e\\n        # prev-b-a-c\\n        while head and head.next:\\n            a = head \\n            b = a.next \\n            c = b.next \\n            \\n            prev.next = b \\n            b.next = a \\n            a.next = c\\n            \\n            prev= a\\n            head= c\\n        \\n        \\n        return dummy.next\\n\\t\\t\\n\\t\\t\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2588735,
                "title": "recursion-7-lines-python-solution",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def swap(node):\\n            if not node or not node.next:\\n                return node\\n            first, second = node, node.next\\n            first.next, second.next = second.next,first\\n            first.next = swap(first.next)\\n            return second\\n       \\n        return swap(head)\\n   ```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def swap(node):\\n            if not node or not node.next:\\n                return node\\n            first, second = node, node.next\\n            first.next, second.next = second.next,first\\n            first.next = swap(first.next)\\n            return second\\n       \\n        return swap(head)\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 2420385,
                "title": "java-solution-with-pointer",
                "content": "The code is commented and if you are familiar with using pointers and linkedlist you may be able to understand it \\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode currentPtr = dummy ; // for iteration\\n        \\n        while(currentPtr.next != null && currentPtr.next.next != null ){\\n            ListNode firstNode = currentPtr.next ; \\n            ListNode secondNode  = currentPtr.next.next;\\n            // swaping nodes by replacing next wrt the currentPtr, which points to dummy atm\\n            firstNode.next = secondNode.next;\\n            currentPtr.next = secondNode;\\n            currentPtr.next.next = firstNode; \\n            \\n            // now, currentPtr will move to the 2nd node, then currentPtr.next will become first             //   node for the second pair\\n            currentPtr = currentPtr.next.next;\\n            \\n        }\\n        // our dummy is empty so after that lies our first node(head of the new list)\\n        return dummy.next;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode currentPtr = dummy ; // for iteration\\n        \\n        while(currentPtr.next != null && currentPtr.next.next != null ){\\n            ListNode firstNode = currentPtr.next ; \\n            ListNode secondNode  = currentPtr.next.next;\\n            // swaping nodes by replacing next wrt the currentPtr, which points to dummy atm\\n            firstNode.next = secondNode.next;\\n            currentPtr.next = secondNode;\\n            currentPtr.next.next = firstNode; \\n            \\n            // now, currentPtr will move to the 2nd node, then currentPtr.next will become first             //   node for the second pair\\n            currentPtr = currentPtr.next.next;\\n            \\n        }\\n        // our dummy is empty so after that lies our first node(head of the new list)\\n        return dummy.next;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347917,
                "title": "c-100-faster-recursive-solution",
                "content": "```\\nvoid swa(ListNode*head)\\n    {\\n        if(head==NULL || head->next==NULL || head->next->next==NULL)\\n            return;\\n        ListNode*t=head->next;\\n        head->next=t->next;\\n        t->next=t->next->next;\\n        head->next->next=t;\\n        swa(head->next->next);\\n        \\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        // return NULL;\\n        if(!head || !head->next)return head;\\n       ListNode*temp=head->next;\\n        head->next=temp->next;\\n        temp->next=head;\\n        head=temp;\\n        swa(head->next);\\n       return head;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid swa(ListNode*head)\\n    {\\n        if(head==NULL || head->next==NULL || head->next->next==NULL)\\n            return;\\n        ListNode*t=head->next;\\n        head->next=t->next;\\n        t->next=t->next->next;\\n        head->next->next=t;\\n        swa(head->next->next);\\n        \\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        // return NULL;\\n        if(!head || !head->next)return head;\\n       ListNode*temp=head->next;\\n        head->next=temp->next;\\n        temp->next=head;\\n        head=temp;\\n        swa(head->next);\\n       return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2245683,
                "title": "simple-python-reccursion-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head == None or head.next == None:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        third = second.next\\n        \\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        return second\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head == None or head.next == None:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        third = second.next\\n        \\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        return second\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990913,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic ListNode swapPairs(ListNode leftNode){\\n        if (leftNode == null || leftNode.next == null){\\n            return leftNode;\\n        }\\n        \\n        ListNode rightNode = leftNode.next;\\n        leftNode.next = swapPairs(rightNode.next);\\n        rightNode.next = leftNode;\\n        return rightNode;\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n\\tListNode* swapPairs(ListNode* head) {\\n\\t\\tif(!head || !head->next) return head;\\n\\t\\t\\n\\t\\tListNode* prev=head;ListNode* curr=head;\\n\\t\\thead=head->next;\\n\\t\\twhile(curr && curr->next){\\n\\t\\t\\tprev->next=curr->next;\\n\\n\\t\\t\\tprev=curr;\\n\\t\\t\\tcurr=curr->next;\\n\\t\\t\\tprev->next=curr->next;\\n\\t\\t\\tcurr->next=prev;\\n\\t\\t\\tcurr=curr->next->next;}\\n\\t\\treturn head;\\n\\n\\t}\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nconst swapPairs = data => {\\n  let current = data;\\n  let count = 0;\\n  while (current) {\\n    if (count % 2 === 0 && current.next) {\\n      const tmp = current.val;\\n      current.val = current.next.val;\\n      current.next.val = tmp; \\n    }\\n    count++;\\n    current = current.next;\\n  }\\n  return data;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n\\t\\n\\t\\t// if we got empty list return null\\n        head ?: return null\\n\\n\\t\\t// create a pointer, pointing to second element in the list \\n\\t\\t// we will handle the case of swapping first two elements\\n\\t\\t// in the list later\\n        var ptr: ListNode? = head?.next\\n\\n        // in case of list with single element, return the list as\\n\\t\\t// swapping is not possible with just one element\\n        ptr ?: return head\\n\\n        while (ptr?.next != null) {\\n\\t\\t\\t// assign a temp pointer pointing to first of the two elements\\n\\t\\t\\t// to be swapped (we\\'re swapping in chunks on two in entire list)\\n\\t\\t\\t// so, for eg, if the list is 1 -> 2 -> 3 -> 4 -> 5, variable ptr \\n\\t\\t\\t// will point to 2 and variable temp will point to 3 in first pass\\n\\t\\t\\t// of this while loop\\n            val temp = ptr?.next \\n\\n\\t\\t\\t// check if the next chunk of two numbers exist or not\\n\\t\\t\\t// this check will handle lists with odd number of nodes\\n\\t\\t\\t// as the last nodes will not end up being swapped\\n            if (ptr?.next?.next != null) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// swap the two nodes\\n                ptr?.next = ptr?.next?.next \\n                temp?.next = ptr?.next?.next \\n                ptr?.next?.next = temp\\n            }\\n\\n\\t\\t\\t// move the pointer by two nodes, remember we\\'re swapping\\n\\t\\t\\t// in chunks of two?\\n            ptr = ptr?.next?.next\\n        }\\n\\n        // swap elements at head\\n        ptr = head\\n        val temp: ListNode? = head?.next\\n        ptr?.next = temp?.next\\n        temp?.next = ptr\\n        return temp\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic ListNode swapPairs(ListNode leftNode){\\n        if (leftNode == null || leftNode.next == null){\\n            return leftNode;\\n        }\\n        \\n        ListNode rightNode = leftNode.next;\\n        leftNode.next = swapPairs(rightNode.next);\\n        rightNode.next = leftNode;\\n        return rightNode;\\n    }\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n\\tListNode* swapPairs(ListNode* head) {\\n\\t\\tif(!head || !head->next) return head;\\n\\t\\t\\n\\t\\tListNode* prev=head;ListNode* curr=head;\\n\\t\\thead=head->next;\\n\\t\\twhile(curr && curr->next){\\n\\t\\t\\tprev->next=curr->next;\\n\\n\\t\\t\\tprev=curr;\\n\\t\\t\\tcurr=curr->next;\\n\\t\\t\\tprev->next=curr->next;\\n\\t\\t\\tcurr->next=prev;\\n\\t\\t\\tcurr=curr->next->next;}\\n\\t\\treturn head;\\n\\n\\t}\\n};\\n```\n```\\n```\n```\\n```\n```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```\n```\\n```\n```\\n```\n```\\nconst swapPairs = data => {\\n  let current = data;\\n  let count = 0;\\n  while (current) {\\n    if (count % 2 === 0 && current.next) {\\n      const tmp = current.val;\\n      current.val = current.next.val;\\n      current.next.val = tmp; \\n    }\\n    count++;\\n    current = current.next;\\n  }\\n  return data;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n\\t\\n\\t\\t// if we got empty list return null\\n        head ?: return null\\n\\n\\t\\t// create a pointer, pointing to second element in the list \\n\\t\\t// we will handle the case of swapping first two elements\\n\\t\\t// in the list later\\n        var ptr: ListNode? = head?.next\\n\\n        // in case of list with single element, return the list as\\n\\t\\t// swapping is not possible with just one element\\n        ptr ?: return head\\n\\n        while (ptr?.next != null) {\\n\\t\\t\\t// assign a temp pointer pointing to first of the two elements\\n\\t\\t\\t// to be swapped (we\\'re swapping in chunks on two in entire list)\\n\\t\\t\\t// so, for eg, if the list is 1 -> 2 -> 3 -> 4 -> 5, variable ptr \\n\\t\\t\\t// will point to 2 and variable temp will point to 3 in first pass\\n\\t\\t\\t// of this while loop\\n            val temp = ptr?.next \\n\\n\\t\\t\\t// check if the next chunk of two numbers exist or not\\n\\t\\t\\t// this check will handle lists with odd number of nodes\\n\\t\\t\\t// as the last nodes will not end up being swapped\\n            if (ptr?.next?.next != null) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// swap the two nodes\\n                ptr?.next = ptr?.next?.next \\n                temp?.next = ptr?.next?.next \\n                ptr?.next?.next = temp\\n            }\\n\\n\\t\\t\\t// move the pointer by two nodes, remember we\\'re swapping\\n\\t\\t\\t// in chunks of two?\\n            ptr = ptr?.next?.next\\n        }\\n\\n        // swap elements at head\\n        ptr = head\\n        val temp: ListNode? = head?.next\\n        ptr?.next = temp?.next\\n        temp?.next = ptr\\n        return temp\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965896,
                "title": "python-iterative-solution-w-o-temporary-variables",
                "content": "```\\n def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(val=None,next=head)\\n        \\n        prev = dummy\\n        cur = head\\n        \\n        while cur and cur.next:\\n            \\n            prev.next, cur.next.next, cur.next, prev, cur = cur.next, cur, cur.next.next, cur, cur.next.next\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(val=None,next=head)\\n        \\n        prev = dummy\\n        cur = head\\n        \\n        while cur and cur.next:\\n            \\n            prev.next, cur.next.next, cur.next, prev, cur = cur.next, cur, cur.next.next, cur, cur.next.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1775864,
                "title": "c-o-n-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp = new ListNode;\\n        temp->next = head;\\n        ListNode* prev = temp;\\n        ListNode* cur = head;\\n        while(cur && cur->next){\\n            prev->next = cur->next;\\n            prev = prev->next;\\n            cur->next = prev->next;\\n            prev->next = cur;\\n            prev = cur;\\n            cur = cur->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp = new ListNode;\\n        temp->next = head;\\n        ListNode* prev = temp;\\n        ListNode* cur = head;\\n        while(cur && cur->next){\\n            prev->next = cur->next;\\n            prev = prev->next;\\n            cur->next = prev->next;\\n            prev->next = cur;\\n            prev = cur;\\n            cur = cur->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775090,
                "title": "2-java-solution-with-comments-recursive-and-iterative",
                "content": "1.take three pointers. prev, curr, next. and create arbitary node with dummy value and point it to head. by this we don\\'t need to handle head conditions.\\n2.initially curr will point to head and prev to dummynode and next to curr.next node.\\n3.loop till we curr and curr.next available. and perform below step.\\n4.just swap nodes next and curr. and after that reassign values of prev, curr and next to right position so that we can again swap curr with next.\\n\\n```\\npublic ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) {\\n            return head;\\n        }\\n        ListNode tempHead = new ListNode(-1);\\n        ListNode prev = tempHead;\\n        ListNode curr=head;\\n        while(curr!=null && curr.next!=null) {\\n            ListNode next=curr.next;\\n            curr.next=next.next;\\n            next.next=curr;\\n            prev.next=next;\\n            prev=curr;\\n            curr=curr.next;\\n        }\\n        return tempHead.next;\\n    }\\n```\\n\\nRecursive ->\\n```\\npublic ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tListNode second = head.next;\\n\\t\\tListNode third = second.next;\\n\\t\\tsecond.next=(head);\\n\\t\\thead.next=(swapPairs(third));\\n\\t\\treturn second;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) {\\n            return head;\\n        }\\n        ListNode tempHead = new ListNode(-1);\\n        ListNode prev = tempHead;\\n        ListNode curr=head;\\n        while(curr!=null && curr.next!=null) {\\n            ListNode next=curr.next;\\n            curr.next=next.next;\\n            next.next=curr;\\n            prev.next=next;\\n            prev=curr;\\n            curr=curr.next;\\n        }\\n        return tempHead.next;\\n    }\\n```\n```\\npublic ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tListNode second = head.next;\\n\\t\\tListNode third = second.next;\\n\\t\\tsecond.next=(head);\\n\\t\\thead.next=(swapPairs(third));\\n\\t\\treturn second;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774677,
                "title": "c-code-using-a-vector",
                "content": "-> used a vector to store sum of every pair node. \\n-> the traverse through the vector and current node value is replaced by (v[i] - (curr->val)\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* curr = head;\\n        ListNode* temp = curr;\\n        vector<int> v;\\n        while(head && head->next )\\n        {\\n            v.push_back(head->val + head->next->val);\\n            head = head->next->next;\\n        }\\n        int k = v.size();\\n        int i = 0;\\n        while(i<k)\\n        {\\n            curr->val = v[i]-(curr->val);\\n            curr->next->val = v[i]-(curr->next->val);\\n            curr = curr->next->next;\\n            i++;\\n        }\\n        \\n        return temp;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* curr = head;\\n        ListNode* temp = curr;\\n        vector<int> v;\\n        while(head && head->next )\\n        {\\n            v.push_back(head->val + head->next->val);\\n            head = head->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1722643,
                "title": "four-recursive-and-iterative-solutions-in-python",
                "content": "## Approach 1. recursion with modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n\\n            self.swapPairs(head.next.next)\\n\\n        return head\\n```\\n## Approach 2. iteration with modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(1)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n\\n        while curr and curr.next:\\n            curr.val, curr.next.val = curr.next.val, curr.val\\n\\n            curr = curr.next.next\\n\\n        return head\\n```\\n\\n## Approach 3. recursion without modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        first, second = head, head.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n\\n        return second\\n```\\n\\n## Approach 4. iteration without modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(1)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n\\n        prev = dummy\\n\\n        while head and head.next:\\n            first, second = head, head.next\\n\\n            prev.next = second\\n            first.next = second.next\\n            second.next = first\\n\\n            prev = first\\n            head = head.first\\n\\n        return dummy.next\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n\\n            self.swapPairs(head.next.next)\\n\\n        return head\\n```\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n\\n        while curr and curr.next:\\n            curr.val, curr.next.val = curr.next.val, curr.val\\n\\n            curr = curr.next.next\\n\\n        return head\\n```\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        first, second = head, head.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n\\n        return second\\n```\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n\\n        prev = dummy\\n\\n        while head and head.next:\\n            first, second = head, head.next\\n\\n            prev.next = second\\n            first.next = second.next\\n            second.next = first\\n\\n            prev = first\\n            head = head.first\\n\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585587,
                "title": "python-recursion-with-example",
                "content": "```\\ndef swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        \\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        \\n        return second\\n```\\n\\nThe recursive function is called on the 1st node of each pair. The recursive flow will be as follows:\\n\\nConsider the example : 1 --> 2 --> 3 --> 4 --> 5\\n\\n```\\nswap(1) --> first = 1\\n\\t\\t\\tsecond = 2\\n\\t\\t\\t1.next = swap(3) --> first = 3\\n\\t\\t\\t2.next = 1           second = 4\\n\\t\\t\\treturn 2\\t\\t\\t 3.next = swap(5) -- > return 5\\n\\t\\t\\t\\t\\t\\t\\t\\t 4.next = 3\\n\\t\\t\\t\\t\\t\\t\\t\\t return 4\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        \\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        \\n        return second\\n```\n```\\nswap(1) --> first = 1\\n\\t\\t\\tsecond = 2\\n\\t\\t\\t1.next = swap(3) --> first = 3\\n\\t\\t\\t2.next = 1           second = 4\\n\\t\\t\\treturn 2\\t\\t\\t 3.next = swap(5) -- > return 5\\n\\t\\t\\t\\t\\t\\t\\t\\t 4.next = 3\\n\\t\\t\\t\\t\\t\\t\\t\\t return 4\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1489575,
                "title": "easy-c-solution",
                "content": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL) return head;\\n        int sum=0;\\n        ListNode* start=head,*temp=head;\\n        start=head;\\n        while(start){\\n            sum++;\\n            start=start->next;\\n        }\\n        if(sum==1) return head;\\n        else if(sum%2==0){\\n            start=head;\\n            while(start){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }else if(sum%2==1){\\n            start=head;\\n            while(start->next){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL) return head;\\n        int sum=0;\\n        ListNode* start=head,*temp=head;\\n        start=head;\\n        while(start){\\n            sum++;\\n            start=start->next;\\n        }\\n        if(sum==1) return head;\\n        else if(sum%2==0){\\n            start=head;\\n            while(start){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }else if(sum%2==1){\\n            start=head;\\n            while(start->next){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453499,
                "title": "java-beats-100-simple-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null){\\n            return head;\\n        }\\n        \\n        ListNode dummyHead = new ListNode(-1);\\n        ListNode prev = dummyHead;\\n        ListNode curr = head;\\n        \\n        while(curr != null && curr.next != null){\\n            prev.next = curr.next;\\n            curr.next = curr.next.next;\\n            prev.next.next = curr;\\n            curr = curr.next;\\n            prev = prev.next.next;\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null){\\n            return head;\\n        }\\n        \\n        ListNode dummyHead = new ListNode(-1);\\n        ListNode prev = dummyHead;\\n        ListNode curr = head;\\n        \\n        while(curr != null && curr.next != null){\\n            prev.next = curr.next;\\n            curr.next = curr.next.next;\\n            prev.next.next = curr;\\n            curr = curr.next;\\n            prev = prev.next.next;\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318487,
                "title": "python-easy-solution-with-comments-and-explanation",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        \\n        # dummy -> A -> B -> C \\n        \\n        # we want to swap A and B so we have to make dummy to point towards B and B towards A and A towards C \\n        \\n        \\n        # dummy >>>>> B\\n        # B >>>>> A\\n        # A >>>>> C \\n        # all steps simultaneously\\n        \\n        \\n        dummy = ListNode(0)\\n        \\n        dummy.next = head\\n        \\n        start = dummy\\n        \\n        \\n        while dummy.next and dummy.next.next:\\n            \\n            temp1 = dummy.next # A\\n            temp2 = temp1.next # B\\n            \\n            dummy.next ,temp2.next , temp1.next = temp2 , temp1, temp2.next\\n            \\n            dummy = temp1\\n            \\n        return start.next\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        \\n        # dummy -> A -> B -> C \\n        \\n        # we want to swap A and B so we have to make dummy to point towards B and B towards A and A towards C \\n        \\n        \\n        # dummy >>>>> B\\n        # B >>>>> A\\n        # A >>>>> C \\n        # all steps simultaneously\\n        \\n        \\n        dummy = ListNode(0)\\n        \\n        dummy.next = head\\n        \\n        start = dummy\\n        \\n        \\n        while dummy.next and dummy.next.next:\\n            \\n            temp1 = dummy.next # A\\n            temp2 = temp1.next # B\\n            \\n            dummy.next ,temp2.next , temp1.next = temp2 , temp1, temp2.next\\n            \\n            dummy = temp1\\n            \\n        return start.next\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269068,
                "title": "python-solution-using-recursion",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        if head is None or head.next is None:\\n            return head\\n        else:\\n            # Swap the 2 nodes\\n            temp = head \\n            head = head.next\\n            temp.next = head.next\\n            head.next = temp\\n            \\n            # call function recursively for next nodes\\n            temp.next = self.swapPairs(temp.next)\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        if head is None or head.next is None:\\n            return head\\n        else:\\n            # Swap the 2 nodes\\n            temp = head \\n            head = head.next\\n            temp.next = head.next\\n            head.next = temp\\n            \\n            # call function recursively for next nodes\\n            temp.next = self.swapPairs(temp.next)\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984754,
                "title": "easy-understandable-python-solution",
                "content": "```\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        head2 = head\\n        while head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n            head = head.next.next\\n            \\n        return head2\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        head2 = head\\n        while head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n            head = head.next.next\\n            \\n        return head2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 984473,
                "title": "python-o-n-easy-clear-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef swapPairs(self, head: ListNode) -> ListNode:\\n\\t\\t\\tif not head or not head.next:\\n\\t\\t\\t\\treturn head\\n\\t\\t\\t\\n\\t\\t\\ttmp = head\\n\\t\\t\\thead = head.next\\n\\t\\t\\ttmp.next = head.next\\n\\t\\t\\thead.next = tmp\\n\\t\\t\\t\\n\\t\\t\\ttmp.next = self.swapPairs(tmp.next)\\n\\t\\t\\t\\n\\t\\t\\treturn head",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef swapPairs(self, head: ListNode) -> ListNode:\\n\\t\\t\\tif not head or not head.next:\\n\\t\\t\\t\\treturn head\\n\\t\\t\\t\\n\\t\\t\\ttmp = head\\n\\t\\t\\thead = head.next\\n\\t\\t\\ttmp.next = head.next\\n\\t\\t\\thead.next = tmp\\n\\t\\t\\t\\n\\t\\t\\ttmp.next = self.swapPairs(tmp.next)\\n\\t\\t\\t\\n\\t\\t\\treturn head",
                "codeTag": "Java"
            },
            {
                "id": 984443,
                "title": "swap-nodes-in-pair-c-faster-than-100-00-solutions-o-n-time-o-1-space-0ms-runtime",
                "content": "Time: O(n)\\nSpace: O(1)\\nThis is a very easy-to-follow solution. It beats 100% of the submitted C++ solutions according to my submission on Leetcode:\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        // If NULL, then return\\n        if(head == NULL)\\n            return head;\\n        \\n        // An iterator node for traversing the LinkedList\\n        ListNode* it = head;\\n        \\n        // A previous pointer to store the second node of the previous pair \\n        ListNode* prev = NULL;\\n        \\n        while(it != NULL && it->next != NULL)\\n        {\\n            // Front and back pointers for the two nodes of the pair to be swapped\\n            ListNode* back = it;\\n            ListNode* front = back->next;\\n            \\n            // Pointing Back node to the node next to Front \\n            back->next = front->next;\\n            \\n            // If it\\'s the start of the Linked List\\n            if(prev == NULL)\\n            {\\n                front->next = back;\\n                // point the head to Front since Front is not swapped back\\n                head = front;\\n            }\\n            else\\n            {\\n                // If it\\'s not the start of the linkedlist,\\n                // point the Prev pointer to the Front\\n                // And, Front pointer to the Back.\\n                prev->next = front;\\n                front->next = back;\\n            }\\n            \\n            // Update the Prev pointer\\n            prev = back;\\n            \\n            // Shift it to Front and two nodes ahead\\n            it = front;\\n            it = it->next->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\nAny question let me know. If you like the post please upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        // If NULL, then return\\n        if(head == NULL)\\n            return head;\\n        \\n        // An iterator node for traversing the LinkedList\\n        ListNode* it = head;\\n        \\n        // A previous pointer to store the second node of the previous pair \\n        ListNode* prev = NULL;\\n        \\n        while(it != NULL && it->next != NULL)\\n        {\\n            // Front and back pointers for the two nodes of the pair to be swapped\\n            ListNode* back = it;\\n            ListNode* front = back->next;\\n            \\n            // Pointing Back node to the node next to Front \\n            back->next = front->next;\\n            \\n            // If it\\'s the start of the Linked List\\n            if(prev == NULL)\\n            {\\n                front->next = back;\\n                // point the head to Front since Front is not swapped back\\n                head = front;\\n            }\\n            else\\n            {\\n                // If it\\'s not the start of the linkedlist,\\n                // point the Prev pointer to the Front\\n                // And, Front pointer to the Back.\\n                prev->next = front;\\n                front->next = back;\\n            }\\n            \\n            // Update the Prev pointer\\n            prev = back;\\n            \\n            // Shift it to Front and two nodes ahead\\n            it = front;\\n            it = it->next->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877607,
                "title": "rust-straightforward-non-recursive-i-e-o-1-space",
                "content": "```rust\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut curr: &mut Option<Box<ListNode>> = &mut head;\\n        // Man, if-let chains or box patterns would be so nice...\\n        while curr.is_some() && curr.as_ref().unwrap().next.is_some() {\\n            let mut node1 = curr.take().unwrap();\\n            let mut node2 = node1.next.take().unwrap();\\n            let rest = node2.next.take();\\n            node1.next = rest;\\n            node2.next = Some(node1);\\n            *curr = Some(node2);\\n            curr = &mut curr.as_mut().unwrap().next.as_mut().unwrap().next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut curr: &mut Option<Box<ListNode>> = &mut head;\\n        // Man, if-let chains or box patterns would be so nice...\\n        while curr.is_some() && curr.as_ref().unwrap().next.is_some() {\\n            let mut node1 = curr.take().unwrap();\\n            let mut node2 = node1.next.take().unwrap();\\n            let rest = node2.next.take();\\n            node1.next = rest;\\n            node2.next = Some(node1);\\n            *curr = Some(node2);\\n            curr = &mut curr.as_mut().unwrap().next.as_mut().unwrap().next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820212,
                "title": "c-monster-oneliner-solution-vs-iterative-approach-explained-100-time-90-space",
                "content": "This is a rather simple to understand and not necessarily trivial to solve problem, so I decided to give myself a good extra challenge and to solve it first of all with a recursive approach.\\n\\nAnd doing it in one line.\\n\\nMy original code, the blasphemous oneliner:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head, ListNode *originalHead = NULL, ListNode *tmp = NULL) {\\n        return (originalHead = originalHead ? originalHead : head && head->next ? head->next : head, head) && head->next ? swapPairs(head->next->next, originalHead, (tmp = head->next, head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next, tmp->next = head)) : originalHead;\\n    }\\n};\\n```\\n\\nNow, for the sake of exercise and possibly for the joy of some of my most affectionate readers, I converted it into an iterative approach.\\n\\nFirst of all we move the variable declaration where they belong (in the recursive approach, I used the trick of setting them as additional parameters).\\n\\nAnd we get the first tricky part: `originalHead` needs to be `head->next` (because we are going to swap the first 2 elements too), provided it exists, otherwise it is going to be just `head` (if it is a valid node or `NULL`), so we initialise it to `head && head->next ? head->next : head`; `tmp` does not need to be initialised. And anyway nobody ever loved `tmp` and its parent were not even proud of `tmp`, so `tmp` does not deserve any initial value! In this version we will also need another pointer that I could avoid using previously, `nextHead`.\\n\\nBut enough with pointers\\' drama: we move on and convert the bulk of the rest of the logic to fit into a `while` loop with a `head && head->next` condition, again matching the logic of our oversized oneliner.\\n\\nInside our loop we can first of all store the value of the element after the current `head` in `tmp` and the value of the next `head` into `nextHead`.\\n\\nThen we have to update `head->next`: it has to be an element 3 steps to the right, if such an element exist, otherwise it is going to be an element 2 steps to the right (as it is the case for when we encounter the last element in an odd-lengthed list).\\n\\nTime to switch, so we set `tmp->next = head` and, since we are done with the logic for this run, all that we are missing is just to set it for the next iteration, with `head = nextHead`.\\n\\nOnce we are done looping, we can just return `originalHead`.\\n\\nThe refactored (and significantly more readable) code, which curiously seems to run a bit slower:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head) {\\n        ListNode *originalHead = head && head->next ? head->next : head, *tmp, *nextHead;\\n        while (head && head->next) {\\n            // storing the current value of the node following head\\n            tmp = head->next;\\n            // storing the head of the next loop\\n            nextHead = head->next->next;\\n            // updating head->next\\n            head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next;\\n            // switching head and its previous next position\\n            tmp->next = head;\\n            // setting the head of the next loop\\n            head = nextHead;\\n        }\\n        return originalHead;\\n    }\\n};\\n```\\n\\nAnd that was me months ago; I forgot about having solved the problem already, so I came up with another solution using one less variable.\\n\\nIn it I just declare `nextHead`, initialised to be `head->next`, provided both it and `head` exist, then I assign `head->next` the result of a recursive call, swap `head` and `nextHead` and return the latter.\\n\\nThe updated code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case: we are at the end of the line\\n        if (!head || !head->next) return head; \\n        // support variable\\n        ListNode *nextHead = head->next;\\n        // swapping positions\\n        head->next = swapPairs(nextHead->next);\\n        nextHead->next = head;\\n        return nextHead;\\n    }\\n};\\n```\\n\\nEven turning it into one liner is much more concise \\uD83D\\uDE09 :\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head, ListNode *nextHead = NULL) {\\n        return head && head->next ? nextHead = head->next, head->next = swapPairs(nextHead->next), nextHead->next = head, nextHead : head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head, ListNode *originalHead = NULL, ListNode *tmp = NULL) {\\n        return (originalHead = originalHead ? originalHead : head && head->next ? head->next : head, head) && head->next ? swapPairs(head->next->next, originalHead, (tmp = head->next, head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next, tmp->next = head)) : originalHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head) {\\n        ListNode *originalHead = head && head->next ? head->next : head, *tmp, *nextHead;\\n        while (head && head->next) {\\n            // storing the current value of the node following head\\n            tmp = head->next;\\n            // storing the head of the next loop\\n            nextHead = head->next->next;\\n            // updating head->next\\n            head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next;\\n            // switching head and its previous next position\\n            tmp->next = head;\\n            // setting the head of the next loop\\n            head = nextHead;\\n        }\\n        return originalHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case: we are at the end of the line\\n        if (!head || !head->next) return head; \\n        // support variable\\n        ListNode *nextHead = head->next;\\n        // swapping positions\\n        head->next = swapPairs(nextHead->next);\\n        nextHead->next = head;\\n        return nextHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head, ListNode *nextHead = NULL) {\\n        return head && head->next ? nextHead = head->next, head->next = swapPairs(nextHead->next), nextHead->next = head, nextHead : head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793729,
                "title": "3-lines-in-python-recursion",
                "content": "```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        head.next.next, head.next, head = head, self.swapPairs(head.next.next), head.next\\n        return head\\n```\\n\\nAnd, non-recursion in 5 lines:\\n```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        prev, cur = dummy, dummy.next = ListNode(0), head\\n        while cur and cur.next:\\n            cur.next.next, cur.next, prev.next = prev.next, cur.next.next, cur.next\\n            prev, cur = cur, cur.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        head.next.next, head.next, head = head, self.swapPairs(head.next.next), head.next\\n        return head\\n```\n```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        prev, cur = dummy, dummy.next = ListNode(0), head\\n        while cur and cur.next:\\n            cur.next.next, cur.next, prev.next = prev.next, cur.next.next, cur.next\\n            prev, cur = cur, cur.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393307,
                "title": "very-short-line-of-kotlin-code",
                "content": "Hope if you guys love it\\n\\n```\\nfun swapPairs(head: ListNode?): ListNode? {\\n    if(head?.next == null) return head\\n    val remaining = swapPairs(head.next?.next)\\n    val newHead = head.next!!\\n    newHead.next = head\\n    newHead.next!!.next = remaining\\n    return newHead\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun swapPairs(head: ListNode?): ListNode? {\\n    if(head?.next == null) return head\\n    val remaining = swapPairs(head.next?.next)\\n    val newHead = head.next!!\\n    newHead.next = head\\n    newHead.next!!.next = remaining\\n    return newHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 303149,
                "title": "c-recursive-solution-short-simple-with-comments",
                "content": "```\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head != NULL && head->next != NULL)\\n        {\\n            ListNode *temp = head->next;                // temp = 2\\n            head->next = swapPairs(head->next->next);   // 1->3\\n            temp->next = head;                          // 2->1 \\n            head = temp;                                // head = 2\\n        }\\n        return head; // if head is NULL, head->next is NULL, or we\\'re done swapping\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head != NULL && head->next != NULL)\\n        {\\n            ListNode *temp = head->next;                // temp = 2\\n            head->next = swapPairs(head->next->next);   // 1->3\\n            temp->next = head;                          // 2->1 \\n            head = temp;                                // head = 2\\n        }\\n        return head; // if head is NULL, head->next is NULL, or we\\'re done swapping\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1574728,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895922,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566737,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1783820,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1836468,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1827949,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566051,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895437,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1671797,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1571062,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1574728,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895922,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566737,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1783820,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1836468,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1827949,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566051,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895437,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1671797,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1571062,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895928,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1576659,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1896284,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1573008,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 2057965,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 2034957,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 2013646,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1997607,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1988499,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1985704,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1984894,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1972364,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1972265,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1968740,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1958756,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1896214,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895915,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895810,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895807,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895616,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895609,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895543,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895531,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895521,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895482,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895451,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895446,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895389,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1883859,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1817742,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1808252,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1804363,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1803290,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1799258,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1786274,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1785572,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1764185,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1763737,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1760984,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1760448,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Maximum Path Sum",
        "question_content": "<p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>\n\n<p>The <strong>path sum</strong> of a path is the sum of the node&#39;s values in the path.</p>\n\n<p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 = 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [-10,9,20,null,null,15,7]\n<strong>Output:</strong> 42\n<strong>Explanation:</strong> The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 3 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 603423,
                "title": "python-recursion-stack-thinking-process-diagram",
                "content": "This problem requires quite a bit of quirky thinking steps. Take it slow until you fully grasp it.\\n\\n# **Basics**\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177330.png)\\n\\n\\n# **Base cases**\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177335.png)\\n\\n\\n# **Important Observations**\\n* These important observations are very important to understand `Line 9` and `Line 10` in the code.\\n\\t* For example, in the code (`Line 9`), we do something like `max(get_max_gain(node.left), 0)`. The important part is: why do we take maximum value between 0 and maximum gain we can get from left branch? Why 0?\\n\\t* Check the two images below first.\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177343.png)\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177349.png)\\n\\n* The important thing is \"We can only get any sort of gain IF our branches are not below zero. If they are below zero, why do we even bother considering them? Just pick 0 in that case. Therefore, we do `max(<some gain we might get or not>, 0)`.\\n\\n# **Going down the recursion stack for one example**\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177356.png)\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177362.png)\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177368.png)\\n\\n* Because of this, we do `Line 12` and `Line 13`. It is important to understand the different between looking for the maximum path INVOLVING the current node in process and what we return for the node which starts the recursion stack. `Line 12` and `Line 13` takes care of the former issue and `Line 15` (and the image below) takes care of the latter issue.\\n\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177373.png)\\n\\n* Because of this fact, we have to return like `Line 15`. For our example, for node 1, which is the recursion call that node 3 does for `max(get_max_gain(node.left), 0)`, node 1 cannot include both node 6 and node 7 for a path to include node 3. Therefore, we can only pick the max gain from left path or right path of node 1.\\n\\n\\n**Python**\\n``` python\\n1. class Solution:\\n2.     def maxPathSum(self, root: TreeNode) -> int:\\n3. \\t\\tmax_path = float(\"-inf\") # placeholder to be updated\\n4. \\t\\tdef get_max_gain(node):\\n5. \\t\\t\\tnonlocal max_path # This tells that max_path is not a local variable\\n6. \\t\\t\\tif node is None:\\n7. \\t\\t\\t\\treturn 0\\n8. \\t\\t\\t\\t\\n9. \\t\\t\\tgain_on_left = max(get_max_gain(node.left), 0) # Read the part important observations\\n10. \\t\\tgain_on_right = max(get_max_gain(node.right), 0)  # Read the part important observations\\n11. \\t\\t\\t\\n12. \\t\\tcurrent_max_path = node.val + gain_on_left + gain_on_right # Read first three images of going down the recursion stack\\n13. \\t\\tmax_path = max(max_path, current_max_path) # Read first three images of going down the recursion stack\\n14. \\t\\t\\t\\n15. \\t\\treturn node.val + max(gain_on_left, gain_on_right) # Read the last image of going down the recursion stack\\n16. \\t\\t\\t\\n17. \\t\\t\\t\\n18. \\tget_max_gain(root) # Starts the recursion chain\\n19. \\treturn max_path\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "``` python\\n1. class Solution:\\n2.     def maxPathSum(self, root: TreeNode) -> int:\\n3. \\t\\tmax_path = float(\"-inf\") # placeholder to be updated\\n4. \\t\\tdef get_max_gain(node):\\n5. \\t\\t\\tnonlocal max_path # This tells that max_path is not a local variable\\n6. \\t\\t\\tif node is None:\\n7. \\t\\t\\t\\treturn 0\\n8. \\t\\t\\t\\t\\n9. \\t\\t\\tgain_on_left = max(get_max_gain(node.left), 0) # Read the part important observations\\n10. \\t\\tgain_on_right = max(get_max_gain(node.right), 0)  # Read the part important observations\\n11. \\t\\t\\t\\n12. \\t\\tcurrent_max_path = node.val + gain_on_left + gain_on_right # Read first three images of going down the recursion stack\\n13. \\t\\tmax_path = max(max_path, current_max_path) # Read first three images of going down the recursion stack\\n14. \\t\\t\\t\\n15. \\t\\treturn node.val + max(gain_on_left, gain_on_right) # Read the last image of going down the recursion stack\\n16. \\t\\t\\t\\n17. \\t\\t\\t\\n18. \\tget_max_gain(root) # Starts the recursion chain\\n19. \\treturn max_path\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39775,
                "title": "accepted-short-solution-in-java",
                "content": "Here's my ideas:\\n\\n - A path from start to end, goes up on the tree for 0 or more steps, then goes down for 0 or more steps. Once it goes down, it can't go up. Each path has a highest node, which is also the lowest common ancestor of all other nodes on the path.\\n - A recursive method `maxPathDown(TreeNode node)` (1) computes the maximum path sum with highest node is the input node, update maximum if necessary (2) returns the maximum sum of the path that can be extended to input node's parent.\\n\\nCode:\\n\\n    public class Solution {\\n        int maxValue;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            maxValue = Integer.MIN_VALUE;\\n            maxPathDown(root);\\n            return maxValue;\\n        }\\n        \\n        private int maxPathDown(TreeNode node) {\\n            if (node == null) return 0;\\n            int left = Math.max(0, maxPathDown(node.left));\\n            int right = Math.max(0, maxPathDown(node.right));\\n            maxValue = Math.max(maxValue, left + right + node.val);\\n            return Math.max(left, right) + node.val;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int maxValue;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            maxValue = Integer.MIN_VALUE;\\n            maxPathDown(root);\\n            return maxValue;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 389609,
                "title": "full-explanation-article-with-pseudo-code-beats-java-100-time-and-100-space-solution",
                "content": "A lot of the discussions here left me wondering with the magic that was happening between the lines and did not clearly explain the concept of the solution.\\nHere is a step by step solution of what would probably be easier to understand.\\n\\nOur goal is to find the maximum path sum. Now consider the following example.\\n\\n       10\\n\\t  /  \\\\\\n\\tnull null\\n\\t\\n\\t\\nIn this simple case we know that the max sum would be just the root node itself and the answer would be 10. So fo all `leaf`  nodes the max sum path is the value of the node itself.\\n\\nNow let\\'s consider the following example.\\n\\n ```\\n    20\\n   /  \\\\\\n 10    30\\n```\\n\\nHere there are multiple possibilities and we need to take care of the following **FOUR PATHS** that could be our max.\\n1.  The root iself : `20 `\\n2.  The root with the maximum from it\\'s left subTree : \\n\\t```\\n\\t\\t20\\n\\t\\t/\\n\\t  10\\n```\\t\\n3. The root with the maximum from it\\'s right subTree : \\n\\t\\n\\t\\t20\\n\\t\\t  \\\\\\n\\t       30\\n```\\t\\n4. The root with it\\'s left, right and itself\\n ```\\n\\t\\t 20\\n\\t\\t / \\\\\\n\\t 10  30\\n```\\n\\nIn case you are wondering  why we did not choose the root.left (10) or root.right(30) alone in the calculation ( like I wondered ), that\\'s because we would have already computed the result of it as a node in our recursion separately.\\n\\nThis actually breaks down our code to a very simple pseudo code:\\n\\n```\\nif( root == null) return 0;\\nleft = recurse(leftChild);\\nright = recurse(rightChild);\\n\\n// now find the max of all the four paths\\nleftPath = root.value + left;\\nrightPath = root.value + right;\\ncompletePath = root.value + right + left;\\n\\nresult = max( root.value, leftPath, rightPath, completePath );\\n\\nreturn max(root.value, leftPath, rightPath);\\n```\\n\\n*What\\'s  interesting to note here is the last line of the code* :\\n\\n```\\nreturn max(root.value, leftPath, rightPath);\\n```\\n\\n**Wondering why  did we do that ?**\\n\\nWell,  we know that we did all the calculations possible if the tree only consists of the current node as root in any possible recursion cycle. And the result of that cycle would have been stored in the `result` variable.\\nBut, what if the current node is just a child of it\\'s parent. Then it needs to return a value, such that the root had to be part of the answer. \\nSo if the root has to be part of the answer, it should return what\\'s the maximum value it can return if it\\'s part of it.\\nThat would be either of the three cases here :\\n1.  The root iself : `20 `\\n2.  The root with the maximum from it\\'s left subTree : \\n\\t```\\n\\t\\t20\\n\\t\\t/\\n\\t  10\\n```\\t\\n3. The root with the maximum from it\\'s right subTree : \\n\\t\\n\\t\\t20\\n\\t\\t  \\\\\\n\\t       30\\n```\\t\\nThis concludes us to the following code :\\n\\n```\\npublic class BinaryTreeMaximumPathSum {\\n    private int maxSum;\\n\\n    public int maxSumHelper(TreeNode root) {\\n\\t\\t\\n\\t\\t// base case\\n        if (root == null) return 0; \\n\\t\\t\\n\\t\\t// recursing through left and right subtree\\n        int leftMax = maxSumHelper(root.left);\\n        int rightMax = maxSumHelper(root.right);\\n\\n\\t\\t// finding all the four paths and the maximum between all of them\\n        int maxRightLeft = Math.max(leftMax, rightMax);\\n        int maxOneNodeRoot = Math.max(root.val, (root.val + maxRightLeft));\\n        int maxAll = Math.max(maxOneNodeRoot, leftMax + rightMax + root.val);\\n\\t\\t\\n\\t\\t// Storing the result in the maxSum holder\\n        maxSum = Math.max(maxSum, maxAll);\\n\\t\\t\\n\\t\\t// returning the value if root was part of the answer\\n        return maxOneNodeRoot;\\n\\n    }\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        maxSumHelper(root);\\n        return maxSum; // as maxSum will always store the result\\n\\n    }\\n}\\n\\n```\\nHope this post helps you clear your doubts !\\n",
                "solutionTags": [],
                "code": "```\\n    20\\n   /  \\\\\\n 10    30\\n```\n```\\n\\t\\t20\\n\\t\\t/\\n\\t  10\\n```\n```\\t\\n4. The root with it\\'s left, right and itself\\n ```\n```\\n\\nIn case you are wondering  why we did not choose the root.left (10) or root.right(30) alone in the calculation ( like I wondered ), that\\'s because we would have already computed the result of it as a node in our recursion separately.\\n\\nThis actually breaks down our code to a very simple pseudo code:\\n\\n```\n```\\n\\n*What\\'s  interesting to note here is the last line of the code* :\\n\\n```\n```\\n\\n**Wondering why  did we do that ?**\\n\\nWell,  we know that we did all the calculations possible if the tree only consists of the current node as root in any possible recursion cycle. And the result of that cycle would have been stored in the `result` variable.\\nBut, what if the current node is just a child of it\\'s parent. Then it needs to return a value, such that the root had to be part of the answer. \\nSo if the root has to be part of the answer, it should return what\\'s the maximum value it can return if it\\'s part of it.\\nThat would be either of the three cases here :\\n1.  The root iself : `20 `\\n2.  The root with the maximum from it\\'s left subTree : \\n\\t```\n```\\t\\n3. The root with the maximum from it\\'s right subTree : \\n\\t\\n\\t\\t20\\n\\t\\t  \\\\\\n\\t       30\\n```\n```\\npublic class BinaryTreeMaximumPathSum {\\n    private int maxSum;\\n\\n    public int maxSumHelper(TreeNode root) {\\n\\t\\t\\n\\t\\t// base case\\n        if (root == null) return 0; \\n\\t\\t\\n\\t\\t// recursing through left and right subtree\\n        int leftMax = maxSumHelper(root.left);\\n        int rightMax = maxSumHelper(root.right);\\n\\n\\t\\t// finding all the four paths and the maximum between all of them\\n        int maxRightLeft = Math.max(leftMax, rightMax);\\n        int maxOneNodeRoot = Math.max(root.val, (root.val + maxRightLeft));\\n        int maxAll = Math.max(maxOneNodeRoot, leftMax + rightMax + root.val);\\n\\t\\t\\n\\t\\t// Storing the result in the maxSum holder\\n        maxSum = Math.max(maxSum, maxAll);\\n\\t\\t\\n\\t\\t// returning the value if root was part of the answer\\n        return maxOneNodeRoot;\\n\\n    }\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        maxSumHelper(root);\\n        return maxSum; // as maxSum will always store the result\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603072,
                "title": "c-solution-o-n-with-detailed-explanation",
                "content": "```\\nThe way to think of a solution to this is that when we are looking a path in a tree its unidirectional and cannot retrace back what i mean by that is:\\n    _\\n  / 1 \\\\ \\n / / \\\\ \\\\ <-----path that goes like a depth first search without backtracking\\n/ 2   3 v  \\n\\nSo a way to solve this is that if i am at a node i can choose a left or right subtree but if i choose both this is the only subtree that will contain my maximum\\n\\nI first set my max_sum to INT_MIN.\\nI can do either either of the options presented:\\n1.I can choose to take up the left subtree or drop it.\\n2.I can either choose to take up the right subtree or drop it.\\n3.I check for a possibility whether if i were to take both left subtree and right subtree would that beat my current max_sum?\\nLets consider\\n   -10\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\nI do my postorder traversal with a bit of variation:-\\n\\nint l=max(max_gain(root->left),0);\\nint r=max(max_gain(root->right),0);\\nBut why?\\nThis is because I have the option to choose the left or right subtree or whether i will just settle with my root value.\\n\\nSo I do my regular postorder traversal and do the above steps\\nI hit 9\\n\\n    9\\n   / \\\\\\nNULL  NULL\\n\\nint l=0,r=0(Base condition)\\ni store the value of 9+0+0 in a variable\\nThen check if this is greater than maxsum or not is so i update it.\\nAs my max_sum was INT_MIN it gets updated to 9\\n\\nNow we explore the right tree of root which reaches 15\\n\\n    15\\n   / \\\\\\nNULL  NULL\\n\\nint l=0,r=0(Base condition)\\ni store the value of 9+0+0 in a variable\\nThen check if this is greater than maxsum or not is so i update it.\\nAs my max_sum was 9 it gets updated to 15\\n\\nSimilarly with 7 but 7 doesnt beat the max_sum so nothing happens.\\n\\nNow we backtrack 20\\nhere int r=7(as 7>0)\\n     int l=15(as 15>0)\\n now i check whether 20+15+7(considering this subtree to be my maximum)\\n as 42>15 max_sum=42\\n Now what if we dont consider this subtree?\\n\\n Then we choose 20 and maximum of its left or right subtree\\n so we send return root->val+max(l,r) to our recursion stack\\n so when i reach the root it would be like this\\n           -10\\n           /  \\\\    <----I considered 15 and 20 because its along a path and is greater than 20+7\\n          9    35\\n  int l=9\\n      r=35\\n      check whether 9+35+-10=34 beats max_sum\\n      34<42 so nothing happens and we return -10+max(9,35)=25 to the caller after which we break out of the helper function and we get max_sum as 42.\\n\\n    int max_sum=INT_MIN;\\n    int max_gain(TreeNode* root)\\n    {\\n        if(!root)return 0;\\n        int l=max(max_gain(root->left),0);\\n        int r=max(max_gain(root->right),0);\\n        int new_price=root->val+l+r;\\n        max_sum=max(max_sum,new_price);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        max_gain(root);\\n        return max_sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nThe way to think of a solution to this is that when we are looking a path in a tree its unidirectional and cannot retrace back what i mean by that is:\\n    _\\n  / 1 \\\\ \\n / / \\\\ \\\\ <-----path that goes like a depth first search without backtracking\\n/ 2   3 v  \\n\\nSo a way to solve this is that if i am at a node i can choose a left or right subtree but if i choose both this is the only subtree that will contain my maximum\\n\\nI first set my max_sum to INT_MIN.\\nI can do either either of the options presented:\\n1.I can choose to take up the left subtree or drop it.\\n2.I can either choose to take up the right subtree or drop it.\\n3.I check for a possibility whether if i were to take both left subtree and right subtree would that beat my current max_sum?\\nLets consider\\n   -10\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\nI do my postorder traversal with a bit of variation:-\\n\\nint l=max(max_gain(root->left),0);\\nint r=max(max_gain(root->right),0);\\nBut why?\\nThis is because I have the option to choose the left or right subtree or whether i will just settle with my root value.\\n\\nSo I do my regular postorder traversal and do the above steps\\nI hit 9\\n\\n    9\\n   / \\\\\\nNULL  NULL\\n\\nint l=0,r=0(Base condition)\\ni store the value of 9+0+0 in a variable\\nThen check if this is greater than maxsum or not is so i update it.\\nAs my max_sum was INT_MIN it gets updated to 9\\n\\nNow we explore the right tree of root which reaches 15\\n\\n    15\\n   / \\\\\\nNULL  NULL\\n\\nint l=0,r=0(Base condition)\\ni store the value of 9+0+0 in a variable\\nThen check if this is greater than maxsum or not is so i update it.\\nAs my max_sum was 9 it gets updated to 15\\n\\nSimilarly with 7 but 7 doesnt beat the max_sum so nothing happens.\\n\\nNow we backtrack 20\\nhere int r=7(as 7>0)\\n     int l=15(as 15>0)\\n now i check whether 20+15+7(considering this subtree to be my maximum)\\n as 42>15 max_sum=42\\n Now what if we dont consider this subtree?\\n\\n Then we choose 20 and maximum of its left or right subtree\\n so we send return root->val+max(l,r) to our recursion stack\\n so when i reach the root it would be like this\\n           -10\\n           /  \\\\    <----I considered 15 and 20 because its along a path and is greater than 20+7\\n          9    35\\n  int l=9\\n      r=35\\n      check whether 9+35+-10=34 beats max_sum\\n      34<42 so nothing happens and we return -10+max(9,35)=25 to the caller after which we break out of the helper function and we get max_sum as 42.\\n\\n    int max_sum=INT_MIN;\\n    int max_gain(TreeNode* root)\\n    {\\n        if(!root)return 0;\\n        int l=max(max_gain(root->left),0);\\n        int r=max(max_gain(root->right),0);\\n        int new_price=root->val+l+r;\\n        max_sum=max(max_sum,new_price);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        max_gain(root);\\n        return max_sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39875,
                "title": "elegant-java-solution",
                "content": "    public class Solution {\\n        int max = Integer.MIN_VALUE;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            helper(root);\\n            return max;\\n        }\\n        \\n        // helper returns the max branch \\n        // plus current node's value\\n        int helper(TreeNode root) {\\n            if (root == null) return 0;\\n            \\n            int left = Math.max(helper(root.left), 0);\\n            int right = Math.max(helper(root.right), 0);\\n            \\n            max = Math.max(max, root.val + left + right);\\n            \\n            return root.val + Math.max(left, right);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        int max = Integer.MIN_VALUE;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            helper(root);\\n            return max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39869,
                "title": "simple-o-n-algorithm-with-one-traversal-through-the-tree",
                "content": "    class Solution {\\n        int maxToRoot(TreeNode *root, int &re) {\\n            if (!root) return 0;\\n            int l = maxToRoot(root->left, re);\\n            int r = maxToRoot(root->right, re);\\n            if (l < 0) l = 0;\\n            if (r < 0) r = 0;\\n            if (l + r + root->val > re) re = l + r + root->val;\\n            return root->val += max(l, r);\\n        }\\n    public:\\n        int maxPathSum(TreeNode *root) {\\n            int max = -2147483648;\\n            maxToRoot(root, max);\\n            return max;\\n        }\\n    };\\n\\nupdate the val of each node of the tree bottom-up, the new val of TreeNode *x stands for the max sum started from any node in subtree x and ended in x, mataining the re for result in traversal at the same time.",
                "solutionTags": [],
                "code": "class Solution {\\n        int maxToRoot(TreeNode *root, int &re) {\\n            if (!root) return 0;\\n            int l = maxToRoot(root->left, re);\\n            int r = maxToRoot(root->right, re);\\n            if (l < 0) l = 0;\\n            if (r < 0) r = 0;\\n            if (l + r + root->val > re) re = l + r + root->val;\\n            return root->val += max(l, r);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 370666,
                "title": "concise-dfs-solution-with-detailed-explanation-python",
                "content": "The idea is to **update node values with the biggest, positive cumulative sum gathered by its children**:\\n* If both contributions are negative, no value is added. \\n* If both are positive, only the biggest one is added, so that we don\\'t include both children during the rest of the tree exploration. \\n* Leaves return its own value and we recursively work our way upwards.\\n\\nA global maximum sum variable is maintained so that **every path can be individually checked**, while updated node values on the tree **allow for exploration of other valid paths outside of the current subtree**. \\nMore details in the code comments:\\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.max_sum = float(\\'-inf\\')\\n        self.dfs(root)\\n        return self.max_sum\\n    \\n    def dfs(self, node):\\n        if not node: return 0\\n        \\n        # only add positive contributions\\n        leftST_sum = max(0, self.dfs(node.left))\\n        rightST_sum = max(0, self.dfs(node.right))\\n\\n        # check if cumulative sum at current node > global max sum so far\\n        # this evaluates a candidate path\\n        self.max_sum = max(self.max_sum, leftST_sum + rightST_sum + node.val)\\n        \\n        # add to the current node ONLY one of the children contributions\\n        # in order to maintain the constraint of considering only paths\\n        # if not, we would be exploring explore the whole tree - against problem definition\\n        return max(leftST_sum, rightST_sum) + node.val\\n```\\n\\nThe key is to always choose the maximum cumulative sum path, while updating the \"global\" maximum value, from the leaves upwards.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.max_sum = float(\\'-inf\\')\\n        self.dfs(root)\\n        return self.max_sum\\n    \\n    def dfs(self, node):\\n        if not node: return 0\\n        \\n        # only add positive contributions\\n        leftST_sum = max(0, self.dfs(node.left))\\n        rightST_sum = max(0, self.dfs(node.right))\\n\\n        # check if cumulative sum at current node > global max sum so far\\n        # this evaluates a candidate path\\n        self.max_sum = max(self.max_sum, leftST_sum + rightST_sum + node.val)\\n        \\n        # add to the current node ONLY one of the children contributions\\n        # in order to maintain the constraint of considering only paths\\n        # if not, we would be exploring explore the whole tree - against problem definition\\n        return max(leftST_sum, rightST_sum) + node.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39919,
                "title": "8-10-lines-two-solutions",
                "content": "Two solutions:\\n\\n---\\n\\n**Solution 1: *Helper returning two values*:** (240 ms, 8 lines)\\n\\n    def maxPathSum(self, root):\\n        def maxsums(node):\\n            if not node:\\n                return [-2**31] * 2\\n            left = maxsums(node.left)\\n            right = maxsums(node.right)\\n            return [node.val + max(left[0], right[0], 0),\\n                    max(left + right + [node.val + left[0] + right[0]])]\\n        return max(maxsums(root))\\n\\nMy helper function returns two values:\\n\\n 1. The max sum of all paths ending in the given node (can be extended through the parent)\\n 2. The max sum of all paths anywhere in tree rooted at the given node (can *not* be extended through the parent).\\n\\n\\n---\\n\\n**Solution 2: *Helper updating a \"global\" maximum*:** (172 ms, 10 lines)\\n\\n    def maxPathSum(self, root):\\n        def maxend(node):\\n            if not node:\\n                return 0\\n            left = maxend(node.left)\\n            right = maxend(node.right)\\n            self.max = max(self.max, left + node.val + right)\\n            return max(node.val + max(left, right), 0)\\n        self.max = None\\n        maxend(root)\\n        return self.max\\n\\nHere the helper is similar, but only returns the first of the two values (the max sum of all paths ending in the given node). Instead of returning the second value (the max sum of all paths anywhere in tree rooted at the given node), it updates a \"global\" maximum.",
                "solutionTags": [
                    "Python"
                ],
                "code": "Two solutions:\\n\\n---\\n\\n**Solution 1: *Helper returning two values*:** (240 ms, 8 lines)\\n\\n    def maxPathSum(self, root):\\n        def maxsums(node):\\n            if not node:\\n                return [-2**31] * 2\\n            left = maxsums(node.left)\\n            right = maxsums(node.right)\\n            return [node.val + max(left[0], right[0], 0),\\n                    max(left + right + [node.val + left[0] + right[0]])]\\n        return max(maxsums(root))\\n\\nMy helper function returns two values:\\n\\n 1. The max sum of all paths ending in the given node (can be extended through the parent)\\n 2. The max sum of all paths anywhere in tree rooted at the given node (can *not* be extended through the parent).\\n\\n\\n---\\n\\n**Solution 2: *Helper updating a \"global\" maximum*:** (172 ms, 10 lines)\\n\\n    def maxPathSum(self, root):\\n        def maxend(node):\\n            if not node:\\n                return 0\\n            left = maxend(node.left)\\n            right = maxend(node.right)\\n            self.max = max(self.max, left + node.val + right)\\n            return max(node.val + max(left, right), 0)\\n        self.max = None\\n        maxend(root)\\n        return self.max\\n\\nHere the helper is similar, but only returns the first of the two values (the max sum of all paths ending in the given node). Instead of returning the second value (the max sum of all paths anywhere in tree rooted at the given node), it updates a \"global\" maximum.",
                "codeTag": "Python3"
            },
            {
                "id": 39873,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "    class Solution {\\n        int sum;\\n    public:\\n        int maxPathSum(TreeNode* root) {\\n            sum=INT_MIN;\\n            help(root);\\n            return sum;\\n        }\\n        \\n        /*** return the max-value-ended-at-root-node ***/\\n        int help(TreeNode* root){\\n            if(!root)   return 0;\\n            int left = max(0, help(root->left));\\n            int right = max(0, help(root->right));\\n            /*** key parts : embedding the max-value-find in the recursion process ***/\\n            sum = max(sum, left+right+root->val);\\n            /*** get the max-value-ended-at-root ***/\\n            return max(left, right)+root->val;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        int sum;\\n    public:\\n        int maxPathSum(TreeNode* root) {\\n            sum=INT_MIN;\\n            help(root);\\n            return sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1288024,
                "title": "c-easy-to-understand-full-explanation-article-with-code",
                "content": "```\\nLet\\'s think what can be the possible cases for this question:\\n1) The MaxPathSum can pass through root node.\\n    eg: \\n            10  <- MaxPathSum passes through this node ( considering 10 as root ).\\n            /\\\\\\n           2  10\\n          /\\\\    \\\\\\n         20 1   -20 \\n2) MaxPathSum can be present in the left Subtree.\\n    eg:\\n           -100  <- MaxPathSum passes lies in the left Subtree ( considering -100 as root ).\\n            /\\\\\\n           2  10\\n          /\\\\    \\\\\\n         20 1   -20 \\n    \\n\\n3) MaxPathSum can be present int the right Subtree.\\n\\n    eg:\\n           -100  <- MaxPathSum passes lies in the right Subtree ( considering -100 as root ).\\n            /\\\\\\n         -200  1000\\n          /\\\\    \\\\\\n         20 1   200 \\n\\nSo, we just have to write for the case when it passes through the root node. Recursion will take care of the rest.\\n\\nAnother thing, we have to also keep a track of max branch sum. Here is an example why:\\n    eg: \\n\\n        Lets say the left branch sum of this subtree is 20 and right branch is 30.\\n            10\\n           /  \\\\                         BS = Branch Sum\\n        /\\\\      /\\\\  \\n       /20\\\\    /30\\\\\\n      / BS \\\\  / BS \\\\\\n     /______\\\\/______\\\\\\n\\n But it may be possible that we can find even better answer which includes this subtree. \\n In that case we have to pick a single branch of this subtree.\\n Since path can only be in one direction from a node, i.e, either we can go left or right from a node.\\n like, \\n\\n              50            MaxPathSum = 30 + 10 + 50 + 7\\n             /  \\\\ \\n            10   7\\n           /  \\\\\\n        /\\\\      /\\\\  \\n       /20\\\\    /30\\\\\\n      / BS \\\\  / BS \\\\\\n     /______\\\\/______\\\\\\n\\n So, here the root 50 should know what is the maxBranchSum in the left to find the maxPathSum.\\nSo, 10 will return the branch sum as [max(leftBranchSum , rightBranchSum) + root->val] to its parent.\\n```\\n\\n\\nOnce you have figured that out, then the answer is pretty simple.\\n\\nthe ans can be :\\nmax({\\n    root->val,                                    //root can be ans\\n    leftBS,   //BS = BranchSum        //left branch of the root may have the ans\\n    rightBS,  //BS = BranchSum      //right branch of the root may have the ans\\n    leftBS + rightBS + root->val   //left branch + root + right branch can be the ans\\n});\\nLets have a look at the code:\\n```\\n\\nint maxSum(TreeNode* root, int& ans) {\\n    /* This function return the Branch Sum......\\n    So if the node is NULL then it won\\'t have a branch....so the branch sum will be 0.\\n    */\\n    //Base Case\\n    if(root == NULL){\\n        return 0;\\n    }\\n    \\n    //Recursive Case \\n    //BS = Branch Sum\\n    int leftBS = root->val + maxSum( root->left , ans );\\n    int rightBS = root->val + maxSum( root->right , ans );\\n    \\n    ans = max({\\n                ans,            //we may have found the maximum ans already\\n                root->val,      //may be the current root val is the maximum sum possible\\n                leftBS,         //may be the answer contain root->val + left branch value\\n                rightBS,        //may be the answer contain root->val + right branch value\\n                leftBS + rightBS - root->val   // may be ans conatin left branch + right branch + root->val\\n                                               // Since the root val is added twice from leftBS and rightBS so we are sunstracting it.\\n            });\\n    \\n    //Return the max branch Sum\\n    return max({ leftBS , rightBS , root->val });\\n}\\n\\nint maxPathSum(TreeNode* root) {\\n    int ans = INT_MIN;\\n    maxSum(root, ans);\\n    return ans;\\n}\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nLet\\'s think what can be the possible cases for this question:\\n1) The MaxPathSum can pass through root node.\\n    eg: \\n            10  <- MaxPathSum passes through this node ( considering 10 as root ).\\n            /\\\\\\n           2  10\\n          /\\\\    \\\\\\n         20 1   -20 \\n2) MaxPathSum can be present in the left Subtree.\\n    eg:\\n           -100  <- MaxPathSum passes lies in the left Subtree ( considering -100 as root ).\\n            /\\\\\\n           2  10\\n          /\\\\    \\\\\\n         20 1   -20 \\n    \\n\\n3) MaxPathSum can be present int the right Subtree.\\n\\n    eg:\\n           -100  <- MaxPathSum passes lies in the right Subtree ( considering -100 as root ).\\n            /\\\\\\n         -200  1000\\n          /\\\\    \\\\\\n         20 1   200 \\n\\nSo, we just have to write for the case when it passes through the root node. Recursion will take care of the rest.\\n\\nAnother thing, we have to also keep a track of max branch sum. Here is an example why:\\n    eg: \\n\\n        Lets say the left branch sum of this subtree is 20 and right branch is 30.\\n            10\\n           /  \\\\                         BS = Branch Sum\\n        /\\\\      /\\\\  \\n       /20\\\\    /30\\\\\\n      / BS \\\\  / BS \\\\\\n     /______\\\\/______\\\\\\n\\n But it may be possible that we can find even better answer which includes this subtree. \\n In that case we have to pick a single branch of this subtree.\\n Since path can only be in one direction from a node, i.e, either we can go left or right from a node.\\n like, \\n\\n              50            MaxPathSum = 30 + 10 + 50 + 7\\n             /  \\\\ \\n            10   7\\n           /  \\\\\\n        /\\\\      /\\\\  \\n       /20\\\\    /30\\\\\\n      / BS \\\\  / BS \\\\\\n     /______\\\\/______\\\\\\n\\n So, here the root 50 should know what is the maxBranchSum in the left to find the maxPathSum.\\nSo, 10 will return the branch sum as [max(leftBranchSum , rightBranchSum) + root->val] to its parent.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39927,
                "title": "iterative-java-solution",
                "content": "Hi guys!\\n\\nThe idea of mine approach is similar to recursive solutions which can be found in other posts but made in iterative manner. We just need to traverse the nodes in post-order (the same as the order of topological sorting, actually) storing the maximum root paths in a cache and updating the result value. Here's how it looks like in Java:\\n\\n    // just returns the nodes in post-order\\n    public Iterable<TreeNode> topSort(TreeNode root) {\\n        Deque<TreeNode> result = new LinkedList<>();\\n        if (root != null) {\\n            Deque<TreeNode> stack = new LinkedList<>();\\n            stack.push(root);\\n            while (!stack.isEmpty()) {\\n                TreeNode curr = stack.pop();\\n                result.push(curr);\\n                if (curr.right != null) stack.push(curr.right);\\n                if (curr.left != null) stack.push(curr.left);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int maxPathSum(TreeNode root) {\\n        int result = Integer.MIN_VALUE;\\n        Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\\n        maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\\n        for (TreeNode node : topSort(root)) {\\n            // as we process nodes in post-order their children are already cached\\n            int left = Math.max(maxRootPath.get(node.left), 0);\\n            int right = Math.max(maxRootPath.get(node.right), 0); \\n            maxRootPath.put(node, Math.max(left, right) + node.val);\\n            result = Math.max(left + right + node.val, result);\\n        }\\n        return result;\\n    }\\n\\nHappy coding!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nThe idea of mine approach is similar to recursive solutions which can be found in other posts but made in iterative manner. We just need to traverse the nodes in post-order (the same as the order of topological sorting, actually) storing the maximum root paths in a cache and updating the result value. Here's how it looks like in Java:\\n\\n    // just returns the nodes in post-order\\n    public Iterable<TreeNode> topSort(TreeNode root) {\\n        Deque<TreeNode> result = new LinkedList<>();\\n        if (root != null) {\\n            Deque<TreeNode> stack = new LinkedList<>();\\n            stack.push(root);\\n            while (!stack.isEmpty()) {\\n                TreeNode curr = stack.pop();\\n                result.push(curr);\\n                if (curr.right != null) stack.push(curr.right);\\n                if (curr.left != null) stack.push(curr.left);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int maxPathSum(TreeNode root) {\\n        int result = Integer.MIN_VALUE;\\n        Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\\n        maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\\n        for (TreeNode node : topSort(root)) {\\n            // as we process nodes in post-order their children are already cached\\n            int left = Math.max(maxRootPath.get(node.left), 0);\\n            int right = Math.max(maxRootPath.get(node.right), 0); \\n            maxRootPath.put(node, Math.max(left, right) + node.val);\\n            result = Math.max(left + right + node.val, result);\\n        }\\n        return result;\\n    }\\n\\nHappy coding!",
                "codeTag": "Unknown"
            },
            {
                "id": 39807,
                "title": "a-very-concise-recursive-solution",
                "content": "    int maxPathSum(TreeNode *root) {\\n        int maxPath = INT_MIN;\\n        dfsMaxPath(root, maxPath);\\n        return maxPath;\\n    }\\n    \\n    int dfsMaxPath(TreeNode *root, int &maxPath) {\\n        if (!root) return 0;\\n        int l = max(0, dfsMaxPath(root->left, maxPath));\\n        int r = max(0, dfsMaxPath(root->right, maxPath));\\n        maxPath = max(maxPath, l + r + root->val);\\n        return root->val + max(l, r);\\n    }",
                "solutionTags": [],
                "code": "    int maxPathSum(TreeNode *root) {\\n        int maxPath = INT_MIN;\\n        dfsMaxPath(root, maxPath);\\n        return maxPath;\\n    }\\n    \\n    int dfsMaxPath(TreeNode *root, int &maxPath) {\\n        if (!root) return 0;\\n        int l = max(0, dfsMaxPath(root->left, maxPath));\\n        int r = max(0, dfsMaxPath(root->right, maxPath));\\n        maxPath = max(maxPath, l + r + root->val);\\n        return root->val + max(l, r);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39884,
                "title": "python-solution-beats-97",
                "content": "    class Solution(object):\\n        current_max = float('-inf')\\n        def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n            self.maxPathSumHelper(root)\\n            return self.current_max\\n    \\n        def maxPathSumHelper(self, root):\\n            \"\"\"Helper method\"\"\"\\n            if root is None:\\n                return root\\n            left = self.maxPathSumHelper(root.left)\\n            right = self.maxPathSumHelper(root.right)\\n            left = 0 if left is None else (left if left > 0 else 0)\\n            right = 0 if right is None else (right if right > 0 else 0)\\n            self.current_max = max(left+right+root.val, self.current_max)\\n            return max(left, right) + root.val\\n\\nThis is my first post and I thought I would share my solution since it beats 97% of submissions. I keep a global variable current_max and update it whenever the sum of the root and its children are greater than the current max. I don't consider a child if its value is negative(set it to zero). Each parent returns its maximum child plus its own value.",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        current_max = float('-inf')\\n        def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n            self.maxPathSumHelper(root)\\n            return self.current_max\\n    \\n        def maxPathSumHelper(self, root):\\n            \"\"\"Helper method\"\"\"\\n            if root is None:\\n                return root\\n            left = self.maxPathSumHelper(root.left)\\n            right = self.maxPathSumHelper(root.right)\\n            left = 0 if left is None else (left if left > 0 else 0)\\n            right = 0 if right is None else (right if right > 0 else 0)\\n            self.current_max = max(left+right+root.val, self.current_max)\\n            return max(left, right) + root.val\\n\\nThis is my first post and I thought I would share my solution since it beats 97% of submissions. I keep a global variable current_max and update it whenever the sum of the root and its children are greater than the current max. I don't consider a child if its value is negative(set it to zero). Each parent returns its maximum child plus its own value.",
                "codeTag": "Java"
            },
            {
                "id": 982696,
                "title": "javascript-o-n-time-easy-to-understand-with-explanation",
                "content": "It\\'s important to point out that we are looking for the **maximum path**. In the most simple case, a single node can be the max path, or even the entire tree could be the max path. To keep the max variable up to date, I create a global variable that will be updated over the run of the functions.\\n\\nWe are doing a DFS recursive function here.\\n\\nWe need a base case, and that base case is if we hit a null, we return 0. We are going going to finish the left subtree before going to the right subtree, which is denoted by `findSums(node.left)` then after is `findSums(node.right)`. After the left and right subtree are done (for an example, look at a single node), we have three different sums. All three nodes (left, right and node.val), left side (node.val and left), right side (node.val and right) or just the single node. We use these values (with the current max) to find the max.\\n\\nThe most important part is **what do we return for this recursive function?** The answer is we are returning\\n\\n\\tThe Max Path from this node\\n\\t\\nThat can be node.val, leftNodeSum, or rightNodeSum. We cannot return allSum since that would not be a path. Very, very important to point that out.\\n\\n```\\nconst maxPathSum = (root) => {\\n\\tlet max = -Infinity;\\n\\n\\tconst findSums = (node) => {\\n\\t\\t// Base case / hit a null\\n\\t\\tif (!node) return 0;\\n\\n\\t\\tlet left = findSums(node.left),\\n\\t\\t\\tright = findSums(node.right),\\n\\t\\t\\tallSum = left + right + node.val,\\n\\t\\t\\tleftNodeSum = left + node.val,\\n\\t\\t\\trightNodeSum = right + node.val;\\n\\n\\t\\t// Max is all possible combinations\\n\\t\\tmax = Math.max(max, node.val, allSum, leftNodeSum, rightNodeSum);\\n\\t\\t\\n\\t\\t// Return the MAX path, which can be node.val, left + node.val, or right + node.val\\n\\t\\treturn Math.max(leftNodeSum, rightNodeSum, node.val);\\n\\t};\\n\\n\\tfindSums(root);\\n\\n\\treturn max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst maxPathSum = (root) => {\\n\\tlet max = -Infinity;\\n\\n\\tconst findSums = (node) => {\\n\\t\\t// Base case / hit a null\\n\\t\\tif (!node) return 0;\\n\\n\\t\\tlet left = findSums(node.left),\\n\\t\\t\\tright = findSums(node.right),\\n\\t\\t\\tallSum = left + right + node.val,\\n\\t\\t\\tleftNodeSum = left + node.val,\\n\\t\\t\\trightNodeSum = right + node.val;\\n\\n\\t\\t// Max is all possible combinations\\n\\t\\tmax = Math.max(max, node.val, allSum, leftNodeSum, rightNodeSum);\\n\\t\\t\\n\\t\\t// Return the MAX path, which can be node.val, left + node.val, or right + node.val\\n\\t\\treturn Math.max(leftNodeSum, rightNodeSum, node.val);\\n\\t};\\n\\n\\tfindSums(root);\\n\\n\\treturn max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419793,
                "title": "python-recursive-solution-beats-98-in-time-and-75-in-memory",
                "content": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        self.res = float(\\'-inf\\')\\n        self.helper(root)\\n        return self.res \\n        \\n    def helper(self, root):\\n        if not root:\\n            return 0\\n        left, right = self.helper(root.left), self.helper(root.right)\\n        self.res = max(self.res, root.val + left + right)\\n        return max(root.val + max(left, right), 0)\\n   ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        self.res = float(\\'-inf\\')\\n        self.helper(root)\\n        return self.res \\n        \\n    def helper(self, root):\\n        if not root:\\n            return 0\\n        left, right = self.helper(root.left), self.helper(root.right)\\n        self.res = max(self.res, root.val + left + right)\\n        return max(root.val + max(left, right), 0)\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 39908,
                "title": "python-solution-with-comments",
                "content": "    \\n    # Recursively \\n    def maxPathSum(self, root):\\n        self.res = -sys.maxsize-1\\n        self.oneSideSum(root)\\n        return self.res\\n        \\n    # compute one side maximal sum, \\n    # (root+left children, or root+right children),\\n    # root is the included top-most node \\n    def oneSideSum(self, root):\\n        if not root:\\n            return 0\\n        l = max(0, self.oneSideSum(root.left))\\n        r = max(0, self.oneSideSum(root.right))\\n        self.res = max(self.res, l+r+root.val)\\n        return max(l, r)+root.val",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "    \\n    # Recursively \\n    def maxPathSum(self, root):\\n        self.res = -sys.maxsize-1\\n        self.oneSideSum(root)\\n        return self.res\\n        \\n    # compute one side maximal sum, \\n    # (root+left children, or root+right children),\\n    # root is the included top-most node \\n    def oneSideSum(self, root):\\n        if not root:\\n            return 0\\n        l = max(0, self.oneSideSum(root.left))\\n        r = max(0, self.oneSideSum(root.right))\\n        self.res = max(self.res, l+r+root.val)\\n        return max(l, r)+root.val",
                "codeTag": "Python3"
            },
            {
                "id": 39862,
                "title": "easy-understand-34ms-c-dfs-solution",
                "content": "    class Solution {\\n    private:\\n        int dfs(TreeNode* root, int& maxsum) {\\n            if(!root) return 0;\\n            int l = max(0,dfs(root->left,maxsum));\\n            int r = max(0,dfs(root->right,maxsum));\\n            maxsum = max(l+r+root->val, maxsum);\\n            return root->val + max(l,r);\\n        }\\n    public:\\n        int maxPathSum(TreeNode* root) {\\n            int maxsum = INT_MIN;\\n            dfs(root,maxsum);\\n            return maxsum;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    private:\\n        int dfs(TreeNode* root, int& maxsum) {\\n            if(!root) return 0;\\n            int l = max(0,dfs(root->left,maxsum));\\n            int r = max(0,dfs(root->right,maxsum));\\n            maxsum = max(l+r+root->val, maxsum);\\n            return root->val + max(l,r);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39767,
                "title": "simple-python-o-n-solution",
                "content": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        self.msum = float('-inf')\\n        self.get_sum(root)\\n        return self.msum\\n    \\n    def get_sum(self, node):\\n        if not node:\\n            return 0\\n        \\n        ls, rs = self.get_sum(node.left), self.get_sum(node.right)\\n        max_single_path = max(node.val+max(ls,rs), node.val)\\n        self.msum = max(self.msum, max_single_path , node.val+ls+rs)\\n        return max_single_path\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        self.msum = float('-inf')\\n        self.get_sum(root)\\n        return self.msum\\n    \\n    def get_sum(self, node):\\n        if not node:\\n            return 0\\n        \\n        ls, rs = self.get_sum(node.left), self.get_sum(node.right)\\n        max_single_path = max(node.val+max(ls,rs), node.val)\\n        self.msum = max(self.msum, max_single_path , node.val+ls+rs)\\n        return max_single_path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39779,
                "title": "8-lines-c-similar-to-diameter-of-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int maxSum = INT_MIN;\\n        DFS(root, maxSum);\\n        return maxSum;\\n    }\\n    \\n    int DFS(TreeNode* root, int& maxSum){\\n        if(!root) return 0;\\n        int left = max(0, DFS(root->left, maxSum));\\n        int right = max(0, DFS(root->right, maxSum));\\n        maxSum = max(maxSum, left + right + root->val);\\n        return max(left, right) + root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int maxSum = INT_MIN;\\n        DFS(root, maxSum);\\n        return maxSum;\\n    }\\n    \\n    int DFS(TreeNode* root, int& maxSum){\\n        if(!root) return 0;\\n        int left = max(0, DFS(root->left, maxSum));\\n        int right = max(0, DFS(root->right, maxSum));\\n        maxSum = max(maxSum, left + right + root->val);\\n        return max(left, right) + root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040330,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\n// just returns the nodes in post-order\\npublic Iterable<TreeNode> topSort(TreeNode root) {\\n    Deque<TreeNode> result = new LinkedList<>();\\n    if (root != null) {\\n        Deque<TreeNode> stack = new LinkedList<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n            result.push(curr);\\n            if (curr.right != null) stack.push(curr.right);\\n            if (curr.left != null) stack.push(curr.left);\\n        }\\n    }\\n    return result;\\n}\\n\\npublic int maxPathSum(TreeNode root) {\\n    int result = Integer.MIN_VALUE;\\n    Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\\n    maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\\n    for (TreeNode node : topSort(root)) {\\n        // as we process nodes in post-order their children are already cached\\n        int left = Math.max(maxRootPath.get(node.left), 0);\\n        int right = Math.max(maxRootPath.get(node.right), 0); \\n        maxRootPath.put(node, Math.max(left, right) + node.val);\\n        result = Math.max(left + right + node.val, result);\\n    }\\n    return result;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nint maxSum(TreeNode* root, int& ans) {\\n    /* This function return the Branch Sum......\\n    So if the node is NULL then it won\\'t have a branch....so the branch sum will be 0.\\n    */\\n    //Base Case\\n    if(root == NULL){\\n        return 0;\\n    }\\n    \\n    //Recursive Case \\n    //BS = Branch Sum\\n    int leftBS = root->val + maxSum( root->left , ans );\\n    int rightBS = root->val + maxSum( root->right , ans );\\n    \\n    ans = max({\\n                ans,            //we may have found the maximum ans already\\n                root->val,      //may be the current root val is the maximum sum possible\\n                leftBS,         //may be the answer contain root->val + left branch value\\n                rightBS,        //may be the answer contain root->val + right branch value\\n                leftBS + rightBS - root->val   // may be ans conatin left branch + right branch + root->val\\n                                               // Since the root val is added twice from leftBS and rightBS so we are sunstracting it.\\n            });\\n    \\n    //Return the max branch Sum\\n    return max({ leftBS , rightBS , root->val });\\n}\\n\\nint maxPathSum(TreeNode* root) {\\n    int ans = INT_MIN;\\n    maxSum(root, ans);\\n    return ans;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = float(\\'-inf\\')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def traverse(root):\\n            if root:\\n                left = traverse(root.left)\\n                right = traverse(root.right)\\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\\n                return max(root.val,root.val + left,root.val + right)\\n            else:\\n                return 0\\n        traverse(root)\\n        return self.maxSum\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar maxPathSum = function(root) {\\n  var max = -Number.MAX_VALUE;\\n  getMaxSum(root);\\n  return max;\\n  function getMaxSum(node) {\\n    if (!node) return 0;\\n    var leftSum = getMaxSum(node.left);\\n    var rightSum = getMaxSum(node.right);\\n    max = Math.max(max, node.val + leftSum + rightSum);\\n    return Math.max(0, node.val + leftSum, node.val + rightSum);\\n  }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun maxPathSum(root: TreeNode?) = postorder(root).maxSum\\n\\n    private fun postorder(node: TreeNode?): Res {\\n        if (node == null)\\n            return Res(Int.MIN_VALUE, 0)\\n\\n        val (leftMaxSum, leftPathSum) = postorder(node.left)\\n        val (rightMaxSum, rightPathSum) = postorder(node.right)\\n\\n        val value = node.`val`\\n        val sum = leftPathSum + rightPathSum + value\\n\\n        return Res(maxOf(leftMaxSum, rightMaxSum, sum), maxOf(0, value + maxOf(leftPathSum, rightPathSum)))\\n    }\\n\\n    private data class Res(val maxSum: Int, val pathSum: Int)\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var currMaxSum = Int.min\\n        return max(maxPathSum(root, currMaxSum: &currMaxSum), currMaxSum)\\n    }\\n\\n    \\n    private func maxPathSum(_ currNode: TreeNode?, currMaxSum: inout Int) -> Int {\\n        guard let currNode = currNode else { return 0 }\\n\\n        let leftSum = max(maxPathSum(currNode.left, currMaxSum: &currMaxSum), 0)\\n        let rightSum = max(maxPathSum(currNode.right, currMaxSum: &currMaxSum), 0)\\n\\n        currMaxSum = max(currNode.val + leftSum + rightSum, currMaxSum)\\n        return max(leftSum, rightSum) + currNode.val\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\n// just returns the nodes in post-order\\npublic Iterable<TreeNode> topSort(TreeNode root) {\\n    Deque<TreeNode> result = new LinkedList<>();\\n    if (root != null) {\\n        Deque<TreeNode> stack = new LinkedList<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n            result.push(curr);\\n            if (curr.right != null) stack.push(curr.right);\\n            if (curr.left != null) stack.push(curr.left);\\n        }\\n    }\\n    return result;\\n}\\n\\npublic int maxPathSum(TreeNode root) {\\n    int result = Integer.MIN_VALUE;\\n    Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\\n    maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\\n    for (TreeNode node : topSort(root)) {\\n        // as we process nodes in post-order their children are already cached\\n        int left = Math.max(maxRootPath.get(node.left), 0);\\n        int right = Math.max(maxRootPath.get(node.right), 0); \\n        maxRootPath.put(node, Math.max(left, right) + node.val);\\n        result = Math.max(left + right + node.val, result);\\n    }\\n    return result;\\n}\\n```\n```\\n```\n```\\n```\n```\\nint maxSum(TreeNode* root, int& ans) {\\n    /* This function return the Branch Sum......\\n    So if the node is NULL then it won\\'t have a branch....so the branch sum will be 0.\\n    */\\n    //Base Case\\n    if(root == NULL){\\n        return 0;\\n    }\\n    \\n    //Recursive Case \\n    //BS = Branch Sum\\n    int leftBS = root->val + maxSum( root->left , ans );\\n    int rightBS = root->val + maxSum( root->right , ans );\\n    \\n    ans = max({\\n                ans,            //we may have found the maximum ans already\\n                root->val,      //may be the current root val is the maximum sum possible\\n                leftBS,         //may be the answer contain root->val + left branch value\\n                rightBS,        //may be the answer contain root->val + right branch value\\n                leftBS + rightBS - root->val   // may be ans conatin left branch + right branch + root->val\\n                                               // Since the root val is added twice from leftBS and rightBS so we are sunstracting it.\\n            });\\n    \\n    //Return the max branch Sum\\n    return max({ leftBS , rightBS , root->val });\\n}\\n\\nint maxPathSum(TreeNode* root) {\\n    int ans = INT_MIN;\\n    maxSum(root, ans);\\n    return ans;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = float(\\'-inf\\')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def traverse(root):\\n            if root:\\n                left = traverse(root.left)\\n                right = traverse(root.right)\\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\\n                return max(root.val,root.val + left,root.val + right)\\n            else:\\n                return 0\\n        traverse(root)\\n        return self.maxSum\\n```\n```\\n```\n```\\n```\n```\\nvar maxPathSum = function(root) {\\n  var max = -Number.MAX_VALUE;\\n  getMaxSum(root);\\n  return max;\\n  function getMaxSum(node) {\\n    if (!node) return 0;\\n    var leftSum = getMaxSum(node.left);\\n    var rightSum = getMaxSum(node.right);\\n    max = Math.max(max, node.val + leftSum + rightSum);\\n    return Math.max(0, node.val + leftSum, node.val + rightSum);\\n  }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun maxPathSum(root: TreeNode?) = postorder(root).maxSum\\n\\n    private fun postorder(node: TreeNode?): Res {\\n        if (node == null)\\n            return Res(Int.MIN_VALUE, 0)\\n\\n        val (leftMaxSum, leftPathSum) = postorder(node.left)\\n        val (rightMaxSum, rightPathSum) = postorder(node.right)\\n\\n        val value = node.`val`\\n        val sum = leftPathSum + rightPathSum + value\\n\\n        return Res(maxOf(leftMaxSum, rightMaxSum, sum), maxOf(0, value + maxOf(leftPathSum, rightPathSum)))\\n    }\\n\\n    private data class Res(val maxSum: Int, val pathSum: Int)\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var currMaxSum = Int.min\\n        return max(maxPathSum(root, currMaxSum: &currMaxSum), currMaxSum)\\n    }\\n\\n    \\n    private func maxPathSum(_ currNode: TreeNode?, currMaxSum: inout Int) -> Int {\\n        guard let currNode = currNode else { return 0 }\\n\\n        let leftSum = max(maxPathSum(currNode.left, currMaxSum: &currMaxSum), 0)\\n        let rightSum = max(maxPathSum(currNode.right, currMaxSum: &currMaxSum), 0)\\n\\n        currMaxSum = max(currNode.val + leftSum + rightSum, currMaxSum)\\n        return max(leftSum, rightSum) + currNode.val\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329033,
                "title": "python-bottom-up-dfs-solution",
                "content": "Please see and vote for my solutions for these similar problems.\\n[250. Count Univalue Subtrees](https://leetcode.com/problems/count-univalue-subtrees/discuss/329039/Python-bottom-up-DFS-solution)\\n[508. Most Frequent Subtree Sum](https://leetcode.com/problems/most-frequent-subtree-sum/discuss/329045/Python-bottom-up-DFS)\\n[543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/discuss/329022/Python-DFS-solution%3A-return-values-and-update-global-result-from-bottom-to-top)\\n[1245. Tree Diameter](https://leetcode.com/problems/tree-diameter/discuss/418906/Python-bottom-up-DFS-solution-(similar-problems-listed))\\n[687. Longest Univalue Path](https://leetcode.com/problems/longest-univalue-path/discuss/329031/Python-bottom-up-DFS-solution)\\n[124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/329033/Python-bottom-up-DFS-solution)\\n[Max Path Sum in a Grid](https://leetcode.com/discuss/interview-question/391278/google-phone-screen-maximal-path-sum/351744)\\n[298. Binary Tree Longest Consecutive Sequence](https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/discuss/389208/Python-bottom-up-DFS-solution)\\n[549. Binary Tree Longest Consecutive Sequence II](https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/discuss/389210/Python-bottom-up-DFS-solution-(56-ms-beat-93.37))\\n\\nA path may or may not pass through the root.\\nAll paths = {all paths passing through a node and its desendants | for each node in tree}.\\nBottom-up DFS: from bottom to top,\\nfind the maximum-sum path passing through a node and its desendants,\\nupdate the global maximum sum.\\n```\\n    def maxPathSum(self, root):\\n        def maxSum(root):\\n            if not root:\\n                return 0\\n            l_sum = maxSum(root.left)\\n            r_sum = maxSum(root.right)\\n            l = max(0, l_sum)\\n            r = max(0, r_sum)\\n            res[0] = max(res[0], root.val + l + r)\\n            return root.val + max(l, r)\\n        \\n        res = [-float(\\'inf\\')]\\n        maxSum(root)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxPathSum(self, root):\\n        def maxSum(root):\\n            if not root:\\n                return 0\\n            l_sum = maxSum(root.left)\\n            r_sum = maxSum(root.right)\\n            l = max(0, l_sum)\\n            r = max(0, r_sum)\\n            res[0] = max(res[0], root.val + l + r)\\n            return root.val + max(l, r)\\n        \\n        res = [-float(\\'inf\\')]\\n        maxSum(root)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 278525,
                "title": "python-iterative-solution",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    \\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        res = float(\\'-inf\\')\\n        stack, last, d = [], None, defaultdict(int)\\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            node = stack[-1]        \\n            if node.right and last != node.right:\\n                root = node.right\\n            else:\\n                # Consume the node\\n                node = stack.pop()\\n                last = node\\n                d[node] = max(max(d[node.left], d[node.right]) + node.val, 0)\\n                res = max(res, d[node.left] + d[node.right] + node.val)\\n                \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    \\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        res = float(\\'-inf\\')\\n        stack, last, d = [], None, defaultdict(int)\\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            node = stack[-1]        \\n            if node.right and last != node.right:\\n                root = node.right\\n            else:\\n                # Consume the node\\n                node = stack.pop()\\n                last = node\\n                d[node] = max(max(d[node.left], d[node.right]) + node.val, 0)\\n                res = max(res, d[node.left] + d[node.right] + node.val)\\n                \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 602827,
                "title": "python-recursive-clean-beat-99",
                "content": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.max = float(\\'-inf\\')\\n        def get_sum(root):\\n            if root is None:\\n                return 0\\n            else:\\n                ls = max(get_sum(root.left), 0)\\n                rs = max(get_sum(root.right), 0)\\n                self.max = max(self.max, ls + rs + root.val)\\n                return max(ls, rs, 0) + root.val\\n        \\n        get_sum(root)\\n        return self.max",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.max = float(\\'-inf\\')\\n        def get_sum(root):\\n            if root is None:\\n                return 0\\n            else:\\n                ls = max(get_sum(root.left), 0)\\n                rs = max(get_sum(root.right), 0)\\n                self.max = max(self.max, ls + rs + root.val)\\n                return max(ls, rs, 0) + root.val\\n        \\n        get_sum(root)\\n        return self.max",
                "codeTag": "Java"
            },
            {
                "id": 39933,
                "title": "accepted-o-n-solution",
                "content": "The idea is based on the solution of max sum of a sequence array, Here is the explaination of the code:\\n\\n - Have a recursive method which traverse the binary tree, it also\\n   return the max possible sum of left branch and right branch\\n   saperately. for example, For node A, when it's left and right node\\n   recusive call returned, we will know the max possible sum of left\\n   branch, right branch.\\n   \\n - Have a CheckMax function which will compare the sequence sum and\\n   record the max history. For node A, check whether left branch + this \\n   node + right branch is the maximum, check whether left branch + this \\n   node is max\\uff0c check whether right branch + this node is max.\\n - When recursive method return, we should only return the max sum of one path - either the left branch + this node, or the right branch +\\n   this node. So that this is still a single path and can be used to\\n   link by node A's parent node.\\n\\nIt's accepted by OL. Let me know if you have any question\\n\\n    class Solution {\\n        public:\\n            int maxPathSum(TreeNode *root) {\\n                if(!root) return 0;\\n                maxSum = root->val;\\n                recNodes(root); \\n                return maxSum;\\n            }\\n        \\n        protected:\\n            int recNodes(TreeNode* node)\\n            {\\n                int numl=0,numr=0;\\n                if (node->left)\\n                    numl = recNodes(node->left);\\n                if (node->right)\\n                    numr = recNodes(node->right);\\n        \\n                //choose the max path, either left or right \\n                int value = node->val;\\n                int sumWhole = checkMax(value,numl+numr);\\n                int sumLeft = numl>0?checkMax(value,numl):value;\\n                int sumRight = numr>0?checkMax(value,numr):value;\\n        \\n                return max(sumLeft,sumRight);\\n            }\\n        \\n            int checkMax(int value, int sum)\\n            {\\n                if(sum>0)\\n                    sum+=value;\\n                else\\n                    sum=value;\\n                if(sum>maxSum)\\n                    maxSum = sum;\\n                return sum;\\n            }\\n        \\n            int maxSum;\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int maxPathSum(TreeNode *root) {\\n                if(!root) return 0;\\n                maxSum = root->val;\\n                recNodes(root); \\n                return maxSum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 39871,
                "title": "sharing-a-simple-java-solution",
                "content": "\\n    int max = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n    \\n    public int helper(TreeNode root) {\\n        if(root == null)\\n            return Integer.MIN_VALUE;\\n        int left = Math.max(0, helper(root.left));\\n        int right = Math.max(0, helper(root.right));\\n        max = Math.max(max, root.val + left + right);\\n        return root.val + Math.max(left, right);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    int max = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n    \\n    public int helper(TreeNode root) {\\n        if(root == null)\\n            return Integer.MIN_VALUE;\\n        int left = Math.max(0, helper(root.left));\\n        int right = Math.max(0, helper(root.right));\\n        max = Math.max(max, root.val + left + right);\\n        return root.val + Math.max(left, right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39926,
                "title": "12-line-o-n-javascript-solution-with-176-ms-execution-time",
                "content": "    var maxPathSum = function(root) {\\n      var max = -Number.MAX_VALUE;\\n      getMaxSum(root);\\n      return max;\\n      function getMaxSum(node) {\\n        if (!node) return 0;\\n        var leftSum = getMaxSum(node.left);\\n        var rightSum = getMaxSum(node.right);\\n        max = Math.max(max, node.val + leftSum + rightSum);\\n        return Math.max(0, node.val + leftSum, node.val + rightSum);\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var maxPathSum = function(root) {\\n      var max = -Number.MAX_VALUE;\\n      getMaxSum(root);\\n      return max;\\n      function getMaxSum(node) {\\n        if (!node) return 0;\\n        var leftSum = getMaxSum(node.left);\\n        var rightSum = getMaxSum(node.right);\\n        max = Math.max(max, node.val + leftSum + rightSum);\\n        return Math.max(0, node.val + leftSum, node.val + rightSum);\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1242055,
                "title": "swift-binary-tree-maximum-path-sum-test-cases",
                "content": "```swift\\nclass Solution {\\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        var maxSum = Int.min\\n        dfs(root, &maxSum)\\n        return maxSum\\n    }\\n    private func dfs(_ root: TreeNode?, _ maxSum: inout Int) -> Int {\\n        guard let root = root else { return 0 }\\n        let left = max(dfs(root.left, &maxSum), 0)\\n        let right = max(dfs(root.right, &maxSum), 0)\\n        maxSum = max(maxSum, (root.val + left + right))\\n        return root.val + max(left, right)\\n    }\\n}\\n```\\n<hr>\\n\\n##### Test Cases\\n\\n```swift\\nimport XCTest\\n\\n//      Executed 2 tests, with 0 failures (0 unexpected) in 0.387 (0.389) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let tree = TreeNode([1,2,3])\\n        XCTAssertEqual(s.maxPathSum(tree), 6)\\n    }\\n    func test2() {\\n        let tree = TreeNode([-10,9,20,nil,nil,15,7])\\n        XCTAssertEqual(s.maxPathSum(tree), 42)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n<hr>\\n\\n##### TreeNode class\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    \\n    // Additional initializer\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        var maxSum = Int.min\\n        dfs(root, &maxSum)\\n        return maxSum\\n    }\\n    private func dfs(_ root: TreeNode?, _ maxSum: inout Int) -> Int {\\n        guard let root = root else { return 0 }\\n        let left = max(dfs(root.left, &maxSum), 0)\\n        let right = max(dfs(root.right, &maxSum), 0)\\n        maxSum = max(maxSum, (root.val + left + right))\\n        return root.val + max(left, right)\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n//      Executed 2 tests, with 0 failures (0 unexpected) in 0.387 (0.389) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let tree = TreeNode([1,2,3])\\n        XCTAssertEqual(s.maxPathSum(tree), 6)\\n    }\\n    func test2() {\\n        let tree = TreeNode([-10,9,20,nil,nil,15,7])\\n        XCTAssertEqual(s.maxPathSum(tree), 42)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    \\n    // Additional initializer\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271697,
                "title": "java-1ms-solution-with-highly-detailed-explanation",
                "content": "Intuitively, we can use recursive method to solve the problem. In order to get the max path sum, we must consider every node in the tree. \\nThe final path must consist of three parts: one node as root (necessary), an **Up To Down Path** originated from its left child (optional)  and an **Up To Down Path** originated from its right child (optional). Here, the **Up to Down Path denotes a sub path originated from a node to its leaf.**\\nWe use ```leftMax``` to denote the max up to down path sum originated from the left child of a node and ```rightMax``` to denote the max up to down path sum originated from the right child of a node. Then the **max path sum** of a node ```n``` is ```n.val + Math.max(leftMax, 0) + Math.max(rightMax, 0)```. Apparently, if ```leftMax``` or ```rightMax``` is no greater than zero, then we don\\'t need them and that\\'s why they are optional. \\nAfter processing a node, we return its **max up to down path sum (not max path sum)**, i.e., ```n.val + Math.max(Math.max(leftMax, 0), Math.max(rightMax, 0))```. \\nAs we can see, the key point of this problem is processing current node to get **max path sum** while returning **max up to down path sum** after processing the node. It is an important idea for solving complex tree problems: processing a problem and return the result of another problem.\\n```\\nint result = Integer.MIN_VALUE;\\n    \\npublic int maxSum(TreeNode root) {\\n\\tif( root == null )\\n\\t\\treturn 0;\\n\\tint leftMax = Math.max(0, maxSum(root.left));\\n\\tint rightMax = Math.max(0, maxSum(root.right));\\n\\tresult = Math.max(result, root.val + leftMax + rightMax);\\n\\treturn root.val + Math.max(leftMax, rightMax);\\n}\\n\\npublic int maxPathSum(TreeNode root) {\\n\\tif( root == null )\\n\\t\\treturn 0;\\n\\telse {\\n\\t\\tmaxSum(root);\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```leftMax```\n```rightMax```\n```n```\n```n.val + Math.max(leftMax, 0) + Math.max(rightMax, 0)```\n```leftMax```\n```rightMax```\n```n.val + Math.max(Math.max(leftMax, 0), Math.max(rightMax, 0))```\n```\\nint result = Integer.MIN_VALUE;\\n    \\npublic int maxSum(TreeNode root) {\\n\\tif( root == null )\\n\\t\\treturn 0;\\n\\tint leftMax = Math.max(0, maxSum(root.left));\\n\\tint rightMax = Math.max(0, maxSum(root.right));\\n\\tresult = Math.max(result, root.val + leftMax + rightMax);\\n\\treturn root.val + Math.max(leftMax, rightMax);\\n}\\n\\npublic int maxPathSum(TreeNode root) {\\n\\tif( root == null )\\n\\t\\treturn 0;\\n\\telse {\\n\\t\\tmaxSum(root);\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39913,
                "title": "clean-c-solution",
                "content": "    class Solution {\\n        int res;\\n    public:\\n        int depth(TreeNode *root){\\n            if(root==NULL) return 0;\\n            int a=depth(root->left), b=depth(root->right);\\n            res=max(res,a+b+root->val);//if *root is the top node in the path\\n            return max(0,max(a, b)+root->val);//if *root is in the path, if this branch a burden or a plus\\n        }\\n        int maxPathSum(TreeNode *root) {\\n            if(root==NULL) return 0;\\n            res=root->val;\\n            depth(root);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        int res;\\n    public:\\n        int depth(TreeNode *root){\\n            if(root==NULL) return 0;\\n            int a=depth(root->left), b=depth(root->right);\\n            res=max(res,a+b+root->val);//if *root is the top node in the path\\n            return max(0,max(a, b)+root->val);//if *root is in the path, if this branch a burden or a plus\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1481368,
                "title": "java-dfs-explained-faster-than-100-ttt",
                "content": "**This problem needs a bit of thinking**\\nThe key to solving this problem is to break the problem into 2 smaller and simpler sub-parts\\n\\nWe are asked to find out the path with the largest sum. **So, two cases can arise**\\n1. **Case 1** : the present node is included in the largest sum path. If so, it is obvious that the largest sum path will either pass through the left subtree or the right subtree or it might terminate here. *If the larget sum path has to terminate at the current node then it must not include any subtree contribution. Here, it is imp to understand that if the subtrees have a negative contribution then we MUST not add it to our path because if we add anyhting negative, the final value will be even lesser. *\\nExample: If the root val is -2 and the left subtree can generate a max sum of -1 and the right tree can generate -7. If we add either of these values the ultimate result will be lesser that -2. Hence, we WILL ADD ONLY POSITIVE VALUES \\n\\n2. **Case 2 :** the present node need not be included in the path to get the greatest path sum. So, we need to update the max result at every dfs call and we wil see how in the code\\n\\nNow, that we have segmented the question, let\\'s see the code\\n```\\nclass Solution {\\n    int res = Integer.MIN_VALUE; \\n    //this variable will be used to store the result after each possible path and hence will finally store the max  path sum\\n    public int maxPathSum(TreeNode root) {\\n        if(root == null)return res;\\n        dfs(root);      //this will update the value or res as required\\n        return res;\\n    }\\n    public int dfs(TreeNode root){\\n        if(root == null)return 0;   //base case and very imp\\n        \\n        //at any node we want to find the left and right side max Sum\\n        int left = Math.max(dfs(root.left), 0);\\n        int right = Math.max(dfs(root.right), 0);\\n        // we are finding the max with 0 as we do not want to include any subtree with negative contributiuon. See explaination above\\n        \\n\\t\\t\\n\\t\\t//left here is storing the max possible contribution of the left subtree \\n\\t\\t//right here is storing the max possible contribution of right subtree\\n\\t\\t//if either of left and rigth have a possitive contribution(value), the larger will finally be taken \\n\\t\\t\\n\\t\\t//but first we will have to assume that the subtree with root node as root(the variable in this function) will have the largest sum path, so we will inlude this in our res if it has a value larger than previous res\\n        res = Math.max(res, root.val+left + right);\\n\\t\\t\\n\\t\\t\\n\\t\\t//the function however is expected to return the contribution of the current subtree if the subtree was include as in case 1 explained above. It it was terminating here, left and right would have value 0\\n\\t\\t//so we simply return the sum of the root val and the larger between left and rigth subtree sum\\n        return root.val + Math.max(left, right);\\n    \\n    }\\n} //do upvote if this helps\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int res = Integer.MIN_VALUE; \\n    //this variable will be used to store the result after each possible path and hence will finally store the max  path sum\\n    public int maxPathSum(TreeNode root) {\\n        if(root == null)return res;\\n        dfs(root);      //this will update the value or res as required\\n        return res;\\n    }\\n    public int dfs(TreeNode root){\\n        if(root == null)return 0;   //base case and very imp\\n        \\n        //at any node we want to find the left and right side max Sum\\n        int left = Math.max(dfs(root.left), 0);\\n        int right = Math.max(dfs(root.right), 0);\\n        // we are finding the max with 0 as we do not want to include any subtree with negative contributiuon. See explaination above\\n        \\n\\t\\t\\n\\t\\t//left here is storing the max possible contribution of the left subtree \\n\\t\\t//right here is storing the max possible contribution of right subtree\\n\\t\\t//if either of left and rigth have a possitive contribution(value), the larger will finally be taken \\n\\t\\t\\n\\t\\t//but first we will have to assume that the subtree with root node as root(the variable in this function) will have the largest sum path, so we will inlude this in our res if it has a value larger than previous res\\n        res = Math.max(res, root.val+left + right);\\n\\t\\t\\n\\t\\t\\n\\t\\t//the function however is expected to return the contribution of the current subtree if the subtree was include as in case 1 explained above. It it was terminating here, left and right would have value 0\\n\\t\\t//so we simply return the sum of the root val and the larger between left and rigth subtree sum\\n        return root.val + Math.max(left, right);\\n    \\n    }\\n} //do upvote if this helps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39885,
                "title": "c-very-concise-recursive-solution",
                "content": "    int maxSum;\\n    int maxPathSum(TreeNode* root) {\\n        maxSum = INT_MIN;\\n        dfs(root);\\n        return maxSum;\\n    }\\n    // post order\\n    int dfs(TreeNode *root) {\\n        if (!root) return 0;\\n         int l = dfs(root->left);\\n         int r = dfs(root->right);\\n         maxSum = max(maxSum, root->val + (l > 0 ? l : 0) + (r > 0 ? r : 0));\\n         return (max(l, r) > 0 ? max(l, r) : 0) + root->val;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    int maxSum;\\n    int maxPathSum(TreeNode* root) {\\n        maxSum = INT_MIN;\\n        dfs(root);\\n        return maxSum;\\n    }\\n    // post order\\n    int dfs(TreeNode *root) {\\n        if (!root) return 0;\\n         int l = dfs(root->left);\\n         int r = dfs(root->right);\\n         maxSum = max(maxSum, root->val + (l > 0 ? l : 0) + (r > 0 ? r : 0));\\n         return (max(l, r) > 0 ? max(l, r) : 0) + root->val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39888,
                "title": "a-recursive-solution-with-comment",
                "content": "        \\n        // global max\\n        int max = Integer.MIN_VALUE;\\n\\n        public int maxPathSum(TreeNode root) {\\n            dfs(root);\\n            return max;\\n        }\\n        \\n        private int dfs(TreeNode root) {\\n            if (root == null) return 0;\\n            // 2 possible choices\\n            // 1.Already calculated in left or right child\\n            // 2.left max path + right max path + root\\n            int lMax = dfs(root.left);\\n            int rMax = dfs(root.right);\\n            if (lMax + rMax + root.val > max) max = lMax + rMax + root.val;\\n            // if the below path is negative, just make it 0 so that we could 'ignore' it\\n            return Math.max(0, root.val + Math.max(lMax, rMax));\\n        }",
                "solutionTags": [],
                "code": "        \\n        // global max\\n        int max = Integer.MIN_VALUE;\\n\\n        public int maxPathSum(TreeNode root) {\\n            dfs(root);\\n            return max;\\n        }\\n        \\n        private int dfs(TreeNode root) {\\n            if (root == null) return 0;\\n            // 2 possible choices\\n            // 1.Already calculated in left or right child\\n            // 2.left max path + right max path + root\\n            int lMax = dfs(root.left);\\n            int rMax = dfs(root.right);\\n            if (lMax + rMax + root.val > max) max = lMax + rMax + root.val;\\n            // if the below path is negative, just make it 0 so that we could 'ignore' it\\n            return Math.max(0, root.val + Math.max(lMax, rMax));\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1935332,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var currMaxSum = Int.min\\n        return max(maxPathSum(root, currMaxSum: &currMaxSum), currMaxSum)\\n    }\\n\\n    \\n    private func maxPathSum(_ currNode: TreeNode?, currMaxSum: inout Int) -> Int {\\n        guard let currNode = currNode else { return 0 }\\n\\n        let leftSum = max(maxPathSum(currNode.left, currMaxSum: &currMaxSum), 0)\\n        let rightSum = max(maxPathSum(currNode.right, currMaxSum: &currMaxSum), 0)\\n\\n        currMaxSum = max(currNode.val + leftSum + rightSum, currMaxSum)\\n        return max(leftSum, rightSum) + currNode.val\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var currMaxSum = Int.min\\n        return max(maxPathSum(root, currMaxSum: &currMaxSum), currMaxSum)\\n    }\\n\\n    \\n    private func maxPathSum(_ currNode: TreeNode?, currMaxSum: inout Int) -> Int {\\n        guard let currNode = currNode else { return 0 }\\n\\n        let leftSum = max(maxPathSum(currNode.left, currMaxSum: &currMaxSum), 0)\\n        let rightSum = max(maxPathSum(currNode.right, currMaxSum: &currMaxSum), 0)\\n\\n        currMaxSum = max(currNode.val + leftSum + rightSum, currMaxSum)\\n        return max(leftSum, rightSum) + currNode.val\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167952,
                "title": "clean-python-solution-o-n",
                "content": "Bottom up divider and conquer\\nAt each rode, it can form 3 tyes of path. \\n1st is node \\n2nd is left - node - right\\n3rd is left/right - node\\nOnce we get the max after comparsion, we return 1st or 3rd path sum to the upper level.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nclass Solution:\\n    res = -float(\\'inf\\')\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        self.helper(root)\\n        return self.res\\n    \\n    def helper(self, root):\\n        if root == None:\\n            return 0\\n        leftMax = self.helper(root.left)\\n        rightMax = self.helper(root.right)\\n        tempPath = root.val + leftMax + rightMax\\n        sum = root.val + max(leftMax, rightMax, 0)\\n        self.res = max(sum, tempPath, self.res)\\n        return sum\\n",
                "solutionTags": [],
                "code": "Bottom up divider and conquer\\nAt each rode, it can form 3 tyes of path. \\n1st is node \\n2nd is left - node - right\\n3rd is left/right - node\\nOnce we get the max after comparsion, we return 1st or 3rd path sum to the upper level.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nclass Solution:\\n    res = -float(\\'inf\\')\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        self.helper(root)\\n        return self.res\\n    \\n    def helper(self, root):\\n        if root == None:\\n            return 0\\n        leftMax = self.helper(root.left)\\n        rightMax = self.helper(root.right)\\n        tempPath = root.val + leftMax + rightMax\\n        sum = root.val + max(leftMax, rightMax, 0)\\n        self.res = max(sum, tempPath, self.res)\\n        return sum\\n",
                "codeTag": "Java"
            },
            {
                "id": 39810,
                "title": "12-lines-of-python-code-fast-and-easy-to-understand",
                "content": "    class Solution(object):\\n        def maxPathSum(self, root):\\n            def dfs(node):  # returns: max one side path sum, max path sum\\n                l = r = 0\\n                ls = rs = None\\n                if node.left:\\n                    l, ls = dfs(node.left)\\n                    l = max(l, 0)\\n                if node.right:\\n                    r, rs = dfs(node.right)\\n                    r = max(r, 0)\\n                return node.val + max(l, r), max(node.val + l + r, ls, rs)\\n            if root:\\n                return dfs(root)[1]\\n            return 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def maxPathSum(self, root):\\n            def dfs(node):  # returns: max one side path sum, max path sum\\n                l = r = 0\\n                ls = rs = None\\n                if node.left:\\n                    l, ls = dfs(node.left)\\n                    l = max(l, 0)\\n                if node.right:\\n                    r, rs = dfs(node.right)\\n                    r = max(r, 0)\\n                return node.val + max(l, r), max(node.val + l + r, ls, rs)\\n            if root:\\n                return dfs(root)[1]\\n            return 0",
                "codeTag": "Java"
            },
            {
                "id": 2899997,
                "title": "c-dfs-subtree-sum-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int subTreesum(TreeNode* root,int& mx)\\n    {\\n        if(root==NULL) return 0;\\n\\n        // we are using max function over here because as we know node can be negative , and we also know that when we take negatuve nodes\\n        // then they will reduce our path cost but we need to maximize it as much as possible\\n        // so whenever we got negative node then just take 0 instead of negative value\\n        int l = max(0,subTreesum(root->left,mx));\\n        int r = max(0,subTreesum(root->right,mx));\\n\\n        int curr = root->val+l+r;                             // curr node + left node + right node (path sum for curr node)\\n        cout<<curr<<\" \";\\n\\n        mx = max(mx,curr);                                    // took max out of all\\n\\n        return root->val+max(l,r);                            // max(l,r) means we will chose one path that will gave max path sum to us\\n    }\\n    int maxPathSum(TreeNode* root) \\n    {\\n        int mx = INT_MIN;\\n        subTreesum(root,mx);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subTreesum(TreeNode* root,int& mx)\\n    {\\n        if(root==NULL) return 0;\\n\\n        // we are using max function over here because as we know node can be negative , and we also know that when we take negatuve nodes\\n        // then they will reduce our path cost but we need to maximize it as much as possible\\n        // so whenever we got negative node then just take 0 instead of negative value\\n        int l = max(0,subTreesum(root->left,mx));\\n        int r = max(0,subTreesum(root->right,mx));\\n\\n        int curr = root->val+l+r;                             // curr node + left node + right node (path sum for curr node)\\n        cout<<curr<<\" \";\\n\\n        mx = max(mx,curr);                                    // took max out of all\\n\\n        return root->val+max(l,r);                            // max(l,r) means we will chose one path that will gave max path sum to us\\n    }\\n    int maxPathSum(TreeNode* root) \\n    {\\n        int mx = INT_MIN;\\n        subTreesum(root,mx);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2632175,
                "title": "100-fastest-solution-with-explain-best-approach-easy-to-understand",
                "content": "**Read the below approach with dry run to understand the logic.**\\n\\n***Please upvote if you like it!!!!***\\n\\n**Approach:** \\n* A brute force approach would be to generate all paths and compare them. Generating all paths will be a time-costly activity therefore we need to look for something else.\\n\\n* We first need to define what is the maximum path sum through a given node (when that node is acting as the root node/curving point). At a given node with a value, if we find the max leftSumPath in the left-subtree and the max rightSumPath in the right subtree, then the maxPathSum through that node is value+(leftSumPath+rightSumPath).\\n\\n![image](https://assets.leetcode.com/users/images/8908909f-7acc-47b8-a570-2d6228fbd324_1664308086.3526118.png)\\n\\n* Now we can apply this formula at every node by doing a simple tree traversal and storing the maximum value (our answer) in a reference variable.\\n\\n* For our recursion to work, it is very important to understand what value we return from our function. In our recursive function, we find and compare the maxPathSum from a given node when it is the root/turning point of the path. But what we return is the maxPathSum of that same node when it is NOT the root/turning point of the path. To find the latter maxPath, we no longer have the liberty to consider both leftMaxPath and rightMaxPath, we will simply take the maximum of the two and it to the value of the node.\\n\\n![image](https://assets.leetcode.com/users/images/b1e861d5-d848-4f93-81d6-98aa8d162c6a_1664308132.2479436.png)\\n\\n**To summarize:**\\n\\n* Initialize a maxi variable to store our final answer.\\n* Do a simple tree traversal. At each node, find  recursively its leftMaxPath and its rightMaxPath.\\n* Calculate the maxPath through the node as val + (leftMaxPath + rightMaxPath) and update maxi accordingly.\\n* Return the maxPath when node is not the curving point as val + max(leftMaxPath, rightMaxPath).\\n\\n**Paper dry run:**\\n\\n![image](https://assets.leetcode.com/users/images/353e17b5-20b5-47f9-a434-ad2e83a01d7e_1664308186.004981.jpeg)\\n\\n**~Time Complexity: O(N).**\\n* **Reason:** We are doing a tree traversal.\\n\\n**~Space Complexity: O(N)**\\n* **Reason:** Space is needed for the recursion stack. In the worst case (skewed tree), space complexity can be O(N).\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int& mx){\\n        if(!root) return 0;\\n        \\n        int left=max(0,solve(root->left,mx));\\n        int right=max(0,solve(root->right,mx));\\n        int currVal=root->val;\\n        \\n        mx=max(mx,left+right+currVal);\\n        return max(left,right)+currVal;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int mx=INT_MIN;\\n        solve(root,mx);\\n        return mx;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int& mx){\\n        if(!root) return 0;\\n        \\n        int left=max(0,solve(root->left,mx));\\n        int right=max(0,solve(root->right,mx));\\n        int currVal=root->val;\\n        \\n        mx=max(mx,left+right+currVal);\\n        return max(left,right)+currVal;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int mx=INT_MIN;\\n        solve(root,mx);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295418,
                "title": "java-solution-with-explanation",
                "content": "**Idea**\\nThe main part of the logic is same as https://leetcode.com/problems/maximum-subarray/description/\\nThree key points here. \\n1. Since the path doesn\\'t need to go through the root node, we need to try all nodes.\\n2. At the current node, let us say you have maxPathSum **from** the left node and maxPathSum **from** the right node, we can easily check what is the `max` so far. It should be either of those or the path connecting both.\\n3. We should return \"max path sum ending here\" to the caller, this will be either extending the path on left or right or just returning `curr` node.\\n\\nFurther explanation https://leetcode.com/problems/longest-univalue-path/discuss/130315/Java-Solution-With-Explanation\\n\\n---\\n\\n```\\nclass Solution {\\n    int max = -Integer.MAX_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n    private Integer helper(TreeNode curr){\\n        if(curr == null) return null;\\n        Integer l = helper(curr.left), r = helper(curr.right);\\n        int maxEndingHere = curr.val;\\n        if(l != null && r != null){\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+l);\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+r);\\n            max = Math.max(max, l+r+curr.val);\\n        }else if(l != null)\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+l);\\n        else if(r != null)\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+r);\\n        max = Math.max(max, maxEndingHere);\\n        return maxEndingHere;\\n    }\\n}\\n```\\n\\nShorter version of the same idea\\n```\\nclass Solution {\\n    int maxSumSoFar = -1001;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxSumSoFar;\\n    }\\n    \\n    private int helper(TreeNode curr){\\n        if(curr == null) return -1001;\\n        int l = helper(curr.left);\\n        int maxEndHere = Math.max(l+curr.val, curr.val);\\n        maxSumSoFar = Math.max(maxSumSoFar, maxEndHere);\\n        int r = helper(curr.right);\\n        maxEndHere = Math.max(r+curr.val, maxEndHere);\\n        maxSumSoFar = Math.max(maxSumSoFar, maxEndHere);\\n        maxSumSoFar = Math.max(maxSumSoFar, l+r+curr.val);\\n        \\n        return maxEndHere;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = -Integer.MAX_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n    private Integer helper(TreeNode curr){\\n        if(curr == null) return null;\\n        Integer l = helper(curr.left), r = helper(curr.right);\\n        int maxEndingHere = curr.val;\\n        if(l != null && r != null){\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+l);\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+r);\\n            max = Math.max(max, l+r+curr.val);\\n        }else if(l != null)\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+l);\\n        else if(r != null)\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+r);\\n        max = Math.max(max, maxEndingHere);\\n        return maxEndingHere;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int maxSumSoFar = -1001;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxSumSoFar;\\n    }\\n    \\n    private int helper(TreeNode curr){\\n        if(curr == null) return -1001;\\n        int l = helper(curr.left);\\n        int maxEndHere = Math.max(l+curr.val, curr.val);\\n        maxSumSoFar = Math.max(maxSumSoFar, maxEndHere);\\n        int r = helper(curr.right);\\n        maxEndHere = Math.max(r+curr.val, maxEndHere);\\n        maxSumSoFar = Math.max(maxSumSoFar, maxEndHere);\\n        maxSumSoFar = Math.max(maxSumSoFar, l+r+curr.val);\\n        \\n        return maxEndHere;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39943,
                "title": "java-accepted-solution-with-post-order-traversal",
                "content": "Short Java solution involving a postorder visit of the tree. Complexity is O(n).\\n\\n\\n    public class Solution {\\n        \\n        int max;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            \\n            if(root==null) return 0;\\n            \\n            //still check the result of the \"root subtree\"\\n            max = root.val;\\n            int tmp = visit(root);\\n            if(tmp > max) max = tmp;\\n            \\n            return max;\\n            \\n        }\\n        \\n        //recursive visit\\n        private int visit(TreeNode current){\\n        \\n            if(current==null) return 0;\\n        \\n            int l = visit(current.left);\\n            int r = visit(current.right);\\n            \\n            if(l<0) l=0;\\n            if(r<0) r=0;\\n            \\n            //check if current subtree is better than max\\n            int tmp = l+r+current.val;\\n            if(tmp>max) max = tmp;\\n            \\n            //return the best of the two ways to go down\\n            //if coming from top, cannot go both left and right\\n            //same if we come from down and want to go up, cannot go down again through other child\\n            if(l>r) {return l+current.val;}\\n            else {return r+current.val;}\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        \\n        int max;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            \\n            if(root==null) return 0;\\n            \\n            //still check the result of the \"root subtree\"\\n            max = root.val;\\n            int tmp = visit(root);\\n            if(tmp > max) max = tmp;\\n            \\n            return max;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2899158,
                "title": "python-c-compute-left-right-partial-sums-with-dfs-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Depth First Search* approach to traverse the tree in order to compute left and right partial path sums for each node. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Python.**\\n```\\nclass Solution:\\n    def maxPathSum(self, root, s = -inf) -> int:\\n        \\n        def dfs(n):                    # this recursive function \\n            nonlocal s                 # computes best partial path\\n            if not n : return 0        # sum starting from node \\'n\\':\\n            l = max(0, dfs(n.left))    # [1] compute left and right\\n            r = max(0, dfs(n.right))   #     partial path sums\\n            s = max(s, l + r + n.val)  # [2] compute full path sum\\n            return n.val + max(l, r)   # [3] choose best partial sum\\n\\n        dfs(root)\\n        return s\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    int maxPathSum(TreeNode* root, int s = INT_MIN) \\n    {\\n        function<int(TreeNode*)> dfs;\\n        dfs = [&](TreeNode* n) -> int\\n        {\\n            if (!n) return 0;\\n            int l = max(0, dfs(n->left));\\n            int r = max(0, dfs(n->right));\\n            s = max(s, l + r + n->val);\\n            return n->val + max(l, r);\\n        };\\n        \\n        dfs(root);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root, s = -inf) -> int:\\n        \\n        def dfs(n):                    # this recursive function \\n            nonlocal s                 # computes best partial path\\n            if not n : return 0        # sum starting from node \\'n\\':\\n            l = max(0, dfs(n.left))    # [1] compute left and right\\n            r = max(0, dfs(n.right))   #     partial path sums\\n            s = max(s, l + r + n.val)  # [2] compute full path sum\\n            return n.val + max(l, r)   # [3] choose best partial sum\\n\\n        dfs(root)\\n        return s\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int maxPathSum(TreeNode* root, int s = INT_MIN) \\n    {\\n        function<int(TreeNode*)> dfs;\\n        dfs = [&](TreeNode* n) -> int\\n        {\\n            if (!n) return 0;\\n            int l = max(0, dfs(n->left));\\n            int r = max(0, dfs(n->right));\\n            s = max(s, l + r + n->val);\\n            return n->val + max(l, r);\\n        };\\n        \\n        dfs(root);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776579,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    int maxi = INT_MIN;\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        depth(root);\\n        return maxi;\\n    }\\n    \\n    int depth(TreeNode* root){\\n        if(root == NULL) return 0;\\n        \\n        int lh = max(0,depth(root->left));\\n        int rh = max(0,depth(root->right));\\n        \\n        maxi = max(maxi , root->val + lh + rh);\\n        \\n        return root->val + max(lh,rh);\\n    }\\n};\\n```\\n\\nThought Process : \\n\\nFor any node in the Tree , we will consider the current node as the pivot point and add it\\'s left sub-tree and right sub-tree and the node itself. We will check this value with the maximum yet found and update if its larger.\\n\\nWhile backtracking we will set the node\\'s value = root->val + max(left-subtree sum , right-subtree sum) so that in case if parent nodes chose to take it we have the maximum possible sum present to the leaf node.\\n\\nIn case , we have negative values in the sub-trees or the path sum turns out to be negative ,  we will not include it in our path as we want maximum possible sum and mark the sum as 0 instead of -ve.",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int maxi = INT_MIN;\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        depth(root);\\n        return maxi;\\n    }\\n    \\n    int depth(TreeNode* root){\\n        if(root == NULL) return 0;\\n        \\n        int lh = max(0,depth(root->left));\\n        int rh = max(0,depth(root->right));\\n        \\n        maxi = max(maxi , root->val + lh + rh);\\n        \\n        return root->val + max(lh,rh);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332780,
                "title": "recursive-javascript-solution-with-comments",
                "content": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function(root) {\\n  var max = -Infinity // Initialize to a very small number to handle a path of negative values\\n  getMaxSum(root) // Call our recursive fn to start the program\\n  \\n  return max // Once we have popped out of our recursive calls, `max` contains our maximum path sum\\n  \\n  function getMaxSum(tree) {\\n    if (tree == null) { return 0 } // Termination condition\\n    \\n    const leftBranch = Math.max(0, getMaxSum(tree.left)) // calculate the root to leaf sum where root is the left node\\n    const rightBranch = Math.max(0, getMaxSum(tree.right)) // calculate the root to leaf sum where root is the right node\\n    const currentPath = leftBranch + tree.val + rightBranch  // Sum the path: left -> root -> right (leaf to leaf)\\n    \\n    max = Math.max(max, currentPath) // if the current path is greater than the previous value of `max`, update `max` to the current path sum\\n    return tree.val + Math.max(leftBranch, rightBranch)\\n  }\\n};\\n```\\n\\n---\\n\\nI hope others find my code and comments helpful.  Please add feedback if there is an error in my thinking.",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function(root) {\\n  var max = -Infinity // Initialize to a very small number to handle a path of negative values\\n  getMaxSum(root) // Call our recursive fn to start the program\\n  \\n  return max // Once we have popped out of our recursive calls, `max` contains our maximum path sum\\n  \\n  function getMaxSum(tree) {\\n    if (tree == null) { return 0 } // Termination condition\\n    \\n    const leftBranch = Math.max(0, getMaxSum(tree.left)) // calculate the root to leaf sum where root is the left node\\n    const rightBranch = Math.max(0, getMaxSum(tree.right)) // calculate the root to leaf sum where root is the right node\\n    const currentPath = leftBranch + tree.val + rightBranch  // Sum the path: left -> root -> right (leaf to leaf)\\n    \\n    max = Math.max(max, currentPath) // if the current path is greater than the previous value of `max`, update `max` to the current path sum\\n    return tree.val + Math.max(leftBranch, rightBranch)\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209995,
                "title": "python-solution",
                "content": "Idea: Use DFS to compute for each node `v` the largest path sum ending with `v`. This can be done recursively using the formua `max_end_here = max(l_max, r_max)`, where `l_max = dfs(v.left)+v.val` if `dfs(v.left)` > 0, and `l_max = v.val` if `dfs(v.left) <= 0` (i.e., the left path ending with `v` that has the maximum sum consists of `v` only because the maximum path ending with `v.left` sums to a negative value). Similarly, `r_max = dfs(v.right)+v.val` if `dfs(v.right)` > 0, and `l_max = v.val` if `dfs(v.right) <= 0`. From `l_max` and `r_max`, we can compute the maximum path sum of a path that pass through `v` (not necessarily ending with `v`) by the formula `maximum = l_max+r_max-root.val`. We can then update the global variable `self.maximum = max(self.maximum, maximum)`, and return `max_end_here`. After running DFS from the root of the tree, `self.maximum` gives the desired maximum path sum.\\n\\nTime complexity: `O(n)`, space complexity: `O(h)`.\\n\\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            l_max = dfs(root.left)\\n            r_max = dfs(root.right)\\n            if l_max < 0:\\n                l_max = root.val\\n            else:\\n                l_max += root.val\\n            if r_max < 0:\\n                r_max = root.val\\n            else:\\n                r_max += root.val\\n            self.maximum = max(self.maximum, l_max+r_max-root.val)\\n            return max(l_max, r_max)\\n           \\n        self.maximum = -float(\\'inf\\')\\n        dfs(root)\\n        return self.maximum \\n```\\nWith a slight modification, we can eliminate the need for the variable `self.maximum`.\\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0, -float(\\'inf\\')\\n            l_max, res_l = dfs(root.left)\\n            r_max, res_r = dfs(root.right)\\n            if l_max < 0:\\n                l_max = root.val\\n            else:\\n                l_max += root.val\\n            if r_max < 0:\\n                r_max = root.val\\n            else:\\n                r_max += root.val\\n            maximum = l_max+r_max-root.val\\n            return max(l_max, r_max), max(maximum, res_l, res_r)\\n        \\n        res = dfs(root)[1]\\n        return res if res != -float(\\'inf\\') else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            l_max = dfs(root.left)\\n            r_max = dfs(root.right)\\n            if l_max < 0:\\n                l_max = root.val\\n            else:\\n                l_max += root.val\\n            if r_max < 0:\\n                r_max = root.val\\n            else:\\n                r_max += root.val\\n            self.maximum = max(self.maximum, l_max+r_max-root.val)\\n            return max(l_max, r_max)\\n           \\n        self.maximum = -float(\\'inf\\')\\n        dfs(root)\\n        return self.maximum \\n```\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0, -float(\\'inf\\')\\n            l_max, res_l = dfs(root.left)\\n            r_max, res_r = dfs(root.right)\\n            if l_max < 0:\\n                l_max = root.val\\n            else:\\n                l_max += root.val\\n            if r_max < 0:\\n                r_max = root.val\\n            else:\\n                r_max += root.val\\n            maximum = l_max+r_max-root.val\\n            return max(l_max, r_max), max(maximum, res_l, res_r)\\n        \\n        res = dfs(root)[1]\\n        return res if res != -float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39879,
                "title": "my-ac-java-recursive-solution",
                "content": "max1 is the max value of the current node to pass to the upper level node. \\n\\nmax is the global max value that could be max1 or the sum of root and left max and right max \\n\\n    public class Solution {\\n    \\n    int max=Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxPathSumR(root);\\n        return max;\\n    }\\n    \\n    public int maxPathSumR(TreeNode root) {\\n        \\n        if(root==null) return 0;\\n        int left=maxPathSumR(root.left);\\n        int right=maxPathSumR(root.right);\\n        \\n        int max1 = Math.max(root.val,Math.max(root.val+left,root.val+right));\\n        max = Math.max(max,Math.max(max1,left+right+root.val));\\n        return max1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int max=Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxPathSumR(root);\\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3655975,
                "title": "easiest-c-code-2-easy-concepts-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int m=INT_MIN;\\n\\n    int find_max_sum(TreeNode* root){   //maxsum \\n        if(!root)\\n        return 0;\\n\\n        return root->val+max(0,max(find_max_sum(root->left),find_max_sum(root->right)));\\n    }\\n\\n    void solve(TreeNode* root){   //postorder\\n        if(root){\\n            solve(root->left);\\n            solve(root->right);\\n            int ls=find_max_sum(root->left);\\n            int rs=find_max_sum(root->right);\\n\\n            if(ls<0)\\n            ls=0;\\n            if(rs<0)\\n            rs=0;\\n\\n            m=max(ls+rs+root->val,m);\\n        }\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        solve(root);\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int m=INT_MIN;\\n\\n    int find_max_sum(TreeNode* root){   //maxsum \\n        if(!root)\\n        return 0;\\n\\n        return root->val+max(0,max(find_max_sum(root->left),find_max_sum(root->right)));\\n    }\\n\\n    void solve(TreeNode* root){   //postorder\\n        if(root){\\n            solve(root->left);\\n            solve(root->right);\\n            int ls=find_max_sum(root->left);\\n            int rs=find_max_sum(root->right);\\n\\n            if(ls<0)\\n            ls=0;\\n            if(rs<0)\\n            rs=0;\\n\\n            m=max(ls+rs+root->val,m);\\n        }\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        solve(root);\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763640,
                "title": "c-solution-easy-simple-code-comment-explaination",
                "content": "\\n\\n# Code\\n```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    int solve(TreeNode* root,int &ans){\\n        // base case\\n        if(root == NULL){\\n            return 0;\\n        }\\n\\n        int left = max(0,solve(root->left,ans));\\n        int right = max(0,solve(root->right,ans));\\n\\n        int curr = root->val + left + right;\\n        ans = max(curr,ans);\\n\\n        return root->val + max(left,right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n\\n        return ans;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    int solve(TreeNode* root,int &ans){\\n        // base case\\n        if(root == NULL){\\n            return 0;\\n        }\\n\\n        int left = max(0,solve(root->left,ans));\\n        int right = max(0,solve(root->right,ans));\\n\\n        int curr = root->val + left + right;\\n        ans = max(curr,ans);\\n\\n        return root->val + max(left,right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n\\n        return ans;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827780,
                "title": "java-0-ms-faster-than-100-00-short-and-simple",
                "content": "```\\nclass Solution {\\n    int maxPath = 0;\\n    public int maxPathSum(TreeNode root) {\\n        maxPath = root.val;\\n        getMax(root);\\n        return maxPath;\\n    }\\n    \\n    private int getMax(TreeNode root) {\\n        if (root==null) {\\n            return 0;\\n        }\\n        int leftMax = getMax(root.left);\\n        int rightMax = getMax(root.right);\\n        leftMax = Math.max(leftMax, 0);\\n        rightMax = Math.max(rightMax, 0);\\n        maxPath = Math.max(maxPath, root.val + leftMax + rightMax);\\n        return root.val + Math.max(leftMax, rightMax);\\n    }\\n}\\n```\\n\\nPlease upvote if you like the solution..!!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int maxPath = 0;\\n    public int maxPathSum(TreeNode root) {\\n        maxPath = root.val;\\n        getMax(root);\\n        return maxPath;\\n    }\\n    \\n    private int getMax(TreeNode root) {\\n        if (root==null) {\\n            return 0;\\n        }\\n        int leftMax = getMax(root.left);\\n        int rightMax = getMax(root.right);\\n        leftMax = Math.max(leftMax, 0);\\n        rightMax = Math.max(rightMax, 0);\\n        maxPath = Math.max(maxPath, root.val + leftMax + rightMax);\\n        return root.val + Math.max(leftMax, rightMax);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187845,
                "title": "java-100-short-simple",
                "content": "```\\n\\nclass Solution {\\n    int ans = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        recurse(root);\\n        return ans;\\n    }\\n    \\n    public int recurse(TreeNode root) {\\n\\t\\t//base case\\n        if(root == null) return 0;\\n\\t\\t//postorder\\n        int left = recurse(root.left); \\n        int right = recurse(root.right);\\n        \\n\\t\\t//anything that is negative will never help maximize the path , so lets ignore it\\n        if(left < 0) left = 0;\\n        if(right < 0) right = 0;\\n\\t\\t\\n\\t\\t//worst case - root is only considered , if left and right are negatives\\n        int sum = root.val + left + right;\\n\\t\\t//update global answer\\n        ans = Math.max(sum, ans);\\n\\t\\t//from here send to parent what is max (it will be either curr+leftMax or curr+rightMax , as path in one directional)\\n        return Math.max(left + root.val, right + root.val);\\n    }\\n}\\n```\\n\\nIf the approach helps, please up-vote for reach.",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int ans = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        recurse(root);\\n        return ans;\\n    }\\n    \\n    public int recurse(TreeNode root) {\\n\\t\\t//base case\\n        if(root == null) return 0;\\n\\t\\t//postorder\\n        int left = recurse(root.left); \\n        int right = recurse(root.right);\\n        \\n\\t\\t//anything that is negative will never help maximize the path , so lets ignore it\\n        if(left < 0) left = 0;\\n        if(right < 0) right = 0;\\n\\t\\t\\n\\t\\t//worst case - root is only considered , if left and right are negatives\\n        int sum = root.val + left + right;\\n\\t\\t//update global answer\\n        ans = Math.max(sum, ans);\\n\\t\\t//from here send to parent what is max (it will be either curr+leftMax or curr+rightMax , as path in one directional)\\n        return Math.max(left + root.val, right + root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602931,
                "title": "c-o-n-recursive-short-and-easy-to-understand-with-comment",
                "content": "```\\nclass Solution {\\n    int helper( TreeNode* node, int &maxSum ) {\\n        if( !node ) return 0;\\n        int left = 0, right = 0;\\n        if( node->left )  left = helper( node->left, maxSum );\\n        if( node->right ) right = helper( node->right, maxSum );\\n        \\n        // node+left or node+right or node\\n        int leftOrRightOrNode = max( node->val, node->val + max( left, right ) );\\n        // set maxSum to max of maxSum, node+left+right, node+left, node+right, node\\n        maxSum = max( maxSum, max( node->val + left + right, leftOrRightOrNode ) );        \\n        return leftOrRightOrNode;\\n    }\\n    \\npublic:\\n    int maxPathSum( TreeNode* root ) {\\n        int maxSum = INT_MIN;\\n        helper( root, maxSum );\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int helper( TreeNode* node, int &maxSum ) {\\n        if( !node ) return 0;\\n        int left = 0, right = 0;\\n        if( node->left )  left = helper( node->left, maxSum );\\n        if( node->right ) right = helper( node->right, maxSum );\\n        \\n        // node+left or node+right or node\\n        int leftOrRightOrNode = max( node->val, node->val + max( left, right ) );\\n        // set maxSum to max of maxSum, node+left+right, node+left, node+right, node\\n        maxSum = max( maxSum, max( node->val + left + right, leftOrRightOrNode ) );        \\n        return leftOrRightOrNode;\\n    }\\n    \\npublic:\\n    int maxPathSum( TreeNode* root ) {\\n        int maxSum = INT_MIN;\\n        helper( root, maxSum );\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577860,
                "title": "python-beats-89-49-basic-recursion-structure-w-algorithm-explanation",
                "content": "Idea:\\n\\nEvery single node in the original tree could be the \"root\" of the max path.\\nFor every one of these \"roots,\" you could add the stuff on the left, the stuff on the right, neither, or both to get the max path.\\n* What is this \"stuff\"? It\\'s the max path of the subtree created by following node.left or node.right.\\n\\nAt the end, we return the max of EITHER just the root, the root and the max path left subtree, or the root and the max path right subtree.\\n* Why not root and both left and right subtree? If the root ISN\\'T the actual root, it\\'ll be in either the left or right subtree of the actual root. Since we want a single path, the path can\\'t \"split\", so it needs to take exactly one \"road\", namely left or right.\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = float(\\'-inf\\')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def traverse(root):\\n            if root:\\n                left = traverse(root.left)\\n                right = traverse(root.right)\\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\\n                return max(root.val,root.val + left,root.val + right)\\n            else:\\n                return 0\\n        traverse(root)\\n        return self.maxSum\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = float(\\'-inf\\')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def traverse(root):\\n            if root:\\n                left = traverse(root.left)\\n                right = traverse(root.right)\\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\\n                return max(root.val,root.val + left,root.val + right)\\n            else:\\n                return 0\\n        traverse(root)\\n        return self.maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254281,
                "title": "javascript",
                "content": "```\\nvar maxPathSum = function(root) {\\n    let maxPathSumNum = -Infinity;\\n    \\n    const maxPathSumRec = function(node){\\n        if(!node){\\n            return 0;\\n        }\\n        \\n        let leftMax = Math.max(maxPathSumRec(node.left), 0);\\n        let rightMax = Math.max(maxPathSumRec(node.right), 0);\\n        maxPathSumNum = Math.max(maxPathSumNum, leftMax + rightMax + node.val);\\n        return Math.max(leftMax, rightMax) + node.val;\\n    };\\n    \\n    maxPathSumRec(root);\\n    return maxPathSumNum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxPathSum = function(root) {\\n    let maxPathSumNum = -Infinity;\\n    \\n    const maxPathSumRec = function(node){\\n        if(!node){\\n            return 0;\\n        }\\n        \\n        let leftMax = Math.max(maxPathSumRec(node.left), 0);\\n        let rightMax = Math.max(maxPathSumRec(node.right), 0);\\n        maxPathSumNum = Math.max(maxPathSumNum, leftMax + rightMax + node.val);\\n        return Math.max(leftMax, rightMax) + node.val;\\n    };\\n    \\n    maxPathSumRec(root);\\n    return maxPathSumNum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 232373,
                "title": "postorder-iterative-solution-python",
                "content": "The general idea is that we can go through the nodes in post order traversal and cache the maximum path from a node\\'s subtree to itself (the reason is that we can obtain the left_max_path and right_max_path in O(1) time).\\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: \\'TreeNode\\') -> \\'int\\':\\n        def post_order(node):\\n            cur = node\\n            stack = []\\n            res = []\\n            while cur or stack:\\n                if cur:\\n                    stack.append(cur)\\n                    res.append(cur)\\n                    cur = cur.right\\n                else:\\n                    cur = stack.pop()\\n                    cur = cur.left\\n            return res[::-1]\\n        \\n        res = -float(\\'inf\\')\\n        nodes = post_order(root)\\n        path_until_node = {None: 0}\\n        for node in nodes:\\n            left_max_path = max(0, path_until_node[node.left])\\n            right_max_path = max(0, path_until_node[node.right])\\n            res = max(res, left_max_path + right_max_path + node.val)\\n            path_until_node[node] = max(left_max_path, right_max_path) + node.val\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root: \\'TreeNode\\') -> \\'int\\':\\n        def post_order(node):\\n            cur = node\\n            stack = []\\n            res = []\\n            while cur or stack:\\n                if cur:\\n                    stack.append(cur)\\n                    res.append(cur)\\n                    cur = cur.right\\n                else:\\n                    cur = stack.pop()\\n                    cur = cur.left\\n            return res[::-1]\\n        \\n        res = -float(\\'inf\\')\\n        nodes = post_order(root)\\n        path_until_node = {None: 0}\\n        for node in nodes:\\n            left_max_path = max(0, path_until_node[node.left])\\n            right_max_path = max(0, path_until_node[node.right])\\n            res = max(res, left_max_path + right_max_path + node.val)\\n            path_until_node[node] = max(left_max_path, right_max_path) + node.val\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171807,
                "title": "python-dfs",
                "content": "# 124. Binary Tree Maximum Path Sum\\n[\\u6B64\\u9898\\u6536\\u5F55\\u5728Github](https://github.com/yuzhoujr/leetcode/issues/33)\\n\\n1. \\u5206\\u5236\\u5230\\u5E95\\u90E8\\uFF0C\\u5728\\u8FD4\\u56DE\\u7684\\u65F6\\u5019\\u4F20\\u5165\\u5DE6\\u53F3\\u4EFB\\u610F\\u4E00\\u904D\\u6700\\u5927\\u503C\\u52A0\\u4E0A\\u76EE\\u524D`root.val`:\\n`cur = max(left, right) + root.val`\\n\\u8FD9\\u79CD\\u60C5\\u51B5\\u5904\\u7406\\u4E86\\u4ECERoot\\u5230\\u5DE6\\u53F3\\u4EFB\\u610F\\u4E00\\u8FB9\\u7684\\u6700\\u5927\\u503C\\uFF0C\\u4E5F\\u5C31\\u662F `root.val + left` \\u548C `root.val + right`\\n2. \\u8FD8\\u6709\\u4E00\\u79CD\\u60C5\\u51B5\\u5C31\\u662F\\u5F53\\u6700\\u5927\\u503C = `root.val + left + right`\\uFF0C \\u6211\\u4EEC\\u5728\\u653E\\u5165global\\u53D8\\u91CF\\u7684\\u65F6\\u5019\\u4F55\\u5176\\u6BD4\\u8F83\\u3002\\n3. \\u5BF9\\u4E8E\\u6700\\u5E95\\u90E8\\u53F6\\u5B50\\u8282\\u70B9\\u4F20\\u4E0A\\u6765\\u7684\\u503C\\uFF0C\\u6211\\u4EEC\\u5C06\\u5176\\u8BBE\\u7F6E\\u62100: `return cur if cur > 0 else 0`\\n\\n```python\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.res = - float(\\'inf\\')\\n        self.dfs(root)\\n        return self.res\\n\\n    \\n    def dfs(self, root):\\n        if not root: return 0\\n        left = self.dfs(root.left)\\n        right = self.dfs(root.right)\\n        self.res = max(self.res, left + right + root.val)\\n        cur = max(left, right) + root.val\\n        return cur if cur > 0 else 0\\n```\\n<br>",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.res = - float(\\'inf\\')\\n        self.dfs(root)\\n        return self.res\\n\\n    \\n    def dfs(self, root):\\n        if not root: return 0\\n        left = self.dfs(root.left)\\n        right = self.dfs(root.right)\\n        self.res = max(self.res, left + right + root.val)\\n        cur = max(left, right) + root.val\\n        return cur if cur > 0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39813,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Binary Tree Maximum Path Sum** https://leetcode.com/problems/binary-tree-maximum-path-sum/\\n\\n**Brute Force Solution: O(N^2)**\\n* Assume we have nodes numbered 1 to N\\n* sum(i) = Maximum sum of a path containing node(i). Clearly the solution of the problem is max(sum(1), sum(2), ...., sum(N))\\n* Now what is the maximum sum of a path containing a particular node(i)?\\n* lresult[0]: maximum path sum starting at node(i).left\\n* rresult[0]: maximum path sum starting at node(i).right\\n* sum(i) = max(lresult[0], 0) + max(rresult[0], 0) + node(i).val\\n* Why do we do max(lresult[0], 0)? sum(i) must contain node(i).val. We will add lresult[0] or rresult[0] only when they help increase sum(i). We will ignore lresult[0] or rresult[0] if they are negative.\\n* We use pre-order traversal to iterate over the nodes and compute sum(i) for each node(i).\\n* Time complexity for sum(i) is O(N). Total time complexity is O(N^2)\\n* Space complexity is O(N)\\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.answer = float('-inf')\\n        self.helper(root)\\n        return self.answer\\n    \\n    def max_path_sum(self, root, so_far, result):\\n        if root is None:\\n            return\\n        result[0] = max(result[0], so_far + root.val)\\n        self.max_path_sum(root.left, so_far + root.val, result)\\n        self.max_path_sum(root.right, so_far + root.val, result)\\n        return\\n    \\n    def helper(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return\\n        lresult, rresult = [float('-inf')], [float('-inf')]\\n        self.max_path_sum(root.left, 0, lresult) # Find maximum path sum starting from root.left\\n        self.max_path_sum(root.right, 0, rresult) # Find maximum path sum starting from root.right\\n        self.answer = max(max(lresult[0], 0) + max(rresult[0], 0) + root.val, self.answer)\\n        self.helper(root.left)\\n        self.helper(root.right)        \\n        return\\n```\\n**Bottom Up Optimized Solution: O(N)**\\n* Bottom up template uses post-order traversal and usually returns two items. To visualize this algorithm, always start with bottom up picture returning 1 or 2 values\\n* In this algorithm, we can use post-order traversal and return the maximum sum in the subtree starting from the root. \\n* We call it lresult and rresult for left and right subtree\\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.max_so_far = float('-inf')\\n        self.helper(root) # Maximum sum starting from root\\n        return self.max_so_far\\n        \\n    def helper(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        lresult = self.helper(root.left) # Maximum sum starting from root.left\\n        rresult = self.helper(root.right) # Maximum sum starting from root.left\\n        self.max_so_far = max(max(lresult, 0) + max(rresult, 0) + root.val, self.max_so_far)\\n        return max(lresult, rresult, 0) + root.val # Return maximum sum starting from root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.answer = float('-inf')\\n        self.helper(root)\\n        return self.answer\\n    \\n    def max_path_sum(self, root, so_far, result):\\n        if root is None:\\n            return\\n        result[0] = max(result[0], so_far + root.val)\\n        self.max_path_sum(root.left, so_far + root.val, result)\\n        self.max_path_sum(root.right, so_far + root.val, result)\\n        return\\n    \\n    def helper(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return\\n        lresult, rresult = [float('-inf')], [float('-inf')]\\n        self.max_path_sum(root.left, 0, lresult) # Find maximum path sum starting from root.left\\n        self.max_path_sum(root.right, 0, rresult) # Find maximum path sum starting from root.right\\n        self.answer = max(max(lresult[0], 0) + max(rresult[0], 0) + root.val, self.answer)\\n        self.helper(root.left)\\n        self.helper(root.right)        \\n        return\\n```\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.max_so_far = float('-inf')\\n        self.helper(root) # Maximum sum starting from root\\n        return self.max_so_far\\n        \\n    def helper(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        lresult = self.helper(root.left) # Maximum sum starting from root.left\\n        rresult = self.helper(root.right) # Maximum sum starting from root.left\\n        self.max_so_far = max(max(lresult, 0) + max(rresult, 0) + root.val, self.max_so_far)\\n        return max(lresult, rresult, 0) + root.val # Return maximum sum starting from root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899144,
                "title": "kotlin-clean-and-efficient-less-than-15-lines",
                "content": "```\\nclass Solution {\\n    fun maxPathSum(root: TreeNode?): Int {\\n        var bestSum = Integer.MIN_VALUE\\n        \\n        fun recurse(node: TreeNode?): Int {\\n            if (node == null) return 0\\n            val left = Math.max(recurse(node.left), 0)\\n            val right =  Math.max(recurse(node.right), 0)\\n            bestSum = Math.max(bestSum, left + right + node.`val`)\\n            return node.`val` + Math.max(left, right)\\n        }\\n        recurse(root)\\n\\n        return bestSum\\n    }\\n}\\n```\\n\\nworst case time: O(n) the solution traverses all nodes\\nworst case space: O(n) the call stack could include the number of nodes",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxPathSum(root: TreeNode?): Int {\\n        var bestSum = Integer.MIN_VALUE\\n        \\n        fun recurse(node: TreeNode?): Int {\\n            if (node == null) return 0\\n            val left = Math.max(recurse(node.left), 0)\\n            val right =  Math.max(recurse(node.right), 0)\\n            bestSum = Math.max(bestSum, left + right + node.`val`)\\n            return node.`val` + Math.max(left, right)\\n        }\\n        recurse(root)\\n\\n        return bestSum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305158,
                "title": "implementing-using-pair-class-c-o-n-easy-to-understand-15-line-code",
                "content": "The idea is to implement a pair class to store the answer of each node as well as the maximum sum including that node in the path(**NOTE: this is different from the actual answer because it is not necessary that the node is part of our answer**) this helps us to find maximum sum including that node in O(1) time.\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> helper(TreeNode* root){\\n        if(root==NULL){\\n            pair<int,int> p={0,INT_MIN};\\n            return p;\\n        }\\n        pair<int,int> left=helper(root->left);\\n        pair<int,int> right=helper(root->right);\\n        int include=max(max(root->val,root->val+left.first+right.first),max(root->val+left.first,root->val+right.first)); \\n        int notinclude=max(left.second,right.second);\\n        pair<int,int>ans;\\n        ans.second=max(include,notinclude);\\n        ans.first=max(max(left.first,right.first)+root->val,root->val);\\n        return ans;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        return helper(root).second;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    pair<int,int> helper(TreeNode* root){\\n        if(root==NULL){\\n            pair<int,int> p={0,INT_MIN}",
                "codeTag": "Java"
            },
            {
                "id": 2304217,
                "title": "c-easy-short-and-fastest",
                "content": "```\\nclass Solution {\\nprivate:\\n    int helper(TreeNode* root, int&ans){\\n\\t\\t// Escape condition\\n        if(!root) return 0;\\n        \\n\\t\\t// DFS\\n\\t\\tint left = max(0, helper(root->left,ans));\\n        int right = max(0, helper(root->right,ans));\\n        \\n\\t\\t// There is also possibility left+parent+right > ans\\n\\t\\tans = max(ans, root->val + left + right);\\n\\t\\t\\n\\t\\t// Inorder to make the path continous we can send either right or the left side,\\n\\t\\t// So we will send the maximum side\\n        return root->val + max(left, right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n\\t\\t// The answer\\n        int ans = INT_MIN;\\n        if(!root) return 0;\\n        \\n\\t\\t// Recurssive function\\n\\t\\thelper(root, ans);\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(TreeNode* root, int&ans){\\n\\t\\t// Escape condition\\n        if(!root) return 0;\\n        \\n\\t\\t// DFS\\n\\t\\tint left = max(0, helper(root->left,ans));\\n        int right = max(0, helper(root->right,ans));\\n        \\n\\t\\t// There is also possibility left+parent+right > ans\\n\\t\\tans = max(ans, root->val + left + right);\\n\\t\\t\\n\\t\\t// Inorder to make the path continous we can send either right or the left side,\\n\\t\\t// So we will send the maximum side\\n        return root->val + max(left, right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n\\t\\t// The answer\\n        int ans = INT_MIN;\\n        if(!root) return 0;\\n        \\n\\t\\t// Recurssive function\\n\\t\\thelper(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335817,
                "title": "recursive-solution-c-and-java-0-ms",
                "content": "We need to find the maximum path sum, We can do it by simply comparing the sum of the root* along with its leftSubtree sum or rightSubtree sum and returning the max. But, there is a condition left that we still need to fulfill. \\n   Suppose, what is the maximum sum in a path -> sum of all the nodes present in the path but what if one or two nodes are negative what would we do in this case, as we need to find the maximum sum we will not count them and will take zero to obtain the maximum result.\\n  \\n ```\\n  class Solution {\\n  public:  \\n  \\n    int sum = INT_MIN;\\n   \\n    int helper(TreeNode* root)\\n    {\\n        if(!root)  return 0;\\n        \\n        int leftSum = max(0,helper(root->left));\\n        int rightSum = max(0,helper(root->right));\\n        \\n        sum = max(sum,leftSum + rightSum + root->val);\\n        \\n        return max(leftSum,rightSum) + root->val;   \\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        helper(root);\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\nwe didn\\'t  include current root->val + root-> left + root->right in the last line while returning value because, for current root\\'s parent root, if we were to include root->val + root->left + root->right in the maxPathSum, it would violate the principle that we can only traverse each node once.\\nWe are returning the path sum not the subtree sum.\\n\\nsame code in Java\\n\\n```\\nclass Solution {\\n    int sum = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        sum = Integer.MIN_VALUE;\\n        \\n        helper(root);\\n        \\n        return sum;\\n    }\\n    \\n    public int helper(TreeNode root)\\n    {\\n        if(root == null)\\n            return 0;\\n        \\n        int leftSum = Math.max(0,helper(root.left));\\n        int rightSum = Math.max(0,helper(root.right));\\n        \\n        sum = Math.max(sum,leftSum + rightSum + root.val);\\n        \\n        return Math.max(leftSum,rightSum) + root.val;  \\n    }\\n}\\n```\\n\\nPS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43\\n",
                "solutionTags": [],
                "code": "```\\n  class Solution {\\n  public:  \\n  \\n    int sum = INT_MIN;\\n   \\n    int helper(TreeNode* root)\\n    {\\n        if(!root)  return 0;\\n        \\n        int leftSum = max(0,helper(root->left));\\n        int rightSum = max(0,helper(root->right));\\n        \\n        sum = max(sum,leftSum + rightSum + root->val);\\n        \\n        return max(leftSum,rightSum) + root->val;   \\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        helper(root);\\n        \\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int sum = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        sum = Integer.MIN_VALUE;\\n        \\n        helper(root);\\n        \\n        return sum;\\n    }\\n    \\n    public int helper(TreeNode root)\\n    {\\n        if(root == null)\\n            return 0;\\n        \\n        int leftSum = Math.max(0,helper(root.left));\\n        int rightSum = Math.max(0,helper(root.right));\\n        \\n        sum = Math.max(sum,leftSum + rightSum + root.val);\\n        \\n        return Math.max(leftSum,rightSum) + root.val;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258344,
                "title": "c-concise-o-n-solution-easy",
                "content": "```\\n int sum(TreeNode* root, int& res)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int l = sum(root -> left, res);\\n        int r = sum(root -> right, res);\\n        \\n        int temp = max(max(l, r) + root -> val, root -> val);\\n        int ans = max(temp, l + r + root -> val);\\n        res =  max(res, ans);\\n        \\n        return temp;\\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        int res = INT_MIN;\\n        sum(root, res);\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n int sum(TreeNode* root, int& res)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int l = sum(root -> left, res);\\n        int r = sum(root -> right, res);\\n        \\n        int temp = max(max(l, r) + root -> val, root -> val);\\n        int ans = max(temp, l + r + root -> val);\\n        res =  max(res, ans);\\n        \\n        return temp;\\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        int res = INT_MIN;\\n        sum(root, res);\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113179,
                "title": "python-recursion-solution",
                "content": "See docstring for algorithm\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        # set initial max to negative to system max size\\n        self.max_sum = -sys.maxsize\\n        \\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def get_max(node):\\n            \"\"\"Search for max path for given node and update global max \\n            \\n            - Find max of these 4 cases:\\n            -- node \\n            -- node + left \\n            -- node + right \\n            -- node + left + right \\n            \\n            for left and right calculation use recursion \\n            \\n            - Update global max with this value \\n            \\n            Return max of only first 3 cases - becasue 4th case marks top of the tree \\n            If both children of node are added - then it can\\'t be connected to caller\\n            \\n            :param node: current node to calculate\\n            :type node: TreeNode\\n            :returns: max path that can be continued\\n            :rype: int\\n            \"\"\"\\n            if not node:\\n                return 0 \\n\\n            \\n            left = get_max(node.left)\\n            right = get_max(node.right)\\n            \\n            cases = [\\n                    node.val,                      # when node is the best case\\n                    node.val + left,               # when left path is chosen \\n                    node.val + right,              # when right parth is chosen\\n                    node.val + left + right,       # top of the tree case - this cannot be part of any other path\\n                ]\\n            \\n            self.max_sum = max(self.max_sum, max(cases))\\n                       \\n            return max(cases[0:3])\\n\\n        get_max(root)\\n        return self.max_sum\\n        \\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "See docstring for algorithm\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        # set initial max to negative to system max size\\n        self.max_sum = -sys.maxsize\\n        \\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def get_max(node):\\n            \"\"\"Search for max path for given node and update global max \\n            \\n            - Find max of these 4 cases:\\n            -- node \\n            -- node + left \\n            -- node + right \\n            -- node + left + right \\n            \\n            for left and right calculation use recursion \\n            \\n            - Update global max with this value \\n            \\n            Return max of only first 3 cases - becasue 4th case marks top of the tree \\n            If both children of node are added - then it can\\'t be connected to caller\\n            \\n            :param node: current node to calculate\\n            :type node: TreeNode\\n            :returns: max path that can be continued\\n            :rype: int\\n            \"\"\"\\n            if not node:\\n                return 0 \\n\\n            \\n            left = get_max(node.left)\\n            right = get_max(node.right)\\n            \\n            cases = [\\n                    node.val,                      # when node is the best case\\n                    node.val + left,               # when left path is chosen \\n                    node.val + right,              # when right parth is chosen\\n                    node.val + left + right,       # top of the tree case - this cannot be part of any other path\\n                ]\\n            \\n            self.max_sum = max(self.max_sum, max(cases))\\n                       \\n            return max(cases[0:3])\\n\\n        get_max(root)\\n        return self.max_sum\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 592138,
                "title": "clean-and-simple-c-solution-96-57-faster-100-memory",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int max_sum = root->val;\\n        getMaxSumPath(root, &max_sum);\\n        return max_sum;\\n    }\\nprivate:\\n    int getMaxSumPath(TreeNode* node, int* max_sum) {\\n        if (node == nullptr) return 0;\\n        auto l = max(getMaxSumPath(node->left, max_sum), 0);\\n        auto r = max(getMaxSumPath(node->right, max_sum), 0);\\n        *max_sum = max(*max_sum, node->val + l + r);\\n        return node->val + max(l, r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int max_sum = root->val;\\n        getMaxSumPath(root, &max_sum);\\n        return max_sum;\\n    }\\nprivate:\\n    int getMaxSumPath(TreeNode* node, int* max_sum) {\\n        if (node == nullptr) return 0;\\n        auto l = max(getMaxSumPath(node->left, max_sum), 0);\\n        auto r = max(getMaxSumPath(node->right, max_sum), 0);\\n        *max_sum = max(*max_sum, node->val + l + r);\\n        return node->val + max(l, r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422797,
                "title": "javascript-solution-w-explanation",
                "content": "### The Idea\\n1. Use DFS\\n2. If a branch\\'s maximum sum is negative, we will never consider that route so we set it to 0\\n3. Right before we backtrack, calculate the global maximum sum\\n4. For the backtrack value, we return the current route\\'s max sum \\n``` \\nvar maxPathSum = function(root) {\\n    let max = -Infinity;\\n    var recur = function(node) {\\n        if (node == null) return 0;\\n        let left = Math.max(0, recur(node.left)); // negative sums will just be ignored\\n        let right = Math.max(0, recur(node.right));\\n        max = Math.max(left + right + node.val, max); // calculate the global max\\n        return Math.max(left, right)+node.val;  // return current route\\'s best sum\\n    }\\n    recur(root)\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar maxPathSum = function(root) {\\n    let max = -Infinity;\\n    var recur = function(node) {\\n        if (node == null) return 0;\\n        let left = Math.max(0, recur(node.left)); // negative sums will just be ignored\\n        let right = Math.max(0, recur(node.right));\\n        max = Math.max(left + right + node.val, max); // calculate the global max\\n        return Math.max(left, right)+node.val;  // return current route\\'s best sum\\n    }\\n    recur(root)\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213322,
                "title": "javascript-dfs-o-n-100",
                "content": "```\\nvar maxPathSum = function(root) {\\n    \\n    let max = -Infinity;\\n    \\n    function dfs(node) {\\n        if(!node) return 0;\\n        \\n        let left = dfs(node.left);\\n        let right = dfs(node.right);\\n        \\n        max = Math.max(\\n            left + right + node.val,\\n            left + node.val,\\n            right + node.val,\\n            node.val,\\n            max\\n        );\\n        \\n        return Math.max(left + node.val, right + node.val, node.val);\\n        \\n    }\\n    \\n    dfs(root);\\n    \\n    return max;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxPathSum = function(root) {\\n    \\n    let max = -Infinity;\\n    \\n    function dfs(node) {\\n        if(!node) return 0;\\n        \\n        let left = dfs(node.left);\\n        let right = dfs(node.right);\\n        \\n        max = Math.max(\\n            left + right + node.val,\\n            left + node.val,\\n            right + node.val,\\n            node.val,\\n            max\\n        );\\n        \\n        return Math.max(left + node.val, right + node.val, node.val);\\n        \\n    }\\n    \\n    dfs(root);\\n    \\n    return max;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189725,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    int Max = Int32.MinValue;\\n    \\n    public int MaxPathSum(TreeNode root) {\\n            Helper(root);\\n            return Max;\\n    }\\n    \\n    private int Helper(TreeNode root)\\n    {\\n        if (root == null)\\n            return 0;\\n\\n        int leftMax = Helper(root.left),\\n            rightMax = Helper(root.right),\\n            currentMax = 0;\\n\\n        currentMax = Math.Max(currentMax, Math.Max(leftMax + root.val, rightMax + root.val));\\n        Max = Math.Max(Max, leftMax + root.val + rightMax);\\n\\n        return currentMax;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int Max = Int32.MinValue;\\n    \\n    public int MaxPathSum(TreeNode root) {\\n            Helper(root);\\n            return Max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 39872,
                "title": "ac-java-solution-very-simple-dfs",
                "content": "    private int maxPath = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        traverse(root);\\n        return maxPath;\\n    }\\n    \\n    public int traverse(TreeNode root){\\n        if(root == null)    return 0;\\n        \\n        int left = traverse(root.left) + root.val;\\n        int right = traverse(root.right) + root.val;\\n\\n        int tmpMax = Math.max(left, Math.max(right, root.val));\\n        maxPath = Math.max(maxPath, Math.max(tmpMax, left + right - root.val));\\n        return tmpMax;\\n    }",
                "solutionTags": [],
                "code": "    private int maxPath = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        traverse(root);\\n        return maxPath;\\n    }\\n    \\n    public int traverse(TreeNode root){\\n        if(root == null)    return 0;\\n        \\n        int left = traverse(root.left) + root.val;\\n        int right = traverse(root.right) + root.val;\\n\\n        int tmpMax = Math.max(left, Math.max(right, root.val));\\n        maxPath = Math.max(maxPath, Math.max(tmpMax, left + right - root.val));\\n        return tmpMax;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39940,
                "title": "accepted-java-code-19-lines-simple-and-effective",
                "content": "The thought is bottom-up, first we need to get left and right tree max value and make sure that they need to be larger than 0. Next add them to current node value, compare to the total max value and update the total max value. Finally return current value with one of left or right max value (>=0).\\n    \\n    public class Solution {\\n            int max = 0;\\n            public int maxPathSum(TreeNode root) {\\n                if(root == null) return 0;\\n                max = root.val;\\n                helper(root);\\n                return max;\\n            }\\n            public int helper(TreeNode node)\\n            {\\n                if(node == null) return 0;\\n                int left = helper(node.left);\\n                int right = helper(node.right);\\n                left = left > 0 ? left : 0;\\n                right = right > 0 ? right : 0;\\n                int curMax = node.val + left + right;\\n                max = Math.max(max, curMax);\\n                return node.val + Math.max(left, right);\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n            int max = 0;\\n            public int maxPathSum(TreeNode root) {\\n                if(root == null) return 0;\\n                max = root.val;\\n                helper(root);\\n                return max;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3587990,
                "title": "c-recursion-most-optimized-very-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int &ans){\\n        if(root == NULL)return 0;\\n        int l = solve(root->left,ans);\\n        int r = solve(root->right,ans);\\n        ans = max({ans,root->val,r+root->val,l+root->val,l+r+root->val});\\n        return max({max({l,r})+root->val,root->val,0});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int &ans){\\n        if(root == NULL)return 0;\\n        int l = solve(root->left,ans);\\n        int r = solve(root->right,ans);\\n        ans = max({ans,root->val,r+root->val,l+root->val,l+r+root->val});\\n        return max({max({l,r})+root->val,root->val,0});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425731,
                "title": "simple-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root,int &maxi){\\n        if(root == NULL)\\n            return 0;\\n\\n        int ls = max(0,helper(root->left,maxi));\\n        int rs = max(0,helper(root->right,maxi));\\n\\n        maxi = max(maxi,(ls + root->val + rs));\\n        return (root->val + max(ls,rs));\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        int maxi = INT_MIN;\\n        helper(root,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root,int &maxi){\\n        if(root == NULL)\\n            return 0;\\n\\n        int ls = max(0,helper(root->left,maxi));\\n        int rs = max(0,helper(root->right,maxi));\\n\\n        maxi = max(maxi,(ls + root->val + rs));\\n        return (root->val + max(ls,rs));\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        int maxi = INT_MIN;\\n        helper(root,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221814,
                "title": "best-o-n-solution",
                "content": "# Approach\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        findMaxPathSum(root, ans);\\n        return ans;\\n    }\\nprivate:\\n    int findMaxPathSum(TreeNode* root, int& ans) {\\n        if (root == NULL)\\n            return 0;\\n        int leftSum = max (0, findMaxPathSum(root->left, ans));    \\n        int rightSum = max (0, findMaxPathSum(root->right, ans)); \\n        ans = max (ans, root->val + leftSum + rightSum);\\n        return root->val + max (leftSum, rightSum);   \\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        findMaxPathSum(root, ans);\\n        return ans;\\n    }\\nprivate:\\n    int findMaxPathSum(TreeNode* root, int& ans) {\\n        if (root == NULL)\\n            return 0;\\n        int leftSum = max (0, findMaxPathSum(root->left, ans));    \\n        int rightSum = max (0, findMaxPathSum(root->right, ans)); \\n        ans = max (ans, root->val + leftSum + rightSum);\\n        return root->val + max (leftSum, rightSum);   \\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195903,
                "title": "beats-92-69-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution also uses a recursive approach, but instead of keeping track of the maximum path sum so far in a global variable, it passes it down as a parameter to the recursive function. This allows for a cleaner implementation of the DFS function, as it only needs to return the maximum path sum of the current node and its subtrees.\\n\\nThe function dfs takes a node as input and returns the maximum path sum of the current node and its subtrees. It first checks if the node is None (i.e., a leaf node), and returns 0 in that case. Then, it recursively calls itself on the left and right subtrees, and stores the maximum sums in the variables left_sum and right_sum.\\n\\nThe maximum path sum of the current node is then calculated by adding the value of the node to the maximum sums of the left and right subtrees (if they are positive), and updating the global variable self.max_path_sum if necessary.\\n\\nFinally, the function returns the maximum sum of the current node and the maximum sums of its left and right subtrees.\\n\\nThe main function maxPathSum first initializes the maximum path sum to negative infinity, and then calls the dfs function on the root node. It then returns the maximum path sum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nBeats\\n92.69%\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(node):\\n            # Base case: node is None\\n            if not node:\\n                return 0\\n            \\n            # Get the maximum sum of the left subtree\\n            left_sum = max(dfs(node.left), 0)\\n            # Get the maximum sum of the right subtree\\n            right_sum = max(dfs(node.right), 0)\\n            \\n            # Update the maximum path sum so far with the sum of the current node\\n            # and the maximum sums of the left and right subtrees\\n            self.max_path_sum = max(self.max_path_sum, node.val + left_sum + right_sum)\\n            \\n            # Return the maximum sum of the current node and the maximum sum of its\\n            # left and right subtrees\\n            return node.val + max(left_sum, right_sum)\\n        \\n        # Initialize the maximum path sum to negative infinity\\n        self.max_path_sum = float(\\'-inf\\')\\n        \\n        # Start the depth-first search\\n        dfs(root)\\n        \\n        # Return the maximum path sum\\n        return self.max_path_sum\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(node):\\n            # Base case: node is None\\n            if not node:\\n                return 0\\n            \\n            # Get the maximum sum of the left subtree\\n            left_sum = max(dfs(node.left), 0)\\n            # Get the maximum sum of the right subtree\\n            right_sum = max(dfs(node.right), 0)\\n            \\n            # Update the maximum path sum so far with the sum of the current node\\n            # and the maximum sums of the left and right subtrees\\n            self.max_path_sum = max(self.max_path_sum, node.val + left_sum + right_sum)\\n            \\n            # Return the maximum sum of the current node and the maximum sum of its\\n            # left and right subtrees\\n            return node.val + max(left_sum, right_sum)\\n        \\n        # Initialize the maximum path sum to negative infinity\\n        self.max_path_sum = float(\\'-inf\\')\\n        \\n        # Start the depth-first search\\n        dfs(root)\\n        \\n        # Return the maximum path sum\\n        return self.max_path_sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093544,
                "title": "java-c-100-solution-using-depth-first-search-binary-tree-maximum-path-sum",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\npublic class Solution {\\n    int maxValue;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxValue = Integer.MIN_VALUE;\\n        maxPathDown(root);\\n        return maxValue;\\n    }\\n    \\n    private int maxPathDown(TreeNode node) {\\n        if (node == null) return 0;\\n        int left = Math.max(0, maxPathDown(node.left));\\n        int right = Math.max(0, maxPathDown(node.right));\\n\\n        maxValue = Math.max(maxValue, left + right + node.val);\\n        return Math.max(left, right) + node.val;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int res = INT_MIN;\\n    int solve(TreeNode* root){\\n        if(root)\\n        {   \\n            int left = max(0,solve(root->left));\\n            int right = max(0,solve(root->right));\\n\\n            res = max(res,root->val+left+right);\\n            return max(left,right)+root->val;\\n        }\\n        return 0;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        solve(root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```Java []\\npublic class Solution {\\n    int maxValue;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxValue = Integer.MIN_VALUE;\\n        maxPathDown(root);\\n        return maxValue;\\n    }\\n    \\n    private int maxPathDown(TreeNode node) {\\n        if (node == null) return 0;\\n        int left = Math.max(0, maxPathDown(node.left));\\n        int right = Math.max(0, maxPathDown(node.right));\\n\\n        maxValue = Math.max(maxValue, left + right + node.val);\\n        return Math.max(left, right) + node.val;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int res = INT_MIN;\\n    int solve(TreeNode* root){\\n        if(root)\\n        {   \\n            int left = max(0,solve(root->left));\\n            int right = max(0,solve(root->right));\\n\\n            res = max(res,root->val+left+right);\\n            return max(left,right)+root->val;\\n        }\\n        return 0;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        solve(root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045768,
                "title": "very-short-c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust simply check for left subtree and right subtree and keep updating the maximum sum .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt first we intiliaze our maxi by INT_MIN then check with left and right subtree\\'s data and current root\\'s data if its max update it .\\n\\n---\\n\\n\\n` int l=max(height(root->left,dis),0);`\\n - `is because we don\\'t want negative sum if there is negative node value then don\\'t take it or we should not explore that branch which gives overall negative sum and that means 0. So just take the sum if its +ve gain or take it 0 if its -ve`\\n\\n\\n---\\n\\n- `similarly for right subtree.` // ` int r=max(height(root->right,dis),0);`\\n- Then just update the the max_sum stored\\n     -  `dis=max(dis,l+r+root->val);`\\n- Then at last return  `max(l+root->val,r+root->val);` which starts recursive stack\\n# Complexity\\n- Time complexity:O(n) `Gotta Traverse n nodes`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) `Recusrive stack`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int height(TreeNode * root,int& dis){\\n       if(!root)return 0;\\n        int l=max(height(root->left,dis),0);\\n        int r=max(height(root->right,dis),0);\\n        dis=max(dis,l+r+root->val);\\n        return max(l+root->val,r+root->val);\\n   }\\n    int maxPathSum(TreeNode* root) {\\n        int dis=INT_MIN;\\n        height(root,dis);\\n        return dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int height(TreeNode * root,int& dis){\\n       if(!root)return 0;\\n        int l=max(height(root->left,dis),0);\\n        int r=max(height(root->right,dis),0);\\n        dis=max(dis,l+r+root->val);\\n        return max(l+root->val,r+root->val);\\n   }\\n    int maxPathSum(TreeNode* root) {\\n        int dis=INT_MIN;\\n        height(root,dis);\\n        return dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900900,
                "title": "simple-5-lines-dfs-solution-o-n-time-space",
                "content": "//upvote if helpful.\\n//thank you.\\n\\n# Approach\\nwe can see here we just need 5 values which are maximum value which we will get from my left child , maximum value which we will get from right child, we should add them to my value to return to my parent or just return my own value. I have commented the solution to get the understanding better.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root,int& ans){\\n        if(!root)return 0; //this is base case which is we have reached end of some path.\\n\\n        int lmax= dfs(root->left,  ans);// it will give me max value which i can get from my left child\\n        int rmax= dfs(root->right, ans);// it will give me max value which i can get from my right child\\n        ans= max({lmax+root->val, rmax+root->val, rmax+lmax+root->val, ans, root->val});// this is tricky because has 5 cases in total\\n        //1) should i take value coming from left child and add my value\\n        //2) should i take value coming from right child and add my value\\n        //3) or assume myself as root of that path then i have to take values coming from left+right and have to add mine too.\\n        //4) this is obvious\\n        //5)the path could contain myself only instead of taking left, right or my parent.\\n\\n        // now when i am returning my own max to my parent then \\n        //it will be my value+ either lmax or rmax because \\n        //if i am returning some value to my parent then it implies\\n        //that i am not root so we have to take either left or right.\\n        // and there is one more chance that both lmax, rmax are negative so i will return my value only.\\n        return max(root->val+max(lmax, rmax), root->val);\\n\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=root->val;\\n        //if(root->left==NULL && root->right==NULL)return root->val;\\n        int k= dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root,int& ans){\\n        if(!root)return 0; //this is base case which is we have reached end of some path.\\n\\n        int lmax= dfs(root->left,  ans);// it will give me max value which i can get from my left child\\n        int rmax= dfs(root->right, ans);// it will give me max value which i can get from my right child\\n        ans= max({lmax+root->val, rmax+root->val, rmax+lmax+root->val, ans, root->val});// this is tricky because has 5 cases in total\\n        //1) should i take value coming from left child and add my value\\n        //2) should i take value coming from right child and add my value\\n        //3) or assume myself as root of that path then i have to take values coming from left+right and have to add mine too.\\n        //4) this is obvious\\n        //5)the path could contain myself only instead of taking left, right or my parent.\\n\\n        // now when i am returning my own max to my parent then \\n        //it will be my value+ either lmax or rmax because \\n        //if i am returning some value to my parent then it implies\\n        //that i am not root so we have to take either left or right.\\n        // and there is one more chance that both lmax, rmax are negative so i will return my value only.\\n        return max(root->val+max(lmax, rmax), root->val);\\n\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=root->val;\\n        //if(root->left==NULL && root->right==NULL)return root->val;\\n        int k= dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481730,
                "title": "o-n-recursive-solution-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int max_so_far = INT_MIN;\\npublic:\\n    int dfs(TreeNode* root) {\\n        if(!root) {\\n            return 0;\\n        }\\n        // l & r -> give the maximum sum path in both subtrees\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n\\n        // max_till_now -> assure path won\\'t be discontinuous\\n        int max_till_now = max({ root->val, r + root->val, l + root->val });\\n\\n        // max_path_in_subtrees -> forms the max path b/w 2 leaf nodes, through current node\\n        int max_path_in_subtrees = root->val + l + r;\\n        \\n        // max_so_far -> maintains the max path\\n        max_so_far = max({ max_so_far, max_till_now, max_path_in_subtrees });\\n\\n        // return\\n        return max_till_now;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int p = dfs(root);\\n        return max_so_far;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int max_so_far = INT_MIN;\\npublic:\\n    int dfs(TreeNode* root) {\\n        if(!root) {\\n            return 0;\\n        }\\n        // l & r -> give the maximum sum path in both subtrees\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n\\n        // max_till_now -> assure path won\\'t be discontinuous\\n        int max_till_now = max({ root->val, r + root->val, l + root->val });\\n\\n        // max_path_in_subtrees -> forms the max path b/w 2 leaf nodes, through current node\\n        int max_path_in_subtrees = root->val + l + r;\\n        \\n        // max_so_far -> maintains the max path\\n        max_so_far = max({ max_so_far, max_till_now, max_path_in_subtrees });\\n\\n        // return\\n        return max_till_now;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int p = dfs(root);\\n        return max_so_far;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149399,
                "title": "deceptively-simple-problem-intuitive-java-solution-with-comments-beats-100",
                "content": "I felt the problem is deceptively simple, and very easy to get it wrong. Hence an intuitive answer is most helpful because you can possibly come up with this solution during interview without memorizing the approach!\\n\\nTwo main things to remember:\\n* This is a max path sum problem, not max subtree sum problem\\n* The value that is interesting for the current node may not be interesting for its parent, given the constraints of the problem\\n\\nI found the best way to solve this is to have a tracker that maintains maximum sum for every node visited. The tree is traversed post-order with each node returning path sum. The tracker is used to memorize the max path sum. The return value really is the path sum that the subtree rooted at the current node can contribute as path sum if the parent node decides to include it. This aspect is intuitive when you think about it, but it may not come to mind first time!\\n\\nThe time complexity of the code below is O(n) - every node is visited. Space complexity should be O(h) considering the recursion stack size.\\n\\n```\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root); // return value is not important in this function\\n        return maxSum;\\n    }\\n    \\n    private int helper(TreeNode node) {\\n        if (node == null) {\\n            return 0; // null node contributes nothing to the sum\\n        }\\n        \\n        // Postorder traversal\\n        int leftSum = helper(node.left);\\n        int rightSum = helper(node.right);\\n        \\n        int maxChildSum = Math.max(leftSum, rightSum);\\n        \\n        // We now need to compute three aspects:\\n        // Case 1: Max path is only the current node\\n        maxSum = Math.max(node.val, maxSum);\\n        // Case 2: the path includes node and both of its children\\n        maxSum = Math.max(node.val + leftSum + rightSum, maxSum);\\n        // Case 3: Path including Node and only one of the child\\n        maxSum = Math.max(node.val + maxChildSum, maxSum);\\n        \\n        // The question here is to find max path sum, and not max subtree sum\\n        // hence we return only a viable path sum to the parent node\\n        // Depending on the value of the nodes, this can either be the node itself, \\n        // or sum of the node and max of its children\\n        return Math.max(node.val, node.val + maxChildSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root); // return value is not important in this function\\n        return maxSum;\\n    }\\n    \\n    private int helper(TreeNode node) {\\n        if (node == null) {\\n            return 0; // null node contributes nothing to the sum\\n        }\\n        \\n        // Postorder traversal\\n        int leftSum = helper(node.left);\\n        int rightSum = helper(node.right);\\n        \\n        int maxChildSum = Math.max(leftSum, rightSum);\\n        \\n        // We now need to compute three aspects:\\n        // Case 1: Max path is only the current node\\n        maxSum = Math.max(node.val, maxSum);\\n        // Case 2: the path includes node and both of its children\\n        maxSum = Math.max(node.val + leftSum + rightSum, maxSum);\\n        // Case 3: Path including Node and only one of the child\\n        maxSum = Math.max(node.val + maxChildSum, maxSum);\\n        \\n        // The question here is to find max path sum, and not max subtree sum\\n        // hence we return only a viable path sum to the parent node\\n        // Depending on the value of the nodes, this can either be the node itself, \\n        // or sum of the node and max of its children\\n        return Math.max(node.val, node.val + maxChildSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101447,
                "title": "java-beats-100-easy-to-understand-solution-with-explanation-and-comments",
                "content": "/**\\n *Definition for a binary tree node.\\npublic class TreeNode {\\n \\xA0 int val;\\n TreeNode left;\\n TreeNode right;\\n  \\xA0 \\xA0 TreeNode() {}\\n TreeNode(int val) { this.val = val; }\\n TreeNode(int val, TreeNode left, TreeNode right) {\\n this.val = val;\\n this.left = left;\\n this.right = right;\\n }\\n}\\n */ \\n \\n \\n // Solution explanation\\n// In this solution we are doing postorder tranversal and finding maximum path sum for each node during traversal\\n\\n\\n// We need to take care of 3 test cases\\n// Case 1: The current node lies in the path of maximum sum \\n// Case 2: The current node is the root of maximum path sum\\n// Case 3: The current node doesn\\'t lie in the path of maximum sum \\n```\\n\\n```class Solution {\\n    // this variable is going to store maximum sum we have found \\n    int result= Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n       maxUtil( root);\\n          return result;\\n    }\\n    public int maxUtil(TreeNode root){\\n       \\n        if(root==null)\\n            return 0;\\n        // left & right variable is storing maximum path sum of left & right subtree\\n       int left=maxUtil(root.left);\\n       int right=maxUtil(root.right);\\n// checking for Case 1 here either we are coming from left subtree or right subtree in this case that\\'s why taking maximum of left & right \\n        int max1=Math.max(Math.max(left,right)+root.val,root.val);\\n        // checking for case 2 here and comparing it with previous case 1 value . In this case max sum is root\\'s value + left child value+ right child value \\n        int max2=Math.max(max1,left+right+root.val);\\n        // finally comparing the maximum sum we have got so far and updating its value checking case 3 as well \\n    \\n        result= Math.max(max2, result);\\n        return max1;\\n        \\n}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1044638,
                "title": "java-intuitive-0ms-100",
                "content": "```\\nclass Solution {\\n    int res = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        postTraverse(root);\\n        return res;\\n    }\\n    \\n    public int postTraverse(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        int leftMax = postTraverse(root.left);\\n        int rightMax = postTraverse(root.right);\\n        \\n        // Max of (root+left), (root+right), (root); \\n        //only max1 gets returned to it\\'s parent to make a single path along the parent node.\\n        int max1 = Math.max(Math.max(leftMax, rightMax)+root.val, root.val); \\n        \\n        // Max of (root+left), (root+right), (root), (root+left+right); \\n        // check if a subtree makes the max sum path.\\n        int max2 = Math.max(max1, leftMax + rightMax + root.val);\\n        \\n        res = Math.max(res, max2); \\n        \\n        return max1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        postTraverse(root);\\n        return res;\\n    }\\n    \\n    public int postTraverse(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        int leftMax = postTraverse(root.left);\\n        int rightMax = postTraverse(root.right);\\n        \\n        // Max of (root+left), (root+right), (root); \\n        //only max1 gets returned to it\\'s parent to make a single path along the parent node.\\n        int max1 = Math.max(Math.max(leftMax, rightMax)+root.val, root.val); \\n        \\n        // Max of (root+left), (root+right), (root), (root+left+right); \\n        // check if a subtree makes the max sum path.\\n        int max2 = Math.max(max1, leftMax + rightMax + root.val);\\n        \\n        res = Math.max(res, max2); \\n        \\n        return max1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013639,
                "title": "c-clean-short-simplest-solution-ever-faster-than-99-5",
                "content": "This question should be medium, not hard!\\n```\\nclass Solution {\\npublic:\\n    int rec(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        int left = max(rec(root->left), 0);\\n        int right = max(rec(root->right), 0);\\n        maxi = max(maxi, left+right+root->val);\\n        return max(left, right) + root->val;\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        rec(root);\\n        return maxi;\\n    }\\nprivate:\\n    int maxi = INT_MIN;\\n};\\n```\\n**Like it? Please upvote!!\\nHave any comments? I\\'d love to hear...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        int left = max(rec(root->left), 0);\\n        int right = max(rec(root->right), 0);\\n        maxi = max(maxi, left+right+root->val);\\n        return max(left, right) + root->val;\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        rec(root);\\n        return maxi;\\n    }\\nprivate:\\n    int maxi = INT_MIN;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769037,
                "title": "a-precise-recursive-dfs-solution-in-java-with-explanation",
                "content": "Algorithm for Problem: Since we have to find the maximum sum from some node in the binary tree to any node,we can use  a recursive bottom up approach to solve this problem. \\nWe have to consider the left child of every node and right child of every node then we need to find the current sum  that can be  calculated using basic logic.\\n**currentsum=Math.max((root.val+left),Math.max((root.val+right),Math.max(root.val,root.val+left+right)));\\nWe need to consider three cases:\\n1)The subtree sum of left child+right child +root value(subtree might be the maximu path).\\n2)The sum of left child and root value.\\n3)The sum of right child and root value.\\n4)We need to find the maximum of step 1,2,3.**\\n\\nAfter finding the current sum we need to compare it with maxsum,if it is less than maxsum then we do nothing,if it is greater than maxsum then we update maxsum to currentsum.\\n\\nMost Important process to whole algorithm is to get the return value form the function,this is a little bit tricky.\\nWe cannot return maxsum because it might contain the whole subtree(which might not be maxmium path) and we seek to find maximum path .\\nHere we define integer ret:\\n**ret=Math.max(root.val+left,Math.max(root.val+right,root.val));\\nValue to be returned we be either of the three:\\n1)Sum of Left child and Root value.\\n2)Sum of Right child and Root value.\\n3)Only root value.**\\n\\nSolution contains a print statement to demonstrate the flow of program, but is commented.\\n\\n\\n```\\nclass Solution {\\n    int maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        maxpath(root);\\n        return maxsum;\\n    }\\n    public int maxpath(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n        int left=maxpath(root.left);\\n        int right=maxpath(root.right);\\n        int currentsum=Math.max((root.val+left),Math.max((root.val+right),Math.max(root.val,root.val+left+right)));\\n        //System.out.println(\"left \"+left+\" right \"+right+\" currentsum \"+currentsum);\\n        maxsum=Math.max(maxsum,currentsum);\\n        int ret=Math.max(root.val+left,Math.max(root.val+right,root.val));\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        maxpath(root);\\n        return maxsum;\\n    }\\n    public int maxpath(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n        int left=maxpath(root.left);\\n        int right=maxpath(root.right);\\n        int currentsum=Math.max((root.val+left),Math.max((root.val+right),Math.max(root.val,root.val+left+right)));\\n        //System.out.println(\"left \"+left+\" right \"+right+\" currentsum \"+currentsum);\\n        maxsum=Math.max(maxsum,currentsum);\\n        int ret=Math.max(root.val+left,Math.max(root.val+right,root.val));\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684624,
                "title": "java-with-picture",
                "content": "\\nThanks [@wei-bung](https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/39775/Accepted-short-solution-in-Java)\\n\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_124_common.png)  \\n\\n\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_124_careful_with_return.png)  \\n\\n\\n``` java\\nclass Solution {\\n    \\n    int ans = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return ans;\\n    }\\n    \\n    private int helper(TreeNode root){\\n        \\n        // Base case.\\n        if (root == null) return 0;\\n        \\n        int left  = Math.max(0, helper(root.left));\\n        int right = Math.max(0, helper(root.right));\\n        int cur   = root.val + left + right;\\n        ans       = Math.max(ans, cur);\\n        // return cur;\\n        return Math.max(left, right) + root.val;\\n    }\\n}\\n```\\n\\n`Enjoy it ! `",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    \\n    int ans = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return ans;\\n    }\\n    \\n    private int helper(TreeNode root){\\n        \\n        // Base case.\\n        if (root == null) return 0;\\n        \\n        int left  = Math.max(0, helper(root.left));\\n        int right = Math.max(0, helper(root.right));\\n        int cur   = root.val + left + right;\\n        ans       = Math.max(ans, cur);\\n        // return cur;\\n        return Math.max(left, right) + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467723,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 16 ms, faster than 90.40% of Go online submissions for Binary Tree Maximum Path Sum.\\nMemory Usage: 6.7 MB, less than 100.00% of Go online submissions for Binary Tree Maximum Path Sum.\\n\\n```go\\nfunc maxPathSum(root *TreeNode) int {\\n    res := math.MinInt32\\n    helper(root, &res)\\n    return res\\n}\\n\\nfunc helper(node *TreeNode, res *int) int {\\n    if node == nil { return 0 }\\n    left := helper(node.Left, res)\\n    right := helper(node.Right, res)\\n    currentNodeNotAsRoot := max(max(left, right) + node.Val, node.Val)\\n    currentNodeAsRoot := max(currentNodeNotAsRoot, left + right + node.Val)\\n    *res = max(*res, currentNodeAsRoot)\\n    return currentNodeNotAsRoot\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maxPathSum(root *TreeNode) int {\\n    res := math.MinInt32\\n    helper(root, &res)\\n    return res\\n}\\n\\nfunc helper(node *TreeNode, res *int) int {\\n    if node == nil { return 0 }\\n    left := helper(node.Left, res)\\n    right := helper(node.Right, res)\\n    currentNodeNotAsRoot := max(max(left, right) + node.Val, node.Val)\\n    currentNodeAsRoot := max(currentNodeNotAsRoot, left + right + node.Val)\\n    *res = max(*res, currentNodeAsRoot)\\n    return currentNodeNotAsRoot\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340521,
                "title": "my-java-solution",
                "content": "We need to figure out 3 things to solve this problem. \\nSuppose we are on one tree node,\\n**1. what do we want from left subtree and right subtree.**\\nWe need to know max sum from two children. And if sum < 0, we must left it be 0 to eliminate its negative effect because we want the max sum path. This is very important.\\n```\\n\\tint left = Math.max(0, dfs(root.left));\\n\\tint right = Math.max(0, dfs(root.right));\\n```\\n**2. What do we want to do in the current layer**\\nWe want to add leftSum, rightSum and the node value up. This is a sum path from one leaf node to another leaf node. So we need to get the global_max like\\n```\\n\\tglobal_max = Math.max(global_max, left + right + root.val);\\n```\\n**3. What value we want to return to our parent node.**\\nWhat we want to return is not the full sum path. It\\'s the max path from root to one leaf node. So, we need to return\\n```\\n\\treturn Math.max(left, right) + root.val;\\n```\\nMy code is shown below:\\n```\\nclass Solution {\\n    int global_max;\\n    public int maxPathSum(TreeNode root) {\\n        global_max = Integer.MIN_VALUE;\\n        dfs(root);\\n\\t    return global_max;\\n}\\nprivate int dfs(TreeNode root){\\n\\tif (root == null){\\n\\t\\treturn 0;\\n\\t}\\n\\tint left = Math.max(0, dfs(root.left));\\n\\tint right = Math.max(0, dfs(root.right));\\n\\tif (root.left != null && root.right != null){\\n\\t\\tglobal_max = Math.max(global_max, left + right + root.val);\\n\\t\\treturn Math.max(left, right) + root.val;\\n\\t}\\n\\tif (root.left == null){\\n\\t\\tglobal_max = Math.max(global_max, right + root.val);\\n\\t\\treturn right + root.val;\\n\\t}\\t\\n\\telse {\\n\\t\\tglobal_max = Math.max(global_max, left + root.val);\\n\\t\\treturn  left + root.val;\\n\\t}\\n}\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint left = Math.max(0, dfs(root.left));\\n\\tint right = Math.max(0, dfs(root.right));\\n```\n```\\n\\tglobal_max = Math.max(global_max, left + right + root.val);\\n```\n```\\n\\treturn Math.max(left, right) + root.val;\\n```\n```\\nclass Solution {\\n    int global_max;\\n    public int maxPathSum(TreeNode root) {\\n        global_max = Integer.MIN_VALUE;\\n        dfs(root);\\n\\t    return global_max;\\n}\\nprivate int dfs(TreeNode root){\\n\\tif (root == null){\\n\\t\\treturn 0;\\n\\t}\\n\\tint left = Math.max(0, dfs(root.left));\\n\\tint right = Math.max(0, dfs(root.right));\\n\\tif (root.left != null && root.right != null){\\n\\t\\tglobal_max = Math.max(global_max, left + right + root.val);\\n\\t\\treturn Math.max(left, right) + root.val;\\n\\t}\\n\\tif (root.left == null){\\n\\t\\tglobal_max = Math.max(global_max, right + root.val);\\n\\t\\treturn right + root.val;\\n\\t}\\t\\n\\telse {\\n\\t\\tglobal_max = Math.max(global_max, left + root.val);\\n\\t\\treturn  left + root.val;\\n\\t}\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321667,
                "title": "swift-o-n-linear-recursive-solution",
                "content": "```\\nclass Solution {\\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        var result: Int = 0;\\n        if root != nil {\\n            result = root!.val\\n            maxPathSumHelper(root, &result)\\n        }\\n        return result\\n    }\\n    \\n    func maxPathSumHelper(_ root: TreeNode?, _ result: inout Int) -> Int {\\n        \\n        guard let root = root else { return 0 }\\n        \\n        var leftCost = maxPathSumHelper(root.left, &result)\\n        if leftCost < 0 { leftCost = 0 }\\n        \\n        var rightCost = maxPathSumHelper(root.right, &result)\\n        if rightCost < 0 { rightCost = 0 }\\n        \\n        var val = root.val + leftCost + rightCost\\n        if val > result { result = val }\\n        \\n        return root.val + max(leftCost, rightCost)\\n    }\\n    \\n}\\n```\\n\\nThe main difficulty with this question is understanding what \"path\" means at each recursion level. For calculating the max possible path, we can take into consideration the current node AND (none, one, or both children). For calculating the return value, we are focusing on a sub-path, which means there would be a fork in our path - basically, we can only pick one child as our max path to return to a parent, which will count both directional children of its max computation... \\n\\nThink of the max/result computation as independent from the return value, because it is...",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        var result: Int = 0;\\n        if root != nil {\\n            result = root!.val\\n            maxPathSumHelper(root, &result)\\n        }\\n        return result\\n    }\\n    \\n    func maxPathSumHelper(_ root: TreeNode?, _ result: inout Int) -> Int {\\n        \\n        guard let root = root else { return 0 }\\n        \\n        var leftCost = maxPathSumHelper(root.left, &result)\\n        if leftCost < 0 { leftCost = 0 }\\n        \\n        var rightCost = maxPathSumHelper(root.right, &result)\\n        if rightCost < 0 { rightCost = 0 }\\n        \\n        var val = root.val + leftCost + rightCost\\n        if val > result { result = val }\\n        \\n        return root.val + max(leftCost, rightCost)\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306274,
                "title": "actually-reabable-python-with-explanation-14-lines",
                "content": "**Idea**:\\n1) The first and most imporant insight here is a path, as defined formally in the question, can only **cross the two subtrees at most once in the entire path**.  \\n```\\n   -10\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\n```\\n**E.g. Once we have path [15,20,7], we can never have a path that includes 20 and any of its ancestor together. Because in those paths, we will be touching 20 more than once and that would not be a legal path. For instance, had -10 and 20 been included together on the same path, there\\'s no way to touch every node of the subtree rooted at 20 without touching 20 twice.**\\n\\n**When we include a root node of a tree, I call it *crossing the subtrees* (imagine crossing left subtree into right subtree).**\\n\\n2) The second insight is just that there are two kinds of sums - a) the sum you get by crossing some pair of subtrees b) the sum you get by not crossing any pair of subtrees.\\n\\nIn the code, for each node, I call the sum you get crossing the subtrees max_ex (for max_extensible because you could choose to extend this sum by crossing subtrees when we get to its ancestors) and the max_nonex (for max_nonextensible). \\n\\nThen everything follows from these definitions/worldviews.\\na) (max_ex, again, the sum by going on a straight path, no crossing subtrees) max_ex is defined to be the max of i) root.val (straight path of 1 node) and ii) results of subproblems\\nb) max_nonex is defined to be i) max_ex (for the optimal result could be a straight path from current node to one of its descendent and we just don\\'t extend it for reasons like maybe ancestors are negative as in our example), ii) root.val + max_left_ex + max_right_ex (for extending and crossing the subtrees) and finally iii) results of the subproblems.\\n\\nSee everything in action, a modified diagram of max_ex and max_nonex next to each node.val:\\n```\\nformat: node.val (max_ex, max_nonex)\\n   -10 (25,42)\\n   /           \\\\\\n  9 (9,9) 20 (35,42)\\n    /              \\\\\\n   15 (15,15)  7 (7,7)\\n```\\n\\nNote:\\nThis writing is one of my first few writings on Leetcode, I\\'d love to get some feedback from you and keep improving and shareing my thoughts. My focus is try to explain what may be confusing in other explanations as simply as possible while keeping the insights I had while coding. Because at the end of the day, it\\'s these insights that help us solve these problems. \\n\\nPlease don\\'t feel frustrated or give up if you don\\'t understand as my writing could\\'ve been confusing. Do try focus on the above example I provided here. Please provide feedback, leave a comment, and I will try my best to get back to you. \\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        return max(self.exten_and_nonexten_sum(root))\\n    def exten_and_nonexten_sum(self, root: TreeNode) -> int:\\n        if not root:\\n            return (float(\\'-inf\\'), float(\\'-inf\\'))\\n        max_left_ex, max_left_nonex = self.exten_and_nonexten_sum(root.left)\\n        max_right_ex, max_right_nonex = self.exten_and_nonexten_sum(root.right)\\n        max_ex = max(root.val, root.val + max_left_ex, root.val + max_right_ex)\\n        max_nonex = max(\\n            max_ex,\\n            root.val + max_left_ex + max_right_ex,\\n            max_left_nonex,\\n            max_right_nonex)\\n        return (max_ex, max_nonex)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n   -10\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\n```\n```\\nformat: node.val (max_ex, max_nonex)\\n   -10 (25,42)\\n   /           \\\\\\n  9 (9,9) 20 (35,42)\\n    /              \\\\\\n   15 (15,15)  7 (7,7)\\n```\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        return max(self.exten_and_nonexten_sum(root))\\n    def exten_and_nonexten_sum(self, root: TreeNode) -> int:\\n        if not root:\\n            return (float(\\'-inf\\'), float(\\'-inf\\'))\\n        max_left_ex, max_left_nonex = self.exten_and_nonexten_sum(root.left)\\n        max_right_ex, max_right_nonex = self.exten_and_nonexten_sum(root.right)\\n        max_ex = max(root.val, root.val + max_left_ex, root.val + max_right_ex)\\n        max_nonex = max(\\n            max_ex,\\n            root.val + max_left_ex + max_right_ex,\\n            max_left_nonex,\\n            max_right_nonex)\\n        return (max_ex, max_nonex)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179498,
                "title": "recursion-thinking-process",
                "content": ">Each node can be the root of the final Maximum Path Sum - root here means the topmost node in a path.\\n\\n>We calculate Maximum Path Sum rooted at each node and update `maxSum`  on the fly.\\n\\n>Maximum Path Sum rooted at a node = \\n```\\nmax(maxPathSumFrom(node.left), 0) + max(maxPathSumFrom(node.right), 0) + node.val)\\n// Pay attention to how 0-trick saves tedious comparison.\\n```\\n\\n> getDownwardPathSum(node) =\\n```\\nmax(maxPathSumFrom(node.left), maxPathSumFrom(node.right)) + node.val\\n```\\n\\n****\\n```\\n    private int maxSum;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        maxPathSumFrom(root);\\n        return maxSum;\\n    }\\n    \\n    private int maxPathSumFrom(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        int left = Math.max(0, maxPathSumFrom(root.left));\\n        int right = Math.max(0, maxPathSumFrom(root.right));\\n        \\n        maxSum = Math.max(maxSum, left + right + root.val);\\n        \\n        return Math.max(left, right) + root.val;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nmax(maxPathSumFrom(node.left), 0) + max(maxPathSumFrom(node.right), 0) + node.val)\\n// Pay attention to how 0-trick saves tedious comparison.\\n```\n```\\nmax(maxPathSumFrom(node.left), maxPathSumFrom(node.right)) + node.val\\n```\n```\\n    private int maxSum;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        maxPathSumFrom(root);\\n        return maxSum;\\n    }\\n    \\n    private int maxPathSumFrom(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        int left = Math.max(0, maxPathSumFrom(root.left));\\n        int right = Math.max(0, maxPathSumFrom(root.right));\\n        \\n        maxSum = Math.max(maxSum, left + right + root.val);\\n        \\n        return Math.max(left, right) + root.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39851,
                "title": "simple-recursive-yet-still-accepted-as-best-in-cpp",
                "content": "    class Solution {\\n    private:\\n        int traverse(TreeNode* root, int& maxSum)\\n        {\\n            if(!root) return 0;\\n            int lMax = max(0, traverse(root->left, maxSum));\\n            int rMax = max(0, traverse(root->right, maxSum));\\n            maxSum = max(maxSum, lMax+rMax+root->val);\\n            return max(lMax, rMax)+root->val;\\n        }\\n    public:\\n        int maxPathSum(TreeNode* root) {\\n            int maxSum = INT_MIN;\\n            traverse(root, maxSum);\\n            return maxSum;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    private:\\n        int traverse(TreeNode* root, int& maxSum)\\n        {\\n            if(!root) return 0;\\n            int lMax = max(0, traverse(root->left, maxSum));\\n            int rMax = max(0, traverse(root->right, maxSum));\\n            maxSum = max(maxSum, lMax+rMax+root->val);\\n            return max(lMax, rMax)+root->val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3998373,
                "title": "a-dynamic-programming-dp-approach-images-c-simple-intuitive-100-runtime-90-memory",
                "content": "# Intuition\\nWhen faced with a problem like finding the maximum sum binary tree path, it\\'s tempting to draw parallels with familiar algorithms like the maximum sum subarray problem. However, in this case, we don\\'t have a simple array to work with. Instead, we\\'re dealing with a binary tree. The question arises: can we transform the tree into an array and then apply a 1D dynamic programming approach? The answer is not straightforward. Consider the following counterexample:\\n`[1,-2,-3,1,3,-2,null,-1]`\\n\\n![Screenshot 2023-09-03 at 13.33.41.png](https://assets.leetcode.com/users/images/95804efb-eb89-4544-b6a7-2401a8d0174d_1693762433.8614566.png)\\n\\nIn the inorder traversal of this tree `[-1,1,-2,3,1,-3,-2]`, the numbers 1 and 3 are adjacent. However, they do not form a valid path in the tree.\\n\\nNevertheless, the essence of the idea is promising. For calculating the maximum subarray sum, we can use the dynamic programming formula:\\n`dp[i] = max(dp[i - 1] + arr[i], arr[i])`\\n\\nIn our case, we have more options than just considering the previous element, and we must account for the \"path\" nature of the problem.\\n\\n# Approach\\nLet\\'s define our dynamic programming (DP) for the current node. We want to calculate the maximum path sum that includes the current node as the root. Logically, it can be expressed as:\\n```\\ndp[curr_node] = max(\\n    dp[left_child] + curr_val, \\n    dp[right_child] + curr_val, \\n    curr_val\\n)\\n```\\n\\nWe have three choices: either take the left subtree sum and add the current node\\'s value, or take the right subtree sum and add the current node\\'s value, or ignore both subtrees and just take the current node\\'s value.\\n\\nHowever, there are two significant problems with this solution so far:\\n\\n- We don\\'t know how to calculate dp[node] because there is no unique way to define a node (values are not guaranteed to be unique).\\n- The solution only supports paths that start in a specific node as their left or right subtree, while the path may lead from any node to any other node.\\n\\n![1.png](https://assets.leetcode.com/users/images/008a6416-ca3b-45b4-b365-414a5560b250_1693763460.2434177.png)\\n\\nLet\\'s address the second problem first. Every time we calculate `dp[curr_node]`, we can also compute the `ans`, which represents the best answer seen so far (the maximum path sum up to that point). To accommodate paths that don\\'t necessarily start from a specific node, we modify our answer calculation as follows:\\n```\\nans = max(ans, dp[curr_node], dp[left_child] + curr_val + dp[right_child])\\n```\\n\\nNow what about `dp[curr_node]`? Well, we have `node.val` for every node, and we do not have a requirement on keeping this value after the function execution. So we can use this `node.val` as our `dp[curr_node]`:\\n```\\ncurr.val = max(curr.val, max(left + curr.val, right + curr.val));\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - we simply do tree traversal (dfs)\\n\\n- Space complexity:\\n$$O(n)$$ - because of the recursive approach, we could also do that in $$O(1)$$ rewriting in iterative way.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    const int INF = 1e9;\\n    int ans = -1e9;\\n\\n    // dp for current node is max(left + curr, right + curr, left + right + curr, curr);\\n\\n    int dfs(TreeNode *curr) {\\n        if (curr == NULL) return -INF;\\n\\n        int left = dfs(curr->left);\\n        int right = dfs(curr->right);\\n\\n        int cval = curr->val;\\n        curr->val = std::max(\\n            cval,\\n            std::max(left + cval, right + cval)\\n        );\\n\\n        ans = std::max(std::max(ans, curr->val), left + cval + right);\\n\\n        return curr->val;\\n    }\\n\\n    int maxPathSum(TreeNode* curr) {\\n        int res = dfs(curr);\\n        return std::max(res, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\ndp[curr_node] = max(\\n    dp[left_child] + curr_val, \\n    dp[right_child] + curr_val, \\n    curr_val\\n)\\n```\n```\\nans = max(ans, dp[curr_node], dp[left_child] + curr_val + dp[right_child])\\n```\n```\\ncurr.val = max(curr.val, max(left + curr.val, right + curr.val));\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    const int INF = 1e9;\\n    int ans = -1e9;\\n\\n    // dp for current node is max(left + curr, right + curr, left + right + curr, curr);\\n\\n    int dfs(TreeNode *curr) {\\n        if (curr == NULL) return -INF;\\n\\n        int left = dfs(curr->left);\\n        int right = dfs(curr->right);\\n\\n        int cval = curr->val;\\n        curr->val = std::max(\\n            cval,\\n            std::max(left + cval, right + cval)\\n        );\\n\\n        ans = std::max(std::max(ans, curr->val), left + cval + right);\\n\\n        return curr->val;\\n    }\\n\\n    int maxPathSum(TreeNode* curr) {\\n        int res = dfs(curr);\\n        return std::max(res, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813082,
                "title": "java-easy-solution-full-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize a `maxValue` array to store our final answer.\\n- Do a simple tree traversal. At each node, find  recursively its `leftMaxPath` and its `rightMaxPath`.\\n- Calculate the maxPath through the node as `val + (leftMaxPath + rightMaxPath)` and update maxi accordingly.\\n- Return the maxPath when node is not the curving point as `val + max(leftMaxPath, rightMaxPath)`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int maxPathSum(TreeNode root) {\\n      int maxValue[] = new int[1];\\n      maxValue[0] = Integer.MIN_VALUE;\\n      helper(root, maxValue);\\n      return maxValue[0];\\n    }\\n  int helper(TreeNode root, int[] maxValue) {\\n    if(root == null) return 0;\\n    int left = Math.max(helper(root.left, maxValue), 0);\\n    int right = Math.max(helper(root.right, maxValue), 0);  \\n    \\n    maxValue[0] = Math.max(maxValue[0], root.val + left + right);\\n    return root.val + Math.max(left, right);\\n  }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int maxPathSum(TreeNode root) {\\n      int maxValue[] = new int[1];\\n      maxValue[0] = Integer.MIN_VALUE;\\n      helper(root, maxValue);\\n      return maxValue[0];\\n    }\\n  int helper(TreeNode root, int[] maxValue) {\\n    if(root == null) return 0;\\n    int left = Math.max(helper(root.left, maxValue), 0);\\n    int right = Math.max(helper(root.right, maxValue), 0);  \\n    \\n    maxValue[0] = Math.max(maxValue[0], root.val + left + right);\\n    return root.val + Math.max(left, right);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718407,
                "title": "binary-tree-maximum-path-sum-leetcode",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, int &maxi){\\n        // base case:-\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int left = max(solve(root -> left, maxi), 0);\\n        int right = max(solve(root -> right, maxi), 0);\\n\\n        maxi = max(maxi, left + right + root -> val);\\n        return max(left,right) + root -> val;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        // base case:-\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int maxi = INT_MIN;\\n        int ans = solve(root,maxi);\\n        return max(maxi,ans);\\n    }\\n// By ~ Shubham Verma\\n};\\n```\\n![7cfadaec-4ab3-45e4-9ad8-313c2db992f9_1678433858.6366765.png](https://assets.leetcode.com/users/images/a89c7575-9822-4560-9cbc-50f4ffa8b753_1688490238.7928553.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, int &maxi){\\n        // base case:-\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int left = max(solve(root -> left, maxi), 0);\\n        int right = max(solve(root -> right, maxi), 0);\\n\\n        maxi = max(maxi, left + right + root -> val);\\n        return max(left,right) + root -> val;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        // base case:-\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int maxi = INT_MIN;\\n        int ans = solve(root,maxi);\\n        return max(maxi,ans);\\n    }\\n// By ~ Shubham Verma\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702811,
                "title": "a-simple-accepted-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int maxPathSumHelper(TreeNode* root, int& res) {\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n        \\n        int leftSum = maxPathSumHelper(root->left, res);\\n        int rightSum = maxPathSumHelper(root->right, res);\\n        \\n        int maxChildSum = max(leftSum, rightSum);\\n        \\n        int maxRootSum = max(maxChildSum + root->val, root->val);\\n        int maxTreeSum = max(maxRootSum, leftSum + rightSum + root->val);\\n        \\n        res = max(res, maxTreeSum);\\n        \\n        return maxRootSum;\\n    }\\n    \\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res = INT_MIN;\\n        maxPathSumHelper(root, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int maxPathSumHelper(TreeNode* root, int& res) {\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n        \\n        int leftSum = maxPathSumHelper(root->left, res);\\n        int rightSum = maxPathSumHelper(root->right, res);\\n        \\n        int maxChildSum = max(leftSum, rightSum);\\n        \\n        int maxRootSum = max(maxChildSum + root->val, root->val);\\n        int maxTreeSum = max(maxRootSum, leftSum + rightSum + root->val);\\n        \\n        res = max(res, maxTreeSum);\\n        \\n        return maxRootSum;\\n    }\\n    \\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res = INT_MIN;\\n        maxPathSumHelper(root, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693478,
                "title": "100-beats-cpp-c-code-tc-o-n-easy-code-dfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int solve(TreeNode* root, int &maxi){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int lefti=max(0,solve(root->left,maxi));\\n        int righti=max(0,solve(root->right,maxi));\\n        // int op1=max(lefti,righti);\\n        // int op2=max(lefti+root->val,righti+root->val);\\n        // int op3=root->val+lefti+righti;\\n        // maxi=max(op1,max(op2,op3));\\n        // return maxi;\\n        maxi=max(maxi,lefti+righti+root->val);\\n        return max(lefti,righti)+root->val;\\n\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int maxi=INT_MIN;\\n        int result=solve(root,maxi);\\n        return max(maxi,result);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int solve(TreeNode* root, int &maxi){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int lefti=max(0,solve(root->left,maxi));\\n        int righti=max(0,solve(root->right,maxi));\\n        // int op1=max(lefti,righti);\\n        // int op2=max(lefti+root->val,righti+root->val);\\n        // int op3=root->val+lefti+righti;\\n        // maxi=max(op1,max(op2,op3));\\n        // return maxi;\\n        maxi=max(maxi,lefti+righti+root->val);\\n        return max(lefti,righti)+root->val;\\n\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int maxi=INT_MIN;\\n        int result=solve(root,maxi);\\n        return max(maxi,result);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645311,
                "title": "c-easy-and-crisp-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxsum(TreeNode* root, int & maxi){\\n        if(!root) return 0;\\n        int l=max(maxsum(root->left,maxi),0);\\n        int r=max(maxsum(root->right,maxi),0);\\n        maxi=max(maxi,root->val+l+r);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root){\\n        int maxi=INT_MIN;\\n        maxsum(root,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxsum(TreeNode* root, int & maxi){\\n        if(!root) return 0;\\n        int l=max(maxsum(root->left,maxi),0);\\n        int r=max(maxsum(root->right,maxi),0);\\n        maxi=max(maxi,root->val+l+r);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root){\\n        int maxi=INT_MIN;\\n        maxsum(root,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169589,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res = INT_MIN;\\n        find_max(root, res);\\n        return res;\\n    }\\n\\n    int find_max(TreeNode* root, int& res) {\\n        if (root == nullptr) return 0;\\n\\n        int left_max = find_max(root->left, res);\\n        int right_max = find_max(root->right, res);\\n\\n        int sum = root->val;\\n        if (left_max > 0) sum += left_max;\\n        if (right_max > 0) sum += right_max;\\n        if (sum > res) res = sum;\\n\\n        int root_max = root->val;\\n        root_max += max(0, max(left_max, right_max));\\n        return root_max;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        self.sum = root.val\\n        def maxHelper( root: Optional[TreeNode]) -> int:\\n            l, r = 0, 0\\n            if root.left != None:\\n                l += maxHelper(root.left)\\n            if root.right != None:\\n                r += maxHelper(root.right)\\n\\n            sum1, sum2 = root.val, root.val\\n            if l > 0:\\n                sum1 += l\\n            if r > 0:\\n                sum1 += r\\n            \\n            if l > 0 or r > 0:\\n                sum2 += l if l > r else r\\n\\n            self.sum = sum2 if self.sum < sum2 else self.sum\\n            self.sum = sum1 if self.sum < sum1 else self.sum\\n            return sum2\\n        if root:\\n            maxHelper(root)\\n        return self.sum\\n```\\n\\n```Java []\\nclass Solution {\\n\\n    int ans = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxPathSumHelper(root);\\n        return ans;\\n    }\\n\\n    public int maxPathSumHelper(TreeNode root) {\\n\\n         if(root == null) return 0;\\n         int left = maxPathSumHelper(root.left);\\n         int right = maxPathSumHelper(root.right);\\n         int max = Math.max(root.val, Math.max(Math.max(root.val+left, root.val+right), root.val+left+right)); \\n         ans = Math.max(ans, max);\\n        return Math.max(root.val, Math.max(root.val+left, root.val+right));\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res = INT_MIN;\\n        find_max(root, res);\\n        return res;\\n    }\\n\\n    int find_max(TreeNode* root, int& res) {\\n        if (root == nullptr) return 0;\\n\\n        int left_max = find_max(root->left, res);\\n        int right_max = find_max(root->right, res);\\n\\n        int sum = root->val;\\n        if (left_max > 0) sum += left_max;\\n        if (right_max > 0) sum += right_max;\\n        if (sum > res) res = sum;\\n\\n        int root_max = root->val;\\n        root_max += max(0, max(left_max, right_max));\\n        return root_max;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        self.sum = root.val\\n        def maxHelper( root: Optional[TreeNode]) -> int:\\n            l, r = 0, 0\\n            if root.left != None:\\n                l += maxHelper(root.left)\\n            if root.right != None:\\n                r += maxHelper(root.right)\\n\\n            sum1, sum2 = root.val, root.val\\n            if l > 0:\\n                sum1 += l\\n            if r > 0:\\n                sum1 += r\\n            \\n            if l > 0 or r > 0:\\n                sum2 += l if l > r else r\\n\\n            self.sum = sum2 if self.sum < sum2 else self.sum\\n            self.sum = sum1 if self.sum < sum1 else self.sum\\n            return sum2\\n        if root:\\n            maxHelper(root)\\n        return self.sum\\n```\n```Java []\\nclass Solution {\\n\\n    int ans = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxPathSumHelper(root);\\n        return ans;\\n    }\\n\\n    public int maxPathSumHelper(TreeNode root) {\\n\\n         if(root == null) return 0;\\n         int left = maxPathSumHelper(root.left);\\n         int right = maxPathSumHelper(root.right);\\n         int max = Math.max(root.val, Math.max(Math.max(root.val+left, root.val+right), root.val+left+right)); \\n         ans = Math.max(ans, max);\\n        return Math.max(root.val, Math.max(root.val+left, root.val+right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042357,
                "title": "postorder-traversal-solution-with-pair-int-int-approach",
                "content": "# Intuition\\nIn this question we have to return maximum the sum of path between any 2 node. So, if we are present at root we have to compare between 3 entity :\\n1. Max path sum in left subtree(if exist).\\n2. Max path sum in right subtree(if exist).\\n3. sum of left, right subtree from node to root with root.\\n\\n# Approach\\nTake helper function pathSum with return type pair<int, int> where first int store the maximum path sum between any two node in a tree and second int store the maximum path sum of any node from the root node either from the left sub tree or right subtree. \\n\\n# Complexity\\n- Time complexity:\\nO(n) : As it traverse all nodes\\n\\n- Space complexity:\\nO(n) : if tree is skew tree.\\nO(logn) : if tree is a binary tree.\\n\\n# Abbreviation\\n\\n1. lpsum : maximum path sum exist between any 2 nodes in left subtree\\n2. rpsum : maximum path sum exist between any 2 nodes in right subtree\\n3. lsum : maximum sum from node to root in left subtree.\\n4. rsum : maximum sum from node to root in right subtree.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int, int> pathSum(TreeNode* root){\\n        if(root == NULL){\\n            return {INT_MIN, INT_MIN};\\n        }\\n        pair<int, int> leftchild = pathSum(root->left);\\n        pair<int, int> rightchild = pathSum(root->right);\\n        int lpsum = leftchild.first;\\n        int lsum = leftchild.second;\\n        int rpsum = rightchild.first;\\n        int rsum = rightchild.second;\\n        // if leftsum or rightsum is less than 0 then initialise as zero as we don\\'t include that path in it\\n        if(lsum < 0){\\n            lsum = 0;\\n        }\\n        if(rsum < 0){\\n            rsum = 0;\\n        }\\n        int valu = lsum+rsum+root->val;\\n        int maxpsum = max(lpsum, max(rpsum, valu));\\n        return {maxpsum, max(lsum,rsum)+root->val};\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        pair<int, int> ans = pathSum(root);\\n        return ans.first;\\n    }\\n};\\n```\\n\\nPlease do UPVOTE if you like it !!",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> pathSum(TreeNode* root){\\n        if(root == NULL){\\n            return {INT_MIN, INT_MIN};\\n        }\\n        pair<int, int> leftchild = pathSum(root->left);\\n        pair<int, int> rightchild = pathSum(root->right);\\n        int lpsum = leftchild.first;\\n        int lsum = leftchild.second;\\n        int rpsum = rightchild.first;\\n        int rsum = rightchild.second;\\n        // if leftsum or rightsum is less than 0 then initialise as zero as we don\\'t include that path in it\\n        if(lsum < 0){\\n            lsum = 0;\\n        }\\n        if(rsum < 0){\\n            rsum = 0;\\n        }\\n        int valu = lsum+rsum+root->val;\\n        int maxpsum = max(lpsum, max(rpsum, valu));\\n        return {maxpsum, max(lsum,rsum)+root->val};\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        pair<int, int> ans = pathSum(root);\\n        return ans.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900629,
                "title": "c-stacks-and-queue-modifying-tree-value",
                "content": "# Intuition\\nStart from bottom.\\nAt a node, there are 3 options:\\n* Choose the left path (left sum - lc)\\n* Choose the right path (right sum - rc)\\n* Choosing none (0)\\n\\nThe path is selected by checking the maximum value of these 3 options.\\nAdding the sum to node\\'s value acts like selecting a maximum sum path.\\n\\nBends can be handled easily just by adding left value , right value and node value for the node.\\n\\nThe maximum of all values for all nodes is our answer.\\n\\n# Approach\\nStore the nodes in a stack in level wise order (Bottom first and right to left)\\nPop and store elements from this stack. Make a variable that stores the sum of paths that have bends in them.\\nUpdate the node\\'s value by adding the larger of left path sum and right path sum(making sure new value is a greater value). \\nThe new result will be maximum of bended value, the node value and old result.\\n\\nWhen the stack is finished, res will return the maximum path sum.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        queue<TreeNode*> level;\\n        level.push(root);\\n        while(!level.empty()){\\n            TreeNode* temp = level.front();\\n            level.pop();\\n            st.push(temp);\\n            if(temp->left){\\n                level.push(temp->left);\\n            }\\n            if(temp->right){\\n                level.push(temp->right);\\n            }\\n        }\\n        int res=INT_MIN;\\n        while(!st.empty()){\\n            TreeNode* temp = st.top();\\n            st.pop();\\n            int lc = temp->left? temp->left->val : 0;\\n            int rc = temp->right? temp->right->val : 0;\\n            int bend = lc + rc + temp->val;\\n            temp->val += max(0,max(lc,rc));\\n            res = max(bend,max(res,temp->val));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        queue<TreeNode*> level;\\n        level.push(root);\\n        while(!level.empty()){\\n            TreeNode* temp = level.front();\\n            level.pop();\\n            st.push(temp);\\n            if(temp->left){\\n                level.push(temp->left);\\n            }\\n            if(temp->right){\\n                level.push(temp->right);\\n            }\\n        }\\n        int res=INT_MIN;\\n        while(!st.empty()){\\n            TreeNode* temp = st.top();\\n            st.pop();\\n            int lc = temp->left? temp->left->val : 0;\\n            int rc = temp->right? temp->right->val : 0;\\n            int bend = lc + rc + temp->val;\\n            temp->val += max(0,max(lc,rc));\\n            res = max(bend,max(res,temp->val));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900612,
                "title": "c-begineer-friendly-easy-understanding-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/IIn-jtjniXw\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int sum =INT_MIN;\\n\\n    int maxPathSum(TreeNode* root) {\\n\\n        calcualteMaxPathSum(root);\\n        return sum;\\n\\n    }\\n    // max sum path including root of the tree.\\n    int calcualteMaxPathSum(TreeNode* root){\\n        if(root == NULL) return 0;\\n\\n        //if lhsum is comming -ve so we will return 0;\\n\\n      int  lhsum = max(0,calcualteMaxPathSum(root->left));\\n      int  rhsum = max(0,calcualteMaxPathSum(root->right));\\n\\n\\n        //updating the value in the sum.. // maximum sum upto now.(can be subtree sum)\\n        sum = max(sum,root->val+lhsum+rhsum);\\n\\n\\n        //returning the maxximum sum possible.. using which path.\\n        return max(lhsum,rhsum) + root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int sum =INT_MIN;\\n\\n    int maxPathSum(TreeNode* root) {\\n\\n        calcualteMaxPathSum(root);\\n        return sum;\\n\\n    }\\n    // max sum path including root of the tree.\\n    int calcualteMaxPathSum(TreeNode* root){\\n        if(root == NULL) return 0;\\n\\n        //if lhsum is comming -ve so we will return 0;\\n\\n      int  lhsum = max(0,calcualteMaxPathSum(root->left));\\n      int  rhsum = max(0,calcualteMaxPathSum(root->right));\\n\\n\\n        //updating the value in the sum.. // maximum sum upto now.(can be subtree sum)\\n        sum = max(sum,root->val+lhsum+rhsum);\\n\\n\\n        //returning the maxximum sum possible.. using which path.\\n        return max(lhsum,rhsum) + root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899155,
                "title": "javascript-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function (root) {\\n  const ans = { val: -Infinity };\\n  dfs(root, ans);\\n\\n  return ans.val;\\n};\\n\\nfunction dfs(root, ans) {\\n  if (!root) return 0;\\n\\n  const left = dfs(root.left, ans);\\n  const right = dfs(root.right, ans);\\n\\n  const maxVal = Math.max(root.val, root.val + left, root.val + right);\\n  ans.val = Math.max(ans.val, maxVal, root.val + left + right);\\n\\n  return maxVal;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function (root) {\\n  const ans = { val: -Infinity };\\n  dfs(root, ans);\\n\\n  return ans.val;\\n};\\n\\nfunction dfs(root, ans) {\\n  if (!root) return 0;\\n\\n  const left = dfs(root.left, ans);\\n  const right = dfs(root.right, ans);\\n\\n  const maxVal = Math.max(root.val, root.val + left, root.val + right);\\n  ans.val = Math.max(ans.val, maxVal, root.val + left + right);\\n\\n  return maxVal;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2899116,
                "title": "java-code-solution-it-works",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) as we have to traverse all of the nodes in the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) as we are using a recursion stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int maxsum;\\n    public int maxPathSum(TreeNode root) {\\n        maxsum = Integer.MIN_VALUE;\\n        maxPathSumUtil(root);\\n        return maxsum;\\n    }\\n    \\n    public int maxPathSumUtil(TreeNode root){\\n        if(root==null) return 0;\\n        int leftMaxSum = Math.max(0,maxPathSumUtil(root.left));\\n        int rightMaxSum = Math.max(0,maxPathSumUtil(root.right));\\n        \\n        maxsum = Math.max(maxsum, root.val+leftMaxSum+rightMaxSum);\\n        return root.val+Math.max(leftMaxSum, rightMaxSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    int maxsum;\\n    public int maxPathSum(TreeNode root) {\\n        maxsum = Integer.MIN_VALUE;\\n        maxPathSumUtil(root);\\n        return maxsum;\\n    }\\n    \\n    public int maxPathSumUtil(TreeNode root){\\n        if(root==null) return 0;\\n        int leftMaxSum = Math.max(0,maxPathSumUtil(root.left));\\n        int rightMaxSum = Math.max(0,maxPathSumUtil(root.right));\\n        \\n        maxsum = Math.max(maxsum, root.val+leftMaxSum+rightMaxSum);\\n        return root.val+Math.max(leftMaxSum, rightMaxSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616820,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode *root, int &ans){\\n        if(root==nullptr) return 0;        \\n        int l = solve(root->left, ans);\\n        int r = solve(root->right, ans);\\n        int v = root->val;\\n        ans = max({ans, v, r+l+v, r+v, l+v});\\n        return max(max(r,l)+v, v);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        int ans=-1001;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode *root, int &ans){\\n        if(root==nullptr) return 0;        \\n        int l = solve(root->left, ans);\\n        int r = solve(root->right, ans);\\n        int v = root->val;\\n        ans = max({ans, v, r+l+v, r+v, l+v});\\n        return max(max(r,l)+v, v);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        int ans=-1001;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485475,
                "title": "python-what-is-a-path-intuition-for-the-problem",
                "content": "This problem is a mash up of\\n* https://leetcode.com/problems/maximum-depth-of-binary-tree/ BT height/width\\n* https://leetcode.com/problems/diameter-of-binary-tree/ BT height/width\\n* https://leetcode.com/problems/maximum-subarray/ Kadane\\'s algo applied to a tree\\n* https://leetcode.com/problems/longest-univalue-path/ BT path\\n\\nIf you understand all of the above, there\\'s nothing to solve here.\\n\\nThe crux of the problem is the \"path\" definition. A few examples what\\'s path and what\\'s not.\\nAs it\\'s said \"a picture is worth a thousand words\":\\n\\n**What is a path here?**\\n\\nYou can imagine a path as a road (set of nodes). You can turn left or right. But you **cannot turn left and right** at the same time. Path can be a single node, or it can be a linked-list like skewed tree. It can start anywhere and also end in the middle of the tree.\\n\\n![image](https://assets.leetcode.com/users/images/d5202c73-011e-4ecd-bd23-02979540997e_1661544784.4822035.png)\\n\\n**How to solve the problem with a few examples?**\\n\\nWe are going to build and check paths from the tree leaves and up to the root, from bottom to top.\\n\\nWe\\'ll need to use a **post order traversal** for this. (offtop: btw, the same idea with Binary Tree Cameras problem)\\nWhy?\\n\\nPost-order processing: *process left subtree paths*, *process right subtree paths*, and only then **process root**.\\n\\nBecause in order to make a decision - \"pick the left subtree path or pick the right subtree path\", we need to know information from the node children beforehand.\\n\\n```\\nleft_path_sum = postorder(node.left)\\nright_path_sum = postorder(node.right)\\n\\n# info processing code\\n```\\n\\nWe have info from the left subtree, the right subtree and the node - so we can make some decision about path building. \\n\\n**How Kadane\\'s algo ideas and max sum are related to the problem?**\\n\\nLet\\'s look at examples where we need to make decisions:\\n\\n**Case #1**\\nYellow node needs to decide if it\\'s going to join the path from left subtree or from the right subtree.\\n\\n![image](https://assets.leetcode.com/users/images/49e5b58c-a7f4-4bc2-8763-05ee288adcef_1661548368.0108829.png)\\n\\nHere it\\'s easy: pick the one with the max sum. In our case:\\n\\n80 + 0 vs 5+100 + 0\\n\\nObviously we choose 105 and form a path 5->100->0.\\n\\nLogic to handle the case:\\n```\\npath_sum = max(left_path_sum + node.val, right_path_sum + node.val)\\n```\\n\\n**Case #2**\\nYellow node needs to decide if it\\'s going to join the path from left subtree or from the right subtree.\\nNow what heppens in this case???\\n\\n![image](https://assets.leetcode.com/users/images/ddd7e50f-a496-4ad3-93e0-32a5d58ab770_1661549406.0686157.png)\\n\\nPick the one with the max sum... but wait! left path sum = -50, right path sum = -85\\n\\n-50 vs -85\\n\\nWhich one is the best???\\n\\n**NEITHER!!!**\\n\\nLet\\'s see what\\'s going on: building a path with the left path is -50+100 = 50. With the right path is -85+100 = 15.\\n\\nHere\\'s where the idea from Kadane\\'s algo come into play...\\nWe choose neither and start building the path from scratch from the node that we have.\\n\\n-50 vs -85 **vs 100**\\n\\nLogic to handle the cases 1-2:\\n```\\npath_sum = max(node.val, left_path_sum + node.val, right_path_sum + node.val)\\n```\\n\\nRemember about \"**cannot turn left and right** at the same time\"? That is where we decide how we build the path - join left part or right. So we have the option #3: start building a path from scratch from the node.\\n\\n**Case with only negative numbers**\\nWhat if we have negative values. Only negative values.\\n\\n![image](https://assets.leetcode.com/users/images/23e815ce-ef90-4792-a2f2-1385d097e4a5_1661550144.2250712.png)\\n\\nIn this case logic from case #2 will handle the case. How?\\n\\nEvery time the node see\\'s that there\\'s an option to build a new better path with max sum from scratch, it will do it. Pick max from (node_left_path + node.val, node_right_path + node.val, node.val)\\n\\nThis way we will have the following paths: -100, -15, -50, -200. Pick the max values from the paths.\\n\\n---\\n\\n**There is one more important case #3**\\nGoing back to our case #1 example:\\n\\nBut is this the max possible path where the node \"0\" is a part of?\\nSo far we checked the following path: 5, 5+100, 5+100+0, 80, 80+0.\\n\\n![image](https://assets.leetcode.com/users/images/49e5b58c-a7f4-4bc2-8763-05ee288adcef_1661548368.0108829.png)\\n\\n*Here it\\'s easy: pick the one with the max sum. In our case:*\\n*80 + 0 vs 5+100 + 0*\\n*Obviously we choose 105 and form a path 5->100->0.*\\n\\nBut is this the max path sum???\\n\\n---\\n!!!\\nThe most important part of the problem is to understand that the path can be not only **root -> left path** or **root -> right path**, **BUT** path can also **go through the node itself** starting from the **left path -> subtree root -> the right path**.\\n!!!\\n\\n---\\n\\nYes. this is a valid path too. It does not \"turn left and right at the same time\" and gives us the max path sum for the node \"0\".\\n\\n![image](https://assets.leetcode.com/users/images/5368634d-0889-4576-8621-e1a0f6dde6a0_1661551187.5639656.png)\\n\\nHere it\\'s **not that** easy: pick the one with left + root + right paths. In our case:\\n80 + 0 vs 5+100 + 0 **vs 80 + 0 + 5 + 100**\\nObviously we choose max 185 and form a path 80->0->100->5*.\\n\\nHow do we handle the logic? The way we described it with words:\\n\\n```\\n# pick max from current_node or left_path + current_node or right_path + current_node\\npath_sum = max(current_node.val, left_path_sum + current_node.val, right_path_sum + current_node.val) # cases 1-2\\n\\n# pick global max path sum: it\\'s either the \\'path_sum\\' or \\'left_path_sum + current_node + right_path_sum\\'\\nself.max_path_sum = max(self.max_path_sum, path_sum, left + right + node.val) # case 3\\n```\\n\\nThat\\'s it!\\n\\nThe full source code for the problem:\\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        def postorder(node):\\n            if not node: # no node - no value, aka the empty sum = 0\\n                return 0\\n            \\n            left = postorder(node.left) # get left max path sum\\n            right = postorder(node.right) # get right max path sum\\n            \\n\\t\\t\\t# pick max from (current_node_only, left_path + current_node, right_path + current_node)\\n\\t\\t\\t# \\'local node\\' max path sum\\n            path_sum = max(node.val, max(left, right) + node.val)\\n\\t\\t\\t\\n\\t\\t\\t# pick global max path: it\\'s either the \\'path_sum\\' or \\'left_path_sum + current_node + right_path_sum\\'\\n\\t\\t\\t# \\'global\\' max path sum\\n            self.max_path_sum = max(self.max_path_sum, path_sum, left + right + node.val)\\n            \\n\\t\\t\\t# return current path max sum - local max_sum\\n            return path_sum\\n\\n\\t\\t# we might have negative path sum only trees, so use \"-infinity\"\\n        self.max_path_sum = float(-inf)\\n        postorder(root) # find the \\'global\\' max path sum\\n        return self.max_path_sum\\n```\\n\\nThat\\'s it!\\n\\nOK. More like dp on trees approach without the \"global/local\" variable.\\n```\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        def postorder(node):\\n            if not node:\\n                return (float(-inf),0) # global_max_path_sum, path_sum\\n            \\n            left = postorder(node.left)\\n            right = postorder(node.right)\\n            \\n            path_sum = max(node.val, max(left[1],right[1]) + node.val)\\n            max_path_sum = max(left[0], right[0], path_sum, left[1] + right[1] + node.val)\\n            \\n            return (max_path_sum, path_sum)\\n        \\n        return postorder(root)[0]\\n```\\n\\n( \\u25D1\\u203F\\u25D1)\\u0254\\u250F\\uD83C\\uDF5F--\\uD83C\\uDF54\\u2511\\u0669(^\\u25E1^ )\\n\\nIf you liked the read, **upvote so the other people can see it too.**\\n\\nP.S. I think after solving \"Binary Tree Cameras\" I mastered the post order traversl that I can now do anything with it.\\n\\nP.P.S. https://leetcode.com/problems/diameter-of-binary-tree/ and this one has quite copy+paste like code. The intuition is different: find \"node\\'s left height + right height + 1\" vs \"max path sum between any 2 nodes\"",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nleft_path_sum = postorder(node.left)\\nright_path_sum = postorder(node.right)\\n\\n# info processing code\\n```\n```\\npath_sum = max(left_path_sum + node.val, right_path_sum + node.val)\\n```\n```\\npath_sum = max(node.val, left_path_sum + node.val, right_path_sum + node.val)\\n```\n```\\n# pick max from current_node or left_path + current_node or right_path + current_node\\npath_sum = max(current_node.val, left_path_sum + current_node.val, right_path_sum + current_node.val) # cases 1-2\\n\\n# pick global max path sum: it\\'s either the \\'path_sum\\' or \\'left_path_sum + current_node + right_path_sum\\'\\nself.max_path_sum = max(self.max_path_sum, path_sum, left + right + node.val) # case 3\\n```\n```\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        def postorder(node):\\n            if not node: # no node - no value, aka the empty sum = 0\\n                return 0\\n            \\n            left = postorder(node.left) # get left max path sum\\n            right = postorder(node.right) # get right max path sum\\n            \\n\\t\\t\\t# pick max from (current_node_only, left_path + current_node, right_path + current_node)\\n\\t\\t\\t# \\'local node\\' max path sum\\n            path_sum = max(node.val, max(left, right) + node.val)\\n\\t\\t\\t\\n\\t\\t\\t# pick global max path: it\\'s either the \\'path_sum\\' or \\'left_path_sum + current_node + right_path_sum\\'\\n\\t\\t\\t# \\'global\\' max path sum\\n            self.max_path_sum = max(self.max_path_sum, path_sum, left + right + node.val)\\n            \\n\\t\\t\\t# return current path max sum - local max_sum\\n            return path_sum\\n\\n\\t\\t# we might have negative path sum only trees, so use \"-infinity\"\\n        self.max_path_sum = float(-inf)\\n        postorder(root) # find the \\'global\\' max path sum\\n        return self.max_path_sum\\n```\n```\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        def postorder(node):\\n            if not node:\\n                return (float(-inf),0) # global_max_path_sum, path_sum\\n            \\n            left = postorder(node.left)\\n            right = postorder(node.right)\\n            \\n            path_sum = max(node.val, max(left[1],right[1]) + node.val)\\n            max_path_sum = max(left[0], right[0], path_sum, left[1] + right[1] + node.val)\\n            \\n            return (max_path_sum, path_sum)\\n        \\n        return postorder(root)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309746,
                "title": "go-26-lines-o-n",
                "content": "```\\nfunc maxPathSum(root *TreeNode) int {\\n    globalMax := -1<<63\\n    dfs(root, &globalMax)\\n    return globalMax\\n}\\n\\nfunc dfs(root *TreeNode, globalMax *int) int {\\n    if root == nil {\\n        return 0\\n    }\\n\\n    pathSumFromLeft := max(dfs(root.Left, globalMax), 0)\\n    pathSumFromRight := max(dfs(root.Right, globalMax), 0)\\n    \\n    *globalMax = max(*globalMax, root.Val + pathSumFromLeft + pathSumFromRight)\\n    \\n    return root.Val + max(pathSumFromLeft, pathSumFromRight) \\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc maxPathSum(root *TreeNode) int {\\n    globalMax := -1<<63\\n    dfs(root, &globalMax)\\n    return globalMax\\n}\\n\\nfunc dfs(root *TreeNode, globalMax *int) int {\\n    if root == nil {\\n        return 0\\n    }\\n\\n    pathSumFromLeft := max(dfs(root.Left, globalMax), 0)\\n    pathSumFromRight := max(dfs(root.Right, globalMax), 0)\\n    \\n    *globalMax = max(*globalMax, root.Val + pathSumFromLeft + pathSumFromRight)\\n    \\n    return root.Val + max(pathSumFromLeft, pathSumFromRight) \\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2130341,
                "title": "simple-clean-faster-than-95-c",
                "content": "The code is self explanatory ! Have a look : ) \\n```\\nclass Solution {\\npublic:\\n    \\n    int maxi = INT_MIN;    // store the maximum \\n    int sum(TreeNode *root){\\n        if(!root)return 0;\\n        \\n        int a = sum(root->right);  // maximum path *starting* from root->right \\n        int b = sum(root->left);   // maximum path *starting* from root->right\\n        \\n        maxi = max({maxi,root->val,root->val+a,root->val+b,root->val+a+b});\\n        return max({root->val,root->val+a,root->val+b});  // return maximum path starting from root itself \\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n      int _ = sum(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxi = INT_MIN;    // store the maximum \\n    int sum(TreeNode *root){\\n        if(!root)return 0;\\n        \\n        int a = sum(root->right);  // maximum path *starting* from root->right \\n        int b = sum(root->left);   // maximum path *starting* from root->right\\n        \\n        maxi = max({maxi,root->val,root->val+a,root->val+b,root->val+a+b});\\n        return max({root->val,root->val+a,root->val+b});  // return maximum path starting from root itself \\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n      int _ = sum(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954827,
                "title": "recursion-easy-to-unuderstand-c",
                "content": "```class Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int maxPathSum(TreeNode* root) {\\n        solve(root,ans);\\n        return ans;\\n    }\\n    \\n    int solve(TreeNode* root,int &ans)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int left=solve(root->left,ans);\\n        int right=solve(root->right,ans);\\n        ans=max({ans,left+right+root->val,left+root->val,right+root->val,root->val});\\n        return max({root->val,root->val+left,root->val+right});\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int maxPathSum(TreeNode* root) {\\n        solve(root,ans);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1775976,
                "title": "divide-and-conquer-method-in-python-time-o-n-explained-very-clearly",
                "content": "**Divide and Conquer**!\\n\\nFirst we need to understand when reaching a node, what should we compare and return.\\n\\n**For example:**\\na tree like this\\n```\\n     [5]\\n   [3, 6]\\n[2, 7, -8, -9]\\n```\\n\\nSuppose now we are at level 1, we need to compare **three** possible cases:\\n* maximum path sum of the **left subtree of 5** (3 as a root)\\n\\twhich is [2, 3, 7] in our example\\n* maximum path sum of the **right subtree of 5** (6 as a root)\\n\\twhich is [6] in our example\\n* maximum path sum of the tree 5 that **includes root 5 in the path**\\n\\nNow the question comes to, how could we get the maximum path sum of the tree 5 that includes root 5 in the path?\\nThe answer should be: We need to know the **left maximum chain**  and **the right maximum chain**!\\n**In the example**, it should be:\\n* left maximum chain: [3, 7]\\n* right maximum chain: [6]\\n\\n**The requirement of maximum chain** is that: it must include the root, and can only goes one direction down, in our example:\\n* left maximum chain: from [3, 7], [3, 2], and [3], we choose [3, 7]\\n* right maximum chain: from [6, -8], [6, -9], and [6], we choose [6]\\n\\nSo, maximum path sum of the tree 5 that includes root 5 should be [3, 7, 5, 6]:\\nleft maximum chain [3, 7] + root 5 + right maximum chain [6]\\n\\nSo now, we understand that, at each subtree of the divide and conquer helper function, we need to **return two things**:\\n* **maximum path sum** of this subtree\\n* **maximum path chain** that includes root of this subtree\\n\\n**Time:** O(n)\\n**Space:** O(H), to keep the recursion stack, H is the height of the binary tree, worst case O(n)\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        \\n        max_sum, _ = self.divideConquer(root)\\n        return max_sum\\n    \\n    def divideConquer(self, node):\\n\\n        if not node:\\n            return float(\\'-inf\\'), 0\\n        \\n        # Divide and conquer, return the maximum path of both left and right subtree of root node, and also return the maximum path chain of both left and right subtree of root node\\n        left_sum, left_chain = self.divideConquer(node.left)\\n        right_sum, right_chain = self.divideConquer(node.right)\\n        \\n        # If any maximum path chain is negative, we will update it to 0, meaning that we will not go down that chain\\n        left_chain = max(left_chain, 0)\\n        right_chain = max(right_chain, 0)\\n\\n        # Construct the maximum path that includes root node\\n        root_sum = node.val + left_chain + right_chain\\n\\n        # Now compare three possible cases, that is\\n        # maximum path sum of the left subtree, maximum path sum of the right subtree, and maximum path sum of the current tree that includes root  \\n        max_sum = max(left_sum, right_sum, root_sum)\\n\\n        # We also need to return the maximum path chain of the current tree\\n        max_chain = max(left_chain, right_chain) + node.val\\n        \\n        return max_sum, max_chain\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\n     [5]\\n   [3, 6]\\n[2, 7, -8, -9]\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        \\n        max_sum, _ = self.divideConquer(root)\\n        return max_sum\\n    \\n    def divideConquer(self, node):\\n\\n        if not node:\\n            return float(\\'-inf\\'), 0\\n        \\n        # Divide and conquer, return the maximum path of both left and right subtree of root node, and also return the maximum path chain of both left and right subtree of root node\\n        left_sum, left_chain = self.divideConquer(node.left)\\n        right_sum, right_chain = self.divideConquer(node.right)\\n        \\n        # If any maximum path chain is negative, we will update it to 0, meaning that we will not go down that chain\\n        left_chain = max(left_chain, 0)\\n        right_chain = max(right_chain, 0)\\n\\n        # Construct the maximum path that includes root node\\n        root_sum = node.val + left_chain + right_chain\\n\\n        # Now compare three possible cases, that is\\n        # maximum path sum of the left subtree, maximum path sum of the right subtree, and maximum path sum of the current tree that includes root  \\n        max_sum = max(left_sum, right_sum, root_sum)\\n\\n        # We also need to return the maximum path chain of the current tree\\n        max_chain = max(left_chain, right_chain) + node.val\\n        \\n        return max_sum, max_chain\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454245,
                "title": "postorder-traversal-kadane-algortihm-commented",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = INT_MIN;\\n    \\n    int traverse(TreeNode *root){\\n        if(!root) return 0;\\n        \\n        int left = traverse(root->left);\\n        int right = traverse(root->right);\\n        \\n        // same as kadane\\'s algo. if negative, make 0\\n        left = (left < 0) ? 0 : left;\\n        right = (right < 0) ? 0 : right;\\n        \\n        // max sum will be root data + left sum + right sum\\n        res = max(res, root->val + left + right);\\n        \\n        // we need path\\'s sum not whole subtree sum; so, return only max sum from left or right\\n        return root->val + max(left, right);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        traverse(root);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = INT_MIN;\\n    \\n    int traverse(TreeNode *root){\\n        if(!root) return 0;\\n        \\n        int left = traverse(root->left);\\n        int right = traverse(root->right);\\n        \\n        // same as kadane\\'s algo. if negative, make 0\\n        left = (left < 0) ? 0 : left;\\n        right = (right < 0) ? 0 : right;\\n        \\n        // max sum will be root data + left sum + right sum\\n        res = max(res, root->val + left + right);\\n        \\n        // we need path\\'s sum not whole subtree sum; so, return only max sum from left or right\\n        return root->val + max(left, right);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        traverse(root);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361330,
                "title": "java-faster-than-100",
                "content": "```\\npublic class BinaryTreeMaximumPathSumProblem {\\n\\n    int maxSum = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum(root);\\n\\n        return maxSum;\\n    }\\n\\n    /*\\n    Steps:\\n    1. check for edge case [null node]\\n    2. calculate left and right sum by recursively calling the child nodes\\n    3. store currSum as the sum of node value, left and right sum\\n    4. update the max sum if current sum is greater\\n    5. return the sum of node value and max of left/right node\\n\\n    Time complexity: O(N), where N is number of nodes, since we visit each node not more than 2 times.\\n\\n    Space complexity: O(H), where H is a tree height, to keep the recursion stack. \\n    In the average case of balanced tree, the tree height H = logN, in the worst case of skewed tree, H=N.\\n    */\\n    public int maxSum(TreeNode node) {\\n\\n        if (node == null) return 0;\\n\\n        int leftSum = Math.max(maxSum(node.left), 0);\\n        int rightSum = Math.max(maxSum(node.right), 0);\\n\\n        int currSum = node.val + leftSum + rightSum;\\n\\n        if (currSum > maxSum) maxSum = currSum;\\n\\n        return node.val + Math.max(leftSum, rightSum);\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/b414232c-f008-4cc8-8200-6689b908d8f6_1627197889.2321608.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic class BinaryTreeMaximumPathSumProblem {\\n\\n    int maxSum = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum(root);\\n\\n        return maxSum;\\n    }\\n\\n    /*\\n    Steps:\\n    1. check for edge case [null node]\\n    2. calculate left and right sum by recursively calling the child nodes\\n    3. store currSum as the sum of node value, left and right sum\\n    4. update the max sum if current sum is greater\\n    5. return the sum of node value and max of left/right node\\n\\n    Time complexity: O(N), where N is number of nodes, since we visit each node not more than 2 times.\\n\\n    Space complexity: O(H), where H is a tree height, to keep the recursion stack. \\n    In the average case of balanced tree, the tree height H = logN, in the worst case of skewed tree, H=N.\\n    */\\n    public int maxSum(TreeNode node) {\\n\\n        if (node == null) return 0;\\n\\n        int leftSum = Math.max(maxSum(node.left), 0);\\n        int rightSum = Math.max(maxSum(node.right), 0);\\n\\n        int currSum = node.val + leftSum + rightSum;\\n\\n        if (currSum > maxSum) maxSum = currSum;\\n\\n        return node.val + Math.max(leftSum, rightSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122979,
                "title": "java-0ms-all-test-cases-covered",
                "content": "```\\nclass Solution {\\n    int pathsum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        path_sum(root);\\n        return pathsum;\\n    }\\n    int path_sum(TreeNode node){\\n        if(node==null){\\n            return 0;\\n        }\\n        \\n        int left= path_sum(node.left);\\n        int right= path_sum(node.right);\\n        \\n        pathsum= Math.max(node.val, Math.max(node.val + left, Math.max(node.val + right, Math.max(node.val+left+right, pathsum))));\\n        \\n        return Math.max(node.val, Math.max(node.val + left, node.val+right));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int pathsum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        path_sum(root);\\n        return pathsum;\\n    }\\n    int path_sum(TreeNode node){\\n        if(node==null){\\n            return 0;\\n        }\\n        \\n        int left= path_sum(node.left);\\n        int right= path_sum(node.right);\\n        \\n        pathsum= Math.max(node.val, Math.max(node.val + left, Math.max(node.val + right, Math.max(node.val+left+right, pathsum))));\\n        \\n        return Math.max(node.val, Math.max(node.val + left, node.val+right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924563,
                "title": "concise-java-solution-using-dfs-beats-100",
                "content": "```\\nclass Solution {\\n    \\n    private int result;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        \\n        result = Integer.MIN_VALUE;\\n        \\n        getMaxSum(root);\\n        \\n        return result;\\n    }\\n    \\n    private int getMaxSum(TreeNode node)\\n    {\\n        if (node == null)\\n            return 0;\\n        \\n        int leftSum = getMaxSum(node.left);\\n        int rightSum = getMaxSum(node.right);\\n        \\n        result = Math.max(result, node.val + leftSum + rightSum);\\n        \\n        // We will not count the path if the max path sum is less than zero\\n        return Math.max(0, node.val + Math.max(leftSum, rightSum));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int result;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        \\n        result = Integer.MIN_VALUE;\\n        \\n        getMaxSum(root);\\n        \\n        return result;\\n    }\\n    \\n    private int getMaxSum(TreeNode node)\\n    {\\n        if (node == null)\\n            return 0;\\n        \\n        int leftSum = getMaxSum(node.left);\\n        int rightSum = getMaxSum(node.right);\\n        \\n        result = Math.max(result, node.val + leftSum + rightSum);\\n        \\n        // We will not count the path if the max path sum is less than zero\\n        return Math.max(0, node.val + Math.max(leftSum, rightSum));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767082,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int sum=INT_MIN;\\n        helper(root,sum);\\n        return sum;\\n    }\\n    int helper(TreeNode* root, int &sum)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int l=max(0,helper(root->left,sum));\\n        int r=max(0,helper(root->right,sum));\\n        \\n        sum=max(sum, root->val+l+r);\\n        return (root->val +max(l,r));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int sum=INT_MIN;\\n        helper(root,sum);\\n        return sum;\\n    }\\n    int helper(TreeNode* root, int &sum)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int l=max(0,helper(root->left,sum));\\n        int r=max(0,helper(root->right,sum));\\n        \\n        sum=max(sum, root->val+l+r);\\n        return (root->val +max(l,r));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727545,
                "title": "super-easy-python-o-n-time-single-traversal",
                "content": "\\n**Super Easy - Python - O(n) Time (Single Traversal)**\\n\\nSimple Code Performing a One-Time Traversal through the Binary Tree with O(n) Time Complexity . The bulk of the work is made by the internal MaxPath function.\\n\\nMaxPath function highlights:\\n\\n1. Each call to the function MaxPath(node) returns the branch with the highest sum starting from \"node\".\\n2. The best path possible is calculated as an in-between move, by attempting to join the left and right branches into one arc.\\n3. Any negative values for the \"left\" and \"right\" branches are ignored, as if they hadn\\'t existed.\\n\\nI think this problem should be \"Medium\" difficulty with all due respect. Cheers,\\n\\n```\\nfmax = lambda x,y: x if x>y else y # Custom Max Function (33% Faster than Python\\'s Built-in Max function)\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.result = root.val\\n        def maxpath(node):\\n            if not node:\\n                return 0\\n            x = node.val\\n            l = fmax(0,maxpath(node.left )) # ignore \"left\" branch if negative\\n            r = fmax(0,maxpath(node.right)) # ignore \"right\" branch if negative\\n            self.result = fmax(self.result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\\n            return fmax(x+l,x+r) # Try to build maximum branch value\\n        maxpath(root)\\n        return self.result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfmax = lambda x,y: x if x>y else y # Custom Max Function (33% Faster than Python\\'s Built-in Max function)\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.result = root.val\\n        def maxpath(node):\\n            if not node:\\n                return 0\\n            x = node.val\\n            l = fmax(0,maxpath(node.left )) # ignore \"left\" branch if negative\\n            r = fmax(0,maxpath(node.right)) # ignore \"right\" branch if negative\\n            self.result = fmax(self.result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\\n            return fmax(x+l,x+r) # Try to build maximum branch value\\n        maxpath(root)\\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673314,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\n   int res;\\n    public:\\n    int maxPathSum(TreeNode* root) {\\n        res = INT_MIN;\\n        call(root);\\n        return res;\\n    }\\n    int call(TreeNode* root)\\n    {\\n        if(root==NULL)return 0;\\n        int l = call(root->left);\\n        int r = call(root->right);\\n        int data_without = max(root->val,max(l,r)+root->val);\\n        int data_with = max(data_without, l+r+root->val);\\n        res = max(res,data_with);\\n        return data_without;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n   int res;\\n    public:\\n    int maxPathSum(TreeNode* root) {\\n        res = INT_MIN;\\n        call(root);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 611877,
                "title": "in-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n\\nint maxPathSumInt(struct TreeNode* root, int *max)\\n{\\n    if (root == NULL) {\\n        return 0;\\n    }\\n    \\n    int left = maxPathSumInt(root->left, max);\\n    int right = maxPathSumInt(root->right, max);\\n    \\n    left = MAX(left, 0);\\n    right = MAX(right, 0);\\n\\n    // XXX: what about int overflows?\\n    int curr = left + root->val + right;\\n    *max = MAX(*max, curr);\\n\\n    return root->val + MAX(left, right);\\n}\\n    \\n\\nint maxPathSum(struct TreeNode* root)\\n{\\n    int max = INT_MIN;\\n    maxPathSumInt(root, &max);\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n\\nint maxPathSumInt(struct TreeNode* root, int *max)\\n{\\n    if (root == NULL) {\\n        return 0;\\n    }\\n    \\n    int left = maxPathSumInt(root->left, max);\\n    int right = maxPathSumInt(root->right, max);\\n    \\n    left = MAX(left, 0);\\n    right = MAX(right, 0);\\n\\n    // XXX: what about int overflows?\\n    int curr = left + root->val + right;\\n    *max = MAX(*max, curr);\\n\\n    return root->val + MAX(left, right);\\n}\\n    \\n\\nint maxPathSum(struct TreeNode* root)\\n{\\n    int max = INT_MIN;\\n    maxPathSumInt(root, &max);\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 603612,
                "title": "java-easy-o-n-solution",
                "content": "```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n       if (root!=null) maxPath(root);\\n        return max;\\n    }\\n    public void maxPath(TreeNode root) {\\n        int current = root.val;\\n          max = Math.max(max, current);\\n        if (root.right!=null){\\n            maxPath(root.right);\\n            root.val = Math.max(root.val, current+root.right.val);\\n            max = Math.max(max, current+root.right.val);\\n        } \\n        if (root.left!=null) {\\n            maxPath(root.left);\\n            root.val = Math.max(root.val, current+root.left.val);\\n            max = Math.max(max, current+root.left.val);\\n        }\\n        if (root.right!=null && root.left!=null){\\n          max = Math.max(max, current+root.left.val+root.right.val);\\n\\t\\t}\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n       if (root!=null) maxPath(root);\\n        return max;\\n    }\\n    public void maxPath(TreeNode root) {\\n        int current = root.val;\\n          max = Math.max(max, current);\\n        if (root.right!=null){\\n            maxPath(root.right);\\n            root.val = Math.max(root.val, current+root.right.val);\\n            max = Math.max(max, current+root.right.val);\\n        } \\n        if (root.left!=null) {\\n            maxPath(root.left);\\n            root.val = Math.max(root.val, current+root.left.val);\\n            max = Math.max(max, current+root.left.val);\\n        }\\n        if (root.right!=null && root.left!=null){\\n          max = Math.max(max, current+root.left.val+root.right.val);\\n\\t\\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416095,
                "title": "c-7-lines-with-explanation",
                "content": "```\\nclass Solution {\\nprivate:  \\n    // Partial sum is like a logger, it logs the max we\\'ve seen so far.\\n    int maxHelper(TreeNode* root, int& partialSum) {\\n        if (!root) return 0;\\n        int leftMine = maxHelper(root->left, partialSum), rightMine = maxHelper(root->right, partialSum); \\n        partialSum = max(partialSum, leftMine + rightMine + root->val); // Log the max we\\'ve seen\\n        return max(0, root->val + max(leftMine, rightMine)); // Here we are returning paths\\n    } // Since we are looking for the longest single path, we make a decision between\\n\\t// returning our current value plus either the left or the right path.\\n\\t// If a path sums to negative, we don\\'t want to return it, it won\\'t add to our longest path\\n      // If a path is positive, it will have a positive impact on our max path, so we want to \\n\\t  // return it as opposed to returning 0.\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res{numeric_limits<int>::min()};\\n        maxHelper(root, res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\nprivate:  \\n    // Partial sum is like a logger, it logs the max we\\'ve seen so far.\\n    int maxHelper(TreeNode* root, int& partialSum) {\\n        if (!root) return 0;\\n        int leftMine = maxHelper(root->left, partialSum), rightMine = maxHelper(root->right, partialSum); \\n        partialSum = max(partialSum, leftMine + rightMine + root->val); // Log the max we\\'ve seen\\n        return max(0, root->val + max(leftMine, rightMine)); // Here we are returning paths\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 301587,
                "title": "8-line-python-beats-90-very-clear",
                "content": "```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.max = root.val\\n        def dfs(root):\\n            if not root: return 0\\n            left, right = dfs(root.left), dfs(root.right)\\n            self.max = max(self.max, root.val + left + right, left+root.val, right+root.val)\\n            return max(left+root.val, right+root.val, root.val)\\n        dfs(root)\\n        return self.max\\n```\\n\\nSo this one is a bit different from the other Path sum questions in that the path need not pass through the root. We do some kind of postorder traversal.\\n\\nNote that the return value in each call of the recursive function must be either: the root value + left value or root value + right value, or just the root value. We **cannot** return root value + left value + right value because otherwise that would end up being an invalid path in case some other tree node wants to include this value in its path. For example: (apology for formatting, tree is taken from the example)\\n\\n   **-10**\\n        / \\\\\\\\\\n  9    **20**\\n        / \\\\\\\\\\n     **15**   **7**\\nis an invalid path. However, the maximum path sum **can** be root value + left value + right value.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.max = root.val\\n        def dfs(root):\\n            if not root: return 0\\n            left, right = dfs(root.left), dfs(root.right)\\n            self.max = max(self.max, root.val + left + right, left+root.val, right+root.val)\\n            return max(left+root.val, right+root.val, root.val)\\n        dfs(root)\\n        return self.max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233315,
                "title": "c-well-commented-solution-with-explanation",
                "content": "```\\n/* Idea ----- \\n   First, we calculate the maximum path value for each node such that the path starts from below (or at) the node\\n   However, in addition to this, we also keep track of the global maximum which also consists of paths going down a node\\n   The trick here is that if you go down a node, the journey is completed and you cannot go up again .\\n   Now, any maxPath sum will eventually come in the section of maxGoingDownRoot and hence will be updated \\n**/   \\n\\n/* Idea borrowed from below source */\\n\\n/* https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/39775/Accepted-short-solution-in-Java */\\n\\n/* Tricky corner case ---- What if everything is negative */\\n\\nclass Solution\\n{    \\npublic:\\n    int maxSoFar = INT_MIN;\\n    int maxPathSum(TreeNode* root);\\n    int maxEndingAt(TreeNode* root);\\n};\\n\\n/* Returns the maximum path value ending at root */\\nint Solution :: maxEndingAt(TreeNode* root)\\n{\\n    // If root is not present, return 0\\n    if(!root) return 0;\\n    \\n    // Get the maximum path value ending at the left and right subtree \\n    int leftMax  = maxEndingAt(root->left);\\n    int rightMax = maxEndingAt(root->right);\\n    \\n    // The maximum value ending at root can include exactly one of them or none of them \\n    int maxEndingAtRoot = max({leftMax + root->val, rightMax + root->val, root->val});\\n    \\n    // Keep updating the global maximum\\n    maxSoFar = max(maxSoFar, maxEndingAtRoot);\\n    \\n    // Once you go down the root, the journey is finished\\n    int maxGoingDownRoot = leftMax + rightMax + root->val;\\n    \\n    // Check if going down can be beneficial. We are just going down virtually\\n    maxSoFar = max(maxSoFar, maxGoingDownRoot);\\n    \\n    // Return the max value ending at root, as per the definitions\\n    return maxEndingAtRoot;\\n}\\n\\n/* Returns the maximum value of the path anywhere in the tree */\\nint Solution :: maxPathSum(TreeNode* root)\\n{\\n    // Run the algorithm and keep track of the maximum path seen\\n    int maxFromRoot = maxEndingAt(root);\\n    \\n    // Return the updated global maximum\\n    return maxSoFar;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* Idea ----- \\n   First, we calculate the maximum path value for each node such that the path starts from below (or at) the node\\n   However, in addition to this, we also keep track of the global maximum which also consists of paths going down a node\\n   The trick here is that if you go down a node, the journey is completed and you cannot go up again .\\n   Now, any maxPath sum will eventually come in the section of maxGoingDownRoot and hence will be updated \\n**/   \\n\\n/* Idea borrowed from below source */\\n\\n/* https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/39775/Accepted-short-solution-in-Java */\\n\\n/* Tricky corner case ---- What if everything is negative */\\n\\nclass Solution\\n{    \\npublic:\\n    int maxSoFar = INT_MIN;\\n    int maxPathSum(TreeNode* root);\\n    int maxEndingAt(TreeNode* root);\\n};\\n\\n/* Returns the maximum path value ending at root */\\nint Solution :: maxEndingAt(TreeNode* root)\\n{\\n    // If root is not present, return 0\\n    if(!root) return 0;\\n    \\n    // Get the maximum path value ending at the left and right subtree \\n    int leftMax  = maxEndingAt(root->left);\\n    int rightMax = maxEndingAt(root->right);\\n    \\n    // The maximum value ending at root can include exactly one of them or none of them \\n    int maxEndingAtRoot = max({leftMax + root->val, rightMax + root->val, root->val});\\n    \\n    // Keep updating the global maximum\\n    maxSoFar = max(maxSoFar, maxEndingAtRoot);\\n    \\n    // Once you go down the root, the journey is finished\\n    int maxGoingDownRoot = leftMax + rightMax + root->val;\\n    \\n    // Check if going down can be beneficial. We are just going down virtually\\n    maxSoFar = max(maxSoFar, maxGoingDownRoot);\\n    \\n    // Return the max value ending at root, as per the definitions\\n    return maxEndingAtRoot;\\n}\\n\\n/* Returns the maximum value of the path anywhere in the tree */\\nint Solution :: maxPathSum(TreeNode* root)\\n{\\n    // Run the algorithm and keep track of the maximum path seen\\n    int maxFromRoot = maxEndingAt(root);\\n    \\n    // Return the updated global maximum\\n    return maxSoFar;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39837,
                "title": "c-recursive-solution-beats-99-with-explanation",
                "content": "Basic idea:\\n- ```maxPathDownwards:``` denotes max sum from the current node downwards **including the current node**\\n- Traverse bottom-up and update ```ans = max(ans, (max(0, left) + max(0, right) + root->val));```, 0 here means we don't use the left/right son's downward path.\\n```\\nclass Solution {\\nprivate:\\n    int ans = -2147483648;\\npublic:\\n    int maxPathDownwards(TreeNode* root) {\\n        if (!root) return 0;\\n        int left = maxPathDownwards(root->left);\\n        int right = maxPathDownwards(root->right);\\n        ans = max(ans, (max(0, left) + max(0, right) + root->val));\\n        return root->val + max(0, max(left, right));\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        maxPathDownwards(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Interactive"
                ],
                "code": "```maxPathDownwards:```\n```ans = max(ans, (max(0, left) + max(0, right) + root->val));```\n```\\nclass Solution {\\nprivate:\\n    int ans = -2147483648;\\npublic:\\n    int maxPathDownwards(TreeNode* root) {\\n        if (!root) return 0;\\n        int left = maxPathDownwards(root->left);\\n        int right = maxPathDownwards(root->right);\\n        ans = max(ans, (max(0, left) + max(0, right) + root->val));\\n        return root->val + max(0, max(left, right));\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        maxPathDownwards(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39930,
                "title": "simple-and-easy-understood-recursive-c-code-with-o-n-time",
                "content": "    class Solution {\\n    public:\\n        int maxPathSum(TreeNode *root) {\\n            buildVector(root);\\n            return maxVal;\\n        }\\n        int buildVector(TreeNode *root){\\n            if(!root)\\n                return 0;\\n            int left = buildVector(root->left);\\n            int right = buildVector(root->right);\\n            //assume this node as root and calcu maxVal based on it\\n            int sum = root->val;\\n            if(left > 0)\\n                sum += left;\\n            if(right > 0)\\n                sum += right;\\n            if(sum > maxVal)\\n                maxVal = sum;\\n            //return val is either left or right node with this node\\n            left = left > right ? left : right;\\n            sum = root->val;\\n            if(left > 0)\\n                sum += left;\\n            return sum;\\n        }\\n    private:\\n        int maxVal = INT_MIN;\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPathSum(TreeNode *root) {\\n            buildVector(root);\\n            return maxVal;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39953,
                "title": "a-java-solution-without-using-a-global-variable",
                "content": "I am using an array with only one element as a function parameter.\\n\\n\\n    public class Solution {\\n        public int maxPathSum(TreeNode root) {\\n            \\n            if (root==null) return 0;\\n            int[] max={Integer.MIN_VALUE};\\n            maxTree(root,max);\\n            return max[0];\\n            \\n        }\\n        //@Param:return the sum of the root value and largest branch\\n        private int maxTree(TreeNode root,int[] max){\\n            if (root==null) return 0;\\n            \\n            int left=root.left!=null?maxTree(root.left,max):Integer.MIN_VALUE;\\n            int right=root.right!=null?maxTree(root.right,max):Integer.MIN_VALUE;\\n            \\n            max[0]=Math.max(max[0],(left>0?left:0)+(right>0?right:0)+root.val);\\n    \\n            return root.val+((left>0||right>0)?Math.max(left,right):0);\\n    \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxPathSum(TreeNode root) {\\n            \\n            if (root==null) return 0;\\n            int[] max={Integer.MIN_VALUE}",
                "codeTag": "Java"
            },
            {
                "id": 3801935,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private int maxPath = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        if(root.left == null && root.right == null) return root.val;\\n        helper(root);\\n        return maxPath;\\n    }\\n\\n    private int helper(TreeNode node) {\\n        if(node == null) return 0;\\n\\n        int left = Math.max(0, helper(node.left));\\n        int right = Math.max(0, helper(node.right));\\n        \\n        maxPath = Math.max(node.val + left + right, maxPath);\\n        return node.val + Math.max(left, right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int maxPath = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        if(root.left == null && root.right == null) return root.val;\\n        helper(root);\\n        return maxPath;\\n    }\\n\\n    private int helper(TreeNode node) {\\n        if(node == null) return 0;\\n\\n        int left = Math.max(0, helper(node.left));\\n        int right = Math.max(0, helper(node.right));\\n        \\n        maxPath = Math.max(node.val + left + right, maxPath);\\n        return node.val + Math.max(left, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652916,
                "title": "commented-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(h)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxAll=INT_MIN;\\n    int maxSum(TreeNode*root){\\n        //Base case\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        // go for left and right\\n        // we don\\'t want negative value to go forward\\n        int left=max(maxSum(root->left),0);\\n        int right=max(maxSum(root->right),0);\\n        \\n        maxAll=max(maxAll,root->val+left+right);\\n\\n        return root->val+max(left,right);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int sum = maxSum(root);\\n        return maxAll;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxAll=INT_MIN;\\n    int maxSum(TreeNode*root){\\n        //Base case\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        // go for left and right\\n        // we don\\'t want negative value to go forward\\n        int left=max(maxSum(root->left),0);\\n        int right=max(maxSum(root->right),0);\\n        \\n        maxAll=max(maxAll,root->val+left+right);\\n\\n        return root->val+max(left,right);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int sum = maxSum(root);\\n        return maxAll;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647138,
                "title": "easy-to-understand-8-liner-dfs-recursion-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWell if you read the question carefully and observe ...you will get the vibe of easy dfs only where we need to store all possibilities at each node and store the maximum of them. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we have 4 possibilities\\n1. ans will lie in below three only (2nd example)\\n2. ans will lie somewhere upper root side which take advantage of left part of current node\\n3. ans will lie somewhere upper root side which take advantage of right part of current node\\n4. ans will be just root without any previous involvement.(ex-[2,-1]...here ans will be 2 only)\\nAt every point we return left_part_max and righ_part_max\\nlets take a variable to store res which takes the maximum of all 4 possibilities.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//--------------------------------normal dfs----------------\\n    pair<int,int> dfs(TreeNode *root,int &res){\\n        if(root==NULL) return {0,0};\\n        pair<int,int> left_part = dfs(root->left,res);\\n        pair<int,int> right_part = dfs(root->right,res);\\n        // if your desired tree exist below this root only hemce no upper connection\\n        int no_upper_conn  = max(left_part.first,left_part.second)+max(right_part.first,right_part.second)+root->val;\\n        //if your desired tree constitute of left part only\\n        int max_left_part  = max(left_part.first,left_part.second)  +root->val ;\\n        //if your desired tree constitute of right part only\\n        int max_right_part = max(right_part.first,right_part.second)+root->val ;\\n        //RES will be max of all 4 possibilities\\n        res = max({res,no_upper_conn,max_left_part,max_right_part,root->val});\\n        //and also IT MAY CONSIST OF ONLY ROOT NODE e.g;[1,-2,3] , [2,1] \\n        //that\\'s why we check max with root->val also\\n        return {max(max_left_part,root->val),max(max_right_part,root->val)};\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int res=INT_MIN;\\n        dfs(root,res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//--------------------------------normal dfs----------------\\n    pair<int,int> dfs(TreeNode *root,int &res){\\n        if(root==NULL) return {0,0};\\n        pair<int,int> left_part = dfs(root->left,res);\\n        pair<int,int> right_part = dfs(root->right,res);\\n        // if your desired tree exist below this root only hemce no upper connection\\n        int no_upper_conn  = max(left_part.first,left_part.second)+max(right_part.first,right_part.second)+root->val;\\n        //if your desired tree constitute of left part only\\n        int max_left_part  = max(left_part.first,left_part.second)  +root->val ;\\n        //if your desired tree constitute of right part only\\n        int max_right_part = max(right_part.first,right_part.second)+root->val ;\\n        //RES will be max of all 4 possibilities\\n        res = max({res,no_upper_conn,max_left_part,max_right_part,root->val});\\n        //and also IT MAY CONSIST OF ONLY ROOT NODE e.g;[1,-2,3] , [2,1] \\n        //that\\'s why we check max with root->val also\\n        return {max(max_left_part,root->val),max(max_right_part,root->val)};\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int res=INT_MIN;\\n        dfs(root,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583833,
                "title": "c-solution-with-diagrammatic-explanation",
                "content": "Before heading to the solution let us see all possible form of testcases for the given question.\\n\\n1. Maximum path exist in the left-subtree or right-subtree. shown in example (i) & (ii).\\n1. Maximum path is the sum of the part of left-subtree , right-subtree and root. shown in example (iii).\\n1. Maximum path is the sum of the (Maximum consecutive path of left-subtree and right-subtree) and root. shown in example (iv) & (v).\\n\\n![image](https://assets.leetcode.com/users/images/452ee832-327d-4443-aae0-699148a7a4ef_1685568434.8347857.png)\\n\\n![image](https://assets.leetcode.com/users/images/37dc84c8-061a-4386-ac35-10f798af31ac_1685568522.5391746.png)\\n\\n![image](https://assets.leetcode.com/users/images/51ed88b8-4ef4-4869-ad91-956253c70853_1685570162.9089835.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3e4e518c-92c2-4c52-933d-67065293986a_1685568716.1070657.png)\\n\\n\\n\\n**Recursive Code Explanation:**\\n* max_ps is storing the maximum path sum and if at some ith recursive call we get a path having sum greater than max_ps then we will change the max_ps.\\n* solve function is giving us the maximum consecutive path posibble including the root node.\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\tint solve(TreeNode* root,int &max_ps) {\\n        if(root==NULL) {\\n            return 0;\\n        }\\n        int l = max(0,solve(root->left,max_ps));\\n        // l gives the maximum consecutive path from left-subtree that can contribute to the  maximum path sum\\n        \\n        int r = max(0,solve(root->right,max_ps));\\n        // r gives the maximum consecutive path from right-subtree that can contribute to the  maximum path sum\\n        \\n        int curr_max = max(max(l,r) + root->val,root->val);\\n        // curr_max gives the maximum consecutive path including root-node as explained in example-(iv) and (v).\\n        \\n        int new_max_ps = max(l + r + root->val,curr_max);\\n        // explanation of l + r + root->val is given in example-(iii)\\n        \\n        max_ps = max(new_max_ps,max_ps);\\n        // updating the max_ps\\n        \\n        return curr_max;\\n    }\\n\\tint maxPathSum(TreeNode* root) {\\n        int max_ps = INT_MIN;\\n        int temp = solve(root,max_ps);\\n        return max_ps;\\n    }\\n};\\n```\\n\\n\\n\\n\\t",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint solve(TreeNode* root,int &max_ps) {\\n        if(root==NULL) {\\n            return 0;\\n        }\\n        int l = max(0,solve(root->left,max_ps));\\n        // l gives the maximum consecutive path from left-subtree that can contribute to the  maximum path sum\\n        \\n        int r = max(0,solve(root->right,max_ps));\\n        // r gives the maximum consecutive path from right-subtree that can contribute to the  maximum path sum\\n        \\n        int curr_max = max(max(l,r) + root->val,root->val);\\n        // curr_max gives the maximum consecutive path including root-node as explained in example-(iv) and (v).\\n        \\n        int new_max_ps = max(l + r + root->val,curr_max);\\n        // explanation of l + r + root->val is given in example-(iii)\\n        \\n        max_ps = max(new_max_ps,max_ps);\\n        // updating the max_ps\\n        \\n        return curr_max;\\n    }\\n\\tint maxPathSum(TreeNode* root) {\\n        int max_ps = INT_MIN;\\n        int temp = solve(root,max_ps);\\n        return max_ps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394265,
                "title": "detailed-image-solution-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int []ans=new int[1];\\n        ans[0]=Integer.MIN_VALUE;\\n        solve(root,ans);\\n        return ans[0];        \\n    }\\n\\n    public int solve(TreeNode root,int[]ans){\\n        if(root==null) return 0;\\n\\n        //if solve(root.left,ans) return the value < 0 then leftSum = 0;\\n        int leftSum=Math.max(0,solve(root.left,ans));\\n\\n        //if solve(root.right,ans) return the value < 0 then rightSum = 0;\\n        int rightSum=Math.max(0,solve(root.right,ans));\\n\\n        ans[0]=Math.max(ans[0],leftSum+rightSum+root.val);\\n\\n        return root.val+Math.max(leftSum,rightSum);\\n    }\\n}\\n```\\n![WhatsApp Image 2023-04-08 at 8.44.18 PM.jpeg](https://assets.leetcode.com/users/images/616bf59f-03d2-43cb-8c45-cd8e5143d825_1680966911.0263126.jpeg)\\n\\n```\\nGive An Upvote if you Understand the solution.\\n```\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int []ans=new int[1];\\n        ans[0]=Integer.MIN_VALUE;\\n        solve(root,ans);\\n        return ans[0];        \\n    }\\n\\n    public int solve(TreeNode root,int[]ans){\\n        if(root==null) return 0;\\n\\n        //if solve(root.left,ans) return the value < 0 then leftSum = 0;\\n        int leftSum=Math.max(0,solve(root.left,ans));\\n\\n        //if solve(root.right,ans) return the value < 0 then rightSum = 0;\\n        int rightSum=Math.max(0,solve(root.right,ans));\\n\\n        ans[0]=Math.max(ans[0],leftSum+rightSum+root.val);\\n\\n        return root.val+Math.max(leftSum,rightSum);\\n    }\\n}\\n```\n```\\nGive An Upvote if you Understand the solution.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363263,
                "title": "this-is-easier-than-easy-category-question-beats-93",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/2d6e0912-50e8-4546-a8c2-855be4a3d60b_1680286287.571895.png)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt just like finding the height of binary tree...Traverse the tree and at every node calculate the sum of node.left+node.right+node.val.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        \\n        int maxValue[] = new int[1]; // Create an array to hold the max value\\n        maxValue[0] = Integer.MIN_VALUE; // Initialize the max value to the lowest possible integer value\\n        maxPathDown(root,maxValue); // Call the recursive helper function to compute the max path sum\\n\\n        return maxValue[0]; // Return the max path sum\\n    }\\n\\n    public int maxPathDown(TreeNode root, int maxValue[]){\\n\\n        if(root == null){ // Base case: If the node is null, return 0\\n            return 0;\\n        }\\n\\n        // Compute the maximum path sum in the left and right subtrees\\n        // int left = maxPathDown(root.left,maxValue);\\n        // int right = maxPathDown(root.right,maxValue);\\n\\n        // Modify the above lines to take care of negative values\\n        int left = Math.max(0,maxPathDown(root.left,maxValue));\\n        int right = Math.max(0,maxPathDown(root.right,maxValue));\\n\\n        // Update the max path sum if the path passing through the current node has a greater sum\\n        maxValue[0] = Math.max(maxValue[0], left + right + root.val);\\n\\n        // Return the maximum path sum down to the current node\\n        return Math.max(left,right) + root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        \\n        int maxValue[] = new int[1]; // Create an array to hold the max value\\n        maxValue[0] = Integer.MIN_VALUE; // Initialize the max value to the lowest possible integer value\\n        maxPathDown(root,maxValue); // Call the recursive helper function to compute the max path sum\\n\\n        return maxValue[0]; // Return the max path sum\\n    }\\n\\n    public int maxPathDown(TreeNode root, int maxValue[]){\\n\\n        if(root == null){ // Base case: If the node is null, return 0\\n            return 0;\\n        }\\n\\n        // Compute the maximum path sum in the left and right subtrees\\n        // int left = maxPathDown(root.left,maxValue);\\n        // int right = maxPathDown(root.right,maxValue);\\n\\n        // Modify the above lines to take care of negative values\\n        int left = Math.max(0,maxPathDown(root.left,maxValue));\\n        int right = Math.max(0,maxPathDown(root.right,maxValue));\\n\\n        // Update the max path sum if the path passing through the current node has a greater sum\\n        maxValue[0] = Math.max(maxValue[0], left + right + root.val);\\n\\n        // Return the maximum path sum down to the current node\\n        return Math.max(left,right) + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327481,
                "title": "java-dfs-solution-beats-100-online-submissions",
                "content": "# Complexity\\n- Time complexity: **O(N)**\\n\\n- Space complexity: **O(N)**\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int ans = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n\\n        update(root);\\n\\n        return ans;\\n    }\\n\\n    private int update(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int leftsum = Math.max(update(root.left),0);\\n        int rightsum = Math.max(update(root.right),0);\\n\\n        ans = Math.max(ans,leftsum+rightsum+root.val);\\n\\n        return Math.max(leftsum+root.val, rightsum+root.val);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    int ans = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n\\n        update(root);\\n\\n        return ans;\\n    }\\n\\n    private int update(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int leftsum = Math.max(update(root.left),0);\\n        int rightsum = Math.max(update(root.right),0);\\n\\n        ans = Math.max(ans,leftsum+rightsum+root.val);\\n\\n        return Math.max(leftsum+root.val, rightsum+root.val);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296155,
                "title": "time-space-o-n-short-sweet-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int &ans){\\n        if(root == NULL)return 0;\\n        int l = solve(root->left,ans);\\n        int r = solve(root->right,ans);\\n        ans = max({ans,root->val,root->val+max({l,r,l+r})});\\n        return max({root->val,root->val+max({l,r})});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        return max(ans,solve(root,ans));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int &ans){\\n        if(root == NULL)return 0;\\n        int l = solve(root->left,ans);\\n        int r = solve(root->right,ans);\\n        ans = max({ans,root->val,root->val+max({l,r,l+r})});\\n        return max({root->val,root->val+max({l,r})});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        return max(ans,solve(root,ans));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280297,
                "title": "note-made-it-clear-onlycode-in-java",
                "content": "# Note\\nIn the maxPathSum function, we want to find the maximum path sum in a binary tree. To accomplish this, we traverse the binary tree and compute the sum of all paths from the root node to a leaf node.\\n\\nDuring the traversal, we keep track of the maximum path sum found so far in the max[0] variable. This variable is initialized to Integer.MIN_VALUE at the beginning of the function.\\n\\nNow, let\\'s consider what would happen if we don\\'t initialize max[0] to Integer.MIN_VALUE. If we simply declare the max array without initializing it, then the default value for an integer, which is 0, would be used as the initial value for max[0].\\n\\nIf all the path sum values in the binary tree are negative, the max[0] variable would never get updated, because every path sum value encountered during the traversal would be less than max[0] (which is 0). Therefore, the function would return 0, which is not correct, since there could be negative path sum values that are less than 0.\\n\\nOn the other hand, by initializing max[0] to Integer.MIN_VALUE, we ensure that max[0] will always be updated with the correct maximum path sum value during the traversal, even if all the path sum values are negative. This is because any path sum value encountered during the traversal will be greater than or equal to Integer.MIN_VALUE, so max[0] will always get updated with the maximum path sum value found so far.\\n\\nTherefore, it is important to initialize max[0] to a value that is lower than any possible path sum value in the binary tree. By convention, Integer.MIN_VALUE is used as the initial value for maximum path sum problems to ensure that max[0] gets updated correctly during the traversal.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int max[]= new int[1];\\n        max[0] = Integer.MIN_VALUE;\\n        ht(root,max);\\n        return max[0];\\n    }\\n    public int ht(TreeNode root,int maxValue[]){\\n        if(root==null) return 0;\\n        int lh = Math.max(0,ht(root.left,maxValue));\\n        int rh = Math.max(0,ht(root.right,maxValue));\\n        maxValue[0] = Math.max(maxValue[0], lh + rh + root.val);\\n        return root.val + Math.max(lh,rh);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int max[]= new int[1];\\n        max[0] = Integer.MIN_VALUE;\\n        ht(root,max);\\n        return max[0];\\n    }\\n    public int ht(TreeNode root,int maxValue[]){\\n        if(root==null) return 0;\\n        int lh = Math.max(0,ht(root.left,maxValue));\\n        int rh = Math.max(0,ht(root.right,maxValue));\\n        maxValue[0] = Math.max(maxValue[0], lh + rh + root.val);\\n        return root.val + Math.max(lh,rh);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270970,
                "title": "1ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int maximum[]=new int[1];\\n        maximum[0]=Integer.MIN_VALUE;\\n        maxPathDown(root,maximum);\\n        return maximum[0];\\n    }\\n    public int maxPathDown(TreeNode node,int maximum[]){\\n        if(node==null){\\n            return 0;\\n        }\\n        int left=Math.max(0,maxPathDown(node.left,maximum));\\n        int right=Math.max(0,maxPathDown(node.right,maximum));\\n        maximum[0]=Math.max(maximum[0],left+right+node.val);\\n        return Math.max(left,right)+node.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int maximum[]=new int[1];\\n        maximum[0]=Integer.MIN_VALUE;\\n        maxPathDown(root,maximum);\\n        return maximum[0];\\n    }\\n    public int maxPathDown(TreeNode node,int maximum[]){\\n        if(node==null){\\n            return 0;\\n        }\\n        int left=Math.max(0,maxPathDown(node.left,maximum));\\n        int right=Math.max(0,maxPathDown(node.right,maximum));\\n        maximum[0]=Math.max(maximum[0],left+right+node.val);\\n        return Math.max(left,right)+node.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936559,
                "title": "striver-recursive-simple-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int[] maxp=new int[1]; //to pass the maxp integer by reference\\n        maxp[0]=Integer.MIN_VALUE; //because we have to compare to find max\\n        solver(root,maxp);\\n        return maxp[0];\\n    }\\n\\n    public int solver(TreeNode root, int[] maxp){\\n        if(root==null) return 0;\\n        int lh=solver(root.left,maxp); //max path sum from left \\n        int rh=solver(root.right,maxp); //max path sum from right\\n        maxp[0]=Math.max(maxp[0],lh+rh+root.val); \\n        int ret= Math.max(root.val,Math.max(lh,rh)+root.val); //max of root and \\n        maxp[0]=Math.max(maxp[0],ret);// max stores the max of (root value, root+maxLeft/right ,path sum including the node from right to left,previous max)\\n        //max can be a discontinuos set sum but returned value is a continous part of branch of tree\\n        return ret; //max path sum from this node \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int[] maxp=new int[1]; //to pass the maxp integer by reference\\n        maxp[0]=Integer.MIN_VALUE; //because we have to compare to find max\\n        solver(root,maxp);\\n        return maxp[0];\\n    }\\n\\n    public int solver(TreeNode root, int[] maxp){\\n        if(root==null) return 0;\\n        int lh=solver(root.left,maxp); //max path sum from left \\n        int rh=solver(root.right,maxp); //max path sum from right\\n        maxp[0]=Math.max(maxp[0],lh+rh+root.val); \\n        int ret= Math.max(root.val,Math.max(lh,rh)+root.val); //max of root and \\n        maxp[0]=Math.max(maxp[0],ret);// max stores the max of (root value, root+maxLeft/right ,path sum including the node from right to left,previous max)\\n        //max can be a discontinuos set sum but returned value is a continous part of branch of tree\\n        return ret; //max path sum from this node \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902290,
                "title": "binary-tree-maximum-path-sum-c-o-n-solution",
                "content": "# Intuition\\nDFS and max between left and right subtree.\\n\\n# Approach\\nUse dfs and check max left and right subtree value then return max(current,left,right), and check max answer at each and every node.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int ans = INT_MIN;\\n    int solve(TreeNode * root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        \\n        int left = solve(root->left);\\n        int right = solve(root->right);\\n        // calculate the max path \\n        // considering current node as a part of the path\\n        int path = root->val;\\n        path = max(path,path+left);\\n        path = max(path,path+right);\\n\\n        //store the ans\\n        ans = max(ans,path);\\n\\n        // return max(current node, left subtree, right subtree);\\n        return max(root->val,root->val+max(left,right));        \\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        ans = root->val;\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int ans = INT_MIN;\\n    int solve(TreeNode * root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        \\n        int left = solve(root->left);\\n        int right = solve(root->right);\\n        // calculate the max path \\n        // considering current node as a part of the path\\n        int path = root->val;\\n        path = max(path,path+left);\\n        path = max(path,path+right);\\n\\n        //store the ans\\n        ans = max(ans,path);\\n\\n        // return max(current node, left subtree, right subtree);\\n        return max(root->val,root->val+max(left,right));        \\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        ans = root->val;\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902181,
                "title": "c-dfs-single-traversal-easy-to-understand",
                "content": "# Intuition\\nwe have to calculate sum of each possible path in a binary tree and then maximize it and store the maximum sum into any variable. So, we can use subtree sum where we can pick the max sum obtained from left subtree and right subtree and on the same time maximize the maxSum (holds the maximum sum of any particular path in a tree)variable as well. \\n\\n# Approach\\nevery time we are going to a particular node we recursively calculating the left sum (left subtree sum) and right sum (right subtree sum) and store them in specified variables. Then we have to maximize the maxSum variable by adding current node value into our leftsubtree sum and rightsubtree sum. At last, we are returning the maximum of leftsubtree sum and rightsubtree sum by adding the root value into it.\\n\\n# Complexity\\n- Time complexity:\\no(h) where h is the height of the tree. In worst case it can got upto o(n) where n is the number of nodes in the tree.\\n\\n- Space complexity:\\n0(n) functional call is stack is used \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int solve(TreeNode* root, int& maxSum) {\\n        if(root == NULL) return 0;\\n        \\n        int lSum = max(0, solve(root->left,maxSum));\\n        int rSum = max(0, solve(root->right,maxSum));\\n        \\n        maxSum = max(maxSum, lSum + rSum + root->val);\\n        \\n        return root->val + max(lSum,rSum);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        int maxSum = INT_MIN;\\n        solve(root,maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int solve(TreeNode* root, int& maxSum) {\\n        if(root == NULL) return 0;\\n        \\n        int lSum = max(0, solve(root->left,maxSum));\\n        int rSum = max(0, solve(root->right,maxSum));\\n        \\n        maxSum = max(maxSum, lSum + rSum + root->val);\\n        \\n        return root->val + max(lSum,rSum);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        int maxSum = INT_MIN;\\n        solve(root,maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901692,
                "title": "easy-c-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint maxi = INT_MIN;\\n    int dfs(TreeNode* root){\\n        if(!root) return 0;\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n        maxi = max(maxi , root->val+l+r);\\n        int sum = root->val + max(l , r);\\n        if(sum<0){\\n            sum=0;\\n        }\\n        return sum;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        dfs(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint maxi = INT_MIN;\\n    int dfs(TreeNode* root){\\n        if(!root) return 0;\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n        maxi = max(maxi , root->val+l+r);\\n        int sum = root->val + max(l , r);\\n        if(sum<0){\\n            sum=0;\\n        }\\n        return sum;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        dfs(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901370,
                "title": "java-easiest-solution-possible",
                "content": "# Code\\n```\\nclass Solution {\\n    private static int ans = Integer.MIN_VALUE;\\n    private static int PathMax(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int left = PathMax(root.left);\\n        int right = PathMax(root.right);\\n        int ms = Math.max(Math.max(left,right)+root.val, root.val);\\n        int ms_1 = Math.max((left+right+root.val), ms);\\n        ans = Math.max(ans, ms_1);\\n\\n        return ms;\\n    }\\n    public int maxPathSum(TreeNode root) {\\n        ans = Integer.MIN_VALUE;\\n        PathMax(root);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static int ans = Integer.MIN_VALUE;\\n    private static int PathMax(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int left = PathMax(root.left);\\n        int right = PathMax(root.right);\\n        int ms = Math.max(Math.max(left,right)+root.val, root.val);\\n        int ms_1 = Math.max((left+right+root.val), ms);\\n        ans = Math.max(ans, ms_1);\\n\\n        return ms;\\n    }\\n    public int maxPathSum(TreeNode root) {\\n        ans = Integer.MIN_VALUE;\\n        PathMax(root);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900237,
                "title": "simple-dfs-log-n",
                "content": "1. Find non negative leftPathSum\\n2. Find non negative rightPathSum\\n3. Calculate maxPathSum for current Node (left+right+root.val)\\n4. Compair final ans and update it.\\n\\n# Code\\n### Python\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n\\n        self.ans = float(\\'-inf\\')\\n        def leftRightSum(root):\\n            if not root:\\n                return 0\\n            l = max(leftRightSum(root.left), 0)\\n            r = max(leftRightSum(root.right), 0)\\n            self.ans = max(l+r+root.val, self.ans)\\n            # print(l, r, root.val, self.ans)\\n            return max(l, r) + root.val\\n        \\n        leftRightSum(root)\\n        return self.ans\\n\\n```\\n### Go\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc maxPathSum(root *TreeNode) int {\\n    ans := -1 << 63\\n    maxPath(root, &ans)\\n    return ans\\n}\\n\\nfunc maxPath(root *TreeNode, ans *int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    leftPathSum := maxPath(root.Left, ans)\\n    rightPathSum := maxPath(root.Right, ans)\\n    *ans = max(*ans, leftPathSum + rightPathSum + root.Val)\\n    return max(max(leftPathSum+root.Val, rightPathSum+root.Val), 0)\\n}\\n\\nfunc max(a int, b int) int {\\n    if (a >= b) {\\n        return a\\n    }\\n    return b\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n\\n        self.ans = float(\\'-inf\\')\\n        def leftRightSum(root):\\n            if not root:\\n                return 0\\n            l = max(leftRightSum(root.left), 0)\\n            r = max(leftRightSum(root.right), 0)\\n            self.ans = max(l+r+root.val, self.ans)\\n            # print(l, r, root.val, self.ans)\\n            return max(l, r) + root.val\\n        \\n        leftRightSum(root)\\n        return self.ans\\n\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc maxPathSum(root *TreeNode) int {\\n    ans := -1 << 63\\n    maxPath(root, &ans)\\n    return ans\\n}\\n\\nfunc maxPath(root *TreeNode, ans *int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    leftPathSum := maxPath(root.Left, ans)\\n    rightPathSum := maxPath(root.Right, ans)\\n    *ans = max(*ans, leftPathSum + rightPathSum + root.Val)\\n    return max(max(leftPathSum+root.Val, rightPathSum+root.Val), 0)\\n}\\n\\nfunc max(a int, b int) int {\\n    if (a >= b) {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899200,
                "title": "easiest-java-solution-faster-than-99-63",
                "content": "**Intuition:**\\nAt every node, check what is the maxium left and right path sum that you can get. Take the max sum of current path (left + root + right). Now return max(left, right) + root.\\n\\n```java\\n class Solution {\\n    public int maxPathSum(TreeNode root) {\\n        solve(root);\\n        return maxSum;\\n    }\\n    \\n    int maxSum = Integer.MIN_VALUE;\\n    int solve(TreeNode root) {\\n        if (root == null) return 0;\\n        int maxLeft = Math.max(0, solve(root.left));\\n        int maxRight = Math.max(0, solve(root.right));\\n        maxSum = Math.max(maxSum, root.val + maxLeft + maxRight);\\n        return root.val + Math.max(maxLeft, maxRight);\\n    }\\n}\\n```\\n**Time complexity :** `O(N)` for traversing all nodes\\n**Space complexity :** `O(N)` for recursion stack space",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n class Solution {\\n    public int maxPathSum(TreeNode root) {\\n        solve(root);\\n        return maxSum;\\n    }\\n    \\n    int maxSum = Integer.MIN_VALUE;\\n    int solve(TreeNode root) {\\n        if (root == null) return 0;\\n        int maxLeft = Math.max(0, solve(root.left));\\n        int maxRight = Math.max(0, solve(root.right));\\n        maxSum = Math.max(maxSum, root.val + maxLeft + maxRight);\\n        return root.val + Math.max(maxLeft, maxRight);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899166,
                "title": "c-easy-explaination",
                "content": "# Intuition\\nAt every node , we have two possible actions \\n1. At this node, we decide to join the paths from left and right , which means we are trying to form our answer from this node.\\n2. Find the maximum path from left and right , so that it can be used by the ancestor nodes to perform action 1.\\n\\n# Approach\\n1. We will just do a postorder traversal\\n2. At each node, we maximise the answer by adding maximum in left and right\\n3. At the same time we find the maximum path, from left and right\\n4. If the pathsum becomes less than 0, we should drop that path\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(h) h=height of tree \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int helper(TreeNode * root){\\n        if(!root) return 0;\\n        int left = helper(root->left);\\n        int right = helper(root->right);\\n        ans = max(ans , left+right+root->val);\\n        return max({left+root->val,right+root->val,0});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int helper(TreeNode * root){\\n        if(!root) return 0;\\n        int left = helper(root->left);\\n        int right = helper(root->right);\\n        ans = max(ans , left+right+root->val);\\n        return max({left+root->val,right+root->val,0});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899138,
                "title": "simple-and-easy-to-understand-c-recursive-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is quiet simple just travel each node and get max positive path cost of left and right sub tree. Check if cost of left and right sub tree plus cost of node is greater than max path cost till now then update it. Return max positive path cost from left and right sub with increment of node\\'s cost.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ if Consider Recursive Call Stack then Space Complexity will be $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int getMaxPath(TreeNode* root, int &maxPath){\\n        if(!root)\\n            return 0;\\n        int leftVal = max(getMaxPath(root->left, maxPath),0);\\n        int rightVal = max(getMaxPath(root->right, maxPath),0);\\n        maxPath = max(maxPath, root->val+leftVal+rightVal);\\n        return max(leftVal, rightVal)+root->val;\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int maxPath = -1001;\\n        getMaxPath(root, maxPath);\\n        return maxPath;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int getMaxPath(TreeNode* root, int &maxPath){\\n        if(!root)\\n            return 0;\\n        int leftVal = max(getMaxPath(root->left, maxPath),0);\\n        int rightVal = max(getMaxPath(root->right, maxPath),0);\\n        maxPath = max(maxPath, root->val+leftVal+rightVal);\\n        return max(leftVal, rightVal)+root->val;\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int maxPath = -1001;\\n        getMaxPath(root, maxPath);\\n        return maxPath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899130,
                "title": "java-beat-99-6-post-order-traversal-easy-solution",
                "content": "```\\n    //post order traverse\\n    int res = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        getSiglePathMax(root);\\n        return res;\\n    }\\n    \\n    private int getSiglePathMax(TreeNode root) {\\n        if(root == null) return 0;\\n        //no need to add if it\\'s negetive\\n        int left = Math.max(0, getSiglePathMax(root.left));\\n        int right = Math.max(0, getSiglePathMax(root.right));\\n        int curPath = left + right + root.val;\\n        res = Math.max(res, curPath);\\n        return Math.max(left, right) + root.val;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    //post order traverse\\n    int res = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        getSiglePathMax(root);\\n        return res;\\n    }\\n    \\n    private int getSiglePathMax(TreeNode root) {\\n        if(root == null) return 0;\\n        //no need to add if it\\'s negetive\\n        int left = Math.max(0, getSiglePathMax(root.left));\\n        int right = Math.max(0, getSiglePathMax(root.right));\\n        int curPath = left + right + root.val;\\n        res = Math.max(res, curPath);\\n        return Math.max(left, right) + root.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831066,
                "title": "c-o-n-solution-with-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int as(TreeNode* root,int& ans){\\n        if(root==NULL) return 0;\\n        int l=as(root->left,ans);\\n        if(l<0) l=0;\\n        int r=as(root->right,ans);\\n        if(r<0) r=0;\\n        ans=max(ans,root->val+l+r);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        as(root,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int as(TreeNode* root,int& ans){\\n        if(root==NULL) return 0;\\n        int l=as(root->left,ans);\\n        if(l<0) l=0;\\n        int r=as(root->right,ans);\\n        if(r<0) r=0;\\n        ans=max(ans,root->val+l+r);\\n        return root->val+max(l,r);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2749045,
                "title": "easy-c-solution-o-n-with-comments",
                "content": "Here is my C++ Solution :\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    int demo (TreeNode* root){\\n        if (root==NULL)return 0;\\n        int ls= max(0,demo(root->left));   // taking max with 0 to avoid negative nodes\\n        int rs= max(0,demo(root->right));\\n        maxi = max(maxi, root->val+ls+rs); // for umbrellas;\\n        return root->val + max(ls,rs); // for along heights;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        demo(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    int demo (TreeNode* root){\\n        if (root==NULL)return 0;\\n        int ls= max(0,demo(root->left));   // taking max with 0 to avoid negative nodes\\n        int rs= max(0,demo(root->right));\\n        maxi = max(maxi, root->val+ls+rs); // for umbrellas;\\n        return root->val + max(ls,rs); // for along heights;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        demo(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571541,
                "title": "very-easy-solution-binary-tree-maximum-path-sum",
                "content": "class Solution {\\npublic:\\n    int solve(TreeNode*root, int &res){\\n        if(!root) return 0;\\n        \\n        int l=solve(root->left, res);\\n        int r=solve(root->right, res);\\n        \\n        int temp=max(max(l,r)+root->val, root->val);\\n      //  cout<<temp<<\" \"<<endl;\\n        int ans=max(temp, l+r+root->val);\\n        cout<<ans<<\" \";\\n        res=max(res,ans);\\n        \\n        return temp;\\n        \\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int res=INT_MIN;\\n        solve(root, res);\\n        \\n        return res;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int solve(TreeNode*root, int &res){\\n        if(!root) return 0;\\n        \\n        int l=solve(root->left, res);\\n        int r=solve(root->right, res);\\n        \\n        int temp=max(max(l,r)+root->val, root->val);\\n      //  cout<<temp<<\" \"<<endl;\\n        int ans=max(temp, l+r+root->val);\\n        cout<<ans<<\" \";\\n        res=max(res,ans);\\n        \\n        return temp;\\n        \\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2392892,
                "title": "5-line-c-dfs-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n    \\n    int dfs(TreeNode* node , int &ans) {\\n        if(node == NULL) return 0;\\n        int l = max(0, dfs(node->left, ans));\\n        int r = max(0, dfs(node->right, ans));\\n        ans = max(ans, l + r + node->val);\\n        return max(l, r) + node->val;\\n    }\\n};\\n```\\n**Please Upvote\\nthank you!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n    \\n    int dfs(TreeNode* node , int &ans) {\\n        if(node == NULL) return 0;\\n        int l = max(0, dfs(node->left, ans));\\n        int r = max(0, dfs(node->right, ans));\\n        ans = max(ans, l + r + node->val);\\n        return max(l, r) + node->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262932,
                "title": "simple-c-solution-recursion",
                "content": "Solution -->\\n```\\nclass Solution {\\npublic:\\n    int sum(TreeNode* root, int& ans)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        int left=sum(root->left,ans);\\n        int right=sum(root->right,ans);\\n        \\n        int temp=max(max(left,right)+root->val,root->val);\\n        temp=max(temp,left+right+root->val);\\n        ans=max(ans,temp);\\n        return max(max(left,right)+root->val,root->val);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        int res = INT_MIN;\\n        sum(root, res);\\n        return res;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum(TreeNode* root, int& ans)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        int left=sum(root->left,ans);\\n        int right=sum(root->right,ans);\\n        \\n        int temp=max(max(left,right)+root->val,root->val);\\n        temp=max(temp,left+right+root->val);\\n        ans=max(ans,temp);\\n        return max(max(left,right)+root->val,root->val);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        int res = INT_MIN;\\n        sum(root, res);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254617,
                "title": "aditya-varma-dp-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int solve(TreeNode *root, int &res)\\n    {\\n        if (root == NULL)\\n            return 0;\\n\\n        int l = solve(root->left, res);\\n        int r = solve(root->right, res);\\n\\n        int temp = max(max(l, r) + root->val, root->val);\\n        int ans = max(temp, l + r + root->val);\\n        res = max(res, ans);\\n        return temp;\\n    }\\n\\n    int maxPathSum(TreeNode *root)\\n    {\\n        int res = INT_MIN;\\n        solve(root, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int solve(TreeNode *root, int &res)\\n    {\\n        if (root == NULL)\\n            return 0;\\n\\n        int l = solve(root->left, res);\\n        int r = solve(root->right, res);\\n\\n        int temp = max(max(l, r) + root->val, root->val);\\n        int ans = max(temp, l + r + root->val);\\n        res = max(res, ans);\\n        return temp;\\n    }\\n\\n    int maxPathSum(TreeNode *root)\\n    {\\n        int res = INT_MIN;\\n        solve(root, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177649,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mx=-1001;\\n    int getans(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int left=max(0,getans(root->left));\\n        int right=max(0,getans(root->right));\\n        \\n        mx=max(mx,root->val+left+right);\\n        return max(left,right)+root->val;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int k= getans(root);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mx=-1001;\\n    int getans(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int left=max(0,getans(root->left));\\n        int right=max(0,getans(root->right));\\n        \\n        mx=max(mx,root->val+left+right);\\n        return max(left,right)+root->val;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int k= getans(root);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105359,
                "title": "java-commented-beats-100",
                "content": "**Idea**: At any point in time we need to maintain the best at that node but the value that we bubble up must be part of a path (cannot have both children), so we must choose the best of current value with left subtree, right subtree or the current node\\'s value itself. But our actual maximum may go through the root, so we can keep track of it separately.\\nRest is explained with comments.\\n\\n```\\nclass Solution {\\n\\t// to maintain the actual maximum sum of path\\n    int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        path(root);\\n        return max;\\n    }\\n    \\n    private int path(TreeNode node) {\\n\\t\\t// base case\\n        if(node == null) {\\n            return 0;\\n        }\\n        \\n\\t\\t// traverse left and right subtrees\\n        int left = path(node.left);\\n        int right = path(node.right);\\n        \\n\\t\\t// get the best of left subtree + current node\\'s val vs. right subtree + current node\\'s val vs. current node\\'s val \\n\\t\\t// as this value will ensure either of the path (left, right or just from the current node itself but not both the children)\\n\\t\\t// we return this to the parent\\n        int leftOrRightOrCurrent = \\n            Math.max(Math.max(left + node.val, right + node.val), node.val);\\n\\t\\t\\n\\t\\t// maximum of current node\\'s val vs. all the above possibilities to see if this is actually the max path?\\n\\t\\t// best max path upto this node is this (localMaxima)\\n        int localMaxima = Math.max(left + right + node.val, leftOrRightOrCurrent);\\n            \\n        // overall maximum\\n\\t\\t// compare the localMaxima with overall tree\\'s max value, this will be our answer\\n        max = Math.max(localMaxima, max);\\n        \\n\\t\\t// return to parent as discussed earlier\\n        return leftOrRightOrCurrent;\\n    }\\n}\\n```\\n\\n**Time Complexity: O(N)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t// to maintain the actual maximum sum of path\\n    int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        path(root);\\n        return max;\\n    }\\n    \\n    private int path(TreeNode node) {\\n\\t\\t// base case\\n        if(node == null) {\\n            return 0;\\n        }\\n        \\n\\t\\t// traverse left and right subtrees\\n        int left = path(node.left);\\n        int right = path(node.right);\\n        \\n\\t\\t// get the best of left subtree + current node\\'s val vs. right subtree + current node\\'s val vs. current node\\'s val \\n\\t\\t// as this value will ensure either of the path (left, right or just from the current node itself but not both the children)\\n\\t\\t// we return this to the parent\\n        int leftOrRightOrCurrent = \\n            Math.max(Math.max(left + node.val, right + node.val), node.val);\\n\\t\\t\\n\\t\\t// maximum of current node\\'s val vs. all the above possibilities to see if this is actually the max path?\\n\\t\\t// best max path upto this node is this (localMaxima)\\n        int localMaxima = Math.max(left + right + node.val, leftOrRightOrCurrent);\\n            \\n        // overall maximum\\n\\t\\t// compare the localMaxima with overall tree\\'s max value, this will be our answer\\n        max = Math.max(localMaxima, max);\\n        \\n\\t\\t// return to parent as discussed earlier\\n        return leftOrRightOrCurrent;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017695,
                "title": "java-best-solution-easy",
                "content": "IF YOU FIND THE SOLUTION HELPFULL , KINDLY UPVOTE.\\nThank You\\n\\n```\\npublic class Solution {\\n  int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n      helper(root);\\n      return max;\\n    }\\n  int helper(TreeNode root) {\\n    if(root == null) return 0;\\n    int left = Math.max(helper(root.left), 0);\\n    int right = Math.max(helper(root.right), 0);  \\n    \\n    max = Math.max(max, root.val + left + right);\\n    return root.val + Math.max(left, right);\\n  }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n  int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n      helper(root);\\n      return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1944012,
                "title": "beats-96-91-5-lines-logic-c",
                "content": "1. First thing is we have to traverse every node. So it needs a DFS solution.\\n2. On every node, we need to find out maximum left and right downward path. Node should only focus on its children and grandchildren.\\n3. At every node, if its left or right path is > 0, then only it is going to increase the sum. So we use **max(leftSum, 0)** and **max(rightSum, 0)**\\n4. At every node, we calculate node->val + left + right and compare it with answer till now and update the answer if the current node has a better value.\\n5. Tricky and important part what should DFS return at every node. Whatever current DFS node will return will be used by its parent. \\ne.g. \\n____________________________________1\\n___________________________2_____________3\\n________________________4___5_________6___7\\n\\nSo it should return current **node->val + max(left,right)**. Because parent cannot use its children\\'s both left and right sum. In above example, DFS(2) should return 2 + max(4,5), because 1 can include only 4 or 5 in its path\\n\\n```\\nclass Solution {\\nprivate:\\n    int DFS(TreeNode* root, int& ans) {\\n        if(root == NULL) return 0;\\n        int left = max(DFS(root->left, ans), 0);\\n        int right = max(DFS(root->right, ans), 0);\\n\\n        int sum = root->val + left + right;\\n        ans = max(ans, sum);\\n        return root->val + max(left, right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        DFS(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int DFS(TreeNode* root, int& ans) {\\n        if(root == NULL) return 0;\\n        int left = max(DFS(root->left, ans), 0);\\n        int right = max(DFS(root->right, ans), 0);\\n\\n        int sum = root->val + left + right;\\n        ans = max(ans, sum);\\n        return root->val + max(left, right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        DFS(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870416,
                "title": "we-just-have-to-find-the-diameter-java-beats-100-with-explanation",
                "content": "**Approach and Intuition:-**  In this question, the catch is to find the diameter of the binary tree, with little changes. Instead of just finding the left and right height of a particular node in the tree, we find the maximum left and right heights of that node, including it. The remaining steps are similar to the \\'diameter\\' problem, but we need to ensure that while returning the ```max(lh,rh)```, we need to add ```root.val``` to it, because the path passes through that node too. \\n\\n**Code:-**\\n\\n```\\n    int ans=Integer.MIN_VALUE;;\\n    public int maxPathSum(TreeNode root)\\n    {\\n        height(root);\\n        return ans;\\n    }\\n    public int height(TreeNode root)\\n    {\\n        if (root==null) return 0;\\n        int lh=Math.max(0,height(root.left));\\n        int rh=Math.max(0,height(root.right));\\n        ans=Math.max(ans,lh+rh+root.val);\\n        return Math.max(lh,rh)+root.val;\\n    }\\n```\\t\\n\\n**Time Complexity:-**  O(n), where n is the number of nodes\\n**Space Complexity:-**  O(h), where h is the height of the binary tree",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```max(lh,rh)```\n```root.val```\n```\\n    int ans=Integer.MIN_VALUE;;\\n    public int maxPathSum(TreeNode root)\\n    {\\n        height(root);\\n        return ans;\\n    }\\n    public int height(TreeNode root)\\n    {\\n        if (root==null) return 0;\\n        int lh=Math.max(0,height(root.left));\\n        int rh=Math.max(0,height(root.right));\\n        ans=Math.max(ans,lh+rh+root.val);\\n        return Math.max(lh,rh)+root.val;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1712502,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1567490,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1712498,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1575621,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568229,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568300,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1567489,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1573705,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568163,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568185,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1712502,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1567490,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1712498,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1575621,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568229,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568300,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1567489,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1573705,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568163,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568185,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1719855,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1575882,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1568161,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1568372,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1831659,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1574509,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1570162,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1573688,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1569581,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1569384,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1571258,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1568939,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1968277,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1913206,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1713496,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1713041,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1712996,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1576840,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1574948,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1574635,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1574522,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1574241,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573743,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573728,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573179,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573082,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573043,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573000,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1572765,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1572530,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1571918,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1571256,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1571257,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1571259,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1571260,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1569854,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1569832,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1574464,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 2053458,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 2049353,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 2044402,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2043278,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2043258,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2029786,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2015070,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2011346,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2001542,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 1995849,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 1985488,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 1976870,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 1968407,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1960420,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1954087,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1949563,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1948314,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1944726,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1936781,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1929615,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1904357,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1891895,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1891194,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1881384,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1867463,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1809989,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1784664,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1741884,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1728215,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1723785,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1720514,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1719123,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1714502,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713611,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713526,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713491,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713442,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713415,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713277,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713269,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713171,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713050,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            }
        ]
    },
    {
        "title": "Basic Calculator",
        "question_content": "<p>Given a string <code>s</code> representing a valid expression, implement a basic calculator to evaluate it, and return <em>the result of the evaluation</em>.</p>\n\n<p><strong>Note:</strong> You are <strong>not</strong> allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1 + 1&quot;\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; 2-1 + 2 &quot;\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(1+(4+5+2)-3)+(6+8)&quot;\n<strong>Output:</strong> 23\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, and <code>&#39; &#39;</code>.</li>\n\t<li><code>s</code> represents a valid expression.</li>\n\t<li><code>&#39;+&#39;</code> is <strong>not</strong> used as a unary operation (i.e., <code>&quot;+1&quot;</code> and <code>&quot;+(2 + 3)&quot;</code> is invalid).</li>\n\t<li><code>&#39;-&#39;</code> could be used as a unary operation (i.e., <code>&quot;-1&quot;</code> and <code>&quot;-(2 + 3)&quot;</code> is valid).</li>\n\t<li>There will be no two consecutive operators in the input.</li>\n\t<li>Every number and running calculation will fit in a signed 32-bit integer.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 62361,
                "title": "iterative-java-solution-with-stack",
                "content": "Simple iterative solution by identifying characters one by one. One important thing is that the input is valid, which means the parentheses are always paired and in order.\\nOnly 5 possible input we need to pay attention:\\n\\n 1. digit: it should be one digit from the current number\\n 2. '+': number is over, we can add the previous number and start a new number\\n 3. '-': same as above\\n 4. '(': push the previous result and the sign into the stack, set result to 0, just calculate the new result within the parenthesis.\\n 5. ')': pop out the top two numbers from stack, first one is the sign before this pair of parenthesis, second is the temporary result before this pair of parenthesis. We add them together.\\n \\n \\nFinally if there is only one number, from the above solution, we haven't add the number to the result, so we do a check see if the number is zero.\\n\\n----------\\n\\n\\n    public int calculate(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int result = 0;\\n        int number = 0;\\n        int sign = 1;\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(Character.isDigit(c)){\\n                number = 10 * number + (int)(c - '0');\\n            }else if(c == '+'){\\n                result += sign * number;\\n                number = 0;\\n                sign = 1;\\n            }else if(c == '-'){\\n                result += sign * number;\\n                number = 0;\\n                sign = -1;\\n            }else if(c == '('){\\n                //we push the result first, then sign;\\n                stack.push(result);\\n                stack.push(sign);\\n                //reset the sign and result for the value in the parenthesis\\n                sign = 1;   \\n                result = 0;\\n            }else if(c == ')'){\\n                result += sign * number;  \\n                number = 0;\\n                result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n                result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n                \\n            }\\n        }\\n        if(number != 0) result += sign * number;\\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "Simple iterative solution by identifying characters one by one. One important thing is that the input is valid, which means the parentheses are always paired and in order.\\nOnly 5 possible input we need to pay attention:\\n\\n 1. digit: it should be one digit from the current number\\n 2. '+': number is over, we can add the previous number and start a new number\\n 3. '-': same as above\\n 4. '(': push the previous result and the sign into the stack, set result to 0, just calculate the new result within the parenthesis.\\n 5. ')': pop out the top two numbers from stack, first one is the sign before this pair of parenthesis, second is the temporary result before this pair of parenthesis. We add them together.\\n \\n \\nFinally if there is only one number, from the above solution, we haven't add the number to the result, so we do a check see if the number is zero.\\n\\n----------\\n\\n\\n    public int calculate(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int result = 0;\\n        int number = 0;\\n        int sign = 1;\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(Character.isDigit(c)){\\n                number = 10 * number + (int)(c - '0');\\n            }else if(c == '+'){\\n                result += sign * number;\\n                number = 0;\\n                sign = 1;\\n            }else if(c == '-'){\\n                result += sign * number;\\n                number = 0;\\n                sign = -1;\\n            }else if(c == '('){\\n                //we push the result first, then sign;\\n                stack.push(result);\\n                stack.push(sign);\\n                //reset the sign and result for the value in the parenthesis\\n                sign = 1;   \\n                result = 0;\\n            }else if(c == ')'){\\n                result += sign * number;  \\n                number = 0;\\n                result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n                result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n                \\n            }\\n        }\\n        if(number != 0) result += sign * number;\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62362,
                "title": "java-easy-version-to-understand",
                "content": "    public static int calculate(String s) {\\n\\t\\tint len = s.length(), sign = 1, result = 0;\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (Character.isDigit(s.charAt(i))) {\\n\\t\\t\\t\\tint sum = s.charAt(i) - '0';\\n\\t\\t\\t\\twhile (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n\\t\\t\\t\\t\\tsum = sum * 10 + s.charAt(i + 1) - '0';\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult += sum * sign;\\n\\t\\t\\t} else if (s.charAt(i) == '+')\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\telse if (s.charAt(i) == '-')\\n\\t\\t\\t\\tsign = -1;\\n\\t\\t\\telse if (s.charAt(i) == '(') {\\n\\t\\t\\t\\tstack.push(result);\\n\\t\\t\\t\\tstack.push(sign);\\n\\t\\t\\t\\tresult = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t} else if (s.charAt(i) == ')') {\\n\\t\\t\\t\\tresult = result * stack.pop() + stack.pop();\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    public static int calculate(String s) {\\n\\t\\tint len = s.length(), sign = 1, result = 0;\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (Character.isDigit(s.charAt(i))) {\\n\\t\\t\\t\\tint sum = s.charAt(i) - '0';\\n\\t\\t\\t\\twhile (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n\\t\\t\\t\\t\\tsum = sum * 10 + s.charAt(i + 1) - '0';\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult += sum * sign;\\n\\t\\t\\t} else if (s.charAt(i) == '+')\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\telse if (s.charAt(i) == '-')\\n\\t\\t\\t\\tsign = -1;\\n\\t\\t\\telse if (s.charAt(i) == '(') {\\n\\t\\t\\t\\tstack.push(result);\\n\\t\\t\\t\\tstack.push(sign);\\n\\t\\t\\t\\tresult = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t} else if (s.charAt(i) == ')') {\\n\\t\\t\\t\\tresult = result * stack.pop() + stack.pop();\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1456850,
                "title": "python-basic-calculator-i-ii-iii-easy-solution-detailed-explanation",
                "content": "This algorithm works for `Basic Calculator (BC I)` problem, where we can have only `+ - ( )` operations, for `Basic Calculator II (BC II)`, where we can have only `+ - * /` operations and also for `Basic Calculator III (BC III)`, where we can have all `+ - * / ( )` operations.\\n\\n### Stack of monomials\\nThe idea is to use both stack and recursion (which can be seen as 2 stack, because recursion use implicit stack). First, let us consider, that we do not have any brackets. Then let us keep the stack of monomial, consider the example `s = 1*2 - 3\\\\4*5 + 6`.  Then we want our stack to be equal to `[1*2, -3\\\\4*5, 6]`, let us do it step by step:\\n1. Put 1 into stack, we have `stack = [1]`.\\n2. We can see that operation is equal to `*`, so we pop the last element from our stack and put new element: `1*2`, now `stack = [1*2]`.\\n3. Now, operation is equal to `-`, so we  put `-3` to stack and we have `stack = [1*2, -3]` now\\n4. Now, operation is equal to `\\\\`, so we pop the last element from stack and put `-3\\\\4` instead, `stack = [1*2, -3\\\\4]`\\n5. Now, operation is equal to `*`, so we pop last element from stack and put `-3\\\\4*5` instead, `stack = [1*2, -3\\\\4*5]`.\\n6. Finally, operation is equal to `+`, so we put `6` to stack: `stack = [1*2, -3\\\\4*5, 6]`\\n\\nNow, all we need to do is to return sum of all elements in stack.\\n\\n### How to deal with brackets\\nIf we want to be able to process the brackets properly, all we need to do is to call our calculator recursively! When we see the open bracket `(`, we call calculator with the rest of our string, and when we see closed bracket \\')\\', we give back the value of expression inside brackets and the place where we need to start when we go out of recursion.\\n\\n\\n### Complexity\\nEven though we have stack and also have recursion, we process every element only once, so time complexity is `O(n)`. However we pass slice of string as argument each time we meet bracket, so time complexity can go upto `O(n^2)` on example like `(1+(1+(... +)))` with `O(n)` open brackets. Space complexity is potentially `O(n)`, because we need to keep stacks, but each element not more than once.\\n\\n``` \\nclass Solution:\\n    def calculate(self, s):\\n        def update(op, v):\\n            if op == \"+\": stack.append(v)\\n            if op == \"-\": stack.append(-v)\\n            if op == \"*\": stack.append(stack.pop() * v)           #for BC II and BC III\\n            if op == \"/\": stack.append(int(stack.pop() / v))      #for BC II and BC III\\n    \\n        it, num, stack, sign = 0, 0, [], \"+\"\\n        \\n        while it < len(s):\\n            if s[it].isdigit():\\n                num = num * 10 + int(s[it])\\n            elif s[it] in \"+-*/\":\\n                update(sign, num)\\n                num, sign = 0, s[it]\\n            elif s[it] == \"(\":                                        # For BC I and BC III\\n                num, j = self.calculate(s[it + 1:])\\n                it = it + j\\n            elif s[it] == \")\":                                        # For BC I and BC III\\n                update(sign, num)\\n                return sum(stack), it + 1\\n            it += 1\\n        update(sign, num)\\n        return sum(stack)\\n```\\n\\n#### Solution 2\\nThe problem of previous code is that we pass slice of string as parameter. In python it works quite fast, because function is implemented in C and it works very fast. If we want to have honest linear time, we need to pass index as parameter. (there is alternative way like I used in problem **1896** https://leetcode.com/problems/minimum-cost-to-change-the-final-value-of-expression/discuss/1267304/Python-Recursion-dfs-solution-explained, where we can precalculate pairs of open and closing brackets)\\n\\n#### Complexity\\nNow time complexity it is `O(n)`, space is still `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def calculate(self, s):    \\n        def calc(it):\\n            def update(op, v):\\n                if op == \"+\": stack.append(v)\\n                if op == \"-\": stack.append(-v)\\n                if op == \"*\": stack.append(stack.pop() * v)\\n                if op == \"/\": stack.append(int(stack.pop() / v))\\n        \\n            num, stack, sign = 0, [], \"+\"\\n            \\n            while it < len(s):\\n                if s[it].isdigit():\\n                    num = num * 10 + int(s[it])\\n                elif s[it] in \"+-*/\":\\n                    update(sign, num)\\n                    num, sign = 0, s[it]\\n                elif s[it] == \"(\":\\n                    num, j = calc(it + 1)\\n                    it = j - 1\\n                elif s[it] == \")\":\\n                    update(sign, num)\\n                    return sum(stack), it + 1\\n                it += 1\\n            update(sign, num)\\n            return sum(stack)\\n\\n        return calc(0)\\n```",
                "solutionTags": [
                    "Stack",
                    "Recursion"
                ],
                "code": "``` \\nclass Solution:\\n    def calculate(self, s):\\n        def update(op, v):\\n            if op == \"+\": stack.append(v)\\n            if op == \"-\": stack.append(-v)\\n            if op == \"*\": stack.append(stack.pop() * v)           #for BC II and BC III\\n            if op == \"/\": stack.append(int(stack.pop() / v))      #for BC II and BC III\\n    \\n        it, num, stack, sign = 0, 0, [], \"+\"\\n        \\n        while it < len(s):\\n            if s[it].isdigit():\\n                num = num * 10 + int(s[it])\\n            elif s[it] in \"+-*/\":\\n                update(sign, num)\\n                num, sign = 0, s[it]\\n            elif s[it] == \"(\":                                        # For BC I and BC III\\n                num, j = self.calculate(s[it + 1:])\\n                it = it + j\\n            elif s[it] == \")\":                                        # For BC I and BC III\\n                update(sign, num)\\n                return sum(stack), it + 1\\n            it += 1\\n        update(sign, num)\\n        return sum(stack)\\n```\n```python\\nclass Solution:\\n    def calculate(self, s):    \\n        def calc(it):\\n            def update(op, v):\\n                if op == \"+\": stack.append(v)\\n                if op == \"-\": stack.append(-v)\\n                if op == \"*\": stack.append(stack.pop() * v)\\n                if op == \"/\": stack.append(int(stack.pop() / v))\\n        \\n            num, stack, sign = 0, [], \"+\"\\n            \\n            while it < len(s):\\n                if s[it].isdigit():\\n                    num = num * 10 + int(s[it])\\n                elif s[it] in \"+-*/\":\\n                    update(sign, num)\\n                    num, sign = 0, s[it]\\n                elif s[it] == \"(\":\\n                    num, j = calc(it + 1)\\n                    it = j - 1\\n                elif s[it] == \")\":\\n                    update(sign, num)\\n                    return sum(stack), it + 1\\n                it += 1\\n            update(sign, num)\\n            return sum(stack)\\n\\n        return calc(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62344,
                "title": "easy-18-lines-c-16-lines-python",
                "content": "Keep a global running total and a stack of signs (+1 or -1), one for each open scope. The \"global\" outermost sign is +1.\\n\\n- Each number consumes a sign.\\n- Each `+` and `-` causes a new sign.\\n- Each `(` duplicates the current sign so it can be used for the first term inside the new scope. That's also why I start with `[1, 1]` - the global sign 1 and a duplicate to be used for the first term, since expressions start like `3...` or `(...`, not like `+3...` or `+(...`.\\n- Each `)` closes the current scope and thus drops the current sign.\\n\\nAlso see the example trace below my programs.\\n\\n**C++:**\\n\\n    int calculate(string s) {\\n        int total = 0;\\n        vector<int> signs(2, 1);\\n        for (int i=0; i<s.size(); i++) {\\n            char c = s[i];\\n            if (c >= '0') {\\n                int number = 0;\\n                while (i < s.size()  &&  s[i] >= '0')\\n                    number = 10 * number + s[i++] - '0';\\n                total += signs.back() * number;\\n                signs.pop_back();\\n                i--;\\n            }\\n            else if (c == ')')\\n                signs.pop_back();\\n            else if (c != ' ')\\n                signs.push_back(signs.back() * (c == '-' ? -1 : 1));\\n        }\\n        return total;\\n    }\\n\\n**Python:**\\n\\n    def calculate(self, s):\\n        total = 0\\n        i, signs = 0, [1, 1]\\n        while i < len(s):\\n            c = s[i]\\n            if c.isdigit():\\n                start = i\\n                while i < len(s) and s[i].isdigit():\\n                    i += 1\\n                total += signs.pop() * int(s[start:i])\\n                continue\\n            if c in '+-(':\\n                signs += signs[-1] * (1, -1)[c == '-'],\\n            elif c == ')':\\n                signs.pop()\\n            i += 1\\n        return total\\n\\n**Example trace:**\\n\\nHere's an example trace for input `3-(2+(9-4))`.\\n\\n      remaining   sign stack      total\\n    3-(2+(9-4))   [1, 1]            0\\n     -(2+(9-4))   [1]               3\\n      (2+(9-4))   [1, -1]           3\\n       2+(9-4))   [1, -1, -1]       3\\n        +(9-4))   [1, -1]           1\\n         (9-4))   [1, -1, -1]       1\\n          9-4))   [1, -1, -1, -1]   1\\n           -4))   [1, -1, -1]      -8\\n            4))   [1, -1, -1, 1]   -8\\n             ))   [1, -1, -1]      -4\\n              )   [1, -1]          -4\\n                  [1]              -4\\n\\nIf you want to see traces for other examples, you can add this at the start inside the loop and after the loop (that's for the Python solution, where it's all easier):\\n\\n    print '%11s   %-16s %2d' % (s[i:], signs, total)",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "Keep a global running total and a stack of signs (+1 or -1), one for each open scope. The \"global\" outermost sign is +1.\\n\\n- Each number consumes a sign.\\n- Each `+` and `-` causes a new sign.\\n- Each `(` duplicates the current sign so it can be used for the first term inside the new scope. That's also why I start with `[1, 1]` - the global sign 1 and a duplicate to be used for the first term, since expressions start like `3...` or `(...`, not like `+3...` or `+(...`.\\n- Each `)` closes the current scope and thus drops the current sign.\\n\\nAlso see the example trace below my programs.\\n\\n**C++:**\\n\\n    int calculate(string s) {\\n        int total = 0;\\n        vector<int> signs(2, 1);\\n        for (int i=0; i<s.size(); i++) {\\n            char c = s[i];\\n            if (c >= '0') {\\n                int number = 0;\\n                while (i < s.size()  &&  s[i] >= '0')\\n                    number = 10 * number + s[i++] - '0';\\n                total += signs.back() * number;\\n                signs.pop_back();\\n                i--;\\n            }\\n            else if (c == ')')\\n                signs.pop_back();\\n            else if (c != ' ')\\n                signs.push_back(signs.back() * (c == '-' ? -1 : 1));\\n        }\\n        return total;\\n    }\\n\\n**Python:**\\n\\n    def calculate(self, s):\\n        total = 0\\n        i, signs = 0, [1, 1]\\n        while i < len(s):\\n            c = s[i]\\n            if c.isdigit():\\n                start = i\\n                while i < len(s) and s[i].isdigit():\\n                    i += 1\\n                total += signs.pop() * int(s[start:i])\\n                continue\\n            if c in '+-(':\\n                signs += signs[-1] * (1, -1)[c == '-'],\\n            elif c == ')':\\n                signs.pop()\\n            i += 1\\n        return total\\n\\n**Example trace:**\\n\\nHere's an example trace for input `3-(2+(9-4))`.\\n\\n      remaining   sign stack      total\\n    3-(2+(9-4))   [1, 1]            0\\n     -(2+(9-4))   [1]               3\\n      (2+(9-4))   [1, -1]           3\\n       2+(9-4))   [1, -1, -1]       3\\n        +(9-4))   [1, -1]           1\\n         (9-4))   [1, -1, -1]       1\\n          9-4))   [1, -1, -1, -1]   1\\n           -4))   [1, -1, -1]      -8\\n            4))   [1, -1, -1, 1]   -8\\n             ))   [1, -1, -1]      -4\\n              )   [1, -1]          -4\\n                  [1]              -4\\n\\nIf you want to see traces for other examples, you can add this at the start inside the loop and after the loop (that's for the Python solution, where it's all easier):\\n\\n    print '%11s   %-16s %2d' % (s[i:], signs, total)",
                "codeTag": "Python3"
            },
            {
                "id": 62424,
                "title": "python-concise-solution-with-stack",
                "content": "        \\n    def calculate(self, s):\\n        res, num, sign, stack = 0, 0, 1, []\\n        for ss in s:\\n            if ss.isdigit():\\n                num = 10*num + int(ss)\\n            elif ss in [\"-\", \"+\"]:\\n                res += sign*num\\n                num = 0\\n                sign = [-1, 1][ss==\"+\"]\\n            elif ss == \"(\":\\n                stack.append(res)\\n                stack.append(sign)\\n                sign, res = 1, 0\\n            elif ss == \")\":\\n                res += sign*num\\n                res *= stack.pop()\\n                res += stack.pop()\\n                num = 0\\n        return res + num*sign",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "        \\n    def calculate(self, s):\\n        res, num, sign, stack = 0, 0, 1, []\\n        for ss in s:\\n            if ss.isdigit():\\n                num = 10*num + int(ss)\\n            elif ss in [\"-\", \"+\"]:\\n                res += sign*num\\n                num = 0\\n                sign = [-1, 1][ss==\"+\"]\\n            elif ss == \"(\":\\n                stack.append(res)\\n                stack.append(sign)\\n                sign, res = 1, 0\\n            elif ss == \")\":\\n                res += sign*num\\n                res *= stack.pop()\\n                res += stack.pop()\\n                num = 0\\n        return res + num*sign",
                "codeTag": "Python3"
            },
            {
                "id": 62377,
                "title": "16-ms-solution-in-c-with-stacks",
                "content": "    class Solution {\\n    public:\\n        int calculate(string s) {\\n            stack <int> nums, ops;\\n            int num = 0;\\n            int rst = 0;\\n            int sign = 1;\\n            for (char c : s) { \\n                if (isdigit(c)) {\\n                    num = num * 10 + c - '0';\\n                }\\n                else {\\n                    rst += sign * num;\\n                    num = 0;\\n                    if (c == '+') sign = 1;\\n                    if (c == '-') sign = -1;\\n                    if (c == '(') {\\n                        nums.push(rst);\\n                        ops.push(sign);\\n                        rst = 0;\\n                        sign = 1;\\n                    }\\n                    if (c == ')' && ops.size()) {\\n                        rst = ops.top() * rst + nums.top();\\n                        ops.pop(); nums.pop();\\n                    }\\n                }\\n            }\\n            rst += sign * num;\\n            return rst;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int calculate(string s) {\\n            stack <int> nums, ops;\\n            int num = 0;\\n            int rst = 0;\\n            int sign = 1;\\n            for (char c : s) { \\n                if (isdigit(c)) {\\n                    num = num * 10 + c - '0';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1457045,
                "title": "c-explained-stacks-beginner-friendly-easy-to-understand",
                "content": "# ***Approach***\\n```\\nThis is a very good stacks problem , we are given an expression in form of string with \\nchars as [nums , \\'(\\' , \\')\\' , \\'+\\' , \\'-\\' , \\' \\']\\n\\nNote : we can totally ignore \\' \\' and  \\'+\\'.\\n    \\nLogic:\\n        what we are going to do is very simple , \\n        first intilaize two vars , sum and sign\\n        sum = 0\\n        sign = +1\\n            \\n        traverse the string:\\n            if(ch is digit)\\n                num = get_full_num; // may be multidigit\\n                add it to sum , sum += (num * sign)\\n                reset sign to +1\\n            else if(ch is \\'(\\')\\n                save current state of sum and sign in stack\\n                reset sum and sign\\n            else if(ch is \\')\\')\\n                sum = val_at_top + (sign_at_top * sum)\\n                pop;\\n            else if(ch is \\'-\\')\\n                toggle sign\\n                \\n       the use of sum and sign are to evaluate current expression inside a () braces or completely outside\\n       stack is used to store the state of sum and sign take example\\n       1 + 2 + 3 - (5 + 6) => 6 - (5 + 6)\\n                when we encounter \\'(\\' saving state means\\n                stack will store pair(6 , -) and first calculate (5 + 6)\\n                once (5 + 6) is calculated which is 11\\n                pop from stack => sum = (6 + (sum * -1)) = (6 + (11 * -1)) = -5 ans\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n   int calculate(string s) {\\n       stack<pair<int,int>> st; // pair(prev_calc_value , sign before next bracket () )\\n       \\n       long long int sum = 0;\\n       int sign = +1;\\n       \\n       for(int i = 0 ; i < s.size() ; ++i)\\n       {\\n           char ch = s[i];\\n           \\n           if(isdigit(ch))\\n           {\\n               long long int num = 0;\\n               while(i < s.size() and isdigit(s[i]))\\n               {\\n                   num = (num * 10) + s[i] - \\'0\\';\\n                   i++;\\n               }\\n               i--; // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n               sum += (num * sign);\\n               sign = +1; // reseting sign\\n           }\\n           else if(ch == \\'(\\')\\n           {\\n               // Saving current state of (sum , sign) in stack\\n               st.push(make_pair(sum , sign));\\n               \\n               // Reseting sum and sign for inner bracket calculation\\n               sum = 0; \\n               sign = +1;\\n           }\\n           else if(ch == \\')\\')\\n           {\\n               sum = st.top().first + (st.top().second * sum);\\n               st.pop();\\n           }\\n           else if(ch == \\'-\\')\\n           {\\n               // toggle sign\\n               sign = (-1 * sign);\\n           }\\n       }\\n       return sum;\\n   }\\n};\\n```\\n# ***If you liked the solution , Please Upvote!!!***",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nThis is a very good stacks problem , we are given an expression in form of string with \\nchars as [nums , \\'(\\' , \\')\\' , \\'+\\' , \\'-\\' , \\' \\']\\n\\nNote : we can totally ignore \\' \\' and  \\'+\\'.\\n    \\nLogic:\\n        what we are going to do is very simple , \\n        first intilaize two vars , sum and sign\\n        sum = 0\\n        sign = +1\\n            \\n        traverse the string:\\n            if(ch is digit)\\n                num = get_full_num; // may be multidigit\\n                add it to sum , sum += (num * sign)\\n                reset sign to +1\\n            else if(ch is \\'(\\')\\n                save current state of sum and sign in stack\\n                reset sum and sign\\n            else if(ch is \\')\\')\\n                sum = val_at_top + (sign_at_top * sum)\\n                pop;\\n            else if(ch is \\'-\\')\\n                toggle sign\\n                \\n       the use of sum and sign are to evaluate current expression inside a () braces or completely outside\\n       stack is used to store the state of sum and sign take example\\n       1 + 2 + 3 - (5 + 6) => 6 - (5 + 6)\\n                when we encounter \\'(\\' saving state means\\n                stack will store pair(6 , -) and first calculate (5 + 6)\\n                once (5 + 6) is calculated which is 11\\n                pop from stack => sum = (6 + (sum * -1)) = (6 + (11 * -1)) = -5 ans\\n```\n```\\nclass Solution {\\npublic:\\n   int calculate(string s) {\\n       stack<pair<int,int>> st; // pair(prev_calc_value , sign before next bracket () )\\n       \\n       long long int sum = 0;\\n       int sign = +1;\\n       \\n       for(int i = 0 ; i < s.size() ; ++i)\\n       {\\n           char ch = s[i];\\n           \\n           if(isdigit(ch))\\n           {\\n               long long int num = 0;\\n               while(i < s.size() and isdigit(s[i]))\\n               {\\n                   num = (num * 10) + s[i] - \\'0\\';\\n                   i++;\\n               }\\n               i--; // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n               sum += (num * sign);\\n               sign = +1; // reseting sign\\n           }\\n           else if(ch == \\'(\\')\\n           {\\n               // Saving current state of (sum , sign) in stack\\n               st.push(make_pair(sum , sign));\\n               \\n               // Reseting sum and sign for inner bracket calculation\\n               sum = 0; \\n               sign = +1;\\n           }\\n           else if(ch == \\')\\')\\n           {\\n               sum = st.top().first + (st.top().second * sum);\\n               st.pop();\\n           }\\n           else if(ch == \\'-\\')\\n           {\\n               // toggle sign\\n               sign = (-1 * sign);\\n           }\\n       }\\n       return sum;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831471,
                "title": "python3-stack-approach-with-detailed-explanations-o-n",
                "content": "(1) The trick is to use ```sign``` to store the \\'+\\' and \\'-\\' during the process.\\n```sign = 1 for \\'+\\'``` and ```sign = -1 for \\'-\\'```\\n\\n(2) We use ```num``` to hold the current number that we are constructing, and ```sign``` to hold the \\'+\\' (1) or \\'-\\' (-1) **BEFORE** the current number.\\n\\n(3) The evaluation happends whenever we see a operator, we add the ```num * sign``` to the last element in the ```stack```.\\n\\n\\n(4) Whenever we see ```(``` we will put ```sign``` into the stack and a ```0``` at the end ```stack[-1] = 0```, ```stack[-1]``` will be updated when we are evaluating the expression inside this ```()```.\\n\\n```stack``` holds the evaluation results where the last element is the one we are currently working on. For example, if we are evaluating things inside a ```()```, stack[-1] should represent the current evaluation result inside this ```()```.\\n```e.g., \\ns = \"1+2+(3+4)\" and we are currently at the number 4,\\nstack = [3, 1, 3], the first 3 is 1+2, the 1 is the sign of the (), and the last 3 is the number we are working on.\\n```\\n\\n(5) Whenever we see ```)``` we know that there has to be a ```(``` before, and the current stack should looks like this: \\n\\n[........, ```sign```, everything in this ```()``` ending with the current ```)``` except the current ```num``` and ```sign``` we are holding], \\n\\nso we will\\n\\t- pop the last element and combine it with the current ```num``` and ```sign``` we are holding.\\n\\t- pop the last element again which is the ```sign``` for this ```()```, and muitiply them together.\\n\\t- add everything we get from this ```()``` to the last element in the stack\\n\\n(6) At the end, we need to add the current ```num``` and ```sign``` we are holding to the result (note that if the expression ended with a ```)```, ```num``` will be 0).\\n\\n```python\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n    \\t\\n    \\t### num is the current number we are constructing\\n    \\t\\n    \\t### sign is the \\'+\\' or \\'-\\' before the current number we are constructing/holding\\n    \\t### Note that we initialize sign with 1 to represent \\'+\\'\\n    \\t\\n    \\t### The last element in the stack will be the number we are updating during the \\n    \\t### process, so put a 0 in it.\\n        num, sign, stack = 0, 1, [0]\\n\\n        for c in s:\\n\\n        \\t### Constructing the number.\\n            if c.isdigit():\\n                num = num*10 + int(c)\\n\\n            ### Skip the space\\n            elif c==\\' \\':\\n                continue\\n\\n            ### When we see \\'+\\', we need to multiply the current number we are holding with the \\n            ### sign before this number, and update the last element in the stack.\\n            ### We also need to reset num to 0 and sign to 1\\n            elif c == \\'+\\':\\n                stack[-1] += num * sign\\n                sign = 1\\n                num = 0\\n\\n            ### Doing the same thing as \\'+\\', but reset sign to -1\\n            elif c == \\'-\\':\\n                stack[-1] += num * sign\\n                sign = -1\\n                num = 0\\n\\n            ### We add sign to stack which represent the sign of this ()\\n            ### We also add a 0 so we can keep update while evaluating the expression inside this ()\\n            ### Reset num and sign again\\n            elif c == \\'(\\':\\n                stack.extend([sign,0])\\n                sign = 1\\n                num = 0\\n\\n            ### pop the last element and combine it with the current num and sign we are holding (the last element inside this \\'()\\' ).\\n\\t\\t\\t### pop the last element again which is the sign for this \\'()\\' and muitiply them together.\\n\\t\\t\\t### add everything we get inside this \\'()\\' to the last element in the stack.\\n            elif c == \\')\\':\\n                lastNum = (stack.pop() + num*sign) * stack.pop()\\n                stack[-1] += lastNum\\n                sign = 1\\n                num = 0\\n                \\n        ### stack should only contain one element representing everything except the last number if the expression ended with a number, so add the current num we are holding to the result.\\n        return stack[-1]+num*sign\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```sign```\n```sign = 1 for \\'+\\'```\n```sign = -1 for \\'-\\'```\n```num```\n```sign```\n```num * sign```\n```stack```\n```(```\n```sign```\n```0```\n```stack[-1] = 0```\n```stack[-1]```\n```()```\n```stack```\n```()```\n```()```\n```e.g., \\ns = \"1+2+(3+4)\" and we are currently at the number 4,\\nstack = [3, 1, 3], the first 3 is 1+2, the 1 is the sign of the (), and the last 3 is the number we are working on.\\n```\n```)```\n```(```\n```sign```\n```()```\n```)```\n```num```\n```sign```\n```num```\n```sign```\n```sign```\n```()```\n```()```\n```num```\n```sign```\n```)```\n```num```\n```python\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n    \\t\\n    \\t### num is the current number we are constructing\\n    \\t\\n    \\t### sign is the \\'+\\' or \\'-\\' before the current number we are constructing/holding\\n    \\t### Note that we initialize sign with 1 to represent \\'+\\'\\n    \\t\\n    \\t### The last element in the stack will be the number we are updating during the \\n    \\t### process, so put a 0 in it.\\n        num, sign, stack = 0, 1, [0]\\n\\n        for c in s:\\n\\n        \\t### Constructing the number.\\n            if c.isdigit():\\n                num = num*10 + int(c)\\n\\n            ### Skip the space\\n            elif c==\\' \\':\\n                continue\\n\\n            ### When we see \\'+\\', we need to multiply the current number we are holding with the \\n            ### sign before this number, and update the last element in the stack.\\n            ### We also need to reset num to 0 and sign to 1\\n            elif c == \\'+\\':\\n                stack[-1] += num * sign\\n                sign = 1\\n                num = 0\\n\\n            ### Doing the same thing as \\'+\\', but reset sign to -1\\n            elif c == \\'-\\':\\n                stack[-1] += num * sign\\n                sign = -1\\n                num = 0\\n\\n            ### We add sign to stack which represent the sign of this ()\\n            ### We also add a 0 so we can keep update while evaluating the expression inside this ()\\n            ### Reset num and sign again\\n            elif c == \\'(\\':\\n                stack.extend([sign,0])\\n                sign = 1\\n                num = 0\\n\\n            ### pop the last element and combine it with the current num and sign we are holding (the last element inside this \\'()\\' ).\\n\\t\\t\\t### pop the last element again which is the sign for this \\'()\\' and muitiply them together.\\n\\t\\t\\t### add everything we get inside this \\'()\\' to the last element in the stack.\\n            elif c == \\')\\':\\n                lastNum = (stack.pop() + num*sign) * stack.pop()\\n                stack[-1] += lastNum\\n                sign = 1\\n                num = 0\\n                \\n        ### stack should only contain one element representing everything except the last number if the expression ended with a number, so add the current num we are holding to the result.\\n        return stack[-1]+num*sign\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62372,
                "title": "accepted-java-infix-to-postfix-based-solution-with-explaination-600ms",
                "content": "The solution has 2 steps:\\n\\n  1. parse the input string and convert it to postfix notation.\\n  2. evaluate the postfix string from step 1.\\n\\n**Infix to postfix conversion** \\n\\nconverting a simple expression string that doesn't contain brackets to postfix is explained [here][1]. You can imagine the expression between brackets as a new simple expression (which we know how to convert to postfix). So when we encounter opening bracket \"(\" push it to the top stack. When we encounter a closing bracket \")\" keep popping from stack until we find the matching \"(\", here we are removing all operators that belong to the expression between brackets. Then pop the \"(\" from the stack.\\n\\nOne more thing to take into consideration, we don't want any operator to pop the \"(\" from the stack except the \")\". We can handle this be assigning the \"(\" the lowest rank such that no operator can pop it.\\n\\n\\n**Evaluate postfix expression**\\n\\npostfix evaluation is explained [here][2]\\n\\nIf you have any ideas how to cut down the run time, please share your ideas :D.\\n\\nDisclaimer: I didn't write the included links, however I find them simple and neat.\\n\\n\\n    public class Solution {\\n    \\tint rank(char op){\\n    \\t    // the bigger the number, the higher the rank\\n    \\t    switch(op){\\n    \\t        case '+':return 1;\\n    \\t        case '-':return 1;\\n    \\t        case '*':return 2;\\n    \\t        case '/':return 2;\\n    \\t        default :return 0; // '(' \\n    \\t    }\\n    \\t}\\n    \\tList<Object> infixToPostfix(String s) {\\n    \\t\\tStack<Character> operators = new Stack<Character>();\\n    \\t\\tList<Object> postfix = new LinkedList<Object>();\\n    \\n    \\t\\tint numberBuffer = 0;\\n    \\t\\tboolean bufferingOperand = false;\\n    \\t\\tfor (char c : s.toCharArray()) {\\n    \\t\\t\\tif (c >= '0' && c <= '9') {\\n    \\t\\t\\t\\tnumberBuffer = numberBuffer * 10 + c - '0';\\n    \\t\\t\\t\\tbufferingOperand = true;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tif(bufferingOperand)\\n    \\t\\t\\t\\t\\tpostfix.add(numberBuffer);\\n    \\t\\t\\t\\tnumberBuffer = 0;\\n    \\t\\t\\t\\tbufferingOperand = false;\\n    \\t\\t\\t\\t\\n    \\t\\t\\t\\tif (c == ' '|| c == '\\\\t')\\n    \\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t\\n    \\t\\t\\t\\tif (c == '(') {\\n    \\t\\t\\t\\t\\toperators.push('(');\\n    \\t\\t\\t\\t} else if (c == ')') {\\n    \\t\\t\\t\\t\\twhile (operators.peek() != '(')\\n    \\t\\t\\t\\t\\t\\tpostfix.add(operators.pop());\\n    \\t\\t\\t\\t\\toperators.pop(); // popping \"(\"\\n    \\t\\t\\t\\t} else { // operator\\n    \\t\\t\\t\\t\\twhile (!operators.isEmpty() && rank(c) <= rank(operators.peek()))\\n    \\t\\t\\t\\t\\t\\tpostfix.add(operators.pop());\\n    \\t\\t\\t\\t\\toperators.push(c);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\n    \\t\\t}\\n    \\t\\tif (bufferingOperand)\\n    \\t\\t\\tpostfix.add(numberBuffer);\\n    \\n    \\t\\twhile (!operators.isEmpty())\\n    \\t\\t\\tpostfix.add(operators.pop());\\n    \\n    \\t\\treturn postfix;\\n    \\t}\\n    \\n    \\tint evaluatePostfix(List<Object> postfix) {\\n    \\t\\tStack<Integer> operands = new Stack<Integer>();\\n    \\t\\tint a = 0, b = 0;\\n    \\t\\tfor (Object s : postfix) {\\n    \\t\\t\\tif(s instanceof Character){\\n    \\t\\t\\t\\tchar c = (Character) s;\\n    \\t\\t\\t\\tb = operands.pop();\\n    \\t\\t\\t\\ta = operands.pop();\\n    \\t\\t\\t\\tswitch (c) {\\n    \\t\\t\\t\\t\\tcase '+': operands.push(a + b); break;\\n    \\t\\t\\t\\t\\tcase '-': operands.push(a - b); break;\\n    \\t\\t\\t\\t\\tcase '*': operands.push(a * b); break;\\n    \\t\\t\\t\\t\\tdefault : operands.push(a / b); \\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else { // instanceof Integer\\n    \\t\\t\\t\\toperands.push((Integer)s);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn operands.pop();\\n    \\t}\\n    \\n    \\tpublic int calculate(String s) {\\n    \\t\\treturn evaluatePostfix(infixToPostfix(s));\\n    \\t}\\n    \\n    }\\n\\n\\n  [1]: http://scriptasylum.com/tutorials/infix_postfix/algorithms/infix-postfix/\\n  [2]: http://scriptasylum.com/tutorials/infix_postfix/algorithms/postfix-evaluation/",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    \\tint rank(char op){\\n    \\t    // the bigger the number, the higher the rank\\n    \\t    switch(op){\\n    \\t        case '+':return 1;\\n    \\t        case '-':return 1;\\n    \\t        case '*':return 2;\\n    \\t        case '/':return 2;\\n    \\t        default :return 0; // '(' \\n    \\t    }",
                "codeTag": "Java"
            },
            {
                "id": 62345,
                "title": "24-line-c-o-n-recursive-solution-20ms-and-intuitive",
                "content": "Each invocation of evaluate() evaluates whatever inside a pair of parenthese. Nested parenthese will be handled by recursive calls.\\n\\nSo \"(1+(4+5+2)-3)+(6+8)\"\\n\\n->\\n\\n(1+(9+2)-3)+(6+8)\\n\\n->\\n\\n(1+11-3)+(6+8)\\n\\n->\\n\\n(12-3)+(6+8)\\n\\n->\\n\\n9+(6+8)\\n\\n->\\n\\n9+14\\n\\n->\\n\\n23\\n\\n\\n    class Solution {\\n    public:\\n        int calculate(string s) {\\n            int pos=0;\\n            return evaluate(s,pos);\\n        }\\n        \\n        int evaluate(string& s, int& i) {\\n            int res = 0;\\n            bool negFlag=false;\\n            while(i<s.size()&&s[i]!=')') {\\n                if(s[i]=='+'||s[i]==' ') \\n                    i++;\\n                else if(s[i]=='-') {\\n                    i++;\\n                    negFlag=true;\\n                }\\n                else if(s[i]=='(') {\\n                    i++;\\n                    res+=negFlag?-evaluate(s,i):evaluate(s,i);\\n                    negFlag=false;\\n                }\\n                else {// numeric chars\\n                    int num=0;\\n                    while(i<s.size()&&isdigit(s[i]))\\n                        num = num*10 + s[i++]-'0';\\n                    res+=negFlag?-num:num;\\n                    negFlag=false;\\n                }\\n            }\\n            i++; // skip the current ')'\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int calculate(string s) {\\n            int pos=0;\\n            return evaluate(s,pos);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 546092,
                "title": "simple-python-solution-using-stack-with-explanation-inline",
                "content": "```\\n    def calculate(self, s: str) -> int:\\n        \"\"\"\\n        1. Take 3 containers:\\n        num -> to store current num value only\\n        sign -> to store sign value, initially +1\\n        res -> to store sum\\n        When ( comes these containers used for calculate sum of intergers within () brackets.\\n        --------------------\\n        2. When c is + or -\\n        Move num to res, because we need to empty num for next integer value.\\n        set num = 0\\n        sign = update with c\\n        --------------------\\n        3. When c is \\'(\\'\\n        Here, we need num, res, sign to calculate sum of integers within ()\\n        So, move num and sign to stack => [num, sign]\\n        Now reset - res = 0, num = 0, sign = 1 (default)\\n        --------------------\\n        4. When c is \\')\\' -> 2-(3+4), Here res=3, num=4, sign=1 stack [2, -] \\n        res +=sign*num -> calculate sum for num first, then pop items from stack, res=7\\n        res *=stack.pop() - > Pop sign(+ or -) to multiply with res, res = 7*(-1)\\n        res +=stack.pop() - > Pop integer and add with prev. sum, res = -7 + 2 - 5\\n        --------------------\\n        Simple Example: 2 - 3\\n        Initially res will have 2,i.e. res = 2\\n        then store \\'-\\' in sign. it will be used when 3 comes. ie. sign = -1\\n        Now 3 comes => res = res + num*sign\\n        Return statement: res+num*sign => res = 2 + 3(-1) = 2 - 3 = -1\\n        \"\"\"\\n        num = 0\\n        sign = 1\\n        res = 0\\n        stack = []\\n        for i in range(len(s)): # iterate till last character\\n            c = s[i]\\n            if c.isdigit(): # process if there is digit\\n                num = num*10 + int(c) # for consecutive digits 98 => 9x10 + 8 = 98\\n            elif c in \\'-+\\': # check for - and +\\n                res += num*sign\\n                sign = -1 if c == \\'-\\' else 1\\n                num = 0\\n            elif c == \\'(\\':\\n                stack.append(res)\\n                stack.append(sign)\\n                res = 0\\n                sign = 1\\n            elif c == \\')\\':\\n                res +=sign*num\\n                res *=stack.pop()\\n                res +=stack.pop()\\n                num = 0\\n        return res + num*sign\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n    def calculate(self, s: str) -> int:\\n        \"\"\"\\n        1. Take 3 containers:\\n        num -> to store current num value only\\n        sign -> to store sign value, initially +1\\n        res -> to store sum\\n        When ( comes these containers used for calculate sum of intergers within () brackets.\\n        --------------------\\n        2. When c is + or -\\n        Move num to res, because we need to empty num for next integer value.\\n        set num = 0\\n        sign = update with c\\n        --------------------\\n        3. When c is \\'(\\'\\n        Here, we need num, res, sign to calculate sum of integers within ()\\n        So, move num and sign to stack => [num, sign]\\n        Now reset - res = 0, num = 0, sign = 1 (default)\\n        --------------------\\n        4. When c is \\')\\' -> 2-(3+4), Here res=3, num=4, sign=1 stack [2, -] \\n        res +=sign*num -> calculate sum for num first, then pop items from stack, res=7\\n        res *=stack.pop() - > Pop sign(+ or -) to multiply with res, res = 7*(-1)\\n        res +=stack.pop() - > Pop integer and add with prev. sum, res = -7 + 2 - 5\\n        --------------------\\n        Simple Example: 2 - 3\\n        Initially res will have 2,i.e. res = 2\\n        then store \\'-\\' in sign. it will be used when 3 comes. ie. sign = -1\\n        Now 3 comes => res = res + num*sign\\n        Return statement: res+num*sign => res = 2 + 3(-1) = 2 - 3 = -1\\n        \"\"\"\\n        num = 0\\n        sign = 1\\n        res = 0\\n        stack = []\\n        for i in range(len(s)): # iterate till last character\\n            c = s[i]\\n            if c.isdigit(): # process if there is digit\\n                num = num*10 + int(c) # for consecutive digits 98 => 9x10 + 8 = 98\\n            elif c in \\'-+\\': # check for - and +\\n                res += num*sign\\n                sign = -1 if c == \\'-\\' else 1\\n                num = 0\\n            elif c == \\'(\\':\\n                stack.append(res)\\n                stack.append(sign)\\n                res = 0\\n                sign = 1\\n            elif c == \\')\\':\\n                res +=sign*num\\n                res *=stack.pop()\\n                res +=stack.pop()\\n                num = 0\\n        return res + num*sign\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 62418,
                "title": "python-with-stack",
                "content": "This [solution][1] uses stack to store previous result and sign when encounter a \"(\"\\n\\nFor this problem storing sign is enough, and will be faster.\\n\\n    def calculate(self, s):\\n        res, num, sign, stack = 0, 0, 1, [1]\\n        for i in s+\"+\":\\n            if i.isdigit():\\n                num = 10*num + int(i)\\n            elif i in \"+-\":\\n                res += num * sign * stack[-1]\\n                sign = 1 if i==\"+\" else -1\\n                num = 0\\n            elif i == \"(\":\\n                stack.append(sign * stack[-1])\\n                sign = 1\\n            elif i == \")\":\\n                res += num * sign * stack[-1]\\n                num = 0\\n                stack.pop()\\n        return res\\n\\n\\n  [1]: https://leetcode.com/discuss/61237/python-concise-solution-with-stack",
                "solutionTags": [
                    "Python"
                ],
                "code": "This [solution][1] uses stack to store previous result and sign when encounter a \"(\"\\n\\nFor this problem storing sign is enough, and will be faster.\\n\\n    def calculate(self, s):\\n        res, num, sign, stack = 0, 0, 1, [1]\\n        for i in s+\"+\":\\n            if i.isdigit():\\n                num = 10*num + int(i)\\n            elif i in \"+-\":\\n                res += num * sign * stack[-1]\\n                sign = 1 if i==\"+\" else -1\\n                num = 0\\n            elif i == \"(\":\\n                stack.append(sign * stack[-1])\\n                sign = 1\\n            elif i == \")\":\\n                res += num * sign * stack[-1]\\n                num = 0\\n                stack.pop()\\n        return res\\n\\n\\n  [1]: https://leetcode.com/discuss/61237/python-concise-solution-with-stack",
                "codeTag": "Python3"
            },
            {
                "id": 62430,
                "title": "java-solution-stack",
                "content": "My approach is based on the fact that the final arithmetic operation on each number is not only depend on the sign directly operating on it, but all signs associated with each unmatched '(' before that number.\\n\\ne.g.\\n5 - ( 6 + ( 4 - 7 ) ), if we remove all parentheses, the expression becomes 5 - 6 - 4 + 7.\\n\\nsign:\\n\\n6: (-1)(1) = -1\\n\\n4: (-1)(1)(1) = -1\\n\\n7: (-1)(1)(-1) = 1\\n\\nThe effect of associated signs are cumulative, stack is builded based on this. Any improvement is welcome.\\n\\n    public int calculate(String s) {\\n        Deque<Integer> stack = new LinkedList<>();\\n        int rs = 0;\\n        int sign = 1;\\n        stack.push(1);\\n        for (int i = 0; i < s.length(); i++){\\n            if (s.charAt(i) == ' ') continue;\\n            else if (s.charAt(i) == '('){\\n                stack.push(stack.peekFirst() * sign);\\n                sign = 1;\\n            }\\n            else if (s.charAt(i) == ')') stack.pop();\\n            else if (s.charAt(i) == '+') sign = 1;\\n            else if (s.charAt(i) == '-') sign = -1;\\n            else{\\n                int temp = s.charAt(i) - '0';\\n                while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1)))\\n                    temp = temp * 10 + s.charAt(++i) - '0';\\n                rs += sign * stack.peekFirst() * temp;\\n            }\\n        }\\n        return rs;\\n    }",
                "solutionTags": [],
                "code": "My approach is based on the fact that the final arithmetic operation on each number is not only depend on the sign directly operating on it, but all signs associated with each unmatched '(' before that number.\\n\\ne.g.\\n5 - ( 6 + ( 4 - 7 ) ), if we remove all parentheses, the expression becomes 5 - 6 - 4 + 7.\\n\\nsign:\\n\\n6: (-1)(1) = -1\\n\\n4: (-1)(1)(1) = -1\\n\\n7: (-1)(1)(-1) = 1\\n\\nThe effect of associated signs are cumulative, stack is builded based on this. Any improvement is welcome.\\n\\n    public int calculate(String s) {\\n        Deque<Integer> stack = new LinkedList<>();\\n        int rs = 0;\\n        int sign = 1;\\n        stack.push(1);\\n        for (int i = 0; i < s.length(); i++){\\n            if (s.charAt(i) == ' ') continue;\\n            else if (s.charAt(i) == '('){\\n                stack.push(stack.peekFirst() * sign);\\n                sign = 1;\\n            }\\n            else if (s.charAt(i) == ')') stack.pop();\\n            else if (s.charAt(i) == '+') sign = 1;\\n            else if (s.charAt(i) == '-') sign = -1;\\n            else{\\n                int temp = s.charAt(i) - '0';\\n                while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1)))\\n                    temp = temp * 10 + s.charAt(++i) - '0';\\n                rs += sign * stack.peekFirst() * temp;\\n            }\\n        }\\n        return rs;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62449,
                "title": "simple-c-in-24-ms",
                "content": "    class Solution {\\n    public:\\n        int calculate(string s) {\\n            // the given expression is always valid!!!\\n            // only + and - !!!\\n            // every + and - can be flipped base on it's depth in ().\\n            stack<int> signs;\\n            int sign = 1;\\n            int num = 0;\\n            int ans = 0;\\n            \\n            // always transform s into ( s )\\n            signs.push(1);\\n            \\n            for (auto c : s) {\\n                if (c >= '0' && c <= '9') {\\n                    num = 10 * num + c - '0';\\n                } else if (c == '+' || c == '-') {\\n                    ans = ans + signs.top() * sign * num;\\n                    num = 0;\\n                    sign = (c == '+' ? 1 : -1);\\n                } else if (c == '(') {\\n                    signs.push(sign * signs.top());\\n                    sign = 1;\\n                } else if (c == ')') {\\n                    ans = ans + signs.top() * sign * num;\\n                    num = 0;\\n                    signs.pop();\\n                    sign = 1;\\n                }\\n            }\\n            \\n            if (num) {\\n                ans = ans + signs.top() * sign * num;\\n            }\\n            \\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int calculate(string s) {\\n            // the given expression is always valid!!!\\n            // only + and - !!!\\n            // every + and - can be flipped base on it's depth in ().\\n            stack<int> signs;\\n            int sign = 1;\\n            int num = 0;\\n            int ans = 0;\\n            \\n            // always transform s into ( s )\\n            signs.push(1);\\n            \\n            for (auto c : s) {\\n                if (c >= '0' && c <= '9') {\\n                    num = 10 * num + c - '0';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2017431,
                "title": "stop-hating-parsing-problems-and-start-having-fun",
                "content": "I hate parsing problems only when solved the way Leetcode suggested (using stack). The most intuitive way (that I learned 10+ years ago and it somehow sticks with me) is to use parsing grammar. That actually makes parsing quite fun!\\n\\nThis problem can be converted to a recursive pseudo-grammar notation like this:\\n\\n```plan\\nexpr: factor [+/-] factor [+/-] factor ...\\nfactor: num | -num | (expr) | -(expr)\\n```\\n\\nIt says an expression (`expr`) can be a few `factor`s that are separated by `+` or `-`. On the other hand `factor` can optionally start with an unary operation `-` followed by either a number like `123` or just another `expr` (recursively).\\n\\nNow we just need to implement `factor` and `expr` functions and they can call each other. Another thing that makes it simple is a tokenizer which is like a stream wrapping a string. Tokenizer just keeps an index pointing to the current character on the string that we\\'re parsing.\\n\\nHere is a simple implementation of a tokenizer that also takes care of the white-spaces, so there are less things to be worried about:\\n\\n```python\\nclass Tokenizer:\\n    def __init__(self, s):\\n        self.s = s\\n        self.pc = 0\\n        self.skip_whitespaces()\\n        \\n    def has_next(self):\\n        return self.pc < len(self.s)\\n        \\n    def next(self):\\n        self.pc += 1\\n        self.skip_whitespaces()\\n            \\n    def skip_whitespaces(self):\\n        while self.has_next() and self.current() == \\' \\':\\n            self.pc += 1\\n        \\n    def is_digit(self):\\n        return self.current().isdigit()\\n        \\n    def current(self):\\n        return self.s[self.pc]\\n```\\n\\nNow let\\'s implement the main parser:\\n\\n```python\\ndef calculate(s: str) -> int:\\n    \\n    tokenizer = Tokenizer(s)\\n    op_map = {\\n        \\'+\\': lambda a,b: a+b,\\n        \\'-\\': lambda a,b: a-b\\n    }\\n    \\n    def num():\\n        n = 0\\n        while tokenizer.has_next() and tokenizer.is_digit():\\n            n = (n * 10) + int(tokenizer.current())\\n            tokenizer.next()\\n        return n\\n\\n    # factor:  [-]num | [-](expr)\\n    def factor():\\n        # Handle unary operator\\n        neg = 1\\n        if tokenizer.current() == \\'-\\':\\n            tokenizer.next()\\n            neg = -1\\n        \\n        if tokenizer.current() == \\'(\\':\\n            tokenizer.next() # Skip \\'(\\'\\n            n = expr()\\n            tokenizer.next() # Skip \\')\\'\\n        elif tokenizer.is_digit():\\n            n = num()\\n        else:\\n            raise ValueError(f\\'Unexpected token: {tokenizer.current()}\\')\\n            \\n        return n * neg\\n    \\n    # expr: factor [+-] factor [+-] factor ...\\n    def expr():\\n        acc = factor()\\n        while tokenizer.has_next() and tokenizer.current() in op_map:\\n            op = tokenizer.current()\\n            tokenizer.next() # Skip the operator\\n            acc = op_map[op](acc, factor())\\n        return acc\\n    \\n    return expr()\\n```\\n\\nThe beauty of this solution is that it works with all other kinds of calculator problems. For example the grammar for a calculator with operator precedence is simply like this:\\n\\n```plan\\nexpr: term [+-] term [+-] term ...\\nterm = factor [*/] factor [*/] factor ...\\nfactor: num | -num | (expr) | -(expr)\\n```\\n\\nLooking at it in a recursive way, handles the operator precedence in an intuitive way. Isn\\'t it more beautiful and simpler?\\n\\nMore reading: https://www.sigmdel.ca/michel/program/delphi/parser/parser1_en.html\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```plan\\nexpr: factor [+/-] factor [+/-] factor ...\\nfactor: num | -num | (expr) | -(expr)\\n```\n```python\\nclass Tokenizer:\\n    def __init__(self, s):\\n        self.s = s\\n        self.pc = 0\\n        self.skip_whitespaces()\\n        \\n    def has_next(self):\\n        return self.pc < len(self.s)\\n        \\n    def next(self):\\n        self.pc += 1\\n        self.skip_whitespaces()\\n            \\n    def skip_whitespaces(self):\\n        while self.has_next() and self.current() == \\' \\':\\n            self.pc += 1\\n        \\n    def is_digit(self):\\n        return self.current().isdigit()\\n        \\n    def current(self):\\n        return self.s[self.pc]\\n```\n```python\\ndef calculate(s: str) -> int:\\n    \\n    tokenizer = Tokenizer(s)\\n    op_map = {\\n        \\'+\\': lambda a,b: a+b,\\n        \\'-\\': lambda a,b: a-b\\n    }\\n    \\n    def num():\\n        n = 0\\n        while tokenizer.has_next() and tokenizer.is_digit():\\n            n = (n * 10) + int(tokenizer.current())\\n            tokenizer.next()\\n        return n\\n\\n    # factor:  [-]num | [-](expr)\\n    def factor():\\n        # Handle unary operator\\n        neg = 1\\n        if tokenizer.current() == \\'-\\':\\n            tokenizer.next()\\n            neg = -1\\n        \\n        if tokenizer.current() == \\'(\\':\\n            tokenizer.next() # Skip \\'(\\'\\n            n = expr()\\n            tokenizer.next() # Skip \\')\\'\\n        elif tokenizer.is_digit():\\n            n = num()\\n        else:\\n            raise ValueError(f\\'Unexpected token: {tokenizer.current()}\\')\\n            \\n        return n * neg\\n    \\n    # expr: factor [+-] factor [+-] factor ...\\n    def expr():\\n        acc = factor()\\n        while tokenizer.has_next() and tokenizer.current() in op_map:\\n            op = tokenizer.current()\\n            tokenizer.next() # Skip the operator\\n            acc = op_map[op](acc, factor())\\n        return acc\\n    \\n    return expr()\\n```\n```plan\\nexpr: term [+-] term [+-] term ...\\nterm = factor [*/] factor [*/] factor ...\\nfactor: num | -num | (expr) | -(expr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62421,
                "title": "3ms-java-concise-and-fast-recursive-solution-with-comments-beats-99-61",
                "content": "    public int calculate(String s) {\\n        if (s.length() == 0) return 0;\\n        s = \"(\" + s + \")\";\\n        int[] p = {0};\\n        return eval(s, p);\\n    }\\n    // calculate value between parentheses\\n    private int eval(String s, int[] p){\\n        int val = 0;\\n        int i = p[0]; \\n        int oper = 1; //1:+ -1:-\\n        int num = 0;\\n        while(i < s.length()){\\n            char c = s.charAt(i);\\n            switch(c){\\n                case '+': val = val + oper * num; num = 0; oper = 1; i++; break;// end of number and set operator\\n                case '-': val = val + oper * num; num = 0; oper = -1; i++; break;// end of number and set operator\\n                case '(': p[0] = i + 1; val = val + oper * eval(s, p); i = p[0]; break; // start a new eval\\n                case ')': p[0] = i + 1; return val + oper * num; // end current eval and return. Note that we need to deal with the last num\\n                case ' ': i++; continue;\\n                default : num = num * 10 + c - '0'; i++;\\n            }\\n        }\\n        return val;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public int calculate(String s) {\\n        if (s.length() == 0) return 0;\\n        s = \"(\" + s + \")\";\\n        int[] p = {0};\\n        return eval(s, p);\\n    }\\n    // calculate value between parentheses\\n    private int eval(String s, int[] p){\\n        int val = 0;\\n        int i = p[0]; \\n        int oper = 1; //1:+ -1:-\\n        int num = 0;\\n        while(i < s.length()){\\n            char c = s.charAt(i);\\n            switch(c){\\n                case '+': val = val + oper * num; num = 0; oper = 1; i++; break;// end of number and set operator\\n                case '-': val = val + oper * num; num = 0; oper = -1; i++; break;// end of number and set operator\\n                case '(': p[0] = i + 1; val = val + oper * eval(s, p); i = p[0]; break; // start a new eval\\n                case ')': p[0] = i + 1; return val + oper * num; // end current eval and return. Note that we need to deal with the last num\\n                case ' ': i++; continue;\\n                default : num = num * 10 + c - '0'; i++;\\n            }\\n        }\\n        return val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2344042,
                "title": "java-2ms-100-recursion-easy-to-understand",
                "content": "PLEASE UPVOTE IF YOU FIND THIS SOLUTION HELPFUL, THANK YOU\\n\\nTC: O(n), where n is the length of the string\\nSC: O(number of brackets), which is less than n/2;\\n```\\nclass Solution {\\n    int idx; // this index traverse the string in one pass, between different level of recursion\\n    public int calculate(String s) {\\n        idx = 0; // Initialization should be here\\n        return calc(s);\\n    }\\n    \\n    private int calc(String s) {\\n        int res = 0, num = 0, sign = 1;\\n        while (idx < s.length()) {\\n            char c = s.charAt(idx++);\\n            if (c >= \\'0\\' && c <= \\'9\\') num = num * 10 + c - \\'0\\';\\n            else if (c == \\'(\\') num = calc(s); // ( is start of a new sub-problem, Let recursion solve the sub-problem\\n            else if (c == \\')\\') return res + sign * num;\\n            else if (c == \\'+\\' || c == \\'-\\') { // only when we meet a new sign, we know a while number has been read\\n                res += sign * num;\\n                num = 0;\\n                sign = c == \\'-\\' ? -1 : 1;\\n            }\\n        }\\n        return res + sign * num; // last number is not processed yet\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int idx; // this index traverse the string in one pass, between different level of recursion\\n    public int calculate(String s) {\\n        idx = 0; // Initialization should be here\\n        return calc(s);\\n    }\\n    \\n    private int calc(String s) {\\n        int res = 0, num = 0, sign = 1;\\n        while (idx < s.length()) {\\n            char c = s.charAt(idx++);\\n            if (c >= \\'0\\' && c <= \\'9\\') num = num * 10 + c - \\'0\\';\\n            else if (c == \\'(\\') num = calc(s); // ( is start of a new sub-problem, Let recursion solve the sub-problem\\n            else if (c == \\')\\') return res + sign * num;\\n            else if (c == \\'+\\' || c == \\'-\\') { // only when we meet a new sign, we know a while number has been read\\n                res += sign * num;\\n                num = 0;\\n                sign = c == \\'-\\' ? -1 : 1;\\n            }\\n        }\\n        return res + sign * num; // last number is not processed yet\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62432,
                "title": "ac-c-solution-with-two-stacks",
                "content": "Yet another stack-based solution. Very similar to the solution given by @jiannan [here][1] with a few minor differences.\\n\\nThe basic idea is to scan from left to right. Push every (, + and - to an 'operator' stack, and every number to an 'number' stack. In this process, whenever a RIGHT operand is added to the 'number' stack, we can do a computation using the top two numbers in the 'number' stack with the operation specified by the top of the operator stack. \\n\\nThere are only two situations when a RIGHT operand appears in the number stack: \\n1. A number that is the RIGHT operand, .e.g 4 as in 3 + 4, is pushed;\\n2. A braced block that is the RIGHT operand, e.g. (4+5) as in 3 + (4 + 5), is terminated and its result is added to the number stack.\\n\\nHow do we know if a number added is the RIGHT or LEFT operand? The idea is, whenever a RIGHT operand appears, there must be an unused '+' or '-' left in the 'operator' stack.\\n\\n    int calculate(string s) {\\n        stack<char> ops;\\n        stack<int> nums;\\n        int curnum = 0;\\n         \\n        for (int i = 0; i < s.size(); ++i) {\\n            char c = s[i];\\n            if (c == ' ') continue;   // Skip spaces\\n            if (c == '(' || c == '+' || c == '-') {ops.push(c); continue;}  // Store these operators for later\\n            \\n            // Only do calculation when 1. a braced block is terminated, 2. When the second operand isn added\\n            if (c == ')') ops.pop(); \\n            else if (isdigit(c)) {\\n                curnum = curnum * 10 + c -'0';\\n                if (i+1<s.size() && isdigit(s[i+1])) continue;    //This number is not finished\\n                nums.push(curnum);      // Otherwise, this number is ready and must be pushed to stack\\n                curnum = 0;             // Reset cursum;\\n            }\\n            \\n            if (ops.empty() || ops.top()=='(') continue;    // If, however, there is no more computational operators in stack\\n            // then either we have just added the LEFT operand, or if the braced block just terminated is a LEFT operand.\\n            // Either way, we cannot do computation yet.\\n            // Otherwise, it is safe to do the computation, assuming the expression is always valid:\\n            \\n            int n2 = nums.top(); nums.pop();                \\n            if (ops.top() == '+') nums.top() += n2;\\n            else if (ops.top() == '-') nums.top() -= n2;\\n            ops.pop();\\n        }\\n        return nums.top();\\n    }\\n\\n  [1]: https://leetcode.com/discuss/39458/64-ms-c-easy-solution",
                "solutionTags": [],
                "code": "Yet another stack-based solution. Very similar to the solution given by @jiannan [here][1] with a few minor differences.\\n\\nThe basic idea is to scan from left to right. Push every (, + and - to an 'operator' stack, and every number to an 'number' stack. In this process, whenever a RIGHT operand is added to the 'number' stack, we can do a computation using the top two numbers in the 'number' stack with the operation specified by the top of the operator stack. \\n\\nThere are only two situations when a RIGHT operand appears in the number stack: \\n1. A number that is the RIGHT operand, .e.g 4 as in 3 + 4, is pushed;\\n2. A braced block that is the RIGHT operand, e.g. (4+5) as in 3 + (4 + 5), is terminated and its result is added to the number stack.\\n\\nHow do we know if a number added is the RIGHT or LEFT operand? The idea is, whenever a RIGHT operand appears, there must be an unused '+' or '-' left in the 'operator' stack.\\n\\n    int calculate(string s) {\\n        stack<char> ops;\\n        stack<int> nums;\\n        int curnum = 0;\\n         \\n        for (int i = 0; i < s.size(); ++i) {\\n            char c = s[i];\\n            if (c == ' ') continue;   // Skip spaces\\n            if (c == '(' || c == '+' || c == '-') {ops.push(c); continue;}  // Store these operators for later\\n            \\n            // Only do calculation when 1. a braced block is terminated, 2. When the second operand isn added\\n            if (c == ')') ops.pop(); \\n            else if (isdigit(c)) {\\n                curnum = curnum * 10 + c -'0';\\n                if (i+1<s.size() && isdigit(s[i+1])) continue;    //This number is not finished\\n                nums.push(curnum);      // Otherwise, this number is ready and must be pushed to stack\\n                curnum = 0;             // Reset cursum;\\n            }\\n            \\n            if (ops.empty() || ops.top()=='(') continue;    // If, however, there is no more computational operators in stack\\n            // then either we have just added the LEFT operand, or if the braced block just terminated is a LEFT operand.\\n            // Either way, we cannot do computation yet.\\n            // Otherwise, it is safe to do the computation, assuming the expression is always valid:\\n            \\n            int n2 = nums.top(); nums.pop();                \\n            if (ops.top() == '+') nums.top() += n2;\\n            else if (ops.top() == '-') nums.top() -= n2;\\n            ops.pop();\\n        }\\n        return nums.top();\\n    }\\n\\n  [1]: https://leetcode.com/discuss/39458/64-ms-c-easy-solution",
                "codeTag": "Unknown"
            },
            {
                "id": 2831900,
                "title": "c-solution",
                "content": "``` C++ []\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int result=0;\\n        int sum=0;\\n        int sign=1;\\n        stack<int>st;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                sum=s[i] -\\'0\\';\\n                while(i+1<n && isdigit(s[i+1]))\\n                {\\n                    sum = sum*10 + (s[i+1] -\\'0\\');\\n                    i++;\\n                }\\n                result+=sum*sign;\\n            }\\n            \\n            else if(s[i] == \\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if (s[i] == \\'-\\')\\n            {\\n                sign=-1;\\n            }\\n            else if (s[i] == \\'(\\')\\n            {\\n                st.push(result);\\n                st.push(sign);\\n                result=0;\\n                sign=1;\\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n                int xsign=st.top();\\n                st.pop();\\n                int xresult= st.top();\\n                st.pop();\\n                result=result*xsign + xresult;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n*Upvote if it helped you*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int result=0;\\n        int sum=0;\\n        int sign=1;\\n        stack<int>st;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                sum=s[i] -\\'0\\';\\n                while(i+1<n && isdigit(s[i+1]))\\n                {\\n                    sum = sum*10 + (s[i+1] -\\'0\\');\\n                    i++;\\n                }\\n                result+=sum*sign;\\n            }\\n            \\n            else if(s[i] == \\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if (s[i] == \\'-\\')\\n            {\\n                sign=-1;\\n            }\\n            else if (s[i] == \\'(\\')\\n            {\\n                st.push(result);\\n                st.push(sign);\\n                result=0;\\n                sign=1;\\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n                int xsign=st.top();\\n                st.pop();\\n                int xresult= st.top();\\n                st.pop();\\n                result=result*xsign + xresult;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549777,
                "title": "c-easy-solution-string-math-stack-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* The intuition behind the code is to use a stack to store the intermediate results of the evaluation.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) When the algorithm encounters a digit, it parses the digits as a number and pushes the number onto the stack.\\n2) When the algorithm encounters an operator, it pops two numbers off the stack, performs the operation, and pushes the result back onto the stack.\\n3) When the algorithm encounters a left parenthesis, it pushes the current state of the stack onto a new stack.\\n4) When the algorithm encounters a right parenthesis, it pops the top stack, performs the operations on the numbers on the top of the stack, and pushes the result back onto the stack.\\n5) After iterating over the entire string, the algorithm pops the top number off the stack and returns it as the result of the expression.\\n# Complexity\\n- Time complexity: $$O(S)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(S)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        long long int sum = 0;\\n        int sign = 1;\\n        stack<pair<int,int>> st;\\n\\n        for(int i=0; i<s.size();i++){\\n            if(isdigit(s[i])){\\n                long long int num = 0;\\n                while(i<s.size() && isdigit(s[i])){\\n                    num = num * 10 + (s[i] - \\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                sum += num * sign;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\'(\\'){\\n                st.push({sum, sign});\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\')\\'){\\n                sum = st.top().first + (st.top().second * sum);\\n                st.pop();\\n\\n            }\\n            else if(s[i] == \\'-\\'){\\n                sign = -1 * sign;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/9e265da5-ca9a-438b-ad37-cb3fde6b73ab_1684698427.2365825.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        long long int sum = 0;\\n        int sign = 1;\\n        stack<pair<int,int>> st;\\n\\n        for(int i=0; i<s.size();i++){\\n            if(isdigit(s[i])){\\n                long long int num = 0;\\n                while(i<s.size() && isdigit(s[i])){\\n                    num = num * 10 + (s[i] - \\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                sum += num * sign;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\'(\\'){\\n                st.push({sum, sign});\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\')\\'){\\n                sum = st.top().first + (st.top().second * sum);\\n                st.pop();\\n\\n            }\\n            else if(s[i] == \\'-\\'){\\n                sign = -1 * sign;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831476,
                "title": "java-solution-using-stack-with-o-n",
                "content": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sum = 0;\\n        int sign = 1;\\n        Stack<Integer>st = new Stack<>();\\n        for(int i = 0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(Character.isDigit(ch)){\\n                int val = 0;\\n                 while(i < s.length() && Character.isDigit(s.charAt(i))){\\n                     val = val * 10 + (s.charAt(i) - \\'0\\');\\n                     i++;\\n                 }\\n             i--;\\n             val = val * sign;\\n             sign = 1;\\n             sum += val;   \\n            }\\n            else if(ch == \\'(\\'){\\n              st.push(sum);\\n              st.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(ch == \\')\\'){\\n                sum *= st.pop();\\n                sum += st.pop();\\n            }\\n            else if(ch == \\'-\\'){\\n                sign*= -1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sum = 0;\\n        int sign = 1;\\n        Stack<Integer>st = new Stack<>();\\n        for(int i = 0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(Character.isDigit(ch)){\\n                int val = 0;\\n                 while(i < s.length() && Character.isDigit(s.charAt(i))){\\n                     val = val * 10 + (s.charAt(i) - \\'0\\');\\n                     i++;\\n                 }\\n             i--;\\n             val = val * sign;\\n             sign = 1;\\n             sum += val;   \\n            }\\n            else if(ch == \\'(\\'){\\n              st.push(sum);\\n              st.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(ch == \\')\\'){\\n                sum *= st.pop();\\n                sum += st.pop();\\n            }\\n            else if(ch == \\'-\\'){\\n                sign*= -1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62464,
                "title": "64-ms-c-easy-solution",
                "content": "    class Solution {\\n    public:\\n        int calculate(string s) {\\n            int n = s.size();\\n            stack<int> s1;\\n            stack<char> s2;\\n            string v;\\n            for(int i = n - 1; i >= 0; i--){\\n                if(s[i] == ')' || s[i] == '+' || s[i] == '-') s2.push(s[i]);\\n                else if(s[i] >= '0' && s[i] <= '9'){\\n                    v = s[i] + v;\\n                    if(i == 0 || s[i - 1] < '0' || s[i - 1] > '9'){\\n                        s1.push(stoi(v)); \\n                        v = \"\";\\n                    }\\n                } else if(s[i] == '('){\\n                    while(s2.top() != ')') cal(s1, s2);\\n                    s2.pop();\\n                }\\n            }\\n            while(!s2.empty()) cal(s1, s2);\\n            return s1.top();\\n        }\\n    \\n        void cal(stack<int> &s1, stack<char> &s2){\\n            int v1 = s1.top(); s1.pop();\\n            int v2 = s1.top(); s1.pop();\\n            char c = s2.top(); s2.pop();\\n            if(c == '+') s1.push(v1 + v2);\\n            if(c == '-') s1.push(v1 - v2);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int calculate(string s) {\\n            int n = s.size();\\n            stack<int> s1;\\n            stack<char> s2;\\n            string v;\\n            for(int i = n - 1; i >= 0; i--){\\n                if(s[i] == ')' || s[i] == '+' || s[i] == '-') s2.push(s[i]);\\n                else if(s[i] >= '0' && s[i] <= '9'){\\n                    v = s[i] + v;\\n                    if(i == 0 || s[i - 1] < '0' || s[i - 1] > '9'){\\n                        s1.push(stoi(v)); \\n                        v = \"\";\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 414898,
                "title": "infix-to-postfix-a-general-approach-to-similar-questions",
                "content": "Similar questions:\\n\\n1. [Basic Calculator](https://leetcode.com/problems/basic-calculator/) | [Solution](https://leetcode.com/problems/basic-calculator/discuss/414898/Infix-to-Postfix-a-general-approach-to-similar-questions) (this one)\\n2. [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/) | [Solution](https://leetcode.com/problems/basic-calculator-ii/discuss/414897/Infix-to-Postfix-a-general-approach-to-similar-questions)\\n3. [Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/) | [Solution](https://leetcode.com/problems/basic-calculator-iii/discuss/414896/Infix-to-Postfix-a-general-approach-to-similar-questions)\\n\\nThese questions all ask we to evaluate a infix expression with simple math operators in it. \\nWhats infix? For infix expression(the one we use daily) binary operators appear between two operand. And for postfix, operator appears after operand, even for unary operand.\\n\\nInfix: \\n`1 -  (1 + 2)`\\nPostfix:\\n`1 1 2 + -`\\n\\nEvaluating postfix expressions is much easier and simpler than infix ones, so the general idea is to convert infix expression to a postfix one, and evaluate postfix expression with the help of stack.\\n\\nThe general solution comes in two parts:\\n1. Convert infix expression to postfix expression\\n2. Evaluate postfix expression\\n\\n---\\n\\n1. Convert\\n\\nHere is the algorithm I found online: \\nhttps://condor.depaul.edu/ichu/csc415/notes/notes9/Infix.htm\\n\\nFor this question, the code looks like this. For the code for other questions, please see the link above.\\n\\n```python\\ndef calculate(self, s: str) -> int:\\n\\tstack = []\\n\\t# postfix result\\n\\toutput = []\\n\\n\\trank = {\\n\\t\\t\\'+\\': 1,\\n\\t\\t\\'-\\': 1,\\n\\t\\t\\'*\\': 2,\\n\\t\\t\\'/\\': 2,\\n\\t}\\n\\n\\t# None means no number is parsed\\n\\tnum = None\\n\\n\\tfor c in s:\\n\\t\\tif c == \\' \\':\\n\\t\\t\\tcontinue\\n\\n\\t\\tif c in \"0123456789\":\\n\\t\\t\\tif num is None:\\n\\t\\t\\t\\tnum = 0\\n\\t\\t\\tnum = num * 10 + int(c)\\n\\t\\t\\tcontinue\\n\\n\\t\\t# c is opeartor or ()\\n\\t\\t# output prev num to output\\n\\t\\tif num is not None:\\n\\t\\t\\toutput.append(num)\\n\\t\\t\\tnum = None\\n\\n\\t\\tif c == \\'(\\':\\n\\t\\t\\tstack.append(\\'(\\')\\n\\t\\telif c == \\')\\':\\n\\t\\t\\t# pop until (\\n\\t\\t\\twhile stack[-1] != \\'(\\':\\n\\t\\t\\t\\toutput.append(stack.pop())\\n\\n\\t\\t\\t# pop (\\n\\t\\t\\tstack.pop()\\n\\t\\telse:\\n\\t\\t\\t# pop all aperator with higher or equal rank in stack, until meet (\\n\\t\\t\\twhile stack and stack[-1] != \\'(\\' and rank[stack[-1]] >= rank[c]:\\n\\t\\t\\t\\toutput.append(stack.pop())\\n\\n\\t\\t\\t# push cur operator\\n\\t\\t\\tstack.append(c)\\n\\n\\t# handle leftover\\n\\tif num != None:\\n\\t\\toutput.append(num)\\n\\twhile stack:\\n\\t\\toutput.append(stack.pop())\\n\\n\\treturn self.eval(output)\\n```\\n\\n2. Evaluate\\n\\nThis part is almost the same for all three questions.\\n\\n```\\ndef eval(self, postfix):\\n\\tstack = []\\n\\tfor token in postfix:\\n\\t\\tif token == \\'+\\':\\n\\t\\t\\ta = stack.pop()\\n\\t\\t\\tb = stack.pop()\\n\\n\\t\\t\\tstack.append(a + b)\\n\\t\\telif token == \\'-\\':\\n\\t\\t\\tb = stack.pop()\\n\\t\\t\\ta = stack.pop()\\n\\n\\t\\t\\tstack.append(a - b)\\n\\t\\telif token == \\'*\\':\\n\\t\\t\\ta = stack.pop()\\n\\t\\t\\tb = stack.pop()\\n\\n\\t\\t\\tstack.append(a * b)\\n\\t\\telif token == \\'/\\':\\n\\t\\t\\tb = stack.pop()\\n\\t\\t\\ta = stack.pop()\\n\\n\\t\\t\\tstack.append(a // b)\\n\\t\\telse:\\n\\t\\t\\tstack.append(token)\\n\\n\\treturn stack[-1]\\n```\\n\\nI not sure about the time complexity, i think it should be O(n) because we go through the input once, and in the worst case we have to go through the stack once too to pop all the operators in it.",
                "solutionTags": [],
                "code": "```python\\ndef calculate(self, s: str) -> int:\\n\\tstack = []\\n\\t# postfix result\\n\\toutput = []\\n\\n\\trank = {\\n\\t\\t\\'+\\': 1,\\n\\t\\t\\'-\\': 1,\\n\\t\\t\\'*\\': 2,\\n\\t\\t\\'/\\': 2,\\n\\t}\\n\\n\\t# None means no number is parsed\\n\\tnum = None\\n\\n\\tfor c in s:\\n\\t\\tif c == \\' \\':\\n\\t\\t\\tcontinue\\n\\n\\t\\tif c in \"0123456789\":\\n\\t\\t\\tif num is None:\\n\\t\\t\\t\\tnum = 0\\n\\t\\t\\tnum = num * 10 + int(c)\\n\\t\\t\\tcontinue\\n\\n\\t\\t# c is opeartor or ()\\n\\t\\t# output prev num to output\\n\\t\\tif num is not None:\\n\\t\\t\\toutput.append(num)\\n\\t\\t\\tnum = None\\n\\n\\t\\tif c == \\'(\\':\\n\\t\\t\\tstack.append(\\'(\\')\\n\\t\\telif c == \\')\\':\\n\\t\\t\\t# pop until (\\n\\t\\t\\twhile stack[-1] != \\'(\\':\\n\\t\\t\\t\\toutput.append(stack.pop())\\n\\n\\t\\t\\t# pop (\\n\\t\\t\\tstack.pop()\\n\\t\\telse:\\n\\t\\t\\t# pop all aperator with higher or equal rank in stack, until meet (\\n\\t\\t\\twhile stack and stack[-1] != \\'(\\' and rank[stack[-1]] >= rank[c]:\\n\\t\\t\\t\\toutput.append(stack.pop())\\n\\n\\t\\t\\t# push cur operator\\n\\t\\t\\tstack.append(c)\\n\\n\\t# handle leftover\\n\\tif num != None:\\n\\t\\toutput.append(num)\\n\\twhile stack:\\n\\t\\toutput.append(stack.pop())\\n\\n\\treturn self.eval(output)\\n```\n```\\ndef eval(self, postfix):\\n\\tstack = []\\n\\tfor token in postfix:\\n\\t\\tif token == \\'+\\':\\n\\t\\t\\ta = stack.pop()\\n\\t\\t\\tb = stack.pop()\\n\\n\\t\\t\\tstack.append(a + b)\\n\\t\\telif token == \\'-\\':\\n\\t\\t\\tb = stack.pop()\\n\\t\\t\\ta = stack.pop()\\n\\n\\t\\t\\tstack.append(a - b)\\n\\t\\telif token == \\'*\\':\\n\\t\\t\\ta = stack.pop()\\n\\t\\t\\tb = stack.pop()\\n\\n\\t\\t\\tstack.append(a * b)\\n\\t\\telif token == \\'/\\':\\n\\t\\t\\tb = stack.pop()\\n\\t\\t\\ta = stack.pop()\\n\\n\\t\\t\\tstack.append(a // b)\\n\\t\\telse:\\n\\t\\t\\tstack.append(token)\\n\\n\\treturn stack[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1246403,
                "title": "c-easy-using-basic-method-of-solving",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int calculate(string s) {\\n        //we basically calculate everything at a time and update it in result varibale\\n        int result=0;\\n        int sign=1; //1 represents +ve -1 represents -ve\\n        int j=0;\\n        int len=s.length();\\n        stack<int> stk;\\n        \\n        while(j<len){ \\n            if(s[j]==\\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if(s[j]==\\'-\\')\\n            {\\n                //we got a negative value\\n                sign=-1;\\n            }\\n            else if(isdigit(s[j]))\\n            {\\n                //get the number \\n                int num=s[j]-\\'0\\';\\n                while(j+1<len && isdigit(s[j+1])){\\n                    num=num*10+(s[j+1]-\\'0\\');\\n                    j++;\\n                }\\n                //now add it to the result along with sign\\n                result+=num*sign;\\n            }\\n            else if(s[j]==\\'(\\')\\n            {\\n                //we push the current result and current sign into the stack\\n                stk.push(result);\\n                stk.push(sign);\\n                result=0;\\n                sign=1;\\n            }\\n            else if(s[j]==\\')\\')\\n            {\\n                //get the last result and the sign from the stack\\n                int xsign=stk.top();\\n                stk.pop();\\n                int xresult=stk.top();\\n                stk.pop();\\n                //add the curr result in parenthesis to prev result and update the entire result\\n                result=result*xsign + xresult;\\n                //xsign will be the sign before the begin of parenthesis\\n            }\\n            j++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int calculate(string s) {\\n        //we basically calculate everything at a time and update it in result varibale\\n        int result=0;\\n        int sign=1; //1 represents +ve -1 represents -ve\\n        int j=0;\\n        int len=s.length();\\n        stack<int> stk;\\n        \\n        while(j<len){ \\n            if(s[j]==\\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if(s[j]==\\'-\\')\\n            {\\n                //we got a negative value\\n                sign=-1;\\n            }\\n            else if(isdigit(s[j]))\\n            {\\n                //get the number \\n                int num=s[j]-\\'0\\';\\n                while(j+1<len && isdigit(s[j+1])){\\n                    num=num*10+(s[j+1]-\\'0\\');\\n                    j++;\\n                }\\n                //now add it to the result along with sign\\n                result+=num*sign;\\n            }\\n            else if(s[j]==\\'(\\')\\n            {\\n                //we push the current result and current sign into the stack\\n                stk.push(result);\\n                stk.push(sign);\\n                result=0;\\n                sign=1;\\n            }\\n            else if(s[j]==\\')\\')\\n            {\\n                //get the last result and the sign from the stack\\n                int xsign=stk.top();\\n                stk.pop();\\n                int xresult=stk.top();\\n                stk.pop();\\n                //add the curr result in parenthesis to prev result and update the entire result\\n                result=result*xsign + xresult;\\n                //xsign will be the sign before the begin of parenthesis\\n            }\\n            j++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833545,
                "title": "c-simple-solution-one-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int calculate(string s) \\n    {\\n        stack<int>st; \\n        int ans=0; \\n        long long cur_val = 0, sign=1; \\n       \\n        for (char c : s) \\n        { \\n            if(isdigit(c)) \\n            {\\n                // extract the number\\n                cur_val = 10*cur_val + (c-\\'0\\'); \\n            }\\n            else if(c==\\'+\\')\\n            {\\n                ans += cur_val*sign; \\n                cur_val = 0;\\n                sign = 1;   \\n            }\\n            else if(c==\\'-\\')\\n            {\\n                ans += cur_val*sign; \\n                cur_val = 0; \\n                sign = -1; \\n            }\\n            else if(c==\\'(\\')\\n            {\\n                st.push(ans);    \\n                st.push(sign); \\n                ans = 0; \\n                sign = 1;\\n            }\\n            else if(c==\\')\\')\\n            { \\n                ans += cur_val*sign; \\n                cur_val = 0;\\n                \\n                ans = ans*st.top(); // multiplying with sign\\n                st.pop();\\n                ans = ans + st.top(); // multiplying with number\\n                st.pop();\\n            }\\n        }\\n        \\n        ans += cur_val*sign; \\n        return ans; \\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int calculate(string s) \\n    {\\n        stack<int>st; \\n        int ans=0; \\n        long long cur_val = 0, sign=1; \\n       \\n        for (char c : s) \\n        { \\n            if(isdigit(c)) \\n            {\\n                // extract the number\\n                cur_val = 10*cur_val + (c-\\'0\\'); \\n            }\\n            else if(c==\\'+\\')\\n            {\\n                ans += cur_val*sign; \\n                cur_val = 0;\\n                sign = 1;   \\n            }\\n            else if(c==\\'-\\')\\n            {\\n                ans += cur_val*sign; \\n                cur_val = 0; \\n                sign = -1; \\n            }\\n            else if(c==\\'(\\')\\n            {\\n                st.push(ans);    \\n                st.push(sign); \\n                ans = 0; \\n                sign = 1;\\n            }\\n            else if(c==\\')\\')\\n            { \\n                ans += cur_val*sign; \\n                cur_val = 0;\\n                \\n                ans = ans*st.top(); // multiplying with sign\\n                st.pop();\\n                ans = ans + st.top(); // multiplying with number\\n                st.pop();\\n            }\\n        }\\n        \\n        ans += cur_val*sign; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974370,
                "title": "c-easy-to-understand-stack-detailed-explanations",
                "content": "**Code flow With diagram**\\n\\n![image](https://assets.leetcode.com/users/images/2fd1c4a5-c106-4eb3-bd3d-83c9d8c7d5b0_1650696375.4016645.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n       \\n        int n = s.length();\\n        stack<int> stk ;\\n        int res = 0;\\n        int sign = 1;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            if(s[i] == \\'+\\')\\n                sign = 1;\\n            else if(s[i] == \\'-\\')\\n                sign = -1;\\n            else if(isdigit(s[i])){\\n                long long temp = 0;\\n                \\n                while(i < n and isdigit(s[i])){\\n                    temp = temp*10 + s[i] - \\'0\\';\\n                    i++;\\n                }\\n                i--;\\n                res = res + sign*temp;\\n            }\\n            else if(s[i] == \\'(\\'){\\n                stk.push(res);\\n                stk.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\')\\'){\\n                int curr_sign = stk.top(); stk.pop();\\n                int curr_val = stk.top(); stk.pop();\\n                \\n                res = curr_val + curr_sign * res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**If you find this is helpful**\\n**Please Upvote this solution !!**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n       \\n        int n = s.length();\\n        stack<int> stk ;\\n        int res = 0;\\n        int sign = 1;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            if(s[i] == \\'+\\')\\n                sign = 1;\\n            else if(s[i] == \\'-\\')\\n                sign = -1;\\n            else if(isdigit(s[i])){\\n                long long temp = 0;\\n                \\n                while(i < n and isdigit(s[i])){\\n                    temp = temp*10 + s[i] - \\'0\\';\\n                    i++;\\n                }\\n                i--;\\n                res = res + sign*temp;\\n            }\\n            else if(s[i] == \\'(\\'){\\n                stk.push(res);\\n                stk.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\')\\'){\\n                int curr_sign = stk.top(); stk.pop();\\n                int curr_val = stk.top(); stk.pop();\\n                \\n                res = curr_val + curr_sign * res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689035,
                "title": "python-3-using-recursion-without-stack",
                "content": "```\\nclass Solution:\\n    def calculate(self, s):\\n        def evaluate(i):\\n            res, digit, sign = 0, 0, 1\\n            \\n            while i < len(s):\\n                if s[i].isdigit():\\n                    digit = digit * 10 + int(s[i])\\n                elif s[i] in \\'+-\\':\\n                    res += digit * sign\\n                    digit = 0\\n                    sign = 1 if s[i] == \\'+\\' else -1\\n                elif s[i] == \\'(\\':\\n                    subres, i = evaluate(i+1)\\n                    res += sign * subres\\n                elif s[i] == \\')\\':\\n                    res += digit * sign\\n                    return res, i\\n                i += 1\\n\\n            return res + digit * sign\\n        \\n        return evaluate(0)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s):\\n        def evaluate(i):\\n            res, digit, sign = 0, 0, 1\\n            \\n            while i < len(s):\\n                if s[i].isdigit():\\n                    digit = digit * 10 + int(s[i])\\n                elif s[i] in \\'+-\\':\\n                    res += digit * sign\\n                    digit = 0\\n                    sign = 1 if s[i] == \\'+\\' else -1\\n                elif s[i] == \\'(\\':\\n                    subres, i = evaluate(i+1)\\n                    res += sign * subres\\n                elif s[i] == \\')\\':\\n                    res += digit * sign\\n                    return res, i\\n                i += 1\\n\\n            return res + digit * sign\\n        \\n        return evaluate(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625909,
                "title": "javascript-iterative-stack-with-comments",
                "content": "```\\nvar calculate = function(s) {\\n    let sign = 1, sum = 0;\\n    \\n    const stack = []; \\n    for (let i = 0; i < s.length; i += 1) {\\n        if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            let num = 0\\n\\t\\t\\t// num can be multiple digits, iterate to build full num.\\n            while (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                num = (num * 10) + (s[i] - \\'0\\');\\n                i += 1;\\n            }\\n\\t\\t\\t// add your completed sum.\\n            sum += (num * sign);\\n\\t\\t\\t// while loop from earlier causes our index to move forward once, bring it back\\n            i -= 1;\\n        } else if (s[i] === \\'+\\') {\\n            sign = 1;\\n        } else if (s[i] === \\'-\\') {\\n            sign = -1;\\n        } else if (s[i] === \\'(\\') {\\n\\t\\t\\t// open parens signifies that we should calculate the inside of the parens first and store the outer sum and sign in stack. \\n\\t\\t\\t// we can later retrieve the values in our stack once we find a closing bracket.\\n            stack.push(sum);\\n            stack.push(sign);\\n            sum = 0\\n\\t\\t\\t// we used our sign, reset it to default.\\n            sign = 1;\\n        } else if (s[i] === \\')\\') {\\n\\t\\t\\t// closing bracket assumes we\\'ve calculated the sum inside the parens. \\n\\t\\t\\t// Earlier, we pushed the sum first into our stack. First pop will be the sign. Second pop will be the outer sum.\\n            sum = stack.pop() * sum;\\n            sum += stack.pop();\\n        }\\n    }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar calculate = function(s) {\\n    let sign = 1, sum = 0;\\n    \\n    const stack = []; \\n    for (let i = 0; i < s.length; i += 1) {\\n        if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            let num = 0\\n\\t\\t\\t// num can be multiple digits, iterate to build full num.\\n            while (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                num = (num * 10) + (s[i] - \\'0\\');\\n                i += 1;\\n            }\\n\\t\\t\\t// add your completed sum.\\n            sum += (num * sign);\\n\\t\\t\\t// while loop from earlier causes our index to move forward once, bring it back\\n            i -= 1;\\n        } else if (s[i] === \\'+\\') {\\n            sign = 1;\\n        } else if (s[i] === \\'-\\') {\\n            sign = -1;\\n        } else if (s[i] === \\'(\\') {\\n\\t\\t\\t// open parens signifies that we should calculate the inside of the parens first and store the outer sum and sign in stack. \\n\\t\\t\\t// we can later retrieve the values in our stack once we find a closing bracket.\\n            stack.push(sum);\\n            stack.push(sign);\\n            sum = 0\\n\\t\\t\\t// we used our sign, reset it to default.\\n            sign = 1;\\n        } else if (s[i] === \\')\\') {\\n\\t\\t\\t// closing bracket assumes we\\'ve calculated the sum inside the parens. \\n\\t\\t\\t// Earlier, we pushed the sum first into our stack. First pop will be the sign. Second pop will be the outer sum.\\n            sum = stack.pop() * sum;\\n            sum += stack.pop();\\n        }\\n    }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1483709,
                "title": "n-th-tribonacci-number-one-pass-w-explanation-c-python-java",
                "content": "**IDEA**\\n*One Pass*\\n\\nTo calculate N-th Tribonacci Number\\n* `T[0] = 0`\\n* `T[1] = 1`\\n* `T[2] = 1`\\n* `T[n] = T[n-3] + T[n-2] + T[n-1]`, `n >= 3`\\n\\nWe only need to store three values at a time. We can use \\n* 3 variables\\n* A static array and modulo-3 indexing.\\n\\n**TIME COMPLEXITY - O(N)**\\n**SPACE COMPLEXITY - O(1)**\\n\\n**SOLUTION**\\n*Using 3 variables*\\n`IN C++`\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if (n < 2) \\n            return n;\\n        int a = 0, b = 1, c = 1, d = a + b + c;\\n        while (n-- > 2) {\\n            d = a + b + c, a = b, b = c, c = d;\\n        }\\n        return c;\\n    }\\n};\\n```\\n`IN JAVA`\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if (n < 2) return n;\\n        int a = 0, b = 1, c = 1, d;\\n        while (n-- > 2) {\\n            d = a + b + c;\\n            a = b;\\n            b = c;\\n            c = d;\\n        }\\n        return c;\\n    }\\n}\\n```\\n`IN PYTHON`\\n```\\ndef tribonacci(self, n):\\n        a, b, c = 1, 0, 0\\n        for _ in xrange(n): a, b, c = b, c, a + b + c\\n        return c\\n```\\n*Using Static Array*\\n`IN C++`\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int a[3] = {0 , 1 , 1} ;\\n        for(int i = 3 ; i <= n ; i++)\\n        {\\n            a[i%3] += a[(i+1)%3] + a[(i+2)%3] ;\\n        }\\n        return a[n%3] ;\\n    }\\n};\\n```\\n`IN JAVA`\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int a[] = {0, 1, 1};\\n        for (int i = 3; i <= n; i++)\\n            a[i % 3] = a[0] + a[1] + a[2];\\n        return a[n % 3];\\n    }\\n}\\n```\\n`IN PYTHON`\\n```\\nclass Solution(object):\\n    def tribonacci(self, n):\\n        a = [0, 1, 1]\\n        for i in xrange(3, n + 1):\\n            a[i % 3] = sum(a)\\n        return a[n % 3]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if (n < 2) \\n            return n;\\n        int a = 0, b = 1, c = 1, d = a + b + c;\\n        while (n-- > 2) {\\n            d = a + b + c, a = b, b = c, c = d;\\n        }\\n        return c;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if (n < 2) return n;\\n        int a = 0, b = 1, c = 1, d;\\n        while (n-- > 2) {\\n            d = a + b + c;\\n            a = b;\\n            b = c;\\n            c = d;\\n        }\\n        return c;\\n    }\\n}\\n```\n```\\ndef tribonacci(self, n):\\n        a, b, c = 1, 0, 0\\n        for _ in xrange(n): a, b, c = b, c, a + b + c\\n        return c\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int a[3] = {0 , 1 , 1} ;\\n        for(int i = 3 ; i <= n ; i++)\\n        {\\n            a[i%3] += a[(i+1)%3] + a[(i+2)%3] ;\\n        }\\n        return a[n%3] ;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int a[] = {0, 1, 1};\\n        for (int i = 3; i <= n; i++)\\n            a[i % 3] = a[0] + a[1] + a[2];\\n        return a[n % 3];\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def tribonacci(self, n):\\n        a = [0, 1, 1]\\n        for i in xrange(3, n + 1):\\n            a[i % 3] = sum(a)\\n        return a[n % 3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686489,
                "title": "optimal-generic-solution-for-basic-calculator-i-ii-iii-time-and-space-o-n",
                "content": "I found the similar template solution on these three 3 problems:\\n[Basic Calculator](https://leetcode.com/problems/basic-calculator/)  :   The expression string may contain open ( and closing parentheses ), the + , - operators, non-negative integers and empty spaces .\\n[Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)  : The expression string contains only non-negative integers, +, -, *, / operators \\n[Basic Calculator III ](https://leetcode.com/problems/basic-calculator-iii/) : The expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces \\n\\n\\nSolution for [Basic Calculator III ](https://leetcode.com/problems/basic-calculator-iii/)\\n\\n```\\nclass Solution {\\n    // recursive Time and Space O(N)\\n    int i = 0;\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int result = 0, tmp = 0, num = 0;\\n        char op = \\'+\\';\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i++);\\n            if (Character.isDigit(c)) {\\n                tmp = tmp * 10 + c - \\'0\\';\\n            } else if (c == \\'(\\') {\\n                tmp = calculate(s);     // string parse index is tracked by i\\n            } else if (c == \\')\\') {\\n                break;\\n            } else if (c != \\' \\') {\\n                //process the numerical value of string so far; based on what \\'op\\' we have before it\\n                num = cal(num, tmp, op);\\n                if (c == \\'+\\' || c == \\'-\\') {\\n                    result += num;\\n                    num = 0;\\n                }\\n                //reset \\'tmp\\' and op for next character  processing\\n                tmp = 0;\\n                op = c;\\n            }\\n        }\\n        return result + cal(num, tmp, op);\\n    }\\n    private int cal(int num, int tmp, char op) {\\n        if (op == \\'+\\') return num + tmp;\\n        else if (op == \\'-\\') return num - tmp;\\n        else if (op == \\'*\\') return num * tmp;\\n        else return num / tmp;\\n    }\\n}\\n```\\n\\nSolution for [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)\\n```\\nclass Solution {        // 3 + 2 * 5\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int num = 0, tmp = 0, res = 0;\\n        char op = \\'+\\';\\n        for (char c : s.toCharArray()) {\\n            if (Character.isDigit(c)) {\\n                tmp = tmp*10 + c - \\'0\\';\\n            } else if (c != \\' \\') {\\n\\t\\t\\t\\t//process the numerical value of string so far; based on what \\'op\\' we have before it\\n                num = cal(num, tmp, op);\\n                if (c == \\'+\\' || c == \\'-\\') {\\n                    res += num;\\n                    num = 0;\\n                }\\n\\t\\t\\t\\t// reset\\n                tmp = 0;\\n                op = c;\\n            }\\n        }\\n        return res + cal(num, tmp, op);\\n    }\\n    private int cal(int num, int tmp, char op) {\\n        if (op == \\'+\\') return num + tmp;\\n        else if (op == \\'-\\') return num - tmp;\\n        else if (op == \\'*\\') return num * tmp;\\n        else    return num / tmp;\\n    }\\n}\\n```\\n\\n\\nSolution for [Basic Calculator](https://leetcode.com/problems/basic-calculator/)\\n\\n```\\nclass Solution {\\n    // Time O(N) Space O(N) for recursive or stack\\n    int i = 0;\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int tmp = 0, sign = 1, result = 0;\\n        while (i < s.length()) {\\n            char c = s.charAt(i++);\\n            if (Character.isDigit(c)) {\\n                tmp = tmp * 10 + c - \\'0\\';\\n            } else if (c == \\'(\\') {\\n                tmp = calculate(s);\\n            } else if (c == \\')\\') {\\n                break;\\n            } else if (c == \\'+\\' || c == \\'-\\') {\\n                result += sign * tmp;\\n                tmp = 0;\\n                sign = (c == \\'+\\')? 1 : -1;\\n            }\\n        }\\n        result += sign * tmp;\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // recursive Time and Space O(N)\\n    int i = 0;\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int result = 0, tmp = 0, num = 0;\\n        char op = \\'+\\';\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i++);\\n            if (Character.isDigit(c)) {\\n                tmp = tmp * 10 + c - \\'0\\';\\n            } else if (c == \\'(\\') {\\n                tmp = calculate(s);     // string parse index is tracked by i\\n            } else if (c == \\')\\') {\\n                break;\\n            } else if (c != \\' \\') {\\n                //process the numerical value of string so far; based on what \\'op\\' we have before it\\n                num = cal(num, tmp, op);\\n                if (c == \\'+\\' || c == \\'-\\') {\\n                    result += num;\\n                    num = 0;\\n                }\\n                //reset \\'tmp\\' and op for next character  processing\\n                tmp = 0;\\n                op = c;\\n            }\\n        }\\n        return result + cal(num, tmp, op);\\n    }\\n    private int cal(int num, int tmp, char op) {\\n        if (op == \\'+\\') return num + tmp;\\n        else if (op == \\'-\\') return num - tmp;\\n        else if (op == \\'*\\') return num * tmp;\\n        else return num / tmp;\\n    }\\n}\\n```\n```\\nclass Solution {        // 3 + 2 * 5\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int num = 0, tmp = 0, res = 0;\\n        char op = \\'+\\';\\n        for (char c : s.toCharArray()) {\\n            if (Character.isDigit(c)) {\\n                tmp = tmp*10 + c - \\'0\\';\\n            } else if (c != \\' \\') {\\n\\t\\t\\t\\t//process the numerical value of string so far; based on what \\'op\\' we have before it\\n                num = cal(num, tmp, op);\\n                if (c == \\'+\\' || c == \\'-\\') {\\n                    res += num;\\n                    num = 0;\\n                }\\n\\t\\t\\t\\t// reset\\n                tmp = 0;\\n                op = c;\\n            }\\n        }\\n        return res + cal(num, tmp, op);\\n    }\\n    private int cal(int num, int tmp, char op) {\\n        if (op == \\'+\\') return num + tmp;\\n        else if (op == \\'-\\') return num - tmp;\\n        else if (op == \\'*\\') return num * tmp;\\n        else    return num / tmp;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // Time O(N) Space O(N) for recursive or stack\\n    int i = 0;\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int tmp = 0, sign = 1, result = 0;\\n        while (i < s.length()) {\\n            char c = s.charAt(i++);\\n            if (Character.isDigit(c)) {\\n                tmp = tmp * 10 + c - \\'0\\';\\n            } else if (c == \\'(\\') {\\n                tmp = calculate(s);\\n            } else if (c == \\')\\') {\\n                break;\\n            } else if (c == \\'+\\' || c == \\'-\\') {\\n                result += sign * tmp;\\n                tmp = 0;\\n                sign = (c == \\'+\\')? 1 : -1;\\n            }\\n        }\\n        result += sign * tmp;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227625,
                "title": "224-time-93-3-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis code implements a basic calculator to evaluate a given expression represented as a string s.\\n\\nThe algorithm processes the string character by character and maintains three variables ans, num, and sign, and a stack stack.\\n\\nans stores the running total of the expression evaluated so far, num stores the currently processed number, and sign stores the sign of the current environment. The stack keeps track of nested environments by storing the sign of the previous environment.\\n\\nThe algorithm then iterates through each character c in the string s and does the following:\\n\\n- If c is a digit, it appends it to num.\\n- If c is a left parenthesis (, it appends the current sign to the stack and sets sign to 1 (since the current environment is positive).\\n- If c is a right parenthesis ), it pops the last sign from the stack and sets sign to it.\\n- If c is a plus + or minus -, it updates the ans by adding the current sign * num to it, updates the sign to 1 or -1 depending on the current operator, and sets num to 0.\\n\\nFinally, the function returns the updated ans value plus the last sign * num.\\n\\nOverall, this algorithm works in linear time with respect to the length of the input string, since each character is processed once.\\n\\n# Complexity\\n- Time complexity:\\n93.3%\\n\\n- Space complexity:\\n72.30%\\n# Code\\n```\\nclass Solution:\\n  def calculate(self, s: str) -> int:\\n    ans = 0\\n    num = 0\\n    sign = 1\\n    stack = [sign]  # stack[-1]: current env\\'s sign\\n\\n    for c in s:\\n      if c.isdigit():\\n        num = num * 10 + (ord(c) - ord(\\'0\\'))\\n      elif c == \\'(\\':\\n        stack.append(sign)\\n      elif c == \\')\\':\\n        stack.pop()\\n      elif c == \\'+\\' or c == \\'-\\':\\n        ans += sign * num\\n        sign = (1 if c == \\'+\\' else -1) * stack[-1]\\n        num = 0\\n\\n    return ans + sign * num\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n  def calculate(self, s: str) -> int:\\n    ans = 0\\n    num = 0\\n    sign = 1\\n    stack = [sign]  # stack[-1]: current env\\'s sign\\n\\n    for c in s:\\n      if c.isdigit():\\n        num = num * 10 + (ord(c) - ord(\\'0\\'))\\n      elif c == \\'(\\':\\n        stack.append(sign)\\n      elif c == \\')\\':\\n        stack.pop()\\n      elif c == \\'+\\' or c == \\'-\\':\\n        ans += sign * num\\n        sign = (1 if c == \\'+\\' else -1) * stack[-1]\\n        num = 0\\n\\n    return ans + sign * num\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832860,
                "title": "c-dijkstra-s-shunting-yard-algorithm",
                "content": "There are much shorter solutions for this problem. The approach taken here is a little bit more generic and can easily adopted for other problems.\\n\\n# Approach 1: Dijkstra\\'s shunting yard algorithm\\n\\nThis approach is slightly more generic than it would need to be to solve this problem. It also handles multiplication and division. Checkout wikipedia for more details. I am not linking directly to it, as am worried that the LC automatic content moderator will flag the post.\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    // Operator precedence.\\n    static int prec(char ch) {\\n        switch (ch) {\\n            case \\'(\\':\\n                // Use the lowest because we handled this differently.\\n                return -1;\\n\\n            case \\'+\\':\\n            case \\'-\\':\\n                return 0;\\n\\n            case \\'*\\':\\n            case \\'/\\':\\n                return 1;\\n\\n            case \\'_\\':\\n                // Use \\'_\\' for unary minus.\\n                return 2;\\n        }\\n        assert(false);\\n        return -1;\\n    }\\n    \\n    // Apply operators.\\n    static void apply(stack<int>& out, char op) {\\n        // Unary minus.\\n        if (op == \\'_\\') {\\n            out.top() *= -1;\\n            return;\\n        }\\n\\n        const int right = out.top(); out.pop();\\n        const int left = out.top(); out.pop();\\n        switch (op) {\\n            case \\'+\\':\\n                out.push(left + right);\\n                break;\\n            case \\'-\\':\\n                out.push(left - right);\\n                break;\\n            case \\'*\\':\\n                out.push(left * right);\\n                break;\\n            case \\'/\\':\\n                out.push(left / right);\\n                break;\\n            default:\\n                assert(false);\\n        }\\n    }\\n\\npublic:\\n    static int calculate(string s) {\\n        // Handling unary \\'-\\' from wcipeg.com:\\n        // A minus sign is always binary if it immediately follows an operand\\n        // or a right parenthesis, and it is always unary if it immediately\\n        // follows another operator or a left parenthesis, or if it occurs at\\n        // the very beginning of the input. The algorithm must be modified in\\n        // order to distinguish between the two.\\n\\n        // ... so we always push the last number\\n        s.push_back(\\' \\');\\n        \\n        stack<int> out;\\n        stack<char> st;\\n        \\n        char prev = \\' \\';\\n        string num;\\n        for (char ch : s) {\\n            if (isdigit(ch)) {\\n                num.push_back(ch);\\n                prev = \\'1\\';\\n            } else {\\n                if (!empty(num)) {\\n                    out.push(stoi(num));\\n                    num.clear();\\n                }\\n                \\n                if (ch == \\' \\') continue;\\n                \\n                if (ch == \\'(\\') {\\n                    st.push(\\'(\\');\\n                } else if (ch == \\')\\') {\\n                    while (st.top() != \\'(\\') {\\n                        apply(out, st.top());\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                } else {\\n                    // Unary minus.\\n                    if (ch == \\'-\\' && prev != \\'1\\' && prev != \\')\\') {\\n                        ch = \\'_\\';\\n                    }\\n                    while (!empty(st) && prec(ch) <= prec(st.top())) {\\n                        apply(out, st.top());\\n                        st.pop();\\n                    }\\n                    st.push(ch);\\n                }\\n\\n                prev = ch;\\n            }\\n        }\\n        \\n        while (!empty(st)) {\\n            apply(out, st.top());\\n            st.pop();\\n        }\\n\\n        assert(size(out) == 1);\\n        return out.top();\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the length of the input string then the\\n  * Time complexity is $$O(n)$$, and the \\n  * Space complexity is $$O(n)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    // Operator precedence.\\n    static int prec(char ch) {\\n        switch (ch) {\\n            case \\'(\\':\\n                // Use the lowest because we handled this differently.\\n                return -1;\\n\\n            case \\'+\\':\\n            case \\'-\\':\\n                return 0;\\n\\n            case \\'*\\':\\n            case \\'/\\':\\n                return 1;\\n\\n            case \\'_\\':\\n                // Use \\'_\\' for unary minus.\\n                return 2;\\n        }\\n        assert(false);\\n        return -1;\\n    }\\n    \\n    // Apply operators.\\n    static void apply(stack<int>& out, char op) {\\n        // Unary minus.\\n        if (op == \\'_\\') {\\n            out.top() *= -1;\\n            return;\\n        }\\n\\n        const int right = out.top(); out.pop();\\n        const int left = out.top(); out.pop();\\n        switch (op) {\\n            case \\'+\\':\\n                out.push(left + right);\\n                break;\\n            case \\'-\\':\\n                out.push(left - right);\\n                break;\\n            case \\'*\\':\\n                out.push(left * right);\\n                break;\\n            case \\'/\\':\\n                out.push(left / right);\\n                break;\\n            default:\\n                assert(false);\\n        }\\n    }\\n\\npublic:\\n    static int calculate(string s) {\\n        // Handling unary \\'-\\' from wcipeg.com:\\n        // A minus sign is always binary if it immediately follows an operand\\n        // or a right parenthesis, and it is always unary if it immediately\\n        // follows another operator or a left parenthesis, or if it occurs at\\n        // the very beginning of the input. The algorithm must be modified in\\n        // order to distinguish between the two.\\n\\n        // ... so we always push the last number\\n        s.push_back(\\' \\');\\n        \\n        stack<int> out;\\n        stack<char> st;\\n        \\n        char prev = \\' \\';\\n        string num;\\n        for (char ch : s) {\\n            if (isdigit(ch)) {\\n                num.push_back(ch);\\n                prev = \\'1\\';\\n            } else {\\n                if (!empty(num)) {\\n                    out.push(stoi(num));\\n                    num.clear();\\n                }\\n                \\n                if (ch == \\' \\') continue;\\n                \\n                if (ch == \\'(\\') {\\n                    st.push(\\'(\\');\\n                } else if (ch == \\')\\') {\\n                    while (st.top() != \\'(\\') {\\n                        apply(out, st.top());\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                } else {\\n                    // Unary minus.\\n                    if (ch == \\'-\\' && prev != \\'1\\' && prev != \\')\\') {\\n                        ch = \\'_\\';\\n                    }\\n                    while (!empty(st) && prec(ch) <= prec(st.top())) {\\n                        apply(out, st.top());\\n                        st.pop();\\n                    }\\n                    st.push(ch);\\n                }\\n\\n                prev = ch;\\n            }\\n        }\\n        \\n        while (!empty(st)) {\\n            apply(out, st.top());\\n            st.pop();\\n        }\\n\\n        assert(size(out) == 1);\\n        return out.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153199,
                "title": "do-it-the-hard-way-real-lexer-and-parser",
                "content": "```py\\ndigits = set(\\'0123456789\\')\\n\\n\\ndef lexer(s):\\n    stack = []\\n    nums = \\'\\'\\n    for c in s:\\n        if c in digits:\\n            nums += c\\n        else:\\n            if len(nums) > 0:\\n                stack.append(int(nums))\\n                nums = \\'\\'\\n            if c != \\' \\':\\n                stack.append(c)\\n    if len(nums) > 0:\\n        stack.append(int(nums))\\n    return stack[::-1]\\n\\n\\n\"\"\"\\nterm = NUM | (expr)\\nexpr = term op_terms\\nop_terms = None | op_term op_terms\\nop_term = + term | - term\\n\"\"\"\\n\\n\\ndef parser_term(tokens):\\n    t = tokens.pop()\\n    if isinstance(t, int):\\n        return t\\n    elif t == \\'(\\':\\n        content = parser_expr(tokens)\\n        back = tokens.pop()\\n        assert back == \\')\\'\\n        return content\\n    else:\\n        print(tokens)\\n        raise Exception()\\n\\n\\ndef parser_expr(tokens):\\n    lhs = parser_term(tokens)\\n    if not tokens:\\n        return lhs\\n    op_terms = parser_op_terms(tokens)\\n    return lhs + op_terms\\n\\n\\ndef parser_op_terms(tokens):\\n    ret = 0\\n    while True:\\n        op_term = parser_op_term(tokens)\\n        if op_term is None:\\n            return ret\\n        ret += op_term\\n\\n\\ndef parser_op_term(tokens):\\n    if not tokens:\\n        return None\\n    t = tokens.pop()\\n    if t == \\'+\\':\\n        return parser_term(tokens)\\n    elif t == \\'-\\':\\n        return - parser_term(tokens)\\n    else:\\n        tokens.append(t)\\n        return None\\n\\n\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        return parser_expr(lexer(s))\\n        \\n```",
                "solutionTags": [],
                "code": "```py\\ndigits = set(\\'0123456789\\')\\n\\n\\ndef lexer(s):\\n    stack = []\\n    nums = \\'\\'\\n    for c in s:\\n        if c in digits:\\n            nums += c\\n        else:\\n            if len(nums) > 0:\\n                stack.append(int(nums))\\n                nums = \\'\\'\\n            if c != \\' \\':\\n                stack.append(c)\\n    if len(nums) > 0:\\n        stack.append(int(nums))\\n    return stack[::-1]\\n\\n\\n\"\"\"\\nterm = NUM | (expr)\\nexpr = term op_terms\\nop_terms = None | op_term op_terms\\nop_term = + term | - term\\n\"\"\"\\n\\n\\ndef parser_term(tokens):\\n    t = tokens.pop()\\n    if isinstance(t, int):\\n        return t\\n    elif t == \\'(\\':\\n        content = parser_expr(tokens)\\n        back = tokens.pop()\\n        assert back == \\')\\'\\n        return content\\n    else:\\n        print(tokens)\\n        raise Exception()\\n\\n\\ndef parser_expr(tokens):\\n    lhs = parser_term(tokens)\\n    if not tokens:\\n        return lhs\\n    op_terms = parser_op_terms(tokens)\\n    return lhs + op_terms\\n\\n\\ndef parser_op_terms(tokens):\\n    ret = 0\\n    while True:\\n        op_term = parser_op_term(tokens)\\n        if op_term is None:\\n            return ret\\n        ret += op_term\\n\\n\\ndef parser_op_term(tokens):\\n    if not tokens:\\n        return None\\n    t = tokens.pop()\\n    if t == \\'+\\':\\n        return parser_term(tokens)\\n    elif t == \\'-\\':\\n        return - parser_term(tokens)\\n    else:\\n        tokens.append(t)\\n        return None\\n\\n\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        return parser_expr(lexer(s))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 120868,
                "title": "javascript-in-68ms-beat-100",
                "content": "```\\nvar calculate = function(s) {\\n    let result = 0, sign = 1;\\n    const stack = [], opStack = [];\\n    \\n    for(let i = 0; i < s.length; i++){\\n        const curr = s.charAt(i);\\n        if(curr === \\' \\'){ \\n            continue;\\n        } else if(curr === \\'+\\'){ \\n            sign = 1;\\n        } else if(curr === \\'-\\'){ \\n            sign = -1;\\n        } else if(curr >= \\'0\\' && curr <= \\'9\\'){\\n            let num = curr;\\n            while(i+1 < s.length && s.charAt(i+1) >= \\'0\\' && s.charAt(i+1) <= \\'9\\'){\\n                num += s.charAt(i+1);\\n                i++;\\n            }\\n            result += sign * parseInt(num);\\n        } else if(curr === \\'(\\'){\\n            stack.push(result);  \\n            result = 0;  \\n            opStack.push(sign);  \\n            sign = 1;\\n        } else if(curr === \\')\\'){\\n            result = opStack.pop() * result + stack.pop();  \\n            sign = 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar calculate = function(s) {\\n    let result = 0, sign = 1;\\n    const stack = [], opStack = [];\\n    \\n    for(let i = 0; i < s.length; i++){\\n        const curr = s.charAt(i);\\n        if(curr === \\' \\'){ \\n            continue;\\n        } else if(curr === \\'+\\'){ \\n            sign = 1;\\n        } else if(curr === \\'-\\'){ \\n            sign = -1;\\n        } else if(curr >= \\'0\\' && curr <= \\'9\\'){\\n            let num = curr;\\n            while(i+1 < s.length && s.charAt(i+1) >= \\'0\\' && s.charAt(i+1) <= \\'9\\'){\\n                num += s.charAt(i+1);\\n                i++;\\n            }\\n            result += sign * parseInt(num);\\n        } else if(curr === \\'(\\'){\\n            stack.push(result);  \\n            result = 0;  \\n            opStack.push(sign);  \\n            sign = 1;\\n        } else if(curr === \\')\\'){\\n            result = opStack.pop() * result + stack.pop();  \\n            sign = 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 62443,
                "title": "simple-java-solution-with-recursion",
                "content": "        import java.util.*;\\n    \\n    public class Solution {\\n        public int calculate(String s) {\\n            return calc(new StringTokenizer(s, \" ()+-\", true));\\n        }\\n        \\n        int calc(StringTokenizer st){\\n            int sofar = 0;\\n            boolean plus = true; // last seen operator.\\n            while(st.hasMoreTokens()){\\n                int val =0;\\n                String next = st.nextToken();\\n                switch(next){\\n                    case \"(\":\\n                        val = calc(st);\\n                        sofar += (plus ?  val : -val);\\n                        break;\\n                    case \")\":\\n                        return sofar;\\n                    case \"+\":\\n                        plus = true;\\n                        break;\\n                    case \"-\":\\n                        plus = false;\\n                        break;\\n                    case \" \": // no-op\\n                        break;\\n                    default:\\n                        val = Integer.parseInt(next);\\n                        sofar += (plus ?  val : -val);\\n                        break;\\n                }\\n                \\n            }\\n            \\n            return sofar;\\n        }\\n    }\\n\\n\\nExplained: \\ncalc(), the working horse, is using a simple strategy: if \"(\" spotted, dive one level deeper in recursion. when it sees matching \")\", return with an integer value of expression between \"(...)\" . Each call of calc() handles expression within one pair of \"(...)\".\\n\\nWithin one pair of \"(..)\", generally there are only two cases: operator and operand. It's easy to handle them respectively. Slightly tricky thing is remembering last seen operator which is + or -.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public int calculate(String s) {\\n            return calc(new StringTokenizer(s, \" ()+-\", true));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3403529,
                "title": "self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimplest Iterative Approacg usubg Stack\\nThe code is itself self explanatory\\n# Code\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    int result = 0;\\n    int number = 0;\\n    int sign = 1;\\n    for(int i = 0; i < s.length(); i++){\\n        char c = s.charAt(i);\\n        if(Character.isDigit(c)){\\n            number = 10 * number + (int)(c - \\'0\\');\\n        }else if(c == \\'+\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = 1;\\n        }else if(c == \\'-\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = -1;\\n        }else if(c == \\'(\\'){\\n            //we push the result first, then sign;\\n            stack.push(result);\\n            stack.push(sign);\\n            //reset the sign and result for the value in the parenthesis\\n            sign = 1;   \\n            result = 0;\\n        }else if(c == \\')\\'){\\n            result += sign * number;  \\n            number = 0;\\n            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n            \\n        }\\n    }\\n    if(number != 0) result += sign * number;\\n    return result;\\n}\\n}\\n```\\n![471ac8c9-5c1b-4052-a76c-b8019c47bb11_1679937665.6666765.png](https://assets.leetcode.com/users/images/a268707f-dfc4-4df7-9595-d0db33e6f8b6_1681197417.9673645.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    int result = 0;\\n    int number = 0;\\n    int sign = 1;\\n    for(int i = 0; i < s.length(); i++){\\n        char c = s.charAt(i);\\n        if(Character.isDigit(c)){\\n            number = 10 * number + (int)(c - \\'0\\');\\n        }else if(c == \\'+\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = 1;\\n        }else if(c == \\'-\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = -1;\\n        }else if(c == \\'(\\'){\\n            //we push the result first, then sign;\\n            stack.push(result);\\n            stack.push(sign);\\n            //reset the sign and result for the value in the parenthesis\\n            sign = 1;   \\n            result = 0;\\n        }else if(c == \\')\\'){\\n            result += sign * number;  \\n            number = 0;\\n            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n            \\n        }\\n    }\\n    if(number != 0) result += sign * number;\\n    return result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429098,
                "title": "python3-solution-after-tokenization-60ms-beat-99-75",
                "content": "Please see and vote for my solutions for these similar problems\\n[224. Basic Calculator](https://leetcode.com/problems/basic-calculator/discuss/429098/Python3-solution-after-tokenization-(60ms-beat-99.75))\\n[227. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/discuss/429100/Python3-solution-after-tokenization-(56ms-beat-99.92))\\n[282. Expression Add Operators](https://leetcode.com/problems/expression-add-operators/discuss/310707/Clean-Python-DFS-solution)\\n[772. Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/discuss/429132/Python3-solution-after-tokenization-(40ms-beat-93.59))\\n\\n```\\n    def calculate(self, s):\\n        for ch in [\\'+\\', \\'-\\', \\'(\\', \\')\\']:\\n            s = s.replace(ch, \\' \\' + ch + \\' \\')\\n        sign = 1\\n        stack = [0]\\n        for token in s.split():\\n            if token in \\'+-\\':\\n                sign = 1 if token == \\'+\\' else -1\\n            elif token == \\'(\\':\\n                stack.extend([sign, 0])\\n                sign = 1\\n            elif token == \\')\\':\\n                value = stack.pop() * stack.pop()\\n                stack[-1] += value\\n            else:\\n                stack[-1] += sign * int(token)\\n        return stack[-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def calculate(self, s):\\n        for ch in [\\'+\\', \\'-\\', \\'(\\', \\')\\']:\\n            s = s.replace(ch, \\' \\' + ch + \\' \\')\\n        sign = 1\\n        stack = [0]\\n        for token in s.split():\\n            if token in \\'+-\\':\\n                sign = 1 if token == \\'+\\' else -1\\n            elif token == \\'(\\':\\n                stack.extend([sign, 0])\\n                sign = 1\\n            elif token == \\')\\':\\n                value = stack.pop() * stack.pop()\\n                stack[-1] += value\\n            else:\\n                stack[-1] += sign * int(token)\\n        return stack[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 62386,
                "title": "java-one-pass-recursion-method-3ms-beat-99",
                "content": "```\\npublic class Solution {\\n    public int calculate(String s) {\\n        if (s.length() == 0) return 0;\\n        return calculateHelper(s, 0, new int[]{s.length()});\\n    }\\n        \\n    private int calculateHelper(String s, int start, int[] end) {\\n        int sum = 0;\\n        int res = 0;\\n        char sign = '+';\\n        for (int i = start; i < end[0]; i++) {\\n            char temp = s.charAt(i);\\n            if (temp >= '0' && temp <= '9') {\\n                sum = sum * 10 + (temp - '0');\\n            }\\n            if (temp == '+' || temp == '-' || temp == ')' || i == end[0] - 1) {\\n                res = (sign == '+') ? res + sum : res - sum; \\n                if (temp != ')') sign = temp;\\n                sum = 0;\\n            }\\n            // Return condition for recursion\\n            if (temp == ')' || i == end[0] - 1) {\\n                end[0] = i;\\n                return res;\\n            }\\n            if (temp == '(') {\\n                int[] newEnd = {end[0]};\\n                sum = calculateHelper(s, i + 1, newEnd);\\n                if (newEnd[0] == end[0] - 1) {\\n                    res = (sign == '+') ? res + sum : res - sum; \\n                }\\n                i = newEnd[0]; // Set i to the last recursion end point\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int calculate(String s) {\\n        if (s.length() == 0) return 0;\\n        return calculateHelper(s, 0, new int[]{s.length()});\\n    }\\n        \\n    private int calculateHelper(String s, int start, int[] end) {\\n        int sum = 0;\\n        int res = 0;\\n        char sign = '+';\\n        for (int i = start; i < end[0]; i++) {\\n            char temp = s.charAt(i);\\n            if (temp >= '0' && temp <= '9') {\\n                sum = sum * 10 + (temp - '0');\\n            }\\n            if (temp == '+' || temp == '-' || temp == ')' || i == end[0] - 1) {\\n                res = (sign == '+') ? res + sum : res - sum; \\n                if (temp != ')') sign = temp;\\n                sum = 0;\\n            }\\n            // Return condition for recursion\\n            if (temp == ')' || i == end[0] - 1) {\\n                end[0] = i;\\n                return res;\\n            }\\n            if (temp == '(') {\\n                int[] newEnd = {end[0]};\\n                sum = calculateHelper(s, i + 1, newEnd);\\n                if (newEnd[0] == end[0] - 1) {\\n                    res = (sign == '+') ? res + sum : res - sum; \\n                }\\n                i = newEnd[0]; // Set i to the last recursion end point\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832718,
                "title": "python-faster-than-98-o-n-stack-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/96403984-e4da-4825-aacd-83323d7db386_1668934190.883803.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        output, curr, sign, stack = 0, 0, 1, []\\n        for c in s:\\n            if c.isdigit():\\n                curr = (curr * 10) + int(c)\\n            \\n            elif c in \\'+-\\':\\n                output += curr * sign\\n                curr = 0\\n                if c == \\'+\\':\\n                    sign = 1\\n\\n                else:\\n                    sign = -1\\n            \\n            elif c == \\'(\\':\\n                stack.append(output)\\n                stack.append(sign)\\n                sign = 1\\n                output = 0\\n            \\n            elif c == \\')\\':\\n                output += curr * sign\\n                output *= stack.pop()    #sign\\n                output += stack.pop()    #last output\\n                curr = 0\\n\\n        return output + (curr * sign)\\n```\\n# Please upvote if you find this helpful.",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        output, curr, sign, stack = 0, 0, 1, []\\n        for c in s:\\n            if c.isdigit():\\n                curr = (curr * 10) + int(c)\\n            \\n            elif c in \\'+-\\':\\n                output += curr * sign\\n                curr = 0\\n                if c == \\'+\\':\\n                    sign = 1\\n\\n                else:\\n                    sign = -1\\n            \\n            elif c == \\'(\\':\\n                stack.append(output)\\n                stack.append(sign)\\n                sign = 1\\n                output = 0\\n            \\n            elif c == \\')\\':\\n                output += curr * sign\\n                output *= stack.pop()    #sign\\n                output += stack.pop()    #last output\\n                curr = 0\\n\\n        return output + (curr * sign)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62446,
                "title": "java-solution-use-stack",
                "content": "    public int calculate(String s) {\\n        int res =0,val=0;\\n        int sign = 1;\\n        Stack<Integer> st = new Stack<Integer>();\\n        s.trim();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == '('){\\n                st.push(sign);\\n            }else if(s.charAt(i) == ')'){\\n                st.pop();\\n            }else if(s.charAt(i) == '+' || s.charAt(i) == '-'){\\n                res += sign*val;\\n                val = 0;\\n                if(!st.isEmpty()) {\\n                    sign = s.charAt(i) =='-'?st.peek()*(-1):st.peek();\\n                }else {\\n                    sign = s.charAt(i) =='-'?-1:1;\\n                }\\n            }else if(s.charAt(i) !=' '){\\n                val = val*10 + (s.charAt(i)-'0');\\n            }\\n        }\\n        res += val*sign;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public int calculate(String s) {\\n        int res =0,val=0;\\n        int sign = 1;\\n        Stack<Integer> st = new Stack<Integer>();\\n        s.trim();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == '('){\\n                st.push(sign);\\n            }else if(s.charAt(i) == ')'){\\n                st.pop();\\n            }else if(s.charAt(i) == '+' || s.charAt(i) == '-'){\\n                res += sign*val;\\n                val = 0;\\n                if(!st.isEmpty()) {\\n                    sign = s.charAt(i) =='-'?st.peek()*(-1):st.peek();\\n                }else {\\n                    sign = s.charAt(i) =='-'?-1:1;\\n                }\\n            }else if(s.charAt(i) !=' '){\\n                val = val*10 + (s.charAt(i)-'0');\\n            }\\n        }\\n        res += val*sign;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2579719,
                "title": "c-with-comments-stack-easy-solution",
                "content": "///\\n\\nclass Solution {\\npublic:\\n\\n    int stringTointeger(string str)   //To convert the given string into integer (since we don\\'t have to use any built-in function)\\n    {\\n        int sum = 0;\\n        for(int i = 0 ; i < str.length() ; i++)\\n        {\\n            sum = sum*10 + (str[i]-\\'0\\');\\n        }\\n        return sum;\\n    }\\n    \\n    int calculate(string s) {\\n        int num = 0, ans = 0 , i = 0, sign = 1;\\n        stack<int> st;\\n        \\n        while(i < s.length())\\n        {\\n            if(s[i] >= 48 && s[i] <= 57)   //if we encounter with any digit (0---9)\\n            {\\n                string number;\\n                while(s[i]>= 48 && s[i] <= 57)  // store the whole digit in a new string \\n                {\\n                    number += s[i];\\n                    i++;\\n                }\\n                i--;   // i will be one index forward after coming out from while loop, so we\\'ll decrement it to its right place\\n                num = stringTointeger(number);  // converting digit string to num \\n                num *= sign;                   // multiplying with sign and storing to ans\\n                ans += num;\\n            }\\n            \\n            else if(s[i] == \\'+\\')\\n                sign = 1;\\n            else if(s[i] == \\'-\\')\\n                sign = -1;\\n            else if(s[i] == \\'(\\')    // if we encounter this, we\\'ll push our current answer with its sign \\n            {                       // then we\\'ll consider new ans to be 0 and number to be positive and repeat the same steps\\n                st.push(ans);\\n                st.push(sign);\\n                ans = 0;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\')\\')  // when the whole bracket is done , we\\'ll multiplty it with previous num sign stored in stack \\n            {                     // and then adding the previous ans to our current ans \\n                ans *= st.top();\\n                st.pop();\\n                ans += st.top();\\n                st.pop();\\n            }\\n            i++;\\n        }\\n      return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int stringTointeger(string str)   //To convert the given string into integer (since we don\\'t have to use any built-in function)\\n    {\\n        int sum = 0;\\n        for(int i = 0 ; i < str.length() ; i++)\\n        {\\n            sum = sum*10 + (str[i]-\\'0\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1488171,
                "title": "explaining-transform-to-chessboard-c",
                "content": "**The key idea is:**\\nIf the grid has a solution, we can arrive at the solution by looking only at the first row and the first column. This happens because each solution step moves the entire row or entire column.\\n\\n**How to know if the table has a solution?**\\nThe dimensions are dependent, so we need to check that when correcting the first row or first column, the values in the middle of the table are resolved too.\\n\\nThe code below shows how we analyze this:\\n```c++\\nfor (int i=1; i<board.size(); i++) {\\n    for (int j=1; j<board[i].size(); j++) {\\n        if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n            return -1;\\n        }\\n    }\\n}\\n```\\n\\nThis code compares whether the middle value has the same parity with the edge values.\\n\\n[![Image from Gyazo](https://i.gyazo.com/1dc9dbe67d99ded468cd73efb0a2a03e.png)](https://gyazo.com/1dc9dbe67d99ded468cd73efb0a2a03e)\\n\\n- if the blue cells have different values, the green cells must also have different values.\\n- if blue cells have equal values, green cells must also have equal values.\\n\\nIf neither of the above two conditions are true, we have a table that is impossible to solve. \\nThis looks like magic right? Let\\'s look at the solved table:\\n<p>\\n<img src=\"https://i.gyazo.com/f3e3ee7360a38024e12ef928fef72cc9.png\" width=\"30%\">\\n</p>\\n\\nBetween two adjacent lines, one is the conjugate of the other and the same applies for columns. When we swap a row or a column from an solved table, we have two scenarios:\\n\\n1. Swap identical row or collumn\\n2. Swap conjugated row or collumn\\n\\nNo matter how many operations you do, we will always fall into these two scenarios. In summary, the code above checks if the current table has this property.\\n\\nBefore calculating the number of steps to reach the solution. We need to do one more validation, this one is much simpler.\\n\\nThis validation consists of counting the number of 1s and 0s in the first row and in the first column:\\n```c++\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i]) onesInFirstRow++;\\n\\telse zerosInFirstRow++;\\n\\n\\tif (board[i][0]) onesInFirstCol++;\\n\\telse zerosInFirstCol++;\\n}\\n\\nif (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\nif (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n```\\n\\n- If the difference between zeros and ones is greater than 1, it\\'s impossible solve this table.\\n\\n\\nNow to calculate the minimum number of steps, we need to solve the first column and the first row individually and sum each result.\\n\\n**Solving to first row and column**\\n\\nTo solve this, we have two scenarios:\\n1. N even\\n2. N odd\\n\\nWhen N is even, we have two solutions:\\n\\n- **[0,1,...,0,1]** (starting with 0)\\n- **[1,0,...,1,0]** (starting with 1)\\n\\n\\nWe know that each swap can fix two elements as we can see in the example below:\\n\\n- **[0,0,1,1]**  --> **[0,1,0,1]**  (swap second with third item)\\n\\nSo, the number of moviments needed to transform a row or a collumn to any two possible solution is:\\n\\n- number of wrong elements divided by 2\\n\\nAs one solution is the inverse of the other, we can say that:\\n\\n- **solution_start_one** = N - **solution_start_zero**\\n\\nTherefore, when N is even, the answer will be the smallest value between the two possible solutions.\\n\\n```c++\\n// This for compare the first row and column \\n// with the solution that starts with one\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i] == i%2) rowMovesNeeded++;\\n\\tif (board[i][0] == i%2) colMovesNeeded++;\\n} \\n\\nif (N % 2 == 0) {\\n\\tcolMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n\\trowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n\\t\\n\\treturn (colMovesNeeded + rowMovesNeeded) / 2;\\n} \\n\\n// solve when N is odd\\n```\\n\\nWhen N is odd, we have only one solution:\\n\\n- **[1,0,..,0,1]** (when the row or column has more ones)\\n- **[0,1,..,1,0]** (when the row or column has more zeros)\\n\\nIf we have more zeros, we only use the value to solution that begin with zero. So with odd N we need analyze the number of zeros and use the correct solution to each case.\\n\\n```c++\\nif (onesInFirstCol < zerosInFirstCol) {\\n\\tcolMovesNeeded = N - colMovesNeeded;\\n}\\n\\nif (onesInFirstRow < zerosInFirstRow) {\\n\\trowMovesNeeded = N - rowMovesNeeded;\\n}\\n\\nreturn (colMovesNeeded + rowMovesNeeded) / 2;\\n```\\n\\nThe code for this question is quite simple, but the idea behind it is quite complex. I really enjoyed the insights that this problem required.\\n\\nThe final code is:\\n```c++\\nclass Solution {\\npublic:\\n\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int N = board.size();\\n        int colMovesNeeded = 0, rowMovesNeeded = 0;\\n        int onesInFirstCol = 0, onesInFirstRow = 0;\\n        int zerosInFirstCol = 0, zerosInFirstRow = 0;\\n\\n        for (int i=1; i<board.size(); i++) {\\n            for (int j=1; j<board[i].size(); j++) {\\n                if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i]) onesInFirstRow++;\\n            else zerosInFirstRow++;\\n            \\n            if (board[i][0]) onesInFirstCol++;\\n            else zerosInFirstCol++;\\n        }\\n        \\n        if (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\n        if (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i] == i%2) rowMovesNeeded++;\\n            if (board[i][0] == i%2) colMovesNeeded++;\\n        }    \\n        \\n        \\n        if (N % 2 == 1) {\\n            \\n            if (onesInFirstCol < zerosInFirstCol) {\\n                colMovesNeeded = N - colMovesNeeded;\\n            }\\n            \\n            if (onesInFirstRow < zerosInFirstRow) {\\n                rowMovesNeeded = N - rowMovesNeeded;\\n            }\\n            \\n        } else {\\n            colMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n            rowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n        }\\n        \\n\\n        \\n        return (colMovesNeeded + rowMovesNeeded) / 2;\\n    }\\n};\\n```\\nI am sorry for my english. I\\'m just a young brazilian boy trying to help this community.",
                "solutionTags": [],
                "code": "```c++\\nfor (int i=1; i<board.size(); i++) {\\n    for (int j=1; j<board[i].size(); j++) {\\n        if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n            return -1;\\n        }\\n    }\\n}\\n```\n```c++\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i]) onesInFirstRow++;\\n\\telse zerosInFirstRow++;\\n\\n\\tif (board[i][0]) onesInFirstCol++;\\n\\telse zerosInFirstCol++;\\n}\\n\\nif (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\nif (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n```\n```c++\\n// This for compare the first row and column \\n// with the solution that starts with one\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i] == i%2) rowMovesNeeded++;\\n\\tif (board[i][0] == i%2) colMovesNeeded++;\\n} \\n\\nif (N % 2 == 0) {\\n\\tcolMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n\\trowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n\\t\\n\\treturn (colMovesNeeded + rowMovesNeeded) / 2;\\n} \\n\\n// solve when N is odd\\n```\n```c++\\nif (onesInFirstCol < zerosInFirstCol) {\\n\\tcolMovesNeeded = N - colMovesNeeded;\\n}\\n\\nif (onesInFirstRow < zerosInFirstRow) {\\n\\trowMovesNeeded = N - rowMovesNeeded;\\n}\\n\\nreturn (colMovesNeeded + rowMovesNeeded) / 2;\\n```\n```c++\\nclass Solution {\\npublic:\\n\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int N = board.size();\\n        int colMovesNeeded = 0, rowMovesNeeded = 0;\\n        int onesInFirstCol = 0, onesInFirstRow = 0;\\n        int zerosInFirstCol = 0, zerosInFirstRow = 0;\\n\\n        for (int i=1; i<board.size(); i++) {\\n            for (int j=1; j<board[i].size(); j++) {\\n                if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i]) onesInFirstRow++;\\n            else zerosInFirstRow++;\\n            \\n            if (board[i][0]) onesInFirstCol++;\\n            else zerosInFirstCol++;\\n        }\\n        \\n        if (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\n        if (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i] == i%2) rowMovesNeeded++;\\n            if (board[i][0] == i%2) colMovesNeeded++;\\n        }    \\n        \\n        \\n        if (N % 2 == 1) {\\n            \\n            if (onesInFirstCol < zerosInFirstCol) {\\n                colMovesNeeded = N - colMovesNeeded;\\n            }\\n            \\n            if (onesInFirstRow < zerosInFirstRow) {\\n                rowMovesNeeded = N - rowMovesNeeded;\\n            }\\n            \\n        } else {\\n            colMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n            rowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n        }\\n        \\n\\n        \\n        return (colMovesNeeded + rowMovesNeeded) / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456881,
                "title": "basic-calculator-with-explanation-stack",
                "content": "We know that things in the parentheses should be on higher priority. \\nHere, we need to calculate the numbers on the same level. Whenever we see a `(`, put the intermediate result into the stack, and start new calculation right after this `(`. When we see a `)`, pop the add/minus the result with the last item in the stack.\\n\\nWe need to pay attention to 5 possible inputs\\n\\n- digit: it should be one digit from the current number and consecutive digits forms sum\\n-  `+`: set the sign to 1;\\n-  `-`: set the sgin to -1\\n-  `(`: push the previous result and the sign into the stack, set result to 0, just calculate the new result within the parenthesis.\\n- `)`: pop out the top two numbers from stack, first one is the sign before this pair of parenthesis, second is the temporary result before this pair of parenthesis. We add them together.\\n\\n***Java Solution***\\n```\\nint len = s.length(), sign = 1, result = 0;\\nStack<Integer> stack = new Stack<Integer>();\\nfor (int i = 0; i < len; i++) {\\n\\tif (Character.isDigit(s.charAt(i))) {\\n\\t\\tint sum = s.charAt(i) - \\'0\\';\\n\\t\\twhile (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n\\t\\t\\tsum = sum * 10 + s.charAt(i + 1) - \\'0\\';\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tresult += sum * sign;\\n\\t} else if (s.charAt(i) == \\'+\\')\\n\\t\\tsign = 1;\\n\\telse if (s.charAt(i) == \\'-\\')\\n\\t\\tsign = -1;\\n\\telse if (s.charAt(i) == \\'(\\') {\\n\\t\\tstack.push(result);\\n\\t\\tstack.push(sign);\\n\\t\\tresult = 0;\\n\\t\\tsign = 1;\\n\\t} else if (s.charAt(i) == \\')\\') {\\n\\t\\tresult = result * stack.pop() + stack.pop();\\n\\t}\\n\\n}\\nreturn result;\\n```\\n\\n___\\n\\n***Python Solution***\\n```\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        stack = []\\n        # 1 means positive, -1 means negative\\n        # we declare it as an integer because we want to put the +- in the stack too\\n        sign = 1\\n        num = 0\\n        i = 0\\n        while i < len(s):\\n            if s[i].isdigit():\\n                # construct a multi-digits number if any, e.g. \"23\" = 2*10+3 = 23\\n                j = i\\n                num = 0\\n                while j < len(s) and s[j].isdigit():\\n                    num = num*10 + int(s[j])\\n                    j += 1\\n                # sum up the intermediate result\\n                res += sign * num\\n                i = j\\n            elif s[i] == \\'+\\':\\n                # the next number will be using +\\n                sign = 1\\n                i += 1\\n            elif s[i] == \\'-\\':\\n                # the next number will be using -\\n                sign = -1\\n                i += 1\\n            elif s[i] == \\'(\\':\\n                # put the intermediate result(from the front) and sign into the stack\\n                stack.append(res)\\n                stack.append(sign)\\n                # since we have put the intermediate result in stack,\\n                # we can reset the things for calculation starting from this (\\n                res = 0\\n                sign = 1\\n                i += 1\\n            elif s[i] == \\')\\':\\n                # last item is the sign we saved for calculation e.g. 1+(2+3) the 1st +\\n                sign = stack.pop()\\n                # previousLevelResult the intermediate result before this level, (xxx)\\n                previousLevelResult = stack.pop()\\n                # sign*res is the result within the current (xxx)\\n                res = previousLevelResult + sign * res\\n                i += 1\\n            else:\\n                i += 1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Stack"
                ],
                "code": "```\\nint len = s.length(), sign = 1, result = 0;\\nStack<Integer> stack = new Stack<Integer>();\\nfor (int i = 0; i < len; i++) {\\n\\tif (Character.isDigit(s.charAt(i))) {\\n\\t\\tint sum = s.charAt(i) - \\'0\\';\\n\\t\\twhile (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n\\t\\t\\tsum = sum * 10 + s.charAt(i + 1) - \\'0\\';\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tresult += sum * sign;\\n\\t} else if (s.charAt(i) == \\'+\\')\\n\\t\\tsign = 1;\\n\\telse if (s.charAt(i) == \\'-\\')\\n\\t\\tsign = -1;\\n\\telse if (s.charAt(i) == \\'(\\') {\\n\\t\\tstack.push(result);\\n\\t\\tstack.push(sign);\\n\\t\\tresult = 0;\\n\\t\\tsign = 1;\\n\\t} else if (s.charAt(i) == \\')\\') {\\n\\t\\tresult = result * stack.pop() + stack.pop();\\n\\t}\\n\\n}\\nreturn result;\\n```\n```\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        stack = []\\n        # 1 means positive, -1 means negative\\n        # we declare it as an integer because we want to put the +- in the stack too\\n        sign = 1\\n        num = 0\\n        i = 0\\n        while i < len(s):\\n            if s[i].isdigit():\\n                # construct a multi-digits number if any, e.g. \"23\" = 2*10+3 = 23\\n                j = i\\n                num = 0\\n                while j < len(s) and s[j].isdigit():\\n                    num = num*10 + int(s[j])\\n                    j += 1\\n                # sum up the intermediate result\\n                res += sign * num\\n                i = j\\n            elif s[i] == \\'+\\':\\n                # the next number will be using +\\n                sign = 1\\n                i += 1\\n            elif s[i] == \\'-\\':\\n                # the next number will be using -\\n                sign = -1\\n                i += 1\\n            elif s[i] == \\'(\\':\\n                # put the intermediate result(from the front) and sign into the stack\\n                stack.append(res)\\n                stack.append(sign)\\n                # since we have put the intermediate result in stack,\\n                # we can reset the things for calculation starting from this (\\n                res = 0\\n                sign = 1\\n                i += 1\\n            elif s[i] == \\')\\':\\n                # last item is the sign we saved for calculation e.g. 1+(2+3) the 1st +\\n                sign = stack.pop()\\n                # previousLevelResult the intermediate result before this level, (xxx)\\n                previousLevelResult = stack.pop()\\n                # sign*res is the result within the current (xxx)\\n                res = previousLevelResult + sign * res\\n                i += 1\\n            else:\\n                i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327015,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n = s.size();\\n        stack<int> stk;\\n        int sum=0,sign=1;\\n        \\n        for(int i=0;i<n;++i){\\n            char ch = s[i];\\n            if(isdigit(ch)){\\n                int val=0;\\n                while(i<n && isdigit(s[i])){\\n                    val = val*10 + (s[i]-\\'0\\');\\n                    ++i;\\n                }\\n                --i;\\n                val *= sign;\\n                sum += val;\\n                sign = 1;\\n            }else if(ch==\\'(\\'){\\n                stk.push(sum);\\n                stk.push(sign);\\n                sum=0;\\n                sign = 1;\\n            }else if(ch==\\')\\'){\\n                sum *= stk.top(); stk.pop();\\n                sum += stk.top(); stk.pop();\\n            }else if(ch==\\'-\\'){\\n                sign = -1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n = s.size();\\n        stack<int> stk;\\n        int sum=0,sign=1;\\n        \\n        for(int i=0;i<n;++i){\\n            char ch = s[i];\\n            if(isdigit(ch)){\\n                int val=0;\\n                while(i<n && isdigit(s[i])){\\n                    val = val*10 + (s[i]-\\'0\\');\\n                    ++i;\\n                }\\n                --i;\\n                val *= sign;\\n                sum += val;\\n                sign = 1;\\n            }else if(ch==\\'(\\'){\\n                stk.push(sum);\\n                stk.push(sign);\\n                sum=0;\\n                sign = 1;\\n            }else if(ch==\\')\\'){\\n                sum *= stk.top(); stk.pop();\\n                sum += stk.top(); stk.pop();\\n            }else if(ch==\\'-\\'){\\n                sign = -1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142162,
                "title": "beats-100-stack-recursion-java-scala-python",
                "content": "It is inductive to loop through `s` and take action according to the current character.\\n* **Common ground** for both solutions \\nWhenever we meet `\\'+\\'` or `\\'-\\'`, we update current `curSign`.\\nWhenever we meet `\\' \\'`, we do nothing but move on.\\nWhenever we meet a number, we update current `result`.\\n* **Difference** between two solutions lies in how to do with contents between the parenthesis.\\n**Solution using stack**: \\nWhen we meet `\\'(\\'`, `stack.push(result); stack.push(curSign);`\\nWhen we meet `\\')\\'`, `result = stack.pop() * result + stack.pop();`.\\n**Solution using Recursion**: \\nWhen we meet `\\'(\\'`, `result += curSign * calculateAfter(s);`\\nWhen we meet `\\')\\'`, `return result` to terminate current recursion.\\nPlase note that the problem shares the same structure with its subproblems - evaluate expression within the parenthesis. There are two types of base cases - `i == s.length()` for the outmost recursion, `case \\')\\'` for inner recursion layers.\\n> Java\\n\\n**Using Stack**\\n```\\n    public int calculate(String s) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int i = 0, curSign = 1, curNum = 0, result = 0;\\n        \\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            switch(ch) {\\n                case \\' \\':\\n                    break;\\n                case \\'+\\':\\n                    curSign = 1;\\n                    break;\\n                case \\'-\\':\\n                    curSign = -1;\\n                    break;\\n                case \\'(\\':\\n                    stack.push(result);\\n                    stack.push(curSign);\\n                    result = 0;\\n                    curSign = 1;\\n                    break;\\n                case \\')\\':\\n                    result = stack.pop() * result + stack.pop();\\n                    break;\\n                default:\\n                    int num = ch - \\'0\\';\\n                    while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {\\n                        num = num * 10 + s.charAt(++i) - \\'0\\';\\n                    }\\n                    curNum = num;\\n                    result += curSign * curNum;\\n            } \\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\n**Recursion**\\n```\\n    private static int i;\\n    \\n    public int calculate(String s) {\\n        i = 0;\\n        return calculateAfter(s);\\n    }\\n    \\n    private int calculateAfter(String s) {\\n        // Base case.\\n        if (i == s.length()) \\n            return 0;\\n        \\n        int curSign = 1, curNum = 0, result = 0;\\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            switch(ch) {\\n                case \\' \\':\\n                    break;\\n                case \\'+\\':\\n                    curSign = 1;\\n                    break;\\n                case \\'-\\':\\n                    curSign = -1;\\n                    break;\\n                case \\'(\\':\\n                    i++;\\n                    result += curSign * calculateAfter(s);\\n                    curSign = 1;\\n                    break;\\n                case \\')\\':\\n                    // Base case.\\n                    return result;\\n                default:\\n                    int num = ch - \\'0\\';\\n                    while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {\\n                        num = num * 10 + s.charAt(++i) - \\'0\\';\\n                    }\\n                    curNum = num;\\n                    result += curSign * curNum;\\n            } \\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n```\\n> Scala\\n```\\n    def calculate(s: String): Int = {\\n        var i = 0\\n        \\n        def evaluate(s: String): Int = {\\n            var curSign = 1 // 1 if plus operator, -1 if minus operator.\\n            var curResult = 0 \\n            \\n            while (i < s.length()) {\\n                s(i) match {\\n                    case \\'+\\' => curSign = 1\\n                    case \\'-\\' => curSign = -1\\n                    case \\' \\' => \\n                    case \\'(\\' => {\\n                        i += 1\\n                        curResult += curSign * evaluate(s)\\n                        curSign = 1\\n                    }\\n                    case \\')\\' => return curResult\\n                    case _ => { // If s(i) is a digit.\\n                        // Get the current whole number.\\n                        var curNum = s(i) - \\'0\\' \\n                        while (i + 1 < s.length() && Character.isDigit(s(i + 1))) {\\n                            curNum = curNum * 10 +  s(i + 1) - \\'0\\'\\n                            i += 1\\n                        }\\n                        \\n                        curResult += curSign * curNum \\n                        curSign = 1\\n                    }\\n                }\\n                \\n                i += 1\\n            }\\n            \\n            return curResult\\n        }\\n        \\n        evaluate(s)\\n    }\\n```\\n> Python\\n```\\n    def calculate(self, s):\\n  \\n      def evaluation(s):\\n        nonlocal i\\n        curSign, curResult = 1, 0\\n        \\n        while i < len(s):\\n          if s[i] == \\' \\': \\n            i += 1\\n            continue\\n          elif s[i] == \\'+\\':\\n            curSign = 1\\n          elif s[i] == \\'-\\':\\n            curSign = -1\\n          elif s[i] == \\'(\\':\\n            i += 1\\n            curResult += curSign * evaluation(s)\\n            curSign = 1\\n          elif s[i] == \\')\\':\\n            return curResult\\n          else:  # s[i] is digit.\\n            curNum = int(s[i])\\n            while i + 1 < len(s) and s[i + 1].isdigit():\\n              curNum = curNum * 10 + int(s[i + 1])\\n              i += 1\\n            curResult += curNum * curSign\\n            curSign = 1\\n          i += 1\\n          \\n        return curResult\\n      \\n      i = 0\\n      return evaluation(s)\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public int calculate(String s) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int i = 0, curSign = 1, curNum = 0, result = 0;\\n        \\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            switch(ch) {\\n                case \\' \\':\\n                    break;\\n                case \\'+\\':\\n                    curSign = 1;\\n                    break;\\n                case \\'-\\':\\n                    curSign = -1;\\n                    break;\\n                case \\'(\\':\\n                    stack.push(result);\\n                    stack.push(curSign);\\n                    result = 0;\\n                    curSign = 1;\\n                    break;\\n                case \\')\\':\\n                    result = stack.pop() * result + stack.pop();\\n                    break;\\n                default:\\n                    int num = ch - \\'0\\';\\n                    while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {\\n                        num = num * 10 + s.charAt(++i) - \\'0\\';\\n                    }\\n                    curNum = num;\\n                    result += curSign * curNum;\\n            } \\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n```\n```\\n    private static int i;\\n    \\n    public int calculate(String s) {\\n        i = 0;\\n        return calculateAfter(s);\\n    }\\n    \\n    private int calculateAfter(String s) {\\n        // Base case.\\n        if (i == s.length()) \\n            return 0;\\n        \\n        int curSign = 1, curNum = 0, result = 0;\\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            switch(ch) {\\n                case \\' \\':\\n                    break;\\n                case \\'+\\':\\n                    curSign = 1;\\n                    break;\\n                case \\'-\\':\\n                    curSign = -1;\\n                    break;\\n                case \\'(\\':\\n                    i++;\\n                    result += curSign * calculateAfter(s);\\n                    curSign = 1;\\n                    break;\\n                case \\')\\':\\n                    // Base case.\\n                    return result;\\n                default:\\n                    int num = ch - \\'0\\';\\n                    while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {\\n                        num = num * 10 + s.charAt(++i) - \\'0\\';\\n                    }\\n                    curNum = num;\\n                    result += curSign * curNum;\\n            } \\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n```\n```\\n    def calculate(s: String): Int = {\\n        var i = 0\\n        \\n        def evaluate(s: String): Int = {\\n            var curSign = 1 // 1 if plus operator, -1 if minus operator.\\n            var curResult = 0 \\n            \\n            while (i < s.length()) {\\n                s(i) match {\\n                    case \\'+\\' => curSign = 1\\n                    case \\'-\\' => curSign = -1\\n                    case \\' \\' => \\n                    case \\'(\\' => {\\n                        i += 1\\n                        curResult += curSign * evaluate(s)\\n                        curSign = 1\\n                    }\\n                    case \\')\\' => return curResult\\n                    case _ => { // If s(i) is a digit.\\n                        // Get the current whole number.\\n                        var curNum = s(i) - \\'0\\' \\n                        while (i + 1 < s.length() && Character.isDigit(s(i + 1))) {\\n                            curNum = curNum * 10 +  s(i + 1) - \\'0\\'\\n                            i += 1\\n                        }\\n                        \\n                        curResult += curSign * curNum \\n                        curSign = 1\\n                    }\\n                }\\n                \\n                i += 1\\n            }\\n            \\n            return curResult\\n        }\\n        \\n        evaluate(s)\\n    }\\n```\n```\\n    def calculate(self, s):\\n  \\n      def evaluation(s):\\n        nonlocal i\\n        curSign, curResult = 1, 0\\n        \\n        while i < len(s):\\n          if s[i] == \\' \\': \\n            i += 1\\n            continue\\n          elif s[i] == \\'+\\':\\n            curSign = 1\\n          elif s[i] == \\'-\\':\\n            curSign = -1\\n          elif s[i] == \\'(\\':\\n            i += 1\\n            curResult += curSign * evaluation(s)\\n            curSign = 1\\n          elif s[i] == \\')\\':\\n            return curResult\\n          else:  # s[i] is digit.\\n            curNum = int(s[i])\\n            while i + 1 < len(s) and s[i + 1].isdigit():\\n              curNum = curNum * 10 + int(s[i + 1])\\n              i += 1\\n            curResult += curNum * curSign\\n            curSign = 1\\n          i += 1\\n          \\n        return curResult\\n      \\n      i = 0\\n      return evaluation(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 62346,
                "title": "c-13ms-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int>stk, op;\\n        int res = 0, sign = 1;\\n        for(int i = 0; i < s.size(); i++){\\n            char c = s[i];\\n            if(isdigit(c)){\\n                int num = c - '0';\\n                while(i + 1 < s.size() && isdigit(s[i + 1])){\\n                    num = num * 10 + s[i + 1] - '0';\\n                    i++;\\n                }\\n                res += num * sign;\\n            }\\n            else if(c == '+') sign = 1;\\n            else if(c == '-') sign = -1;\\n            else if(c == '('){\\n                stk.push(res);\\n                op.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if(c == ')'){\\n                res = res * op.top();\\n                op.pop();\\n                res += stk.top();\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int>stk, op;\\n        int res = 0, sign = 1;\\n        for(int i = 0; i < s.size(); i++){\\n            char c = s[i];\\n            if(isdigit(c)){\\n                int num = c - '0';\\n                while(i + 1 < s.size() && isdigit(s[i + 1])){\\n                    num = num * 10 + s[i + 1] - '0';\\n                    i++;\\n                }\\n                res += num * sign;\\n            }\\n            else if(c == '+') sign = 1;\\n            else if(c == '-') sign = -1;\\n            else if(c == '('){\\n                stk.push(res);\\n                op.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if(c == ')'){\\n                res = res * op.top();\\n                op.pop();\\n                res += stk.top();\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62472,
                "title": "detailed-explained-easy-java-general-solution-using-reverse-polish-notation",
                "content": "Basic idea: parse the given regular expression by an order of reverse polish notation and calculate while parsing.\\n\\nSteps:\\n\\n 1. Use two stack to store operators and values(name: \"operator\" and \"result\").\\n 2. Use one map to define the priority of operators.\\n 3. Use \"#\" as an ending indicator, push \"#\" to operator and add it to the given string in the end.\\n 4. Scan the given string character by charcter.\\n\\n    4.1 If the current character is a digit, continue to retrive the whole\\n    number and push it to \"result\" stack. \\n\\n    4.2 if the current character is an operator(call it holding operator here), compare the holding operator with the top operator in \"operator\" stack by priority defined in the map. Keep popping the operator from stack until the holding operator's priority is less than the current one's. Send the popped operators to result stack to activiate calculation by their popped order. Then push the holding operator to \"operator\" stack.\\n \\n    4.3 If the current character is '(', push it to \"operator\" stack;\\n        \\n       4.4 if the current character is ')', keep popping the operators in \"operator\" stack until ')' occurs, leave both parenthesis and\\n    send all popped operators to result stack to activate calculation by\\n    their popped order.\\n    \\n       4.5 Repeat 4.1~4.4 until a \"#\" is scanned, then pop out all operators in \"operator\" stack and send them to calculation until # occurred.\\n\\n 5. Return what left in \"result\" stack. And this solution can be used not only for + and -, but also for almost all operators included, as long as priority order is defined.\\n\\n \\n\\n\\n\\n\\n\\npublic class Solution {\\n\\n    public int calculate(String s) {\\n\\n        Stack<Character> operator = new Stack<Character>();\\n\\t\\tStack<Integer> result = new Stack<Integer>();\\n\\n\\t\\tHashMap<Character, Integer> priority = new HashMap<Character, Integer>() {\\n\\t\\t\\t{\\n\\t\\t\\t\\tput('#', 0);\\n\\t\\t\\t\\tput('+', 1);\\n\\t\\t\\t\\tput('-', 1);\\n\\t\\t\\t\\tput('*', 2);\\n\\t\\t\\t\\tput('/', 2);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\ts = s.replace(\" \", \"\");\\n\\n\\t\\ts = s + '#';\\n\\t\\toperator.push('#');\\n\\n\\t\\tint i = 0;\\n\\n\\t\\twhile (i < s.length()) {\\n\\t\\t\\t\\n\\t\\t\\tif (Character.isDigit(s.charAt(i))) {\\n\\t\\t\\t\\tint j = i + 1;\\n\\t\\t\\t\\twhile (j < s.length()) {\\n\\t\\t\\t\\t\\tif (!Character.isDigit(s.charAt(j)))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult.push(Integer.parseInt(s.substring(i, j)));\\n\\t\\t\\t\\ti = j;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tswitch (s.charAt(i)) {\\n\\t\\t\\t\\tcase ('('): {\\n\\t\\t\\t\\t\\toperator.push('(');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcase (')'): {\\n\\n\\t\\t\\t\\t\\tchar temp = operator.pop();\\n\\t\\t\\t\\t\\twhile (temp != '(') {\\n\\t\\t\\t\\t\\t\\tcalculate(temp, result);\\n\\t\\t\\t\\t\\t\\ttemp = operator.pop();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcase ('#'): {\\n\\n\\t\\t\\t\\t\\twhile (!operator.isEmpty())\\n\\t\\t\\t\\t\\t\\tcalculate(operator.pop(), result);\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdefault: {\\n\\t\\t\\t\\t\\tchar current = operator.pop();\\n\\t\\t\\t\\t\\tchar holding = s.charAt(i);\\n\\t\\t\\t\\t\\twhile (current !='(' && priority.get(holding) <= priority.get(current)) {\\n\\t\\t\\t\\t\\t\\tcalculate(current, result);\\n\\t\\t\\t\\t\\t\\tcurrent = operator.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\toperator.push(current);\\n\\t\\t\\t\\t\\toperator.push(holding);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result.pop();\\n\\t}\\n\\n\\tprivate void calculate(char operator, Stack<Integer> s) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tint temp;\\n\\t\\tswitch (operator) {\\n\\t\\tcase '+': {\\n\\t\\t\\ttemp = s.pop();\\n\\t\\t\\ts.push(s.pop() + temp);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tcase '-': {\\n\\t\\t\\ttemp = s.pop();\\n\\t\\t\\ts.push(s.pop() - temp);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tcase '*': {\\n\\t\\t\\ttemp = s.pop();\\n\\t\\t\\ts.push(s.pop() * temp);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tcase '/': {\\n\\t\\t\\ttemp = s.pop();\\n\\t\\t\\ts.push(s.pop() / temp);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tdefault:\\n\\t\\t\\tbreak;\\n\\t\\t}\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int calculate(String s) {\\n\\n        Stack<Character> operator = new Stack<Character>();\\n\\t\\tStack<Integer> result = new Stack<Integer>();\\n\\n\\t\\tHashMap<Character, Integer> priority = new HashMap<Character, Integer>() {\\n\\t\\t\\t{\\n\\t\\t\\t\\tput('#', 0);\\n\\t\\t\\t\\tput('+', 1);\\n\\t\\t\\t\\tput('-', 1);\\n\\t\\t\\t\\tput('*', 2);\\n\\t\\t\\t\\tput('/', 2);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4011331,
                "title": "beats-75-easy-java-solution-using-stack-with-detailed-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a stack st to store intermediate results during the evaluation.\\n2. Initialize variables ans (to store the final result), num (to accumulate the current number being processed), and sign (to track the current sign, which can be either 1 or -1).\\n3. Iterate through each character of the input string s using a for loop.\\n4. For each character c in the input string:\\n- If c is a digit, accumulate it into the num variable. This is done to handle multi-digit numbers.\\n- If c is a + sign, it indicates an addition operation. Add sign * num to the ans, reset num to 0, and set sign to 1.\\n- If c is a - sign, it indicates a subtraction operation. Add sign * num to the ans, reset num to 0, and set sign to -1.\\n- If c is an open parenthesis (, it indicates the start of a subexpression. Push the current ans and sign onto the stack to save the context. Reset ans to 0 and set sign to 1 for the new subexpression.\\n- If c is a closing parenthesis ), it indicates the end of a subexpression. First, add sign * num to ans to calculate the result within the parentheses. Then, multiply the result by the last saved sign value from the stack and add it to the last saved result value from the stack.\\n5. After processing all characters in the input string, if num is not zero, add sign * num to ans to handle any remaining number.\\n6. Finally, return the value of ans, which represents the result of evaluating the mathematical expression.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        Stack<Integer> st=new Stack();\\n        int ans=0,num=0,sign=1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(Character.isDigit(c))\\n                num=num*10+(int)(c-\\'0\\');\\n            else if(c==\\'+\\'){\\n                ans+=sign*num;\\n                num=0;\\n                sign=1;\\n            }\\n            else if(c==\\'-\\'){\\n                ans+=sign*num;\\n                num=0;\\n                sign=-1;              \\n            }\\n            else if(c==\\'(\\'){\\n                st.push(ans);\\n                st.push(sign);\\n                sign=1;\\n                ans=0;\\n            }\\n            else if(c==\\')\\'){\\n                ans+=sign*num;\\n                num=0;\\n                ans*=st.pop();\\n                ans+=st.pop();\\n            }\\n        }\\n        if(num!=0)\\n            ans+=sign*num;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        Stack<Integer> st=new Stack();\\n        int ans=0,num=0,sign=1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(Character.isDigit(c))\\n                num=num*10+(int)(c-\\'0\\');\\n            else if(c==\\'+\\'){\\n                ans+=sign*num;\\n                num=0;\\n                sign=1;\\n            }\\n            else if(c==\\'-\\'){\\n                ans+=sign*num;\\n                num=0;\\n                sign=-1;              \\n            }\\n            else if(c==\\'(\\'){\\n                st.push(ans);\\n                st.push(sign);\\n                sign=1;\\n                ans=0;\\n            }\\n            else if(c==\\')\\'){\\n                ans+=sign*num;\\n                num=0;\\n                ans*=st.pop();\\n                ans+=st.pop();\\n            }\\n        }\\n        if(num!=0)\\n            ans+=sign*num;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832688,
                "title": "c-recuesion-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int idx = 0;\\n        return helper(s,idx);      \\n    }\\n\\n    int helper(string s, int& idx) {\\n        int res = 0;\\n        int sign = 1; // \\'+\\'=1, \\'-\\'=-1\\n        int number = 0;\\n        \\n        for(;idx<s.size(); idx++){\\n            char x=s[idx]; //current char\\n\\n            if(x==\\' \\') continue;\\n            else if(x==\\'+\\'||x==\\'-\\') {\\n                res+= sign*(number);\\n                number=0;\\n                sign = (x==\\'+\\')?1:-1;\\n            }\\n            else if(x==\\'(\\') res += sign*helper(s, ++idx);\\n            else if(x==\\')\\') break;\\n            else number = number*10+(x-\\'0\\');\\n        }  \\n        return res+sign*(number);      \\n    }\\n};\\n```\\nupvote if it helps, thanks!",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int idx = 0;\\n        return helper(s,idx);      \\n    }\\n\\n    int helper(string s, int& idx) {\\n        int res = 0;\\n        int sign = 1; // \\'+\\'=1, \\'-\\'=-1\\n        int number = 0;\\n        \\n        for(;idx<s.size(); idx++){\\n            char x=s[idx]; //current char\\n\\n            if(x==\\' \\') continue;\\n            else if(x==\\'+\\'||x==\\'-\\') {\\n                res+= sign*(number);\\n                number=0;\\n                sign = (x==\\'+\\')?1:-1;\\n            }\\n            else if(x==\\'(\\') res += sign*helper(s, ++idx);\\n            else if(x==\\')\\') break;\\n            else number = number*10+(x-\\'0\\');\\n        }  \\n        return res+sign*(number);      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832375,
                "title": "easy-stack-solution-in-c-java-javascript",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int res = 0, sum = 0, sign = 1;\\n        stack<int> myStack({1});\\n        for(auto ch: s){\\n            if(isdigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n            else{\\n                res += sum * sign * myStack.top();\\n                sum = 0;\\n                if(ch == \\'-\\') sign = -1;\\n                else if(ch == \\'+\\') sign = 1;\\n                else if(ch == \\'(\\') myStack.push(myStack.top() * sign), sign = 1;\\n                else if(ch == \\')\\') myStack.pop();\\n            }\\n        }\\n        return res += (sum * sign);\\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        int res = 0, sum = 0, sign = 1;\\n        Stack<Integer> myStack = new Stack<>();\\n        myStack.push(1);\\n        for(char ch: s.toCharArray()){\\n            if(Character.isDigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n            else{\\n                res += sum * sign * myStack.peek();\\n                sum = 0;\\n                if(ch == \\'-\\') sign = -1;\\n                else if(ch == \\'+\\') sign = 1;\\n                else if(ch == \\'(\\'){\\n                    myStack.push(myStack.peek() * sign);\\n                    sign = 1;\\n                } else if(ch == \\')\\') myStack.pop();\\n            }\\n        }\\n        return res += sign * sum;\\n    }\\n}\\n```\\n# JAVASCRIPT\\n```\\nvar calculate = function(s) {\\n    let res = 0, sum = 0, sign = 1;\\n    let myStack = [];\\n    myStack.push(1);\\n    const isDigit = (ch) => {\\n        return ch >= \\'0\\' && ch <= \\'9\\';\\n    }\\n    for(let ch of s){\\n        if(isDigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n        else{\\n            res += sum * sign * myStack[myStack.length - 1];\\n            sum = 0;\\n            if(ch === \\'-\\') sign = -1;\\n            else if(ch === \\'+\\') sign = 1;\\n            else if(ch === \\'(\\') {myStack.push(myStack[myStack.length - 1] * sign); sign = 1;}\\n            else if(ch === \\')\\') myStack.pop(); \\n        }\\n    }\\n    return res += (sign * sum);\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int res = 0, sum = 0, sign = 1;\\n        stack<int> myStack({1});\\n        for(auto ch: s){\\n            if(isdigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n            else{\\n                res += sum * sign * myStack.top();\\n                sum = 0;\\n                if(ch == \\'-\\') sign = -1;\\n                else if(ch == \\'+\\') sign = 1;\\n                else if(ch == \\'(\\') myStack.push(myStack.top() * sign), sign = 1;\\n                else if(ch == \\')\\') myStack.pop();\\n            }\\n        }\\n        return res += (sum * sign);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        int res = 0, sum = 0, sign = 1;\\n        Stack<Integer> myStack = new Stack<>();\\n        myStack.push(1);\\n        for(char ch: s.toCharArray()){\\n            if(Character.isDigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n            else{\\n                res += sum * sign * myStack.peek();\\n                sum = 0;\\n                if(ch == \\'-\\') sign = -1;\\n                else if(ch == \\'+\\') sign = 1;\\n                else if(ch == \\'(\\'){\\n                    myStack.push(myStack.peek() * sign);\\n                    sign = 1;\\n                } else if(ch == \\')\\') myStack.pop();\\n            }\\n        }\\n        return res += sign * sum;\\n    }\\n}\\n```\n```\\nvar calculate = function(s) {\\n    let res = 0, sum = 0, sign = 1;\\n    let myStack = [];\\n    myStack.push(1);\\n    const isDigit = (ch) => {\\n        return ch >= \\'0\\' && ch <= \\'9\\';\\n    }\\n    for(let ch of s){\\n        if(isDigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n        else{\\n            res += sum * sign * myStack[myStack.length - 1];\\n            sum = 0;\\n            if(ch === \\'-\\') sign = -1;\\n            else if(ch === \\'+\\') sign = 1;\\n            else if(ch === \\'(\\') {myStack.push(myStack[myStack.length - 1] * sign); sign = 1;}\\n            else if(ch === \\')\\') myStack.pop(); \\n        }\\n    }\\n    return res += (sign * sum);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233404,
                "title": "simple-c-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        //we basically calculate everything at a time and update it in result varibale\\n        int result=0;\\n        int sign=1; //1 rep +ve -1 rep -ve\\n        int j=0;\\n        int len=s.length();\\n        stack<int> stk;\\n        while(j<len){ \\n            if(s[j]==\\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if(s[j]==\\'-\\')\\n            {\\n                //we got a negative value\\n                sign=-1;\\n            }\\n            else if(isdigit(s[j]))\\n            {\\n                //get the number \\n                int num=s[j]-\\'0\\';\\n                while(j+1<len && isdigit(s[j+1])){\\n                    num=num*10+(s[j+1]-\\'0\\');\\n                    j++;\\n                }\\n                //now add it to the result along with sign\\n                result+=num*sign;\\n            }\\n            else if(s[j]==\\'(\\')\\n            {\\n                //we push the current result and current sign into the stack\\n                stk.push(result);\\n                stk.push(sign);\\n                result=0;\\n                sign=1;\\n            }\\n            else if(s[j]==\\')\\')\\n            {\\n                //get the last result and the sign from the stack\\n                int xsign=stk.top();\\n                stk.pop();\\n                int xresult=stk.top();\\n                stk.pop();\\n                //add the curr result in parenthesis to prev result and update the entire result\\n                result=result*xsign + xresult;\\n                //xsign will be the sign before the begin of parenthesis\\n            }\\n            j++;\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Please upvote if this helps :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        //we basically calculate everything at a time and update it in result varibale\\n        int result=0;\\n        int sign=1; //1 rep +ve -1 rep -ve\\n        int j=0;\\n        int len=s.length();\\n        stack<int> stk;\\n        while(j<len){ \\n            if(s[j]==\\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if(s[j]==\\'-\\')\\n            {\\n                //we got a negative value\\n                sign=-1;\\n            }\\n            else if(isdigit(s[j]))\\n            {\\n                //get the number \\n                int num=s[j]-\\'0\\';\\n                while(j+1<len && isdigit(s[j+1])){\\n                    num=num*10+(s[j+1]-\\'0\\');\\n                    j++;\\n                }\\n                //now add it to the result along with sign\\n                result+=num*sign;\\n            }\\n            else if(s[j]==\\'(\\')\\n            {\\n                //we push the current result and current sign into the stack\\n                stk.push(result);\\n                stk.push(sign);\\n                result=0;\\n                sign=1;\\n            }\\n            else if(s[j]==\\')\\')\\n            {\\n                //get the last result and the sign from the stack\\n                int xsign=stk.top();\\n                stk.pop();\\n                int xresult=stk.top();\\n                stk.pop();\\n                //add the curr result in parenthesis to prev result and update the entire result\\n                result=result*xsign + xresult;\\n                //xsign will be the sign before the begin of parenthesis\\n            }\\n            j++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227155,
                "title": "javascript-simple-solution-with-explanation",
                "content": "Runtime: 132 ms, faster than 25.48% of JavaScript online submissions for Basic Calculator.\\nMemory Usage: 48 MB, less than 23.77% of JavaScript online submissions for Basic Calculator.\\n\\nhow this code works :\\nUntil \")\" of stringS appears, always push s[i] into stack, when  \")\" appears, pop stack into temp until the last index of stack is \"(\"\\nand reverse temp and then start counting.\\nsome of cases like \"-1+2\" or \"5+(+1+2)\", will additional push zero into stack, like \"**0**-1+2\", \"5+(**0**+1+2)\"\\n\\n```\\nvar calculate = function(s) {\\n    s = \"(\"+s+\")\"\\n    let stack = [];\\n    let temp = [];\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i]===\" \") continue;\\n        if(s[i]===\")\"){     \\n            while(stack[stack.length-1]!==\"(\") temp.push(stack.pop());                   \\n            stack.pop();\\n            stack.push(count(temp));\\n            continue;\\n        }\\n         if(isNum(stack[stack.length-1])&&isNum(s[i])){\\n            stack[stack.length-1]+=s[i];   \\n            continue;             \\n        } \\n        if(s[i]===\"-\"||s[i]===\"+\"){\\n             if(stack.length===0||stack[stack.length-1]===\"(\") stack.push(\"0\");    \\n        }\\n        stack.push(s[i]);\\n    }\\n    return stack[0];\\n};\\n    \\nfunction count(temp) {\\n   temp = temp.reverse();\\n      while(temp.length!==1){\\n          if(temp[1]===\"+\") temp[0]=(+temp[0])+(+temp[2]);\\n          if(temp[1]===\"-\") temp[0]=(+temp[0])-(+temp[2]);\\n          temp.splice(1,2);\\n      }\\n    return temp.pop();\\n}\\n    \\nfunction isNum(str) {\\n  return /[0-9]+/.test(str);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar calculate = function(s) {\\n    s = \"(\"+s+\")\"\\n    let stack = [];\\n    let temp = [];\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i]===\" \") continue;\\n        if(s[i]===\")\"){     \\n            while(stack[stack.length-1]!==\"(\") temp.push(stack.pop());                   \\n            stack.pop();\\n            stack.push(count(temp));\\n            continue;\\n        }\\n         if(isNum(stack[stack.length-1])&&isNum(s[i])){\\n            stack[stack.length-1]+=s[i];   \\n            continue;             \\n        } \\n        if(s[i]===\"-\"||s[i]===\"+\"){\\n             if(stack.length===0||stack[stack.length-1]===\"(\") stack.push(\"0\");    \\n        }\\n        stack.push(s[i]);\\n    }\\n    return stack[0];\\n};\\n    \\nfunction count(temp) {\\n   temp = temp.reverse();\\n      while(temp.length!==1){\\n          if(temp[1]===\"+\") temp[0]=(+temp[0])+(+temp[2]);\\n          if(temp[1]===\"-\") temp[0]=(+temp[0])-(+temp[2]);\\n          temp.splice(1,2);\\n      }\\n    return temp.pop();\\n}\\n    \\nfunction isNum(str) {\\n  return /[0-9]+/.test(str);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564036,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n      int res = 0;\\n      int num = 0, sign = 1; // 1 for positiove and - 1 for negative\\n      stack<int> stk;\\n      for(int i = 0; i < s.size(); ++i) {\\n         while(i < s.size() && isdigit(s[i])) {\\n           num = num * 10 + (s[i] - \\'0\\');\\n           ++i;\\n         }\\n         res += (num * sign);\\n         num = 0;\\n         if(s[i] == \\'+\\') {\\n            sign = 1;\\n         }else if( s[i] == \\'-\\') {\\n            sign = - 1;\\n         }else if(s[i] == \\'(\\') {\\n            stk.push(res);\\n            res = 0;\\n            stk.push(sign);\\n            sign = 1;\\n         }else if(s[i] == \\')\\') {\\n            res *= stk.top();\\n            stk.pop();\\n            res += stk.top();\\n            stk.pop();\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n      int res = 0;\\n      int num = 0, sign = 1; // 1 for positiove and - 1 for negative\\n      stack<int> stk;\\n      for(int i = 0; i < s.size(); ++i) {\\n         while(i < s.size() && isdigit(s[i])) {\\n           num = num * 10 + (s[i] - \\'0\\');\\n           ++i;\\n         }\\n         res += (num * sign);\\n         num = 0;\\n         if(s[i] == \\'+\\') {\\n            sign = 1;\\n         }else if( s[i] == \\'-\\') {\\n            sign = - 1;\\n         }else if(s[i] == \\'(\\') {\\n            stk.push(res);\\n            res = 0;\\n            stk.push(sign);\\n            sign = 1;\\n         }else if(s[i] == \\')\\') {\\n            res *= stk.top();\\n            stk.pop();\\n            res += stk.top();\\n            stk.pop();\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62351,
                "title": "ultimate-solutions-in-java-for-all-follow-ups",
                "content": "Hi guys, here I list solutions for 6 different versions of the problem, some of them are inspired by code from other people.\\nSorry I don't have time to write explanation or comment but I believe all of them are not too hard to understand. I may add some explanations in the future if I have some time.\\nPlease leave your comments about these solutions and give me an up-vote if they help. \\nThank you guys! Fighting!\\n\\nVersion 1: Support [ + - ]\\n-------\\n(not tested)\\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        int len = s.length(), sign = 1, res = 0, num = 0;\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (c == ' ') continue;\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == len - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    res += sign * num;\\n                    num = 0;\\n                }\\n            } else { // + or -\\n                if (c == '+') sign = 1;\\n                if (c == '-') sign = -1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```\\n\\n\\nVersion 2: Support [ + - ( ) ] (this problem)\\n-------\\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        int len = s.length(), sign = 1, res = 0, num = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (c == ' ') continue; //\\u53ea\\u8981\\u6570\\u5b57\\u4e0d\\u4f1a\\u88ab\\u62c6\\u5f00\\uff0c\\u7528\\u8fd9\\u4e2a\\u5c31\\u6ca1\\u95ee\\u9898\\u3002\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == len - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    res += sign * num;\\n                    num = 0;\\n                }\\n            } else { // + - ( )\\n                if (c == '+') {\\n                    sign = 1;\\n                }\\n                if (c == '-') {\\n                    sign = -1;\\n                }\\n                if (c == '(') {\\n                    stack.push(res);\\n                    stack.push(sign);\\n                    res = 0;\\n                    sign = 1;\\n                }\\n                if (c == ')') {\\n                    res = res * stack.pop() + stack.pop();\\n                }               \\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```\\n\\nVersion 3: Support [ + - * / ]\\n---------\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int len = s.length();\\n        int num = 0;\\n        char sign = '+';\\n        int curr = 0, res = 0; //important, use curr to store value of last segment.\\n        for (int i = 0; i < len; i++) {\\n            if (s.charAt(i) == ' ') continue;\\n            if (!Character.isDigit(s.charAt(i))) {\\n                num = 0;\\n                sign = s.charAt(i);\\n                if (sign == '+' || sign == '-') {\\n                    res += curr;\\n                    curr = 0; // not necessary\\n                }\\n            } else {\\n                num = num * 10 + s.charAt(i) - '0';\\n                if (i == len - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    if (sign == '+') curr = num;\\n                    if (sign == '-') curr = -num;\\n                    if (sign == '*') curr *= num;\\n                    if (sign == '/') curr /= num;\\n                }\\n            }         \\n        }\\n        res += curr; // add last segment\\n        return res;\\n    }\\n}\\n\\n```\\n\\nVersion 4: Support [ + - * / ( ) ]\\n--------\\nShould be easily derived from Version 6, just remove anything related to ^.\\n\\n\\nVersion 5: Support [ + - * / ^ ]\\n-----------------\\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        // remove spaces //\\u8fd9\\u90e8\\u5206\\u4e5f\\u53ef\\u4ee5\\u653e\\u5728\\u4e0b\\u9762\\u5224\\u65ad\\uff0c\\u4e00\\u53e5\\u641e\\u5b9a\\uff0c\\u662f\\u7a7a\\u683c\\u7684\\u65f6\\u5019\\u8df3\\u8fc7\\n        String[] strs = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < strs.length; i++) {\\n            sb.append(strs[i]);\\n        }\\n        s = sb.toString();\\n        \\n        // init\\n        if (s == null || sb.length() == 0) return 0;\\n        int num = 0;\\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<Character> opStack = new Stack<>();\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put('+', 1); map.put('-', 1);\\n        map.put('*', 2); map.put('/', 2);\\n        map.put('^', 3);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == s.length() - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    numStack.push(num);\\n                    num = 0;                  \\n                }\\n            } else { // op: + - * / ^\\n                if (opStack.empty() || map.get(c) > map.get(opStack.peek())) {\\n                    opStack.push(c);\\n                } else {\\n                    while (!opStack.empty() && map.get(c) <= map.get(opStack.peek())) {\\n                        helper(numStack, opStack);\\n                    }\\n                    opStack.push(c);\\n                }                     \\n            }           \\n        }\\n        \\n        while (!opStack.empty()) {\\n            helper(numStack, opStack);\\n        }\\n        return numStack.pop();\\n    }\\n    \\n    private void helper(Stack<Integer> numStack, Stack<Character> opStack) {\\n        int b = numStack.pop();\\n        int a = numStack.pop();\\n        char op = opStack.pop();\\n        if (op == '+') numStack.push(a + b);\\n        if (op == '-') numStack.push(a - b);\\n        if (op == '*') numStack.push(a * b);\\n        if (op == '/') numStack.push(a / b);\\n        if (op == '^') numStack.push((int)Math.pow(a, b));\\n    }\\n\\n}\\n```\\n\\nVersion 6: Support [ + - * / ^ ( ) ]\\n---------------\\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        // remove spaces //\\u8fd9\\u90e8\\u5206\\u4e5f\\u53ef\\u4ee5\\u653e\\u5728\\u4e0b\\u9762\\u5224\\u65ad\\uff0c\\u4e00\\u53e5\\u641e\\u5b9a\\uff0c\\u662f\\u7a7a\\u683c\\u7684\\u65f6\\u5019\\u8df3\\u8fc7\\n        String[] strs = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < strs.length; i++) {\\n            sb.append(strs[i]);\\n        }\\n        s = sb.toString();\\n        \\n        // init\\n        if (s == null || sb.length() == 0) return 0;\\n        int num = 0;\\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<Character> opStack = new Stack<>();\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put('+', 1); map.put('-', 1);\\n        map.put('*', 2); map.put('/', 2);\\n        map.put('^', 3);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == s.length() - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    numStack.push(num);\\n                    num = 0;                  \\n                }\\n            } else { // op or ()\\n                if (c == '(') {\\n                    opStack.push(c);\\n                }\\n                if (c == ')') {\\n                    while (!opStack.empty() && opStack.peek() != '(') {\\n                        helper(numStack, opStack);\\n                    }\\n                    opStack.pop(); // pop the '('\\n                }\\n                if (map.containsKey(c)) { // + - * / ^\\n                    if (opStack.empty() || opStack.peek() == '(' || map.get(c) > map.get(opStack.peek())) {\\n                        opStack.push(c);\\n                    } else {\\n                        while (!opStack.empty() && opStack.peek() != '(' && map.get(c) <= map.get(opStack.peek())) {\\n                            helper(numStack, opStack);\\n                        }\\n                        opStack.push(c);\\n                    }                 \\n                }              \\n            }           \\n        }\\n        \\n        while (!opStack.empty()) {\\n            helper(numStack, opStack);\\n        }\\n        return numStack.pop();\\n    }\\n    \\n    private void helper(Stack<Integer> numStack, Stack<Character> opStack) {\\n        int b = numStack.pop();\\n        int a = numStack.pop();\\n        char op = opStack.pop();\\n        if (op == '+') numStack.push(a + b);\\n        if (op == '-') numStack.push(a - b);\\n        if (op == '*') numStack.push(a * b);\\n        if (op == '/') numStack.push(a / b);\\n        if (op == '^') numStack.push((int)Math.pow(a, b));\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        int len = s.length(), sign = 1, res = 0, num = 0;\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (c == ' ') continue;\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == len - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    res += sign * num;\\n                    num = 0;\\n                }\\n            } else { // + or -\\n                if (c == '+') sign = 1;\\n                if (c == '-') sign = -1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        int len = s.length(), sign = 1, res = 0, num = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (c == ' ') continue; //\\u53ea\\u8981\\u6570\\u5b57\\u4e0d\\u4f1a\\u88ab\\u62c6\\u5f00\\uff0c\\u7528\\u8fd9\\u4e2a\\u5c31\\u6ca1\\u95ee\\u9898\\u3002\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == len - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    res += sign * num;\\n                    num = 0;\\n                }\\n            } else { // + - ( )\\n                if (c == '+') {\\n                    sign = 1;\\n                }\\n                if (c == '-') {\\n                    sign = -1;\\n                }\\n                if (c == '(') {\\n                    stack.push(res);\\n                    stack.push(sign);\\n                    res = 0;\\n                    sign = 1;\\n                }\\n                if (c == ')') {\\n                    res = res * stack.pop() + stack.pop();\\n                }               \\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int len = s.length();\\n        int num = 0;\\n        char sign = '+';\\n        int curr = 0, res = 0; //important, use curr to store value of last segment.\\n        for (int i = 0; i < len; i++) {\\n            if (s.charAt(i) == ' ') continue;\\n            if (!Character.isDigit(s.charAt(i))) {\\n                num = 0;\\n                sign = s.charAt(i);\\n                if (sign == '+' || sign == '-') {\\n                    res += curr;\\n                    curr = 0; // not necessary\\n                }\\n            } else {\\n                num = num * 10 + s.charAt(i) - '0';\\n                if (i == len - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    if (sign == '+') curr = num;\\n                    if (sign == '-') curr = -num;\\n                    if (sign == '*') curr *= num;\\n                    if (sign == '/') curr /= num;\\n                }\\n            }         \\n        }\\n        res += curr; // add last segment\\n        return res;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        // remove spaces //\\u8fd9\\u90e8\\u5206\\u4e5f\\u53ef\\u4ee5\\u653e\\u5728\\u4e0b\\u9762\\u5224\\u65ad\\uff0c\\u4e00\\u53e5\\u641e\\u5b9a\\uff0c\\u662f\\u7a7a\\u683c\\u7684\\u65f6\\u5019\\u8df3\\u8fc7\\n        String[] strs = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < strs.length; i++) {\\n            sb.append(strs[i]);\\n        }\\n        s = sb.toString();\\n        \\n        // init\\n        if (s == null || sb.length() == 0) return 0;\\n        int num = 0;\\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<Character> opStack = new Stack<>();\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put('+', 1); map.put('-', 1);\\n        map.put('*', 2); map.put('/', 2);\\n        map.put('^', 3);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == s.length() - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    numStack.push(num);\\n                    num = 0;                  \\n                }\\n            } else { // op: + - * / ^\\n                if (opStack.empty() || map.get(c) > map.get(opStack.peek())) {\\n                    opStack.push(c);\\n                } else {\\n                    while (!opStack.empty() && map.get(c) <= map.get(opStack.peek())) {\\n                        helper(numStack, opStack);\\n                    }\\n                    opStack.push(c);\\n                }                     \\n            }           \\n        }\\n        \\n        while (!opStack.empty()) {\\n            helper(numStack, opStack);\\n        }\\n        return numStack.pop();\\n    }\\n    \\n    private void helper(Stack<Integer> numStack, Stack<Character> opStack) {\\n        int b = numStack.pop();\\n        int a = numStack.pop();\\n        char op = opStack.pop();\\n        if (op == '+') numStack.push(a + b);\\n        if (op == '-') numStack.push(a - b);\\n        if (op == '*') numStack.push(a * b);\\n        if (op == '/') numStack.push(a / b);\\n        if (op == '^') numStack.push((int)Math.pow(a, b));\\n    }\\n\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        // remove spaces //\\u8fd9\\u90e8\\u5206\\u4e5f\\u53ef\\u4ee5\\u653e\\u5728\\u4e0b\\u9762\\u5224\\u65ad\\uff0c\\u4e00\\u53e5\\u641e\\u5b9a\\uff0c\\u662f\\u7a7a\\u683c\\u7684\\u65f6\\u5019\\u8df3\\u8fc7\\n        String[] strs = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < strs.length; i++) {\\n            sb.append(strs[i]);\\n        }\\n        s = sb.toString();\\n        \\n        // init\\n        if (s == null || sb.length() == 0) return 0;\\n        int num = 0;\\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<Character> opStack = new Stack<>();\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put('+', 1); map.put('-', 1);\\n        map.put('*', 2); map.put('/', 2);\\n        map.put('^', 3);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == s.length() - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    numStack.push(num);\\n                    num = 0;                  \\n                }\\n            } else { // op or ()\\n                if (c == '(') {\\n                    opStack.push(c);\\n                }\\n                if (c == ')') {\\n                    while (!opStack.empty() && opStack.peek() != '(') {\\n                        helper(numStack, opStack);\\n                    }\\n                    opStack.pop(); // pop the '('\\n                }\\n                if (map.containsKey(c)) { // + - * / ^\\n                    if (opStack.empty() || opStack.peek() == '(' || map.get(c) > map.get(opStack.peek())) {\\n                        opStack.push(c);\\n                    } else {\\n                        while (!opStack.empty() && opStack.peek() != '(' && map.get(c) <= map.get(opStack.peek())) {\\n                            helper(numStack, opStack);\\n                        }\\n                        opStack.push(c);\\n                    }                 \\n                }              \\n            }           \\n        }\\n        \\n        while (!opStack.empty()) {\\n            helper(numStack, opStack);\\n        }\\n        return numStack.pop();\\n    }\\n    \\n    private void helper(Stack<Integer> numStack, Stack<Character> opStack) {\\n        int b = numStack.pop();\\n        int a = numStack.pop();\\n        char op = opStack.pop();\\n        if (op == '+') numStack.push(a + b);\\n        if (op == '-') numStack.push(a - b);\\n        if (op == '*') numStack.push(a * b);\\n        if (op == '/') numStack.push(a / b);\\n        if (op == '^') numStack.push((int)Math.pow(a, b));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804998,
                "title": "c-easy-solution-using-stack-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int sum=0;\\n        int sign=1;\\n        stack<int> stac;\\n        for (int i=0;i<s.length();i++){\\n            char ch=s[i];\\n            if (isdigit(ch)){\\n                int val=0;\\n                while(i<s.length() && isdigit(s[i])){\\n                    val=val*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                sum=sum+sign*val;\\n                sign=1;\\n            }else if (ch==\\'(\\'){\\n                stac.push(sum);\\n                stac.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if (ch==\\')\\'){\\n                sum=stac.top()*sum;\\n                stac.pop();\\n                sum=sum+stac.top();\\n                stac.pop();\\n            }\\n            else if (ch==\\'-\\'){\\n                sign*=-1;\\n            }\\n        }\\n        return sum ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int sum=0;\\n        int sign=1;\\n        stack<int> stac;\\n        for (int i=0;i<s.length();i++){\\n            char ch=s[i];\\n            if (isdigit(ch)){\\n                int val=0;\\n                while(i<s.length() && isdigit(s[i])){\\n                    val=val*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                sum=sum+sign*val;\\n                sign=1;\\n            }else if (ch==\\'(\\'){\\n                stac.push(sum);\\n                stac.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if (ch==\\')\\'){\\n                sum=stac.top()*sum;\\n                stac.pop();\\n                sum=sum+stac.top();\\n                stac.pop();\\n            }\\n            else if (ch==\\'-\\'){\\n                sign*=-1;\\n            }\\n        }\\n        return sum ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735632,
                "title": "best-c-using-stack-solution-and-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse stack approch\\n\\n# Complexity\\n- Time complexity:\\nO(n) //as n is length of input string\\n\\n- Space complexity:\\nO(n) // as we use stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int len=s.length();\\n        stack<int> st;\\n        \\n        int sign=1;  //initially take +ve sign\\n        int currNum=0;\\n        int ans=0;\\n\\n        for(int i=0;i<len;i++){\\n            if(isdigit(s[i])){\\n                currNum=s[i]-\\'0\\';\\n\\n                while(i+1<len && isdigit(s[i+1])){\\n                    currNum=(currNum*10)+(s[i+1]-\\'0\\');\\n                    i++;\\n                }\\n                currNum=currNum*sign;\\n                ans+=currNum;\\n                currNum=0;\\n            }\\n            else if(s[i]==\\'+\\'){\\n                sign=1;\\n            }\\n            else if(s[i]==\\'-\\'){\\n                sign=-1;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(ans);\\n                st.push(sign);\\n\\n                sign=1;\\n                currNum=0;\\n                ans=0;\\n            }\\n\\n            else if(s[i]==\\')\\'){\\n                int prevSign=st.top();\\n                ans=ans*prevSign;\\n                st.pop();\\n\\n                int prevAns=st.top();\\n                ans+=prevAns;\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int len=s.length();\\n        stack<int> st;\\n        \\n        int sign=1;  //initially take +ve sign\\n        int currNum=0;\\n        int ans=0;\\n\\n        for(int i=0;i<len;i++){\\n            if(isdigit(s[i])){\\n                currNum=s[i]-\\'0\\';\\n\\n                while(i+1<len && isdigit(s[i+1])){\\n                    currNum=(currNum*10)+(s[i+1]-\\'0\\');\\n                    i++;\\n                }\\n                currNum=currNum*sign;\\n                ans+=currNum;\\n                currNum=0;\\n            }\\n            else if(s[i]==\\'+\\'){\\n                sign=1;\\n            }\\n            else if(s[i]==\\'-\\'){\\n                sign=-1;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(ans);\\n                st.push(sign);\\n\\n                sign=1;\\n                currNum=0;\\n                ans=0;\\n            }\\n\\n            else if(s[i]==\\')\\'){\\n                int prevSign=st.top();\\n                ans=ans*prevSign;\\n                st.pop();\\n\\n                int prevAns=st.top();\\n                ans+=prevAns;\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294226,
                "title": "easiest-solution-ever-pls-take-a-look",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sign = 1;\\n        int sum = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i<s.length(); i++){\\n            if(s.charAt(i)>=\\'0\\' && s.charAt(i)<=\\'9\\'){\\n                int num = 0;\\n                while(i<s.length() && s.charAt(i)>=\\'0\\' && s.charAt(i)<=\\'9\\'){\\n                    num = num * 10 + s.charAt(i) - \\'0\\';\\n                    i++;\\n                }\\n                sum += num * sign;\\n                i--;\\n            }\\n            else if(s.charAt(i)==\\'+\\') sign = 1;\\n            else if(s.charAt(i)==\\'-\\') sign = -1;\\n            else if(s.charAt(i)==\\'(\\'){\\n                stack.push(sum);\\n                stack.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(s.charAt(i)==\\')\\'){\\n                sum = stack.pop() * sum;\\n                sum += stack.pop();\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sign = 1;\\n        int sum = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i<s.length(); i++){\\n            if(s.charAt(i)>=\\'0\\' && s.charAt(i)<=\\'9\\'){\\n                int num = 0;\\n                while(i<s.length() && s.charAt(i)>=\\'0\\' && s.charAt(i)<=\\'9\\'){\\n                    num = num * 10 + s.charAt(i) - \\'0\\';\\n                    i++;\\n                }\\n                sum += num * sign;\\n                i--;\\n            }\\n            else if(s.charAt(i)==\\'+\\') sign = 1;\\n            else if(s.charAt(i)==\\'-\\') sign = -1;\\n            else if(s.charAt(i)==\\'(\\'){\\n                stack.push(sum);\\n                stack.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(s.charAt(i)==\\')\\'){\\n                sum = stack.pop() * sum;\\n                sum += stack.pop();\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832292,
                "title": "most-intuitive-2-approaches-stack-and-recursion",
                "content": "**Recursion based:**\\n\\n```\\nclass Solution {\\nprivate:\\n    int calculateUtil(string &s, int &i) {\\n        int res = 0, curr = 0, prev_oper = 1;\\n        while(i < s.size()) {\\n            \\n            if(s[i] == \\'(\\') \\n                curr = calculateUtil(s, ++i);\\n\\n            else if(s[i] == \\')\\') \\n                break;\\n\\n            else if(s[i] == \\'+\\') {\\n                res += curr*prev_oper;\\n                prev_oper = 1;\\n                curr = 0;\\n            }\\n\\n            else if(s[i] == \\'-\\') {\\n                res += curr*prev_oper;\\n                prev_oper = -1;\\n                curr = 0;\\n            }\\n\\n            else if(s[i] != \\' \\')\\n                curr = curr*10+(s[i]-\\'0\\');\\n\\n            ++i;\\n        }\\n\\n        return res += curr*prev_oper;\\n    }\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return calculateUtil(s,i);\\n    }\\n};\\n```\\n\\n-----------------\\n\\n**Stack based:**\\n\\n```\\nclass Solution {\\npublic:\\n   int calculate(string s) {\\n       stack<pair<int, int>> st;                    // pair(prev_calc_value , sign before next bracket () )\\n       \\n       long long int sum = 0;\\n       int sign = +1;\\n       \\n       for(int i = 0 ; i < s.size() ; i++) {\\n           \\n           char ch = s[i];\\n           \\n           if(isdigit(ch)) {\\n               long long int num = 0;\\n               while(i < s.size() and isdigit(s[i]))\\n               {\\n                   num = (num * 10) + s[i] - \\'0\\'; i++;\\n               }\\n               i--;                                 // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n               sum += (num * sign);\\n               sign = +1;                           // reseting sign\\n           }\\n           else if(ch == \\'(\\') {\\n               \\n               st.push(make_pair(sum , sign));      // Saving current state of (sum , sign) in stack\\n               \\n               sum = 0;                             // Reseting sum and sign for inner bracket calculation\\n               sign = +1;\\n           }\\n           else if(ch == \\')\\') {\\n               sum = st.top().first + (st.top().second * sum);\\n               st.pop();\\n           }\\n           else if(ch == \\'-\\')\\n               sign = (-1 * sign);                  // toggle sign\\n       }\\n       return sum;\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int calculateUtil(string &s, int &i) {\\n        int res = 0, curr = 0, prev_oper = 1;\\n        while(i < s.size()) {\\n            \\n            if(s[i] == \\'(\\') \\n                curr = calculateUtil(s, ++i);\\n\\n            else if(s[i] == \\')\\') \\n                break;\\n\\n            else if(s[i] == \\'+\\') {\\n                res += curr*prev_oper;\\n                prev_oper = 1;\\n                curr = 0;\\n            }\\n\\n            else if(s[i] == \\'-\\') {\\n                res += curr*prev_oper;\\n                prev_oper = -1;\\n                curr = 0;\\n            }\\n\\n            else if(s[i] != \\' \\')\\n                curr = curr*10+(s[i]-\\'0\\');\\n\\n            ++i;\\n        }\\n\\n        return res += curr*prev_oper;\\n    }\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return calculateUtil(s,i);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   int calculate(string s) {\\n       stack<pair<int, int>> st;                    // pair(prev_calc_value , sign before next bracket () )\\n       \\n       long long int sum = 0;\\n       int sign = +1;\\n       \\n       for(int i = 0 ; i < s.size() ; i++) {\\n           \\n           char ch = s[i];\\n           \\n           if(isdigit(ch)) {\\n               long long int num = 0;\\n               while(i < s.size() and isdigit(s[i]))\\n               {\\n                   num = (num * 10) + s[i] - \\'0\\'; i++;\\n               }\\n               i--;                                 // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n               sum += (num * sign);\\n               sign = +1;                           // reseting sign\\n           }\\n           else if(ch == \\'(\\') {\\n               \\n               st.push(make_pair(sum , sign));      // Saving current state of (sum , sign) in stack\\n               \\n               sum = 0;                             // Reseting sum and sign for inner bracket calculation\\n               sign = +1;\\n           }\\n           else if(ch == \\')\\') {\\n               sum = st.top().first + (st.top().second * sum);\\n               st.pop();\\n           }\\n           else if(ch == \\'-\\')\\n               sign = (-1 * sign);                  // toggle sign\\n       }\\n       return sum;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831636,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "Solution:\\n```\\nclass Solution {\\n    func calculate(_ s: String) -> Int {\\n        var result = 0\\n        var num = 0\\n        var sign = 1\\n        var stack = [sign]\\n        \\n        for char in s {\\n            switch char {\\n            case \"+\", \"-\":\\n                result += num * sign\\n                sign = stack.last! * (char == \"+\" ? 1 : -1)\\n                num = 0\\n            case \"(\":\\n                stack.append(sign)\\n            case \")\":\\n                stack.removeLast()\\n            case \" \":\\n                break\\n            default:\\n                num = num * 10 + char.wholeNumberValue!\\n            }\\n        }\\n        \\n        return result + num * sign\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func calculate(_ s: String) -> Int {\\n        var result = 0\\n        var num = 0\\n        var sign = 1\\n        var stack = [sign]\\n        \\n        for char in s {\\n            switch char {\\n            case \"+\", \"-\":\\n                result += num * sign\\n                sign = stack.last! * (char == \"+\" ? 1 : -1)\\n                num = 0\\n            case \"(\":\\n                stack.append(sign)\\n            case \")\":\\n                stack.removeLast()\\n            case \" \":\\n                break\\n            default:\\n                num = num * 10 + char.wholeNumberValue!\\n            }\\n        }\\n        \\n        return result + num * sign\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035196,
                "title": "two-methods-using-stack-dfs-in-python-explained-to-details",
                "content": "**Two Methods:**\\none using stack\\none using DFS\\n\\n**Method 1:**\\nUse **stack**!\\n\\n**Initiate:**\\n* a running number\\n* a running result\\n* a running sign\\n\\nWhen we reach a **\"(\"**, we append the current res and sign to the stack.\\nWhen we reach a **\")\"**, we pop the before stored res and sign.\\n\\n**TIme:** O(n)\\n**Space:** O(n)\\n\\n```\\nclass Solution:\\n      \\n    def calculate(self, s: str) -> int:\\n\\n        stack = []\\n        num = 0 # Running number\\n        res = 0 # Running result\\n        sign = 1 # Running sign, 1 means positive, -1 means negative  \\n\\n        for char in s:\\n            \\n            if char.isdigit():\\n                num = (num * 10) + int(char)\\n\\n            elif char == \\'+\\':\\n                res += sign * num\\n                sign = 1\\n                num = 0\\n\\n            elif char == \\'-\\':\\n                res += sign * num\\n                sign = -1\\n                num = 0\\n\\n            elif char == \\'(\\':\\n                stack.append(res)\\n                stack.append(sign)\\n\\n                num = 0\\n                sign = 1\\n                res = 0\\n\\n            elif char == \\')\\':\\n                res += sign * num\\n\\n                res *= stack.pop() # stack pop previously stored sign\\n                res += stack.pop() # stack pop previously stored operand\\n\\n                num = 0\\n\\n        return res + sign * num\\n```\\n\\n\\n**Method 2:**\\nUse **DFS**!\\n\\nThis solution could be easily extended to **\"Q772: Basic Calculator III\"**\\n**Reference:**\\nhttps://leetcode.com/problems/basic-calculator-iii/\\nhttps://leetcode.com/problems/basic-calculator-iii/discuss/2035890/Greatly-Explained-DFS-%2B-Deque-%2B-Stack-Solution-in-Python-Easy-to-Understand!!!\\n\\nTake it as a **tree**!\\nEvery time we reach a **\"(\"**, we go to **next level**!\\n\\n**For example:**\\n**3 + ((7 + 6) - (8 + 5))**\\n7 + 6 is in level 2\\n8 + 5 is in level 2\\n13 - 13 is in level 1\\n3 + 0 is in level 0\\n\\n**Time:** O(n)\\n**Space:** O(n)\\n\\n```\\nclass Solution:\\n      \\n    def calculate(self, s: str) -> int:\\n\\n        queue = deque(s.replace(\\' \\',\\'\\'))\\n        return self.helper(queue)\\n    \\n    def helper(self, q):\\n        \\n        res = []       \\n        num = 0\\n        sign = \\'+\\'\\n        \\n        while q:\\n            x = q.popleft()\\n            if x == \\'(\\':\\n                num = self.helper(q) # go to next level\\n            if x.isdigit():\\n                num = num * 10 + int(x)\\n            if not x.isdigit() or not q:\\n                if sign ==\\'+\\':\\n                    res.append(num)\\n                elif sign ==\\'-\\':\\n                    res.append(-1 * num)\\n                sign = x\\n                num = 0\\n            if x == \\')\\':\\n                break\\n        \\n        return sum(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n      \\n    def calculate(self, s: str) -> int:\\n\\n        stack = []\\n        num = 0 # Running number\\n        res = 0 # Running result\\n        sign = 1 # Running sign, 1 means positive, -1 means negative  \\n\\n        for char in s:\\n            \\n            if char.isdigit():\\n                num = (num * 10) + int(char)\\n\\n            elif char == \\'+\\':\\n                res += sign * num\\n                sign = 1\\n                num = 0\\n\\n            elif char == \\'-\\':\\n                res += sign * num\\n                sign = -1\\n                num = 0\\n\\n            elif char == \\'(\\':\\n                stack.append(res)\\n                stack.append(sign)\\n\\n                num = 0\\n                sign = 1\\n                res = 0\\n\\n            elif char == \\')\\':\\n                res += sign * num\\n\\n                res *= stack.pop() # stack pop previously stored sign\\n                res += stack.pop() # stack pop previously stored operand\\n\\n                num = 0\\n\\n        return res + sign * num\\n```\n```\\nclass Solution:\\n      \\n    def calculate(self, s: str) -> int:\\n\\n        queue = deque(s.replace(\\' \\',\\'\\'))\\n        return self.helper(queue)\\n    \\n    def helper(self, q):\\n        \\n        res = []       \\n        num = 0\\n        sign = \\'+\\'\\n        \\n        while q:\\n            x = q.popleft()\\n            if x == \\'(\\':\\n                num = self.helper(q) # go to next level\\n            if x.isdigit():\\n                num = num * 10 + int(x)\\n            if not x.isdigit() or not q:\\n                if sign ==\\'+\\':\\n                    res.append(num)\\n                elif sign ==\\'-\\':\\n                    res.append(-1 * num)\\n                sign = x\\n                num = 0\\n            if x == \\')\\':\\n                break\\n        \\n        return sum(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458648,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\nInspired by [this](https://leetcode.com/problems/basic-calculator/discuss/62361/Iterative-Java-solution-with-stack) solution\\n```\\nfunc calculate(s string) int {\\n\\tif len(s) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tresult, sign, num := 0, 1, 0\\n\\n\\tvar st []int\\n\\tst = append(st, sign)\\n\\n\\tfor i := range s {\\n\\t\\tif s[i] >= \\'0\\' && s[i] <= \\'9\\' {\\n\\t\\t\\tnum = num*10 + int(s[i]-\\'0\\')\\n\\t\\t} else if s[i] == \\'+\\' || s[i] == \\'-\\' {\\n\\t\\t\\tresult += sign * num\\n\\t\\t\\tsign = st[len(st)-1]\\n\\t\\t\\tif s[i] != \\'+\\' {\\n\\t\\t\\t\\tsign *= -1\\n\\t\\t\\t}\\n\\t\\t\\tnum = 0\\n\\t\\t} else if s[i] == \\'(\\' {\\n\\t\\t\\tst = append(st, sign)\\n\\t\\t} else if s[i] == \\')\\' {\\n\\t\\t\\tst = st[:len(st)-1]\\n\\t\\t}\\n\\t}\\n\\n\\tresult += sign * num\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc calculate(s string) int {\\n\\tif len(s) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tresult, sign, num := 0, 1, 0\\n\\n\\tvar st []int\\n\\tst = append(st, sign)\\n\\n\\tfor i := range s {\\n\\t\\tif s[i] >= \\'0\\' && s[i] <= \\'9\\' {\\n\\t\\t\\tnum = num*10 + int(s[i]-\\'0\\')\\n\\t\\t} else if s[i] == \\'+\\' || s[i] == \\'-\\' {\\n\\t\\t\\tresult += sign * num\\n\\t\\t\\tsign = st[len(st)-1]\\n\\t\\t\\tif s[i] != \\'+\\' {\\n\\t\\t\\t\\tsign *= -1\\n\\t\\t\\t}\\n\\t\\t\\tnum = 0\\n\\t\\t} else if s[i] == \\'(\\' {\\n\\t\\t\\tst = append(st, sign)\\n\\t\\t} else if s[i] == \\')\\' {\\n\\t\\t\\tst = st[:len(st)-1]\\n\\t\\t}\\n\\t}\\n\\n\\tresult += sign * num\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1457033,
                "title": "java-stacks-solution",
                "content": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sum=0;\\n        int sign=1;\\n        Stack<Integer> stack=new Stack();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(Character.isDigit(c)){\\n                int val=0;\\n                while(i<s.length() && Character.isDigit(s.charAt(i))){\\n                    val=val*10+s.charAt(i)-\\'0\\';\\n                    i++;\\n                }\\n                i--;\\n                val=val*sign;\\n                sum+=val;\\n                sign=1; //reset the sign\\n            }\\n            else if(c==\\'(\\'){\\n                stack.push(sum);\\n                stack.push(sign);\\n                sum=0;\\n                sign=1;\\n            }else if(c==\\')\\'){\\n                sum*=stack.pop();\\n                sum+=stack.pop();\\n            }else if(c==\\'-\\'){\\n                sign*=-1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sum=0;\\n        int sign=1;\\n        Stack<Integer> stack=new Stack();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(Character.isDigit(c)){\\n                int val=0;\\n                while(i<s.length() && Character.isDigit(s.charAt(i))){\\n                    val=val*10+s.charAt(i)-\\'0\\';\\n                    i++;\\n                }\\n                i--;\\n                val=val*sign;\\n                sum+=val;\\n                sign=1; //reset the sign\\n            }\\n            else if(c==\\'(\\'){\\n                stack.push(sum);\\n                stack.push(sign);\\n                sum=0;\\n                sign=1;\\n            }else if(c==\\')\\'){\\n                sum*=stack.pop();\\n                sum+=stack.pop();\\n            }else if(c==\\'-\\'){\\n                sign*=-1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446691,
                "title": "c-explained-stacks-beginner-friendly",
                "content": "# ***Approach***\\n```\\nThis is a very good stacks problem , we are given an expression in form of string with \\nchars as [nums , \\'(\\' , \\')\\' , \\'+\\' , \\'-\\' , \\' \\']\\n\\nNote : we can totally ignore \\' \\' and  \\'+\\'.\\n    \\nLogic:\\n        what we are going to do is very simple , \\n        first intilaize two vars , sum and sign\\n        sum = 0\\n        sign = +1\\n            \\n        traverse the string:\\n            if(ch is digit)\\n                num = get_full_num; // may be multidigit\\n                add it to sum , sum += (num * sign)\\n                reset sign to +1\\n            else if(ch is \\'(\\')\\n                save current state of sum and sign in stack\\n                reset sum and sign\\n            else if(ch is \\')\\')\\n                sum = val_at_top + (sign_at_top * sum)\\n                pop;\\n            else if(ch is \\'-\\')\\n                toggle sign\\n                \\n       the use of sum and sign are to evaluate current expression inside a () braces or completely outside\\n       stack is used to store the state of sum and sign take example\\n       1 + 2 + 3 - (5 + 6) => 6 - (5 + 6)\\n                when we encounter saving state means\\n                stack will store pair(6 , -) and first calculate (5 + 6)\\n                once (5 + 6) is calculated which is 11\\n                pop from stack => sum = (6 + (sum * -1)) = (6 + (11 * -1)) = -5 ans\\n ```\\n # ***Code***\\n ```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<pair<int,int>> st; // pair(prev_calc_value , sign before next bracket () )\\n        \\n        long long int sum = 0;\\n        int sign = +1;\\n        \\n        for(int i = 0 ; i < s.size() ; ++i)\\n        {\\n            char ch = s[i];\\n            \\n            if(isdigit(ch))\\n            {\\n                long long int num = 0;\\n                while(i < s.size() and isdigit(s[i]))\\n                {\\n                    num = (num * 10) + s[i] - \\'0\\';\\n                    i++;\\n                }\\n                i--; // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n                sum += (num * sign);\\n                sign = +1; // reseting sign\\n            }\\n            else if(ch == \\'(\\')\\n            {\\n                // Saving current state of (sum , sign) in stack\\n                st.push(make_pair(sum , sign));\\n                \\n                // Reseting sum and sign for inner bracket calculation\\n                sum = 0; \\n                sign = +1;\\n            }\\n            else if(ch == \\')\\')\\n            {\\n                sum = st.top().first + (st.top().second * sum);\\n                st.pop();\\n            }\\n            else if(ch == \\'-\\')\\n            {\\n                // toggle sign\\n                sign = (-1 * sign);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n# ***If you liked the solution , Please Upvote!!!***",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nThis is a very good stacks problem , we are given an expression in form of string with \\nchars as [nums , \\'(\\' , \\')\\' , \\'+\\' , \\'-\\' , \\' \\']\\n\\nNote : we can totally ignore \\' \\' and  \\'+\\'.\\n    \\nLogic:\\n        what we are going to do is very simple , \\n        first intilaize two vars , sum and sign\\n        sum = 0\\n        sign = +1\\n            \\n        traverse the string:\\n            if(ch is digit)\\n                num = get_full_num; // may be multidigit\\n                add it to sum , sum += (num * sign)\\n                reset sign to +1\\n            else if(ch is \\'(\\')\\n                save current state of sum and sign in stack\\n                reset sum and sign\\n            else if(ch is \\')\\')\\n                sum = val_at_top + (sign_at_top * sum)\\n                pop;\\n            else if(ch is \\'-\\')\\n                toggle sign\\n                \\n       the use of sum and sign are to evaluate current expression inside a () braces or completely outside\\n       stack is used to store the state of sum and sign take example\\n       1 + 2 + 3 - (5 + 6) => 6 - (5 + 6)\\n                when we encounter saving state means\\n                stack will store pair(6 , -) and first calculate (5 + 6)\\n                once (5 + 6) is calculated which is 11\\n                pop from stack => sum = (6 + (sum * -1)) = (6 + (11 * -1)) = -5 ans\\n ```\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<pair<int,int>> st; // pair(prev_calc_value , sign before next bracket () )\\n        \\n        long long int sum = 0;\\n        int sign = +1;\\n        \\n        for(int i = 0 ; i < s.size() ; ++i)\\n        {\\n            char ch = s[i];\\n            \\n            if(isdigit(ch))\\n            {\\n                long long int num = 0;\\n                while(i < s.size() and isdigit(s[i]))\\n                {\\n                    num = (num * 10) + s[i] - \\'0\\';\\n                    i++;\\n                }\\n                i--; // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n                sum += (num * sign);\\n                sign = +1; // reseting sign\\n            }\\n            else if(ch == \\'(\\')\\n            {\\n                // Saving current state of (sum , sign) in stack\\n                st.push(make_pair(sum , sign));\\n                \\n                // Reseting sum and sign for inner bracket calculation\\n                sum = 0; \\n                sign = +1;\\n            }\\n            else if(ch == \\')\\')\\n            {\\n                sum = st.top().first + (st.top().second * sum);\\n                st.pop();\\n            }\\n            else if(ch == \\'-\\')\\n            {\\n                // toggle sign\\n                sign = (-1 * sign);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344266,
                "title": "python-recursive-easy-to-understand",
                "content": "The approach here is somewhat similar to https://leetcode.com/problems/construct-binary-tree-from-string/ in the sense that an opening parenthesis signals a new subexpression and therefore a signal that we need to recurse. Each entry on the call stack is responsible for evaluating it\\'s assigned subexpression and returning the result of that subexpression as well as the last index of that expression. The method call one level up on the stack resumes where the subexpression left off.\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        \\n        def recurs(s, start):\\n            operand = result = 0\\n            nextSign = 1 # 1 for positive, -1 for negative (used to change sign of operand since we\\'re always adding)\\n            i = start\\n            while i < len(s) - 1:\\n                i += 1\\n                c = s[i]\\n                \\n                if c == \" \":\\n                    continue\\n\\n                if c.isdigit():\\n                    # add digit to operand (could be multiple)\\n                    operand = 10 * operand + int(c)\\n                elif c == \"(\":\\n                    # new sub-expression - recurs\\n                    end, operand = recurs(s, i)\\n                    i = end\\n                elif c == \")\":\\n                    # sub-expression ended - exit\\n                    break\\n                else:\\n                    # operator\\n                    result += nextSign * operand\\n                    nextSign = 1 if c == \"+\" else -1\\n                    operand = 0\\n\\n            return i, result + (nextSign * operand)\\n        \\n        return recurs(s, -1)[1]\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        \\n        def recurs(s, start):\\n            operand = result = 0\\n            nextSign = 1 # 1 for positive, -1 for negative (used to change sign of operand since we\\'re always adding)\\n            i = start\\n            while i < len(s) - 1:\\n                i += 1\\n                c = s[i]\\n                \\n                if c == \" \":\\n                    continue\\n\\n                if c.isdigit():\\n                    # add digit to operand (could be multiple)\\n                    operand = 10 * operand + int(c)\\n                elif c == \"(\":\\n                    # new sub-expression - recurs\\n                    end, operand = recurs(s, i)\\n                    i = end\\n                elif c == \")\":\\n                    # sub-expression ended - exit\\n                    break\\n                else:\\n                    # operator\\n                    result += nextSign * operand\\n                    nextSign = 1 if c == \"+\" else -1\\n                    operand = 0\\n\\n            return i, result + (nextSign * operand)\\n        \\n        return recurs(s, -1)[1]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1254459,
                "title": "python-concise-solution-with-stack",
                "content": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        \\n        num=0\\n        res=0\\n        sign=1\\n        stack=[]\\n        \\n        for char in s:\\n            if char.isdigit():\\n                num=num*10+int(char)\\n            elif char in [\"-\",\"+\"]:\\n                res=res+num*sign\\n                num=0\\n                if char==\"-\":\\n                    sign=-1\\n                else:\\n                    sign=1\\n            elif char==\"(\":\\n                stack.append(res)\\n                stack.append(sign)\\n                sign=1\\n                res=0\\n            elif char==\")\":\\n                res+=sign*num\\n                res*=stack.pop()## process sign\\n                res+=stack.pop() ##process with old value\\n                num=0\\n        \\n        return res+num*sign\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        \\n        num=0\\n        res=0\\n        sign=1\\n        stack=[]\\n        \\n        for char in s:\\n            if char.isdigit():\\n                num=num*10+int(char)\\n            elif char in [\"-\",\"+\"]:\\n                res=res+num*sign\\n                num=0\\n                if char==\"-\":\\n                    sign=-1\\n                else:\\n                    sign=1\\n            elif char==\"(\":\\n                stack.append(res)\\n                stack.append(sign)\\n                sign=1\\n                res=0\\n            elif char==\")\":\\n                res+=sign*num\\n                res*=stack.pop()## process sign\\n                res+=stack.pop() ##process with old value\\n                num=0\\n        \\n        return res+num*sign\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62483,
                "title": "ac-python-solution",
                "content": "    class Solution:\\n    def calculate(self, s):\\n        s = '+(+' + s + ')'\\n        s = s.replace('+-', '-').replace('++', '+') # for the corner case '-5', '+5'\\n        stack = []\\n        for i in s:\\n            if i == ')':\\n                total = 0\\n                while stack[-1] != '(':\\n                    total += int(stack.pop())\\n                stack.pop()\\n                sign = 1 if stack.pop() == '+' else -1\\n                stack.append(sign * total)\\n            elif i.isdigit() and stack[-1][-1] in '+-0123456789':\\n                stack[-1] += i\\n            elif i != ' ':\\n                stack.append(i)\\n        return stack[0]",
                "solutionTags": [],
                "code": "    class Solution:\\n    def calculate(self, s):\\n        s = '+(+' + s + ')'\\n        s = s.replace('+-', '-').replace('++', '+') # for the corner case '-5', '+5'\\n        stack = []\\n        for i in s:\\n            if i == ')':\\n                total = 0\\n                while stack[-1] != '(':\\n                    total += int(stack.pop())\\n                stack.pop()\\n                sign = 1 if stack.pop() == '+' else -1\\n                stack.append(sign * total)\\n            elif i.isdigit() and stack[-1][-1] in '+-0123456789':\\n                stack[-1] += i\\n            elif i != ' ':\\n                stack.append(i)\\n        return stack[0]",
                "codeTag": "Java"
            },
            {
                "id": 3745689,
                "title": "very-easy-to-understand-as-relatable-with-real-math-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**At begining :**  I can\\'t visualize the solution , i thought about a problem **Evaluate Reverse Polish Notation** , can\\'t think beyond this than i search for solution .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Very easy approach** as we do generally we start from begining and we take the value and evaluate it. As we **get \\'(\\'** we put our calculated ans and prev sign to stack as we did in our real math problem . Than in same way start calculating the ans for value untill we **get\\')\\'** .\\n\\n\\nThan after **we first give sign to the value which we calculated inside the bracket** ( for this we push the ans first and than sign ) and after this we add that vlaue with previous one .\\n\\n**This is the same way as we solved our real math problems .**\\n\\n**Plz give your approach in comment , this will very helpful for me**\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n**O(n)** \\nwhere n : length of given string \\n\\n- Space complexity:\\n **O(n)**\\n****Bold**** As i use a stack \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n      stack<int> st;\\n\\n      int sign =1, ans=0;\\n      for(int i=0;i<s.size();i++){\\n          if(s[i]>=\\'0\\'){\\n              int num=0;\\n              while( i<s.size() && s[i]>=\\'0\\')\\n              num = (num *10) +(s[i++] -\\'0\\');\\n              i--;\\n             \\n             ans+=(sign * num);\\n             \\n          }\\n\\n          else if( s[i]== \\'+\\')\\n          sign = 1;\\n          else if(s[i]== \\'-\\')\\n          sign =-1;\\n\\n          else if(s[i]==\\'(\\'){\\n              st.push(ans);\\n              st.push(sign);\\n\\n              ans=0;\\n              sign =1;\\n          }\\n          else if(s[i]== \\')\\'){\\n              ans*=st.top();\\n              st.pop();\\n              ans+=st.top();\\n              st.pop();\\n\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n      stack<int> st;\\n\\n      int sign =1, ans=0;\\n      for(int i=0;i<s.size();i++){\\n          if(s[i]>=\\'0\\'){\\n              int num=0;\\n              while( i<s.size() && s[i]>=\\'0\\')\\n              num = (num *10) +(s[i++] -\\'0\\');\\n              i--;\\n             \\n             ans+=(sign * num);\\n             \\n          }\\n\\n          else if( s[i]== \\'+\\')\\n          sign = 1;\\n          else if(s[i]== \\'-\\')\\n          sign =-1;\\n\\n          else if(s[i]==\\'(\\'){\\n              st.push(ans);\\n              st.push(sign);\\n\\n              ans=0;\\n              sign =1;\\n          }\\n          else if(s[i]== \\')\\'){\\n              ans*=st.top();\\n              st.pop();\\n              ans+=st.top();\\n              st.pop();\\n\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832590,
                "title": "swift-tokenizer",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nTokenizer concept please refer to this post\\n[Stop hating parsing problems and start having fun!](https://leetcode.com/problems/basic-calculator/solutions/2017431/stop-hating-parsing-problems-and-start-having-fun/)\\n\\nSome solution are great, pretty short, beautiful and good performance,\\nbut the more important thing to me is can I remember it in a interview several monthes after?\\n\\nThe concept should be very simple\\nif the number included sign, then the result is the summary of all numbers\\n\\n    1 - 1 = 1 + (-1) \\n\\nSecond thing is I have to deal with long numbers from string\\n\\n    num = num * 10 + digit\\n\\nLast is the expression `1 + 2 - (3 + 4)`\\nwe can treat `(3 + 4)` as another `calculate(\"3+4\")`\\n\\n    1 + 2 - 7\\n\\nAlso, recursive actually is a call stack\\nin this case, recursive is as same as push the existing result to `stack`\\nand proceed from top by `pop` after expression result returned\\n\\nAnd it\\'s easy to find out one information missed when expression back,\\nwe need to cache the `lastSign` in front of expression\\n\\n    1 + 2 - (+ 3 + 4)\\n          ^: last sign\\n\\nExtract parsing logic to Tokenizer seems let code longer,\\nbut each function become simpler which means less mistake in interview\\nerasing the space by replacing also for the same purpose\\nwe always can improve when the interview time is available\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Tokenizer {\\n    let s: String\\n    var index: String.Index\\n    var lastSign = 1 // for expression back\\n    init(_ s: String) {\\n        self.s = s\\n        self.index = s.startIndex\\n    }\\n\\n    func nextNum() -> Int {\\n        var num = 0\\n        var sign = 1\\n        if index < s.endIndex, \"-+\".contains(s[index]) {\\n            if s[index] == \"-\" { sign = -1 }\\n            next()\\n        }\\n        while index < s.endIndex, let n = Int(String(s[index])) {\\n            num = num * 10 + n\\n            next()\\n        }\\n        lastSign = sign\\n        return num * sign\\n    }\\n\\n    func hasNext() -> Bool {\\n        index < s.endIndex\\n    }\\n\\n    func next() {\\n        index = s.index(after: index)\\n    }\\n\\n    func isExpressionStart() -> Bool {\\n        index < s.endIndex && s[index] == \"(\"\\n    }\\n\\n    func isExpressionEnd() -> Bool {\\n        index < s.endIndex && s[index] == \")\"\\n    }\\n}\\n\\nclass Solution {\\n    func calculate(_ s: String) -> Int {\\n        // O(n), can move space handle to tokenizer for improvement\\n        let tokenizer = Tokenizer(s.replacingOccurrences(of: \" \", with: \"\"))\\n        var calculateStack = [Int]()\\n        var signStack = [Int]()\\n        var result = 0\\n        while tokenizer.hasNext() {\\n            result += tokenizer.nextNum()\\n            // -(1+2), nextNum: 0 -> no impact to the result\\n            if tokenizer.isExpressionStart() {\\n                calculateStack.append(result)\\n                signStack.append(tokenizer.lastSign)\\n                result = 0\\n                tokenizer.next()\\n            } else if tokenizer.isExpressionEnd() {\\n                // 1+(1+2), stack: [1], result: 1 + 3\\n                // (1+1), stack: [0], result: 0 + 2\\n                // 2 - 3 + (1 + 4) stack: -1, sign: 1\\n                // 2 - 3 - (1 + 1) stack: -1, sign: -1\\n                result = calculateStack.removeLast() + result * signStack.removeLast()\\n                tokenizer.next()\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Tokenizer {\\n    let s: String\\n    var index: String.Index\\n    var lastSign = 1 // for expression back\\n    init(_ s: String) {\\n        self.s = s\\n        self.index = s.startIndex\\n    }\\n\\n    func nextNum() -> Int {\\n        var num = 0\\n        var sign = 1\\n        if index < s.endIndex, \"-+\".contains(s[index]) {\\n            if s[index] == \"-\" { sign = -1 }\\n            next()\\n        }\\n        while index < s.endIndex, let n = Int(String(s[index])) {\\n            num = num * 10 + n\\n            next()\\n        }\\n        lastSign = sign\\n        return num * sign\\n    }\\n\\n    func hasNext() -> Bool {\\n        index < s.endIndex\\n    }\\n\\n    func next() {\\n        index = s.index(after: index)\\n    }\\n\\n    func isExpressionStart() -> Bool {\\n        index < s.endIndex && s[index] == \"(\"\\n    }\\n\\n    func isExpressionEnd() -> Bool {\\n        index < s.endIndex && s[index] == \")\"\\n    }\\n}\\n\\nclass Solution {\\n    func calculate(_ s: String) -> Int {\\n        // O(n), can move space handle to tokenizer for improvement\\n        let tokenizer = Tokenizer(s.replacingOccurrences(of: \" \", with: \"\"))\\n        var calculateStack = [Int]()\\n        var signStack = [Int]()\\n        var result = 0\\n        while tokenizer.hasNext() {\\n            result += tokenizer.nextNum()\\n            // -(1+2), nextNum: 0 -> no impact to the result\\n            if tokenizer.isExpressionStart() {\\n                calculateStack.append(result)\\n                signStack.append(tokenizer.lastSign)\\n                result = 0\\n                tokenizer.next()\\n            } else if tokenizer.isExpressionEnd() {\\n                // 1+(1+2), stack: [1], result: 1 + 3\\n                // (1+1), stack: [0], result: 0 + 2\\n                // 2 - 3 + (1 + 4) stack: -1, sign: 1\\n                // 2 - 3 - (1 + 1) stack: -1, sign: -1\\n                result = calculateStack.removeLast() + result * signStack.removeLast()\\n                tokenizer.next()\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831465,
                "title": "c-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n\\n        public int Calculate(string s)\\n        {\\n            int result = 0;\\n            int i = 0;\\n            Stack<int> stack = new Stack<int>();\\n            int sign = 1;\\n            int num = 0;\\n            while (i < s.Length)\\n            {\\n                switch (s[i])\\n                {\\n                    case \\'+\\':\\n                        sign = 1;\\n                        break;\\n                    case \\'-\\':\\n                        sign = -1;\\n                        break;\\n                    case \\'(\\':\\n                        stack.Push(result);\\n                        stack.Push(sign);\\n                        result = 0;\\n                        sign = 1;\\n                        break;\\n                    case \\')\\':\\n                        int lastSign = stack.Pop();\\n                        result *= lastSign;\\n                        int lastNum = stack.Pop();\\n                        result += lastNum;\\n\\n                        break;\\n                    case \\' \\':\\n                        break;\\n                    default:\\n                        if (char.IsDigit(s[i]))\\n                        {\\n                            StringBuilder stringBuilder = new StringBuilder();\\n                            stringBuilder.Append(s[i]);\\n                            while (i+1 < s.Length && char.IsDigit(s[i+1]))\\n                            {\\n                                stringBuilder.Append(s[++i]);\\n                            }\\n\\n                            num = int.Parse(stringBuilder.ToString());\\n                            num *= sign;\\n                            result+=num;\\n                            sign = 1;\\n                        }\\n                        break;\\n                }\\n                i++;\\n            }\\n\\n            return result;\\n        }\\n      \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n        public int Calculate(string s)\\n        {\\n            int result = 0;\\n            int i = 0;\\n            Stack<int> stack = new Stack<int>();\\n            int sign = 1;\\n            int num = 0;\\n            while (i < s.Length)\\n            {\\n                switch (s[i])\\n                {\\n                    case \\'+\\':\\n                        sign = 1;\\n                        break;\\n                    case \\'-\\':\\n                        sign = -1;\\n                        break;\\n                    case \\'(\\':\\n                        stack.Push(result);\\n                        stack.Push(sign);\\n                        result = 0;\\n                        sign = 1;\\n                        break;\\n                    case \\')\\':\\n                        int lastSign = stack.Pop();\\n                        result *= lastSign;\\n                        int lastNum = stack.Pop();\\n                        result += lastNum;\\n\\n                        break;\\n                    case \\' \\':\\n                        break;\\n                    default:\\n                        if (char.IsDigit(s[i]))\\n                        {\\n                            StringBuilder stringBuilder = new StringBuilder();\\n                            stringBuilder.Append(s[i]);\\n                            while (i+1 < s.Length && char.IsDigit(s[i+1]))\\n                            {\\n                                stringBuilder.Append(s[++i]);\\n                            }\\n\\n                            num = int.Parse(stringBuilder.ToString());\\n                            num *= sign;\\n                            result+=num;\\n                            sign = 1;\\n                        }\\n                        break;\\n                }\\n                i++;\\n            }\\n\\n            return result;\\n        }\\n      \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831413,
                "title": "python3-using-stack",
                "content": "class Solution:\\n\\n    def calculate(self, s: str) -> int:\\n        sums = 0\\n        i = 0\\n        sign = 1\\n        stack = []\\n        length = len(s)\\n        while i<length:\\n            char = s[i]\\n            if char.isdigit():\\n                val = 0\\n                while i<length and s[i].isdigit():\\n                    val = val*10 + int(s[i])\\n                    i+=1\\n                i-=1\\n                sums+=val*sign\\n                sign = 1\\n            elif char == \\'(\\':\\n                stack.append(sums)\\n                stack.append(sign)\\n                sums,sign = 0,1\\n            elif char == \\')\\':\\n                sums*=stack.pop()\\n                sums+=stack.pop()\\n            elif char ==\\'-\\':\\n                sign*=-1\\n            i+=1\\n            \\n        return sums",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def calculate(self, s: str) -> int:\\n        sums = 0\\n        i = 0\\n        sign = 1\\n        stack = []\\n        length = len(s)\\n        while i<length:\\n            char = s[i]\\n            if char.isdigit():\\n                val = 0\\n                while i<length and s[i].isdigit():\\n                    val = val*10 + int(s[i])\\n                    i+=1\\n                i-=1\\n                sums+=val*sign\\n                sign = 1\\n            elif char == \\'(\\':\\n                stack.append(sums)\\n                stack.append(sign)\\n                sums,sign = 0,1\\n            elif char == \\')\\':\\n                sums*=stack.pop()\\n                sums+=stack.pop()\\n            elif char ==\\'-\\':\\n                sign*=-1\\n            i+=1\\n            \\n        return sums",
                "codeTag": "Java"
            },
            {
                "id": 2744618,
                "title": "standard-method-to-solve-all-basic-calculator-questions",
                "content": "Basic idea is as follows :\\n1. Collect the number and store it in a stack\\n2. Update sign variable when you get \\'+\\' or \\'-\\'\\n3. Recurse whenever you see \\'(\\'\\n4. Return the value whenever you see \\')\\'\\n\\nHere we could have done without stack but I wanted to establish a common implementation for all the 3 Basic calculator implementation.\\n\\n```\\nclass Solution {\\n    \\n    int i;    \\n    public int calculate(String s) {\\n        i = 0;\\n        return recurse(s);\\n    }\\n    \\n    public int recurse(String s) {\\n        int sign = 1;\\n        Stack<Integer> st = new Stack<>();\\n        \\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            if (ch == \\' \\') {\\n                i++;\\n                continue;\\n            }\\n            else if (Character.isDigit(ch)) {\\n                int num = 0;\\n                while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                    num = num*10 + (s.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                st.push((sign*num));\\n            }\\n            else if (ch == \\'+\\' || ch == \\'-\\') {\\n                sign = (ch == \\'+\\') ? 1 : -1;\\n                i++;\\n            }\\n            else if (ch == \\'(\\') {\\n                i++;\\n                int num = recurse(s);\\n                st.push(sign*num);\\n            } \\n            else if (ch == \\')\\') {\\n                i++;\\n                break;\\n            }\\n        }\\n        \\n        int res = 0;\\n        while (!st.isEmpty()) {\\n            res += st.pop();\\n        }\\n        return res;\\n        \\n    }\\n    \\n}\\n```\\n\\nBasic Calculator II : https://leetcode.com/problems/basic-calculator-ii/discuss/2744642/Standard-method-to-solve-all-basic-calculator-questions\\nBasic Calculator III : https://leetcode.com/problems/basic-calculator-iii/discuss/2744645/Standard-method-to-solve-all-basic-calculator-questions",
                "solutionTags": [
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int i;    \\n    public int calculate(String s) {\\n        i = 0;\\n        return recurse(s);\\n    }\\n    \\n    public int recurse(String s) {\\n        int sign = 1;\\n        Stack<Integer> st = new Stack<>();\\n        \\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            if (ch == \\' \\') {\\n                i++;\\n                continue;\\n            }\\n            else if (Character.isDigit(ch)) {\\n                int num = 0;\\n                while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                    num = num*10 + (s.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                st.push((sign*num));\\n            }\\n            else if (ch == \\'+\\' || ch == \\'-\\') {\\n                sign = (ch == \\'+\\') ? 1 : -1;\\n                i++;\\n            }\\n            else if (ch == \\'(\\') {\\n                i++;\\n                int num = recurse(s);\\n                st.push(sign*num);\\n            } \\n            else if (ch == \\')\\') {\\n                i++;\\n                break;\\n            }\\n        }\\n        \\n        int res = 0;\\n        while (!st.isEmpty()) {\\n            res += st.pop();\\n        }\\n        return res;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671982,
                "title": "python-simple-solutions-stack-98",
                "content": "\\u2714\\uFE0F Solution\\nComplexity\\nNow time complexity it is O(n), space is still O(n).\\n\\n```class Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        p = 0\\n        sign = 1\\n        total = 0\\n        while p < len(s):\\n            char = s[p]\\n            if char.isdigit():\\n                num = 0\\n                while p < len(s) and s[p].isdigit():\\n                    num = num*10 + int(s[p])\\n                    p += 1\\n                p -= 1\\n                num *= sign\\n                total += num\\n                sign = 1\\n            elif char == \\'(\\':\\n                stack.append(total)\\n                stack.append(sign)\\n                total, sign = 0, 1\\n            elif char == \\')\\':\\n                total *= stack.pop()\\n                total += stack.pop()\\n            elif char == \\'-\\':\\n                sign = -1\\n            p += 1\\n        return total\\n\\n```\\n\\n# ****\\u2714\\uFE0F UP VOTE IF HELPFUL",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```class Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        p = 0\\n        sign = 1\\n        total = 0\\n        while p < len(s):\\n            char = s[p]\\n            if char.isdigit():\\n                num = 0\\n                while p < len(s) and s[p].isdigit():\\n                    num = num*10 + int(s[p])\\n                    p += 1\\n                p -= 1\\n                num *= sign\\n                total += num\\n                sign = 1\\n            elif char == \\'(\\':\\n                stack.append(total)\\n                stack.append(sign)\\n                total, sign = 0, 1\\n            elif char == \\')\\':\\n                total *= stack.pop()\\n                total += stack.pop()\\n            elif char == \\'-\\':\\n                sign = -1\\n            p += 1\\n        return total\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274264,
                "title": "python-solution-beats-97",
                "content": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        operand = 0\\n        res = 0 # for the ongoing result\\n        sign = 1 # 1 means +ve, -1 means -ve\\n        \\n        for ch in s:\\n            if ch.isdigit():\\n                operand = operand * 10 + int(ch)\\n            \\n            \\n            elif ch == \\'+\\':\\n                #evaluate expression to the left\\n                res += sign * operand\\n                #save the sign\\n                sign = 1\\n                #reset operand\\n                operand = 0\\n            elif ch == \\'-\\':\\n                res += sign * operand\\n                sign = -1\\n                operand  = 0\\n            \\n            elif ch == \\'(\\':\\n                #push the result and then the sign\\n                stack.append(res)\\n                stack.append(sign)\\n                sign = 1\\n                res = 0\\n            \\n            elif ch == \\')\\':\\n                res += sign * operand\\n                res *= stack.pop()\\n                res += stack.pop()\\n                operand = 0\\n        return res + sign*operand\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        operand = 0\\n        res = 0 # for the ongoing result\\n        sign = 1 # 1 means +ve, -1 means -ve\\n        \\n        for ch in s:\\n            if ch.isdigit():\\n                operand = operand * 10 + int(ch)\\n            \\n            \\n            elif ch == \\'+\\':\\n                #evaluate expression to the left\\n                res += sign * operand\\n                #save the sign\\n                sign = 1\\n                #reset operand\\n                operand = 0\\n            elif ch == \\'-\\':\\n                res += sign * operand\\n                sign = -1\\n                operand  = 0\\n            \\n            elif ch == \\'(\\':\\n                #push the result and then the sign\\n                stack.append(res)\\n                stack.append(sign)\\n                sign = 1\\n                res = 0\\n            \\n            elif ch == \\')\\':\\n                res += sign * operand\\n                res *= stack.pop()\\n                res += stack.pop()\\n                operand = 0\\n        return res + sign*operand\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880227,
                "title": "shunting-yard-algorithm-with-unary-reverse-polish-notation-rpn-java",
                "content": "Here\\'s my basic implementation of the Shunting Yard algorithm - https://en.wikipedia.org/wiki/Shunting-yard_algorithm - to convert an infix expression to postfix expression or Reverse Polish Notation (RPN) - https://en.wikipedia.org/wiki/Reverse_Polish_notation - and then evaluating the result. This also handles the unary operator. The same logic can be used for all 3 basic calculator problems - I, II, and III:\\n\\n```\\nclass Solution {\\n    public int calculate(String s) {        \\n        // Shunting Yard algorithm implementation\\n        Queue<String> queue = new ArrayDeque();\\n        Deque<Character> stack = new ArrayDeque();\\n        int len = s.length();        \\n        boolean checkUnary = true;\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (Character.isWhitespace(c))\\n                continue;\\n            \\n            if (checkUnary) {\\n                checkUnary = false;\\n                if (c == \\'+\\' || c == \\'-\\')\\n                    queue.add(\"0\");\\n            }\\n            \\n            if (Character.isDigit(c)) {\\n                int num = c - \\'0\\';\\n                while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n                    num = num * 10 + s.charAt(i + 1) - \\'0\\';\\n                    i++;\\n                }\\n                queue.add(String.valueOf(num));\\n            } else if (c == \\'(\\') {\\n                checkUnary = true;\\n                stack.push(c);\\n            } else if (c == \\')\\') {\\n                while (stack.peek() != \\'(\\')\\n                    queue.add(String.valueOf(stack.pop()));\\n                \\n                stack.pop();\\n            } else {\\n                while (!stack.isEmpty() && stack.peek() != \\'(\\' && getPrecedence(c) <= getPrecedence(stack.peek()))\\n                    queue.add(String.valueOf(stack.pop()));\\n                      \\n                stack.push(c);\\n            }\\n        }\\n        \\n        while (!stack.isEmpty())\\n            queue.add(String.valueOf(stack.pop())); \\n        \\n        // Elements in the queue are now set up in Reverse-Polish notation (RPN)\\n        // So \"2*(5+5*2)/3+(6/2+8)\" is now \"2 5 5 2 * + * 3 / 6 2 / 8 + +\"\\n        \\n        // Evaluate RPN to get the result\\n        return evaluateRPN(queue);\\n    }\\n    \\n    // Operator precedence - PEMDAS rule. All 4 have same left-associativity.\\n    private int getPrecedence(char c) {\\n        if (c == \\'*\\' || c == \\'/\\')\\n            return 2;\\n        else // \\'+\\' or \\'-\\'\\n            return 1;\\n    }\\n    \\n    private int evaluateRPN(Queue<String> queue) {        \\n        Deque<Integer> numstack = new ArrayDeque();\\n        int first = 0, second = 0;\\n        while (!queue.isEmpty()) {\\n            String token = queue.poll();\\n            if (token.equals(\"+\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first + second);\\n            } else if (token.equals(\"-\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first - second);\\n            } else if (token.equals(\"*\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first * second);\\n            } else if (token.equals(\"/\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first / second);\\n            } else\\n                numstack.push(Integer.valueOf(token));\\n        }\\n        return numstack.pop();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {        \\n        // Shunting Yard algorithm implementation\\n        Queue<String> queue = new ArrayDeque();\\n        Deque<Character> stack = new ArrayDeque();\\n        int len = s.length();        \\n        boolean checkUnary = true;\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (Character.isWhitespace(c))\\n                continue;\\n            \\n            if (checkUnary) {\\n                checkUnary = false;\\n                if (c == \\'+\\' || c == \\'-\\')\\n                    queue.add(\"0\");\\n            }\\n            \\n            if (Character.isDigit(c)) {\\n                int num = c - \\'0\\';\\n                while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n                    num = num * 10 + s.charAt(i + 1) - \\'0\\';\\n                    i++;\\n                }\\n                queue.add(String.valueOf(num));\\n            } else if (c == \\'(\\') {\\n                checkUnary = true;\\n                stack.push(c);\\n            } else if (c == \\')\\') {\\n                while (stack.peek() != \\'(\\')\\n                    queue.add(String.valueOf(stack.pop()));\\n                \\n                stack.pop();\\n            } else {\\n                while (!stack.isEmpty() && stack.peek() != \\'(\\' && getPrecedence(c) <= getPrecedence(stack.peek()))\\n                    queue.add(String.valueOf(stack.pop()));\\n                      \\n                stack.push(c);\\n            }\\n        }\\n        \\n        while (!stack.isEmpty())\\n            queue.add(String.valueOf(stack.pop())); \\n        \\n        // Elements in the queue are now set up in Reverse-Polish notation (RPN)\\n        // So \"2*(5+5*2)/3+(6/2+8)\" is now \"2 5 5 2 * + * 3 / 6 2 / 8 + +\"\\n        \\n        // Evaluate RPN to get the result\\n        return evaluateRPN(queue);\\n    }\\n    \\n    // Operator precedence - PEMDAS rule. All 4 have same left-associativity.\\n    private int getPrecedence(char c) {\\n        if (c == \\'*\\' || c == \\'/\\')\\n            return 2;\\n        else // \\'+\\' or \\'-\\'\\n            return 1;\\n    }\\n    \\n    private int evaluateRPN(Queue<String> queue) {        \\n        Deque<Integer> numstack = new ArrayDeque();\\n        int first = 0, second = 0;\\n        while (!queue.isEmpty()) {\\n            String token = queue.poll();\\n            if (token.equals(\"+\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first + second);\\n            } else if (token.equals(\"-\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first - second);\\n            } else if (token.equals(\"*\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first * second);\\n            } else if (token.equals(\"/\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first / second);\\n            } else\\n                numstack.push(Integer.valueOf(token));\\n        }\\n        return numstack.pop();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662949,
                "title": "python-actually-working-shunting-yard-that-passes-all-edge-cases",
                "content": "Many of the existing shunting yard examples do not pass all edge cases. This is a working example, in python, of how we can get it to pass 100%. The problem with the textbook wikipedia implementation and many solutions is we don\\'t treat `-4` separately from `5-4`. So we parse every `-` as an operator, but in some cases, this is not true. \\n\\nWe have two choices on how to move forward:\\n\\n1. Handle unary operators separately\\n2. Massage the string to remove all unary operators\\n\\nI chose option 2, but ideally option 1 is the right answer. \\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        if not s:\\n            return 0\\n        \\n        sanitized = self.sanitize_string(s)\\n        \\n        converted = self.convert_postfix(sanitized)\\n        \\n        return self.process_postfix(converted)\\n    \\n    def convert_postfix(self, tokens: List[str]) -> List[str]:\\n        ans = []\\n        stack = []\\n        # both of the ones below can be extended to support many operation types (*/** etc)\\n        ops = [\"+\", \"-\"]\\n        precedence = { \\'+\\': 1, \\'-\\': 1 }\\n        \\n        for ch in tokens:\\n            if ch.isdigit():\\n                ans.append(ch)\\n            elif ch in ops:\\n                while stack and stack[-1] != \"(\" and precedence[stack[-1]] >= precedence[ch]:\\n                    ans.append(stack.pop())\\n                    \\n                stack.append(ch)\\n            elif ch == \"(\":\\n                stack.append(ch)\\n            elif ch == \")\":\\n                while stack and stack[-1] != \"(\":\\n                    ans.append(stack.pop())\\n                \\n                if stack and stack[-1] == \"(\":\\n                    stack.pop()\\n        while stack:\\n            ans.append(stack.pop())\\n        \\n        return ans\\n        \\n    \\n    def process_postfix(self, tokens: List[str]) -> int:\\n        stack = []\\n        ops = [\"+\", \"-\"]\\n        \\n        for token in tokens:\\n            if token not in ops:\\n                # normal digit\\n                stack.append(token)\\n            else:\\n                # operator\\n                op1 = int(stack.pop())\\n                op2 = int(stack.pop())\\n                \\n                if token == \"+\":\\n                    stack.append(op2 + op1)\\n                elif token == \"-\":\\n                    stack.append(op2 - op1)     \\n\\n        return stack.pop()\\n    \\n    \"\"\"\\n        this is needed to create valid postfix expressions for shunting yard\\n        eg: 1 - (-2) creates a postfix of 1 2 - - which is invalid\\n        instead we convert to 1 0 2 - -\\n    \"\"\"\\n    def sanitize_string(self, s: str) -> List[str]:\\n        # trim whitespace around string\\n        s = s.strip()\\n        \\n        # convert starting - to 0 - X\\n        if s[0] == \"-\":\\n            s = \"0\" + s\\n        \\n        # convert this to create a valid postfix express\\n        s = s.replace(\"(-\", \"(0-\")\\n        \\n        # create space around for splits\\n        for op in \"+-()\":\\n            s = s.replace(op, \\' \\' + op + \\' \\')\\n        \\n        return s.split()\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        if not s:\\n            return 0\\n        \\n        sanitized = self.sanitize_string(s)\\n        \\n        converted = self.convert_postfix(sanitized)\\n        \\n        return self.process_postfix(converted)\\n    \\n    def convert_postfix(self, tokens: List[str]) -> List[str]:\\n        ans = []\\n        stack = []\\n        # both of the ones below can be extended to support many operation types (*/** etc)\\n        ops = [\"+\", \"-\"]\\n        precedence = { \\'+\\': 1, \\'-\\': 1 }\\n        \\n        for ch in tokens:\\n            if ch.isdigit():\\n                ans.append(ch)\\n            elif ch in ops:\\n                while stack and stack[-1] != \"(\" and precedence[stack[-1]] >= precedence[ch]:\\n                    ans.append(stack.pop())\\n                    \\n                stack.append(ch)\\n            elif ch == \"(\":\\n                stack.append(ch)\\n            elif ch == \")\":\\n                while stack and stack[-1] != \"(\":\\n                    ans.append(stack.pop())\\n                \\n                if stack and stack[-1] == \"(\":\\n                    stack.pop()\\n        while stack:\\n            ans.append(stack.pop())\\n        \\n        return ans\\n        \\n    \\n    def process_postfix(self, tokens: List[str]) -> int:\\n        stack = []\\n        ops = [\"+\", \"-\"]\\n        \\n        for token in tokens:\\n            if token not in ops:\\n                # normal digit\\n                stack.append(token)\\n            else:\\n                # operator\\n                op1 = int(stack.pop())\\n                op2 = int(stack.pop())\\n                \\n                if token == \"+\":\\n                    stack.append(op2 + op1)\\n                elif token == \"-\":\\n                    stack.append(op2 - op1)     \\n\\n        return stack.pop()\\n    \\n    \"\"\"\\n        this is needed to create valid postfix expressions for shunting yard\\n        eg: 1 - (-2) creates a postfix of 1 2 - - which is invalid\\n        instead we convert to 1 0 2 - -\\n    \"\"\"\\n    def sanitize_string(self, s: str) -> List[str]:\\n        # trim whitespace around string\\n        s = s.strip()\\n        \\n        # convert starting - to 0 - X\\n        if s[0] == \"-\":\\n            s = \"0\" + s\\n        \\n        # convert this to create a valid postfix express\\n        s = s.replace(\"(-\", \"(0-\")\\n        \\n        # create space around for splits\\n        for op in \"+-()\":\\n            s = s.replace(op, \\' \\' + op + \\' \\')\\n        \\n        return s.split()\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477423,
                "title": "java-stack-iterative-solution-o-n-time-o-n-space",
                "content": "\\n```\\n  public int calculate(String s) {\\n\\n    Deque<Integer> signs = new ArrayDeque<>();\\n    signs.add(1);\\n\\n    int result = 0;\\n    int sign = 1;\\n\\n    int curr = 0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n      char currChar = s.charAt(i);\\n\\n      if (Character.isDigit(currChar)) {\\n        curr *= 10;\\n        curr += Character.getNumericValue(currChar);\\n      } else {\\n        result += curr * sign;\\n        curr = 0;\\n      }\\n\\n      if (currChar == \\'-\\') {\\n        sign = signs.peek() * -1;\\n      } else if (currChar == \\'+\\') {\\n        sign = signs.peek();\\n      } else if (currChar == \\'(\\') {\\n        signs.push(sign);\\n      } else if (currChar == \\')\\') {\\n        signs.pop();\\n      }\\n    }\\n\\n    return result + curr * sign;\\n  }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n  public int calculate(String s) {\\n\\n    Deque<Integer> signs = new ArrayDeque<>();\\n    signs.add(1);\\n\\n    int result = 0;\\n    int sign = 1;\\n\\n    int curr = 0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n      char currChar = s.charAt(i);\\n\\n      if (Character.isDigit(currChar)) {\\n        curr *= 10;\\n        curr += Character.getNumericValue(currChar);\\n      } else {\\n        result += curr * sign;\\n        curr = 0;\\n      }\\n\\n      if (currChar == \\'-\\') {\\n        sign = signs.peek() * -1;\\n      } else if (currChar == \\'+\\') {\\n        sign = signs.peek();\\n      } else if (currChar == \\'(\\') {\\n        signs.push(sign);\\n      } else if (currChar == \\')\\') {\\n        signs.pop();\\n      }\\n    }\\n\\n    return result + curr * sign;\\n  }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698175,
                "title": "java-clean-code-easy-to-understand-o-n-time-complexity-4-ms-time-95-faster",
                "content": "```\\nclass Solution {\\n \\n\\tpublic int calculate (String s) {\\n\\t\\t\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tint evaluation = 0;\\n\\t\\tint operand = 0;\\n\\t\\tint sign = 1;\\n \\n\\t\\tfor (char c : s.toCharArray ()) {\\n\\t\\t\\tif (Character.isDigit (c)) {\\n\\t\\t\\t\\toperand = operand * 10 + c - \\'0\\';\\n\\t\\t\\t}\\n\\t\\t\\telse if (c == \\'+\\') {\\n\\t\\t\\t\\tevaluation += sign * operand;\\n\\t\\t\\t\\toperand = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (c == \\'-\\') {\\n\\t\\t\\t\\tevaluation += sign * operand;\\n\\t\\t\\t\\tsign = -1;\\n\\t\\t\\t\\toperand = 0;\\n\\t\\t\\t}\\n \\n\\t\\t\\telse if (c == \\'(\\') {\\n\\t\\t\\t\\tstack.push (evaluation);\\n\\t\\t\\t\\tstack.push (sign);\\n\\t\\t\\t\\tevaluation = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (c == \\')\\') {\\n\\t\\t\\t\\tevaluation += sign * operand;\\n\\t\\t\\t\\tevaluation *= stack.pop ();\\n\\t\\t\\t\\tevaluation += stack.pop ();\\n\\t\\t\\t\\toperand = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n \\n\\t\\treturn evaluation + sign * operand;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n \\n\\tpublic int calculate (String s) {\\n\\t\\t\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tint evaluation = 0;\\n\\t\\tint operand = 0;\\n\\t\\tint sign = 1;\\n \\n\\t\\tfor (char c : s.toCharArray ()) {\\n\\t\\t\\tif (Character.isDigit (c)) {\\n\\t\\t\\t\\toperand = operand * 10 + c - \\'0\\';\\n\\t\\t\\t}\\n\\t\\t\\telse if (c == \\'+\\') {\\n\\t\\t\\t\\tevaluation += sign * operand;\\n\\t\\t\\t\\toperand = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (c == \\'-\\') {\\n\\t\\t\\t\\tevaluation += sign * operand;\\n\\t\\t\\t\\tsign = -1;\\n\\t\\t\\t\\toperand = 0;\\n\\t\\t\\t}\\n \\n\\t\\t\\telse if (c == \\'(\\') {\\n\\t\\t\\t\\tstack.push (evaluation);\\n\\t\\t\\t\\tstack.push (sign);\\n\\t\\t\\t\\tevaluation = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (c == \\')\\') {\\n\\t\\t\\t\\tevaluation += sign * operand;\\n\\t\\t\\t\\tevaluation *= stack.pop ();\\n\\t\\t\\t\\tevaluation += stack.pop ();\\n\\t\\t\\t\\toperand = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n \\n\\t\\treturn evaluation + sign * operand;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368944,
                "title": "c-two-stacks-solution-with-clear-explanations",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        // Stack to store numbers\\n        stack<int> nums;\\n        \\n        // Stack to store operators\\n        stack<char> ops;\\n        \\n        for(int i=0; i<s.size(); ++i) {\\n            char ch = s[i];\\n            \\n            // If current is space, skip it\\n            if(ch == \\' \\') continue;\\n            \\n            // If current is a number\\n            else if(isdigit(ch)) {\\n                // Long type to prevent integer overflow\\n                long num = 0;\\n                \\n                while(i<s.size() && isdigit(s[i])) {\\n                    num = num * 10 + s[i] - \\'0\\';\\n                    ++i;\\n                }\\n                nums.push(num);\\n                --i;\\n            }\\n            // If current is left bracket\\n            else if(ch == \\'(\\') ops.push(ch);\\n            \\n            // If current is right bracket\\n            // Solve entire bracket\\n            else if(ch == \\')\\') {\\n                while(!ops.empty() && ops.top() != \\'(\\') {\\n                    int num2 = nums.top();\\n                    nums.pop();\\n                    int num1 = nums.top();\\n                    nums.pop();\\n\\n                    int out = applyOp(num1, num2, ops.top());\\n                    ops.pop();\\n                    nums.push(out);\\n                }\\n                // Pop left bracket\\n                ops.pop();\\n                \\n            }\\n            // If current is an operator\\n            else {\\n                // While top of \\'ops\\' has same or greater  \\n                // precedence to current token, which \\n                // is an operator. Apply operator on top  \\n                // of \\'ops\\' to top two elements in nums stack. \\n                while(!ops.empty() && precedence(ops.top()) >= precedence(ch)) {\\n                    int num2 = nums.top();\\n                    nums.pop();\\n                    int num1 = nums.top();\\n                    nums.pop();\\n\\n                    int out = applyOp(num1, num2, ops.top());\\n                    ops.pop();\\n                    nums.push(out);\\n                }\\n                ops.push(ch);\\n            }\\n        }\\n        \\n        // Entire expression has been parsed at this \\n        // point, apply remaining ops to remaining \\n        // values. \\n        while(!ops.empty()) {\\n            int num2 = nums.top();\\n            nums.pop();\\n            int num1 = nums.top();\\n            nums.pop();\\n\\n            int out = applyOp(num1, num2, ops.top());\\n            ops.pop();\\n            \\n            nums.push(out);\\n        }\\n        \\n        return nums.top();\\n    }\\n    \\n    int applyOp(int a, int b, char op) {\\n        int out = 0;\\n        \\n        switch(op){ \\n            case \\'+\\': out = a + b; break;\\n            case \\'-\\': out = a - b; break;\\n            case \\'*\\': out = a * b; break;\\n            case \\'/\\': out = a / b; break;\\n        }\\n        return out;\\n    }\\n    \\n    int precedence(char op) {\\n        if(op == \\'+\\' || op == \\'-\\') return 1;\\n        else if (op == \\'*\\' || op == \\'/\\') return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        // Stack to store numbers\\n        stack<int> nums;\\n        \\n        // Stack to store operators\\n        stack<char> ops;\\n        \\n        for(int i=0; i<s.size(); ++i) {\\n            char ch = s[i];\\n            \\n            // If current is space, skip it\\n            if(ch == \\' \\') continue;\\n            \\n            // If current is a number\\n            else if(isdigit(ch)) {\\n                // Long type to prevent integer overflow\\n                long num = 0;\\n                \\n                while(i<s.size() && isdigit(s[i])) {\\n                    num = num * 10 + s[i] - \\'0\\';\\n                    ++i;\\n                }\\n                nums.push(num);\\n                --i;\\n            }\\n            // If current is left bracket\\n            else if(ch == \\'(\\') ops.push(ch);\\n            \\n            // If current is right bracket\\n            // Solve entire bracket\\n            else if(ch == \\')\\') {\\n                while(!ops.empty() && ops.top() != \\'(\\') {\\n                    int num2 = nums.top();\\n                    nums.pop();\\n                    int num1 = nums.top();\\n                    nums.pop();\\n\\n                    int out = applyOp(num1, num2, ops.top());\\n                    ops.pop();\\n                    nums.push(out);\\n                }\\n                // Pop left bracket\\n                ops.pop();\\n                \\n            }\\n            // If current is an operator\\n            else {\\n                // While top of \\'ops\\' has same or greater  \\n                // precedence to current token, which \\n                // is an operator. Apply operator on top  \\n                // of \\'ops\\' to top two elements in nums stack. \\n                while(!ops.empty() && precedence(ops.top()) >= precedence(ch)) {\\n                    int num2 = nums.top();\\n                    nums.pop();\\n                    int num1 = nums.top();\\n                    nums.pop();\\n\\n                    int out = applyOp(num1, num2, ops.top());\\n                    ops.pop();\\n                    nums.push(out);\\n                }\\n                ops.push(ch);\\n            }\\n        }\\n        \\n        // Entire expression has been parsed at this \\n        // point, apply remaining ops to remaining \\n        // values. \\n        while(!ops.empty()) {\\n            int num2 = nums.top();\\n            nums.pop();\\n            int num1 = nums.top();\\n            nums.pop();\\n\\n            int out = applyOp(num1, num2, ops.top());\\n            ops.pop();\\n            \\n            nums.push(out);\\n        }\\n        \\n        return nums.top();\\n    }\\n    \\n    int applyOp(int a, int b, char op) {\\n        int out = 0;\\n        \\n        switch(op){ \\n            case \\'+\\': out = a + b; break;\\n            case \\'-\\': out = a - b; break;\\n            case \\'*\\': out = a * b; break;\\n            case \\'/\\': out = a / b; break;\\n        }\\n        return out;\\n    }\\n    \\n    int precedence(char op) {\\n        if(op == \\'+\\' || op == \\'-\\') return 1;\\n        else if (op == \\'*\\' || op == \\'/\\') return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190148,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        for ch in [\\'+\\', \\'-\\', \\'(\\', \\')\\']:\\n            s = s.replace(ch, \\' \\' + ch + \\' \\')\\n\\n        sign = 1\\n        stack = [0]\\n        for each in s.split():\\n            if each in [\\'+\\', \\'-\\']:\\n                sign = [1, -1][each == \\'-\\']\\n            elif each == \\'(\\':\\n                stack.extend([sign, 0])\\n                sign = 1\\n            elif each == \\')\\':\\n                value = stack.pop() * stack.pop()\\n                stack[-1] += value\\n            else:\\n                stack[-1] += sign * int(each)\\n        return stack[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        for ch in [\\'+\\', \\'-\\', \\'(\\', \\')\\']:\\n            s = s.replace(ch, \\' \\' + ch + \\' \\')\\n\\n        sign = 1\\n        stack = [0]\\n        for each in s.split():\\n            if each in [\\'+\\', \\'-\\']:\\n                sign = [1, -1][each == \\'-\\']\\n            elif each == \\'(\\':\\n                stack.extend([sign, 0])\\n                sign = 1\\n            elif each == \\')\\':\\n                value = stack.pop() * stack.pop()\\n                stack[-1] += value\\n            else:\\n                stack[-1] += sign * int(each)\\n        return stack[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62401,
                "title": "general-kill-reverse-polish-notation",
                "content": "This kind of problems has a general kill. First [convert the infix notation into postfix notation](https://en.wikipedia.org/wiki/Shunting-yard_algorithm), and then [compute the postfix notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation).\\n\\n```\\nfrom collections import deque\\n\\n\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        def infix_to_postfix(s):\\n            S = deque()\\n            t = []\\n            n = len(s)\\n            i = 0\\n            while i < n:\\n                c = s[i]\\n                if c.isdigit():\\n                    j = i\\n                    while j < n and s[j].isdigit():\\n                        j += 1\\n                    t.append(s[i:j])\\n                    i = j\\n                elif c == '(':\\n                    S.append(c)\\n                    i += 1\\n                elif c == ')':\\n                    while S[-1] != '(':\\n                        t.append(S.pop())\\n                    S.pop()\\n                    i += 1\\n                else:  # operators\\n                    while S and S[-1] != '(' and w[S[-1]] >= w[c]:\\n                        t.append(S.pop())\\n                    S.append(c)\\n                    i += 1\\n            while S:\\n                t.append(S.pop())\\n            return t\\n\\n        def eval_postfix(t):\\n            S = deque()\\n            for item in t:\\n                if item[0].isdigit():\\n                    S.append(item)\\n                else:\\n                    op2 = int(S.pop())\\n                    op1 = int(S.pop())\\n                    if item == '+':\\n                        S.append(op1+op2)\\n                    elif item == '-':\\n                        S.append(op1-op2)\\n                    else:  # *\\n                        S.append(op1*op2)\\n            return int(S[-1])\\n\\n        s = s.replace(' ', '')\\n        if not s:\\n            return 0\\n        w = {'+': 1, '-': 1, '*': 2}\\n        return eval_postfix(infix_to_postfix(s))\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\n\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        def infix_to_postfix(s):\\n            S = deque()\\n            t = []\\n            n = len(s)\\n            i = 0\\n            while i < n:\\n                c = s[i]\\n                if c.isdigit():\\n                    j = i\\n                    while j < n and s[j].isdigit():\\n                        j += 1\\n                    t.append(s[i:j])\\n                    i = j\\n                elif c == '(':\\n                    S.append(c)\\n                    i += 1\\n                elif c == ')':\\n                    while S[-1] != '(':\\n                        t.append(S.pop())\\n                    S.pop()\\n                    i += 1\\n                else:  # operators\\n                    while S and S[-1] != '(' and w[S[-1]] >= w[c]:\\n                        t.append(S.pop())\\n                    S.append(c)\\n                    i += 1\\n            while S:\\n                t.append(S.pop())\\n            return t\\n\\n        def eval_postfix(t):\\n            S = deque()\\n            for item in t:\\n                if item[0].isdigit():\\n                    S.append(item)\\n                else:\\n                    op2 = int(S.pop())\\n                    op1 = int(S.pop())\\n                    if item == '+':\\n                        S.append(op1+op2)\\n                    elif item == '-':\\n                        S.append(op1-op2)\\n                    else:  # *\\n                        S.append(op1*op2)\\n            return int(S[-1])\\n\\n        s = s.replace(' ', '')\\n        if not s:\\n            return 0\\n        w = {'+': 1, '-': 1, '*': 2}\\n        return eval_postfix(infix_to_postfix(s))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62465,
                "title": "python-192ms-solution-with-stack",
                "content": "    class Solution(object):\\n        def calculate(self, s):\\n            nums = []\\n            sign = 1\\n            num = 0\\n            rst = 0\\n        \\n            for c in s:\\n                if c.isdigit():\\n                    num = num*10 + int(c)\\n                    continue\\n                rst += sign*num\\n                num = 0\\n            \\n                if c == \"-\": sign = -1\\n                elif c == \"+\": sign = 1\\n                elif c == \"(\":\\n                    nums.append(rst)\\n                    nums.append(sign)\\n                    sign = 1\\n                    rst = 0\\n                elif c == \")\":\\n                    rst *= nums.pop()\\n                    rst += nums.pop()\\n\\n            return rst + sign * num",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def calculate(self, s):\\n            nums = []\\n            sign = 1\\n            num = 0\\n            rst = 0\\n        \\n            for c in s:\\n                if c.isdigit():\\n                    num = num*10 + int(c)\\n                    continue\\n                rst += sign*num\\n                num = 0\\n            \\n                if c == \"-\": sign = -1\\n                elif c == \"+\": sign = 1\\n                elif c == \"(\":\\n                    nums.append(rst)\\n                    nums.append(sign)\\n                    sign = 1\\n                    rst = 0\\n                elif c == \")\":\\n                    rst *= nums.pop()\\n                    rst += nums.pop()\\n\\n            return rst + sign * num",
                "codeTag": "Java"
            },
            {
                "id": 62488,
                "title": "1-pass-o-n-c-solution",
                "content": "A plus sign can be ignored since it has no effect.\\nA minus sign negates the signs contained within a pair of parentheses. \\n\\nA ')' matches the nearest '(', so we can use a stack structure to keep track of the negation context.\\nWhen we encounter '(', save the current context and negate it.\\nWhen ')', restore the previous context.\\n\\n    #include<cstdlib>\\n    #include<string>\\n    #include<vector>\\n    using namespace std;\\n    class Solution {\\n    public:\\n        int calculate(string s) {\\n            typedef long long ll;\\n            vector<int> ctx;\\n            int contextNumberMult = 1;\\n            int localNumberMult = 1;\\n            int ans=0;\\n            for (const char *x = s.c_str();*x;x++){\\n                switch(*x){\\n                case '-':\\n                    localNumberMult = -1;\\n                    break;\\n                case '(':\\n                    contextNumberMult *= localNumberMult;\\n                    ctx.push_back(localNumberMult);\\n                    localNumberMult = 1;\\n                    break;\\n                case ')':\\n                    contextNumberMult *= ctx.back();\\n                    ctx.pop_back();\\n                case ' ':\\n                case '+':\\n                    break;\\n                default:{\\n                    char *end;\\n                    ll n=strtol(x,&end,10);\\n                    ans += n * contextNumberMult  * localNumberMult ;\\n                    localNumberMult = 1;\\n                    x = end-1;\\n                }}\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int calculate(string s) {\\n            typedef long long ll;\\n            vector<int> ctx;\\n            int contextNumberMult = 1;\\n            int localNumberMult = 1;\\n            int ans=0;\\n            for (const char *x = s.c_str();*x;x++){\\n                switch(*x){\\n                case '-':\\n                    localNumberMult = -1;\\n                    break;\\n                case '(':\\n                    contextNumberMult *= localNumberMult;\\n                    ctx.push_back(localNumberMult);\\n                    localNumberMult = 1;\\n                    break;\\n                case ')':\\n                    contextNumberMult *= ctx.back();\\n                    ctx.pop_back();\\n                case ' ':\\n                case '+':\\n                    break;\\n                default:{\\n                    char *end;\\n                    ll n=strtol(x,&end,10);\\n                    ans += n * contextNumberMult  * localNumberMult ;\\n                    localNumberMult = 1;\\n                    x = end-1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3871086,
                "title": "simple-solution-using-stack-and-without-recursion",
                "content": "# Intuition\\nExpression inside the brackets should be evaluated first.\\n# Approach\\nTo solve this problem, first you need to have knowledge to make a calculator without brackets.\\n\\nHere: -\\nFunction \"solve\" just solve any regular expression like: -\\n 21 + 3 - 6;\\nThis function doesn\\'t get \"(\" and \")\" as input.\\n\\nSteps: -\\n1. First convert all the numbers, brackets, operators into     string and store in a vector.\\n2. Traverse the vector from left to right and when we encounter \")\" search for \"(\" in the stack and store strings between these brackets in a different vector.\\n3. Call for solve function with this vector.\\n4. continue this until no brackets remains.\\n5. at last a simple expression will be there without any brackets, call for solve and return this.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2).\\n- Space complexity:\\nO(n).\\n# Code\\n```\\nclass Solution {\\npublic:\\n  string solve(vector<string>v){\\n    stack<string>st;\\n    for(int i=0;i<v.size();i++){\\n      if(v[i] == \"-\"){\\n        int x = 0;\\n        if(st.empty() == false){\\n          x = stoi(st.top());\\n          st.pop();\\n        }\\n        int y = stoi(v[i+1]);\\n        st.push(to_string(x-y));\\n        i++;\\n      }else if(v[i] ==\"+\"){\\n        int x = 0;\\n        if(st.empty() == false){\\n          x = stoi(st.top());\\n          st.pop();\\n        }\\n        int y = stoi(v[i+1]);\\n        st.push(to_string(x+y));\\n        i++;\\n      }else{\\n        st.push(v[i]);\\n      }\\n    }\\n    return st.top();\\n  }\\n  int calculate(string s) {\\n    vector<string>nums;\\n    string temp;\\n//--------------------------------------------------//\\n/*\\n  removed unnecessary spaces and converted each element to \\n  string and stored in a vector.\\n*/\\n    for(int i=0;i<s.size();i++){\\n      if(s[i] == \\' \\'){\\n        continue;\\n      }\\n      if(isdigit(s[i])){\\n        temp += s[i];\\n      }else{\\n        if(temp.empty() == false){\\n          nums.push_back(temp);\\n        }\\n        string t;\\n        t += s[i];\\n        nums.push_back(t);\\n        temp.clear();\\n      }\\n    }\\n    if(temp.empty() == false){\\n      nums.push_back(temp);\\n    }\\n//--------------------------------------------------//\\n    stack<string>st;\\n    for(int i=0;i<nums.size();i++){\\n      vector<string>t;\\n      if(nums[i] == \")\"){\\n        while(st.empty() == false && st.top() != \"(\"){\\n          t.push_back(st.top());\\n          st.pop();\\n        }\\n        st.pop();\\n        reverse(t.begin(),t.end());\\n        string ans = solve(t);\\n        st.push(ans);\\n      }else{\\n        st.push(nums[i]);\\n      }\\n    }\\n    vector<string>v1;\\n    while(st.empty() == false){\\n      v1.push_back(st.top());\\n      st.pop();\\n    }\\n    reverse(v1.begin(),v1.end());\\n    return stoi(solve(v1));\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string solve(vector<string>v){\\n    stack<string>st;\\n    for(int i=0;i<v.size();i++){\\n      if(v[i] == \"-\"){\\n        int x = 0;\\n        if(st.empty() == false){\\n          x = stoi(st.top());\\n          st.pop();\\n        }\\n        int y = stoi(v[i+1]);\\n        st.push(to_string(x-y));\\n        i++;\\n      }else if(v[i] ==\"+\"){\\n        int x = 0;\\n        if(st.empty() == false){\\n          x = stoi(st.top());\\n          st.pop();\\n        }\\n        int y = stoi(v[i+1]);\\n        st.push(to_string(x+y));\\n        i++;\\n      }else{\\n        st.push(v[i]);\\n      }\\n    }\\n    return st.top();\\n  }\\n  int calculate(string s) {\\n    vector<string>nums;\\n    string temp;\\n//--------------------------------------------------//\\n/*\\n  removed unnecessary spaces and converted each element to \\n  string and stored in a vector.\\n*/\\n    for(int i=0;i<s.size();i++){\\n      if(s[i] == \\' \\'){\\n        continue;\\n      }\\n      if(isdigit(s[i])){\\n        temp += s[i];\\n      }else{\\n        if(temp.empty() == false){\\n          nums.push_back(temp);\\n        }\\n        string t;\\n        t += s[i];\\n        nums.push_back(t);\\n        temp.clear();\\n      }\\n    }\\n    if(temp.empty() == false){\\n      nums.push_back(temp);\\n    }\\n//--------------------------------------------------//\\n    stack<string>st;\\n    for(int i=0;i<nums.size();i++){\\n      vector<string>t;\\n      if(nums[i] == \")\"){\\n        while(st.empty() == false && st.top() != \"(\"){\\n          t.push_back(st.top());\\n          st.pop();\\n        }\\n        st.pop();\\n        reverse(t.begin(),t.end());\\n        string ans = solve(t);\\n        st.push(ans);\\n      }else{\\n        st.push(nums[i]);\\n      }\\n    }\\n    vector<string>v1;\\n    while(st.empty() == false){\\n      v1.push_back(st.top());\\n      st.pop();\\n    }\\n    reverse(v1.begin(),v1.end());\\n    return stoi(solve(v1));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674943,
                "title": "easy-c-solution-beats-98-3",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n\\n        int n = s.length();\\n\\n        stack<int> st;\\n\\n        int number = 0;\\n        int result = 0;\\n        int sign = 1; // consider positive at the start\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                number = number*10 + (s[i]-\\'0\\');\\n            }\\n            else if(s[i]==\\'+\\')\\n            {\\n                result+= (number*sign);\\n                number = 0;\\n                sign = 1;\\n            }\\n            else if(s[i]==\\'-\\')\\n            {\\n                result+= (number*sign);\\n                number = 0;\\n                sign = -1;\\n            }\\n            else if(s[i]==\\'(\\')\\n            {\\n                st.push(result);\\n                st.push(sign);\\n                result = 0;\\n                number = 0; \\n                sign = 1;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                result += (number*sign);\\n                number = 0;\\n\\n                int stack_sign = st.top();\\n                st.pop();\\n                int last_result = st.top();\\n                st.pop();\\n\\n                result *= stack_sign;\\n                result += last_result;\\n            }\\n        }\\n\\n        result += (number*sign );\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n\\n        int n = s.length();\\n\\n        stack<int> st;\\n\\n        int number = 0;\\n        int result = 0;\\n        int sign = 1; // consider positive at the start\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                number = number*10 + (s[i]-\\'0\\');\\n            }\\n            else if(s[i]==\\'+\\')\\n            {\\n                result+= (number*sign);\\n                number = 0;\\n                sign = 1;\\n            }\\n            else if(s[i]==\\'-\\')\\n            {\\n                result+= (number*sign);\\n                number = 0;\\n                sign = -1;\\n            }\\n            else if(s[i]==\\'(\\')\\n            {\\n                st.push(result);\\n                st.push(sign);\\n                result = 0;\\n                number = 0; \\n                sign = 1;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                result += (number*sign);\\n                number = 0;\\n\\n                int stack_sign = st.top();\\n                st.pop();\\n                int last_result = st.top();\\n                st.pop();\\n\\n                result *= stack_sign;\\n                result += last_result;\\n            }\\n        }\\n\\n        result += (number*sign );\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570931,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int calculate(String s) {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    int result = 0;\\n    int number = 0;\\n    int sign = 1;\\n    for(int i = 0; i < s.length(); i++){\\n        char c = s.charAt(i);\\n        if(Character.isDigit(c)){\\n            number = 10 * number + (int)(c - \\'0\\');\\n        }else if(c == \\'+\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = 1;\\n        }else if(c == \\'-\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = -1;\\n        }else if(c == \\'(\\'){\\n            //we push the result first, then sign;\\n            stack.push(result);\\n            stack.push(sign);\\n            //reset the sign and result for the value in the parenthesis\\n            sign = 1;   \\n            result = 0;\\n        }else if(c == \\')\\'){\\n            result += sign * number;  \\n            number = 0;\\n            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n            \\n        }\\n    }\\n    if(number != 0) result += sign * number;\\n    return result;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int calculate(String s) {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    int result = 0;\\n    int number = 0;\\n    int sign = 1;\\n    for(int i = 0; i < s.length(); i++){\\n        char c = s.charAt(i);\\n        if(Character.isDigit(c)){\\n            number = 10 * number + (int)(c - \\'0\\');\\n        }else if(c == \\'+\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = 1;\\n        }else if(c == \\'-\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = -1;\\n        }else if(c == \\'(\\'){\\n            //we push the result first, then sign;\\n            stack.push(result);\\n            stack.push(sign);\\n            //reset the sign and result for the value in the parenthesis\\n            sign = 1;   \\n            result = 0;\\n        }else if(c == \\')\\'){\\n            result += sign * number;  \\n            number = 0;\\n            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n            \\n        }\\n    }\\n    if(number != 0) result += sign * number;\\n    return result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871262,
                "title": "eval",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar calculate = function(s) \\n{\\n    return eval(s);\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar calculate = function(s) \\n{\\n    return eval(s);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2834342,
                "title": "easy-understanding-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n=s.size();\\n        int sum=0;\\n        int sign=1;\\n  \\n        stack<int>st;\\n        for(int i=0;i<n;i++){\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                int num=0;\\n                while(s.size()>i && s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                    num=num*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                sum+=num*sign;\\n                i--;\\n            }\\n            else if(s[i]==\\'+\\'){\\n                sign=1;\\n            }\\n            else if(s[i]==\\'-\\'){\\n                sign=-1;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if(s[i]==\\')\\'){\\n                sum=st.top()*sum;\\n                st.pop();\\n                sum+=st.top();\\n                st.pop();          \\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n=s.size();\\n        int sum=0;\\n        int sign=1;\\n  \\n        stack<int>st;\\n        for(int i=0;i<n;i++){\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                int num=0;\\n                while(s.size()>i && s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                    num=num*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                sum+=num*sign;\\n                i--;\\n            }\\n            else if(s[i]==\\'+\\'){\\n                sign=1;\\n            }\\n            else if(s[i]==\\'-\\'){\\n                sign=-1;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if(s[i]==\\')\\'){\\n                sum=st.top()*sum;\\n                st.pop();\\n                sum+=st.top();\\n                st.pop();          \\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834273,
                "title": "golang-100-100",
                "content": "```\\nfunc calculate(s string) int {\\n\\tresult, _ := calculateFrom(s, 0)\\n\\treturn result\\n}\\n\\nfunc calculateFrom(s string, idFrom int) (result, idEnd int) {\\n\\tresult, currNum, sign := 0, 0, 1\\n\\n\\tfor idEnd = idFrom; idEnd < len(s) && s[idEnd] != \\')\\'; idEnd++ {\\n\\t\\tswitch {\\n\\t\\tcase s[idEnd] >= \\'0\\':\\n\\t\\t\\tcurrNum = currNum*10 + int(s[idEnd]-\\'0\\')\\n\\t\\tcase s[idEnd] == \\'(\\':\\n\\t\\t\\tcurrNum, idEnd = calculateFrom(s, idEnd+1)\\n\\t\\tcase s[idEnd] == \\'-\\' || s[idEnd] == \\'+\\':\\n\\t\\t\\tresult, currNum = result+currNum*sign, 0\\n\\t\\t\\tsign = 44 - int(s[idEnd]) // \\'-\\'=45; \\'+\\'=43\\n\\t\\t}\\n\\t}\\n\\n\\treturn result + currNum*sign, idEnd\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc calculate(s string) int {\\n\\tresult, _ := calculateFrom(s, 0)\\n\\treturn result\\n}\\n\\nfunc calculateFrom(s string, idFrom int) (result, idEnd int) {\\n\\tresult, currNum, sign := 0, 0, 1\\n\\n\\tfor idEnd = idFrom; idEnd < len(s) && s[idEnd] != \\')\\'; idEnd++ {\\n\\t\\tswitch {\\n\\t\\tcase s[idEnd] >= \\'0\\':\\n\\t\\t\\tcurrNum = currNum*10 + int(s[idEnd]-\\'0\\')\\n\\t\\tcase s[idEnd] == \\'(\\':\\n\\t\\t\\tcurrNum, idEnd = calculateFrom(s, idEnd+1)\\n\\t\\tcase s[idEnd] == \\'-\\' || s[idEnd] == \\'+\\':\\n\\t\\t\\tresult, currNum = result+currNum*sign, 0\\n\\t\\t\\tsign = 44 - int(s[idEnd]) // \\'-\\'=45; \\'+\\'=43\\n\\t\\t}\\n\\t}\\n\\n\\treturn result + currNum*sign, idEnd\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2834230,
                "title": "java-easy-solution-using-stack-o-n-90-100-faster",
                "content": "# Iterative 90% Faster\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        int result = 0,sign = 1;\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i = 0 ; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            \\n            if(Character.isDigit(ch)){\\n                int num = 0;\\n                while(i < s.length() && Character.isDigit(s.charAt(i))){\\n                    num = num * 10 + (s.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num = num * sign;\\n                sign = 1;\\n                result += num;\\n            }else if(ch == \\'(\\'){\\n                stack.push(result);\\n                stack.push(sign);\\n                result = 0;\\n                sign = 1;\\n            }else  if( ch == \\')\\'){\\n                result *= stack.pop();\\n                result += stack.pop();\\n                \\n            }else if(ch == \\'+\\'){\\n                sign = 1;\\n            }else if( ch == \\'-\\'){\\n                sign = -1;\\n            }else{\\n                continue;\\n            }\\n        }\\n    return result;\\n    }\\n}\\n```\\n# Recursive 100% Faster 2ms\\n```\\nclass Solution {\\n    int idx; // this index traverse the string in one pass, between different level of recursion\\n    public int calculate(String s) {\\n        idx = 0; // Initialization should be here\\n        return calc(s);\\n    }\\n    \\n    private int calc(String s) {\\n        int res = 0, num = 0, sign = 1;\\n        while (idx < s.length()) {\\n            char c = s.charAt(idx++);\\n            if (c >= \\'0\\' && c <= \\'9\\') num = num * 10 + c - \\'0\\';\\n            else if (c == \\'(\\') num = calc(s); // ( is start of a new sub-problem, Let recursion solve the sub-problem\\n            else if (c == \\')\\') return res + sign * num;\\n            else if (c == \\'+\\' || c == \\'-\\') { // only when we meet a new sign, we know a while number has been read\\n                res += sign * num;\\n                num = 0;\\n                sign = c == \\'-\\' ? -1 : 1;\\n            }\\n        }\\n        return res + sign * num; // last number is not processed yet\\n    }\\n}\\n```\\n**please Upvote**",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int result = 0,sign = 1;\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i = 0 ; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            \\n            if(Character.isDigit(ch)){\\n                int num = 0;\\n                while(i < s.length() && Character.isDigit(s.charAt(i))){\\n                    num = num * 10 + (s.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num = num * sign;\\n                sign = 1;\\n                result += num;\\n            }else if(ch == \\'(\\'){\\n                stack.push(result);\\n                stack.push(sign);\\n                result = 0;\\n                sign = 1;\\n            }else  if( ch == \\')\\'){\\n                result *= stack.pop();\\n                result += stack.pop();\\n                \\n            }else if(ch == \\'+\\'){\\n                sign = 1;\\n            }else if( ch == \\'-\\'){\\n                sign = -1;\\n            }else{\\n                continue;\\n            }\\n        }\\n    return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int idx; // this index traverse the string in one pass, between different level of recursion\\n    public int calculate(String s) {\\n        idx = 0; // Initialization should be here\\n        return calc(s);\\n    }\\n    \\n    private int calc(String s) {\\n        int res = 0, num = 0, sign = 1;\\n        while (idx < s.length()) {\\n            char c = s.charAt(idx++);\\n            if (c >= \\'0\\' && c <= \\'9\\') num = num * 10 + c - \\'0\\';\\n            else if (c == \\'(\\') num = calc(s); // ( is start of a new sub-problem, Let recursion solve the sub-problem\\n            else if (c == \\')\\') return res + sign * num;\\n            else if (c == \\'+\\' || c == \\'-\\') { // only when we meet a new sign, we know a while number has been read\\n                res += sign * num;\\n                num = 0;\\n                sign = c == \\'-\\' ? -1 : 1;\\n            }\\n        }\\n        return res + sign * num; // last number is not processed yet\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834192,
                "title": "java-code-using-stack-easy-implementation-with-explanation-line-by-line",
                "content": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int n = s.length();\\n        int sum = 0;\\n        int sign = 1;\\n        Stack<Integer> st = new Stack<Integer>();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n             // number\\n            if(s.charAt(i)>=\\'0\\' &&  s.charAt(i)<=\\'9\\')\\n            {\\n                int num = 0;\\n                while(i<n && s.charAt(i)>=\\'0\\' && s.charAt(i)<=\\'9\\' )    //Eg: 125  (it will work for single and multiple digit number )\\n                {\\n                    num =num*10 + (s.charAt(i)-\\'0\\') ;    //we are converting Character to Integer by subtracting ASCII value of Char \\'0\\'\\n                    i++;\\n                }\\n                sum = sum + num*sign;    // eg: sum = sum + 125*(+1) =125\\n                i--;                    // we are doing  i-- becoz in last step we have gone to next value by incrementing i.e i++\\n            }\\n            \\n            else if(s.charAt(i)==\\'+\\'){\\n                sign = 1;\\n            }\\n            \\n            else if(s.charAt(i)==\\'-\\'){  \\n                sign = -1;\\n            }\\n            \\n            else if(s.charAt(i)==\\'(\\'){     // when there is opening bracket - push SUM in stack , and Push sign(+ve,-ve) in Stack . NOTE: For +ve ( we use +1 ) , for -ve (we use -1)\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            \\n            else if(s.charAt(i)==\\')\\') {          // when there is closing bracket- 1st pop SIGN (1 or -1 ) using st.pop(). Secondly pop Number that is present .\\n                sum = sum*st.pop();           //multiply number with sign -1 or +1\\n                sum = sum + st.pop();\\n            }\\n            \\n        }//forLoop_End\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int n = s.length();\\n        int sum = 0;\\n        int sign = 1;\\n        Stack<Integer> st = new Stack<Integer>();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n             // number\\n            if(s.charAt(i)>=\\'0\\' &&  s.charAt(i)<=\\'9\\')\\n            {\\n                int num = 0;\\n                while(i<n && s.charAt(i)>=\\'0\\' && s.charAt(i)<=\\'9\\' )    //Eg: 125  (it will work for single and multiple digit number )\\n                {\\n                    num =num*10 + (s.charAt(i)-\\'0\\') ;    //we are converting Character to Integer by subtracting ASCII value of Char \\'0\\'\\n                    i++;\\n                }\\n                sum = sum + num*sign;    // eg: sum = sum + 125*(+1) =125\\n                i--;                    // we are doing  i-- becoz in last step we have gone to next value by incrementing i.e i++\\n            }\\n            \\n            else if(s.charAt(i)==\\'+\\'){\\n                sign = 1;\\n            }\\n            \\n            else if(s.charAt(i)==\\'-\\'){  \\n                sign = -1;\\n            }\\n            \\n            else if(s.charAt(i)==\\'(\\'){     // when there is opening bracket - push SUM in stack , and Push sign(+ve,-ve) in Stack . NOTE: For +ve ( we use +1 ) , for -ve (we use -1)\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            \\n            else if(s.charAt(i)==\\')\\') {          // when there is closing bracket- 1st pop SIGN (1 or -1 ) using st.pop(). Secondly pop Number that is present .\\n                sum = sum*st.pop();           //multiply number with sign -1 or +1\\n                sum = sum + st.pop();\\n            }\\n            \\n        }//forLoop_End\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400438,
                "title": "calculator-i-ii-iii-with-one-recursive-template",
                "content": "One template to solve all the calculator problems\\n\\n1. when we have \\'(\\' => we go into the recursion call\\n2. when we have num => process the num\\n3. All we left now is the operators => Handle the current num; \\nIf we have \\'*\\' and \\'/\\', we can use a stack (or a vector) to calculate the result\\nAnd we have to update the current operator in the end\\n\\n**Calculator I**\\nwe have \\'+\\', \\'-\\', and \\'(\\' & \\')\\'\\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return parseExpr(s, i);\\n    }\\n    \\n    int parseExpr(string& s, int& i) {\\n        int res = 0;\\n        char op = \\'+\\';\\n        for (; i < s.length() && op != \\')\\'; i++) {\\n            if (s[i] == \\' \\') continue;\\n            int n = s[i] == \\'(\\' ? parseExpr(s, ++i) : parseNum(s, i);\\n\\t\\t\\t\\n\\t\\t\\t// put the number into the result\\n            switch(op) {\\n                case \\'+\\' : res += n; break;\\n                case \\'-\\' : res -= n; break;\\n            }\\n\\t\\t\\t// +, -, ) left\\n            op = s[i];\\n        }\\n        return res;\\n    }\\n    \\n    int parseNum(string& s, int& i) {\\n        int n = 0;\\n        while(i < s.length() && isdigit(s[i]))\\n            n = s[i++] - \\'0\\' + 10 * n;\\n        return n;\\n    }\\n};\\n```\\n\\n**Calculator II**\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return parseExpr(s, i);\\n    }\\n    \\n    int parseExpr(string& s, int& i) {\\n        vector<int> nums;\\n        char op = \\'+\\';\\n        for (; i < s.length(); i++) {\\n            if (s[i] == \\' \\') continue;\\n            int n = parseNum(s, i);\\n            switch(op) {\\n                case \\'+\\' : nums.push_back(n); break;\\n                case \\'-\\' : nums.push_back(-n); break;\\n                case \\'*\\' : nums.back() *= n; break;\\n                case \\'/\\' : nums.back() /= n; break;\\n            }            \\n            op = s[i];\\n        }\\n        return accumulate(nums.begin(), nums.end(), 0);\\n    }\\n    \\n    int parseNum(string& s, int& i) {\\n        int n = 0;\\n        while(i < s.length() && isdigit(s[i]))\\n            n = s[i++] - \\'0\\' + 10 * n;\\n        return n;\\n    }\\n};\\n```\\n**Calculator III**\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return parseExpr(s, i);\\n    }\\n    \\n    int parseExpr(string& s, int& i) {\\n        vector<int> nums;\\n        char op = \\'+\\';\\n        for (; i < s.length() && op != \\')\\'; i++) {\\n            if (s[i] == \\' \\') continue;\\n            int n = s[i] == \\'(\\' ? parseExpr(s, ++i) : parseNum(s, i);\\n            switch(op) {\\n                case \\'+\\' : nums.push_back(n); break;\\n                case \\'-\\' : nums.push_back(-n); break;\\n                case \\'*\\' : nums.back() *= n; break;\\n                case \\'/\\' : nums.back() /= n; break;\\n            }            \\n            op = s[i];\\n        }\\n        return accumulate(nums.begin(), nums.end(), 0);\\n    }\\n    \\n     int parseNum(string& s, int& i) {     \\n        int n = 0;\\n        while(i < s.length() && isdigit(s[i]))\\n            n = s[i++] - \\'0\\' + 10 * n;\\n        return n;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return parseExpr(s, i);\\n    }\\n    \\n    int parseExpr(string& s, int& i) {\\n        int res = 0;\\n        char op = \\'+\\';\\n        for (; i < s.length() && op != \\')\\'; i++) {\\n            if (s[i] == \\' \\') continue;\\n            int n = s[i] == \\'(\\' ? parseExpr(s, ++i) : parseNum(s, i);\\n\\t\\t\\t\\n\\t\\t\\t// put the number into the result\\n            switch(op) {\\n                case \\'+\\' : res += n; break;\\n                case \\'-\\' : res -= n; break;\\n            }\\n\\t\\t\\t// +, -, ) left\\n            op = s[i];\\n        }\\n        return res;\\n    }\\n    \\n    int parseNum(string& s, int& i) {\\n        int n = 0;\\n        while(i < s.length() && isdigit(s[i]))\\n            n = s[i++] - \\'0\\' + 10 * n;\\n        return n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return parseExpr(s, i);\\n    }\\n    \\n    int parseExpr(string& s, int& i) {\\n        vector<int> nums;\\n        char op = \\'+\\';\\n        for (; i < s.length(); i++) {\\n            if (s[i] == \\' \\') continue;\\n            int n = parseNum(s, i);\\n            switch(op) {\\n                case \\'+\\' : nums.push_back(n); break;\\n                case \\'-\\' : nums.push_back(-n); break;\\n                case \\'*\\' : nums.back() *= n; break;\\n                case \\'/\\' : nums.back() /= n; break;\\n            }            \\n            op = s[i];\\n        }\\n        return accumulate(nums.begin(), nums.end(), 0);\\n    }\\n    \\n    int parseNum(string& s, int& i) {\\n        int n = 0;\\n        while(i < s.length() && isdigit(s[i]))\\n            n = s[i++] - \\'0\\' + 10 * n;\\n        return n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return parseExpr(s, i);\\n    }\\n    \\n    int parseExpr(string& s, int& i) {\\n        vector<int> nums;\\n        char op = \\'+\\';\\n        for (; i < s.length() && op != \\')\\'; i++) {\\n            if (s[i] == \\' \\') continue;\\n            int n = s[i] == \\'(\\' ? parseExpr(s, ++i) : parseNum(s, i);\\n            switch(op) {\\n                case \\'+\\' : nums.push_back(n); break;\\n                case \\'-\\' : nums.push_back(-n); break;\\n                case \\'*\\' : nums.back() *= n; break;\\n                case \\'/\\' : nums.back() /= n; break;\\n            }            \\n            op = s[i];\\n        }\\n        return accumulate(nums.begin(), nums.end(), 0);\\n    }\\n    \\n     int parseNum(string& s, int& i) {     \\n        int n = 0;\\n        while(i < s.length() && isdigit(s[i]))\\n            n = s[i++] - \\'0\\' + 10 * n;\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130978,
                "title": "java-stack-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sum=0;\\n        int sign=1;\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char x=s.charAt(i);\\n            if(Character.isDigit(x)){\\n                int num=0;\\n                while(i<s.length() && Character.isDigit(s.charAt(i))){\\n                    num=num*10 + (s.charAt(i)-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num=num*sign;\\n                sum+=num;\\n                sign=1;\\n            }\\n            else if(x==\\'(\\'){\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if(x==\\')\\'){\\n                sum*=st.pop();\\n                sum+=st.pop();\\n            }\\n            else if(x==\\'-\\'){\\n                sign*=-1;\\n            }\\n            else {\\n                continue;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sum=0;\\n        int sign=1;\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char x=s.charAt(i);\\n            if(Character.isDigit(x)){\\n                int num=0;\\n                while(i<s.length() && Character.isDigit(s.charAt(i))){\\n                    num=num*10 + (s.charAt(i)-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num=num*sign;\\n                sum+=num;\\n                sign=1;\\n            }\\n            else if(x==\\'(\\'){\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if(x==\\')\\'){\\n                sum*=st.pop();\\n                sum+=st.pop();\\n            }\\n            else if(x==\\'-\\'){\\n                sign*=-1;\\n            }\\n            else {\\n                continue;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645587,
                "title": "c-easy-solution-w-comments",
                "content": "**Code :**\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<pair<int, int>> stk; //to store value calculated till now & sign\\n        long long int sum = 0, num = 0;\\n        int  sign = 1; //to store the current sign\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(isdigit(s[i])){\\n                //If it\\'s a multidigit number\\n                while(i < s.size() && isdigit(s[i])){\\n                    num = num*10 + (s[i] - \\'0\\');\\n                    i++;\\n                } \\n                i--;\\n                sum += num*sign;\\n                sign = 1; //reset sign\\n                num = 0;  //reset num\\n            }\\n            else if(s[i] == \\'(\\'){\\n                stk.push(make_pair(sum, sign)); //push the calculated sum & sign\\n                //reset sum & sign\\n                sum = 0;\\n                sign = 1;\\n            \\n            }else if(s[i] == \\'+\\'){ \\n                sign = 1; //sign is positive\\n            }else if(s[i] == \\'-\\'){\\n                sign = sign*(-1);  //toggle sign\\n            }else if(s[i] == \\')\\'){\\n                sum = stk.top().first + (stk.top().second)*sum; //After finishing calculating inside bracket value, add / subtract it from the previously calculated sum\\n                stk.pop();\\n                \\n            }else continue; //in case of empty spaces\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n**Do upvote if you like :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<pair<int, int>> stk; //to store value calculated till now & sign\\n        long long int sum = 0, num = 0;\\n        int  sign = 1; //to store the current sign\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(isdigit(s[i])){\\n                //If it\\'s a multidigit number\\n                while(i < s.size() && isdigit(s[i])){\\n                    num = num*10 + (s[i] - \\'0\\');\\n                    i++;\\n                } \\n                i--;\\n                sum += num*sign;\\n                sign = 1; //reset sign\\n                num = 0;  //reset num\\n            }\\n            else if(s[i] == \\'(\\'){\\n                stk.push(make_pair(sum, sign)); //push the calculated sum & sign\\n                //reset sum & sign\\n                sum = 0;\\n                sign = 1;\\n            \\n            }else if(s[i] == \\'+\\'){ \\n                sign = 1; //sign is positive\\n            }else if(s[i] == \\'-\\'){\\n                sign = sign*(-1);  //toggle sign\\n            }else if(s[i] == \\')\\'){\\n                sum = stk.top().first + (stk.top().second)*sum; //After finishing calculating inside bracket value, add / subtract it from the previously calculated sum\\n                stk.pop();\\n                \\n            }else continue; //in case of empty spaces\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521441,
                "title": "easy-c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) \\n    {\\n        int res = 0, sign = 1;\\n        \\n        stack<int> st;\\n        for(int i = 0; i < s.size(); i++)\\n        {            \\n            char c = s[i];\\n            if(c >= \\'0\\' && c <= \\'9\\')\\n            {\\n                int num = 0;\\n                while(i < s.size() && s[i]>=\\'0\\' && s[i]<= \\'9\\')\\n                    num = num * 10 + (s[i++] - \\'0\\');\\n                res += sign * num;\\n                i--;\\n            }\\n            else if(c ==\\'+\\') sign = 1;\\n            else if(c ==\\'-\\') sign = -1;\\n            else if(c ==\\'(\\')\\n            { \\n                st.push(res);\\n                st.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if(c ==\\')\\')\\n            {\\n                res *= st.top(); \\n                st.pop();\\n                res += st.top(); \\n                st.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) \\n    {\\n        int res = 0, sign = 1;\\n        \\n        stack<int> st;\\n        for(int i = 0; i < s.size(); i++)\\n        {            \\n            char c = s[i];\\n            if(c >= \\'0\\' && c <= \\'9\\')\\n            {\\n                int num = 0;\\n                while(i < s.size() && s[i]>=\\'0\\' && s[i]<= \\'9\\')\\n                    num = num * 10 + (s[i++] - \\'0\\');\\n                res += sign * num;\\n                i--;\\n            }\\n            else if(c ==\\'+\\') sign = 1;\\n            else if(c ==\\'-\\') sign = -1;\\n            else if(c ==\\'(\\')\\n            { \\n                st.push(res);\\n                st.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if(c ==\\')\\')\\n            {\\n                res *= st.top(); \\n                st.pop();\\n                res += st.top(); \\n                st.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459827,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int calculate(string s) \\n    {        \\n        stack<int> values;    \\n        int result = 0;\\n        int sign = 1;\\n        for(int i = 0; i < s.length(); i++) \\n        {\\n            if(s[i] == \\' \\') continue;    \\n            if(isdigit(s[i])) \\n            {\\n                int val = 0;    \\n                while(i < s.length() && isdigit(s[i])) \\n                {\\n                    val = val * 10 + (s[i] - \\'0\\');\\n                    i++;\\n                }\\n                result+= (val * sign);\\n                i--;\\n            }\\n            else if(s[i] == \\'+\\') sign = 1;\\n            else if(s[i] == \\'-\\') sign = -1;\\n            else if(s[i] == \\'(\\') \\n            {    \\n                values.push(result);\\n                values.push(sign);   \\n                result = 0;\\n                sign = 1;\\n            }\\n            else \\n            {    \\n                result *= values.top();\\n                values.pop();\\n                result += values.top();\\n                values.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int calculate(string s) \\n    {        \\n        stack<int> values;    \\n        int result = 0;\\n        int sign = 1;\\n        for(int i = 0; i < s.length(); i++) \\n        {\\n            if(s[i] == \\' \\') continue;    \\n            if(isdigit(s[i])) \\n            {\\n                int val = 0;    \\n                while(i < s.length() && isdigit(s[i])) \\n                {\\n                    val = val * 10 + (s[i] - \\'0\\');\\n                    i++;\\n                }\\n                result+= (val * sign);\\n                i--;\\n            }\\n            else if(s[i] == \\'+\\') sign = 1;\\n            else if(s[i] == \\'-\\') sign = -1;\\n            else if(s[i] == \\'(\\') \\n            {    \\n                values.push(result);\\n                values.push(sign);   \\n                result = 0;\\n                sign = 1;\\n            }\\n            else \\n            {    \\n                result *= values.top();\\n                values.pop();\\n                result += values.top();\\n                values.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457982,
                "title": "clear-go-solution",
                "content": "```\\nfunc calculate(s string) int {\\n\\tresult, num, op := 0, 0, add\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\' \\':\\n\\t\\tcase \\'+\\':\\n\\t\\t\\tresult, num = op(result, num), 0\\n\\t\\t\\top = add\\n\\t\\tcase \\'-\\':\\n\\t\\t\\tresult, num = op(result, num), 0\\n\\t\\t\\top = sub\\n\\t\\tcase \\'(\\':\\n\\t\\t\\tend := findMatch(s, i)\\n\\t\\t\\tnum, i = calculate(s[i+1:end]), end\\n\\t\\tdefault:\\n\\t\\t\\tnum *= 10\\n\\t\\t\\tnum += int(s[i] - \\'0\\')\\n\\t\\t}\\n\\t}\\n\\n\\tresult, num = op(result, num), 0\\n\\treturn result\\n}\\n\\nfunc findMatch(s string, start int) int {\\n\\tlevel := 0\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'(\\':\\n\\t\\t\\tlevel++\\n\\t\\tcase \\')\\':\\n\\t\\t\\tlevel--\\n\\t\\t\\tif level == 0 {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(s) - 1\\n}\\n\\nfunc add(a, b int) int {\\n\\treturn a + b\\n}\\n\\nfunc sub(a, b int) int {\\n\\treturn a - b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc calculate(s string) int {\\n\\tresult, num, op := 0, 0, add\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\' \\':\\n\\t\\tcase \\'+\\':\\n\\t\\t\\tresult, num = op(result, num), 0\\n\\t\\t\\top = add\\n\\t\\tcase \\'-\\':\\n\\t\\t\\tresult, num = op(result, num), 0\\n\\t\\t\\top = sub\\n\\t\\tcase \\'(\\':\\n\\t\\t\\tend := findMatch(s, i)\\n\\t\\t\\tnum, i = calculate(s[i+1:end]), end\\n\\t\\tdefault:\\n\\t\\t\\tnum *= 10\\n\\t\\t\\tnum += int(s[i] - \\'0\\')\\n\\t\\t}\\n\\t}\\n\\n\\tresult, num = op(result, num), 0\\n\\treturn result\\n}\\n\\nfunc findMatch(s string, start int) int {\\n\\tlevel := 0\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'(\\':\\n\\t\\t\\tlevel++\\n\\t\\tcase \\')\\':\\n\\t\\t\\tlevel--\\n\\t\\t\\tif level == 0 {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(s) - 1\\n}\\n\\nfunc add(a, b int) int {\\n\\treturn a + b\\n}\\n\\nfunc sub(a, b int) int {\\n\\treturn a - b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1457042,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n = s.size(), result = 0, sign = 1;\\n        stack<int> stk;\\n        for (int i = 0; i < n; i++) {\\n            if (isdigit(s[i])) {\\n                int num = s[i] - \\'0\\';\\n                while (i + 1 < n && isdigit(s[i + 1])) {\\n                    num = num * 10 + (s[++i] - \\'0\\');\\n                }\\n                result += sign * num;\\n            } else if (s[i] == \\'+\\') {\\n                sign = 1;\\n            } else if (s[i] == \\'-\\') {\\n                sign = -1;\\n            } else if (s[i] == \\'(\\') {\\n                stk.push(result);\\n                stk.push(sign);\\n                result = 0;\\n                sign = 1;\\n            } else if (s[i] == \\')\\') {\\n                result *= stk.top();\\n                stk.pop();\\n                result += stk.top();\\n                stk.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n = s.size(), result = 0, sign = 1;\\n        stack<int> stk;\\n        for (int i = 0; i < n; i++) {\\n            if (isdigit(s[i])) {\\n                int num = s[i] - \\'0\\';\\n                while (i + 1 < n && isdigit(s[i + 1])) {\\n                    num = num * 10 + (s[++i] - \\'0\\');\\n                }\\n                result += sign * num;\\n            } else if (s[i] == \\'+\\') {\\n                sign = 1;\\n            } else if (s[i] == \\'-\\') {\\n                sign = -1;\\n            } else if (s[i] == \\'(\\') {\\n                stk.push(result);\\n                stk.push(sign);\\n                result = 0;\\n                sign = 1;\\n            } else if (s[i] == \\')\\') {\\n                result *= stk.top();\\n                stk.pop();\\n                result += stk.top();\\n                stk.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457029,
                "title": "c-easy-recursion",
                "content": "```\\nclass Solution {\\n    int ret_pos;\\npublic:\\n    int calculate(string s,int i=0) {\\n        int first=0,sum=0;\\n        int sign=1 ;\\n        while(i<s.length() && s[i]!=\\')\\')\\n        {\\n            while(s[i]==\\' \\')i++;\\n            if(s[i]==\\'-\\' ){sign = -1;i++;}\\n            if(s[i]==\\'+\\'){sign =1;i++;}\\n            while(s[i]==\\' \\')i++;\\n            if(s[i]==\\'(\\')\\n            {\\n                first = calculate(s,i+1);\\n                i = ret_pos;\\n            }\\n            else if(isdigit(s[i]))\\n            {\\n                int j=i;\\n                first =0;\\n                while(isdigit(s[j]))\\n                {\\n                    first*=10;\\n                    first +=s[j]-\\'0\\';\\n                    j++;\\n                }\\n                i=j;\\n            }\\n            sum+=sign*first;\\n            first = 0 ;\\n            sign=1;\\n            if(s[i] == \\')\\')\\n            {\\n                ret_pos = i+1;\\n                return  sum;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ret_pos;\\npublic:\\n    int calculate(string s,int i=0) {\\n        int first=0,sum=0;\\n        int sign=1 ;\\n        while(i<s.length() && s[i]!=\\')\\')\\n        {\\n            while(s[i]==\\' \\')i++;\\n            if(s[i]==\\'-\\' ){sign = -1;i++;}\\n            if(s[i]==\\'+\\'){sign =1;i++;}\\n            while(s[i]==\\' \\')i++;\\n            if(s[i]==\\'(\\')\\n            {\\n                first = calculate(s,i+1);\\n                i = ret_pos;\\n            }\\n            else if(isdigit(s[i]))\\n            {\\n                int j=i;\\n                first =0;\\n                while(isdigit(s[j]))\\n                {\\n                    first*=10;\\n                    first +=s[j]-\\'0\\';\\n                    j++;\\n                }\\n                i=j;\\n            }\\n            sum+=sign*first;\\n            first = 0 ;\\n            sign=1;\\n            if(s[i] == \\')\\')\\n            {\\n                ret_pos = i+1;\\n                return  sum;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096842,
                "title": "simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int> st;\\n        int ans=0;\\n        st.push(1),st.push(1);\\n        //s[0] == \\'-\\'? st.push(-1) : st.push(1);\\n        for(int i=0;i<s.size();){\\n            if(s[i] >= \\'0\\'){\\n                int num=0;\\n                while(s[i]>=\\'0\\')\\n                    num = (s[i++] - \\'0\\') + num*10;\\n                ans = ans + st.top() * num;\\n                st.pop();\\n            }else if(s[i] == \\'+\\' || s[i] == \\'-\\'){\\n                s[i] == \\'-\\' ? st.push(st.top() * -1) : st.push(st.top() * 1);\\n                i++;\\n            }\\n            else if(s[i] == \\'(\\') st.push(st.top()), i++;\\n            else if(s[i] == \\')\\') st.pop(),i++;\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int> st;\\n        int ans=0;\\n        st.push(1),st.push(1);\\n        //s[0] == \\'-\\'? st.push(-1) : st.push(1);\\n        for(int i=0;i<s.size();){\\n            if(s[i] >= \\'0\\'){\\n                int num=0;\\n                while(s[i]>=\\'0\\')\\n                    num = (s[i++] - \\'0\\') + num*10;\\n                ans = ans + st.top() * num;\\n                st.pop();\\n            }else if(s[i] == \\'+\\' || s[i] == \\'-\\'){\\n                s[i] == \\'-\\' ? st.push(st.top() * -1) : st.push(st.top() * 1);\\n                i++;\\n            }\\n            else if(s[i] == \\'(\\') st.push(st.top()), i++;\\n            else if(s[i] == \\')\\') st.pop(),i++;\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885944,
                "title": "4ms-linear-solution-with-a-stack-of",
                "content": "The idea is that: each sign before a number within a negative block is flipped:\\n`-(1+2+3+4)` => `-1-2-3-4`\\nAnd it is nested:\\n`1-(2+3-(4-5))` => `1-(2+3-4+5)`=> `1-2-3+4-5`\\nThe gist is to push the sign +/- onto a stack, whenever we counter the combination of `+(` or `-(`. \\nWhen we push `-` onto the stack, we remember that we flip. We also need to flip it back when we pop it from the stack.\\n\\n```\\nint oc=0;\\nchar ostack[512];\\n\\nvoid push(char c) { ostack[oc++] = c;}\\n\\nvoid pop() {oc --;}\\n\\nint calculate(char * s){\\n    oc = 0;\\n    int num = 0; // current number to read\\n    int sum = 0; // current sum\\n    char lastSign = \\'+\\';\\n    bool positive = true;\\n    for(char* c=s;*c;c++) {\\n        if (*c==\\' \\') continue; //skip spaces\\n        \\n        if (\\'0\\' <= *c && *c <= \\'9\\') { // we have a digit\\n            num *= 10;  num += *c - \\'0\\';\\n            if (c[1] < \\'0\\' || c[1] > \\'9\\') { // detect end of number\\n                if (lastSign == \\'-\\') { // this is a negative number\\n                    num = -num;\\n                }\\n                if (positive) { // result of the flip-flop\\n                    sum += num;\\n                } else {\\n                    sum -= num;\\n                }\\n                num = 0;\\n            }\\n        } else  {\\n            if (*c == \\'(\\') {\\n                if(lastSign == \\'-\\') {\\n                    positive = !positive; // FLIP!\\n                }\\n                push(lastSign);\\n                lastSign = \\'+\\';\\n            } else if (*c == \\')\\') {\\n                if (oc > 0 && ostack[oc-1] == \\'-\\') { \\n                    positive = !positive;  // FLIP BACK!\\n                }\\n                pop();\\n            } else if (*c == \\'+\\') {\\n                lastSign = *c;\\n            } else if (*c == \\'-\\') {\\n                lastSign = *c;\\n            }\\n        }\\n    }\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint oc=0;\\nchar ostack[512];\\n\\nvoid push(char c) { ostack[oc++] = c;}\\n\\nvoid pop() {oc --;}\\n\\nint calculate(char * s){\\n    oc = 0;\\n    int num = 0; // current number to read\\n    int sum = 0; // current sum\\n    char lastSign = \\'+\\';\\n    bool positive = true;\\n    for(char* c=s;*c;c++) {\\n        if (*c==\\' \\') continue; //skip spaces\\n        \\n        if (\\'0\\' <= *c && *c <= \\'9\\') { // we have a digit\\n            num *= 10;  num += *c - \\'0\\';\\n            if (c[1] < \\'0\\' || c[1] > \\'9\\') { // detect end of number\\n                if (lastSign == \\'-\\') { // this is a negative number\\n                    num = -num;\\n                }\\n                if (positive) { // result of the flip-flop\\n                    sum += num;\\n                } else {\\n                    sum -= num;\\n                }\\n                num = 0;\\n            }\\n        } else  {\\n            if (*c == \\'(\\') {\\n                if(lastSign == \\'-\\') {\\n                    positive = !positive; // FLIP!\\n                }\\n                push(lastSign);\\n                lastSign = \\'+\\';\\n            } else if (*c == \\')\\') {\\n                if (oc > 0 && ostack[oc-1] == \\'-\\') { \\n                    positive = !positive;  // FLIP BACK!\\n                }\\n                pop();\\n            } else if (*c == \\'+\\') {\\n                lastSign = *c;\\n            } else if (*c == \\'-\\') {\\n                lastSign = *c;\\n            }\\n        }\\n    }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 830231,
                "title": "c-solution-using-recursion-instead-of-a-stack",
                "content": "```\\nclass Solution {\\npublic:    \\n    int get_num(string& s, int& i) {\\n        int num = 0;\\n        while (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            num *= 10;\\n            num += (s[i++] - \\'0\\');\\n        }\\n        return num;\\n    }\\n    \\n    \\n    int get_next(string& s, int& i) {\\n        while (s[i] == \\' \\') ++i;\\n        int ans;\\n        if (s[i] == \\'(\\') {\\n            ans = evaluate(s, ++i);\\n        } else {\\n            ans = get_num(s, i);\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int evaluate (string& s, int& i) {\\n        int sign = 1, ans = 0;\\n        while (i < s.size() && s[i] != \\')\\') {\\n            if (s[i] == \\' \\') { ++i; continue; }\\n            if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                ans += get_num(s, i);\\n            } else if (s[i] == \\'+\\' || s[i] == \\'-\\') {\\n                sign = s[i] == \\'+\\' ? 1 : -1;\\n                ans += sign * get_next(s, ++i);\\n            } else {\\n                ans += evaluate(s, ++i);\\n            }\\n        }\\n        ++i;\\n        return ans;\\n    }\\n    \\n    \\n    int calculate(string s) {\\n        int i = 0;\\n        return evaluate(s, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int get_num(string& s, int& i) {\\n        int num = 0;\\n        while (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            num *= 10;\\n            num += (s[i++] - \\'0\\');\\n        }\\n        return num;\\n    }\\n    \\n    \\n    int get_next(string& s, int& i) {\\n        while (s[i] == \\' \\') ++i;\\n        int ans;\\n        if (s[i] == \\'(\\') {\\n            ans = evaluate(s, ++i);\\n        } else {\\n            ans = get_num(s, i);\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int evaluate (string& s, int& i) {\\n        int sign = 1, ans = 0;\\n        while (i < s.size() && s[i] != \\')\\') {\\n            if (s[i] == \\' \\') { ++i; continue; }\\n            if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                ans += get_num(s, i);\\n            } else if (s[i] == \\'+\\' || s[i] == \\'-\\') {\\n                sign = s[i] == \\'+\\' ? 1 : -1;\\n                ans += sign * get_next(s, ++i);\\n            } else {\\n                ans += evaluate(s, ++i);\\n            }\\n        }\\n        ++i;\\n        return ans;\\n    }\\n    \\n    \\n    int calculate(string s) {\\n        int i = 0;\\n        return evaluate(s, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785669,
                "title": "3ms-easy-recursive-java-without-stack",
                "content": "```\\n    int index = 0;\\n    public int calculate(String s) {\\n        int sum = 0;\\n        int sign = 1;\\n        while(index<s.length()){\\n            char c = s.charAt(index);\\n            if(c==\\'(\\'){\\n                ++index;\\n                int subRes = calculate(s);\\n                sum += sign*subRes;\\n            }else if(c==\\')\\'){\\n                return sum;\\n            }else if(c==\\'+\\'){\\n                sign=1;\\n            }else if(c==\\'-\\'){\\n                sign=-1;\\n            }else if(Character.isDigit(c)){\\n                int num = c-\\'0\\';\\n                while(index+1<s.length() && Character.isDigit(s.charAt(index+1))){\\n                    num = 10*num+s.charAt(++index)-\\'0\\';\\n                }\\n                sum += sign*num;\\n            }\\n            ++index;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    int index = 0;\\n    public int calculate(String s) {\\n        int sum = 0;\\n        int sign = 1;\\n        while(index<s.length()){\\n            char c = s.charAt(index);\\n            if(c==\\'(\\'){\\n                ++index;\\n                int subRes = calculate(s);\\n                sum += sign*subRes;\\n            }else if(c==\\')\\'){\\n                return sum;\\n            }else if(c==\\'+\\'){\\n                sign=1;\\n            }else if(c==\\'-\\'){\\n                sign=-1;\\n            }else if(Character.isDigit(c)){\\n                int num = c-\\'0\\';\\n                while(index+1<s.length() && Character.isDigit(s.charAt(index+1))){\\n                    num = 10*num+s.charAt(++index)-\\'0\\';\\n                }\\n                sum += sign*num;\\n            }\\n            ++index;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 670544,
                "title": "go-stack",
                "content": "```\\nfunc calculate(s string) int {\\n    cur := 0\\n    sign := 1\\n    num := 0\\n    res_stack :=  []int{}\\n    sign_stack := []int{}\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == \\' \\' {\\n            continue\\n        } else if s[i] >= \\'0\\' && s[i] <= \\'9\\' {\\n            num = num * 10 + int(s[i] - \\'0\\')\\n        } else if s[i] == \\'+\\' {\\n            cur += num * sign\\n            num = 0\\n            sign = 1\\n        } else if s[i] == \\'-\\' {\\n            cur += num * sign\\n            num = 0\\n            sign = -1\\n        } else if s[i] == \\'(\\' {\\n            res_stack = append(res_stack, cur)\\n            sign_stack = append(sign_stack, sign)\\n            cur = 0\\n            sign = 1\\n        } else if s[i] == \\')\\' {\\n            cur += sign * num\\n            num = 0\\n            sign = sign_stack[len(sign_stack) - 1]\\n            sign_stack = sign_stack[:len(sign_stack) - 1]\\n            \\n            cur = sign * cur + res_stack[len(res_stack) - 1]\\n            res_stack = res_stack[:len(res_stack) - 1]           \\n        } else {\\n            fmt.Println(\"fuck\")\\n        }\\n    }    \\n    return cur + num * sign    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc calculate(s string) int {\\n    cur := 0\\n    sign := 1\\n    num := 0\\n    res_stack :=  []int{}\\n    sign_stack := []int{}\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == \\' \\' {\\n            continue\\n        } else if s[i] >= \\'0\\' && s[i] <= \\'9\\' {\\n            num = num * 10 + int(s[i] - \\'0\\')\\n        } else if s[i] == \\'+\\' {\\n            cur += num * sign\\n            num = 0\\n            sign = 1\\n        } else if s[i] == \\'-\\' {\\n            cur += num * sign\\n            num = 0\\n            sign = -1\\n        } else if s[i] == \\'(\\' {\\n            res_stack = append(res_stack, cur)\\n            sign_stack = append(sign_stack, sign)\\n            cur = 0\\n            sign = 1\\n        } else if s[i] == \\')\\' {\\n            cur += sign * num\\n            num = 0\\n            sign = sign_stack[len(sign_stack) - 1]\\n            sign_stack = sign_stack[:len(sign_stack) - 1]\\n            \\n            cur = sign * cur + res_stack[len(res_stack) - 1]\\n            res_stack = res_stack[:len(res_stack) - 1]           \\n        } else {\\n            fmt.Println(\"fuck\")\\n        }\\n    }    \\n    return cur + num * sign    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571448,
                "title": "o-n-with-detailed-explanation-novel-approach-with-single-stack-pseudocode-kotlin",
                "content": "For this problem, there is no need to implement a generic expression evaluation algorithm, as all operators that exist in the expression have same priority (namely, `+` and `-`).\\n\\n**If there were no paretheses**, the approach would be as simple as this (pseudocode):\\n\\n```\\nacc = 0   // accumulator\\nprevSign = +1\\n\\nfor (token in s) {  // suppose we tokenized s into signs and numbers\\n    if (token in [\\'+\\', \\'-\\'])  prevSign = (token == \\'+\\' ? +1 : -1)\\n    else acc += prevSign * toInt(token)\\n}\\n\\nreturn acc\\n```\\n\\nLet\\'s think, what exactly do paretheses change in the approach above?  \\n\\nIf there were no minus signs (`-`) directly before opening parenthesis, nothing changes, e.g:\\n\\n```(1 + (2 - 3 + (4) - 5))```\\nis the same as:\\n```1 + 2 - 3 + 4 - 5 ```\\n\\nhowever, \\n```1 - (2 + 3 - (4 + 5)) ```\\nis **not** the same as:\\n```1 - 2 + 3 - 4 + 5 ```\\n**but!**  it\\'s the same as:\\n```1 - 2 - 3 + 4 + 5 ```\\n\\nDo you see what happened there?  When there is a minus sign directly before the opening parenthesis, all the signs within that parentheses pair are inverted!  And if there is another nested \"negative opening parentheses\" it inverts signs again! Even number of inversions amount to no change of sign ( `-1 * -1 * -1 * -1 = 1`), while odd number results in single inversion (`-1 * -1 * -1 = -1`).\\n\\nSo the logical modification for the algorithm above is to know how many levels of nested \"negative opening paretheses\" are we currently in. To do that, simple `sign = 1` variable would suffice, which is inverted when \"negative opening parethesis\" is encoutered or when closing parethesis is encountered, that corresponds to \"negative opening parethesis\". \\n\\nNow, \"negative opening parethesis\" is easy, but how to know whether closing parethesis corresponds to \"negative\" or \"positive\" opening parethesis? To do that we need a stack that holds signs of opening paretheses. When encountering opening parenthesis, put it\\'s sign into stack. When encoutering closing parethesis, pop sign from stack \\u2014 that would be the sign of corresponding opening parethesis.\\n\\nLet\\'s put all of this together:\\n\\n```\\nacc = 0   // accumulator\\nprevSign = +1  // previously encountered sign/operator\\nsignStack = []  // signs of opening parentheses\\nparenSigns = +1  // overall sign of current group of parentheses\\n\\nfor (token in s) {  // suppose we tokenized s into signs, numbers and parentheses\\n    if (token in [\\'+\\', \\'-\\'])  prevSign = (token == \\'+\\' ? +1 : -1)\\n\\telse if (token == \\'(\\')  {\\n\\t  signStack.push(prevSign)\\n\\t  if (prevSign < 0) parenSigns *= -1  // invert sign of nested paretheses\\n\\t  prevSign = +1 // after the opening parethesis, we assume sign is always positive (as in the start of new expression)\\n\\t} else if (token == \\')\\') {\\n\\t  if (signStack.pop() < 0) parenSigns *= -1 // revert sign back\\n\\t} else acc += prevSign * parenSigns * toInt(token)\\n}\\n\\nreturn acc\\n```\\n\\n\\n\\nAnd now in Kotlin:\\n```\\nclass Solution {\\n    \\n    fun calculate(s: String): Int {\\n        var acc = 0        \\n        var i = 0\\n        \\n        val signStack = LinkedList<Int>()  \\n        var parenSigns = 1\\n        var prevSign = 1\\n        \\n        while (i < s.length) {\\n            val c = s[i]\\n            when(c) {\\n                \\' \\' -> {}\\n                \\'(\\' -> { \\n                    signStack.push(prevSign)\\n                    if (prevSign < 0) parenSigns *= -1\\n                    prevSign = 1\\n                }\\n                \\')\\' -> if (signStack.pop() < 0) parenSigns *= -1\\n                \\'+\\' ->  prevSign = 1\\n                \\'-\\' -> prevSign = -1\\n                else -> { // parse whole number\\n                    var n = 0\\n                    while(i < s.length && \\'0\\' <= s[i] && s[i] <= \\'9\\') {\\n                        n = n * 10 + (s[i] - \\'0\\')\\n                        i++\\n                    }\\n                    i--\\n                    acc += n * parenSigns * prevSign\\n                }\\n            }\\n            i++\\n        }\\n     \\n        return acc\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nacc = 0   // accumulator\\nprevSign = +1\\n\\nfor (token in s) {  // suppose we tokenized s into signs and numbers\\n    if (token in [\\'+\\', \\'-\\'])  prevSign = (token == \\'+\\' ? +1 : -1)\\n    else acc += prevSign * toInt(token)\\n}\\n\\nreturn acc\\n```\n```(1 + (2 - 3 + (4) - 5))```\n```1 + 2 - 3 + 4 - 5 ```\n```1 - (2 + 3 - (4 + 5)) ```\n```1 - 2 + 3 - 4 + 5 ```\n```1 - 2 - 3 + 4 + 5 ```\n```\\nacc = 0   // accumulator\\nprevSign = +1  // previously encountered sign/operator\\nsignStack = []  // signs of opening parentheses\\nparenSigns = +1  // overall sign of current group of parentheses\\n\\nfor (token in s) {  // suppose we tokenized s into signs, numbers and parentheses\\n    if (token in [\\'+\\', \\'-\\'])  prevSign = (token == \\'+\\' ? +1 : -1)\\n\\telse if (token == \\'(\\')  {\\n\\t  signStack.push(prevSign)\\n\\t  if (prevSign < 0) parenSigns *= -1  // invert sign of nested paretheses\\n\\t  prevSign = +1 // after the opening parethesis, we assume sign is always positive (as in the start of new expression)\\n\\t} else if (token == \\')\\') {\\n\\t  if (signStack.pop() < 0) parenSigns *= -1 // revert sign back\\n\\t} else acc += prevSign * parenSigns * toInt(token)\\n}\\n\\nreturn acc\\n```\n```\\nclass Solution {\\n    \\n    fun calculate(s: String): Int {\\n        var acc = 0        \\n        var i = 0\\n        \\n        val signStack = LinkedList<Int>()  \\n        var parenSigns = 1\\n        var prevSign = 1\\n        \\n        while (i < s.length) {\\n            val c = s[i]\\n            when(c) {\\n                \\' \\' -> {}\\n                \\'(\\' -> { \\n                    signStack.push(prevSign)\\n                    if (prevSign < 0) parenSigns *= -1\\n                    prevSign = 1\\n                }\\n                \\')\\' -> if (signStack.pop() < 0) parenSigns *= -1\\n                \\'+\\' ->  prevSign = 1\\n                \\'-\\' -> prevSign = -1\\n                else -> { // parse whole number\\n                    var n = 0\\n                    while(i < s.length && \\'0\\' <= s[i] && s[i] <= \\'9\\') {\\n                        n = n * 10 + (s[i] - \\'0\\')\\n                        i++\\n                    }\\n                    i--\\n                    acc += n * parenSigns * prevSign\\n                }\\n            }\\n            i++\\n        }\\n     \\n        return acc\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504818,
                "title": "java-recursion",
                "content": "```java\\npublic static enum Operation {\\n\\tPLUS,\\n\\tMINUS;\\n}\\nint i = 0;\\n\\npublic int calculate(String s) {\\n\\tint num = 0;\\n\\tOperation operation = null;\\n\\twhile (i < s.length()) {\\n\\t\\tswitch (s.charAt(i)) {\\n\\t\\t\\tcase \\' \\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'(\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tnum = operate(num, operation, calculate(s));\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\')\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\treturn num;\\n\\t\\t\\tcase \\'+\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\toperation = Operation.PLUS;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'-\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\toperation = Operation.MINUS;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tint digit = getDigit(s);\\n\\t\\t\\t\\tnum = operate(num, operation, digit);\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn num;\\n}\\n\\npublic int operate(int num1, Operation operation, int num2) {\\n\\tif (operation == null) {\\n\\t\\treturn num2;\\n\\t}\\n\\tswitch (operation) {\\n\\t\\tcase PLUS:\\n\\t\\t\\treturn num1 + num2;\\n\\t\\tcase MINUS:\\n\\t\\t\\treturn num1 - num2;\\n\\t}\\n\\tthrow new IllegalStateException();\\n}\\n\\npublic int getDigit(String s) {\\n\\tint start = i;\\n\\twhile (i < s.length() && Character.isDigit(s.charAt(i))) {\\n\\t\\ti++;\\n\\t}\\n\\treturn Integer.parseInt(s.substring(start, i));\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic static enum Operation {\\n\\tPLUS,\\n\\tMINUS;\\n}\\nint i = 0;\\n\\npublic int calculate(String s) {\\n\\tint num = 0;\\n\\tOperation operation = null;\\n\\twhile (i < s.length()) {\\n\\t\\tswitch (s.charAt(i)) {\\n\\t\\t\\tcase \\' \\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'(\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tnum = operate(num, operation, calculate(s));\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\')\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\treturn num;\\n\\t\\t\\tcase \\'+\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\toperation = Operation.PLUS;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'-\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\toperation = Operation.MINUS;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tint digit = getDigit(s);\\n\\t\\t\\t\\tnum = operate(num, operation, digit);\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn num;\\n}\\n\\npublic int operate(int num1, Operation operation, int num2) {\\n\\tif (operation == null) {\\n\\t\\treturn num2;\\n\\t}\\n\\tswitch (operation) {\\n\\t\\tcase PLUS:\\n\\t\\t\\treturn num1 + num2;\\n\\t\\tcase MINUS:\\n\\t\\t\\treturn num1 - num2;\\n\\t}\\n\\tthrow new IllegalStateException();\\n}\\n\\npublic int getDigit(String s) {\\n\\tint start = i;\\n\\twhile (i < s.length() && Character.isDigit(s.charAt(i))) {\\n\\t\\ti++;\\n\\t}\\n\\treturn Integer.parseInt(s.substring(start, i));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502247,
                "title": "simple-python-stack-solution",
                "content": "```\\ndef calculate(self, s):\\n        s, stack = s.strip(), []\\n        s = \\'(\\' + s + \\')\\'\\n        for char in s:\\n            if char != \\')\\':\\n                stack.append(char)\\n            else:\\n                add, subtract = [], []\\n                while stack[-1] != \\'(\\':\\n                    num1 = \\'\\'\\n                    while stack[-1] not in [\\'+\\',\\'-\\', \\'(\\']:\\n                        num1 = stack.pop(-1) + num1\\n                    symbol = stack.pop(-1) if stack[-1] in [\\'+\\',\\'-\\'] else \\'+\\'\\n                    if symbol == \\'+\\':\\n                        add.append(int(num1))\\n                    else:\\n                        subtract.append(int(num1))\\n                stack.pop(-1)\\n                stack.append(str(sum(add)-sum(subtract)))\\n        return stack[-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef calculate(self, s):\\n        s, stack = s.strip(), []\\n        s = \\'(\\' + s + \\')\\'\\n        for char in s:\\n            if char != \\')\\':\\n                stack.append(char)\\n            else:\\n                add, subtract = [], []\\n                while stack[-1] != \\'(\\':\\n                    num1 = \\'\\'\\n                    while stack[-1] not in [\\'+\\',\\'-\\', \\'(\\']:\\n                        num1 = stack.pop(-1) + num1\\n                    symbol = stack.pop(-1) if stack[-1] in [\\'+\\',\\'-\\'] else \\'+\\'\\n                    if symbol == \\'+\\':\\n                        add.append(int(num1))\\n                    else:\\n                        subtract.append(int(num1))\\n                stack.pop(-1)\\n                stack.append(str(sum(add)-sum(subtract)))\\n        return stack[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 459447,
                "title": "java-expression-tree",
                "content": "Build the expression tree of the input string in linear time with a stack. Then traverse the tree and get the value of the input expression. This method is not as fast but could be applied to other expression porblems such as polish and reverse polish notation.\\n\\nCode:\\nclass Solution {\\n    public class Node{\\n        String ch;\\n        int level;\\n        Node left;\\n        Node right;\\n        \\n        Node(String ch, int level){\\n            this.ch = ch;\\n            this.level = level;\\n            left = null;\\n            right = null;\\n        }\\n    }\\n    \\n    public void helper(Stack<Node> s, Node n){ // build the tree with a monotonous stack according to the level\\n        if(s.isEmpty()){\\n            s.push(n);\\n            return;\\n        }\\n        \\n        while(!s.isEmpty() && n.level <= s.peek().level){\\n            Node out = s.pop();\\n            \\n            if(s.isEmpty()){\\n                n.left = out;\\n            }else{\\n                s.peek().right = null;\\n                if(n.level > s.peek().level){\\n                    n.left = out;\\n                }else{\\n                    s.peek().right = out;\\n                }\\n            }\\n        }\\n        \\n        if(!s.isEmpty()) s.peek().right = n;\\n        s.push(n);\\n    }\\n    \\n    public int dfs(Node n){\\n        if(!n.ch.equals(\"+\") && !n.ch.equals(\"-\")){\\n            return Integer.parseInt(n.ch);\\n        }\\n        \\n        int left = dfs(n.left);\\n        int right = dfs(n.right);\\n        if(n.ch.equals(\"+\")) return left + right;\\n        return left - right;\\n        \\n    }\\n    \\n    public int calculate(String s) {\\n        int level = 0;\\n        char[] ch = s.toCharArray();\\n        Stack<Node> stack = new Stack<>();\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(ch[i] == \\' \\') continue;\\n            if(ch[i] == \\'(\\'){\\n                level+=10;\\n            }else if(ch[i] == \\')\\'){\\n                level-=10;\\n            }else if(ch[i] == \\'+\\' || ch[i] == \\'-\\'){ // + and - have the same level\\n                Node cur = new Node(String.valueOf(ch[i]), level);\\n                helper(stack, cur);\\n            }else{ // digits have the maximum level and donnot take parenthesis into account\\n                StringBuilder sb = new StringBuilder(\"\");\\n                while(i < s.length() && Character.isDigit(ch[i])){\\n                    sb.append(ch[i]);\\n                    i++;\\n                }\\n                i--;\\n                Node cur = new Node(sb.toString(), Integer.MAX_VALUE);\\n                helper(stack, cur);\\n            }\\n        }\\n        \\n        if(stack.isEmpty()) return 0;\\n        \\n        while(stack.size() > 1) stack.pop();\\n        \\n        \\n        return dfs(stack.peek());\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public class Node{\\n        String ch;\\n        int level;\\n        Node left;\\n        Node right;\\n        \\n        Node(String ch, int level){\\n            this.ch = ch;\\n            this.level = level;\\n            left = null;\\n            right = null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 405389,
                "title": "java-recursion-2ms-beat-99",
                "content": "Different strategies for \\'(\\', \\')\\', digit, \\'+\\', \\'-\\' and the rest. A global pointer in[] p moves in one direction. Hence, the time complexity is O(n)\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        return parse(s, new int[]{0});\\n    }\\n    \\n    private int parse(String s, int[] p) {\\n        int res = 0;\\n        int sign = 1;\\n        while (p[0] < s.length()) {\\n            if (s.charAt(p[0]) == \\'(\\') {\\n                p[0]++;\\n                res += sign * parse(s, p);\\n                continue;\\n            } else if (s.charAt(p[0]) == \\')\\') {\\n                p[0]++;\\n                return res;\\n            } else if (Character.isDigit(s.charAt(p[0]))) {\\n                res += sign * getNum(s, p);\\n                continue;\\n            } else if (s.charAt(p[0]) == \\'+\\') {\\n                sign = 1;\\n            } else if (s.charAt(p[0]) == \\'-\\') {\\n                sign = -1;\\n            }\\n            p[0]++;\\n        }\\n        return res;\\n    }\\n    \\n    private int getNum(String s, int[] p) {\\n        int num = 0;\\n        while (p[0] < s.length() && Character.isDigit(s.charAt(p[0]))) {\\n            num = s.charAt(p[0]++) - \\'0\\' + num * 10;\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        return parse(s, new int[]{0});\\n    }\\n    \\n    private int parse(String s, int[] p) {\\n        int res = 0;\\n        int sign = 1;\\n        while (p[0] < s.length()) {\\n            if (s.charAt(p[0]) == \\'(\\') {\\n                p[0]++;\\n                res += sign * parse(s, p);\\n                continue;\\n            } else if (s.charAt(p[0]) == \\')\\') {\\n                p[0]++;\\n                return res;\\n            } else if (Character.isDigit(s.charAt(p[0]))) {\\n                res += sign * getNum(s, p);\\n                continue;\\n            } else if (s.charAt(p[0]) == \\'+\\') {\\n                sign = 1;\\n            } else if (s.charAt(p[0]) == \\'-\\') {\\n                sign = -1;\\n            }\\n            p[0]++;\\n        }\\n        return res;\\n    }\\n    \\n    private int getNum(String s, int[] p) {\\n        int num = 0;\\n        while (p[0] < s.length() && Character.isDigit(s.charAt(p[0]))) {\\n            num = s.charAt(p[0]++) - \\'0\\' + num * 10;\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255794,
                "title": "2-approaches-in-go-golang",
                "content": "1st approach: naive approach\\n---\\n```\\n/*\\n\\t1st approach:\\n\\t- use 2 stacks\\n\\t- the basic idea is to save each operator with the level of parenthesis, see type OpStack\\n\\t- when there is a ), sum up the result on the same parenthesis level, and decrement the global parenthesis level\\n\\n\\te.g. 1+2-(3+4-(5+6))+7\\n\\titerations on each token:\\n\\t1:\\tnumstack = [1]\\n\\t+:\\topstack = [(+,0)]\\n\\t2:\\tnumstack = [1,2]\\n\\t-:\\topstack = [(+,0),(-,0)]\\n\\t(:\\tparenthesesCount 0->1\\n\\t3:\\tnumstack = [1,2,3]\\n\\t+:\\topstack = [(+,0),(-,0),(+,1)]\\n\\t4:\\tnumstack = [1,2,3,4]\\n\\t-:\\topstack = [(+,0),(-,0),(+,1),(-,1)]\\n\\t(:\\tparenthesesCount 1->2\\n\\t5:\\tnumstack = [1,2,3,4,5]\\n\\t+:\\topstack = [(+,0),(-,0),(+,1),(-,1),(+,2)]\\n\\t6:\\tnumstack = [1,2,3,4,5,6]\\n\\t):\\tnumstack = [1,2,3,4,11], opstack = [(+,0),(-,0),(+,1),(-,1)], parenthesesCount 2->1\\n\\t):\\tnumstack = [1,2,-4], opstack = [(+,0),(-,0)], parenthesesCount 1->0\\n\\t+:\\topstack = [(+,0),(-,0),(+,0)]\\n\\t7+\\tnumstack = [1,2,-4,7]\\n\\tend: iterate the numstack and calculate 1+2-(-4)+7=>14\\n\\n\\tTime\\tO(2n) the nested loop actually just runs one time time\\n\\tSpace O(n)\\n\\t28 ms, faster than 25.49%\\n*/\\ntype OpStack struct {\\n\\toperator byte\\n\\tlevel    int\\n}\\n\\nfunc calculate(s string) int {\\n\\tparenthesesCount := 0\\n\\toperatorStack := []OpStack{}\\n\\tnumberStack := []int{}\\n\\ti := 0\\n\\tfor i < len(s) {\\n\\t    // construct a multi-digits number if any, e.g. \"23\" = 2*10+3 = 23\\n\\t\\tif unicode.IsDigit(rune(s[i])) == true {\\n\\t\\t\\tcurNum := 0\\n\\t\\t\\tj := i\\n\\t\\t\\tfor j < len(s) && unicode.IsDigit(rune(s[j])) == true {\\n\\t\\t\\t\\tcurNum = curNum*10 + int(s[j]-\\'0\\')\\n\\t\\t\\t\\tj++\\n\\t\\t\\t}\\n\\t\\t\\tnumberStack = append(numberStack, curNum)\\n\\t\\t\\ti = j\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif s[i] == \\'+\\' || s[i] == \\'-\\' {\\n\\t\\t\\toperatorStack = append(operatorStack, OpStack{s[i], parenthesesCount})\\n\\t\\t}\\n\\t\\tif s[i] == \\'(\\' {\\n\\t\\t\\tparenthesesCount++\\n\\t\\t}\\n\\t\\tif s[i] == \\')\\' {\\n\\t\\t\\tif len(operatorStack) == 0 {\\n\\t\\t\\t\\tparenthesesCount--\\n\\t\\t\\t\\ti++\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\t// pop the items on the same level for calculation\\n\\t\\t\\tlevel := operatorStack[len(operatorStack)-1].level\\n\\t\\t\\tarr := []int{}\\n\\t\\t\\toperators := []byte{}\\n\\n\\t\\t\\tpop := numberStack[len(numberStack)-1]\\n\\t\\t\\tnumberStack = numberStack[:len(numberStack)-1]\\n\\t\\t\\tarr = append([]int{pop}, arr...)\\n\\t\\t\\tfor len(operatorStack) > 0 && operatorStack[len(operatorStack)-1].level == level {\\n\\t\\t\\t\\tpop := numberStack[len(numberStack)-1]\\n\\t\\t\\t\\tnumberStack = numberStack[:len(numberStack)-1]\\n\\t\\t\\t\\tarr = append([]int{pop}, arr...)\\n\\n\\t\\t\\t\\tpopOp := operatorStack[len(operatorStack)-1]\\n\\t\\t\\t\\toperatorStack = operatorStack[:len(operatorStack)-1]\\n\\t\\t\\t\\toperators = append([]byte{popOp.operator}, operators...)\\n\\t\\t\\t}\\n\\t\\t\\t// calculate the result within the current \"(...)\"\\n\\t\\t\\ttemp := 0\\n\\t\\t\\top := \\'+\\'\\n\\t\\t\\tfor _, num := range arr {\\n\\t\\t\\t\\tif op == \\'+\\' {\\n\\t\\t\\t\\t\\ttemp += num\\n\\t\\t\\t\\t} else if op == \\'-\\' {\\n\\t\\t\\t\\t\\ttemp -= num\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif len(operators) > 0 {\\n\\t\\t\\t\\t\\top = rune(operators[0])\\n\\t\\t\\t\\t\\toperators = operators[1:]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnumberStack = append(numberStack, temp)\\n\\t\\t\\tparenthesesCount--\\n\\t\\t}\\n\\t\\ti++\\n\\t}\\n\\t// calculate if there are still operators in the stack\\n\\ttemp := numberStack[0]\\n\\tnumberStack = numberStack[1:]\\n\\tfor len(operatorStack) > 0 {\\n\\t\\top := rune(operatorStack[0].operator)\\n\\t\\toperatorStack = operatorStack[1:]\\n\\n\\t\\tpop := numberStack[0]\\n\\t\\tnumberStack = numberStack[1:]\\n\\t\\tif op == \\'+\\' {\\n\\t\\t\\ttemp += pop\\n\\t\\t} else if op == \\'-\\' {\\n\\t\\t\\ttemp -= pop\\n\\t\\t}\\n\\t}\\n\\n\\treturn temp\\n}\\n```\\nI first cam up with the above approach, because it was straightforward but it is very tedious, \\n- we use 2 stacks\\n- as well as defining a type struct\\n- once we see a `)`, we need to iterate back to calculate the sum which slow down the overall calculation.\\n\\nBut then I was inspired by @southpenguin with his/her concise [approach in java](https://leetcode.com/problems/basic-calculator/discuss/62361/Iterative-Java-solution-with-stack) and rewrote it in golang\\n\\n2nd Approach\\n---\\n```\\n/*\\n\\t2nd approach: suggested solution at https://leetcode.com/problems/basic-calculator/discuss/62361/Iterative-Java-solution-with-stack\\n\\t- use 1 stack\\n\\t- calculate the numbers on the same level\\n\\t- when we see (, put the intermediate result into a stack, and new calculation start from the (\\n\\t- when we see ), pop the add/minus the result with the last item in the stack\\n\\n\\tTime\\tO(n) the nested loop actually just runs one time time\\n\\tSpace O(n)\\n\\t4 ms, faster than 90.20%\\n*/\\nfunc calculate1(s string) int {\\n\\tres := 0\\n\\tstack := make([]int, 0, len(s))\\n\\t// 1 means positive, -1 means negative\\n\\t// we declare it as an integer because we want to put the +- in the stack too\\n\\tsign := 1\\n\\tnum := 0\\n\\t// iteration\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\', \\'0\\':\\n\\t\\t\\t// construct a multi-digits number if any, e.g. \"23\" = 2*10+3 = 23\\n\\t\\t\\tj := i\\n\\t\\t\\tnum = 0\\n\\t\\t\\tfor j < len(s) && unicode.IsDigit(rune(s[j])) == true {\\n\\t\\t\\t\\tnum = num*10 + int(s[j]-\\'0\\')\\n\\t\\t\\t\\tj++\\n\\t\\t\\t}\\n\\t\\t\\t// sum up the intermediate result\\n\\t\\t\\tres += sign * num\\n\\t\\t\\t// since forloop add 1 at the end of closure, we -1\\n\\t\\t\\ti = j - 1\\n\\t\\tcase \\'+\\':\\n\\t\\t\\t// positive\\n\\t\\t\\tsign = 1\\n\\t\\tcase \\'-\\':\\n\\t\\t\\t// negative\\n\\t\\t\\tsign = -1\\n\\t\\tcase \\'(\\':\\n\\t\\t\\t// put the intermediate result(from the front) and sign into the stack\\n\\t\\t\\tstack = append(stack, res)\\n\\t\\t\\tstack = append(stack, sign)\\n\\t\\t\\t// since we have put the intermediate result in stack,\\n\\t\\t\\t// we can reset the things for calculation starting from this (\\n\\t\\t\\tres = 0\\n\\t\\t\\tsign = 1\\n\\t\\tcase \\')\\':\\n\\t\\t\\t// last item is the sign we saved for calculation e.g. 1+(2+3) the 1st +\\n\\t\\t\\tsign = stack[len(stack)-1]\\n\\t\\t\\t// previousLevelResult the intermediate result before this level, \"(...)\"\\n\\t\\t\\tpreviousLevelResult := stack[len(stack)-2]\\n\\t\\t\\t// pop them\\n\\t\\t\\tstack = stack[:len(stack)-2]\\n\\t\\t\\t// sign*res is the result within the current level, \"(...)\"\\n\\t\\t\\tres = previousLevelResult + sign*res\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\t1st approach:\\n\\t- use 2 stacks\\n\\t- the basic idea is to save each operator with the level of parenthesis, see type OpStack\\n\\t- when there is a ), sum up the result on the same parenthesis level, and decrement the global parenthesis level\\n\\n\\te.g. 1+2-(3+4-(5+6))+7\\n\\titerations on each token:\\n\\t1:\\tnumstack = [1]\\n\\t+:\\topstack = [(+,0)]\\n\\t2:\\tnumstack = [1,2]\\n\\t-:\\topstack = [(+,0),(-,0)]\\n\\t(:\\tparenthesesCount 0->1\\n\\t3:\\tnumstack = [1,2,3]\\n\\t+:\\topstack = [(+,0),(-,0),(+,1)]\\n\\t4:\\tnumstack = [1,2,3,4]\\n\\t-:\\topstack = [(+,0),(-,0),(+,1),(-,1)]\\n\\t(:\\tparenthesesCount 1->2\\n\\t5:\\tnumstack = [1,2,3,4,5]\\n\\t+:\\topstack = [(+,0),(-,0),(+,1),(-,1),(+,2)]\\n\\t6:\\tnumstack = [1,2,3,4,5,6]\\n\\t):\\tnumstack = [1,2,3,4,11], opstack = [(+,0),(-,0),(+,1),(-,1)], parenthesesCount 2->1\\n\\t):\\tnumstack = [1,2,-4], opstack = [(+,0),(-,0)], parenthesesCount 1->0\\n\\t+:\\topstack = [(+,0),(-,0),(+,0)]\\n\\t7+\\tnumstack = [1,2,-4,7]\\n\\tend: iterate the numstack and calculate 1+2-(-4)+7=>14\\n\\n\\tTime\\tO(2n) the nested loop actually just runs one time time\\n\\tSpace O(n)\\n\\t28 ms, faster than 25.49%\\n*/\\ntype OpStack struct {\\n\\toperator byte\\n\\tlevel    int\\n}\\n\\nfunc calculate(s string) int {\\n\\tparenthesesCount := 0\\n\\toperatorStack := []OpStack{}\\n\\tnumberStack := []int{}\\n\\ti := 0\\n\\tfor i < len(s) {\\n\\t    // construct a multi-digits number if any, e.g. \"23\" = 2*10+3 = 23\\n\\t\\tif unicode.IsDigit(rune(s[i])) == true {\\n\\t\\t\\tcurNum := 0\\n\\t\\t\\tj := i\\n\\t\\t\\tfor j < len(s) && unicode.IsDigit(rune(s[j])) == true {\\n\\t\\t\\t\\tcurNum = curNum*10 + int(s[j]-\\'0\\')\\n\\t\\t\\t\\tj++\\n\\t\\t\\t}\\n\\t\\t\\tnumberStack = append(numberStack, curNum)\\n\\t\\t\\ti = j\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif s[i] == \\'+\\' || s[i] == \\'-\\' {\\n\\t\\t\\toperatorStack = append(operatorStack, OpStack{s[i], parenthesesCount})\\n\\t\\t}\\n\\t\\tif s[i] == \\'(\\' {\\n\\t\\t\\tparenthesesCount++\\n\\t\\t}\\n\\t\\tif s[i] == \\')\\' {\\n\\t\\t\\tif len(operatorStack) == 0 {\\n\\t\\t\\t\\tparenthesesCount--\\n\\t\\t\\t\\ti++\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\t// pop the items on the same level for calculation\\n\\t\\t\\tlevel := operatorStack[len(operatorStack)-1].level\\n\\t\\t\\tarr := []int{}\\n\\t\\t\\toperators := []byte{}\\n\\n\\t\\t\\tpop := numberStack[len(numberStack)-1]\\n\\t\\t\\tnumberStack = numberStack[:len(numberStack)-1]\\n\\t\\t\\tarr = append([]int{pop}, arr...)\\n\\t\\t\\tfor len(operatorStack) > 0 && operatorStack[len(operatorStack)-1].level == level {\\n\\t\\t\\t\\tpop := numberStack[len(numberStack)-1]\\n\\t\\t\\t\\tnumberStack = numberStack[:len(numberStack)-1]\\n\\t\\t\\t\\tarr = append([]int{pop}, arr...)\\n\\n\\t\\t\\t\\tpopOp := operatorStack[len(operatorStack)-1]\\n\\t\\t\\t\\toperatorStack = operatorStack[:len(operatorStack)-1]\\n\\t\\t\\t\\toperators = append([]byte{popOp.operator}, operators...)\\n\\t\\t\\t}\\n\\t\\t\\t// calculate the result within the current \"(...)\"\\n\\t\\t\\ttemp := 0\\n\\t\\t\\top := \\'+\\'\\n\\t\\t\\tfor _, num := range arr {\\n\\t\\t\\t\\tif op == \\'+\\' {\\n\\t\\t\\t\\t\\ttemp += num\\n\\t\\t\\t\\t} else if op == \\'-\\' {\\n\\t\\t\\t\\t\\ttemp -= num\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif len(operators) > 0 {\\n\\t\\t\\t\\t\\top = rune(operators[0])\\n\\t\\t\\t\\t\\toperators = operators[1:]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnumberStack = append(numberStack, temp)\\n\\t\\t\\tparenthesesCount--\\n\\t\\t}\\n\\t\\ti++\\n\\t}\\n\\t// calculate if there are still operators in the stack\\n\\ttemp := numberStack[0]\\n\\tnumberStack = numberStack[1:]\\n\\tfor len(operatorStack) > 0 {\\n\\t\\top := rune(operatorStack[0].operator)\\n\\t\\toperatorStack = operatorStack[1:]\\n\\n\\t\\tpop := numberStack[0]\\n\\t\\tnumberStack = numberStack[1:]\\n\\t\\tif op == \\'+\\' {\\n\\t\\t\\ttemp += pop\\n\\t\\t} else if op == \\'-\\' {\\n\\t\\t\\ttemp -= pop\\n\\t\\t}\\n\\t}\\n\\n\\treturn temp\\n}\\n```\n```\\n/*\\n\\t2nd approach: suggested solution at https://leetcode.com/problems/basic-calculator/discuss/62361/Iterative-Java-solution-with-stack\\n\\t- use 1 stack\\n\\t- calculate the numbers on the same level\\n\\t- when we see (, put the intermediate result into a stack, and new calculation start from the (\\n\\t- when we see ), pop the add/minus the result with the last item in the stack\\n\\n\\tTime\\tO(n) the nested loop actually just runs one time time\\n\\tSpace O(n)\\n\\t4 ms, faster than 90.20%\\n*/\\nfunc calculate1(s string) int {\\n\\tres := 0\\n\\tstack := make([]int, 0, len(s))\\n\\t// 1 means positive, -1 means negative\\n\\t// we declare it as an integer because we want to put the +- in the stack too\\n\\tsign := 1\\n\\tnum := 0\\n\\t// iteration\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\', \\'0\\':\\n\\t\\t\\t// construct a multi-digits number if any, e.g. \"23\" = 2*10+3 = 23\\n\\t\\t\\tj := i\\n\\t\\t\\tnum = 0\\n\\t\\t\\tfor j < len(s) && unicode.IsDigit(rune(s[j])) == true {\\n\\t\\t\\t\\tnum = num*10 + int(s[j]-\\'0\\')\\n\\t\\t\\t\\tj++\\n\\t\\t\\t}\\n\\t\\t\\t// sum up the intermediate result\\n\\t\\t\\tres += sign * num\\n\\t\\t\\t// since forloop add 1 at the end of closure, we -1\\n\\t\\t\\ti = j - 1\\n\\t\\tcase \\'+\\':\\n\\t\\t\\t// positive\\n\\t\\t\\tsign = 1\\n\\t\\tcase \\'-\\':\\n\\t\\t\\t// negative\\n\\t\\t\\tsign = -1\\n\\t\\tcase \\'(\\':\\n\\t\\t\\t// put the intermediate result(from the front) and sign into the stack\\n\\t\\t\\tstack = append(stack, res)\\n\\t\\t\\tstack = append(stack, sign)\\n\\t\\t\\t// since we have put the intermediate result in stack,\\n\\t\\t\\t// we can reset the things for calculation starting from this (\\n\\t\\t\\tres = 0\\n\\t\\t\\tsign = 1\\n\\t\\tcase \\')\\':\\n\\t\\t\\t// last item is the sign we saved for calculation e.g. 1+(2+3) the 1st +\\n\\t\\t\\tsign = stack[len(stack)-1]\\n\\t\\t\\t// previousLevelResult the intermediate result before this level, \"(...)\"\\n\\t\\t\\tpreviousLevelResult := stack[len(stack)-2]\\n\\t\\t\\t// pop them\\n\\t\\t\\tstack = stack[:len(stack)-2]\\n\\t\\t\\t// sign*res is the result within the current level, \"(...)\"\\n\\t\\t\\tres = previousLevelResult + sign*res\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 236171,
                "title": "cannot-pass-the-test-case-2147483640-55",
                "content": "I run into overflow issues since int cannot handle such large number. Any insights on how to handle this?\\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int sign = 1, curr = 0, result = 0;\\n        stack<int> nums;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (isdigit(s[i])) {\\n                curr = s[i] - \\'0\\';\\n                while ( i + 1 < s.length() && isdigit(s[i + 1])) {\\n                    curr = curr*10 + (s[i + 1] - \\'0\\');\\n                    ++i;\\n                }\\n                result += sign*curr;\\n                sign = 1;\\n            } else if (s[i] == \\'+\\') {\\n                sign = 1;\\n            } else if (s[i] == \\'-\\') {\\n                sign = -1;\\n            } else if (s[i] == \\'(\\') {\\n                nums.push(result);\\n                nums.push(sign);\\n                sign = 1;\\n                result = 0;\\n            } else if (s[i] == \\')\\') {\\n                result *= nums.top();\\n                nums.pop();\\n                result += nums.top();\\n                nums.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int sign = 1, curr = 0, result = 0;\\n        stack<int> nums;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (isdigit(s[i])) {\\n                curr = s[i] - \\'0\\';\\n                while ( i + 1 < s.length() && isdigit(s[i + 1])) {\\n                    curr = curr*10 + (s[i + 1] - \\'0\\');\\n                    ++i;\\n                }\\n                result += sign*curr;\\n                sign = 1;\\n            } else if (s[i] == \\'+\\') {\\n                sign = 1;\\n            } else if (s[i] == \\'-\\') {\\n                sign = -1;\\n            } else if (s[i] == \\'(\\') {\\n                nums.push(result);\\n                nums.push(sign);\\n                sign = 1;\\n                result = 0;\\n            } else if (s[i] == \\')\\') {\\n                result *= nums.top();\\n                nums.pop();\\n                result += nums.top();\\n                nums.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194363,
                "title": "simple-parser-solution-in-python",
                "content": "In case you guys don\\'t know here is the grammar for the language of arithmetic expressions (http://www.cs.gordon.edu/courses/cps222/examples-2015/Recursion/grammar.pdf)\\n\\nSince we don\\'t need to support * and / it\\'s easy. Our Grammar is way restricted:\\n```\\n## Grammar\\nE  := T Op E | T\\nOp := + | -\\nT  := ( E ) | Num  \\n```\\n\\nAll we need is to split the input into tokens using regex (spare some effort removing whitespaces and building up the numbers).\\nMy simple regex: `\"\\\\d+|\\\\(|\\\\)|\\\\+|\\\\-\"`\\n\\nThen we build the recursive descent parser -> a parse method for every non-terminal (aka vars on the left side). But since we have only 2 (E and T) it\\'s fairly easy.\\n\\n```\\nimport re\\n\\nclass BinOp(object):\\n    def __init__(self, left, right):\\n        self.left = left\\n        self.right = right\\n\\nclass Plus(BinOp):\\n    def eval(self): return self.left.eval() + self.right.eval()\\n\\nclass Minus(BinOp):\\n    def eval(self): return self.left.eval() - self.right.eval()\\n\\nclass Number(object):\\n    def __init__(self, val): self.val = int(val)\\n    def eval(self): return self.val\\n\\nclass Parser(object):\\n    def lookahead(self): return self.tokens[self.idx]\\n    \\n    def consume(self): \\n        token = self.lookahead()\\n        self.idx += 1\\n        return token\\n    \\n    def parse(self, tokens): \\n        if len(tokens) == 0: return Number(0)\\n\\n        self.idx = 0\\n        self.tokens = tokens    \\n        return self.__parse_e__()\\n    \\n    def __parse_e__(self):\\n        t = self.__parse_v__()\\n        \\n        while self.idx < len(self.tokens) and self.lookahead() in [\\'+\\', \\'-\\']:\\n            op = self.consume()\\n            t1 = self.__parse_v__()\\n            t = Plus(t, t1) if op == \\'+\\' else Minus(t, t1)\\n            \\n        return t\\n    \\n    def __parse_v__(self):\\n        node = None\\n        if self.lookahead() == \\'(\\':\\n            self.consume() ## \\')\\'\\n            node = self.__parse_e__()\\n            self.consume() ## \\')\\'\\n        else:\\n            node = Number(self.consume())\\n        \\n        return node\\n\\nclass Solution(object):\\n    def calculate(self, s):\\n        def scan(s): return re.findall(\"\\\\d+|\\\\(|\\\\)|\\\\+|\\\\-\", filter(lambda char: char != \\' \\', s))\\n        \\n        tokens = scan(s)\\n        tree = Parser().parse(tokens)\\n        return tree.eval()\\n```",
                "solutionTags": [],
                "code": "```\\n## Grammar\\nE  := T Op E | T\\nOp := + | -\\nT  := ( E ) | Num  \\n```\n```\\nimport re\\n\\nclass BinOp(object):\\n    def __init__(self, left, right):\\n        self.left = left\\n        self.right = right\\n\\nclass Plus(BinOp):\\n    def eval(self): return self.left.eval() + self.right.eval()\\n\\nclass Minus(BinOp):\\n    def eval(self): return self.left.eval() - self.right.eval()\\n\\nclass Number(object):\\n    def __init__(self, val): self.val = int(val)\\n    def eval(self): return self.val\\n\\nclass Parser(object):\\n    def lookahead(self): return self.tokens[self.idx]\\n    \\n    def consume(self): \\n        token = self.lookahead()\\n        self.idx += 1\\n        return token\\n    \\n    def parse(self, tokens): \\n        if len(tokens) == 0: return Number(0)\\n\\n        self.idx = 0\\n        self.tokens = tokens    \\n        return self.__parse_e__()\\n    \\n    def __parse_e__(self):\\n        t = self.__parse_v__()\\n        \\n        while self.idx < len(self.tokens) and self.lookahead() in [\\'+\\', \\'-\\']:\\n            op = self.consume()\\n            t1 = self.__parse_v__()\\n            t = Plus(t, t1) if op == \\'+\\' else Minus(t, t1)\\n            \\n        return t\\n    \\n    def __parse_v__(self):\\n        node = None\\n        if self.lookahead() == \\'(\\':\\n            self.consume() ## \\')\\'\\n            node = self.__parse_e__()\\n            self.consume() ## \\')\\'\\n        else:\\n            node = Number(self.consume())\\n        \\n        return node\\n\\nclass Solution(object):\\n    def calculate(self, s):\\n        def scan(s): return re.findall(\"\\\\d+|\\\\(|\\\\)|\\\\+|\\\\-\", filter(lambda char: char != \\' \\', s))\\n        \\n        tokens = scan(s)\\n        tree = Parser().parse(tokens)\\n        return tree.eval()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62368,
                "title": "c-clean-code-iterative-recursion",
                "content": "**Iterative Solution using stack**\\n```\\n/**\\n * 1. update result - end of number; end of ')'\\n *    res += sign * num;\\n * 2. every operand num have a sign;\\n * 3. push temp result & sign on stack - begin of another \"(\"\\n */\\n```\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<tuple<int, int>> stk;\\n        int res = 0;\\n        int sign = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (isdigit(s[i])) {\\n                int start = i;\\n                while (isdigit(s[i + 1])) { i++; }\\n                res += sign * stoi(s.substr(start, i + 1 - start));\\n            }\\n            else {\\n                if (s[i] == '+') {\\n                    sign = 1;\\n                }\\n                else if (s[i] == '-') {\\n                    sign = -1;\\n                }\\n                else if (s[i] == '(') {\\n                    stk.push(tuple<int, int>(sign, res));\\n                    sign = 1;\\n                    res = 0;\\n                }\\n                else if (s[i] == ')') {\\n                    res = res * get<0>(stk.top()) + get<1>(stk.top());\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**StackFrame**\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<StackFrame> stk;\\n        int res = 0;\\n        int sign = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == '+') {\\n                sign = 1;\\n            }\\n            else if (s[i] == '-') {\\n                sign = -1;\\n            }\\n            else if (isdigit(s[i])) {\\n                int start = i;\\n                while (i + 1 < s.length() && isdigit(s[i + 1])) { i++; }\\n                res += sign * stoi(s.substr(start, i + 1 - start));\\n            }\\n            else if (s[i] == '(') {\\n                stk.push(StackFrame(res, sign));\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if (s[i] == ')') {\\n                res = stk.top().base + stk.top().sign * res;\\n                stk.pop();\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\nprivate:\\n    struct StackFrame {\\n        int base;\\n        int sign;\\n        StackFrame(int base, int sign) : base(base), sign(sign) {};\\n    };\\n};\\n```\\n**Recursion Solution**\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return calculate(s, i);\\n    }\\n\\nprivate:\\n    int calculate(string& s, int& i) {\\n        int res = 0;\\n        int sign = 1;\\n        for (; i < s.length(); i++) {\\n            if (isdigit(s[i])) {\\n                int start = i;\\n                while (i + 1 < s.length() && isdigit(s[i + 1])) { i++; }\\n                res += sign * stoi(s.substr(start, i + 1 - start));\\n            }\\n            else if (s[i] == '(') {\\n                res += sign * calculate(s, ++i);\\n            }\\n            else if (s[i] == ')') {\\n                return res;\\n            }\\n            else if (s[i] == '+') {\\n                sign = 1;\\n            }\\n            else if (s[i] == '-') {\\n                sign = -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * 1. update result - end of number; end of ')'\\n *    res += sign * num;\\n * 2. every operand num have a sign;\\n * 3. push temp result & sign on stack - begin of another \"(\"\\n */\\n```\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<tuple<int, int>> stk;\\n        int res = 0;\\n        int sign = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (isdigit(s[i])) {\\n                int start = i;\\n                while (isdigit(s[i + 1])) { i++; }\\n                res += sign * stoi(s.substr(start, i + 1 - start));\\n            }\\n            else {\\n                if (s[i] == '+') {\\n                    sign = 1;\\n                }\\n                else if (s[i] == '-') {\\n                    sign = -1;\\n                }\\n                else if (s[i] == '(') {\\n                    stk.push(tuple<int, int>(sign, res));\\n                    sign = 1;\\n                    res = 0;\\n                }\\n                else if (s[i] == ')') {\\n                    res = res * get<0>(stk.top()) + get<1>(stk.top());\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<StackFrame> stk;\\n        int res = 0;\\n        int sign = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == '+') {\\n                sign = 1;\\n            }\\n            else if (s[i] == '-') {\\n                sign = -1;\\n            }\\n            else if (isdigit(s[i])) {\\n                int start = i;\\n                while (i + 1 < s.length() && isdigit(s[i + 1])) { i++; }\\n                res += sign * stoi(s.substr(start, i + 1 - start));\\n            }\\n            else if (s[i] == '(') {\\n                stk.push(StackFrame(res, sign));\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if (s[i] == ')') {\\n                res = stk.top().base + stk.top().sign * res;\\n                stk.pop();\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\nprivate:\\n    struct StackFrame {\\n        int base;\\n        int sign;\\n        StackFrame(int base, int sign) : base(base), sign(sign) {};\\n    };\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return calculate(s, i);\\n    }\\n\\nprivate:\\n    int calculate(string& s, int& i) {\\n        int res = 0;\\n        int sign = 1;\\n        for (; i < s.length(); i++) {\\n            if (isdigit(s[i])) {\\n                int start = i;\\n                while (i + 1 < s.length() && isdigit(s[i + 1])) { i++; }\\n                res += sign * stoi(s.substr(start, i + 1 - start));\\n            }\\n            else if (s[i] == '(') {\\n                res += sign * calculate(s, ++i);\\n            }\\n            else if (s[i] == ')') {\\n                return res;\\n            }\\n            else if (s[i] == '+') {\\n                sign = 1;\\n            }\\n            else if (s[i] == '-') {\\n                sign = -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62404,
                "title": "general-solution-for-expression-that-contains-and-negative-integer",
                "content": "```Calculator I``` only contains ```+, -, (, )```, and ```Calculator II``` only contains ```+, -, *, /```, but during interview, we could be asked to write the code which need to take all these factors into consideration. So I come up with this solution, maybe some day LeetCode will add this ```Calculator III```.\\n```\\npublic class Solution {\\n    public int calculate(String s) {\\n        if(s == null || s.length() == 0) return 0;\\n\\n        // deal with the negative numbers\\n        if(s.charAt(0) == '-') s = \"0\" + s;\\n        s = s.replace(\"(-\", \"(0-\");\\n\\n        Stack<Character> ops = new Stack<>();\\n        Stack<Integer> nums = new Stack<>();\\n        char[] sArray = s.toCharArray();\\n\\n        for(int i = 0; i < sArray.length; i++) {\\n            char c = sArray[i];\\n            if(c >= '0' && c <= '9') {\\n                // get a complete number\\n                int currNum = c - '0';\\n                while(i + 1 < sArray.length && sArray[i + 1] >= '0' && sArray[i + 1] <= '9') {\\n                    currNum = 10 * currNum + (sArray[++i] - '0');\\n                }\\n\\n                // it is safe to make a calculation only if the previous sign is * or /\\n                if(!ops.isEmpty() && (ops.peek() == '*' || ops.peek() == '/')) {\\n                    int num2 = currNum, num1 = nums.pop();\\n                    nums.push(operation(num1, num2, ops.pop()));\\n                } else {\\n                    // if don't make a calculation, don't forget to push this new number\\n                    nums.push(currNum);\\n                }\\n            } else if(c == '+' || c == '-') {\\n                // it is safe to make a calculation only if the previous sign is not (\\n                if(!ops.isEmpty() && ops.peek() != '(') {\\n                    int num2 = nums.pop(), num1 = nums.pop();\\n                    nums.push(operation(num1, num2, ops.pop()));\\n                }\\n                ops.push(c);\\n            } else if(c == '*' || c == '/') {\\n                ops.push(c);\\n            } else if(c == '(') {\\n                ops.push(c);\\n            } else if(c == ')') {\\n                // make as many calculations as possible until the previous sign is (\\n                while(ops.peek() != '(') {\\n                    int num2 = nums.pop(), num1 = nums.pop();\\n                    nums.push(operation(num1, num2, ops.pop()));\\n                }\\n\\n                // don't forget to pop out the matching '('\\n                ops.pop();\\n            }\\n        }\\n\\n        // before return, pop out two stacks and do the rest of calculations\\n        while(!ops.isEmpty()) {\\n            int num2 = nums.pop(), num1 = nums.pop();\\n            nums.push(operation(num1, num2, ops.pop()));\\n        }\\n        return nums.peek();\\n    }\\n\\n    private int operation(int num1, int num2, char op) {\\n        if(op == '+') return num1 + num2;\\n        else if(op == '-') return num1 - num2;\\n        else if(op == '*') return num1 * num2;\\n        else return num1 / num2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Calculator I```\n```+, -, (, )```\n```Calculator II```\n```+, -, *, /```\n```Calculator III```\n```\\npublic class Solution {\\n    public int calculate(String s) {\\n        if(s == null || s.length() == 0) return 0;\\n\\n        // deal with the negative numbers\\n        if(s.charAt(0) == '-') s = \"0\" + s;\\n        s = s.replace(\"(-\", \"(0-\");\\n\\n        Stack<Character> ops = new Stack<>();\\n        Stack<Integer> nums = new Stack<>();\\n        char[] sArray = s.toCharArray();\\n\\n        for(int i = 0; i < sArray.length; i++) {\\n            char c = sArray[i];\\n            if(c >= '0' && c <= '9') {\\n                // get a complete number\\n                int currNum = c - '0';\\n                while(i + 1 < sArray.length && sArray[i + 1] >= '0' && sArray[i + 1] <= '9') {\\n                    currNum = 10 * currNum + (sArray[++i] - '0');\\n                }\\n\\n                // it is safe to make a calculation only if the previous sign is * or /\\n                if(!ops.isEmpty() && (ops.peek() == '*' || ops.peek() == '/')) {\\n                    int num2 = currNum, num1 = nums.pop();\\n                    nums.push(operation(num1, num2, ops.pop()));\\n                } else {\\n                    // if don't make a calculation, don't forget to push this new number\\n                    nums.push(currNum);\\n                }\\n            } else if(c == '+' || c == '-') {\\n                // it is safe to make a calculation only if the previous sign is not (\\n                if(!ops.isEmpty() && ops.peek() != '(') {\\n                    int num2 = nums.pop(), num1 = nums.pop();\\n                    nums.push(operation(num1, num2, ops.pop()));\\n                }\\n                ops.push(c);\\n            } else if(c == '*' || c == '/') {\\n                ops.push(c);\\n            } else if(c == '(') {\\n                ops.push(c);\\n            } else if(c == ')') {\\n                // make as many calculations as possible until the previous sign is (\\n                while(ops.peek() != '(') {\\n                    int num2 = nums.pop(), num1 = nums.pop();\\n                    nums.push(operation(num1, num2, ops.pop()));\\n                }\\n\\n                // don't forget to pop out the matching '('\\n                ops.pop();\\n            }\\n        }\\n\\n        // before return, pop out two stacks and do the rest of calculations\\n        while(!ops.isEmpty()) {\\n            int num2 = nums.pop(), num1 = nums.pop();\\n            nums.push(operation(num1, num2, ops.pop()));\\n        }\\n        return nums.peek();\\n    }\\n\\n    private int operation(int num1, int num2, char op) {\\n        if(op == '+') return num1 + num2;\\n        else if(op == '-') return num1 - num2;\\n        else if(op == '*') return num1 * num2;\\n        else return num1 / num2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62455,
                "title": "java-one-pass-solution-with-one-stack",
                "content": "The idea is to use a stack to record \"-\" or \"+\" sign before a \"(\". \\n\\n    public class Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        LinkedList<Integer> stack = new LinkedList<>();\\n        stack.push(1);\\n        int sign = 1;\\n        int start = 0;\\n        long rst = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == '+') {\\n                sign = 1;\\n            } else if (s.charAt(i) == '-') {\\n                sign = -1;\\n            } else if (s.charAt(i) == '(') {\\n                stack.push(sign * stack.peek());\\n                sign = 1;\\n            } else if (s.charAt(i) == ')') {\\n                stack.pop();\\n            }\\n            if (isDigit(s, i) && (i == 0 || !isDigit(s, i - 1))) {\\n                start = i;\\n            }\\n            if (isDigit(s, i) && (i == s.length() - 1 || !isDigit(s, i + 1))) {\\n                // find a number\\n                long num = Long.parseLong(s.substring(start, i + 1));\\n                num = num * sign * stack.peek();\\n                rst += num;\\n            }\\n        }\\n        return (int)rst;\\n    }\\n    boolean isDigit(String s, int i) {\\n        return s.charAt(i) >= '0' && s.charAt(i) <= '9';\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62461,
                "title": "recursive-function-java",
                "content": "    public class Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        return rec(s);\\n    }\\n    public int rec(String s){\\n        int curNum = 0;\\n        int preNum = 0;\\n        char oper = ' ';\\n        int i = 0;\\n        while (i < s.length()){\\n            char c = s.charAt(i);\\n            if (c == ' ') {\\n                i++;\\n                continue;\\n            }\\n            else if (c <= '9' && c >= '0') {\\n                curNum = curNum * 10 + c - '0';\\n                i++;\\n                continue;\\n            }\\n            else if (c == '+' || c == '-'){\\n                if (oper != ' '){\\n                    if (oper == '+') preNum = curNum + preNum;\\n                    else preNum = preNum - curNum;\\n                }\\n                else preNum = curNum;\\n                curNum = 0;\\n                oper = c;\\n                i++;\\n            }\\n            else {\\n                int index = i + 1;\\n                int count = 0;\\n                while (s.charAt(index) != ')' || count > 0) {\\n                    if (s.charAt(index) == '(') count++;\\n                    if (s.charAt(index) == ')') count--;\\n                    index++;\\n                }\\n                curNum = rec(s.substring(i + 1, index));\\n                i = index + 1;\\n            }\\n        }\\n        if (oper == ' ') return curNum;\\n        if (oper == '+') return preNum + curNum;\\n        else return preNum - curNum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        return rec(s);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 62466,
                "title": "java-short-solution-java8-new-syntax",
                "content": "    public class Solution {\\n\\n\\tprivate int num = 0;\\n\\tprivate int ans = 0;\\t\\n\\tprivate int sign = 1;\\n\\n    public int calculate(String s) {\\n    \\tStack<Integer> signs = new Stack<Integer>();\\n    \\ts = \"(\" + s + \")\";  // Every \"s\" can be viewed as \"+(s)\". Since we use \"sign = 1\" \\n    \\t\\t\\t\\t\\t\\t// to represent the proceeding \"+\", skip it from the string.\\n    \\t\\n\\t\\ts.chars().filter((c) -> (\"0123456789+-()\".contains(String.valueOf((char) (c))))).forEach((c) -> {\\n\\t\\t\\tif (c >= '0' && c <= '9') {\\n\\t\\t\\t\\tnum = 10 * num + c - '0';\\n\\t\\t\\t} else if (c == '+' || c == '-') {\\n\\t\\t\\t\\tans = ans + signs.peek() * sign * num;\\n\\t\\t\\t\\tnum = 0;\\n\\t\\t\\t\\tsign = (c == '+') ? 1 : -1;\\n\\t\\t\\t} else if (c == '(') {\\n\\t\\t\\t\\tif (!signs.isEmpty())\\n\\t\\t\\t\\t\\tsigns.push(sign * signs.peek());\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tsigns.push(sign);\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t} else if (c == ')') {\\n\\t\\t\\t\\tans = ans + signs.pop() * sign * num;\\n\\t\\t\\t\\tnum = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn ans;\\n    }\\t\\n)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\tprivate int num = 0;\\n\\tprivate int ans = 0;\\t\\n\\tprivate int sign = 1;\\n\\n    public int calculate(String s) {\\n    \\tStack<Integer> signs = new Stack<Integer>();\\n    \\ts = \"(\" + s + \")\";  // Every \"s\" can be viewed as \"+(s)\". Since we use \"sign = 1\" \\n    \\t\\t\\t\\t\\t\\t// to represent the proceeding \"+\", skip it from the string.\\n    \\t\\n\\t\\ts.chars().filter((c) -> (\"0123456789+-()\".contains(String.valueOf((char) (c))))).forEach((c) -> {\\n\\t\\t\\tif (c >= '0' && c <= '9') {\\n\\t\\t\\t\\tnum = 10 * num + c - '0';\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 62481,
                "title": "c-o-n-with-two-bool-signs-and-one-stack",
                "content": "Use one bool \"sign\" to get the operator before current number;\\nuse another bool \"presign\" to trace the actual operator of the nearest \"(\" before current number;\\n(actual operator means transfer operator inside \"( )\"  into global by virtually \"removing\" outer parenthesis)\\n\\nIf sign and presign are the same, means \"+\" and \"+\", or \"-\" and \"-\", so add it to result\\nelse reduce it from result.\\n\\nFor multiple layers parenthesis, use a stack as a buffer to recognize corresponding layer.\\n\\n    class Solution {\\n    public:\\n    \\tint calculate(string s)\\n    \\t{\\n        \\tint len = s.length();\\n        \\tint sum = 0;\\n        \\tbool presign = true, sign = true;\\n        \\tstack<int> stk;\\n        \\t\\n        \\tfor(int ii=0; ii<len; ++ii)\\n        \\t{\\n        \\t\\tchar cc = s[ii];\\n        \\t\\t\\n        \\t\\tif(' ' == cc)\\n        \\t\\t\\tcontinue;\\n        \\t\\tif('+' == cc)\\n        \\t\\t\\tsign = true;\\n        \\t\\telse if('-' == cc)\\n        \\t\\t\\tsign = false;\\n        \\t\\telse if('(' == cc)\\n        \\t\\t{\\n        \\t\\t\\tstk.push(presign);\\n        \\t\\t\\tpresign = (true == sign)?presign:(!presign);\\n        \\t\\t\\tsign = true;\\n        \\t\\t}\\n        \\t\\telse if(')' == cc)\\n        \\t\\t{\\n        \\t\\t\\tpresign = stk.top();\\n        \\t\\t\\tstk.pop();\\n        \\t\\t\\tsign = true;\\n        \\t\\t}\\n        \\t\\telse\\n        \\t\\t{\\n        \\t\\t\\tint num = s[ii] - '0';\\n        \\t\\t\\twhile(isdigit(s[++ii]))\\n        \\t\\t\\t\\tnum = 10*num + s[ii] - '0';\\n        \\t\\t\\tii--;\\t\\n    \\n        \\t\\t\\tsum += (sign==presign)? num : (0-num);\\n        \\t\\t}\\n        \\t}\\n    \\t\\treturn sum;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint calculate(string s)\\n    \\t{\\n        \\tint len = s.length();\\n        \\tint sum = 0;\\n        \\tbool presign = true, sign = true;\\n        \\tstack<int> stk;\\n        \\t\\n        \\tfor(int ii=0; ii<len; ++ii)\\n        \\t{\\n        \\t\\tchar cc = s[ii];\\n        \\t\\t\\n        \\t\\tif(' ' == cc)\\n        \\t\\t\\tcontinue;\\n        \\t\\tif('+' == cc)\\n        \\t\\t\\tsign = true;\\n        \\t\\telse if('-' == cc)\\n        \\t\\t\\tsign = false;\\n        \\t\\telse if('(' == cc)\\n        \\t\\t{\\n        \\t\\t\\tstk.push(presign);\\n        \\t\\t\\tpresign = (true == sign)?presign:(!presign);\\n        \\t\\t\\tsign = true;\\n        \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 62515,
                "title": "accepted-java-solution-easy-understood-with-explanations-no-need-to-convert-to-postfix-rnp",
                "content": "Explanations are in lines. \\nNo need to convert to RNP.\\nClear logic, easy to follow.\\n\\n\\n    public class Solution {\\n        public static int calculate(String expression)\\n        {\\n            char[] tokens = expression.toCharArray();\\n     \\n             // Stack for numbers: 'values'\\n            Stack<Integer> values = new Stack<Integer>();\\n     \\n            // Stack for Operators: 'ops'\\n            Stack<Character> ops = new Stack<Character>();\\n     \\n            for (int i = 0; i < tokens.length; i++)\\n            {\\n                 // Current token is a whitespace, skip it\\n                if (tokens[i] == ' ')\\n                    continue;\\n     \\n                // Current token is a number, push it to stack for numbers\\n                if (tokens[i] >= '0' && tokens[i] <= '9')\\n                {\\n                    StringBuffer sbuf = new StringBuffer();\\n                    // There may be more than one digits in number\\n                    while (i < tokens.length && tokens[i] >= '0' && tokens[i] <= '9')\\n                        sbuf.append(tokens[i++]);\\n                    values.push(Integer.parseInt(sbuf.toString()));\\n                    i--;\\n                    \\n                }\\n     \\n                // Current token is an opening brace, push it to 'ops'\\n                else if (tokens[i] == '(')\\n                    ops.push(tokens[i]);\\n     \\n                // Closing brace encountered, solve entire brace\\n                else if (tokens[i] == ')')\\n                {\\n                \\t\\n                    while (ops.peek() != '('){\\n                    \\tvalues.push(applyOp(ops.pop(), values.pop(), values.pop()));\\n                    }\\n                    if(ops.size()!=0){\\n                    \\tops.pop();\\n                    }\\n                    \\n                }\\n     \\n                // Current token is an operator.\\n                else if (tokens[i] == '+' || tokens[i] == '-' ||\\n                         tokens[i] == '*' || tokens[i] == '/')\\n                {\\n                    // While top of 'ops' has same or greater precedence to current\\n                    // token, which is an operator. Apply operator on top of 'ops'\\n                    // to top two elements in values stack\\n                    while (!ops.empty() && hasPrecedence(tokens[i], ops.peek()))\\n                      values.push(applyOp(ops.pop(), values.pop(), values.pop()));\\n     \\n                    // Push current token to 'ops'.\\n                    ops.push(tokens[i]);\\n                }\\n            }\\n     \\n            // Entire expression has been parsed at this point, apply remaining\\n            // ops to remaining values\\n            \\n            while (!ops.empty())\\n            {\\tif(values.size()==1)\\n                return values.pop();\\n                values.push(applyOp(ops.pop(), values.pop(), values.pop()));\\n            }\\n     \\n            // Top of 'values' contains result, return it\\n            return values.pop();\\n        }\\n     \\n        // Returns true if 'op2' has higher or same precedence as 'op1',\\n        // otherwise returns false.\\n        public static boolean hasPrecedence(char op1, char op2)\\n        {\\n            if (op2 == '(' || op2 == ')')\\n                return false;\\n            if ((op1 == '*' || op1 == '/') && (op2 == '+' || op2 == '-'))\\n                return false;\\n            else\\n                return true;\\n        }\\n     \\n        // A utility method to apply an operator 'op' on operands 'a'\\n        // and 'b'. Return the result.\\n        public static int applyOp(char op, int b, int a)\\n        {\\n            switch (op)\\n            {\\n            case '+':\\n                return a + b;\\n            case '-':\\n                return a - b;\\n            case '*':\\n                return a * b;\\n            case '/':\\n                if (b == 0)\\n                    throw new\\n                    UnsupportedOperationException(\"Cannot divide by zero\");\\n                return a / b;\\n            }\\n            return 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public static int calculate(String expression)\\n        {\\n            char[] tokens = expression.toCharArray();\\n     \\n             // Stack for numbers: 'values'\\n            Stack<Integer> values = new Stack<Integer>();\\n     \\n            // Stack for Operators: 'ops'\\n            Stack<Character> ops = new Stack<Character>();\\n     \\n            for (int i = 0; i < tokens.length; i++)\\n            {\\n                 // Current token is a whitespace, skip it\\n                if (tokens[i] == ' ')\\n                    continue;\\n     \\n                // Current token is a number, push it to stack for numbers\\n                if (tokens[i] >= '0' && tokens[i] <= '9')\\n                {\\n                    StringBuffer sbuf = new StringBuffer();\\n                    // There may be more than one digits in number\\n                    while (i < tokens.length && tokens[i] >= '0' && tokens[i] <= '9')\\n                        sbuf.append(tokens[i++]);\\n                    values.push(Integer.parseInt(sbuf.toString()));\\n                    i--;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4026801,
                "title": "unique-recursive-solution",
                "content": "# Intuition\\nUsing the approach for Basic Calculator - 2 and using that recursively whenever we encounter an opening bracket..because starting of opening bracket is like a fresh problem.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return helper(s, i);\\n    }\\n\\n    int helper(string& s, int& i) {\\n        int ans = 0, interim = 0; \\n        long long num = 0;\\n        char op = \\'+\\';\\n        while (i < s.size()) {\\n            if (isdigit(s[i])) \\n            {\\n                num = 0;\\n                while (i < s.size() && isdigit(s[i])) {\\n                    num = num * 10 + s[i] - \\'0\\';\\n                    i++;\\n                }\\n                \\n                if (op == \\'+\\' || op == \\'-\\') \\n                {\\n                    ans += interim;\\n                    if(op == \\'-\\') interim= -1*num;\\n                    else interim = num;\\n                } \\n                else if (op == \\'*\\') \\n                {\\n                    interim *= num;\\n                } \\n                else if (op == \\'/\\') \\n                {\\n                    interim /= num;\\n                }\\n            } \\n            else if (s[i] == \\'(\\') \\n            {\\n                i++; // skip the \\'(\\'\\n                num = helper(s, i);\\n                \\n                if (op == \\'+\\' || op == \\'-\\') \\n                {\\n                    ans += interim;\\n                    if(op == \\'-\\') interim= -1*num;\\n                    else interim = num;\\n                } \\n                else if (op == \\'*\\') \\n                {\\n                    interim *= num;\\n                } \\n                else if (op == \\'/\\') \\n                {\\n                    interim /= num;\\n                }\\n            } \\n            else if (s[i] == \\')\\') \\n            {\\n                i++; // skip the \\')\\'\\n                break; // exit the current level of recursion\\n            } \\n            else \\n            {\\n                if (s[i] != \\' \\') op = s[i];\\n                i++;\\n            }\\n        }\\n        ans += interim;\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Dynamic Programming",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return helper(s, i);\\n    }\\n\\n    int helper(string& s, int& i) {\\n        int ans = 0, interim = 0; \\n        long long num = 0;\\n        char op = \\'+\\';\\n        while (i < s.size()) {\\n            if (isdigit(s[i])) \\n            {\\n                num = 0;\\n                while (i < s.size() && isdigit(s[i])) {\\n                    num = num * 10 + s[i] - \\'0\\';\\n                    i++;\\n                }\\n                \\n                if (op == \\'+\\' || op == \\'-\\') \\n                {\\n                    ans += interim;\\n                    if(op == \\'-\\') interim= -1*num;\\n                    else interim = num;\\n                } \\n                else if (op == \\'*\\') \\n                {\\n                    interim *= num;\\n                } \\n                else if (op == \\'/\\') \\n                {\\n                    interim /= num;\\n                }\\n            } \\n            else if (s[i] == \\'(\\') \\n            {\\n                i++; // skip the \\'(\\'\\n                num = helper(s, i);\\n                \\n                if (op == \\'+\\' || op == \\'-\\') \\n                {\\n                    ans += interim;\\n                    if(op == \\'-\\') interim= -1*num;\\n                    else interim = num;\\n                } \\n                else if (op == \\'*\\') \\n                {\\n                    interim *= num;\\n                } \\n                else if (op == \\'/\\') \\n                {\\n                    interim /= num;\\n                }\\n            } \\n            else if (s[i] == \\')\\') \\n            {\\n                i++; // skip the \\')\\'\\n                break; // exit the current level of recursion\\n            } \\n            else \\n            {\\n                if (s[i] != \\' \\') op = s[i];\\n                i++;\\n            }\\n        }\\n        ans += interim;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708272,
                "title": "simple-explanation-for-a-very-complicated-problem",
                "content": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        # sign == 1 means +\\n        # sign == -1 means -\\n        # By default the sign is + i.e. 1\\n        \\n        current, output, sign, stack = 0, 0, 1, []\\n        \\n        for c in s:\\n            #Here we are trying to find the current number\\n            #since current number can be of multiple digits hence we need to do \\n            #these calculations. \\n            if c.isdigit(): \\n                current = current * 10 + int(c)\\n                \\n            #when we see a sign, we will update our current number to + or -.\\n            #To do so, we will use the sign we saw last time, remmeber the sign\\n            #is + by default. So, if we did not see any sign last time, then \\n            #the number is made positive. \\n            #we set output to current and current to zero, bc from now on we want\\n            #to find new current(second value for our calculation)\\n            #We also update the sign variable to -1 or +1, because we will use this\\n            #to assign sign to the next value we will find. \\n            elif c in \\'+-\\':\\n                output += current*sign\\n                current = 0 \\n                if c == \\'-\\':\\n                    sign = -1\\n                else:\\n                    sign = 1\\n                    \\n            #If we see \\'(\\', we will append output and sign to the stack. \\n            #We need to do this because if we see \\'(\\' we will 100% see \\')\\'\\n            #And when we see \\')\\' we will use the stack to get the value and sign for\\n            #the calculation. \\n            #we will also reset output and sign, because inside \\'(\\', we will have\\n            #to do new calculations and we can use stack to do this unifinished \\n            #calculation.\\n            elif c == \\'(\\':\\n                stack.append(output)\\n                stack.append(sign)\\n                output = 0\\n                sign = 1\\n                \\n            \\n            #We we see \\')\\', that means first we need to finished the inner \\n            #calculation ie between (). If you notice when we get \\')\\', we have not\\n            #finished the calculation because we come directly to this branch. \\n            #in order to finish last calculation of (), we have to write two\\n            #statements here. Once last calculation is complete, we not put a sign\\n            #to the output, this is because whatever was the sign before \\'(\\'\\n            #that should be the sign of the whole expression(output).\\n            #eg 1 - (3+2) means 1 - (5) and sign of 5 should be \\'-\\'\\n            #so we put sign to output and add it to the stack top. \\n            #This may be addition or subtraction depending on the sign. \\n            elif c == \\')\\':\\n                output += current * sign \\n                current = 0\\n                \\n                output = output * stack.pop() #This is also a sign ie -1 or 1\\n                output += stack.pop() #this is the last result\\n                \\n        \\n        #If there are no left or right parans in the equation, in that case\\n        #We will have to add current * sign(making current negative if thats the\\n\\t\\t#case) to the output and return that. \\n        return output + (current * sign)\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        # sign == 1 means +\\n        # sign == -1 means -\\n        # By default the sign is + i.e. 1\\n        \\n        current, output, sign, stack = 0, 0, 1, []\\n        \\n        for c in s:\\n            #Here we are trying to find the current number\\n            #since current number can be of multiple digits hence we need to do \\n            #these calculations. \\n            if c.isdigit(): \\n                current = current * 10 + int(c)\\n                \\n            #when we see a sign, we will update our current number to + or -.\\n            #To do so, we will use the sign we saw last time, remmeber the sign\\n            #is + by default. So, if we did not see any sign last time, then \\n            #the number is made positive. \\n            #we set output to current and current to zero, bc from now on we want\\n            #to find new current(second value for our calculation)\\n            #We also update the sign variable to -1 or +1, because we will use this\\n            #to assign sign to the next value we will find. \\n            elif c in \\'+-\\':\\n                output += current*sign\\n                current = 0 \\n                if c == \\'-\\':\\n                    sign = -1\\n                else:\\n                    sign = 1\\n                    \\n            #If we see \\'(\\', we will append output and sign to the stack. \\n            #We need to do this because if we see \\'(\\' we will 100% see \\')\\'\\n            #And when we see \\')\\' we will use the stack to get the value and sign for\\n            #the calculation. \\n            #we will also reset output and sign, because inside \\'(\\', we will have\\n            #to do new calculations and we can use stack to do this unifinished \\n            #calculation.\\n            elif c == \\'(\\':\\n                stack.append(output)\\n                stack.append(sign)\\n                output = 0\\n                sign = 1\\n                \\n            \\n            #We we see \\')\\', that means first we need to finished the inner \\n            #calculation ie between (). If you notice when we get \\')\\', we have not\\n            #finished the calculation because we come directly to this branch. \\n            #in order to finish last calculation of (), we have to write two\\n            #statements here. Once last calculation is complete, we not put a sign\\n            #to the output, this is because whatever was the sign before \\'(\\'\\n            #that should be the sign of the whole expression(output).\\n            #eg 1 - (3+2) means 1 - (5) and sign of 5 should be \\'-\\'\\n            #so we put sign to output and add it to the stack top. \\n            #This may be addition or subtraction depending on the sign. \\n            elif c == \\')\\':\\n                output += current * sign \\n                current = 0\\n                \\n                output = output * stack.pop() #This is also a sign ie -1 or 1\\n                output += stack.pop() #this is the last result\\n                \\n        \\n        #If there are no left or right parans in the equation, in that case\\n        #We will have to add current * sign(making current negative if thats the\\n\\t\\t#case) to the output and return that. \\n        return output + (current * sign)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687154,
                "title": "binbin-solved-another-hard-question-very-happy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        res = 0\\n        pre_op = \"+\"\\n        s += \"+\"\\n        num = 0\\n        stack = []\\n        for i in s:\\n            #print(i)\\n            #print(num,res,pre_op,stack)\\n            if i.isdigit():\\n                num = num*10 + int(i)\\n            elif i == \" \":\\n                continue\\n            elif i in [\"+\",\"-\"]:\\n                if pre_op == \"+\":\\n                    res += num\\n                else:\\n                    res -= num\\n                pre_op = i\\n                num = 0\\n            elif i == \"(\":\\n                stack.append(res)\\n                stack.append(pre_op)\\n                res = 0\\n                num = 0\\n                pre_op = \"+\"\\n            elif i == \")\":\\n                if pre_op == \"+\":\\n                    res += num\\n                else:\\n                    res -= num\\n                if stack[-1] == \"+\":\\n                    #res += num\\n                    stack.pop()\\n                    res += stack.pop()\\n                elif stack[-1] == \"-\":\\n                   # res -= num\\n                    stack.pop()\\n                    res = stack.pop() - res\\n                num = 0\\n                pre_op = \"+\"\\n        return res \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        res = 0\\n        pre_op = \"+\"\\n        s += \"+\"\\n        num = 0\\n        stack = []\\n        for i in s:\\n            #print(i)\\n            #print(num,res,pre_op,stack)\\n            if i.isdigit():\\n                num = num*10 + int(i)\\n            elif i == \" \":\\n                continue\\n            elif i in [\"+\",\"-\"]:\\n                if pre_op == \"+\":\\n                    res += num\\n                else:\\n                    res -= num\\n                pre_op = i\\n                num = 0\\n            elif i == \"(\":\\n                stack.append(res)\\n                stack.append(pre_op)\\n                res = 0\\n                num = 0\\n                pre_op = \"+\"\\n            elif i == \")\":\\n                if pre_op == \"+\":\\n                    res += num\\n                else:\\n                    res -= num\\n                if stack[-1] == \"+\":\\n                    #res += num\\n                    stack.pop()\\n                    res += stack.pop()\\n                elif stack[-1] == \"-\":\\n                   # res -= num\\n                    stack.pop()\\n                    res = stack.pop() - res\\n                num = 0\\n                pre_op = \"+\"\\n        return res \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683723,
                "title": "c-solution-easy",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int> st;\\n        int sum =0;\\n        int sign =1;\\n        int n = s.size(); \\n\\n        for(int i=0; i<n; i++){\\n            //check if number\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                int num =0;\\n                while(i<n && s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                    num = num*10 + (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                sum = sum + sign* num;\\n                i--;\\n            }\\n    \\n            //check if sign \\'-\\' or \\'+\\'\\n\\n            else if(s[i] == \\'+\\'){\\n                sign = 1;\\n            }\\n            else if(s[i] == \\'-\\'){\\n                sign = -1;\\n            }\\n            //check if \\'(\\' or \\')\\'\\n            else if(s[i] == \\'(\\'){\\n                st.push(sum);\\n                st.push(sign);\\n                sum =0;\\n                sign =1;\\n            }\\n            else if(s[i] == \\')\\'){\\n                sum = sum* st.top();\\n                st.pop();\\n                sum = sum +  st.top();\\n                st.pop();\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int> st;\\n        int sum =0;\\n        int sign =1;\\n        int n = s.size(); \\n\\n        for(int i=0; i<n; i++){\\n            //check if number\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                int num =0;\\n                while(i<n && s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                    num = num*10 + (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                sum = sum + sign* num;\\n                i--;\\n            }\\n    \\n            //check if sign \\'-\\' or \\'+\\'\\n\\n            else if(s[i] == \\'+\\'){\\n                sign = 1;\\n            }\\n            else if(s[i] == \\'-\\'){\\n                sign = -1;\\n            }\\n            //check if \\'(\\' or \\')\\'\\n            else if(s[i] == \\'(\\'){\\n                st.push(sum);\\n                st.push(sign);\\n                sum =0;\\n                sign =1;\\n            }\\n            else if(s[i] == \\')\\'){\\n                sum = sum* st.top();\\n                st.pop();\\n                sum = sum +  st.top();\\n                st.pop();\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613339,
                "title": "very-simple-c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i=0;\\n        int n=s.size();\\n        int ans=0;\\n        stack<int>st;\\n        int sign=1;\\n        while(i<n) {\\n            char c=s[i];\\n            if(isdigit(c)) {\\n                int num=0;\\n                while(i<n && isdigit(s[i])) {\\n                    num=num*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                ans+=sign*num;\\n            } \\n            else if(c==\\'+\\') {\\n                sign=1;\\n                i++;\\n            } \\n            else if(c==\\'-\\') {\\n                sign=-1;\\n                i++;\\n            } \\n            else if(c==\\'(\\') {\\n                st.push(ans);\\n                st.push(sign);\\n                ans=0;\\n                sign=1;\\n                i++;\\n            } \\n            else if(c==\\')\\') {\\n                int prevSign=st.top();\\n                st.pop();\\n                int prevAns=st.top();\\n                st.pop();\\n                ans=prevAns+(prevSign * ans);\\n                i++;\\n            } \\n            else{\\n                i++;  \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i=0;\\n        int n=s.size();\\n        int ans=0;\\n        stack<int>st;\\n        int sign=1;\\n        while(i<n) {\\n            char c=s[i];\\n            if(isdigit(c)) {\\n                int num=0;\\n                while(i<n && isdigit(s[i])) {\\n                    num=num*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                ans+=sign*num;\\n            } \\n            else if(c==\\'+\\') {\\n                sign=1;\\n                i++;\\n            } \\n            else if(c==\\'-\\') {\\n                sign=-1;\\n                i++;\\n            } \\n            else if(c==\\'(\\') {\\n                st.push(ans);\\n                st.push(sign);\\n                ans=0;\\n                sign=1;\\n                i++;\\n            } \\n            else if(c==\\')\\') {\\n                int prevSign=st.top();\\n                st.pop();\\n                int prevAns=st.top();\\n                st.pop();\\n                ans=prevAns+(prevSign * ans);\\n                i++;\\n            } \\n            else{\\n                i++;  \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920297,
                "title": "beats-99-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        cur,ans = 0,0\\n        sign = 1\\n        for c in s:\\n            if c.isdigit():\\n                cur = cur*10 + int(c)\\n            elif c in \\'+-\\':\\n                ans += sign*cur\\n                sign = -1 if c == \\'-\\' else 1\\n                cur = 0\\n            elif c == \\'(\\':\\n                stack.append(ans)\\n                stack.append(sign)\\n                ans = 0\\n                sign = 1\\n            elif c == \\')\\':\\n                ans += sign*cur\\n                ans *= stack.pop()\\n                ans += stack.pop()\\n                cur = 0\\n        return ans + sign*cur\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        cur,ans = 0,0\\n        sign = 1\\n        for c in s:\\n            if c.isdigit():\\n                cur = cur*10 + int(c)\\n            elif c in \\'+-\\':\\n                ans += sign*cur\\n                sign = -1 if c == \\'-\\' else 1\\n                cur = 0\\n            elif c == \\'(\\':\\n                stack.append(ans)\\n                stack.append(sign)\\n                ans = 0\\n                sign = 1\\n            elif c == \\')\\':\\n                ans += sign*cur\\n                ans *= stack.pop()\\n                ans += stack.pop()\\n                cur = 0\\n        return ans + sign*cur\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880532,
                "title": "simple-approach-c-easy-to-understand",
                "content": "# Intuition\\nuse stack and iterating from end \\n\\n# Approach\\napproch is simply to iterate from end of string and in first iteration we just evaluates all brackets in expression and in second expression we can simply evaluate all values and get final answer\\n\\n# Complexity\\n- Time complexity:\\ntime complexity to this solution is O(3n) which finally evaluates to  o(n)\\n\\n- Space complexity:\\nspace complexity to this solution is o(n) for stroing whole string in stack \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<char> st;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]!=\\' \\'){\\n                if(st.empty()){\\n                    st.push(s[i]);\\n                }else{\\n                    if(s[i]==\\'(\\'){\\n\\n                        int bracket_evaluation=0;\\n                        \\n                        \\n                        while(st.top()!=\\')\\'){\\n                            int symbol=1;\\n                            int d=0;\\n                            if(st.top()==\\'-\\'){\\n\\n                                //removing symbol\\n                                st.pop();\\n                                symbol=-1;\\n\\n                            }else{\\n\\n                                if(st.top()==\\'+\\'){\\n                                    //removing symbol\\n                                    st.pop();\\n                                }\\n\\n                            }\\n                            if(!st.empty() && st.top()==\\'-\\'){\\n                                st.pop();\\n                                symbol*=-1;\\n                            }\\n\\n                            //making the integer if it is greater than 9\\n                            while(st.top()-\\'0\\'<=9 && st.top()-\\'0\\'>=0){\\n                                d=(d*10)+(st.top()-\\'0\\');\\n                                st.pop();\\n                            }\\n                            d*=symbol;\\n                            //aading value to total bracket evaluation\\n                            bracket_evaluation+=d;\\n                        }\\n                        \\n                        //removing the opening bracket from stack\\n                        st.pop();\\n                        bool negative=false;\\n                        if(bracket_evaluation<0){\\n                            bracket_evaluation*=-1;\\n                            negative=true;\\n                        }\\n                        //push final evaluation in stack in correct order\\n                        string m=to_string(bracket_evaluation);\\n                        cout<<m<<endl;\\n                        for(int k=m.size()-1;k>=0;k--){\\n                            st.push(m[k]);\\n                        }\\n                        if(negative){\\n                            st.push(\\'-\\');\\n                        }\\n                    }else{\\n                        st.push(s[i]);\\n                    }\\n                }\\n            }\\n        }\\n        long long final_evaluation=0;\\n        while(!st.empty()){\\n            //making the integer if it is greater than 9\\n            long long d=0;\\n            int symbol=1;\\n            //checking its symbol and then addition to result\\n            if(!st.empty() && st.top()==\\'-\\'){\\n                st.pop();\\n                symbol=-1;\\n            }else{\\n                if(!st.empty() && st.top()==\\'+\\'){\\n                    st.pop();\\n                }\\n            }\\n            if(!st.empty() && st.top()==\\'-\\'){\\n                st.pop();\\n                symbol*=-1;\\n            }\\n            while(!st.empty() && st.top()-\\'0\\'<=9 && st.top()-\\'0\\'>=0){\\n                d=(d*10)+st.top()-\\'0\\';\\n                st.pop();\\n            }\\n            d*=symbol;\\n            final_evaluation+=d;\\n        }\\n        \\n        return final_evaluation;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<char> st;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]!=\\' \\'){\\n                if(st.empty()){\\n                    st.push(s[i]);\\n                }else{\\n                    if(s[i]==\\'(\\'){\\n\\n                        int bracket_evaluation=0;\\n                        \\n                        \\n                        while(st.top()!=\\')\\'){\\n                            int symbol=1;\\n                            int d=0;\\n                            if(st.top()==\\'-\\'){\\n\\n                                //removing symbol\\n                                st.pop();\\n                                symbol=-1;\\n\\n                            }else{\\n\\n                                if(st.top()==\\'+\\'){\\n                                    //removing symbol\\n                                    st.pop();\\n                                }\\n\\n                            }\\n                            if(!st.empty() && st.top()==\\'-\\'){\\n                                st.pop();\\n                                symbol*=-1;\\n                            }\\n\\n                            //making the integer if it is greater than 9\\n                            while(st.top()-\\'0\\'<=9 && st.top()-\\'0\\'>=0){\\n                                d=(d*10)+(st.top()-\\'0\\');\\n                                st.pop();\\n                            }\\n                            d*=symbol;\\n                            //aading value to total bracket evaluation\\n                            bracket_evaluation+=d;\\n                        }\\n                        \\n                        //removing the opening bracket from stack\\n                        st.pop();\\n                        bool negative=false;\\n                        if(bracket_evaluation<0){\\n                            bracket_evaluation*=-1;\\n                            negative=true;\\n                        }\\n                        //push final evaluation in stack in correct order\\n                        string m=to_string(bracket_evaluation);\\n                        cout<<m<<endl;\\n                        for(int k=m.size()-1;k>=0;k--){\\n                            st.push(m[k]);\\n                        }\\n                        if(negative){\\n                            st.push(\\'-\\');\\n                        }\\n                    }else{\\n                        st.push(s[i]);\\n                    }\\n                }\\n            }\\n        }\\n        long long final_evaluation=0;\\n        while(!st.empty()){\\n            //making the integer if it is greater than 9\\n            long long d=0;\\n            int symbol=1;\\n            //checking its symbol and then addition to result\\n            if(!st.empty() && st.top()==\\'-\\'){\\n                st.pop();\\n                symbol=-1;\\n            }else{\\n                if(!st.empty() && st.top()==\\'+\\'){\\n                    st.pop();\\n                }\\n            }\\n            if(!st.empty() && st.top()==\\'-\\'){\\n                st.pop();\\n                symbol*=-1;\\n            }\\n            while(!st.empty() && st.top()-\\'0\\'<=9 && st.top()-\\'0\\'>=0){\\n                d=(d*10)+st.top()-\\'0\\';\\n                st.pop();\\n            }\\n            d*=symbol;\\n            final_evaluation+=d;\\n        }\\n        \\n        return final_evaluation;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2834479,
                "title": "python3-o-n-stack-solution",
                "content": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        val_stack = []\\n        cur_num = 0\\n        total = 0\\n        sign = 1\\n        for c in s:\\n            if c.isdigit():\\n                cur_num*=10\\n                cur_num+=int(c)\\n            elif c==\\'+\\':\\n                total+=cur_num*sign\\n                cur_num = 0\\n                sign = 1\\n            elif c==\\'-\\':\\n                total+=cur_num*sign\\n                cur_num = 0\\n                sign = -1\\n            elif c==\\'(\\':\\n                val_stack.append(total)\\n                val_stack.append(sign)\\n                sign = 1\\n                total = 0\\n            elif c==\\')\\':\\n                total += sign * cur_num\\n                cur_num = 0\\n                total *= val_stack.pop()\\n                total += val_stack.pop()\\n        if cur_num: total += sign * cur_num\\n        return total\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        val_stack = []\\n        cur_num = 0\\n        total = 0\\n        sign = 1\\n        for c in s:\\n            if c.isdigit():\\n                cur_num*=10\\n                cur_num+=int(c)\\n            elif c==\\'+\\':\\n                total+=cur_num*sign\\n                cur_num = 0\\n                sign = 1\\n            elif c==\\'-\\':\\n                total+=cur_num*sign\\n                cur_num = 0\\n                sign = -1\\n            elif c==\\'(\\':\\n                val_stack.append(total)\\n                val_stack.append(sign)\\n                sign = 1\\n                total = 0\\n            elif c==\\')\\':\\n                total += sign * cur_num\\n                cur_num = 0\\n                total *= val_stack.pop()\\n                total += val_stack.pop()\\n        if cur_num: total += sign * cur_num\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834082,
                "title": "c-easy-explanation-stack-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int calculate(string s) {\\n        \\n        int number = 0;\\n        int result = 0;\\n        int sigh = 1;\\n        \\n        stack<int>st;\\n        \\n        for(int i = 0;i<s.size();i++){\\n\\n          if(isdigit(s[i])){  //if s[i] is digite\\n\\n          number = 10*number+(s[i]-\\'0\\'); //find out the current number\\n              \\n          \\n          }\\n           \\n           else if(s[i] == \\'+\\'){\\n \\n               result += number*sigh;\\n               \\n               number = 0;\\n               sigh = 1;\\n               \\n           \\n           \\n           }\\n            else if(s[i] == \\'-\\'){\\n \\n               result += number*sigh;\\n               \\n               number = 0;\\n               sigh = -1;\\n               \\n           \\n           \\n           }\\n            else if(s[i] == \\'(\\'){\\n \\n                st.push(result);\\n                st.push(sigh);\\n                number = 0;\\n                result = 0;\\n                sigh = 1;\\n                \\n\\n            \\n            }\\n            else if(s[i] == \\')\\'){\\n \\n                result += number*sigh;\\n                number = 0;\\n                int top = st.top();\\n                st.pop();\\n                result *= top;\\n                \\n                top = st.top();\\n                st.pop();\\n                \\n                result +=top;\\n                \\n                \\n             \\n            \\n            }\\n            \\n            \\n        \\n        }\\n        \\n        result += number*sigh;\\n        \\n        return result;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int calculate(string s) {\\n        \\n        int number = 0;\\n        int result = 0;\\n        int sigh = 1;\\n        \\n        stack<int>st;\\n        \\n        for(int i = 0;i<s.size();i++){\\n\\n          if(isdigit(s[i])){  //if s[i] is digite\\n\\n          number = 10*number+(s[i]-\\'0\\'); //find out the current number\\n              \\n          \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2834072,
                "title": "java-stack-not-that-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        int n = s.length();\\n        int sign = 1, sum = 0;\\n\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = s.charAt(i);\\n\\n            if (Character.isDigit(c)) {\\n                int currNo = c - \\'0\\';\\n                while (i + 1 < n && Character.isDigit(s.charAt(i + 1))) {\\n                    currNo = currNo * 10 + s.charAt(i + 1) - \\'0\\';\\n                    i++;\\n                }\\n\\t\\t\\t\\t\\n                currNo *= sign;\\n                sum += currNo;\\n                sign = 1;\\n            }\\n\\t\\t\\t\\n            else if (c == \\'+\\') sign = 1;\\n            else if (c == \\'-\\') sign = -1;\\n            else if (c == \\'(\\') {\\n                stack.push(sum);\\n                stack.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n\\t\\t\\t\\n            else if (c == \\')\\') {\\n                sum *= stack.pop();     // stack.pop() = previous sign\\n                sum += stack.pop();     // stack.pop() = previous sum so far\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int n = s.length();\\n        int sign = 1, sum = 0;\\n\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = s.charAt(i);\\n\\n            if (Character.isDigit(c)) {\\n                int currNo = c - \\'0\\';\\n                while (i + 1 < n && Character.isDigit(s.charAt(i + 1))) {\\n                    currNo = currNo * 10 + s.charAt(i + 1) - \\'0\\';\\n                    i++;\\n                }\\n\\t\\t\\t\\t\\n                currNo *= sign;\\n                sum += currNo;\\n                sign = 1;\\n            }\\n\\t\\t\\t\\n            else if (c == \\'+\\') sign = 1;\\n            else if (c == \\'-\\') sign = -1;\\n            else if (c == \\'(\\') {\\n                stack.push(sum);\\n                stack.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n\\t\\t\\t\\n            else if (c == \\')\\') {\\n                sum *= stack.pop();     // stack.pop() = previous sign\\n                sum += stack.pop();     // stack.pop() = previous sum so far\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833805,
                "title": "easy-c-solution-stack-o-n",
                "content": "class Solution {\\npublic:\\n\\n    int calculate(string s) {\\n        \\n        int i,n=s.size(),sum=0,sign=1;\\n        stack<int> st;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n            {\\n                int num=0;\\n                while(n>i && s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n                {\\n                    num =num*10 +(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                sum+=num*sign;\\n                i--;\\n            }\\n            else if(s[i]==\\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if(s[i]==\\'-\\')\\n            {\\n                sign=-1;\\n            }\\n            else if(s[i]==\\'(\\')\\n            {\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                sum=st.top()*sum;\\n                st.pop();\\n                sum+=st.top();\\n                st.pop();\\n            }\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int calculate(string s) {\\n        \\n        int i,n=s.size(),sum=0,sign=1;\\n        stack<int> st;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n            {\\n                int num=0;\\n                while(n>i && s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n                {\\n                    num =num*10 +(s[i]-\\'0\\');\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2833547,
                "title": "python-stack",
                "content": "Keep a stack of numbers and symbols like \"()+-\".\\nSince the only operations are addition and subtraction, one can just compute the expression from left to right, that is, as soon as you find each term. Withtout parentheses, that means that we\\'re going to be considering just one operation at a time, reducing everything to the left of the current operator:\\n1. If you see a number and the stack is empty, push it (it\\'s the first term in a series of operations).\\n2. If you see an operator, push it (this is to keep track of the current operation)\\n3. If you see a number and the top of the stack is an operator (which is always the case without parentheses since the strings are valid), then the top of the stack (stack[-1]) is going to determine the operation, and the second-to-top of the stack (stack[-2]) is going to be the first operand. Just perform the operation on the left operand and the current number and push it to the stack.\\n4. If the stack is empty and you see a \\'-\\' operand, append 0 and then \\'-\\' to the stack. (ie you get the negative number with a convenient expression)\\n\\nWith parentheses it\\'s not much different. Just keep track of the current level of depth. Actyally, the only things that change are:\\n* In points 1. and 4. of the previous list, the \"stack is empty\" condition now changes to \"stack is empty or top of the stack is \\'(\\'.\\n* When you see \\')\\', the stack must be something like [ ..., \\'(\\', number, \\')\\'  ], and you just have to replace it by [ ..., number]\\n\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        currNum = None\\n        stack = []\\n        \\n        result = None\\n        \\n        ops = { \\'+\\': lambda x, y: x + y, \\'-\\': lambda x, y: x - y }\\n        \\n        i = 0\\n        while i < len(s):\\n            # print(stack)\\n            if s[i] in \"+\":\\n                stack.append(s[i])\\n            elif s[i] == \\'-\\':\\n                if not stack or stack[-1] == \\'(\\':\\n                    stack.append(0)\\n                stack.append(s[i])\\n            elif s[i] == \\'(\\':\\n                stack.append(\\'(\\')\\n            elif s[i] == \\' \\':\\n                None\\n            else:\\n                if s[i].isdigit():\\n                    currNum = int(s[i])\\n                    i+=1\\n                    while i < len(s) and s[i].isdigit():\\n                        currNum *= 10\\n                        currNum += int(s[i])\\n                        i+=1\\n                    i -= 1\\n                elif s[i] == \\')\\':\\n                    currNum = stack.pop()\\n                    stack.pop()\\n                if stack and stack[-1] in \\'+-\\':\\n                    stack.append(ops[stack.pop()](stack.pop(), currNum))\\n                else:\\n                    stack.append(currNum)\\n            i+=1\\n        return stack.pop()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        currNum = None\\n        stack = []\\n        \\n        result = None\\n        \\n        ops = { \\'+\\': lambda x, y: x + y, \\'-\\': lambda x, y: x - y }\\n        \\n        i = 0\\n        while i < len(s):\\n            # print(stack)\\n            if s[i] in \"+\":\\n                stack.append(s[i])\\n            elif s[i] == \\'-\\':\\n                if not stack or stack[-1] == \\'(\\':\\n                    stack.append(0)\\n                stack.append(s[i])\\n            elif s[i] == \\'(\\':\\n                stack.append(\\'(\\')\\n            elif s[i] == \\' \\':\\n                None\\n            else:\\n                if s[i].isdigit():\\n                    currNum = int(s[i])\\n                    i+=1\\n                    while i < len(s) and s[i].isdigit():\\n                        currNum *= 10\\n                        currNum += int(s[i])\\n                        i+=1\\n                    i -= 1\\n                elif s[i] == \\')\\':\\n                    currNum = stack.pop()\\n                    stack.pop()\\n                if stack and stack[-1] in \\'+-\\':\\n                    stack.append(ops[stack.pop()](stack.pop(), currNum))\\n                else:\\n                    stack.append(currNum)\\n            i+=1\\n        return stack.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832981,
                "title": "java-easy-to-understand-solution-with-comments",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        Stack<Integer>st = new Stack<>();  //to handle parenthesis\\n        int n=s.length();\\n        int sum = 0;\\n        int sign = 1;         // if we have to do addition of negative number\\n        for(int i = 0;i<n;i++){\\n            char ch = s.charAt(i);\\n            if(Character.isDigit(ch)){\\n                int val = 0;\\n                 while(i<n && Character.isDigit(s.charAt(i))){  //if digit length>1\\n                     val = val * 10 + (s.charAt(i)-\\'0\\');\\n                     i++;\\n                 }\\n             i--;       //to move i pointer to previous position\\n                        //or you can use new pointer then we dont have to do it\\n             val = val * sign;\\n             sign = 1;\\n             sum += val;   \\n            }\\n            else if(ch == \\'(\\'){   //parenthesis handle\\n              st.push(sum);\\n              st.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(ch == \\')\\'){\\n                sum *= st.pop();\\n                sum += st.pop();\\n            }\\n            else if(ch==\\'-\\'){\\n                sign*=-1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        Stack<Integer>st = new Stack<>();  //to handle parenthesis\\n        int n=s.length();\\n        int sum = 0;\\n        int sign = 1;         // if we have to do addition of negative number\\n        for(int i = 0;i<n;i++){\\n            char ch = s.charAt(i);\\n            if(Character.isDigit(ch)){\\n                int val = 0;\\n                 while(i<n && Character.isDigit(s.charAt(i))){  //if digit length>1\\n                     val = val * 10 + (s.charAt(i)-\\'0\\');\\n                     i++;\\n                 }\\n             i--;       //to move i pointer to previous position\\n                        //or you can use new pointer then we dont have to do it\\n             val = val * sign;\\n             sign = 1;\\n             sum += val;   \\n            }\\n            else if(ch == \\'(\\'){   //parenthesis handle\\n              st.push(sum);\\n              st.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(ch == \\')\\'){\\n                sum *= st.pop();\\n                sum += st.pop();\\n            }\\n            else if(ch==\\'-\\'){\\n                sign*=-1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832157,
                "title": "c-easy-solution-beginner-friendly-stack",
                "content": "\\t/* required : i/p : arthmatic expresiontion conting only + or - or ( ) \\n\\t\\to/p : answer to expresiont \\n\\n\\t\\te.g : 1 + 2 - 3 + 4 = 5 ( how we doing 1 add because + sign and 3 subtract before is negative sign )\\n\\n\\t\\tproble is complex expresion : \\n\\t\\t( 1 + 2 - ( 4 - 5))    :for 1 and 2 logic works but inner braket what to do ? \\n\\n\\t\\t2 ways : move - inseide the breaket for compute braket answer and add with anser \\n\\t\\tor subtract according to sing before braket . \\n\\n\\t\\tproble : how to solve breaket \\n\\t\\tstack madhey previdous ans maintina and inner braket solve . karen \\n\\n\\n\\t */\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint calculate(string s) {\\n\\n\\t\\t\\tlong long  int sum =  0; \\n\\t\\t\\tint sign = 1 ;\\n\\t\\t\\tstack<pair<long long,int>> st;\\n\\t\\t\\tfor( int i = 0 ; i < s.size() ; ++i )\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar ch = s[i];\\n\\n\\t\\t\\t\\tif( isdigit(ch))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// read entire digit compplete \\n\\t\\t\\t\\t\\tlong long num = 0 ;\\n\\t\\t\\t\\t\\twhile( i < s.size() && isdigit(s[i]))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnum = num*10 + s[i]-\\'0\\';\\n\\t\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tsum += (num * sign);\\n\\t\\t\\t\\t\\t--i; // 1 extra read apter digit \\n\\t\\t\\t\\t\\tsign = 1; // reset sign \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if( ch == \\'(\\') // store priviously computed ans and sing   \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.push({sum,sign});\\n\\t\\t\\t\\t\\tsum = 0 ;\\n\\t\\t\\t\\t\\tsign = 1;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if( ch == \\')\\') // adding or subtracing  computed sum to ans and removing priviously stored ans .  \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum =st.top().first + (sum * st.top().second); // contrubuting inner braket in total\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if ( ch ==\\'-\\') // toggle the sing \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsign = -1 * sign;   \\n\\t\\t\\t\\t}\\n\\n\\n\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint calculate(string s) {\\n\\n\\t\\t\\tlong long  int sum =  0; \\n\\t\\t\\tint sign = 1 ;\\n\\t\\t\\tstack<pair<long long,int>> st;\\n\\t\\t\\tfor( int i = 0 ; i < s.size() ; ++i )\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar ch = s[i];\\n\\n\\t\\t\\t\\tif( isdigit(ch))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// read entire digit compplete \\n\\t\\t\\t\\t\\tlong long num = 0 ;\\n\\t\\t\\t\\t\\twhile( i < s.size() && isdigit(s[i]))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnum = num*10 + s[i]-\\'0\\';\\n\\t\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2831635,
                "title": "c-stack-nice-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int sign = 1;\\n        int result = 0;\\n        int number = 0;\\n        \\n        int n = s.size();\\n        stack<int> st;\\n        \\n        for(int i = 0; i < n; i++) {\\n            char c = s[i];\\n            if(c >= \\'0\\' && c <= \\'9\\') {\\n                number = number * 10 + (c - \\'0\\');\\n            }\\n            if(c == \\'-\\') {\\n                // number completed.\\n                // update result\\n                result += (sign) * (number);\\n                number = 0;\\n                sign = -1;\\n            }\\n            if(c == \\'+\\') {\\n                // number completed\\n                // update result\\n                result += (sign) * (number);\\n                number = 0;\\n                sign = 1;\\n            }\\n            if(c == \\'(\\') {\\n                // number completed, result updated already before when we encountered +/- before opening bracket\\n                st.push(result);\\n                st.push(sign); // so that sign remains at the top (signifies sign before opening bracket was encountered)\\n                result = 0; // building result between brackets from scratch\\n                sign = 1;\\n            }\\n            if(c == \\')\\') {\\n                // number is completed\\n                // update result\\n                result += (sign) * (number);\\n                number = 0;\\n                result *= st.top(); // multiplying with sign before opening bracket\\n                st.pop();\\n                result += st.top(); // result constructed before current context.\\n                st.pop();\\n            }\\n        }\\n        \\n        \\n        // last no space character in case is a number itself , we need to use the number also.\\n        result += (sign) * number;\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int sign = 1;\\n        int result = 0;\\n        int number = 0;\\n        \\n        int n = s.size();\\n        stack<int> st;\\n        \\n        for(int i = 0; i < n; i++) {\\n            char c = s[i];\\n            if(c >= \\'0\\' && c <= \\'9\\') {\\n                number = number * 10 + (c - \\'0\\');\\n            }\\n            if(c == \\'-\\') {\\n                // number completed.\\n                // update result\\n                result += (sign) * (number);\\n                number = 0;\\n                sign = -1;\\n            }\\n            if(c == \\'+\\') {\\n                // number completed\\n                // update result\\n                result += (sign) * (number);\\n                number = 0;\\n                sign = 1;\\n            }\\n            if(c == \\'(\\') {\\n                // number completed, result updated already before when we encountered +/- before opening bracket\\n                st.push(result);\\n                st.push(sign); // so that sign remains at the top (signifies sign before opening bracket was encountered)\\n                result = 0; // building result between brackets from scratch\\n                sign = 1;\\n            }\\n            if(c == \\')\\') {\\n                // number is completed\\n                // update result\\n                result += (sign) * (number);\\n                number = 0;\\n                result *= st.top(); // multiplying with sign before opening bracket\\n                st.pop();\\n                result += st.top(); // result constructed before current context.\\n                st.pop();\\n            }\\n        }\\n        \\n        \\n        // last no space character in case is a number itself , we need to use the number also.\\n        result += (sign) * number;\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831586,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "\\nI just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/11/basic-calculator.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nvar calculate = function(s) {\\n    s = \"(\"+s+\")\"\\n    let stack = [];\\n    let temp = [];\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i]===\" \") continue;\\n        if(s[i]===\")\"){     \\n            while(stack[stack.length-1]!==\"(\") temp.push(stack.pop());                   \\n            stack.pop();\\n            stack.push(count(temp));\\n            continue;\\n        }\\n         if(isNum(stack[stack.length-1])&&isNum(s[i])){\\n            stack[stack.length-1]+=s[i];   \\n            continue;             \\n        } \\n        if(s[i]===\"-\"||s[i]===\"+\"){\\n             if(stack.length===0||stack[stack.length-1]===\"(\") stack.push(\"0\");    \\n        }\\n        stack.push(s[i]);\\n    }\\n    return stack[0];\\n};\\n    \\nfunction count(temp) {\\n let res = Number(temp.pop());\\n while(temp.length > 0) {\\n   let sign = temp.pop();\\n        if (sign === \\'+\\') {\\n            res  +=  Number(temp.pop());\\n        } else {\\n            res  -=  Number(temp.pop());\\n        }\\n  }  \\n    return res;\\n}\\nfunction isNum(str) {\\n  return /[0-9]+/.test(str);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar calculate = function(s) {\\n    s = \"(\"+s+\")\"\\n    let stack = [];\\n    let temp = [];\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i]===\" \") continue;\\n        if(s[i]===\")\"){     \\n            while(stack[stack.length-1]!==\"(\") temp.push(stack.pop());                   \\n            stack.pop();\\n            stack.push(count(temp));\\n            continue;\\n        }\\n         if(isNum(stack[stack.length-1])&&isNum(s[i])){\\n            stack[stack.length-1]+=s[i];   \\n            continue;             \\n        } \\n        if(s[i]===\"-\"||s[i]===\"+\"){\\n             if(stack.length===0||stack[stack.length-1]===\"(\") stack.push(\"0\");    \\n        }\\n        stack.push(s[i]);\\n    }\\n    return stack[0];\\n};\\n    \\nfunction count(temp) {\\n let res = Number(temp.pop());\\n while(temp.length > 0) {\\n   let sign = temp.pop();\\n        if (sign === \\'+\\') {\\n            res  +=  Number(temp.pop());\\n        } else {\\n            res  -=  Number(temp.pop());\\n        }\\n  }  \\n    return res;\\n}\\nfunction isNum(str) {\\n  return /[0-9]+/.test(str);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831481,
                "title": "rust-stack-solution-with-comments",
                "content": "thanks [southpenguin](https://leetcode.com/problems/basic-calculator/discuss/62361/Iterative-Java-solution-with-stack) for the idea\\n```\\nimpl Solution {\\n    pub fn calculate(s: String) -> i32 {        \\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut stack = vec![];\\n        \\n        let (mut cur_sign, mut cur_num, mut final_result) = (1, 0, 0);\\n                \\n        for c in s {\\n            match c {\\n                \\' \\' => {},\\n                \\'(\\' => {\\n                    // push the current calculated result for popping after\\n                    // the upcoming parenthesis has been calculated in full\\n                    stack.push(final_result);\\n                    // push the current sign for popping after the\\n                    // upcoming parenthesis has been calculated in full\\n                    stack.push(cur_sign);\\n                    // result and sign can be reset as we are entering\\n                    // a new calculation domain (i.e., in the parenthesis)\\n                    final_result = 0;\\n                    cur_sign = 1;\\n                },\\n                \\')\\' => {\\n                    // add our current stored number to the final solution\\n                    final_result += cur_sign * cur_num;\\n                    // this would be the sign before the opening parenthesis\\n                    final_result *= stack.pop().unwrap();\\n                    // this would be the result prior to the just-solved parenthesis\\n                    final_result += stack.pop().unwrap();\\n                    // reset num and sign for upcoming value\\n                    cur_num = 0;\\n                    cur_sign = 1;\\n                },\\n                \\'+\\' => {\\n                    // we can add our current stored number to the final solution\\n                    // before updating the num + sign values for the next number\\n                    final_result += cur_sign * cur_num;\\n                    cur_num = 0;\\n                    cur_sign = 1;\\n                },\\n                \\'-\\' => {\\n                    // we can subtract our current stored number to the final solution\\n                    // before updating the num + sign values for the next number\\n                    final_result += cur_sign * cur_num;\\n                    cur_num = 0;\\n                    cur_sign = -1;\\n                },\\n                _ => {\\n                    // add a new least-significant digit\\n                    cur_num *= 10;\\n                    cur_num += (c as i32) - 0x30;\\n                }\\n            }\\n        }\\n        \\n        // if we have any stragglers, add to the result\\n        final_result + (cur_sign * cur_num)    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Stack"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn calculate(s: String) -> i32 {        \\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut stack = vec![];\\n        \\n        let (mut cur_sign, mut cur_num, mut final_result) = (1, 0, 0);\\n                \\n        for c in s {\\n            match c {\\n                \\' \\' => {},\\n                \\'(\\' => {\\n                    // push the current calculated result for popping after\\n                    // the upcoming parenthesis has been calculated in full\\n                    stack.push(final_result);\\n                    // push the current sign for popping after the\\n                    // upcoming parenthesis has been calculated in full\\n                    stack.push(cur_sign);\\n                    // result and sign can be reset as we are entering\\n                    // a new calculation domain (i.e., in the parenthesis)\\n                    final_result = 0;\\n                    cur_sign = 1;\\n                },\\n                \\')\\' => {\\n                    // add our current stored number to the final solution\\n                    final_result += cur_sign * cur_num;\\n                    // this would be the sign before the opening parenthesis\\n                    final_result *= stack.pop().unwrap();\\n                    // this would be the result prior to the just-solved parenthesis\\n                    final_result += stack.pop().unwrap();\\n                    // reset num and sign for upcoming value\\n                    cur_num = 0;\\n                    cur_sign = 1;\\n                },\\n                \\'+\\' => {\\n                    // we can add our current stored number to the final solution\\n                    // before updating the num + sign values for the next number\\n                    final_result += cur_sign * cur_num;\\n                    cur_num = 0;\\n                    cur_sign = 1;\\n                },\\n                \\'-\\' => {\\n                    // we can subtract our current stored number to the final solution\\n                    // before updating the num + sign values for the next number\\n                    final_result += cur_sign * cur_num;\\n                    cur_num = 0;\\n                    cur_sign = -1;\\n                },\\n                _ => {\\n                    // add a new least-significant digit\\n                    cur_num *= 10;\\n                    cur_num += (c as i32) - 0x30;\\n                }\\n            }\\n        }\\n        \\n        // if we have any stragglers, add to the result\\n        final_result + (cur_sign * cur_num)    \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831403,
                "title": "daily-leetcoding-challenge-november-day-20",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/basic-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Stack and String Reversal\n\n  \n**Approach 2:** Stack and No String Reversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/basic-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2703291,
                "title": "easy-best-solution-in-c-stack",
                "content": "# Code\\n**PLease Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int size=s.size(),i=0,ans=0,prevSum=0;\\n        char prevOperation=\\'+\\';\\n        stack<pair<int,char>> sta;\\n        while(i<size){\\n            if(s[i]==\\' \\'){\\n                i++;\\n                continue;\\n            }\\n            int num=0;\\n            while(i<size && isdigit(s[i]))\\n                num = num*10 + (s[i++]-\\'0\\');\\n            if(prevOperation==\\'+\\')\\n                prevSum += num;\\n            else if(prevOperation==\\'-\\')\\n                prevSum += -1*num;\\n            if(s[i]==\\'(\\'){\\n                sta.push({prevSum,prevOperation});\\n                prevSum=0;\\n                prevOperation=\\'+\\';\\n                i++;\\n                continue;\\n            }\\n            else if(s[i]==\\')\\'){\\n                pair<int,char> p=sta.top();\\n                sta.pop();\\n                if(p.second==\\'-\\')\\n                    prevSum = -1*prevSum + p.first;\\n                else\\n                    prevSum = prevSum + p.first;\\n            }\\n            prevOperation=s[i++];\\n        }\\n        return prevSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int size=s.size(),i=0,ans=0,prevSum=0;\\n        char prevOperation=\\'+\\';\\n        stack<pair<int,char>> sta;\\n        while(i<size){\\n            if(s[i]==\\' \\'){\\n                i++;\\n                continue;\\n            }\\n            int num=0;\\n            while(i<size && isdigit(s[i]))\\n                num = num*10 + (s[i++]-\\'0\\');\\n            if(prevOperation==\\'+\\')\\n                prevSum += num;\\n            else if(prevOperation==\\'-\\')\\n                prevSum += -1*num;\\n            if(s[i]==\\'(\\'){\\n                sta.push({prevSum,prevOperation});\\n                prevSum=0;\\n                prevOperation=\\'+\\';\\n                i++;\\n                continue;\\n            }\\n            else if(s[i]==\\')\\'){\\n                pair<int,char> p=sta.top();\\n                sta.pop();\\n                if(p.second==\\'-\\')\\n                    prevSum = -1*prevSum + p.first;\\n                else\\n                    prevSum = prevSum + p.first;\\n            }\\n            prevOperation=s[i++];\\n        }\\n        return prevSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692939,
                "title": "simple-c-in-6ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n = s.size();\\n        stack<int>st;\\n        long long int sum = 0;\\n        int sign  = 1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int ch = s[i];\\n            if(isdigit(s[i]))\\n            {\\n                long long int num =0;\\n                while(i<n and isdigit(s[i]))\\n                {\\n                    num = num*10 + (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num *= sign;\\n                sum += num;\\n                sign = 1;\\n            }\\n            else if(ch==\\'(\\')\\n            {\\n                st.push(sum);\\n                st.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(ch==\\')\\')\\n            {\\n                sum *= st.top();\\n                st.pop();\\n                sum += st.top();\\n                st.pop();\\n            }\\n            else if(ch==\\'-\\')\\n            {\\n                sign *= -1;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n = s.size();\\n        stack<int>st;\\n        long long int sum = 0;\\n        int sign  = 1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int ch = s[i];\\n            if(isdigit(s[i]))\\n            {\\n                long long int num =0;\\n                while(i<n and isdigit(s[i]))\\n                {\\n                    num = num*10 + (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num *= sign;\\n                sum += num;\\n                sign = 1;\\n            }\\n            else if(ch==\\'(\\')\\n            {\\n                st.push(sum);\\n                st.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(ch==\\')\\')\\n            {\\n                sum *= st.top();\\n                st.pop();\\n                sum += st.top();\\n                st.pop();\\n            }\\n            else if(ch==\\'-\\')\\n            {\\n                sign *= -1;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677640,
                "title": "c-using-stack-easy-to-understand",
                "content": "~~~\\nclass Solution {\\npublic:\\n   int calculate(string s) {\\n       stack<pair<int,int>> st; // pair(prev_calc_value , sign before next bracket () )\\n       \\n       long long int sum = 0;\\n       int sign = +1;\\n       \\n       for(int i = 0 ; i < s.size() ; ++i)\\n       {\\n           char ch = s[i];\\n           \\n           if(isdigit(ch))\\n           {\\n               long long int num = 0;\\n               while(i < s.size() and isdigit(s[i]))\\n               {\\n                   num = (num * 10) + s[i] - \\'0\\';\\n                   i++;\\n               }\\n               i--; // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n               sum += (num * sign);\\n               sign = +1; // reseting sign\\n           }\\n           else if(ch == \\'(\\')\\n           {\\n               // Saving current state of (sum , sign) in stack\\n               st.push(make_pair(sum , sign));\\n               \\n               // Reseting sum and sign for inner bracket calculation\\n               sum = 0; \\n               sign = +1;\\n           }\\n           else if(ch == \\')\\')\\n           {\\n               sum = st.top().first + (st.top().second * sum);\\n               st.pop();\\n           }\\n           else if(ch == \\'-\\')\\n           {\\n               // toggle sign\\n               sign = (-1 * sign);\\n           }\\n       }\\n       return sum;\\n   }\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   int calculate(string s) {\\n       stack<pair<int,int>> st; // pair(prev_calc_value , sign before next bracket () )\\n       \\n       long long int sum = 0;\\n       int sign = +1;\\n       \\n       for(int i = 0 ; i < s.size() ; ++i)\\n       {\\n           char ch = s[i];\\n           \\n           if(isdigit(ch))\\n           {\\n               long long int num = 0;\\n               while(i < s.size() and isdigit(s[i]))\\n               {\\n                   num = (num * 10) + s[i] - \\'0\\';\\n                   i++;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 2633989,
                "title": "java-explanation-easy-understanding-solution",
                "content": "**1. first i replaced all empty space with \"\"\\nString===>( 1 + (  4 + 5+ 2  )  -   3    )   +   (    6   +   8    )\\nindex===> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18\\n2. in function \"bracketSolver\" i send values in between index 4 to 8 both inclusive and solve it and return its value and replce it like this\\nString===>( 1 + 11 -  3  ) + (  6   +  8    )\\nindex===> 0 1 2 34 5 6 7 8 9 10 11 12 13\\n3\\nString===>9 + (  6 + 8  )\\nindex===> 0 1  2 3 4 5 6\\n4\\nString===>9 + 14\\nindex===> 0 1  23\\n5\\nString===>23\\nindex===> 01**\\n\\n```\\nclass Solution224 {\\n    public int bracketSolver(String ss) {\\n        int ans = 0, res = 0, sign = 0;\\n        for (int i = 0; i <= ss.length() - 1; i++) {\\n            if (Character.isDigit(ss.charAt(i))) {\\n                ans = (ans * 10) + (ss.charAt(i) - 48);\\n                if (i == ss.length() - 1 || ss.charAt(i + 1) == \\'+\\' || ss.charAt(i + 1) == \\'-\\') {\\n                    if (sign == 1) {\\n                        ans = -ans;\\n                        sign = 0;\\n                    }\\n                    res += ans;\\n                    ans = 0;\\n                }\\n            } else if (ss.charAt(i) == \\'-\\')\\n                sign = 1;\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n        StringBuilder ss = new StringBuilder(s.replaceAll(\" \", \"\"));\\n        int ei, si, res;\\n        while (ss.indexOf(\")\") >= 0) {\\n            ei = ss.indexOf(\")\");\\n            si = ss.lastIndexOf(\"(\", ei);\\n            res = bracketSolver(ss.substring(si + 1, ei));\\n            if (si - 1 >= 0 && ss.charAt(si - 1) == \\'-\\') {\\n                res = -res;\\n                si = si - 1;\\n            } else if (si - 1 >= 0 && ss.charAt(si - 1) == \\'+\\')\\n                si = si - 1;\\n            if (res >= 0)\\n                ss.replace(si, ei + 1, \"+\" + res);\\n            else\\n                ss.replace(si, ei + 1, String.valueOf(res));\\n        }\\n        return bracketSolver(ss.toString());\\n    }\\n}\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution224 {\\n    public int bracketSolver(String ss) {\\n        int ans = 0, res = 0, sign = 0;\\n        for (int i = 0; i <= ss.length() - 1; i++) {\\n            if (Character.isDigit(ss.charAt(i))) {\\n                ans = (ans * 10) + (ss.charAt(i) - 48);\\n                if (i == ss.length() - 1 || ss.charAt(i + 1) == \\'+\\' || ss.charAt(i + 1) == \\'-\\') {\\n                    if (sign == 1) {\\n                        ans = -ans;\\n                        sign = 0;\\n                    }\\n                    res += ans;\\n                    ans = 0;\\n                }\\n            } else if (ss.charAt(i) == \\'-\\')\\n                sign = 1;\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n        StringBuilder ss = new StringBuilder(s.replaceAll(\" \", \"\"));\\n        int ei, si, res;\\n        while (ss.indexOf(\")\") >= 0) {\\n            ei = ss.indexOf(\")\");\\n            si = ss.lastIndexOf(\"(\", ei);\\n            res = bracketSolver(ss.substring(si + 1, ei));\\n            if (si - 1 >= 0 && ss.charAt(si - 1) == \\'-\\') {\\n                res = -res;\\n                si = si - 1;\\n            } else if (si - 1 >= 0 && ss.charAt(si - 1) == \\'+\\')\\n                si = si - 1;\\n            if (res >= 0)\\n                ss.replace(si, ei + 1, \"+\" + res);\\n            else\\n                ss.replace(si, ei + 1, String.valueOf(res));\\n        }\\n        return bracketSolver(ss.toString());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556064,
                "title": "recursion",
                "content": "The problem is same as the basic calculator, but the only thing changes is that braces are included.\\nWhen we encounter \\'(\\', just call the same the function for solving value of the expression inside the braces, when we encouter \\')\\' just return result put num = 0.\\n****\\n```\\nclass Solution {\\n    int pos = 0;\\n    public int calculate(String s) {\\n         pos = 0;\\n           return solve(s);\\n    }\\n\\n    private  int solve(String s) {\\n        int sign = 1; // initial take as positive\\n        int num = 0;\\n        int res = 0;\\n        while (pos < s.length()) {\\n            char curr = s.charAt(pos++);\\n            if (curr == \\' \\'){\\n                continue;\\n            }else if (isNum(curr)) {\\n                num = num * 10 + curr - \\'0\\';\\n            } else if (curr == \\'(\\') {\\n                num = solve(s);\\n            } else if(curr == \\')\\') {\\n                res += num * sign;\\n                return res;\\n            } else {\\n               res += sign * num;\\n               sign = curr == \\'-\\' ? -1 : 1;\\n               num = 0;\\n            }\\n    }\\n   int ret = res + (sign * num);\\n        return ret;\\n}\\n\\n    private  boolean isNum(char curr) {\\n        int num = curr - \\'0\\';\\n        return num >= 0 && num <= 9;\\n    }\\n    \\n}\\n```\\n**Thanks for viewing.**\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int pos = 0;\\n    public int calculate(String s) {\\n         pos = 0;\\n           return solve(s);\\n    }\\n\\n    private  int solve(String s) {\\n        int sign = 1; // initial take as positive\\n        int num = 0;\\n        int res = 0;\\n        while (pos < s.length()) {\\n            char curr = s.charAt(pos++);\\n            if (curr == \\' \\'){\\n                continue;\\n            }else if (isNum(curr)) {\\n                num = num * 10 + curr - \\'0\\';\\n            } else if (curr == \\'(\\') {\\n                num = solve(s);\\n            } else if(curr == \\')\\') {\\n                res += num * sign;\\n                return res;\\n            } else {\\n               res += sign * num;\\n               sign = curr == \\'-\\' ? -1 : 1;\\n               num = 0;\\n            }\\n    }\\n   int ret = res + (sign * num);\\n        return ret;\\n}\\n\\n    private  boolean isNum(char curr) {\\n        int num = curr - \\'0\\';\\n        return num >= 0 && num <= 9;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535635,
                "title": "python-solution",
                "content": "Not super fast, but I think quite intuitive:\\n\\n```python\\nclass Solution:\\n    def calc(self, s: str) -> int:\\n        \"\"\" calc simple math without () \"\"\"\\n        stack = []\\n        op = \"+\"\\n        for tok in re.findall(r\"\\\\d+|[-+*]\", s):\\n            if tok.isnumeric():\\n                if op == \"+\":\\n                    stack.append(int(tok))\\n                elif op == \"-\":\\n                    stack.append(-int(tok))\\n                elif op == \"*\":\\n                    stack.append(stack.pop() * int(tok))\\n            else:\\n                op = tok\\n        return sum(stack)\\n    \\n    def calculate(self, s: str) -> int:\\n        s = s.replace(\" \", \"\")\\n        while True:\\n            # deal with most inner (...) each time\\n            sub = re.search(\"\\\\([^()]+\\\\)\", s)\\n            if not sub:\\n                break\\n            subexp = sub.group(0)\\n            subval = self.calc(subexp[1:-1])\\n            s = s.replace(subexp, str(subval))\\n            if subval < 0:\\n                s = s.replace(\"--\", \"+\")  # \"1-(-2)\" tyope of case\\n        return self.calc(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def calc(self, s: str) -> int:\\n        \"\"\" calc simple math without () \"\"\"\\n        stack = []\\n        op = \"+\"\\n        for tok in re.findall(r\"\\\\d+|[-+*]\", s):\\n            if tok.isnumeric():\\n                if op == \"+\":\\n                    stack.append(int(tok))\\n                elif op == \"-\":\\n                    stack.append(-int(tok))\\n                elif op == \"*\":\\n                    stack.append(stack.pop() * int(tok))\\n            else:\\n                op = tok\\n        return sum(stack)\\n    \\n    def calculate(self, s: str) -> int:\\n        s = s.replace(\" \", \"\")\\n        while True:\\n            # deal with most inner (...) each time\\n            sub = re.search(\"\\\\([^()]+\\\\)\", s)\\n            if not sub:\\n                break\\n            subexp = sub.group(0)\\n            subval = self.calc(subexp[1:-1])\\n            s = s.replace(subexp, str(subval))\\n            if subval < 0:\\n                s = s.replace(\"--\", \"+\")  # \"1-(-2)\" tyope of case\\n        return self.calc(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523653,
                "title": "java-recursion-100-fast-easy",
                "content": "**<-------------//VoteUp if you like the solution**\\n\\n```\\nclass Solution {\\n    \\n    int pos = 0;\\n    \\n    public int calculate(String s) {\\n        pos = 0;\\n        return solve(s);\\n    }\\n    \\n    public int solve(String s) {\\n        \\n        int len = s.length();\\n        int res = 0;\\n        int num = 0;\\n        int signNum = 1;//positive sign for start\\n        while(pos < len) {\\n            \\n            char cur_char = s.charAt(pos++);\\n            \\n            if(cur_char == \\' \\') {\\n                continue;\\n            }\\n            else if(isNum(cur_char)){\\n                num = num * 10 + cur_char-\\'0\\';\\n            } \\n            else if(cur_char == \\'(\\'){\\n                //pos++;\\n                num = solve(s);\\n            } \\n            else if(cur_char == \\')\\'){\\n                res += signNum * num;\\n                \\n                return res;\\n            } \\n            else{\\n                res += signNum * num;\\n                signNum = cur_char == \\'-\\'?-1:1;\\n                num = 0;\\n                \\n            }\\n            \\n        }\\n        \\n        int ret = res + signNum * num;\\n        \\n        return ret;\\n    }\\n    \\n    public boolean isNum(char c){\\n        int a = c - \\'0\\';\\n        \\n        if(a >= 0 && a <= 9){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int pos = 0;\\n    \\n    public int calculate(String s) {\\n        pos = 0;\\n        return solve(s);\\n    }\\n    \\n    public int solve(String s) {\\n        \\n        int len = s.length();\\n        int res = 0;\\n        int num = 0;\\n        int signNum = 1;//positive sign for start\\n        while(pos < len) {\\n            \\n            char cur_char = s.charAt(pos++);\\n            \\n            if(cur_char == \\' \\') {\\n                continue;\\n            }\\n            else if(isNum(cur_char)){\\n                num = num * 10 + cur_char-\\'0\\';\\n            } \\n            else if(cur_char == \\'(\\'){\\n                //pos++;\\n                num = solve(s);\\n            } \\n            else if(cur_char == \\')\\'){\\n                res += signNum * num;\\n                \\n                return res;\\n            } \\n            else{\\n                res += signNum * num;\\n                signNum = cur_char == \\'-\\'?-1:1;\\n                num = 0;\\n                \\n            }\\n            \\n        }\\n        \\n        int ret = res + signNum * num;\\n        \\n        return ret;\\n    }\\n    \\n    public boolean isNum(char c){\\n        int a = c - \\'0\\';\\n        \\n        if(a >= 0 && a <= 9){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448567,
                "title": "over-engineered-solution-using-ast-visitor",
                "content": "```python\\nfrom abc import ABC, abstractmethod\\nfrom dataclasses import dataclass\\nfrom enum import auto, Enum\\nfrom typing import Optional, Generic, TypeVar\\n\\nT = TypeVar(\\'T\\')\\n\\n\\nclass Node(ABC):\\n    @abstractmethod\\n    def accept(self, visitor):\\n        ...\\n\\n\\n@dataclass(frozen=True)\\nclass Addition(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_addition(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Subtraction(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_subtraction(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Multiplication(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_multiplication(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Division(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_division(self)\\n\\n@dataclass(frozen=True)\\nclass Modulus(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_modulus(self)\\n\\n\\n@dataclass(frozen=True)\\nclass UnaryMinus(Node):\\n    value: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_unary_minus(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Literal(Node):\\n    value: int\\n\\n    def accept(self, visitor):\\n        return visitor.visit_literal(self)\\n\\n    \\nclass TokenType(Enum):\\n    PLUS = auto()\\n    MINUS = auto()\\n    MUL = auto()\\n    DIV = auto()\\n    MOD = auto()\\n    LPRAREN = auto()\\n    RPAREN = auto()\\n    INTEGER = auto()\\n\\n\\n@dataclass(frozen=True)\\nclass Token:\\n    type: TokenType\\n    value: Optional[int] = None\\n\\n\\nKEYWORDS = {\\n    \\'+\\': TokenType.PLUS,\\n    \\'-\\': TokenType.MINUS,\\n    \\'*\\': TokenType.MUL,\\n    \\'/\\': TokenType.DIV,\\n    \\'%\\': TokenType.MOD,\\n    \\'(\\': TokenType.LPRAREN,\\n    \\')\\': TokenType.RPAREN\\n}\\n\\n\\nclass Lexer:\\n    def __init__(self, expression: str):\\n        self.expression = expression\\n        self.pos = 0\\n        self.tokens = []\\n\\n    def lex(self):\\n        while self.pos < len(self.expression):\\n            value = self.expression[self.pos]\\n\\n            if value in \\' \\\\r\\\\n\\\\t\\':\\n                self.advance()\\n                continue\\n\\n            if ttype := KEYWORDS.get(value):\\n                self.insert(Token(ttype))\\n            elif value.isdigit():\\n                self.lex_number()\\n            else:\\n                raise ValueError(f\\'Invalid symbol: {value}\\')\\n\\n    def lex_number(self):\\n        start = self.pos\\n        self.advance()\\n\\n        while self.pos < len(self.expression) and self.expression[self.pos].isdigit():\\n            self.advance()\\n\\n        end = self.pos\\n        self.revert()\\n        self.insert(Token(TokenType.INTEGER, int(self.expression[start:end])))\\n\\n    def insert(self, token: Token):\\n        self.tokens.append(token)\\n        self.advance()\\n\\n    def advance(self):\\n        self.pos += 1\\n\\n    def revert(self):\\n        self.pos -= 1\\n\\n\\nclass Parser:\\n    def __init__(self, expression: str):\\n        lexer = Lexer(expression)\\n        lexer.lex()\\n        self.tokens = lexer.tokens\\n        self.pos = 0\\n\\n    def parse(self) -> Node:\\n        return self.parse_plus()\\n\\n    def parse_plus(self) -> Node:\\n        result = self.parse_mul()\\n\\n        while True:\\n            if self.accept(TokenType.PLUS):\\n                result = Addition(result, self.parse_mul())\\n            elif self.accept(TokenType.MINUS):\\n                result = Subtraction(result, self.parse_mul())\\n            else:\\n                break\\n\\n        return result\\n\\n    def parse_mul(self) -> Node:\\n        result = self.parse_unary()\\n\\n        while True:\\n            if self.accept(TokenType.MUL):\\n                result = Multiplication(result, self.parse_unary())\\n            elif self.accept(TokenType.DIV):\\n                result = Division(result, self.parse_unary())\\n            elif self.accept(TokenType.MOD):\\n                result = Modulus(result, self.parse_unary())\\n            else:\\n                break\\n\\n        return result\\n\\n    def parse_unary(self) -> Node:\\n        if self.accept(TokenType.MINUS):\\n            return UnaryMinus(self.parse_unary())\\n\\n        return self.parse_primary()\\n\\n    def parse_primary(self) -> Node:\\n        if self.accept(TokenType.LPRAREN):\\n            result = self.parse()\\n            self.expect(TokenType.RPAREN)\\n            return result\\n        elif token := self.accept(TokenType.INTEGER):\\n            return Literal(token.value)\\n\\n        raise ValueError(f\\'Invalid expression\\')\\n\\n    def accept(self, ttype: TokenType) -> Optional[Token]:\\n        current = self.current_token\\n\\n        if current and current.type == ttype:\\n            self.advance()\\n            return current\\n\\n    def expect(self, ttype: TokenType) -> Token:\\n        if token := self.accept(ttype):\\n            return token\\n\\n        raise ValueError(f\\'Expected: {ttype}\\')\\n\\n    @property\\n    def current_token(self) -> Optional[Token]:\\n        if self.pos < len(self.tokens):\\n            return self.tokens[self.pos]\\n\\n    def advance(self):\\n        self.pos += 1\\n\\n\\nclass Visitor(ABC, Generic[T]):\\n    @abstractmethod\\n    def visit_addition(self, node: Addition) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_subtraction(self, node: Subtraction) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_multiplication(self, node: Multiplication) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_division(self, node: Division) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_modulus(self, node: Modulus) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_unary_minus(self, node: UnaryMinus) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_literal(self, node: Literal) -> T:\\n        ...\\n\\n\\nclass Calculator(Visitor[int]):\\n    def execute(self, node: Node) -> int:\\n        return node.accept(self)\\n\\n    def visit_addition(self, node: Addition) -> int:\\n        return self.execute(node.left) + self.execute(node.right)\\n\\n    def visit_subtraction(self, node: Subtraction) -> int:\\n        return self.execute(node.left) - self.execute(node.right)\\n\\n    def visit_multiplication(self, node: Multiplication) -> int:\\n        return self.execute(node.left) * self.execute(node.right)\\n\\n    def visit_division(self, node: Division) -> int:\\n        return self.execute(node.left) // self.execute(node.right)\\n\\n    def visit_modulus(self, node: Modulus) -> T:\\n        return self.execute(node.left) % self.execute(node.right)\\n\\n    def visit_unary_minus(self, node: UnaryMinus) -> int:\\n        return -self.execute(node.value)\\n\\n    def visit_literal(self, node: Literal) -> int:\\n        return node.value\\n\\n\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        parser = Parser(s)\\n        root = parser.parse()\\n\\n        calculator = Calculator()\\n        return calculator.execute(root)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom abc import ABC, abstractmethod\\nfrom dataclasses import dataclass\\nfrom enum import auto, Enum\\nfrom typing import Optional, Generic, TypeVar\\n\\nT = TypeVar(\\'T\\')\\n\\n\\nclass Node(ABC):\\n    @abstractmethod\\n    def accept(self, visitor):\\n        ...\\n\\n\\n@dataclass(frozen=True)\\nclass Addition(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_addition(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Subtraction(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_subtraction(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Multiplication(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_multiplication(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Division(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_division(self)\\n\\n@dataclass(frozen=True)\\nclass Modulus(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_modulus(self)\\n\\n\\n@dataclass(frozen=True)\\nclass UnaryMinus(Node):\\n    value: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_unary_minus(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Literal(Node):\\n    value: int\\n\\n    def accept(self, visitor):\\n        return visitor.visit_literal(self)\\n\\n    \\nclass TokenType(Enum):\\n    PLUS = auto()\\n    MINUS = auto()\\n    MUL = auto()\\n    DIV = auto()\\n    MOD = auto()\\n    LPRAREN = auto()\\n    RPAREN = auto()\\n    INTEGER = auto()\\n\\n\\n@dataclass(frozen=True)\\nclass Token:\\n    type: TokenType\\n    value: Optional[int] = None\\n\\n\\nKEYWORDS = {\\n    \\'+\\': TokenType.PLUS,\\n    \\'-\\': TokenType.MINUS,\\n    \\'*\\': TokenType.MUL,\\n    \\'/\\': TokenType.DIV,\\n    \\'%\\': TokenType.MOD,\\n    \\'(\\': TokenType.LPRAREN,\\n    \\')\\': TokenType.RPAREN\\n}\\n\\n\\nclass Lexer:\\n    def __init__(self, expression: str):\\n        self.expression = expression\\n        self.pos = 0\\n        self.tokens = []\\n\\n    def lex(self):\\n        while self.pos < len(self.expression):\\n            value = self.expression[self.pos]\\n\\n            if value in \\' \\\\r\\\\n\\\\t\\':\\n                self.advance()\\n                continue\\n\\n            if ttype := KEYWORDS.get(value):\\n                self.insert(Token(ttype))\\n            elif value.isdigit():\\n                self.lex_number()\\n            else:\\n                raise ValueError(f\\'Invalid symbol: {value}\\')\\n\\n    def lex_number(self):\\n        start = self.pos\\n        self.advance()\\n\\n        while self.pos < len(self.expression) and self.expression[self.pos].isdigit():\\n            self.advance()\\n\\n        end = self.pos\\n        self.revert()\\n        self.insert(Token(TokenType.INTEGER, int(self.expression[start:end])))\\n\\n    def insert(self, token: Token):\\n        self.tokens.append(token)\\n        self.advance()\\n\\n    def advance(self):\\n        self.pos += 1\\n\\n    def revert(self):\\n        self.pos -= 1\\n\\n\\nclass Parser:\\n    def __init__(self, expression: str):\\n        lexer = Lexer(expression)\\n        lexer.lex()\\n        self.tokens = lexer.tokens\\n        self.pos = 0\\n\\n    def parse(self) -> Node:\\n        return self.parse_plus()\\n\\n    def parse_plus(self) -> Node:\\n        result = self.parse_mul()\\n\\n        while True:\\n            if self.accept(TokenType.PLUS):\\n                result = Addition(result, self.parse_mul())\\n            elif self.accept(TokenType.MINUS):\\n                result = Subtraction(result, self.parse_mul())\\n            else:\\n                break\\n\\n        return result\\n\\n    def parse_mul(self) -> Node:\\n        result = self.parse_unary()\\n\\n        while True:\\n            if self.accept(TokenType.MUL):\\n                result = Multiplication(result, self.parse_unary())\\n            elif self.accept(TokenType.DIV):\\n                result = Division(result, self.parse_unary())\\n            elif self.accept(TokenType.MOD):\\n                result = Modulus(result, self.parse_unary())\\n            else:\\n                break\\n\\n        return result\\n\\n    def parse_unary(self) -> Node:\\n        if self.accept(TokenType.MINUS):\\n            return UnaryMinus(self.parse_unary())\\n\\n        return self.parse_primary()\\n\\n    def parse_primary(self) -> Node:\\n        if self.accept(TokenType.LPRAREN):\\n            result = self.parse()\\n            self.expect(TokenType.RPAREN)\\n            return result\\n        elif token := self.accept(TokenType.INTEGER):\\n            return Literal(token.value)\\n\\n        raise ValueError(f\\'Invalid expression\\')\\n\\n    def accept(self, ttype: TokenType) -> Optional[Token]:\\n        current = self.current_token\\n\\n        if current and current.type == ttype:\\n            self.advance()\\n            return current\\n\\n    def expect(self, ttype: TokenType) -> Token:\\n        if token := self.accept(ttype):\\n            return token\\n\\n        raise ValueError(f\\'Expected: {ttype}\\')\\n\\n    @property\\n    def current_token(self) -> Optional[Token]:\\n        if self.pos < len(self.tokens):\\n            return self.tokens[self.pos]\\n\\n    def advance(self):\\n        self.pos += 1\\n\\n\\nclass Visitor(ABC, Generic[T]):\\n    @abstractmethod\\n    def visit_addition(self, node: Addition) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_subtraction(self, node: Subtraction) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_multiplication(self, node: Multiplication) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_division(self, node: Division) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_modulus(self, node: Modulus) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_unary_minus(self, node: UnaryMinus) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_literal(self, node: Literal) -> T:\\n        ...\\n\\n\\nclass Calculator(Visitor[int]):\\n    def execute(self, node: Node) -> int:\\n        return node.accept(self)\\n\\n    def visit_addition(self, node: Addition) -> int:\\n        return self.execute(node.left) + self.execute(node.right)\\n\\n    def visit_subtraction(self, node: Subtraction) -> int:\\n        return self.execute(node.left) - self.execute(node.right)\\n\\n    def visit_multiplication(self, node: Multiplication) -> int:\\n        return self.execute(node.left) * self.execute(node.right)\\n\\n    def visit_division(self, node: Division) -> int:\\n        return self.execute(node.left) // self.execute(node.right)\\n\\n    def visit_modulus(self, node: Modulus) -> T:\\n        return self.execute(node.left) % self.execute(node.right)\\n\\n    def visit_unary_minus(self, node: UnaryMinus) -> int:\\n        return -self.execute(node.value)\\n\\n    def visit_literal(self, node: Literal) -> int:\\n        return node.value\\n\\n\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        parser = Parser(s)\\n        root = parser.parse()\\n\\n        calculator = Calculator()\\n        return calculator.execute(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418881,
                "title": "c-recursion-time-better-than-99-43-space-better-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    int cal(string &s, int &j)\\n    {\\n        int sum =0;\\n        char ch = \\'+\\';\\n        int tmp = 0;\\n        while(j<s.length())\\n        {\\n            while(j<s.length() && s[j]!=\\'(\\' && s[j]!=\\')\\')\\n            {\\n                if(s[j]>=\\'0\\' && s[j]<=\\'9\\')\\n                {\\n                    tmp = tmp*10 + (s[j]-\\'0\\');\\n                    \\n                }else if(s[j] != \\' \\')\\n                {\\n                    if(ch == \\'+\\')\\n                        sum+=tmp;\\n                    else\\n                        sum-=tmp;\\n                    \\n                    ch = s[j];\\n                    tmp =0;\\n                }\\n                j++;\\n            }\\n            \\n            if(ch == \\'+\\')\\n                sum+=tmp;\\n            else\\n                sum-=tmp;\\n            \\n            if(j<s.length())\\n            {\\n                if(s[j]==\\')\\')\\n                {\\n                    j++;\\n                    return sum;\\n                }\\n                \\n                else if(ch == \\'+\\')\\n                        sum+=cal(s,++j);\\n                else\\n                        sum-=cal(s,++j);\\n            }\\n        }\\n        return sum;\\n    }\\n    int calculate(string &s) {\\n        int  j =0;\\n        int sum =0;\\n        \\n        while(j<s.length())\\n        {\\n            sum+=cal(s,j);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cal(string &s, int &j)\\n    {\\n        int sum =0;\\n        char ch = \\'+\\';\\n        int tmp = 0;\\n        while(j<s.length())\\n        {\\n            while(j<s.length() && s[j]!=\\'(\\' && s[j]!=\\')\\')\\n            {\\n                if(s[j]>=\\'0\\' && s[j]<=\\'9\\')\\n                {\\n                    tmp = tmp*10 + (s[j]-\\'0\\');\\n                    \\n                }else if(s[j] != \\' \\')\\n                {\\n                    if(ch == \\'+\\')\\n                        sum+=tmp;\\n                    else\\n                        sum-=tmp;\\n                    \\n                    ch = s[j];\\n                    tmp =0;\\n                }\\n                j++;\\n            }\\n            \\n            if(ch == \\'+\\')\\n                sum+=tmp;\\n            else\\n                sum-=tmp;\\n            \\n            if(j<s.length())\\n            {\\n                if(s[j]==\\')\\')\\n                {\\n                    j++;\\n                    return sum;\\n                }\\n                \\n                else if(ch == \\'+\\')\\n                        sum+=cal(s,++j);\\n                else\\n                        sum-=cal(s,++j);\\n            }\\n        }\\n        return sum;\\n    }\\n    int calculate(string &s) {\\n        int  j =0;\\n        int sum =0;\\n        \\n        while(j<s.length())\\n        {\\n            sum+=cal(s,j);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247299,
                "title": "my-java-solution",
                "content": "```\\nclass Solution {\\n    //Time Complexity O(N)\\n    //Space Complexity O(N) at most\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        Pair<Integer, Integer> resultPair = calculateFrom(s, 0);\\n        return resultPair.getKey();\\n    }\\n    \\n    public Pair<Integer, Integer> calculateFrom(String s, int fromIdx) {\\n        if (fromIdx >= s.length()) {\\n            return new Pair(0, fromIdx + 1);\\n        }\\n        \\n        int result = 0;\\n        int sign = 1;\\n        int i = fromIdx;\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            \\n            if (c == \\'-\\') {\\n                sign = -1;\\n                i++;\\n                continue;\\n            }\\n            \\n            if (c == \\'+\\' || c == \\' \\') {\\n                i++;\\n                continue;\\n            }\\n            \\n            if (c == \\'(\\') {\\n                Pair<Integer, Integer> pair = calculateFrom(s, i + 1);\\n                result += sign * pair.getKey();\\n                sign = 1;\\n                i = pair.getValue();\\n                continue;\\n            }\\n            \\n            if (c == \\')\\') {\\n                return new Pair(result, i + 1);\\n            }\\n            \\n            //else, evaluate next number\\n            int num = 0;\\n            while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                num = num * 10 + (s.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            result += sign * num;\\n            sign = 1;\\n        }        \\n        \\n        return new Pair(result, s.length());\\n    }\\n}\\n```\\nSolution using Stack:\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<Integer> signStack = new Stack<>();\\n        \\n        int result = 0;\\n        int sign = 1;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (c == \\'-\\') {\\n                sign = -1;\\n                continue;\\n            }\\n            \\n            if (c == \\'+\\' || c == \\' \\') {\\n                continue;\\n            }\\n            \\n            if (c == \\'(\\') {\\n                numStack.push(result);\\n                result = 0;\\n                signStack.push(sign);\\n                sign = 1;\\n                continue;\\n            }\\n            \\n            if (c == \\')\\') {\\n                result = signStack.pop() * result + numStack.pop();\\n                sign = 1;\\n                continue;\\n            }\\n            \\n            int num = 0;\\n            while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                num = num * 10 + (s.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            i--;\\n            result += sign * num;\\n            sign = 1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //Time Complexity O(N)\\n    //Space Complexity O(N) at most\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        Pair<Integer, Integer> resultPair = calculateFrom(s, 0);\\n        return resultPair.getKey();\\n    }\\n    \\n    public Pair<Integer, Integer> calculateFrom(String s, int fromIdx) {\\n        if (fromIdx >= s.length()) {\\n            return new Pair(0, fromIdx + 1);\\n        }\\n        \\n        int result = 0;\\n        int sign = 1;\\n        int i = fromIdx;\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            \\n            if (c == \\'-\\') {\\n                sign = -1;\\n                i++;\\n                continue;\\n            }\\n            \\n            if (c == \\'+\\' || c == \\' \\') {\\n                i++;\\n                continue;\\n            }\\n            \\n            if (c == \\'(\\') {\\n                Pair<Integer, Integer> pair = calculateFrom(s, i + 1);\\n                result += sign * pair.getKey();\\n                sign = 1;\\n                i = pair.getValue();\\n                continue;\\n            }\\n            \\n            if (c == \\')\\') {\\n                return new Pair(result, i + 1);\\n            }\\n            \\n            //else, evaluate next number\\n            int num = 0;\\n            while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                num = num * 10 + (s.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            result += sign * num;\\n            sign = 1;\\n        }        \\n        \\n        return new Pair(result, s.length());\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<Integer> signStack = new Stack<>();\\n        \\n        int result = 0;\\n        int sign = 1;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (c == \\'-\\') {\\n                sign = -1;\\n                continue;\\n            }\\n            \\n            if (c == \\'+\\' || c == \\' \\') {\\n                continue;\\n            }\\n            \\n            if (c == \\'(\\') {\\n                numStack.push(result);\\n                result = 0;\\n                signStack.push(sign);\\n                sign = 1;\\n                continue;\\n            }\\n            \\n            if (c == \\')\\') {\\n                result = signStack.pop() * result + numStack.pop();\\n                sign = 1;\\n                continue;\\n            }\\n            \\n            int num = 0;\\n            while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                num = num * 10 + (s.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            i--;\\n            result += sign * num;\\n            sign = 1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196880,
                "title": "stack-proper-comments-added-c",
                "content": "Implementation\\n\\n**Using Stack\\nTime Complexity = O(N)\\nSpace Complexity = O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        \\n        // will use stack to store the res & sign (for the current bracket)\\n        stack<int> st;\\n        \\n        // intially taking sign as 1, sign can be 1(positive) & -1(negative)\\n        int res = 0, sign = 1, size = s.size();\\n        \\n        // iterating over the string\\n        for(int i = 0; i < size; i++){\\n            \\n            // if current char is digit, then\\n            // collect the digit and multiply it with current sign and add into the res\\n            if(isdigit(s[i])){\\n                // taking long bcz (num * 10) in this statement there can be chance of integer overflow\\n                // i.e, s = \"2147483647\", to handle these type of cases\\n                long num = s[i] - \\'0\\';\\n                while(i+1 < size && isdigit(s[i+1])){\\n                    num = num * 10 + s[i+1] - \\'0\\';\\n                    i++;\\n                }\\n                \\n                res += num * sign;\\n            }\\n            \\n            // if current char is \\'+\\' then change the sign to 1, it means positive\\n            else if(s[i] == \\'+\\'){\\n                sign = 1;\\n            }\\n            \\n            // if current char is \\'-\\' then change the sign to 1, it means negative\\n            else if(s[i] == \\'-\\'){\\n                sign = -1;\\n            }\\n            \\n            // if current char is \\'(\\', then push the res & sign, and reinitialize res as 0, and sign as 1(positive)\\n            else if(s[i] == \\'(\\'){\\n                st.push(res);\\n                st.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            \\n            // if current char is \\')\\', then multiply the res with sign(immediate top of the stack), and add the res(next top of the stack), and simultaneously pop the value from stack as well\\n            else if(s[i] == \\')\\'){\\n                int sign = st.top(); st.pop();\\n                int value = st.top(); st.pop();\\n                res = res * sign + value;\\n            }\\n        }\\n        \\n        // return the res\\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        \\n        // will use stack to store the res & sign (for the current bracket)\\n        stack<int> st;\\n        \\n        // intially taking sign as 1, sign can be 1(positive) & -1(negative)\\n        int res = 0, sign = 1, size = s.size();\\n        \\n        // iterating over the string\\n        for(int i = 0; i < size; i++){\\n            \\n            // if current char is digit, then\\n            // collect the digit and multiply it with current sign and add into the res\\n            if(isdigit(s[i])){\\n                // taking long bcz (num * 10) in this statement there can be chance of integer overflow\\n                // i.e, s = \"2147483647\", to handle these type of cases\\n                long num = s[i] - \\'0\\';\\n                while(i+1 < size && isdigit(s[i+1])){\\n                    num = num * 10 + s[i+1] - \\'0\\';\\n                    i++;\\n                }\\n                \\n                res += num * sign;\\n            }\\n            \\n            // if current char is \\'+\\' then change the sign to 1, it means positive\\n            else if(s[i] == \\'+\\'){\\n                sign = 1;\\n            }\\n            \\n            // if current char is \\'-\\' then change the sign to 1, it means negative\\n            else if(s[i] == \\'-\\'){\\n                sign = -1;\\n            }\\n            \\n            // if current char is \\'(\\', then push the res & sign, and reinitialize res as 0, and sign as 1(positive)\\n            else if(s[i] == \\'(\\'){\\n                st.push(res);\\n                st.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            \\n            // if current char is \\')\\', then multiply the res with sign(immediate top of the stack), and add the res(next top of the stack), and simultaneously pop the value from stack as well\\n            else if(s[i] == \\')\\'){\\n                int sign = st.top(); st.pop();\\n                int value = st.top(); st.pop();\\n                res = res * sign + value;\\n            }\\n        }\\n        \\n        // return the res\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174510,
                "title": "c-stack-math-time-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<string> st;\\n        int n=s.size();\\n        st.push(\"(\");\\n        s.push_back(\\')\\');\\n        int res=0;\\n        for(int i=0;i<=n;){\\n            if(s[i]==\\' \\'){\\n                i++;\\n            }else if(s[i]==\\'(\\'){\\n                st.push(\"(\");\\n                i++;\\n            }else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                string str=\"\";\\n                while(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                    str+=s[i];\\n                    i++;\\n                }\\n                \\n                st.push(str);\\n            }else if(s[i]==\\'-\\' and s[i+1]==\\'(\\'){\\n                st.push(\"-\");\\n                i++;\\n            }else if(s[i]==\\'-\\'){\\n                string str=\"-\";\\n                i++;\\n                while(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                    str+=s[i];\\n                    i++;\\n                }\\n                \\n                st.push(str);\\n            }else if(s[i]==\\')\\'){\\n                int val=0;\\n                while(st.top()!=\"(\"){\\n                    val+=stoi(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(!st.empty() and st.top()==\"-\"){\\n                    val=val*-1;\\n                    st.pop();\\n                }\\n                st.push(to_string(val));\\n                i++;\\n            }else{\\n                i++;\\n            }  \\n        }\\n        return stoi(st.top());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<string> st;\\n        int n=s.size();\\n        st.push(\"(\");\\n        s.push_back(\\')\\');\\n        int res=0;\\n        for(int i=0;i<=n;){\\n            if(s[i]==\\' \\'){\\n                i++;\\n            }else if(s[i]==\\'(\\'){\\n                st.push(\"(\");\\n                i++;\\n            }else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                string str=\"\";\\n                while(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                    str+=s[i];\\n                    i++;\\n                }\\n                \\n                st.push(str);\\n            }else if(s[i]==\\'-\\' and s[i+1]==\\'(\\'){\\n                st.push(\"-\");\\n                i++;\\n            }else if(s[i]==\\'-\\'){\\n                string str=\"-\";\\n                i++;\\n                while(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                    str+=s[i];\\n                    i++;\\n                }\\n                \\n                st.push(str);\\n            }else if(s[i]==\\')\\'){\\n                int val=0;\\n                while(st.top()!=\"(\"){\\n                    val+=stoi(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(!st.empty() and st.top()==\"-\"){\\n                    val=val*-1;\\n                    st.pop();\\n                }\\n                st.push(to_string(val));\\n                i++;\\n            }else{\\n                i++;\\n            }  \\n        }\\n        return stoi(st.top());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043695,
                "title": "224-basic-calculator",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n\\t// sum to calculate the total result of evaluation\\n         int sum=0;\\n  // sign to tell whether its going to be positive or negative\\t\\t \\n        int sign=1;\\n        stack<int> st;\\n        for(int i=0;i<s.size();i++){\\n            // if the current s[i] is digit\\n            if(isdigit(s[i])){\\n\\t    // value to get the value of  multiple digits  like\\n        // 3124+1 will give 3124 it will end loop at + so we do i-- to  go back \\n      // one step to not miss this\\n                int val=0;\\n                while(i<s.size()&&isdigit(s[i])){\\n                    val=val*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n\\t\\t// to get the sign of val, mulitply it with sign and then reset the sign for next ones\\n                val=val*sign;\\n                sign=1;\\n\\t\\t// add the val to our sum\\n                sum+=val;\\n            }\\n            \\n            else if(s[i]==\\'(\\'){\\n\\t// whenever we encounter an \\'(\\' push the sum and sign to stack and reset them\\t\\t\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=+1;\\n            }\\n            \\n            else if(s[i]==\\')\\'){\\n\\t// when we get \\')\\' this means an end of parantheses  so multiply with stack top\\n\\t// which will give us the sign of sum and pop it\\n                sum*=st.top();\\n                st.pop();\\n// after getting the sum add it with our previous sum stored in stack to get the total resultant\\n// and pop it after that\\n                sum+=st.top();\\n                st.pop();\\n            }\\n            \\n            else if(s[i]==\\'-\\'){\\n\\t\\t\\t// if we encounter a - sign just mulitply it our sign\\n                sign*=-1;\\n            }\\n        }\\n        // return our total sum or evaluation\\n        return sum;\\n    }\\n};\\n\\n// give your feedbacks regarding this and **upvote if you like the solution** \\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int calculate(string s) {\\n\\t// sum to calculate the total result of evaluation\\n         int sum=0;\\n  // sign to tell whether its going to be positive or negative\\t\\t \\n        int sign=1;\\n        stack<int> st;\\n        for(int i=0;i<s.size();i++){\\n            // if the current s[i] is digit\\n            if(isdigit(s[i])){\\n\\t    // value to get the value of  multiple digits  like\\n        // 3124+1 will give 3124 it will end loop at + so we do i-- to  go back \\n      // one step to not miss this\\n                int val=0;\\n                while(i<s.size()&&isdigit(s[i])){\\n                    val=val*10+(s[i]-\\'0\\');\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1986385,
                "title": "cpp-stack-commented",
                "content": "```\\nint basicCalculator(string str) {\\n\\t//good, hard question lot of steps are there\\n\\tint sum = 0;\\n\\tint sign = 1;\\n\\tstack<int> st;\\n\\n\\tfor (int i = 0; i < str.size(); i++) {\\n\\t\\tchar ch = str[i];\\n\\t\\tif (isdigit(ch)) {\\n\\t\\t\\t//get the whole number, like if ch is \\'1\\' then iterate further to get the number like \\'15\\'\\n\\t\\t\\tint val = 0;\\n\\t\\t\\twhile (i < str.size() and isdigit(str[i])) {\\n\\t\\t\\t\\tval = val * 10 + (str[i] - \\'0\\');\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\ti--;//coz, i ab ek no digit pe aa gya, or outer for loop se vo ek age or bdh jaega, ek char miss kr dega islie i-- kia\\n\\t\\t\\tval = val * sign;\\n\\t\\t\\tsign = 1;//sign ko reset kia\\n\\t\\t\\tsum += val;\\n\\t\\t}\\n\\t\\telse if (ch == \\'(\\') {\\n\\t\\t\\t//sum dalo stack pe, sign dalo stack pe or fir sign and sum ko reset kro\\n\\t\\t\\tst.push(sum);\\n\\t\\t\\tst.push(sign);\\n\\t\\t\\t//reset sign and sum;\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tsign = 1;\\n\\t\\t}\\n\\t\\telse if (ch == \\')\\') {\\n\\t\\t\\t//stack se sign nikalo or use sum se multiply krdo\\n\\t\\t\\tsum *= st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\t//sum me stack ka top add krdo\\n\\t\\t\\tsum += st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\telse if (ch == \\'-\\') {\\n\\t\\t\\t//minus hota h to sign ko reverse krte hai,bachpn me math me pda tha\\n\\t\\t\\tsign *= -1; //sign ko toggle kia hai\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n}",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nint basicCalculator(string str) {\\n\\t//good, hard question lot of steps are there\\n\\tint sum = 0;\\n\\tint sign = 1;\\n\\tstack<int> st;\\n\\n\\tfor (int i = 0; i < str.size(); i++) {\\n\\t\\tchar ch = str[i];\\n\\t\\tif (isdigit(ch)) {\\n\\t\\t\\t//get the whole number, like if ch is \\'1\\' then iterate further to get the number like \\'15\\'\\n\\t\\t\\tint val = 0;\\n\\t\\t\\twhile (i < str.size() and isdigit(str[i])) {\\n\\t\\t\\t\\tval = val * 10 + (str[i] - \\'0\\');\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\ti--;//coz, i ab ek no digit pe aa gya, or outer for loop se vo ek age or bdh jaega, ek char miss kr dega islie i-- kia\\n\\t\\t\\tval = val * sign;\\n\\t\\t\\tsign = 1;//sign ko reset kia\\n\\t\\t\\tsum += val;\\n\\t\\t}\\n\\t\\telse if (ch == \\'(\\') {\\n\\t\\t\\t//sum dalo stack pe, sign dalo stack pe or fir sign and sum ko reset kro\\n\\t\\t\\tst.push(sum);\\n\\t\\t\\tst.push(sign);\\n\\t\\t\\t//reset sign and sum;\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tsign = 1;\\n\\t\\t}\\n\\t\\telse if (ch == \\')\\') {\\n\\t\\t\\t//stack se sign nikalo or use sum se multiply krdo\\n\\t\\t\\tsum *= st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\t//sum me stack ka top add krdo\\n\\t\\t\\tsum += st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\telse if (ch == \\'-\\') {\\n\\t\\t\\t//minus hota h to sign ko reverse krte hai,bachpn me math me pda tha\\n\\t\\t\\tsign *= -1; //sign ko toggle kia hai\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n}",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1791140,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1689917,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1565470,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1568578,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1690608,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1573016,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1575487,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1570456,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1575320,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1574065,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1791140,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1689917,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1565470,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1568578,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1690608,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1573016,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1575487,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1570456,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1575320,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1574065,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1803550,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 1696720,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 1690782,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 1690577,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 2071733,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 2064534,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 2058441,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 2056993,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 2035750,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 1998615,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 1927140,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1915816,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1900294,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1895892,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1746914,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1724080,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1715878,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1691052,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1690786,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1764218,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Wiggle Sort II",
        "question_content": "<p>Given an integer array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>\n\n<p>You may assume the input array always has a valid answer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,1,1,6,4]\n<strong>Output:</strong> [1,6,1,5,1,4]\n<strong>Explanation:</strong> [1,4,1,5,1,6] is also accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,2,2,3,1]\n<strong>Output:</strong> [2,3,1,3,1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li>It is guaranteed that there will be an answer for the given input <code>nums</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow Up:</strong> Can you do it in <code>O(n)</code> time and/or <strong>in-place</strong> with <code>O(1)</code> extra space?",
        "solutions": [
            {
                "id": 77677,
                "title": "o-n-o-1-after-median-virtual-indexing",
                "content": "This post is mainly about what I call \"virtual indexing\" technique (I'm sure I'm not the first who came up with this, but I couldn't find anything about it, so I made up a name as well. If you know better, let me know).\\n\\n---\\n\\nSolution\\n---\\n\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Find a median.\\n        auto midptr = nums.begin() + n / 2;\\n        nth_element(nums.begin(), midptr, nums.end());\\n        int mid = *midptr;\\n        \\n        // Index-rewiring.\\n        #define A(i) nums[(1+2*(i)) % (n|1)]\\n\\n        // 3-way-partition-to-wiggly in O(n) time with O(1) space.\\n        int i = 0, j = 0, k = n - 1;\\n        while (j <= k) {\\n            if (A(j) > mid)\\n                swap(A(i++), A(j++));\\n            else if (A(j) < mid)\\n                swap(A(j), A(k--));\\n            else\\n                j++;\\n        }\\n    }\\n\\n---\\n\\nExplanation\\n---\\n\\nFirst I find a median using `nth_element`. That only guarantees O(n) **average** time complexity and I don't know about space complexity. I might write this myself using O(n) time and O(1) space, but that's not what I want to show here.\\n\\nThis post is about what comes **after** that. We can use [three-way partitioning](https://en.wikipedia.org/wiki/Dutch_national_flag_problem#Pseudocode) to arrange the numbers so that those *larger than* the median come first, then those *equal to* the median come next, and then those *smaller than* the median come last.\\n\\nOrdinarily, you'd then use one more phase to bring the numbers to their final positions to reach the overall wiggle-property. But I don't know a nice O(1) space way for this. Instead, I embed this right into the partitioning algorithm. That algorithm simply works with indexes 0 to n-1 as usual, but sneaky as I am, I rewire those indexes where I want the numbers to actually end up. The partitioning-algorithm doesn't even know that I'm doing that, it just works like normal (it just uses `A(x)` instead of `nums[x]`).\\n\\nLet's say `nums` is `[10,11,...,19]`. Then after nth_element and ordinary partitioning, we might have this (15 is my median):\\n\\n    index:     0  1  2  3   4   5  6  7  8  9\\n    number:   18 17 19 16  15  11 14 10 13 12\\n\\nI rewire it so that the first spot has index 5, the second spot has index 0, etc, so that I might get this instead:\\n\\n    index:     5  0  6  1  7  2  8  3  9  4\\n    number:   11 18 14 17 10 19 13 16 12 15\\n\\nAnd 11 18 14 17 10 19 13 16 12 15 is perfectly wiggly. And the whole partitioning-to-wiggly-arrangement (everything after finding the median) only takes O(n) time and O(1) space.\\n\\n---\\n\\nIf the above description is unclear, maybe this explicit listing helps:\\n\\nAccessing `A(0)` actually accesses `nums[1]`.  \\nAccessing `A(1)` actually accesses `nums[3]`.  \\nAccessing `A(2)` actually accesses `nums[5]`.  \\nAccessing `A(3)` actually accesses `nums[7]`.  \\nAccessing `A(4)` actually accesses `nums[9]`.  \\nAccessing `A(5)` actually accesses `nums[0]`.  \\nAccessing `A(6)` actually accesses `nums[2]`.  \\nAccessing `A(7)` actually accesses `nums[4]`.  \\nAccessing `A(8)` actually accesses `nums[6]`.  \\nAccessing `A(9)` actually accesses `nums[8]`.\\n\\n---\\n\\nProps to [apolloydy's solution](https://leetcode.com/discuss/77053/time-and-cheating-space-solution-will-there-be-real-solution?show=77054#a77054), I knew the partitioning algorithm already but I didn't know the name. And apolloydy's idea to partition to reverse order happened to make the index rewiring simpler.",
                "solutionTags": [],
                "code": "This post is mainly about what I call \"virtual indexing\" technique (I'm sure I'm not the first who came up with this, but I couldn't find anything about it, so I made up a name as well. If you know better, let me know).\\n\\n---\\n\\nSolution\\n---\\n\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Find a median.\\n        auto midptr = nums.begin() + n / 2;\\n        nth_element(nums.begin(), midptr, nums.end());\\n        int mid = *midptr;\\n        \\n        // Index-rewiring.\\n        #define A(i) nums[(1+2*(i)) % (n|1)]\\n\\n        // 3-way-partition-to-wiggly in O(n) time with O(1) space.\\n        int i = 0, j = 0, k = n - 1;\\n        while (j <= k) {\\n            if (A(j) > mid)\\n                swap(A(i++), A(j++));\\n            else if (A(j) < mid)\\n                swap(A(j), A(k--));\\n            else\\n                j++;\\n        }\\n    }\\n\\n---\\n\\nExplanation\\n---\\n\\nFirst I find a median using `nth_element`. That only guarantees O(n) **average** time complexity and I don't know about space complexity. I might write this myself using O(n) time and O(1) space, but that's not what I want to show here.\\n\\nThis post is about what comes **after** that. We can use [three-way partitioning](https://en.wikipedia.org/wiki/Dutch_national_flag_problem#Pseudocode) to arrange the numbers so that those *larger than* the median come first, then those *equal to* the median come next, and then those *smaller than* the median come last.\\n\\nOrdinarily, you'd then use one more phase to bring the numbers to their final positions to reach the overall wiggle-property. But I don't know a nice O(1) space way for this. Instead, I embed this right into the partitioning algorithm. That algorithm simply works with indexes 0 to n-1 as usual, but sneaky as I am, I rewire those indexes where I want the numbers to actually end up. The partitioning-algorithm doesn't even know that I'm doing that, it just works like normal (it just uses `A(x)` instead of `nums[x]`).\\n\\nLet's say `nums` is `[10,11,...,19]`. Then after nth_element and ordinary partitioning, we might have this (15 is my median):\\n\\n    index:     0  1  2  3   4   5  6  7  8  9\\n    number:   18 17 19 16  15  11 14 10 13 12\\n\\nI rewire it so that the first spot has index 5, the second spot has index 0, etc, so that I might get this instead:\\n\\n    index:     5  0  6  1  7  2  8  3  9  4\\n    number:   11 18 14 17 10 19 13 16 12 15\\n\\nAnd 11 18 14 17 10 19 13 16 12 15 is perfectly wiggly. And the whole partitioning-to-wiggly-arrangement (everything after finding the median) only takes O(n) time and O(1) space.\\n\\n---\\n\\nIf the above description is unclear, maybe this explicit listing helps:\\n\\nAccessing `A(0)` actually accesses `nums[1]`.  \\nAccessing `A(1)` actually accesses `nums[3]`.  \\nAccessing `A(2)` actually accesses `nums[5]`.  \\nAccessing `A(3)` actually accesses `nums[7]`.  \\nAccessing `A(4)` actually accesses `nums[9]`.  \\nAccessing `A(5)` actually accesses `nums[0]`.  \\nAccessing `A(6)` actually accesses `nums[2]`.  \\nAccessing `A(7)` actually accesses `nums[4]`.  \\nAccessing `A(8)` actually accesses `nums[6]`.  \\nAccessing `A(9)` actually accesses `nums[8]`.\\n\\n---\\n\\nProps to [apolloydy's solution](https://leetcode.com/discuss/77053/time-and-cheating-space-solution-will-there-be-real-solution?show=77054#a77054), I knew the partitioning algorithm already but I didn't know the name. And apolloydy's idea to partition to reverse order happened to make the index rewiring simpler.",
                "codeTag": "Unknown"
            },
            {
                "id": 77682,
                "title": "step-by-step-explanation-of-index-mapping-in-java",
                "content": "The virtual index idea in the post https://leetcode.com/discuss/77133/o-n-o-1-after-median-virtual-indexing\\nis very brilliant! However, it takes me a while to understand why and how it works. There is no 'nth_element' in Java, but you can use 'findKthLargest' function from \"https://leetcode.com/problems/kth-largest-element-in-an-array/\" to get the median element in average O(n) time and O(1) space.\\n\\n\\nAssume your original array is {6,13,5,4,5,2}. After you get median element, the 'nums' is partially sorted such that the first half is larger or equal to the median, the second half is smaller or equal to the median, i.e\\n\\n\\n    13   6   5   5   4   2\\n\\n             M\\nIn the post https://leetcode.com/discuss/76965/3-lines-python-with-explanation-proof, we have learned that , to get wiggle sort, you want to put the number in the following way such that\\n \\n(1) elements smaller than the 'median' are put into the last even slots\\n\\n(2) elements larger than the 'median' are put into the first odd slots\\n\\n(3) the  medians are put into the remaining slots.\\n\\n    Index :       0   1   2   3   4   5\\n    Small half:   M       S       S    \\n    Large half:       L       L       M\\n \\nM - Median, S-Small, L-Large. In this example, we want to put {13, 6, 5} in index 1,3,5 and {5,4,2} in index {0,2,4}\\n\\nThe index mapping, (1 + 2*index) % (n | 1) combined with 'Color sort',  will do the job. \\n\\nAfter selecting the median element, which is 5 in this example, we continue as the following\\n\\n    Mapped_idx[Left] denotes the position where the next smaller-than median element  will be inserted.\\n    Mapped_idx[Right] denotes the position where the next larger-than median element  will be inserted.\\n\\n\\n    Step 1: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    5    5    4    2 \\n                 Left\\n                  i\\n                                          Right\\n     nums[Mapped_idx[i]] = nums[1] = 6 > 5, so it is ok to put 6 in the first odd index 1. We increment i and left.\\n\\n\\n    Step 2: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    5    5    4    2 \\n                      Left\\n                       i\\n                                          Right\\n     nums[3] = 5 = 5, so it is ok to put 6 in the index 3. We increment i.\\n\\n\\n    Step 3: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    5    5    4    2 \\n                      Left\\n                            i\\n                                         Right\\n     nums[5] = 2 < 5, so we want to put it to the last even index 4 (pointed by Right). So, we swap nums[Mapped_idx[i]] with nums[Mapped_idx[Right]], i.e. nums[5] with nums[4], and decrement Right. \\n\\n\\n\\n\\n    Step 4: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    5    5    2    4 \\n                      Left\\n                            i\\n                                   Right\\n     nums[5] = 4 < 5, so we want to put it to the second last even index 2. So, we swap nums[5] with nums[2], and decrement Right. \\n\\n\\n\\n\\n    Step 5: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    4    5    2    5 \\n                      Left\\n                            i\\n                                Right\\n     nums[5] = 5 < 5, it is ok to put it there, we increment i.\\n\\n\\n    Step 6: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    4    5    2    5 \\n                      Left\\n                                 i\\n                                Right\\n     nums[0] = 13 > 5, so, we want to put it to the next odd index which is 3 (pointed by 'Left'). So, we swap nums[0] with nums[3], and increment 'Left' and 'i'.\\n\\n\\n    Step Final: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        5    6    4    13   2    5 \\n                          Left\\n                                      i\\n                                Right\\n    i > Right, we get the final wiggle array 5 6 4 13 2 5 !\\n\\nThe code is the following:\\n\\n\\n\\n       public void wiggleSort(int[] nums) {\\n            int median = findKthLargest(nums, (nums.length + 1) / 2);\\n            int n = nums.length;\\n    \\n            int left = 0, i = 0, right = n - 1;\\n    \\n            while (i <= right) {\\n    \\n                if (nums[newIndex(i,n)] > median) {\\n                    swap(nums, newIndex(left++,n), newIndex(i++,n));\\n                }\\n                else if (nums[newIndex(i,n)] < median) {\\n                    swap(nums, newIndex(right--,n), newIndex(i,n));\\n                }\\n                else {\\n                    i++;\\n                }\\n            }\\n    \\n    \\n        }\\n    \\n        private int newIndex(int index, int n) {\\n            return (1 + 2*index) % (n | 1);\\n        }",
                "solutionTags": [],
                "code": "The virtual index idea in the post https://leetcode.com/discuss/77133/o-n-o-1-after-median-virtual-indexing\\nis very brilliant! However, it takes me a while to understand why and how it works. There is no 'nth_element' in Java, but you can use 'findKthLargest' function from \"https://leetcode.com/problems/kth-largest-element-in-an-array/\" to get the median element in average O(n) time and O(1) space.\\n\\n\\nAssume your original array is {6,13,5,4,5,2}. After you get median element, the 'nums' is partially sorted such that the first half is larger or equal to the median, the second half is smaller or equal to the median, i.e\\n\\n\\n    13   6   5   5   4   2\\n\\n             M\\nIn the post https://leetcode.com/discuss/76965/3-lines-python-with-explanation-proof, we have learned that , to get wiggle sort, you want to put the number in the following way such that\\n \\n(1) elements smaller than the 'median' are put into the last even slots\\n\\n(2) elements larger than the 'median' are put into the first odd slots\\n\\n(3) the  medians are put into the remaining slots.\\n\\n    Index :       0   1   2   3   4   5\\n    Small half:   M       S       S    \\n    Large half:       L       L       M\\n \\nM - Median, S-Small, L-Large. In this example, we want to put {13, 6, 5} in index 1,3,5 and {5,4,2} in index {0,2,4}\\n\\nThe index mapping, (1 + 2*index) % (n | 1) combined with 'Color sort',  will do the job. \\n\\nAfter selecting the median element, which is 5 in this example, we continue as the following\\n\\n    Mapped_idx[Left] denotes the position where the next smaller-than median element  will be inserted.\\n    Mapped_idx[Right] denotes the position where the next larger-than median element  will be inserted.\\n\\n\\n    Step 1: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    5    5    4    2 \\n                 Left\\n                  i\\n                                          Right\\n     nums[Mapped_idx[i]] = nums[1] = 6 > 5, so it is ok to put 6 in the first odd index 1. We increment i and left.\\n\\n\\n    Step 2: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    5    5    4    2 \\n                      Left\\n                       i\\n                                          Right\\n     nums[3] = 5 = 5, so it is ok to put 6 in the index 3. We increment i.\\n\\n\\n    Step 3: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    5    5    4    2 \\n                      Left\\n                            i\\n                                         Right\\n     nums[5] = 2 < 5, so we want to put it to the last even index 4 (pointed by Right). So, we swap nums[Mapped_idx[i]] with nums[Mapped_idx[Right]], i.e. nums[5] with nums[4], and decrement Right. \\n\\n\\n\\n\\n    Step 4: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    5    5    2    4 \\n                      Left\\n                            i\\n                                   Right\\n     nums[5] = 4 < 5, so we want to put it to the second last even index 2. So, we swap nums[5] with nums[2], and decrement Right. \\n\\n\\n\\n\\n    Step 5: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    4    5    2    5 \\n                      Left\\n                            i\\n                                Right\\n     nums[5] = 5 < 5, it is ok to put it there, we increment i.\\n\\n\\n    Step 6: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    4    5    2    5 \\n                      Left\\n                                 i\\n                                Right\\n     nums[0] = 13 > 5, so, we want to put it to the next odd index which is 3 (pointed by 'Left'). So, we swap nums[0] with nums[3], and increment 'Left' and 'i'.\\n\\n\\n    Step Final: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        5    6    4    13   2    5 \\n                          Left\\n                                      i\\n                                Right\\n    i > Right, we get the final wiggle array 5 6 4 13 2 5 !\\n\\nThe code is the following:\\n\\n\\n\\n       public void wiggleSort(int[] nums) {\\n            int median = findKthLargest(nums, (nums.length + 1) / 2);\\n            int n = nums.length;\\n    \\n            int left = 0, i = 0, right = n - 1;\\n    \\n            while (i <= right) {\\n    \\n                if (nums[newIndex(i,n)] > median) {\\n                    swap(nums, newIndex(left++,n), newIndex(i++,n));\\n                }\\n                else if (nums[newIndex(i,n)] < median) {\\n                    swap(nums, newIndex(right--,n), newIndex(i,n));\\n                }\\n                else {\\n                    i++;\\n                }\\n            }\\n    \\n    \\n        }\\n    \\n        private int newIndex(int index, int n) {\\n            return (1 + 2*index) % (n | 1);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 77684,
                "title": "summary-of-the-various-solutions-to-wiggle-sort-for-your-reference",
                "content": "This is a quick summary of all the solutions to this problem. Thanks to [stefanpochmann](https://discuss.leetcode.com/user/stefanpochmann), [shuoshankou](https://discuss.leetcode.com/user/shuoshankou) and others for their contributions.\\n\\n---\\n**`I -- Basic ideas`**\\n\\nSuppose the array is already \"wiggly-sorted\", we can divide the elements into two groups: \\n\\n* `odd group`: those collected from elements with **odd** indices\\n* `even group`: those collected from elements with **even** indices\\n\\nAnd from the property of \"wiggle-sort\", we know every element in the `odd group` will be greater than its neighbor(s). But note this is only a **local relation**, i.e., for any element from the `odd group`, except for its neighbor(s), we have no idea about the relationship between it and those from the `even group` which are not its neighbors.\\n\\nThis local relation makes it rather difficult to \"wiggly-sort\" all the elements from scratch. Fortunately there is a way to impose a **global relation** for elements in the two groups, specifically, for every \"wiggly-sorted\" array, it is possible to transform it into a new array such that every element in the `odd group` is **no less than** those in the `even group` while maintaining the \"wiggle-sort\" property. The proof is as follows.\\n\\nSuppose we have this element `a` from the `odd group` which are less than some element `b` from the `even group`, i.e., `a < b`. Let `c`, `d` be the two neighbors of `a`, and `e`, `f` be the two neighbors of `b`, from the \"wiggle-sort\" property, we have `c < a`, `d < a` and `b < e`, `b < f`. Now if we switch `a` and `b`, we still have `c < b`, `d < b` and `a < e`, `a < f`, therefore switching `a` and `b` won\\'t break the \"wiggle-sort\" property but will transfer the larger element to the `odd group`and the smaller element to the `even group`. After a finite sequence of switching, all elements in the `odd group` will be no less than those in the `even group` and we say the array has reached the **global relation** state (otherwise it\\'s in the **local relation** state).\\n\\nBuilding a \"wiggly-sorted\" array in the **global relation** state is much more tractable than its **local relation** state counterpart. And it can be done in two steps:\\n\\n* **Partition**: this will partition the array (with a total of `n` elements) into two groups which will be called `S` and `L`, respectively. The `S` group will have `m` (integer part of `(n+1)/2`) elements and the `L` group contains the rest. Also all elements in the `L` group is no less than those in the `S` group. (Note for this partition, `S` and `L` group will have the same number of elements as the `even group` and `odd group`, respectively. And the size of `L` group is no more than that of `S` group.)\\n\\n* **Placement**: if all elements in the `L` group is greater than those in the `S` group, we can simply place elements in the `L` group at odd indices (thus form the `odd group`) and those in the `S` group at even indices (form the `even group`). The tricky case is when there are overlapping (or equal) elements between the two groups, which will be dealt with as follows.\\n\\nFirst we prove that if the array can be \"wiggly-sorted\", the total number of such overlapping elements is no more than the size of the `S` group, which is `m`. Just assume we do have more such elements than `m`. After the array is \"wiggly-sorted\", all these elements can not be neighbors to each other (note they are equal). Therefore they will occupy either all the even indices or all the odd ones. However, even so we will still have residual such elements since the total number of even or odd indices is no more than `m`. And there is no way to place these excessive elements without breaking the \"wiggle-sort\" property.\\n\\nSecond we show that if we arrange these overlapping elements in such a way that they will occupy the smallest even indices possible if they come from the `S` group and will take the largest odd indices possible if they are from the `L` group, then none of them will be neighbors of others. Let `k1` and `k2` be the total number of such elements in the `S` and `L` groups, respectively, and `k = k1 + k2` is the total number of such elements in the array. First assume `n` is even, then we have `k <= m = n/2`. After the arrangement, the index of the last such element from `S` group will be `2 * (k1 - 1)` while the index of the last one from the `L` group will be `(n - 1) - 2 * (k2 - 1)`. If the former index is less than the latter by at least `1`, then none of the elements will be neighbors of others, which is indeed the case:  `2 * (k1 - 1) + 1 < (n - 1) - 2 * (k2 - 1)  <==> k1 + k2 < [n/2] + 1` and `k1 + k2 = k <= n/2 = [n/2] < [n/2] + 1`. Now assume `n` is odd. If `k = (n + 1)/2`, then the array can be \"wiggly-sorted\"only if `k2 = 0`, i.e., all such elements are in the `S` group and will take all the even indices. Else we have `k1 + k2 = k < (n + 1)/2 = [n/2] + 1`. In either case, our arrangement will scatter the overlapping elements in such a way that none of them will be neighbors of others. \\n\\nOnce the overlapping elements are placed according to the above rules, all the other elements in `S` and `L` groups are free to take any of the remaining available even and odd indices, respectively. And we end up with a \"wiggly-sorted\" array that is in the \"global relation\" state.\\n\\n---\\n**`II -- O(nlogn) time and O(n) space solution by sorting`**\\n\\nThe naive way to partition the array into `L` and `S` groups is by sorting. Here we can sort the elements in either ascending or descending order. For either case, we need to figure out the index mapping rules for the **placement** part. Let `i` be the index of an element before placement and `j` the index after, for ascending order, we have: \\n`j = 2 * (m - 1 - i)` if `i < m` \\n`j = 2 * (n - 1 - i) + 1` if `i >= m`\\nfor descending order, the mapping rule can be combined into one expression:\\n`j =  (2 * i + 1) % (n | 1)`.\\n\\nTo avoid confusion for the index mapping process, we will use an auxiliary array serving as the array before index mapping and the input array as the array after index mapping. Here is the java program for ascending order:\\n```\\npublic void wiggleSort(int[] nums) {\\n    int n = nums.length, m = (n + 1) >> 1;\\n    int[] copy = Arrays.copyOf(nums, n);\\n    Arrays.sort(copy);\\n    \\n    for (int i = m - 1, j = 0; i >= 0; i--, j += 2) nums[j] = copy[i];\\n    for (int i = n - 1, j = 1; i >= m; i--, j += 2) nums[j] = copy[i];\\n}\\n```\\n\\n---\\n**`III -- O(n) time and O(n) space solution by median partition`**\\n\\nSorting the whole array is overkill for the **partition** part, since all we need are the `S` and `L` groups. As for elements within each group, we don\\'t really care whether they are sorted or not. Suppose `m_ele` is the `m-th` smallest element in the array. We partition the array such that all elements less than `m_ele` go to its left and those greater than it end up in its right (or the other way around). After partition, the first `m` elements will form the `S` group while the rest will be the `L` group. To get the `m-th` smallest element, we will use the randomized quick-sort subroutine (refer to problem [leetcode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/) for more details). All the three parts (obtaining the `m-th` smallest element, partition and placement) can be done in `O(n)` time, therefore the total time complexity will be `O(n)`. And again we will use an extra array to simplify the index mapping process. Here is the java code:\\n```\\npublic void wiggleSort(int[] nums) {\\n    int n = nums.length, m = (n + 1) >> 1;\\n    int[] copy = Arrays.copyOf(nums, n);\\n    int median = kthSmallestNumber(nums, m);\\n    \\n    for (int i = 0, j = 0, k = n - 1; j <= k;) {\\n        if (copy[j] < median) {\\n            swap(copy, i++, j++);\\n        } else if (copy[j] > median) {\\n            swap(copy, j, k--);\\n        } else {\\n            j++;\\n        }\\n    }\\n        \\n    for (int i = m - 1, j = 0; i >= 0; i--, j += 2) nums[j] = copy[i];\\n    for (int i = n - 1, j = 1; i >= m; i--, j += 2) nums[j] = copy[i];\\n}\\n\\nprivate int kthSmallestNumber(int[] nums, int k) {\\n    Random random = new Random();\\n    \\n    for (int i = nums.length - 1; i >= 0; i--) {\\n        swap(nums, i, random.nextInt(i + 1));\\n    }\\n    \\n    int l = 0, r = nums.length - 1;\\n    k--;\\n        \\n    while (l < r) {\\n        int m = getMiddle(nums, l, r);\\n        \\n        if (m < k) {\\n            l = m + 1;\\n        } else if (m > k) {\\n            r = m - 1;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n    return nums[k];\\n}\\n    \\nprivate int getMiddle(int[] nums, int l, int r) {\\n    int i = l;\\n    \\n    for (int j = l + 1; j <= r; j++) {\\n        if (nums[j] < nums[l]) swap(nums, ++i, j);\\n    }\\n    \\n    swap(nums, l, i);\\n    return i;\\n}\\n\\nprivate void swap(int[] nums, int i, int j) {\\n    int t = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = t;\\n}\\n```\\n\\n---\\n**`IV -- O(n) time and O(1) space solution by combining partition and placement`**\\n\\nTo have `O(1)` space, we have to drop the extra array. Then both the partition and placement will be done on the input array itself. If these two parts are carried out separately, i.e., placement is done after partition is completely finished, there will be no nice way to do the index mapping without keeping track of mapped and unmapped elements (as far as I know). It turns out the two parts can be combined into a single one. \\n\\nTo see how, let\\'s examine the whole partition and placement process more carefully.  For partition, its core function is to subject each element in the array to the partition rule (i.e., compared with `median`) **exactly once** and distribute the element to the proper position based on the comparison result. Traditionally we will add it to either the left or right half of the array and deal with it later after the partition is over. This is of course unnecessary. The element should be ready for consumption (do whatever you like with it) once the distribution for it is over. We might as well map it to a new position according to the above placement rule (for example, `j =  (2 * i + 1) % (n | 1)` for descending order),  right before going to the next element. The traditional way of disposing the elements corresponds to the identity mapping (i.e., `j = i`).\\n\\nOne important issue here for the index mapping is the order for traversing the array in the partition process. The traditional way of linear scan from left to right works well with the identity mapping, but obviously will violate the constraint that each element will be partitioned **exactly once** if the mapping takes the partitioned element to the unscanned area. The correct traversing order typically depends on the mapping we want to do. Here I prove that the partition constraint will not be violated if the mapping is **bijective** and the traversing order follows that of the linear scan but with the same mapping applied at each position.\\n\\nEach mapping `f` will be characterized by three parts: domain, codomain and mapping rules. For our case, both the domain and codomain will be the set `S = [0, n)` (i.e., integers from `0` up to `n - 1`). If `f` is bijective, we have:\\n1. for any `i1, i2` that belong to `S`, `i1 != i2 <==> f(i1) != f(i2)`.\\n2. if `i` covers all the elements in `S` exactly once, `f(i)` will do the same.\\n\\nIf our traversing order follows that of the linear scan with `f` applied for each position `i` in the linear scan, the first property will guarantee each element will be visited at most once while the second will guarantee each element be visited at least once. Therefore, at the end each element will be visited **exactly once**.\\n\\nBy the way, this index mapping idea is called \"virtual index\" in [stefanpochmann\\'s post](https://discuss.leetcode.com/topic/32929/o-n-o-1-after-median-virtual-indexing/5) and further explained in [shuoshankou\\'s post](https://discuss.leetcode.com/topic/41464/step-by-step-explanation-of-index-mapping-in-java). I will follow the same notation for the index mapping function (which is called `A` here). We can do different mappings as needed. The following implementation is for descending order. And just for fun, a rotation mapping `j = (i + k) % n` will rotate the resulted array after partition, check it out! Anyway, here is the java code:\\n\\n```\\npublic void wiggleSort(int[] nums) {\\n    int n = nums.length, m = (n + 1) >> 1;\\n    int median = kthSmallestNumber(nums, m);\\n    \\n    for (int i = 0, j = 0, k = n - 1; j <= k;) {\\n        if (nums[A(j, n)] > median) {\\n            swap(nums, A(i++, n), A(j++, n));\\n        } else if (nums[A(j, n)] < median) {\\n            swap(nums, A(j, n), A(k--, n));\\n        } else {\\n            j++;\\n        }\\n    }\\n}\\n\\nprivate int A(int i, int n) {\\n    return (2 * i + 1) % (n | 1);\\n}\\n```\\n(Note: `kthSmallestNumber` are defined in part III)",
                "solutionTags": [],
                "code": "```\\npublic void wiggleSort(int[] nums) {\\n    int n = nums.length, m = (n + 1) >> 1;\\n    int[] copy = Arrays.copyOf(nums, n);\\n    Arrays.sort(copy);\\n    \\n    for (int i = m - 1, j = 0; i >= 0; i--, j += 2) nums[j] = copy[i];\\n    for (int i = n - 1, j = 1; i >= m; i--, j += 2) nums[j] = copy[i];\\n}\\n```\n```\\npublic void wiggleSort(int[] nums) {\\n    int n = nums.length, m = (n + 1) >> 1;\\n    int[] copy = Arrays.copyOf(nums, n);\\n    int median = kthSmallestNumber(nums, m);\\n    \\n    for (int i = 0, j = 0, k = n - 1; j <= k;) {\\n        if (copy[j] < median) {\\n            swap(copy, i++, j++);\\n        } else if (copy[j] > median) {\\n            swap(copy, j, k--);\\n        } else {\\n            j++;\\n        }\\n    }\\n        \\n    for (int i = m - 1, j = 0; i >= 0; i--, j += 2) nums[j] = copy[i];\\n    for (int i = n - 1, j = 1; i >= m; i--, j += 2) nums[j] = copy[i];\\n}\\n\\nprivate int kthSmallestNumber(int[] nums, int k) {\\n    Random random = new Random();\\n    \\n    for (int i = nums.length - 1; i >= 0; i--) {\\n        swap(nums, i, random.nextInt(i + 1));\\n    }\\n    \\n    int l = 0, r = nums.length - 1;\\n    k--;\\n        \\n    while (l < r) {\\n        int m = getMiddle(nums, l, r);\\n        \\n        if (m < k) {\\n            l = m + 1;\\n        } else if (m > k) {\\n            r = m - 1;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n    return nums[k];\\n}\\n    \\nprivate int getMiddle(int[] nums, int l, int r) {\\n    int i = l;\\n    \\n    for (int j = l + 1; j <= r; j++) {\\n        if (nums[j] < nums[l]) swap(nums, ++i, j);\\n    }\\n    \\n    swap(nums, l, i);\\n    return i;\\n}\\n\\nprivate void swap(int[] nums, int i, int j) {\\n    int t = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = t;\\n}\\n```\n```\\npublic void wiggleSort(int[] nums) {\\n    int n = nums.length, m = (n + 1) >> 1;\\n    int median = kthSmallestNumber(nums, m);\\n    \\n    for (int i = 0, j = 0, k = n - 1; j <= k;) {\\n        if (nums[A(j, n)] > median) {\\n            swap(nums, A(i++, n), A(j++, n));\\n        } else if (nums[A(j, n)] < median) {\\n            swap(nums, A(j, n), A(k--, n));\\n        } else {\\n            j++;\\n        }\\n    }\\n}\\n\\nprivate int A(int i, int n) {\\n    return (2 * i + 1) % (n | 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 77678,
                "title": "3-lines-python-with-explanation-proof",
                "content": "Solution\\n---\\n\\nRoughly speaking I put the smaller half of the numbers on the even indexes and the larger half on the odd indexes.\\n\\n    def wiggleSort(self, nums):\\n        nums.sort()\\n        half = len(nums[::2])\\n        nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]\\n\\nAlternative, maybe nicer, maybe not:\\n\\n    def wiggleSort(self, nums):\\n        nums.sort()\\n        half = len(nums[::2]) - 1\\n        nums[::2], nums[1::2] = nums[half::-1], nums[:half:-1]\\n\\n---\\n\\n**Explanation / Proof**\\n---\\n\\nI put the smaller half of the numbers on the even indexes and the larger half on the odd indexes, both from right to left:\\n\\n    Example nums = [1,2,...,7]      Example nums = [1,2,...,8] \\n\\n    Small half:  4 . 3 . 2 . 1      Small half:  4 . 3 . 2 . 1 .\\n    Large half:  . 7 . 6 . 5 .      Large half:  . 8 . 7 . 6 . 5\\n    --------------------------      --------------------------\\n    Together:    4 7 3 6 2 5 1      Together:    4 8 3 7 2 6 1 5\\n\\nI want:\\n\\n- Odd-index numbers are larger than their neighbors.\\n\\nSince I put the larger numbers on the odd indexes, clearly I already have:\\n\\n- Odd-index numbers are larger than **or equal to** their neighbors.\\n\\nCould they be \"equal to\"? That would require some number M to appear both in the smaller and the larger half. It would be the largest in the smaller half and the smallest in the larger half. Examples again, where S means some number smaller than M and L means some number larger than M.\\n\\n    Small half:  M . S . S . S      Small half:  M . S . S . S .\\n    Large half:  . L . L . M .      Large half:  . L . L . L . M\\n    --------------------------      --------------------------\\n    Together:    M L S L S M S      Together:    M L S L S L S M\\n\\nYou can see the two M are quite far apart. Of course M could appear more than just twice, for example:\\n\\n    Small half:  M . M . S . S      Small half:  M . S . S . S .\\n    Large half:  . L . L . M .      Large half:  . L . M . M . M\\n    --------------------------      --------------------------\\n    Together:    M L M L S M S      Together:    M L S M S M S M\\n\\nYou can see that with seven numbers, three M are no problem. And with eight numbers, four M are no problem. Should be easy to see that in general, with n numbers, floor(n/2) times M is no problem. Now, if there were more M than that, then my method would fail. But... it would also be impossible:\\n\\n- If n is even, then having more than n/2 times the same number clearly is unsolvable, because you'd have to put two of them next to each other, no matter how you arrange them.\\n- If n is odd, then the only way to successfully arrange a number appearing more than floor(n/2) times is if it appears exactly floor(n/2)+1 times and you put them on all the even indexes. And to have the wiggle-property, all the other numbers would have to be larger. But then we wouldn't have an M in both the smaller and the larger half.\\n\\nSo if the input has a valid answer at all, then my code will find one.",
                "solutionTags": [
                    "Python"
                ],
                "code": "Solution\\n---\\n\\nRoughly speaking I put the smaller half of the numbers on the even indexes and the larger half on the odd indexes.\\n\\n    def wiggleSort(self, nums):\\n        nums.sort()\\n        half = len(nums[::2])\\n        nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]\\n\\nAlternative, maybe nicer, maybe not:\\n\\n    def wiggleSort(self, nums):\\n        nums.sort()\\n        half = len(nums[::2]) - 1\\n        nums[::2], nums[1::2] = nums[half::-1], nums[:half:-1]\\n\\n---\\n\\n**Explanation / Proof**\\n---\\n\\nI put the smaller half of the numbers on the even indexes and the larger half on the odd indexes, both from right to left:\\n\\n    Example nums = [1,2,...,7]      Example nums = [1,2,...,8] \\n\\n    Small half:  4 . 3 . 2 . 1      Small half:  4 . 3 . 2 . 1 .\\n    Large half:  . 7 . 6 . 5 .      Large half:  . 8 . 7 . 6 . 5\\n    --------------------------      --------------------------\\n    Together:    4 7 3 6 2 5 1      Together:    4 8 3 7 2 6 1 5\\n\\nI want:\\n\\n- Odd-index numbers are larger than their neighbors.\\n\\nSince I put the larger numbers on the odd indexes, clearly I already have:\\n\\n- Odd-index numbers are larger than **or equal to** their neighbors.\\n\\nCould they be \"equal to\"? That would require some number M to appear both in the smaller and the larger half. It would be the largest in the smaller half and the smallest in the larger half. Examples again, where S means some number smaller than M and L means some number larger than M.\\n\\n    Small half:  M . S . S . S      Small half:  M . S . S . S .\\n    Large half:  . L . L . M .      Large half:  . L . L . L . M\\n    --------------------------      --------------------------\\n    Together:    M L S L S M S      Together:    M L S L S L S M\\n\\nYou can see the two M are quite far apart. Of course M could appear more than just twice, for example:\\n\\n    Small half:  M . M . S . S      Small half:  M . S . S . S .\\n    Large half:  . L . L . M .      Large half:  . L . M . M . M\\n    --------------------------      --------------------------\\n    Together:    M L M L S M S      Together:    M L S M S M S M\\n\\nYou can see that with seven numbers, three M are no problem. And with eight numbers, four M are no problem. Should be easy to see that in general, with n numbers, floor(n/2) times M is no problem. Now, if there were more M than that, then my method would fail. But... it would also be impossible:\\n\\n- If n is even, then having more than n/2 times the same number clearly is unsolvable, because you'd have to put two of them next to each other, no matter how you arrange them.\\n- If n is odd, then the only way to successfully arrange a number appearing more than floor(n/2) times is if it appears exactly floor(n/2)+1 times and you put them on all the even indexes. And to have the wiggle-property, all the other numbers would have to be larger. But then we wouldn't have an M in both the smaller and the larger half.\\n\\nSo if the input has a valid answer at all, then my code will find one.",
                "codeTag": "Python3"
            },
            {
                "id": 77681,
                "title": "o-n-time-o-1-space-solution-with-detail-explanations",
                "content": "**Methodology:**\\n\\n**Idea 1.**\\n\\nAs **@whnzinc** pointed out in [this thread](https://leetcode.com/discuss/77085/clean-average-o-n-time-in-c), all elements in nums can be classified into three categories:\\n\\n(1) Larger than the median;\\n\\n(2) Equal to the median;\\n\\n(3) Smaller than the median.\\n\\nNote that it's possible to find the median within O(n)-time and O(1)-space.\\n\\nNote: We can use `nth_element` to find the median, but it's not O(n)-time and O(1)-space. For the sake of simplicity, I might use `nth_element` as well.\\n\\n**Idea 2.** \\n\\nAs **@StefanPochmann** pointed out in [this thread](https://leetcode.com/discuss/76965/3-lines-python-with-explanation-proof), we can arrange the elements in the three categories in a deterministic way.\\n\\n(1) Elements that are larger than the median: we can put them in the first few odd slots;\\n\\n(2) Elements that are smaller than the median: we can put them in the last few even slots;\\n\\n(3) Elements that equal the median: we can put them in the remaining slots.\\n\\n**Update:** According to [**@StefanPochmann**'s thread](https://leetcode.com/discuss/77133/o-n-o-1-after-median-virtual-indexing), we can use a one-pass three-way partition to rearrange all elements. His idea is to re-map the indices into its destined indices, odd indices first and even indices follow.\\n\\nExample:\\n\\n    Original Indices:    0  1  2  3  4  5  6  7  8  9 10 11\\n    Mapped Indices:      1  3  5  7  9 11  0  2  4  6  8 10\\n\\n(its reverse mapping is)\\n\\n    Mapped Indices:      0  1  2  3  4  5  6  7  8  9 10 11\\n    Original Indices:    6  0  7  1  8  2  9  3 10  4 11  5   (wiggled)\\n\\n\\nIn order to achieve this, we can use a function alike\\n\\n    int map_index(int idx, int n) {\\n        return (2 * idx + 1) % (n | 1);\\n    }\\n\\nwhere `(n | 1)` calculates the nearest odd that is not less than `n`.\\n\\n--------\\n\\n**Complexities:** (On the condition that finding median is O(n)-time and O(1)-space)\\n\\n- Time: *O*(n)\\n\\n- Space: *O*(1)\\n\\n--------\\n\\n**C++ (Updated, 44ms):**\\n\\n\\n    class Solution {\\n    public:\\n    \\tvoid wiggleSort(vector<int>& nums) {\\n    \\t\\tif (nums.empty()) {\\n    \\t\\t\\treturn;\\n    \\t\\t}    \\n    \\t\\tint n = nums.size();\\n    \\t\\t\\n    \\t\\t// Step 1: Find the median    \\t\\t\\n    \\t\\tvector<int>::iterator nth = next(nums.begin(), n / 2);\\n    \\t\\tnth_element(nums.begin(), nth, nums.end());\\n    \\t\\tint median = *nth;\\n    \\n    \\t\\t// Step 2: Tripartie partition within O(n)-time & O(1)-space.    \\t\\t\\n    \\t\\tauto m = [n](int idx) { return (2 * idx + 1) % (n | 1); };    \\t\\t\\n    \\t\\tint first = 0, mid = 0, last = n - 1;\\n    \\t\\twhile (mid <= last) {\\n    \\t\\t\\tif (nums[m(mid)] > median) {\\n    \\t\\t\\t\\tswap(nums[m(first)], nums[m(mid)]);\\n    \\t\\t\\t\\t++first;\\n    \\t\\t\\t\\t++mid;\\n    \\t\\t\\t}\\n    \\t\\t\\telse if (nums[m(mid)] < median) {\\n    \\t\\t\\t\\tswap(nums[m(mid)], nums[m(last)]);\\n    \\t\\t\\t\\t--last;\\n    \\t\\t\\t}\\t\\t\\t\\t\\n    \\t\\t\\telse {\\n    \\t\\t\\t\\t++mid;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}    \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvoid wiggleSort(vector<int>& nums) {\\n    \\t\\tif (nums.empty()) {\\n    \\t\\t\\treturn;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 77688,
                "title": "o-n-o-1-after-median-without-virtual-indexing",
                "content": "The idea is the same as the [three-way partitioning](https://en.wikipedia.org/wiki/Dutch_national_flag_problem#Pseudocode), but don't use the [virtual indexing](https://discuss.leetcode.com/topic/32929/o-n-o-1-after-median-virtual-indexing) \\n\\nI don't think I can figure out the tricky [Index-rewiring] during interview, so come up my own way to do the three-way partitioning.\\n\\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return;\\n    \\n        // Find a median.\\n        auto midptr = nums.begin() + n / 2;\\n        nth_element(nums.begin(), midptr, nums.end());\\n        int mid = *midptr;\\n        \\n        int i = (n - 1) / 2 * 2, j = i, k = 1;\\n        for (int c = 0; c < n; ++c) {\\n            if (nums[j] < mid) {\\n                swap(nums[i], nums[j]);\\n                i -= 2;\\n                j -= 2;\\n                if (j < 0) j = n / 2 * 2 - 1;\\n            } else if (nums[j] > mid) {\\n                swap(nums[j], nums[k]);\\n                k += 2;\\n            } else {\\n                j -= 2;\\n                if (j < 0) j = n / 2 * 2 - 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return;\\n    \\n        // Find a median.\\n        auto midptr = nums.begin() + n / 2;\\n        nth_element(nums.begin(), midptr, nums.end());\\n        int mid = *midptr;\\n        \\n        int i = (n - 1) / 2 * 2, j = i, k = 1;\\n        for (int c = 0; c < n; ++c) {\\n            if (nums[j] < mid) {\\n                swap(nums[i], nums[j]);\\n                i -= 2;\\n                j -= 2;\\n                if (j < 0) j = n / 2 * 2 - 1;\\n            } else if (nums[j] > mid) {\\n                swap(nums[j], nums[k]);\\n                k += 2;\\n            } else {\\n                j -= 2;\\n                if (j < 0) j = n / 2 * 2 - 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77706,
                "title": "short-simple-c",
                "content": "    void wiggleSort(vector<int>& nums) {\\n        vector<int> sorted(nums);\\n        sort(sorted.begin(), sorted.end());\\n        for (int i=nums.size()-1, j=0, k=i/2+1; i>=0; i--)\\n            nums[i] = sorted[i&1 ? k++ : j++];\\n    }\\n\\nSort and then write the smaller half of the numbers on the even indexes and the larger half of the numbers on the odd indexes, both from the back. Example:\\n\\n    Small half:    4 . 3 . 2 . 1 . 0 .\\n    Large half:    . 9 . 8 . 7 . 6 . 5\\n    ----------------------------------\\n    Together:      4 9 3 8 2 7 1 6 0 5\\n\\nSo write `nums` from the back, interweaving `sorted[0..4]` (indexed by `j`) and `sorted[5..9]` (indexed by `k`).\\n\\nFor more explanation/proof, see [my equivalent Python solution](https://leetcode.com/discuss/76965/3-lines-python-with-explanation-proof).",
                "solutionTags": [
                    "C++"
                ],
                "code": "    void wiggleSort(vector<int>& nums) {\\n        vector<int> sorted(nums);\\n        sort(sorted.begin(), sorted.end());\\n        for (int i=nums.size()-1, j=0, k=i/2+1; i>=0; i--)\\n            nums[i] = sorted[i&1 ? k++ : j++];\\n    }\\n\\nSort and then write the smaller half of the numbers on the even indexes and the larger half of the numbers on the odd indexes, both from the back. Example:\\n\\n    Small half:    4 . 3 . 2 . 1 . 0 .\\n    Large half:    . 9 . 8 . 7 . 6 . 5\\n    ----------------------------------\\n    Together:      4 9 3 8 2 7 1 6 0 5\\n\\nSo write `nums` from the back, interweaving `sorted[0..4]` (indexed by `j`) and `sorted[5..9]` (indexed by `k`).\\n\\nFor more explanation/proof, see [my equivalent Python solution](https://leetcode.com/discuss/76965/3-lines-python-with-explanation-proof).",
                "codeTag": "Unknown"
            },
            {
                "id": 155764,
                "title": "python-3-lines-simplest-solution-for-everyone-to-understand",
                "content": "Downside is it is O(n*logn) and O(N) space but it is the simplest solution. \\n* Just put sorted numbers in array\\n* Put largest numbers in odd indexes first\\n* Then put remaining numbers in even indexes\\n* So even < odd > even\\n```\\nclass Solution:\\n    def wiggleSort(self, nums):\\n        arr = sorted(nums)\\n        for i in range(1, len(nums), 2): nums[i] = arr.pop() \\n        for i in range(0, len(nums), 2): nums[i] = arr.pop() \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wiggleSort(self, nums):\\n        arr = sorted(nums)\\n        for i in range(1, len(nums), 2): nums[i] = arr.pop() \\n        for i in range(0, len(nums), 2): nums[i] = arr.pop() \\n```",
                "codeTag": "Java"
            },
            {
                "id": 333079,
                "title": "python-deterministic-o-n-time-o-1-memory-quick-select-median-of-medians",
                "content": "Basic idea: we find median value, put numbers bigger than median into odd index,  smaller than median into even index. \\nNaive solution: \\n1. Sort the array to find median in O(nlgn) time + O(1) space\\n2. Move odd and even index numbers into temp array and move them back to the original array with new index. Taking O(n) time + O(n) space.\\nTotal: O(nlgn) time + O(n) space\\n\\nIn order to achieve O(n) time + O(1) space, we need to answer two questions:\\n1. How to find median in O(n)+O(1)\\n2. How to re-order the odd-even indexes \"in-place\" using O(1) memory.\\n\\nThree knowledge pre-requisitions:\\n1. Quick select to find median in O(n) time on average, O(n^2) in worst case. Taking O(1) memory.\\n2. \"Median of medians\" alogrithm to improve quick select, making the time complexity \"deterministic O(n)\" rather than \"average O(n)\".\\n3. Virtual indexing technology to achieve in-place wiggle sort based on median value found above.\\n\\nThere is \"median of medians + quick select\" methods provided out of the box in all languages. You have to write it yourself.\\nThis problem deserve to be of \"Hard\" difficulty rather than \"Medium\" for the O(n)+O(1) solution, considering so many technologies involved.\\n\\n*************************************************************\\n**Virtual index:**\\nThis is actually a \"Three color Sort\" problem. Imagine scanning the nums this way: \"1,3,5,7,9, ... 0,2,4,6,8,10...\". During the scan, when you see a big number, put it to \"left\", a small number, put it to \"right\", in the end, you will see all big numbers on left, all small numbers on right, and all median numbers in the middle. \\nBut wait, here \"left\" and \"right\" are actually the left and right of \"1,3,5,7...0,2,4,6,8,...\" indexes, not the left and right of \"0,1,2,3,4,5...\", because you are scanning in \"1,3,5,7...0,2,4,6,8,...\" order. So what you actually see is all big numbers on odd index, all small numbers on even index, all median numbers distributed on the left and right side of the array. And this kind of distribution is guaranteed to be wiggled sorted.\\n\\n\\n*************************************************************\\n**Code:**\\nI use random pivot for quick select rather than \"median of medians\", which is much easier to implement and has average O(n) for all kind of input pattern.\\nPlease be noted that you cannot use recursion in the fast select part, otherwise the space complexity won\\'t be real O(1).\\n```\\nimport random\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        def nsmallest(nums,n):            \\n            start,end=0,len(nums)-1\\n            while True:\\n                pivot=nums[random.randint(start,end)]\\n                i,j,k=start,end,start\\n                while k<=j:\\n                    if nums[k]<pivot:\\n                        nums[i],nums[k]=nums[k],nums[i]\\n                        i+=1\\n                        k+=1\\n                    elif nums[k]>pivot:\\n                        nums[j],nums[k]=nums[k],nums[j]\\n                        j-=1\\n                    else:\\n                        k+=1\\n                if i<=n-1<=j:\\n                    return pivot\\n                elif n-1<i:\\n                    end=i-1\\n                else:\\n                    start=i+1\\n        n=len(nums)\\n        mid=nsmallest(nums,(n+1)//2)\\n        mapIdx=lambda i:(1+2*i)%(n|1)\\n        i,j,k=0,n-1,0\\n        while k<=j:\\n            if nums[mapIdx(k)]>mid:\\n                nums[mapIdx(k)],nums[mapIdx(i)]=nums[mapIdx(i)],nums[mapIdx(k)]\\n                i+=1\\n                k+=1\\n            elif nums[mapIdx(k)]<mid:\\n                nums[mapIdx(k)],nums[mapIdx(j)]=nums[mapIdx(j)],nums[mapIdx(k)]\\n                j-=1\\n            else:\\n                k+=1\\n```\\n",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        def nsmallest(nums,n):            \\n            start,end=0,len(nums)-1\\n            while True:\\n                pivot=nums[random.randint(start,end)]\\n                i,j,k=start,end,start\\n                while k<=j:\\n                    if nums[k]<pivot:\\n                        nums[i],nums[k]=nums[k],nums[i]\\n                        i+=1\\n                        k+=1\\n                    elif nums[k]>pivot:\\n                        nums[j],nums[k]=nums[k],nums[j]\\n                        j-=1\\n                    else:\\n                        k+=1\\n                if i<=n-1<=j:\\n                    return pivot\\n                elif n-1<i:\\n                    end=i-1\\n                else:\\n                    start=i+1\\n        n=len(nums)\\n        mid=nsmallest(nums,(n+1)//2)\\n        mapIdx=lambda i:(1+2*i)%(n|1)\\n        i,j,k=0,n-1,0\\n        while k<=j:\\n            if nums[mapIdx(k)]>mid:\\n                nums[mapIdx(k)],nums[mapIdx(i)]=nums[mapIdx(i)],nums[mapIdx(k)]\\n                i+=1\\n                k+=1\\n            elif nums[mapIdx(k)]<mid:\\n                nums[mapIdx(k)],nums[mapIdx(j)]=nums[mapIdx(j)],nums[mapIdx(k)]\\n                j-=1\\n            else:\\n                k+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755415,
                "title": "o-n-o-1-after-median-no-indexing-required",
                "content": "Since most of the topvoted posts use virtual indexing/three-way-partitioning, I decided to solve the question without it. I didn\\'t think I could come up with it in an interview so I wanted something more intuitive.\\n\\nThe idea is as follows : \\n1. Find the median using quickselect. ( **O(n**) average time)\\n2. Larger numbers than the median can be filled on odd positions starting from the beginning.\\n3. Smaller numbers than the median can be filled on even positions from the end.\\n\\nWhy can\\'t both larger and smaller numbers be filled from the beginning or end? It\\'s because when there are duplicate median elements they will be adjacent to each other in some cases.\\ne.g  \\n[2, 3, 5, 5, 5, 6]  with median **5** outputs:\\n[2, 6, 3, 5, 5, 5] when filled from the beginning.\\n[5, 5, 3, 5, 2, 6] when filled from the end.\\n\\nWe just try to maintain two variables - one from the end **(smallPos)**, one from the start **(largePos)** while traversing the nums array.\\n1. If the current element is smaller than median, we check if it\\'s an **already visited** even position (We decided above that smaller numbers will be placed on even positions). If not, we swap the current element with the smallPos indexed element.\\n2. We similary check for elements larger than median, only difference being that we check if it\\'s at an **already visited** odd position\\n\\n```\\npublic void wiggleSort(int[] nums) {\\n     \\n        int len = nums.length;\\n        if(len==1 || len==0)return;\\n        \\n        int mid = findKthSmall(nums, (len-1)/2); //median\\n        int largePos = 1; //Odd position from start for larger than median numbers\\n        int smallPos = len%2==0 ? len-2: len-1; //Even position from end for smaller than median numbers\\n        int cur = 0;\\n        while(cur<len) {\\n\\t\\t\\t//Avoiding already checked even positions from the end\\n            if(nums[cur]<mid && (cur<smallPos || (cur>=smallPos && cur%2!=0))) {\\n                swap(nums, cur, smallPos);\\n                smallPos-=2;\\n            }\\n\\t\\t\\t//Avoiding already checked odd positions from the start\\n            else if(nums[cur]>mid && (largePos<cur || (largePos>=cur && cur%2==0))) {\\n                swap(nums, cur, largePos);\\n                largePos+=2;\\n            }\\n            \\n            else cur++;\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void wiggleSort(int[] nums) {\\n     \\n        int len = nums.length;\\n        if(len==1 || len==0)return;\\n        \\n        int mid = findKthSmall(nums, (len-1)/2); //median\\n        int largePos = 1; //Odd position from start for larger than median numbers\\n        int smallPos = len%2==0 ? len-2: len-1; //Even position from end for smaller than median numbers\\n        int cur = 0;\\n        while(cur<len) {\\n\\t\\t\\t//Avoiding already checked even positions from the end\\n            if(nums[cur]<mid && (cur<smallPos || (cur>=smallPos && cur%2!=0))) {\\n                swap(nums, cur, smallPos);\\n                smallPos-=2;\\n            }\\n\\t\\t\\t//Avoiding already checked odd positions from the start\\n            else if(nums[cur]>mid && (largePos<cur || (largePos>=cur && cur%2==0))) {\\n                swap(nums, cur, largePos);\\n                largePos+=2;\\n            }\\n            \\n            else cur++;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840002,
                "title": "c-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n= nums.size();\\n        priority_queue<int> q(nums.begin(), nums.end());\\n        for(int i=1; i<n; i += 2){\\n            nums[i] = q.top();\\n            q.pop();\\n        }\\n        for(int i=0; i<n; i += 2){\\n            nums[i] = q.top();\\n            q.pop();\\n        }\\n    }\\n};\\n//Please upvote me if you like the solution.\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n= nums.size();\\n        priority_queue<int> q(nums.begin(), nums.end());\\n        for(int i=1; i<n; i += 2){\\n            nums[i] = q.top();\\n            q.pop();\\n        }\\n        for(int i=0; i<n; i += 2){\\n            nums[i] = q.top();\\n            q.pop();\\n        }\\n    }\\n};\\n//Please upvote me if you like the solution.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215445,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n       int n=nums.length-1;\\n        //copy values to new array\\n       int[] newarr=Arrays.copyOf(nums,nums.length);\\n        //sort new array\\n       Arrays.sort(newarr);\\n        //old arr=1,5,1,1,6,4\\n        //new arr=1,1,1,4,5,6\\n        //now lets apply odd position and even position\\n        //odd position\\n        for(int i=1;i<nums.length;i+=2)\\n            nums[i]=newarr[n--];\\n        //even position\\n        for(int i=0;i<nums.length;i+=2)\\n            nums[i]=newarr[n--];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n       int n=nums.length-1;\\n        //copy values to new array\\n       int[] newarr=Arrays.copyOf(nums,nums.length);\\n        //sort new array\\n       Arrays.sort(newarr);\\n        //old arr=1,5,1,1,6,4\\n        //new arr=1,1,1,4,5,6\\n        //now lets apply odd position and even position\\n        //odd position\\n        for(int i=1;i<nums.length;i+=2)\\n            nums[i]=newarr[n--];\\n        //even position\\n        for(int i=0;i<nums.length;i+=2)\\n            nums[i]=newarr[n--];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234290,
                "title": "c-76-ms-100-solution-using-quick-select-and-virtual-index-w-explanation",
                "content": "I think this problem should be classified as \"hard\" instead of medium. It took me a good 2 hours to get the solution. The problem is split into three parts: figuring out how to solve the problem, implementing quick select, and implementing virtual indexing.\\n\\n**Part 1: Solving the problem**\\n\\nBased on the problem definition of wiggle, we know that we want the vector where all elements in even indices must be less than the neighboring odd indices. Thus, we must split the vector into two subsets, where one set is the elements in the even indices, and the other in the odd indices.\\n\\nThe only way to \"guarantee\" that when combined together, every odd indices is greater than the two neighboring even indices is to take the greatest half the vector as the odd indices subset. If every element in the odd subset is greater than every element in the even subset, then it is impossible for an even index to be greater than an odd index. \\n\\nThis provides us with the basic intuition to solving this problem: Take the vector, find the elements in greater half of the vector, and fill them in the odd slots in the vector.  Then, fill the rest in the even slots. \\n\\nHowever, this neglects a key problem: What if the median is repeated? \\n\\nIf we apply the above algorithm to the test case ```[4, 5, 5, 6]```, we can see that the algorithm will fail. We will end up with the same thing, with the two 5s simply switching positions. This is because the start of the greater half happen to equal to the end of the smaller half. To avoid this, we must separate the medians. The method I chose is to place them as far from each other as possible. This means when I fill in the even slots, I start with the median, and when I fill in the odd slots, I end with the repeated medians. This means for any vector of size greater than 2, a repeated median(s) cannot end up together (assuming the input is valid).\\n\\nThis leads to the solution for this problem: **Fill in the odd slots with elements in the greater half of vector, with medians taking up the last slots (if repeated), and fill in the even slots with the rest, with the median at position 0**.\\n\\nAt this point, the problem can be solved using a sort and rearranging the elements in a new vector. However, this has run-time O(nlogn) and space complexity O(n). The problem is looking for a O(n) solution with O(1) space.\\n\\n**Part 2: Quick Select**\\n\\nBased on the proposed solution, we can see that we don\\'t actually need to sort the vector. We only need the elements in the greater half, but we can get them in any order. We only need to make sure that we place the median values properly, and the rest can be in any order. This means we just need to find the median. Once we have the median, we can separate the vector into the odd and even set.\\n\\nTo do that, we will juse the **Quick Select** algorithm, which is an efficient algorithm for getting the median. The algorithm is more generalized, and is used to **get an element at a specific index if the vector were sorted**. Since the median is the element at the middle of vector if the vector were sorted, we can use this algorithm with the middle index and get the median. This algorithm runs in O(n) amortized time O(n^2) worst case, and is  **in place**. This is within the requirements of the problem.\\n\\nMore on Quick Select: https://www.***.org/quickselect-algorithm/\\n\\nThis step can also be accomplished using the built-in nth_element function, which is the same algorithm, but with heapsort as a back up if the time complexity approaches O(n^2). \\n\\nThe algorithm is implemented below. Because quick select\\'s worst case is for a vector with identical elements, the time complexity approaches quadratic for a vector with many duplicates. To deal with this, I used 3-way partition (Dutch Flag algorithm) to partition the split. This effectively avoids the worst case due to duplicates. I also used median-of-3 from standard quick sort instead of random to guess the median. \\n\\nMore on Dutch Flag algorithm: https://www.***.org/sort-an-array-of-0s-1s-and-2s/\\n\\n**Part 3: Virtual Indexing**\\n\\nOnce we have the median, we know how to split the vector into the two sets. However, we must do it **in place**. Furthermore, we also need to get the medians together. To do that, we can apply the 3-way partition algorithm from earlier. This turns the vector into three coherent parts: ```nums = [elements less than median, medians, elements greater than median]```. We know we have at least 1 median, so we know that the even set will be ```[0, first median]```. The odd set will thus be ```(first median, last index]```. \\n\\nThis however, does not put the elements in the right places. To do this in place, we can use **virtual indexing**. \\n\\nVirtual indexing is basically adding an extra level of indirection to the indices. We will see how this will be useful for solving this problem.\\n\\nSay we have the vector ```[4, 5, 5, 6]```. By following our solution, we know that we should end up with ```[5, 6, 4, 5]```. However, after doing the 3-way partition, we are still at ```[4, 5, 5, 6]```. If we map the indices, we can see the following:\\n\\nOriginal Mapping: (0, 1, 2, 3) -->  [4, 5, 5, 6]\\n   \\nSolution Mapping: (1, 3, 0, 2) --> [5, 6, 4, 5]\\n\\nThis means if we have the virtual mapping: (0 -> 1, 1->3, 2 ->0, 3 ->2), we will end up with the solution simply by 3-way partition on the virtual indices:\\n\\nInitially we have (virtual) (0, 1, 2, 3) --> (actual) (1, 3, 0, 2) --> (5, 6, 4, 5). \\n\\nAfter 3 way partition, we have: (virtual) (0, 1, 2, 3) --> (actual) (1, 3, 0, 2) --> (4, 5, 5, 6).\\n\\nWhat this means is that we have completed 3-way partition with respect to the virtual index. But, what about the actual vector now?\\n\\nIf we sub back the numbers from virtual to actual, we get: 4 at index 2, 5 at 0, 5 at 3, and 6 at 1. \\n\\nThis is the solution vector ```[5, 6, 4, 5]```. \\n\\nThis works because we are simply modifying how the partition algorithm sees the numbers from the matrix. The 0 index number it sees is actually the number at index 2, and so on. But the algorithm is doing the same thing. We are simply manipulating each number from the algorithm to fall into the right places, given that it is in the right place in virtual indices. Since the manipulation is in place, the space complexity is O(1).\\n\\nNow that we know this method will work, we need to find the mapping. In order to keep the medians on the opposite sides, we can simply insert the odd and even set in reverse order. This way, even indices start with the median, and odd end with possibly repeated medians. For a vector with say 9 elements, we would have the following:\\n\\n(0, 1, 2, 3, 4, 5, 6, 7, 8) --> (4, 8, 3, 7, 2, 6, 1, 5, 0).\\n\\nThis means the odd set (5, 6, 7, 8) maps to (7, 5, 3, 1), and the even set (0, 1, 2, 3, 4) maps to (8, 6, 4, 2, 0). I think you can see the pattern now.\\n\\nThis is pattern is described by the following in the code:\\n\\n```\\nif(i <= mid) return (mid - i)*2; // Even set\\nreturn 1 + 2*(size - i - 1); // Odd set\\n```\\n\\nWith this mapping, we simply need to plug it into the partition algorithm whenever it references the actual vector, and we are done.  It is important to remember to work with virtual index iterators in the partition algorithm, since it is solving the problem with respect to the virtual indices. \\n\\nThe algorithm runs in average O(n) time, and uses O(1) space. \\n\\n```\\nclass Solution {\\npublic:\\n    int mid;\\n    int size;\\n    void wiggleSort(vector<int>& nums) {\\n        size = nums.size(); mid = (size-1)/2;\\n        if(size < 2) return;\\n\\n        int m = 0, i = 0, j = size-1, median = quickSelect(nums, mid);\\n\\n        while(m <= j) {\\n            int m_ = virtualIndex(m), i_ = virtualIndex(i), j_ = virtualIndex(j); // Virtual index mapping, so m_, i_, and j_ are actual indices\\n            if(nums[m_] < median) {\\n                swap(nums[i_], nums[m_]);\\n                ++i; ++m; // Algorithm runs in virtual index, so we work with the virtual index iterators.\\n            }\\n            else if(nums[m_] > median) {\\n                swap(nums[m_], nums[j_]);\\n                --j; // Algorithm runs in virtual index, so we work with the virtual index iterators.\\n            }\\n            else ++m; // Algorithm runs in virtual index, so we work with the virtual index iterators.\\n        }\\n    }\\n    \\n    inline int virtualIndex(int i) {\\n        if(i <= mid) return (mid-i)*2;\\n        return 1 + 2*(size - i - 1);\\n    }\\n\\nprivate:\\n    void partition(vector<int>& tmp, int det, int left, int right, int& i, int& j) {\\n        int mid = i = left; j = right;\\n        while(mid <= j) {\\n            if(tmp[mid] < det) swap(tmp[i++], tmp[mid++]);\\n            else if(tmp[mid] > det) swap(tmp[mid], tmp[j--]); \\n            else ++mid;\\n        }\\n        --i; ++j;\\n    }\\n\\n    int qs(vector<int>& tmp, int pos, int i, int j) { // left & right inclusive.\\n        if(i == j) return tmp[i];\\n        if(j - i == 1) {\\n            if(tmp[i] > tmp[j]) swap(tmp[i], tmp[j]);\\n            if(pos == i) return tmp[i];\\n            return tmp[j];\\n        }\\n\\n        int m = i + (j-i)/2, boundLeft, boundRight;\\n        if(tmp[i] > tmp[m]) swap(tmp[i], tmp[m]);\\n        if(tmp[m] > tmp[j]) swap(tmp[m], tmp[j]);\\n        if(tmp[i] > tmp[m]) swap(tmp[i], tmp[m]);\\n        partition(tmp, tmp[m], i, j, boundLeft, boundRight);\\n        if(pos > boundLeft) {\\n            if(pos >= boundRight) return qs(tmp, pos, boundRight, j);\\n            return tmp[pos];\\n        }\\n        return qs(tmp, pos, i, boundLeft);\\n    }\\n\\n    int quickSelect(vector<int>& tmp, int pos) { // 0 indexing for pos\\n        return qs(tmp, pos, 0, tmp.size()-1);\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```[4, 5, 5, 6]```\n```nums = [elements less than median, medians, elements greater than median]```\n```[0, first median]```\n```(first median, last index]```\n```[4, 5, 5, 6]```\n```[5, 6, 4, 5]```\n```[4, 5, 5, 6]```\n```[5, 6, 4, 5]```\n```\\nif(i <= mid) return (mid - i)*2; // Even set\\nreturn 1 + 2*(size - i - 1); // Odd set\\n```\n```\\nclass Solution {\\npublic:\\n    int mid;\\n    int size;\\n    void wiggleSort(vector<int>& nums) {\\n        size = nums.size(); mid = (size-1)/2;\\n        if(size < 2) return;\\n\\n        int m = 0, i = 0, j = size-1, median = quickSelect(nums, mid);\\n\\n        while(m <= j) {\\n            int m_ = virtualIndex(m), i_ = virtualIndex(i), j_ = virtualIndex(j); // Virtual index mapping, so m_, i_, and j_ are actual indices\\n            if(nums[m_] < median) {\\n                swap(nums[i_], nums[m_]);\\n                ++i; ++m; // Algorithm runs in virtual index, so we work with the virtual index iterators.\\n            }\\n            else if(nums[m_] > median) {\\n                swap(nums[m_], nums[j_]);\\n                --j; // Algorithm runs in virtual index, so we work with the virtual index iterators.\\n            }\\n            else ++m; // Algorithm runs in virtual index, so we work with the virtual index iterators.\\n        }\\n    }\\n    \\n    inline int virtualIndex(int i) {\\n        if(i <= mid) return (mid-i)*2;\\n        return 1 + 2*(size - i - 1);\\n    }\\n\\nprivate:\\n    void partition(vector<int>& tmp, int det, int left, int right, int& i, int& j) {\\n        int mid = i = left; j = right;\\n        while(mid <= j) {\\n            if(tmp[mid] < det) swap(tmp[i++], tmp[mid++]);\\n            else if(tmp[mid] > det) swap(tmp[mid], tmp[j--]); \\n            else ++mid;\\n        }\\n        --i; ++j;\\n    }\\n\\n    int qs(vector<int>& tmp, int pos, int i, int j) { // left & right inclusive.\\n        if(i == j) return tmp[i];\\n        if(j - i == 1) {\\n            if(tmp[i] > tmp[j]) swap(tmp[i], tmp[j]);\\n            if(pos == i) return tmp[i];\\n            return tmp[j];\\n        }\\n\\n        int m = i + (j-i)/2, boundLeft, boundRight;\\n        if(tmp[i] > tmp[m]) swap(tmp[i], tmp[m]);\\n        if(tmp[m] > tmp[j]) swap(tmp[m], tmp[j]);\\n        if(tmp[i] > tmp[m]) swap(tmp[i], tmp[m]);\\n        partition(tmp, tmp[m], i, j, boundLeft, boundRight);\\n        if(pos > boundLeft) {\\n            if(pos >= boundRight) return qs(tmp, pos, boundRight, j);\\n            return tmp[pos];\\n        }\\n        return qs(tmp, pos, i, boundLeft);\\n    }\\n\\n    int quickSelect(vector<int>& tmp, int pos) { // 0 indexing for pos\\n        return qs(tmp, pos, 0, tmp.size()-1);\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 77680,
                "title": "clear-java-o-n-avg-time-o-n-space-solution-using-3-way-partition",
                "content": "The basic idea is to first select the kth smallest element, where k is the half the size (if size is even) or half the size+1 (if size is odd). So the array is partitioned into two halves, for even size, left half size==right half size, for odd size, left half size==right half size+1. Then iterate back from left and right half, put each value into original array.\\n\\nFor example, [1, 5, 1, 1, 6, 4], after select kth smallest element, it becomes [1,1,1,5,6,4] with median index of 2. For the left half is [1,1,1], right half is [5,6,4]. After merge, it becomes, 1,4,1,6,1,5.\\n\\nSame for [4,5,5,6], after select kth smallest , it becomes [4,5,5,6] with left half [4,5] and right half [5,6], merge it to be [5,6,4,5].\\n\\nThe tricky parts:\\n1) Do a three-way-partition, so that the duplicates are around median, so that they can be split\\n2) Iterate from the back of two halves, so that the duplicates in between can be split apart.\\n\\n    public class Solution {\\n        public void wiggleSort(int[] nums) {\\n            int median = selectKth(nums, 0, nums.length-1, nums.length%2==0 ? nums.length/2 : nums.length/2+1);\\n            List<Integer> leftArr = new ArrayList<Integer>();\\n            for(int i=0; i<=median; i++)\\n                leftArr.add(nums[i]);\\n            List<Integer> rightArr = new ArrayList<Integer>();\\n            for(int i=median+1; i<nums.length; i++)\\n                rightArr.add(nums[i]);\\n            for(int li=leftArr.size()-1,ri=rightArr.size()-1,i=0; ri>=0; li--,ri--,i+=2) { // right is same or shorter than left\\n                nums[i] = leftArr.get(li);\\n                nums[i+1] = rightArr.get(ri);\\n            }\\n            if(nums.length%2!=0)\\n                nums[nums.length-1] = leftArr.get(0);\\n        }\\n        \\n        private int selectKth(int[] nums, int start, int end, int k) {\\n            int[] res = partition(nums,start,end);\\n            int lb = res[0]; int hb = res[1];\\n            if(k-1<lb)\\n                return selectKth(nums,start,lb-1,k);\\n            else if (k-1>hb)\\n                return selectKth(nums,hb+1,end,k);\\n            else\\n                return k-1;\\n        }\\n        \\n        private int[] partition(int[] nums, int lb, int hb) {\\n            int pVal = nums[lb]; // use random genarater is better in performance\\n            int i = lb;\\n            while(i<=hb) {\\n                if(nums[i]==pVal)\\n                    i++;\\n                else if(nums[i]<pVal)\\n                    swap(nums,i++,lb++);\\n                else\\n                    swap(nums,i,hb--);\\n            }\\n            int[] res = new int[2];\\n            res[0] = lb; res[1] = hb;\\n            return res;\\n        }\\n        \\n        private void swap(int[] nums, int i, int j) {\\n            int tmp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = tmp;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void wiggleSort(int[] nums) {\\n            int median = selectKth(nums, 0, nums.length-1, nums.length%2==0 ? nums.length/2 : nums.length/2+1);\\n            List<Integer> leftArr = new ArrayList<Integer>();\\n            for(int i=0; i<=median; i++)\\n                leftArr.add(nums[i]);\\n            List<Integer> rightArr = new ArrayList<Integer>();\\n            for(int i=median+1; i<nums.length; i++)\\n                rightArr.add(nums[i]);\\n            for(int li=leftArr.size()-1,ri=rightArr.size()-1,i=0; ri>=0; li--,ri--,i+=2) { // right is same or shorter than left\\n                nums[i] = leftArr.get(li);\\n                nums[i+1] = rightArr.get(ri);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 77726,
                "title": "clean-average-o-n-time-in-c",
                "content": "Although a worst case O(n) solution is available, it would make it too challenging to write during an interview. The function nth_element in C++ is readily available and is expected to have O(n) time complexity on average. Need some help, though, on how to make space complexity to be O(1).\\n\\nThe algorithm is relatively straight-forward following the proof given by StefanPochmann in \\n[https://leetcode.com/discuss/76965/3-lines-python-with-explanation-proof][1]\\n\\n    class Solution {\\n    public:\\n        void wiggleSort(vector<int>& nums) {\\n            int n = nums.size();\\n            int mid = n/2;\\n            nth_element(nums.begin(), nums.begin() + mid, nums.end());\\n            threeWayPartition(nums, nums[mid]);\\n            vector<int> res(n);\\n            int largeStart = n-1;\\n            int smallStart = (n%2) ? mid : (mid-1);\\n            for (int i = 0; i < n; i+=2)\\n                res[i] = nums[smallStart--];\\n            for (int i = 1; i < n; i+=2)\\n                res[i] = nums[largeStart--];\\n            nums = res;\\n        }\\n        \\n        // this ensures all values equal to the median is in the middle\\n        void threeWayPartition(vector<int> &nums, int val) {\\n            int i = 0, j = 0;\\n            int n = nums.size()-1;\\n            while (j <= n){\\n                if (nums[j] < val)\\n                    swap(nums[i++], nums[j++]);\\n                else if (nums[j] > val)\\n                    swap(nums[j], nums[n--]);\\n                else\\n                    j++;\\n            }\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/76965/3-lines-python-with-explanation-proof",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void wiggleSort(vector<int>& nums) {\\n            int n = nums.size();\\n            int mid = n/2;\\n            nth_element(nums.begin(), nums.begin() + mid, nums.end());\\n            threeWayPartition(nums, nums[mid]);\\n            vector<int> res(n);\\n            int largeStart = n-1;\\n            int smallStart = (n%2) ? mid : (mid-1);\\n            for (int i = 0; i < n; i+=2)\\n                res[i] = nums[smallStart--];\\n            for (int i = 1; i < n; i+=2)\\n                res[i] = nums[largeStart--];\\n            nums = res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 77746,
                "title": "ac-java-solution-7ms",
                "content": "Inspired by this [question][1]\\n\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] temp = new int[nums.length];\\n        int mid = nums.length%2==0?nums.length/2-1:nums.length/2;\\n        int index = 0;\\n        for(int i=0;i<=mid;i++){\\n        \\ttemp[index] = nums[mid-i];\\n        \\tif(index+1<nums.length)\\n        \\t\\ttemp[index+1] = nums[nums.length-i-1];\\n        \\tindex = index+2;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n\\t\\t\\tnums[i] = temp[i];\\n\\t\\t}\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/77122/simple-modulo-solution",
                "solutionTags": [],
                "code": "Inspired by this [question][1]\\n\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] temp = new int[nums.length];\\n        int mid = nums.length%2==0?nums.length/2-1:nums.length/2;\\n        int index = 0;\\n        for(int i=0;i<=mid;i++){\\n        \\ttemp[index] = nums[mid-i];\\n        \\tif(index+1<nums.length)\\n        \\t\\ttemp[index+1] = nums[nums.length-i-1];\\n        \\tindex = index+2;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n\\t\\t\\tnums[i] = temp[i];\\n\\t\\t}\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/77122/simple-modulo-solution",
                "codeTag": "Unknown"
            },
            {
                "id": 77687,
                "title": "simple-modulo-solution",
                "content": "Once again I sort and then spread the numbers like in this example with nums=[0,1,...,9]:\\n\\n    Small half:    4 . 3 . 2 . 1 . 0 .\\n    Large half:    . 9 . 8 . 7 . 6 . 5\\n    ----------------------------------\\n    Together:      4 9 3 8 2 7 1 6 0 5\\n\\nJust write the numbers 9, 8, 7, etc at indexes 1, 3, 5, etc. Use modulo to wrap around for the second round (the even indexes).\\n\\n---\\n\\n**Python**\\n\\n     def wiggleSort(self, nums):\\n        for i, num in enumerate(sorted(nums)[::-1]):\\n            nums[(1+2*i) % (len(nums)|1)] = num\\n\\n---\\n\\n**C++**\\n\\n    void wiggleSort(vector<int>& nums) {\\n        vector<int> sorted(nums);\\n        sort(sorted.rbegin(), sorted.rend());\\n        int n = nums.size(), m = n | 1;\\n        for (int i=0; i<n; i++)\\n            nums[(1+2*i)%m] = sorted[i];\\n    }\\n\\nOr:\\n\\n    void wiggleSort(vector<int>& nums) {\\n        vector<int> sorted(nums);\\n        sort(sorted.rbegin(), sorted.rend());\\n        int n = nums.size(), m = n | 1, i = -1;\\n        for (int num : sorted)\\n            nums[(i+=2)%m] = num;\\n    }",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "Once again I sort and then spread the numbers like in this example with nums=[0,1,...,9]:\\n\\n    Small half:    4 . 3 . 2 . 1 . 0 .\\n    Large half:    . 9 . 8 . 7 . 6 . 5\\n    ----------------------------------\\n    Together:      4 9 3 8 2 7 1 6 0 5\\n\\nJust write the numbers 9, 8, 7, etc at indexes 1, 3, 5, etc. Use modulo to wrap around for the second round (the even indexes).\\n\\n---\\n\\n**Python**\\n\\n     def wiggleSort(self, nums):\\n        for i, num in enumerate(sorted(nums)[::-1]):\\n            nums[(1+2*i) % (len(nums)|1)] = num\\n\\n---\\n\\n**C++**\\n\\n    void wiggleSort(vector<int>& nums) {\\n        vector<int> sorted(nums);\\n        sort(sorted.rbegin(), sorted.rend());\\n        int n = nums.size(), m = n | 1;\\n        for (int i=0; i<n; i++)\\n            nums[(1+2*i)%m] = sorted[i];\\n    }\\n\\nOr:\\n\\n    void wiggleSort(vector<int>& nums) {\\n        vector<int> sorted(nums);\\n        sort(sorted.rbegin(), sorted.rend());\\n        int n = nums.size(), m = n | 1, i = -1;\\n        for (int num : sorted)\\n            nums[(i+=2)%m] = num;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 429246,
                "title": "java-3ms-100-time-100-space-simple-sorting-with-comments",
                "content": "```\\nclass Solution {\\n    \\n    // the idea is to sort the input array and divide into two equal parts; 0 to mid & mid+ 1 to end\\n    // and then arrange the elements (using auxillary array) using reverse order for both parts (mid to 0 and end to mid + 1).\\n    // an example : Input array [1, 5, 1, 1, 6, 4] , after sorting it becomes [1,1,1,4,5,6]\\n    // the two parts of the array are [1,1,1] & [4,5,6]\\n    // now take last values of these two arrays i.e. index 2(o-based) from both ; which gives us 1 & 6 respectively\\n    // now [1,6,...] becomes the first two values in the final/input array\\n    // now again take previous chosen index - 1, which are index 1 from both ; which gives us 1 & 5 \\n    // now [1,6,1,5] becomes our array\\n    // now again take index - 1 , which is index 0 from both now; this gives us 1 & 4\\n    // now [1,6,1,5,1,4] becomes our answer\\n    public void wiggleSort(int[] nums) {\\n        \\n        //sort the array\\n        Arrays.sort(nums);\\n        \\n        // find mid point of array\\n        int mid = (nums.length - 1 ) / 2;\\n        int right = nums.length - 1;\\n        \\n        //aux array to temp store the values\\n        int[] result = new int[right + 1];\\n        int counter = 0;\\n        \\n        // select values from two parts of the array and arrange them in aux array\\n        while(mid >= 0 || right > (nums.length - 1 ) / 2 ){\\n            \\n            if(counter % 2 == 0){\\n                result[counter] = nums[mid];\\n                mid--;\\n            } else {\\n                result[counter] = nums[right];\\n                right--;\\n            }\\n            \\n            counter++;\\n        }\\n        \\n        //now store back these values in input/original array\\n        for(int i = 0; i < nums.length; i++){\\n            nums[i] = result[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // the idea is to sort the input array and divide into two equal parts; 0 to mid & mid+ 1 to end\\n    // and then arrange the elements (using auxillary array) using reverse order for both parts (mid to 0 and end to mid + 1).\\n    // an example : Input array [1, 5, 1, 1, 6, 4] , after sorting it becomes [1,1,1,4,5,6]\\n    // the two parts of the array are [1,1,1] & [4,5,6]\\n    // now take last values of these two arrays i.e. index 2(o-based) from both ; which gives us 1 & 6 respectively\\n    // now [1,6,...] becomes the first two values in the final/input array\\n    // now again take previous chosen index - 1, which are index 1 from both ; which gives us 1 & 5 \\n    // now [1,6,1,5] becomes our array\\n    // now again take index - 1 , which is index 0 from both now; this gives us 1 & 4\\n    // now [1,6,1,5,1,4] becomes our answer\\n    public void wiggleSort(int[] nums) {\\n        \\n        //sort the array\\n        Arrays.sort(nums);\\n        \\n        // find mid point of array\\n        int mid = (nums.length - 1 ) / 2;\\n        int right = nums.length - 1;\\n        \\n        //aux array to temp store the values\\n        int[] result = new int[right + 1];\\n        int counter = 0;\\n        \\n        // select values from two parts of the array and arrange them in aux array\\n        while(mid >= 0 || right > (nums.length - 1 ) / 2 ){\\n            \\n            if(counter % 2 == 0){\\n                result[counter] = nums[mid];\\n                mid--;\\n            } else {\\n                result[counter] = nums[right];\\n                right--;\\n            }\\n            \\n            counter++;\\n        }\\n        \\n        //now store back these values in input/original array\\n        for(int i = 0; i < nums.length; i++){\\n            nums[i] = result[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266483,
                "title": "two-clear-java-solutions-with-brief-explanation-and-one-more-interesting-question",
                "content": "A very detailed explanation for various solutions is here:\\n\\nhttps://leetcode.com/problems/wiggle-sort-ii/discuss/77684/Summary-of-the-various-solutions-to-Wiggle-Sort-for-your-reference\\n\\nBut it might be too verbose for many people. I\\'d like to provide some brief explanations for two solution.\\n\\n**Solution #1**\\n\\nA pretty simple and straightforward solution is:\\n\\n1. Sort the array (with an auxiliary array)\\n1. Copy the elements to the correct positions\\n\\nIt\\'s the code:\\n\\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int[] val = Arrays.copyOf(nums, nums.length);\\n        Arrays.sort(val);\\n        int idx = val.length - 1;\\n        for(int i = 1;i < nums.length;i += 2) nums[i] = val[idx--];\\n        for(int i = 0;i < nums.length;i += 2) nums[i] = val[idx--];\\n    }\\n}\\n```\\n\\nNote that we don\\'t need to calculate all the concrete positions to be copied; we just need to go through the array by odd and even positions till exhausting the array.\\n\\nThe space complexity is O(N), and the time complexity is O(NlogN) + O(N) (sorting + filling) = **O(NlogN)**.\\n\\n**Solution #2**\\n\\nTo achieve space complexity O(1) and time complexity O(N), a popular approach is:\\n\\n1. Get the median by *Quick Select* algorithm\\n1. Compare and move the elements to the correct positions\\n\\nAbout the Quick Select algorithm, a detailed explanation is here:\\n\\nhttps://en.wikipedia.org/wiki/Quickselect\\n\\nFor step #2, an approach is *Virtual Indexing*. But I adopted another solution, which is from here and more straightforward (I made some little improvements):\\n\\nhttps://leetcode.com/problems/wiggle-sort-ii/discuss/77688/O(n)%2BO(1)-after-median-without-Virtual-Indexing-%3A-\\n\\nIt\\'s the code:\\n\\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int n = nums.length, idx = 0, left = 1,  right = ((n - 1) & 1) == 0 ? (n - 1) : (n - 2), median = qselect(nums, 0, n - 1, (n - 1) / 2), tmp = 0;\\n        while(idx < n){\\n            if(nums[idx] > median && !((idx & 1) == 1 && idx <= left)){\\n                tmp = nums[idx];\\n                nums[idx] = nums[left];\\n                nums[left] = tmp;\\n                left += 2;\\n            }else if(nums[idx] < median && !((idx & 1) == 0 && idx >= right)){\\n                tmp = nums[idx];\\n                nums[idx] = nums[right];\\n                nums[right] = tmp;\\n                right -= 2;\\n            }else{\\n                idx++;\\n            }\\n        }\\n    }\\n    \\n    private int qselect(int[] nums, int start, int end, int k){\\n        if(start == end)return nums[start];\\n        int left = start, right = end, key = nums[right];\\n        while(left < right){\\n            while(left < right && nums[left] <= key)left++;\\n            if(left < right)nums[right--] = nums[left];\\n            while(left < right && nums[right] >= key)right--;\\n            if(left < right)nums[left++] = nums[right];\\n        }\\n        nums[left] = key;\\n        if(k < left)return qselect(nums, start, left - 1, k);\\n        if(k > right)return qselect(nums, right + 1, end, k);\\n        return nums[left];\\n    }\\n}\\n```\\n\\nSome explanations:\\n\\nFor step #1 (quick select), the basic idea is similar to **quick sort**: use one element as pivot, scan the array, compare each element with the pivot and move it to left or right. After the scanning, the new array is separated by the pivot: all elements left to the pivot are smaller than it, and all elements right to the pivot are larger than it.\\n\\nAfter than, if k is smaller than left, which means k is in the left portion, we need to apply quick select again on the left portion; or if k is larger than right, which means k is in the right portion, we need to apply quick select again on the right portion. The only other possibility is k == left, and we can return nums[left] (the pivot) directly.\\n\\nFor step #2, the basic idea is: \\n\\n1. Use two pointers **left** and **right**. **Left** points to the first position of the odd positions of the array (1, 3, 5, ...) which includes the larger portion of the array, and **right** points to the latest position of the even positions of the array (0, 2, 4,...) which includes the smaller portion of the array.\\n1. Scan the array from left to right by using a pointer **idx**. If the number of current position is larger than the median, swap it to the larger portion (indicated by pointer **left**), otherwise swap it to the smaller portion (indicated by the pointer **right**).\\n\\nNote the complexity of step #2. We don\\'t want to rewrite the positions which have been processed, so we need to avoid the processing if:\\n\\n1. The pointer idx are in the the odd positions of the array and idx is smaller than left;\\n1. The pointer idx are in the the even positions of the array and idx is  than right.\\n\\nThe relevant code is:\\n\\n```\\n            if(nums[idx] > median && !(idx <= left && (idx & 1) == 1)) {\\n\\t\\t\\t\\t...\\n            } else if (nums[idx] < median && !(idx >= right && (idx & 1) == 0)) {\\n\\t\\t\\t\\t...\\n            } else {\\n                idx++;\\n            }\\n```\\n\\nFor the Quick Select algorithm, the space complexity is O(1) because it\\'s an in-space algorithm. For time complexity, the average time complexity is O(N), and the worst case is O(N^2). Since the time complexity of step #2 is obviously O(N), generally it\\'s said that the time complexity of the entire solution as **O(N)**. But I wonder it...\\n\\n**One more interesting question**\\n\\nI compared the performances of the two solutions:\\n\\nSolution #1: **3ms** (https://leetcode.com/submissions/detail/218994210/)\\nSolution #2: **68ms** (https://leetcode.com/submissions/detail/218988674/)\\n\\nIt\\'s really surprising because #2 (O(N)) is supposed to be much faster than #1 (O(NlogN)). My guess is, O(N) is just an average case for #2, and actually it might be worse (up to O(N^2)). Another possibility is that the calling of Java API Arrays.sort() is much faster than the Java code I made by myself. But I am not very sure, and I don\\'t have much time for further investigation.\\n\\nAny comments and question is welcome.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int[] val = Arrays.copyOf(nums, nums.length);\\n        Arrays.sort(val);\\n        int idx = val.length - 1;\\n        for(int i = 1;i < nums.length;i += 2) nums[i] = val[idx--];\\n        for(int i = 0;i < nums.length;i += 2) nums[i] = val[idx--];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int n = nums.length, idx = 0, left = 1,  right = ((n - 1) & 1) == 0 ? (n - 1) : (n - 2), median = qselect(nums, 0, n - 1, (n - 1) / 2), tmp = 0;\\n        while(idx < n){\\n            if(nums[idx] > median && !((idx & 1) == 1 && idx <= left)){\\n                tmp = nums[idx];\\n                nums[idx] = nums[left];\\n                nums[left] = tmp;\\n                left += 2;\\n            }else if(nums[idx] < median && !((idx & 1) == 0 && idx >= right)){\\n                tmp = nums[idx];\\n                nums[idx] = nums[right];\\n                nums[right] = tmp;\\n                right -= 2;\\n            }else{\\n                idx++;\\n            }\\n        }\\n    }\\n    \\n    private int qselect(int[] nums, int start, int end, int k){\\n        if(start == end)return nums[start];\\n        int left = start, right = end, key = nums[right];\\n        while(left < right){\\n            while(left < right && nums[left] <= key)left++;\\n            if(left < right)nums[right--] = nums[left];\\n            while(left < right && nums[right] >= key)right--;\\n            if(left < right)nums[left++] = nums[right];\\n        }\\n        nums[left] = key;\\n        if(k < left)return qselect(nums, start, left - 1, k);\\n        if(k > right)return qselect(nums, right + 1, end, k);\\n        return nums[left];\\n    }\\n}\\n```\n```\\n            if(nums[idx] > median && !(idx <= left && (idx & 1) == 1)) {\\n\\t\\t\\t\\t...\\n            } else if (nums[idx] < median && !(idx >= right && (idx & 1) == 0)) {\\n\\t\\t\\t\\t...\\n            } else {\\n                idx++;\\n            }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061742,
                "title": "o-n-run-time-with-space-o-n-using-count-sort",
                "content": "The idea is simple and leverages on the fact taht the max input size would not go greater than 5000. Instead of typical sort, we use count sort and reduce the overall run time complexity of the algorithm. From there onwards, we iterate from reverse of the counts and modify the given list in-place.\\n\\n\\n```class Solution(object):\\n    def wiggleSort(self, nums):\\n        count = [0]*5001\\n        \\n        for n in nums:\\n            count[n]+=1\\n        \\n        odd = 1\\n        even = 0\\n        for n in range(5000,-1,-1):\\n            if odd >= len(nums) and even >= len(nums):\\n                break\\n                \\n            if count[n] == 0:\\n                continue\\n            \\n            while count[n] and (odd < len(nums) or even < len(nums)):\\n                count[n]-=1\\n                if odd < len(nums):\\n                    nums[odd] = n\\n                    odd+=2\\n                else:\\n                    nums[even] = n\\n                    even+=2",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "The idea is simple and leverages on the fact taht the max input size would not go greater than 5000. Instead of typical sort, we use count sort and reduce the overall run time complexity of the algorithm. From there onwards, we iterate from reverse of the counts and modify the given list in-place.\\n\\n\\n```class Solution(object):\\n    def wiggleSort(self, nums):\\n        count = [0]*5001\\n        \\n        for n in nums:\\n            count[n]+=1\\n        \\n        odd = 1\\n        even = 0\\n        for n in range(5000,-1,-1):\\n            if odd >= len(nums) and even >= len(nums):\\n                break\\n                \\n            if count[n] == 0:\\n                continue\\n            \\n            while count[n] and (odd < len(nums) or even < len(nums)):\\n                count[n]-=1\\n                if odd < len(nums):\\n                    nums[odd] = n\\n                    odd+=2\\n                else:\\n                    nums[even] = n\\n                    even+=2",
                "codeTag": "Java"
            },
            {
                "id": 494141,
                "title": "c-virtual-indexing-64ms",
                "content": "If you look closer at these problem it is almost exactly the same as [75. Sort Colors](https://leetcode.com/problems/sort-colors/). I highly recommend to solve [Sort Colors](https://leetcode.com/problems/sort-colors/) first and understand solution with one pass. Here is [My explanation](https://leetcode.com/problems/sort-colors/discuss/494100/C%2B%2B%3A-one-pass-O(n)-4ms). I would appreciate your feedback ;)\\n\\nI didn\\'t come up with algorithm, I am very grateful to [shuoshankou](https://leetcode.com/problems/wiggle-sort-ii/discuss/77682/Step-by-step-explanation-of-index-mapping-in-Java) and [StefanPochmann](https://leetcode.com/problems/wiggle-sort-ii/discuss/77677/O(n)%2BO(1)-after-median-Virtual-Indexing) explanations and kai99 response on question [\"I am curious about how to come up with (1 + 2*index) % (n | 1)\"](https://leetcode.com/problems/wiggle-sort-ii/discuss/77682/Step-by-step-explanation-of-index-mapping-in-Java).\\n\\nIn this problem we need again to sort elements by \\'color\\', but our colors are:\\n* Bigger than median element\\n* Smaller than median element\\n* Equals to median element.\\n\\nFirst, we need to find median element. We can use Quick Select algorithm or `nth_select` function in C++.\\nAfter we have median, we need to do some index mapping. Let\\'s say we have 6 elements in the list, we want first to put all odd positions, then all even positions. Like that:\\n```\\nInitial: 0 1 2 3 4 5\\nMapped:  1 3 5 0 2 4\\n```\\nThis can be achieved by creating array with mapped indexes (int[] {1, 3, 5, 0, 2, 4}) or using a mapping function `i\\' = (1 + 2*i) / (size | 1)` (I use C++ #define to create macros) :\\n`\\n#define A(i) nums[(1 + 2*(i)) % (size | 1)]\\n`\\nWhy does it work? Because for first half of indexes using furmula `(1 + 2*i) % size` it\\'s:\\n`\\n0 => (1 + 2 * 0) % 6 = 1\\n1 => (1 + 2 * 1) % 6 = 3\\n2 => (1 + 2 * 2) % 6 = 5\\n`\\nAnd for the second half indexes would be `1 3 and 5`, but since we use `(size | 1)` this value guaranteed to be odd, so we so to speak odd up our `size` and second half of mapped indexes going to be:\\n`\\n3 => (1 + 2 * 3) % 7 = 0\\n4 => (1 + 2 * 4) % 7 = 2\\n5 => (1 + 2 * 5) % 7 = 4\\n`\\nRest of the code is exact copy from [75. Sort Colors](https://leetcode.com/problems/sort-colors/) algorithm:\\n\\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int size = nums.size();\\n        nth_element(begin(nums), begin(nums) + size / 2, end(nums));\\n        int m = *(begin(nums) + size / 2);\\n        \\n        #define A(i) nums[(1 + 2*(i)) % (size | 1)]\\n        \\n        int l = 0, r = size - 1;\\n        for (int i = 0; i <= r;)\\n            if (A(i) > m) swap(A(i++), A(l++));\\n            else if (A(i) < m) swap(A(i), A(r--));\\n            else i++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nInitial: 0 1 2 3 4 5\\nMapped:  1 3 5 0 2 4\\n```\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int size = nums.size();\\n        nth_element(begin(nums), begin(nums) + size / 2, end(nums));\\n        int m = *(begin(nums) + size / 2);\\n        \\n        #define A(i) nums[(1 + 2*(i)) % (size | 1)]\\n        \\n        int l = 0, r = size - 1;\\n        for (int i = 0; i <= r;)\\n            if (A(i) > m) swap(A(i++), A(l++));\\n            else if (A(i) < m) swap(A(i), A(r--));\\n            else i++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434330,
                "title": "easy-to-understand-c-solution-by-sorting",
                "content": "Runtime: 72 ms, faster than 68.28% of C++ online submissions for Wiggle Sort II.\\nMemory Usage: 11.5 MB, less than 38.46% of C++ online submissions for Wiggle Sort II.\\n\\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        \\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        \\n        int i = (temp.size()-1)/2;\\n        int j = temp.size()-1;\\n        int k = 0;\\n        while(k < nums.size())\\n        {\\n            if(k&1)\\n                nums[k++] = temp[j--];\\n            else\\n                nums[k++] = temp[i--];\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        \\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        \\n        int i = (temp.size()-1)/2;\\n        int j = temp.size()-1;\\n        int k = 0;\\n        while(k < nums.size())\\n        {\\n            if(k&1)\\n                nums[k++] = temp[j--];\\n            else\\n                nums[k++] = temp[i--];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 77740,
                "title": "sorting-based-reverse-order-assigning",
                "content": "After seeing many post, I do think the best way is to sort and then assign the sorted array interleaving.\\n\\nThe trap is the there may be duplicate for the median. So, we should assign the max value first to avoid the \\n\\nduplicate to happen together.\\n\\nThe case like this:\\n\\n        4 5 5 6\\n\\nIf in the original order , the result will be\\n\\n        4  5  5   6\\n\\nIn the reverse order , the result will be \\n\\n       5   6  4  5\\n\\nHere is the code :\\n\\n \\n\\n      class Solution {\\n        public:\\n            void wiggleSort(vector<int>& nums) {\\n                int len=nums.size();\\n                if(len<=1) return;\\n                sort(nums.begin(), nums.end());\\n                vector<int> result(nums);\\n                int j=len-1;\\n                for(int i=1; i<len; i+=2, j--) result[i]=nums[j];\\n                for(int i=0; i<len; i+=2, j--) result[i]=nums[j];\\n                nums=result;\\n                return;\\n            }\\n        };\\n\\n\\n**Update:**\\n\\nAbout how to find the k-th element of the unordered array , here is the implementation ....\\n\\n\\n    class Solution {\\n    public:\\n        /*\\n         * param k : description of k\\n         * param nums : description of array and index 0 ~ n-1\\n         * return: description of return\\n         */\\n        int kthLargestElement(int k, vector<int> nums) {\\n            int left = 0, right = nums.size() - 1;\\n            //default_random_engine gen((random_device())());\\n            while (left <= right) {\\n                // Generates a random int in [left, right].\\n                //uniform_int_distribution<int> dis(left, right);\\n                int pivot_idx = left;\\n                int new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums);\\n                if (new_pivot_idx == k - 1) {\\n                    return nums[new_pivot_idx];\\n                } else if (new_pivot_idx > k - 1) {\\n                    right = new_pivot_idx - 1;\\n                } else {  // new_pivot_idx < k - 1.\\n                    left = new_pivot_idx + 1;\\n                }\\n            }\\n        }\\n    \\n        // Partition nums[left : right] around pivot_idx, returns the new index of the\\n        // pivot, new_pivot_idx, after partition. After partitioning,\\n        // nums[left : new_pivot_idx - 1] contains elements that are greater than the\\n        // pivot, and nums[new_pivot_idx + 1 : right] contains elements that are less\\n        // than the pivot.\\n        int PartitionAroundPivot(int left, int right, int pivot_idx, vector<int>& nums) {\\n            int pivot_value = nums[pivot_idx];\\n            int new_pivot_idx = left;\\n            swap(nums[pivot_idx], nums[right]);\\n            for (int i = left; i < right; ++i) {\\n                if (nums[i] > pivot_value) {\\n                    swap(nums[i], nums[new_pivot_idx++]);\\n                }\\n            }\\n            swap(nums[right], nums[new_pivot_idx]);\\n            return new_pivot_idx;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            void wiggleSort(vector<int>& nums) {\\n                int len=nums.size();\\n                if(len<=1) return;\\n                sort(nums.begin(), nums.end());\\n                vector<int> result(nums);\\n                int j=len-1;\\n                for(int i=1; i<len; i+=2, j--) result[i]=nums[j];\\n                for(int i=0; i<len; i+=2, j--) result[i]=nums[j];\\n                nums=result;\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3242335,
                "title": "324-time-99-2-and-space-99-16-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We first sort the array nums in ascending order.\\n2. We then find the median of the array (i.e., the middle element if the array has odd length, or one of the two middle elements if the array has even length). We can use (n - 1) // 2 to find the index of the median element.\\n3. We then create two subarrays: one containing the larger half of the sorted nums array, and one containing the smaller half. We can use slicing to achieve this: nums[mid::-1] gives us the elements from the median index backwards to the start of the array, and nums[:mid:-1] gives us the elements from the median index forwards to the end of the array, in reverse order.\\n4. Finally, we use slicing again to interleave the elements of the two subarrays. We use nums[::2] to get every second element starting from the first element, and nums[1::2] to get every second element starting from the second element. We assign the elements from the larger subarray to the even indices, and the elements from the smaller subarray to the odd indices.\\n\\nHere\\'s a step-by-step explanation of how the code works:\\n\\n1. n = len(nums): Gets the length of the input array nums.\\n\\n2. nums.sort(): Sorts the array in ascending order. This is necessary because the algorithm needs to rearrange the array in a specific pattern.\\n\\n3. mid = (n - 1) // 2: Calculates the index of the middle element in the sorted array.\\n\\n4. nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]: This is where the main algorithm takes place.\\n\\n- nums[::2]: Slices the array starting from the first element and selects every second element (i.e. elements with even indices).\\n- nums[1::2]: Slices the array starting from the second element and selects every second element (i.e. elements with odd indices).\\n- nums[mid::-1]: Slices the array starting from the middle element and selects every element backwards (i.e. in descending order).\\n- nums[:mid:-1]: Slices the array starting from the element after the middle element and selects every element backwards (i.e. in descending order).\\nBy doing this slicing and reassignment, we\\'re essentially rearranging the array in a \"wiggle\" pattern. Specifically, the even-indexed elements are the larger half of the sorted array, and the odd-indexed elements are the smaller half of the sorted array. This ensures that adjacent elements alternate between being larger and smaller.\\n\\n5. The original array nums is now sorted in a wiggle pattern.\\n\\nOverall, the time complexity of this solution is O(n log n) due to the sorting operation. The space complexity is O(n) due to the slicing and reassignment of nums.\\n\\n# Complexity\\n- Time complexity:\\n99.2%\\n\\n- Space complexity:\\n99.16%\\n\\n# Code\\n```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        n = len(nums)\\n        nums.sort()\\n        mid = (n - 1) // 2\\n        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Divide and Conquer",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        n = len(nums)\\n        nums.sort()\\n        mid = (n - 1) // 2\\n        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488651,
                "title": "two-pointers-faster-than-97-36-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        vector<int> temp(n);\\n        int i = 1, j = n-1;\\n        while(i <nums.size()){\\n            temp[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        i = 0;\\n        while(i<nums.size()){\\n            temp[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        for(int it =0; it<n;it++){\\n            nums[it] = temp[it];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        vector<int> temp(n);\\n        int i = 1, j = n-1;\\n        while(i <nums.size()){\\n            temp[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        i = 0;\\n        while(i<nums.size()){\\n            temp[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        for(int it =0; it<n;it++){\\n            nums[it] = temp[it];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389489,
                "title": "priority-queue-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- insert all elements of array in max-heap\\n- put the top large values in odd positions of array\\n- And remaining values to the even position of array\\n# Complexity\\n- Time complexity:\\n   <!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   O(n)\\n\\n- Space complexity:\\n  <!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n   O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n       int n=nums.size();\\n       //max heap\\n       priority_queue<int>pq;\\n       for(int x:nums) pq.push(x);\\n       //put the top large values in odd positions\\n       //ex-> [1,5,1,1,6,4]------>[_6_5_4_]\\n       int i=1;\\n       while(pq.size() and i<n){\\n           nums[i]=pq.top();\\n           pq.pop();\\n           i+=2;\\n       }\\n       //put remaining values in even position\\n       //[1,6,5,1,4,1] \\n       int j=0;\\n       while(pq.size() and j<n){\\n           nums[j]=pq.top();\\n           pq.pop();\\n           j+=2;\\n       }\\n     //upvote if u like the solution \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n       int n=nums.size();\\n       //max heap\\n       priority_queue<int>pq;\\n       for(int x:nums) pq.push(x);\\n       //put the top large values in odd positions\\n       //ex-> [1,5,1,1,6,4]------>[_6_5_4_]\\n       int i=1;\\n       while(pq.size() and i<n){\\n           nums[i]=pq.top();\\n           pq.pop();\\n           i+=2;\\n       }\\n       //put remaining values in even position\\n       //[1,6,5,1,4,1] \\n       int j=0;\\n       while(pq.size() and j<n){\\n           nums[j]=pq.top();\\n           pq.pop();\\n           j+=2;\\n       }\\n     //upvote if u like the solution \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899607,
                "title": "easiest-c-solution-ever-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n=nums.size();                    // finding the size of vector\\n        sort(nums.begin(),nums.end());        // sorting the complete vector\\n        int arr[n];                           // creating an array of n size\\n        // now we will first fill all the odd place index(1,3,5,7....etc) of arr with the maximum elements\\n        // and as the nums is sorted so we will keep traversing from right to left giving us the largest elements\\n        int i=1;        \\n        int j=n-1;\\n        \\n        // this while loop will basically fill all the odd places in arr\\n        while(i<n)\\n        {\\n            arr[i]=nums[j];\\n            i=i+2;\\n            j--;\\n        }\\n        // now to fill all the even place index(0,2,4,6.....etc) of arr , we will simply fill the remaining elements of nums from j th index to 0 index\\n        i=0;\\n        while(i<n)\\n        {\\n            arr[i]=nums[j];\\n            i=i+2;\\n            j--;\\n        }\\n        \\n        // copying the array arr into nums vector\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=arr[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n=nums.size();                    // finding the size of vector\\n        sort(nums.begin(),nums.end());        // sorting the complete vector\\n        int arr[n];                           // creating an array of n size\\n        // now we will first fill all the odd place index(1,3,5,7....etc) of arr with the maximum elements\\n        // and as the nums is sorted so we will keep traversing from right to left giving us the largest elements\\n        int i=1;        \\n        int j=n-1;\\n        \\n        // this while loop will basically fill all the odd places in arr\\n        while(i<n)\\n        {\\n            arr[i]=nums[j];\\n            i=i+2;\\n            j--;\\n        }\\n        // now to fill all the even place index(0,2,4,6.....etc) of arr , we will simply fill the remaining elements of nums from j th index to 0 index\\n        i=0;\\n        while(i<n)\\n        {\\n            arr[i]=nums[j];\\n            i=i+2;\\n            j--;\\n        }\\n        \\n        // copying the array arr into nums vector\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=arr[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77716,
                "title": "java-18-ms-true-o-1-space-cheated-o-n-time-using-binary-search",
                "content": "I spent a lot of time looking for an in-place linear algorithm for finding the median. Thanks to @StefanPochmann for posting [a link to Stack Overflow][1], I found [this one][2]. It's really esoteric, and what's worse, it's not really a complete algorithm because at some point it just says\\n\\n> then, using any other linear-time in-place selection algorithm, search\\n> the sample for two elements x,y, of ranks...\\n\\nSo in the end, it's not exactly an algorithm for linear in-place selection, but rather an algorithm for finding the best sample for other algorithms to optimize the total number of operations involved. The paper provides references to other algorithms, but I've been unable to find any of them in the open. But surely, one could buy some books or access to some scientific site, and in the end it is possible to solve this in linear time and constant space. The code would be a real mess, though, and I'm not even sure if it will fit within the code length limit.\\n\\nBut [there is a better way][3]. Once I saw that I was amazed how absurdly simple it is. Made me feel like Dr. Watson after another explanation by Holmes.\\n\\nIndeed, why bother with all those algorithms if we know that possible values of the median lie between `INT_MIN` and `INT_MAX`. We can use binary search on the entire range! And since checking whether some number is the median or not takes O(n), then the whole thing is just O(n log 2^32). But log 2^32 is a constant, so it's technically still O(n).\\n\\n    public void wiggleSort(int[] nums) {\\n        if (nums.length <= 1) {\\n            return;\\n        }\\n        int p = bsSelect(nums, (nums.length - 1) / 2 + 1);\\n        // Reverse Dutch National Flag with Wiggle Indexing (StefanPochmann's Virtual Indexing).\\n        // Thanks to apolloydy for reversing this thing.\\n        final int n = nums.length;\\n        int m = 0, r = nums.length - 1;\\n        int lw = 1, mw = 1, rw = (1 + 2 * (nums.length - 1)) % (n | 1);\\n        while (m <= r) {\\n            if (nums[mw] > p) {\\n                int tmp = nums[mw];\\n                nums[mw] = nums[lw];\\n                nums[lw] = tmp;\\n                mw = (mw + 2) % (n | 1);\\n                ++m;\\n                lw = (lw + 2) % (n | 1);\\n            } else if (nums[mw] < p) {\\n                int tmp = nums[mw];\\n                nums[mw] = nums[rw];\\n                nums[rw] = tmp;\\n                rw = (rw - 2 + (n | 1)) % (n | 1);\\n                --r;\\n            } else {\\n                mw = (mw + 2) % (n | 1);\\n                ++m;\\n            }\\n        }\\n    }\\n\\n    private int bsSelect(int[] nums, int k) {\\n        if (k < 1 || k > nums.length) {\\n            throw new IllegalArgumentException(\"length=\" + nums.length + \" k=\" + k);\\n        }\\n        int left = Integer.MIN_VALUE, right = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = (left < 0 && right > 0) ? (left + right) / 2 : left + (right - left) / 2;\\n            int cl = 0, cg = 0, d = 0;\\n            for (int n : nums) {\\n                if (n < mid) {\\n                    if (++cl > k - 1) {\\n                        d = +1; // mid larger than kth\\n                        break;\\n                    }\\n                } else if (n > mid) {\\n                    if (++cg > (nums.length - k)) {\\n                        d = -1; // mid smaller than kth\\n                        break;\\n                    }\\n                }\\n            }\\n            if (d == 0) {\\n                return mid;\\n            } else if (d < 0) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        throw new AssertionError();\\n    }\\n\\nIt almost feels like cheating. But according to that post on Quora, that's exactly what the interviewers expect. Thinking out of the box and such.\\n\\nThis thing runs on my PC for 500 million elements in 31 seconds if the array is sorted and in 38 seconds if it's wiggle-sorted to begin with. This is slower than the median of medians solution (22 and 12 seconds), but this time it's true O(1) space.\\n\\n**Note** that I moved the argument check to the beginning because the old variant was really bugged. And I fixed the binary search because I forgot to do the `mid + 1` / `mid - 1` part. That turned 15 ms into 18 ms for some reason, and if I put `while (true)` there then it raises the runtime to 20 ms. Figures. But at least it's not bugged now (I hope). Note that integer overflows aren't possible because if mid is either `INT_MIN` or `INT_MAX` then the respective condition for decreasing/increasing it would be false.\\n\\nAs noted in the comment below, `mid = (left + right) / 2` may overflow, so it was replaced by that ugly, but overflow-aware line.\\n\\n  [1]: http://stackoverflow.com/questions/34562256/why-is-the-median-of-medians-algorithm-described-as-using-o1-auxiliary-space/34600911?noredirect=1#comment56987453_34600911\\n  [2]: http://www.cai.sk/ojs/index.php/cai/article/viewArticle/345\\n  [3]: https://www.quora.com/Whats-an-algorithm-for-finding-the-median-element-in-an-unsorted-array-in-linear-time-constant-space",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "I spent a lot of time looking for an in-place linear algorithm for finding the median. Thanks to @StefanPochmann for posting [a link to Stack Overflow][1], I found [this one][2]. It's really esoteric, and what's worse, it's not really a complete algorithm because at some point it just says\\n\\n> then, using any other linear-time in-place selection algorithm, search\\n> the sample for two elements x,y, of ranks...\\n\\nSo in the end, it's not exactly an algorithm for linear in-place selection, but rather an algorithm for finding the best sample for other algorithms to optimize the total number of operations involved. The paper provides references to other algorithms, but I've been unable to find any of them in the open. But surely, one could buy some books or access to some scientific site, and in the end it is possible to solve this in linear time and constant space. The code would be a real mess, though, and I'm not even sure if it will fit within the code length limit.\\n\\nBut [there is a better way][3]. Once I saw that I was amazed how absurdly simple it is. Made me feel like Dr. Watson after another explanation by Holmes.\\n\\nIndeed, why bother with all those algorithms if we know that possible values of the median lie between `INT_MIN` and `INT_MAX`. We can use binary search on the entire range! And since checking whether some number is the median or not takes O(n), then the whole thing is just O(n log 2^32). But log 2^32 is a constant, so it's technically still O(n).\\n\\n    public void wiggleSort(int[] nums) {\\n        if (nums.length <= 1) {\\n            return;\\n        }\\n        int p = bsSelect(nums, (nums.length - 1) / 2 + 1);\\n        // Reverse Dutch National Flag with Wiggle Indexing (StefanPochmann's Virtual Indexing).\\n        // Thanks to apolloydy for reversing this thing.\\n        final int n = nums.length;\\n        int m = 0, r = nums.length - 1;\\n        int lw = 1, mw = 1, rw = (1 + 2 * (nums.length - 1)) % (n | 1);\\n        while (m <= r) {\\n            if (nums[mw] > p) {\\n                int tmp = nums[mw];\\n                nums[mw] = nums[lw];\\n                nums[lw] = tmp;\\n                mw = (mw + 2) % (n | 1);\\n                ++m;\\n                lw = (lw + 2) % (n | 1);\\n            } else if (nums[mw] < p) {\\n                int tmp = nums[mw];\\n                nums[mw] = nums[rw];\\n                nums[rw] = tmp;\\n                rw = (rw - 2 + (n | 1)) % (n | 1);\\n                --r;\\n            } else {\\n                mw = (mw + 2) % (n | 1);\\n                ++m;\\n            }\\n        }\\n    }\\n\\n    private int bsSelect(int[] nums, int k) {\\n        if (k < 1 || k > nums.length) {\\n            throw new IllegalArgumentException(\"length=\" + nums.length + \" k=\" + k);\\n        }\\n        int left = Integer.MIN_VALUE, right = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = (left < 0 && right > 0) ? (left + right) / 2 : left + (right - left) / 2;\\n            int cl = 0, cg = 0, d = 0;\\n            for (int n : nums) {\\n                if (n < mid) {\\n                    if (++cl > k - 1) {\\n                        d = +1; // mid larger than kth\\n                        break;\\n                    }\\n                } else if (n > mid) {\\n                    if (++cg > (nums.length - k)) {\\n                        d = -1; // mid smaller than kth\\n                        break;\\n                    }\\n                }\\n            }\\n            if (d == 0) {\\n                return mid;\\n            } else if (d < 0) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        throw new AssertionError();\\n    }\\n\\nIt almost feels like cheating. But according to that post on Quora, that's exactly what the interviewers expect. Thinking out of the box and such.\\n\\nThis thing runs on my PC for 500 million elements in 31 seconds if the array is sorted and in 38 seconds if it's wiggle-sorted to begin with. This is slower than the median of medians solution (22 and 12 seconds), but this time it's true O(1) space.\\n\\n**Note** that I moved the argument check to the beginning because the old variant was really bugged. And I fixed the binary search because I forgot to do the `mid + 1` / `mid - 1` part. That turned 15 ms into 18 ms for some reason, and if I put `while (true)` there then it raises the runtime to 20 ms. Figures. But at least it's not bugged now (I hope). Note that integer overflows aren't possible because if mid is either `INT_MIN` or `INT_MAX` then the respective condition for decreasing/increasing it would be false.\\n\\nAs noted in the comment below, `mid = (left + right) / 2` may overflow, so it was replaced by that ugly, but overflow-aware line.\\n\\n  [1]: http://stackoverflow.com/questions/34562256/why-is-the-median-of-medians-algorithm-described-as-using-o1-auxiliary-space/34600911?noredirect=1#comment56987453_34600911\\n  [2]: http://www.cai.sk/ojs/index.php/cai/article/viewArticle/345\\n  [3]: https://www.quora.com/Whats-an-algorithm-for-finding-the-median-element-in-an-unsorted-array-in-linear-time-constant-space",
                "codeTag": "Unknown"
            },
            {
                "id": 892397,
                "title": "python3-o-n-time-o-1-space-wiggle-sort-ii",
                "content": "Note that the performance actually sucks. Because it\\'s CPython. If a builtin is written in C and it\\'s O(NlgN), its performance may be better than an O(N) implementation in pure Python.\\n\\n```\\n# Inspired by https://leetcode.com/problems/wiggle-sort-ii/discuss/77677/O(n)%2BO(1)-after-median-Virtual-Indexing\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        mid = len(nums) // 2\\n        def quickselect(arr, lo, hi, k):\\n            pivot = random.randint(lo, hi)\\n            arr[pivot], arr[hi] = arr[hi], arr[pivot]\\n            pivot = lo\\n            for i in range(lo, hi):\\n                if arr[i] < arr[hi]:\\n                    arr[i], arr[pivot] = arr[pivot], arr[i]\\n                    pivot += 1\\n            arr[pivot], arr[hi] = arr[hi], arr[pivot]\\n            if k == pivot:\\n                return arr[pivot]\\n            elif k < pivot:\\n                return quickselect(arr, lo, pivot-1, k)\\n            else:\\n                return quickselect(arr, pivot+1, hi, k)\\n        median = quickselect(nums, 0, len(nums)-1, mid)\\n                    \\n        # virtual index\\n        vi = lambda x: x * 2 + 1 if x < mid else (x - mid) * 2\\n        i, j, k = 0, 0, len(nums) - 1\\n        while j <= k:\\n            if nums[vi(j)] < median:\\n                nums[vi(j)], nums[vi(k)] = nums[vi(k)], nums[vi(j)]\\n                k -= 1\\n            elif nums[vi(j)] > median:\\n                nums[vi(j)], nums[vi(i)] = nums[vi(i)], nums[vi(j)]\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Inspired by https://leetcode.com/problems/wiggle-sort-ii/discuss/77677/O(n)%2BO(1)-after-median-Virtual-Indexing\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        mid = len(nums) // 2\\n        def quickselect(arr, lo, hi, k):\\n            pivot = random.randint(lo, hi)\\n            arr[pivot], arr[hi] = arr[hi], arr[pivot]\\n            pivot = lo\\n            for i in range(lo, hi):\\n                if arr[i] < arr[hi]:\\n                    arr[i], arr[pivot] = arr[pivot], arr[i]\\n                    pivot += 1\\n            arr[pivot], arr[hi] = arr[hi], arr[pivot]\\n            if k == pivot:\\n                return arr[pivot]\\n            elif k < pivot:\\n                return quickselect(arr, lo, pivot-1, k)\\n            else:\\n                return quickselect(arr, pivot+1, hi, k)\\n        median = quickselect(nums, 0, len(nums)-1, mid)\\n                    \\n        # virtual index\\n        vi = lambda x: x * 2 + 1 if x < mid else (x - mid) * 2\\n        i, j, k = 0, 0, len(nums) - 1\\n        while j <= k:\\n            if nums[vi(j)] < median:\\n                nums[vi(j)], nums[vi(k)] = nums[vi(k)], nums[vi(j)]\\n                k -= 1\\n            elif nums[vi(j)] > median:\\n                nums[vi(j)], nums[vi(i)] = nums[vi(i)], nums[vi(j)]\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77689,
                "title": "python-o-n-solution",
                "content": "After read @StefanPochmann 's two solutions, I came up with this one.\\nhttps://discuss.leetcode.com/topic/32929/o-n-o-1-after-median-virtual-indexing\\nhttps://discuss.leetcode.com/topic/32861/3-lines-python-with-explanation-proof/30\\n```\\nclass Solution(object):\\n    def wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        self.findMedian(nums,0,len(nums)-1)\\n        half=(len(nums)+1)//2\\n        nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]\\n\\n    \\n    def findMedian(self,nums,left,right):\\n        i=j=k=(left+1)\\n        mid=len(nums)//2\\n        sentinel=nums[left]\\n        while k<=right:\\n            if nums[k]<sentinel:\\n                nums[k],nums[j]=nums[j],nums[k]\\n                nums[i],nums[j]=nums[j],nums[i]\\n                i+=1\\n                j+=1\\n                k+=1\\n            elif nums[k]>sentinel:\\n                k+=1\\n            else:\\n                nums[j],nums[k]=nums[k],nums[j]\\n                j+=1\\n                k+=1\\n        nums[left],nums[i-1]=nums[i-1],nums[left]\\n        if i-1<=mid<j:\\n            return nums[mid]\\n        if mid>=j:\\n            return self.findMedian(nums,j,right)\\n        else:\\n            return self.findMedian(nums,left,i-2)\\n  ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        self.findMedian(nums,0,len(nums)-1)\\n        half=(len(nums)+1)//2\\n        nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]\\n\\n    \\n    def findMedian(self,nums,left,right):\\n        i=j=k=(left+1)\\n        mid=len(nums)//2\\n        sentinel=nums[left]\\n        while k<=right:\\n            if nums[k]<sentinel:\\n                nums[k],nums[j]=nums[j],nums[k]\\n                nums[i],nums[j]=nums[j],nums[i]\\n                i+=1\\n                j+=1\\n                k+=1\\n            elif nums[k]>sentinel:\\n                k+=1\\n            else:\\n                nums[j],nums[k]=nums[k],nums[j]\\n                j+=1\\n                k+=1\\n        nums[left],nums[i-1]=nums[i-1],nums[left]\\n        if i-1<=mid<j:\\n            return nums[mid]\\n        if mid>=j:\\n            return self.findMedian(nums,j,right)\\n        else:\\n            return self.findMedian(nums,left,i-2)\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 276465,
                "title": "sort-nlogn-o-n-space",
                "content": "```\\npublic void wiggleSort(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return;\\n        Arrays.sort(nums);\\n        boolean isOdd = (nums.length % 2 == 0)? false: true;\\n        \\n        int mid = 0;\\n        if (isOdd) {\\n            mid = nums.length / 2 + 1;\\n        } else {\\n            mid = nums.length / 2;\\n        }\\n        \\n        // Create a Copy\\n        int[] copy = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            copy[i] = nums[i];\\n        }\\n        \\n        int k = mid - 1;\\n        int j = nums.length - 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) {\\n                nums[i] = copy[k--];\\n            } else {\\n                nums[i] = copy[j--];\\n            }\\n        }\\n        \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic void wiggleSort(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return;\\n        Arrays.sort(nums);\\n        boolean isOdd = (nums.length % 2 == 0)? false: true;\\n        \\n        int mid = 0;\\n        if (isOdd) {\\n            mid = nums.length / 2 + 1;\\n        } else {\\n            mid = nums.length / 2;\\n        }\\n        \\n        // Create a Copy\\n        int[] copy = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            copy[i] = nums[i];\\n        }\\n        \\n        int k = mid - 1;\\n        int j = nums.length - 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) {\\n                nums[i] = copy[k--];\\n            } else {\\n                nums[i] = copy[j--];\\n            }\\n        }\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 77760,
                "title": "1-liner-c-with-wiggleiterator",
                "content": "This is an extreme version of using what I call [**virtual indexing**](https://leetcode.com/discuss/77133/o-n-o-1-after-median-virtual-indexing). Probably better read that previous post first, as I'm not explaining the underlying idea here. This one is mostly an exercise in writing a custom C++ iterator in order to let the standard `sort` function do the whole job.\\n\\n---\\n\\nThe solution function is just one line:\\n\\n    void wiggleSort(vector<int>& nums) {\\n        sort(wigglebegin(nums), wiggleend(nums));\\n    }\\n\\n---\\n\\nSadly the supporting custom iterator, even though its only job is the index rewiring in `operator*`, needs quite a few more lines :-)\\n\\n    struct wiggleiterator : iterator<random_access_iterator_tag, int> {\\n        vector<int>& v;\\n        int i;\\n        wiggleiterator(vector<int>& vec, int index) : v(vec), i(index) {}\\n        wiggleiterator& operator=(wiggleiterator& b) { v = b.v; i = b.i; return *this; }\\n        bool operator==(wiggleiterator& b) { return i == b.i; }\\n        bool operator!=(wiggleiterator& b) { return i != b.i; }\\n        bool operator<(wiggleiterator& b) { return i < b.i; }\\n        int operator-(wiggleiterator& b) { return i - b.i; }\\n        wiggleiterator operator+(int n) { return wiggleiterator(v, i+n); }\\n        wiggleiterator operator-(int n) { return wiggleiterator(v, i-n); }\\n        void operator++() { i++; }\\n        wiggleiterator& operator--() { i--; return *this; }\\n        int& operator*() { return v[(2*(v.size()-i)-1) % (v.size()|1)]; }\\n    };\\n\\n    wiggleiterator wigglebegin(vector<int>& vec) {\\n        return wiggleiterator(vec, 0);\\n    }\\n    wiggleiterator wiggleend(vector<int>& vec) {\\n        return wiggleiterator(vec, vec.size());\\n    }\\n\\nNote: I have no idea how good my iterator implementation is. I just knew it's possible, so I started it empty and compiled and fixed the first error, then compiled again and fixed the first error again, and so on until the compiler stopped complaining. I'd appreciate any improvements.",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "This is an extreme version of using what I call [**virtual indexing**](https://leetcode.com/discuss/77133/o-n-o-1-after-median-virtual-indexing). Probably better read that previous post first, as I'm not explaining the underlying idea here. This one is mostly an exercise in writing a custom C++ iterator in order to let the standard `sort` function do the whole job.\\n\\n---\\n\\nThe solution function is just one line:\\n\\n    void wiggleSort(vector<int>& nums) {\\n        sort(wigglebegin(nums), wiggleend(nums));\\n    }\\n\\n---\\n\\nSadly the supporting custom iterator, even though its only job is the index rewiring in `operator*`, needs quite a few more lines :-)\\n\\n    struct wiggleiterator : iterator<random_access_iterator_tag, int> {\\n        vector<int>& v;\\n        int i;\\n        wiggleiterator(vector<int>& vec, int index) : v(vec), i(index) {}\\n        wiggleiterator& operator=(wiggleiterator& b) { v = b.v; i = b.i; return *this; }\\n        bool operator==(wiggleiterator& b) { return i == b.i; }\\n        bool operator!=(wiggleiterator& b) { return i != b.i; }\\n        bool operator<(wiggleiterator& b) { return i < b.i; }\\n        int operator-(wiggleiterator& b) { return i - b.i; }\\n        wiggleiterator operator+(int n) { return wiggleiterator(v, i+n); }\\n        wiggleiterator operator-(int n) { return wiggleiterator(v, i-n); }\\n        void operator++() { i++; }\\n        wiggleiterator& operator--() { i--; return *this; }\\n        int& operator*() { return v[(2*(v.size()-i)-1) % (v.size()|1)]; }\\n    };\\n\\n    wiggleiterator wigglebegin(vector<int>& vec) {\\n        return wiggleiterator(vec, 0);\\n    }\\n    wiggleiterator wiggleend(vector<int>& vec) {\\n        return wiggleiterator(vec, vec.size());\\n    }\\n\\nNote: I have no idea how good my iterator implementation is. I just knew it's possible, so I started it empty and compiled and fixed the first error, then compiled again and fixed the first error again, and so on until the compiler stopped complaining. I'd appreciate any improvements.",
                "codeTag": "Unknown"
            },
            {
                "id": 2738420,
                "title": "o-n-time-o-1-space-best-explanation-till-now-with-code",
                "content": "**This post is mainly for O(n) time and O(1) space complexity solution approach**.\\n\\nSo basically according to question we have sort first all even index with the values in decreasing order then secondly sort all odd index with the remaining values in decreasing order.\\n\\nSo this is basically consists of Three way partition(for sorting) with Virtual index(for sorting of desired index).\\nwe have to apply three way partition in virtual indexes.\\n\\n* For Three Way Partition refer to Sort colors ques of leetcode.\\n* For Virtual Indexing use-:\\n                  #define A(i) nums[(1+2*(i)) % (n|1)]     (used for macros)\\n\\t\\t\\t\\t  \\n\\t\\t\\t\\t  \\nAfter Virtual indexing we can access -:\\nfor n = 10,\\nAccessing A(0) actually accesses nums[1].\\nAccessing A(1) actually accesses nums[3].\\nAccessing A(2) actually accesses nums[5].\\nAccessing A(3) actually accesses nums[7].\\nAccessing A(4) actually accesses nums[9].\\nAccessing A(5) actually accesses nums[0].\\nAccessing A(6) actually accesses nums[2].\\nAccessing A(7) actually accesses nums[4].\\nAccessing A(8) actually accesses nums[6].\\nAccessing A(9) actually accesses nums[8].\\n\\n**For more clear explanation**\\n\\n![image](https://assets.leetcode.com/users/images/6f74b95c-f769-4905-8b15-088e32c4de54_1666600178.2854524.jpeg)\\n\\n**C++ code** -:\\n\\n\\'\\'\\'\\n       \\n\\t   void wiggleSort(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        nth_element(nums.begin() , nums.begin()+n/2 , nums.end());\\n        int mid = *(nums.begin() + n/2);\\n        \\n        #define arr(i) nums[(1+2*(i)) % (n|1)]\\n        \\n        int i=0; \\n        int j=0;\\n        int k=n-1;\\n        \\n        while( j <= k){\\n            \\n            if(arr(j) > mid){\\n                swap(arr(i++),arr(j++));\\n            }\\n            else if(arr(j) < mid){\\n                swap(arr(j) , arr(k--));\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n    }\\n\\'\\'\\'\\n**Please Upvote if you got it or if any doubt feel free to ask in comment section.**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**This post is mainly for O(n) time and O(1) space complexity solution approach**.\\n\\nSo basically according to question we have sort first all even index with the values in decreasing order then secondly sort all odd index with the remaining values in decreasing order.\\n\\nSo this is basically consists of Three way partition(for sorting) with Virtual index(for sorting of desired index).\\nwe have to apply three way partition in virtual indexes.\\n\\n* For Three Way Partition refer to Sort colors ques of leetcode.\\n* For Virtual Indexing use-:\\n                  #define A(i) nums[(1+2*(i)) % (n|1)]     (used for macros)\\n\\t\\t\\t\\t  \\n\\t\\t\\t\\t  \\nAfter Virtual indexing we can access -:\\nfor n = 10,\\nAccessing A(0) actually accesses nums[1].\\nAccessing A(1) actually accesses nums[3].\\nAccessing A(2) actually accesses nums[5].\\nAccessing A(3) actually accesses nums[7].\\nAccessing A(4) actually accesses nums[9].\\nAccessing A(5) actually accesses nums[0].\\nAccessing A(6) actually accesses nums[2].\\nAccessing A(7) actually accesses nums[4].\\nAccessing A(8) actually accesses nums[6].\\nAccessing A(9) actually accesses nums[8].\\n\\n**For more clear explanation**\\n\\n![image](https://assets.leetcode.com/users/images/6f74b95c-f769-4905-8b15-088e32c4de54_1666600178.2854524.jpeg)\\n\\n**C++ code** -:\\n\\n\\'\\'\\'\\n       \\n\\t   void wiggleSort(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        nth_element(nums.begin() , nums.begin()+n/2 , nums.end());\\n        int mid = *(nums.begin() + n/2);\\n        \\n        #define arr(i) nums[(1+2*(i)) % (n|1)]\\n        \\n        int i=0; \\n        int j=0;\\n        int k=n-1;\\n        \\n        while( j <= k){\\n            \\n            if(arr(j) > mid){\\n                swap(arr(i++),arr(j++));\\n            }\\n            else if(arr(j) < mid){\\n                swap(arr(j) , arr(k--));\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n    }\\n\\'\\'\\'\\n**Please Upvote if you got it or if any doubt feel free to ask in comment section.**\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 717099,
                "title": "java-simple-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    // wiggle sort 1 allows consecutive duplicates\\n    // so we can just sort it and 1. either swap 2 consecutive elements\\n    // 2. or arrange it 1 by 1\\n\\n    // However, wiggle sort 2 does not allow consecutive duplicates\\n    // So we cannot sort and arrange it from middle - > 0, middle - > end\\n    // the above solution will produce (consecutive) duplicates\\n    // Another thought would be sort and arrange it from 0 - > middle, middle - > end\\n    // the above solution will still produce (consecutive) duplicates\\n\\n    // we need to do some kind of reverse\\n    // we decide to partition the sorted array into 2 halves\\n    // the 1st half size is always >= 2nd half size\\n    // mark the end index of 1st half\\n    // mark the end index of 2nd half\\n    // put them back into nums from index 0 - > end\\n\\n    public void wiggleSort(int[] nums) {\\n        if(nums == null || nums.length < 2) {\\n            return;\\n        }\\n        int[] copy = Arrays.copyOf(nums, nums.length);\\n\\n        Arrays.sort(copy);\\n\\n        int endOf1stHalf = (nums.length - 1) / 2;\\n        int endOf2ndHalf = nums.length - 1;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            if(i % 2 == 0) { // i = 0, 2, 4, 6...\\n                nums[i] = copy[endOf1stHalf--];\\n            } else {\\n                nums[i] = copy[endOf2ndHalf--];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // wiggle sort 1 allows consecutive duplicates\\n    // so we can just sort it and 1. either swap 2 consecutive elements\\n    // 2. or arrange it 1 by 1\\n\\n    // However, wiggle sort 2 does not allow consecutive duplicates\\n    // So we cannot sort and arrange it from middle - > 0, middle - > end\\n    // the above solution will produce (consecutive) duplicates\\n    // Another thought would be sort and arrange it from 0 - > middle, middle - > end\\n    // the above solution will still produce (consecutive) duplicates\\n\\n    // we need to do some kind of reverse\\n    // we decide to partition the sorted array into 2 halves\\n    // the 1st half size is always >= 2nd half size\\n    // mark the end index of 1st half\\n    // mark the end index of 2nd half\\n    // put them back into nums from index 0 - > end\\n\\n    public void wiggleSort(int[] nums) {\\n        if(nums == null || nums.length < 2) {\\n            return;\\n        }\\n        int[] copy = Arrays.copyOf(nums, nums.length);\\n\\n        Arrays.sort(copy);\\n\\n        int endOf1stHalf = (nums.length - 1) / 2;\\n        int endOf2ndHalf = nums.length - 1;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            if(i % 2 == 0) { // i = 0, 2, 4, 6...\\n                nums[i] = copy[endOf1stHalf--];\\n            } else {\\n                nums[i] = copy[endOf2ndHalf--];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806509,
                "title": "simple-c-solution-with-coments",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n\\t//sort the vector and create a empty vector.\\n        sort(nums.begin() , nums.end());\\n        int n = nums.size();\\n        vector<int> ans(n);\\n\\t\\t//take a pointer at empty position of new vector.\\n\\t\\t\\n        int i = 1; \\n        int j = n-1;\\n\\t\\t//Put the large elements at i and iterate i by two positions. \\n        while(i<n){\\n            ans[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n\\t\\t//put the small elements of nums in ans at empty position, starting from the 0th index and at alternate empty positions.\\n        i = 0;\\n        while(i<n){\\n            ans[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        for(i = 0 ; i<n ; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n\\t//sort the vector and create a empty vector.\\n        sort(nums.begin() , nums.end());\\n        int n = nums.size();\\n        vector<int> ans(n);\\n\\t\\t//take a pointer at empty position of new vector.\\n\\t\\t\\n        int i = 1; \\n        int j = n-1;\\n\\t\\t//Put the large elements at i and iterate i by two positions. \\n        while(i<n){\\n            ans[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n\\t\\t//put the small elements of nums in ans at empty position, starting from the 0th index and at alternate empty positions.\\n        i = 0;\\n        while(i<n){\\n            ans[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        for(i = 0 ; i<n ; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776003,
                "title": "o-n-o-1-c-simple-solution",
                "content": "**Step 1**: find median using *nth_element* or  find out the nth smallest element using *quickselect* (Time Complexity: O(n) average)\\n**Step 2**: place elements larger than median in first odd slots, smaller than median in last even slots. This is done to keep the elements equal to median as far as possible.\\n\\n**Psuedo Code**: \\nAfter finding median using nth_element, follow the below steps:\\n\\tPoint variables *o* and *e* to first odd and last even slot respectively.\\n\\tLoop over the *nums* array, for current index *i*:\\n\\t\\t1. if *nums[i] > median* do: if i is an odd slot and is lesser than the current odd slot to be filled (\\'o\\') then stop and move to the next slot as this slot is processed already o/w swap it with the current odd slot and increase o by 2 to point to the next odd slot to be filled.\\n\\t\\t2. if *nums[i] < median* do: similarly do for even slot here.\\n\\t\\t3. if *nums[i] = median* do: stop and move to the next slot.\\n\\t\\t\\n```\\nclass Solution {\\npublic:\\n    \\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size(), mid = (n + 1)/ 2 - 1;;\\n        if(n == 0) return;\\n        \\n        nth_element(nums.begin(), nums.begin() + mid, nums.end());\\n        int median = nums[mid], o = 1, e = ((n - 1) & 1) ? n - 2 : n - 1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i] > median){\\n                if((i & 1) && i < o) continue;\\n                swap(nums[o], nums[i--]);\\n                o += 2;\\n            }else if(nums[i] < median){\\n                if(!(i & 1) && i > e) continue;\\n                swap(nums[e], nums[i--]);\\n                e -= 2;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size(), mid = (n + 1)/ 2 - 1;;\\n        if(n == 0) return;\\n        \\n        nth_element(nums.begin(), nums.begin() + mid, nums.end());\\n        int median = nums[mid], o = 1, e = ((n - 1) & 1) ? n - 2 : n - 1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i] > median){\\n                if((i & 1) && i < o) continue;\\n                swap(nums[o], nums[i--]);\\n                o += 2;\\n            }else if(nums[i] < median){\\n                if(!(i & 1) && i > e) continue;\\n                swap(nums[e], nums[i--]);\\n                e -= 2;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251208,
                "title": "using-heaps",
                "content": "I\\'ve used a MaxHeap for this implementation . Python does not supports the max-heap, hence used the min-heap as max-heap. \\nTwo simple steps:\\n* Put largest numbers in odd indexes first\\n* Then put remaining numbers in even indexes\\n\\n```\\ndef wiggleSort(self, nums: List[int]) -> None:\\n\\t\\t#to make it work as a min-heap\\n        heap = [-i for i in nums]\\n        heapify(heap)\\n\\t\\t\\n\\t\\t#putting largest element into odd index\\n        for i in range(1,len(nums),2):\\n            nums[i] = -heappop(heap)\\n\\t\\t\\n\\t\\t#putting remaining element into even index\\n        for i in range(0, len(nums), 2):\\n            nums[i] = -heappop(heap)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef wiggleSort(self, nums: List[int]) -> None:\\n\\t\\t#to make it work as a min-heap\\n        heap = [-i for i in nums]\\n        heapify(heap)\\n\\t\\t\\n\\t\\t#putting largest element into odd index\\n        for i in range(1,len(nums),2):\\n            nums[i] = -heappop(heap)\\n\\t\\t\\n\\t\\t#putting remaining element into even index\\n        for i in range(0, len(nums), 2):\\n            nums[i] = -heappop(heap)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1030461,
                "title": "c-4ms-100-faster-o-n-o-1-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n        int n = nums.size(), mid = (n + 1)/ 2 - 1;\\n        nth_element(nums.begin(), nums.begin() + mid, nums.end());\\n        int median = nums[mid], o = 1, e = ((n - 1) & 1) ? n - 2 : n - 1;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] > median){\\n                if((i & 1) && i < o) continue;\\n                swap(nums[o], nums[i--]);\\n                o += 2;\\n            }\\n            else if(nums[i] < median){\\n                if(!(i & 1) && i > e) continue;\\n                swap(nums[e], nums[i--]);\\n                e -= 2;\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 430314,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. Sort the array\\n2. Split the array from middle, left part(smaller #s), right part(bigger #s)\\n3. Update nums from left part and right part in turns\\n``` javascript\\nvar wiggleSort = function(nums) {\\n    nums.sort((b,a)=>b-a);\\n    let mid = Math.floor(nums.length/2)\\n    mid+=nums.length%2==0?0:1;\\n    let even = nums.slice(0, mid);\\n    let odd = nums.slice(mid);\\n    for(let i=0;i<nums.length;i++) {\\n        if (i%2==0) {\\n            nums[i] = even.pop();\\n        } else {\\n            nums[i] = odd.pop();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar wiggleSort = function(nums) {\\n    nums.sort((b,a)=>b-a);\\n    let mid = Math.floor(nums.length/2)\\n    mid+=nums.length%2==0?0:1;\\n    let even = nums.slice(0, mid);\\n    let odd = nums.slice(mid);\\n    for(let i=0;i<nums.length;i++) {\\n        if (i%2==0) {\\n            nums[i] = even.pop();\\n        } else {\\n            nums[i] = odd.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 274101,
                "title": "javascript-o-n-solution",
                "content": "This is basically the O(n) + O(1) solution proposed by Stefan Pochmann. I didn\\'t see any proper JavaScript implementation posted here though, so I thought I\\'d post mine.\\n\\n```\\nvar wiggleSort = function(nums) {\\n    const median = quickSelect(nums, parseInt((nums.length+1) / 2));\\n    let n = nums.length;\\n    \\n    let left = 0;\\n    let i = 0;\\n    let right = n - 1;\\n    \\n    while(i <= right){\\n        \\n        if(nums[newIndex(i, n)] > median){\\n            swap(nums, newIndex(left++, n), newIndex(i++, n));\\n        }\\n        else if (nums[newIndex(i, n)] < median){\\n            swap(nums, newIndex(right--, n), newIndex(i, n));\\n        }\\n        else {\\n            i++;\\n        }\\n    }\\n};\\n\\nfunction quickSelect(array, k){\\n    return quickRecurse(0, array.length - 1);\\n\\n    function quickRecurse(left, right){\\n        if (left <= right){\\n            let partitionIndex = partition(left, right);\\n            if (partitionIndex === k-1){\\n                return array[partitionIndex];\\n            } else if (partitionIndex < k-1){\\n                return quickRecurse(partitionIndex + 1, right);\\n            } else if (partitionIndex > k-1){\\n                return quickRecurse(left, partitionIndex - 1);\\n            }\\n        }\\n    }\\n\\n    function partition(left, right){\\n        let pivot = array[right];\\n        let i = left;\\n        for (let j = left; j < right; j++){\\n            if (array[j] < pivot){\\n                swap(array, j, i);\\n                i++;\\n            }\\n        }\\n        swap(array, i, right);\\n        return i;\\n    }\\n}\\n\\nfunction swap(list, left, right){\\n    let temp = list[left];\\n    list[left] = list[right];\\n    list[right] = temp;\\n}\\n\\nfunction newIndex(index, n){\\n    return (1 + 2 * index) % (n | 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar wiggleSort = function(nums) {\\n    const median = quickSelect(nums, parseInt((nums.length+1) / 2));\\n    let n = nums.length;\\n    \\n    let left = 0;\\n    let i = 0;\\n    let right = n - 1;\\n    \\n    while(i <= right){\\n        \\n        if(nums[newIndex(i, n)] > median){\\n            swap(nums, newIndex(left++, n), newIndex(i++, n));\\n        }\\n        else if (nums[newIndex(i, n)] < median){\\n            swap(nums, newIndex(right--, n), newIndex(i, n));\\n        }\\n        else {\\n            i++;\\n        }\\n    }\\n};\\n\\nfunction quickSelect(array, k){\\n    return quickRecurse(0, array.length - 1);\\n\\n    function quickRecurse(left, right){\\n        if (left <= right){\\n            let partitionIndex = partition(left, right);\\n            if (partitionIndex === k-1){\\n                return array[partitionIndex];\\n            } else if (partitionIndex < k-1){\\n                return quickRecurse(partitionIndex + 1, right);\\n            } else if (partitionIndex > k-1){\\n                return quickRecurse(left, partitionIndex - 1);\\n            }\\n        }\\n    }\\n\\n    function partition(left, right){\\n        let pivot = array[right];\\n        let i = left;\\n        for (let j = left; j < right; j++){\\n            if (array[j] < pivot){\\n                swap(array, j, i);\\n                i++;\\n            }\\n        }\\n        swap(array, i, right);\\n        return i;\\n    }\\n}\\n\\nfunction swap(list, left, right){\\n    let temp = list[left];\\n    list[left] = list[right];\\n    list[right] = temp;\\n}\\n\\nfunction newIndex(index, n){\\n    return (1 + 2 * index) % (n | 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 242626,
                "title": "quick-select-three-way-partition-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 2) {\\n            return;\\n        }\\n        int mid = (size % 2 == 1) ? size / 2 : size / 2 - 1;\\n        findMid(nums, 0, size - 1, mid);\\n        int smaller = mid;\\n        int larger = size - 1;\\n        vector<int> result(size, 0);\\n        for (int i = 0; i < size; i += 2) {\\n            result[i] = nums[smaller];\\n            smaller--;\\n            if (i + 1 < size) {\\n                result[i + 1] = nums[larger];\\n                larger--;\\n            }\\n        }\\n        nums = result;\\n        return;\\n    }\\n    \\n    void findMid(vector<int>& nums, int start, int end, int k) {\\n        if (start == end) {\\n            return;\\n        }\\n        int left = start;\\n        int right = end;\\n        int mid = left + (right - left) / 2;\\n        int pivot = nums[mid];\\n        mid = start;\\n        while (mid <= right) {\\n            if (nums[mid] < pivot) {\\n                swap(nums, left, mid);\\n                left++;\\n                mid++;\\n            } else if (nums[mid] > pivot) {\\n                swap(nums, mid, right);\\n                right--;\\n            } else {\\n                mid++;\\n            }\\n        }\\n        if (k <= left) {\\n            findMid(nums, start, left, k);\\n        }\\n        if (k >= mid) {\\n            findMid(nums, mid, end, k);\\n        }\\n        return;\\n    }\\n    \\n    void swap(vector<int>& nums, int i, int j) {\\n        int tmp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = tmp;\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 2) {\\n            return;\\n        }\\n        int mid = (size % 2 == 1) ? size / 2 : size / 2 - 1;\\n        findMid(nums, 0, size - 1, mid);\\n        int smaller = mid;\\n        int larger = size - 1;\\n        vector<int> result(size, 0);\\n        for (int i = 0; i < size; i += 2) {\\n            result[i] = nums[smaller];\\n            smaller--;\\n            if (i + 1 < size) {\\n                result[i + 1] = nums[larger];\\n                larger--;\\n            }\\n        }\\n        nums = result;\\n        return;\\n    }\\n    \\n    void findMid(vector<int>& nums, int start, int end, int k) {\\n        if (start == end) {\\n            return;\\n        }\\n        int left = start;\\n        int right = end;\\n        int mid = left + (right - left) / 2;\\n        int pivot = nums[mid];\\n        mid = start;\\n        while (mid <= right) {\\n            if (nums[mid] < pivot) {\\n                swap(nums, left, mid);\\n                left++;\\n                mid++;\\n            } else if (nums[mid] > pivot) {\\n                swap(nums, mid, right);\\n                right--;\\n            } else {\\n                mid++;\\n            }\\n        }\\n        if (k <= left) {\\n            findMid(nums, start, left, k);\\n        }\\n        if (k >= mid) {\\n            findMid(nums, mid, end, k);\\n        }\\n        return;\\n    }\\n    \\n    void swap(vector<int>& nums, int i, int j) {\\n        int tmp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = tmp;\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77686,
                "title": "6-lines-c-using-sort",
                "content": "```\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>sorted(nums);\\n        sort(sorted.begin(), sorted.end());\\n        int i(0), j((n+1)/2);\\n        for(int k = n-1; k >= 0; k--)\\n            nums[k] = k % 2 == 0 ? sorted[i++] : sorted[j++];\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>sorted(nums);\\n        sort(sorted.begin(), sorted.end());\\n        int i(0), j((n+1)/2);\\n        for(int k = n-1; k >= 0; k--)\\n            nums[k] = k % 2 == 0 ? sorted[i++] : sorted[j++];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2810053,
                "title": "very-easy-solution-in-5-lines-using-python",
                "content": "**1. We have to copy array into temporary space\\n2. Sort temporary array in ascending order\\n3. Then run loop of size 2\\n4. During loop we have to swap elements of orignal array with temporary array\\n5. Swap temporary array values form end (j index point to last till i ! = end of array) and keep assigning value in orignal array start from i = 1 with jump of 2.\\n6. Then reduce i - 1 -> i = 0 and start filling value where we left the j and keep assigning values to original array from i = 0 index till end with jump of 2.**\\n\\n```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        tmp = nums.copy()\\n        tmp.sort()        \\n        n = len(nums)\\n        i, j = 1, n - 1\\n        for _ in range(2): \\n            for k in range(i, n, 2): # when i == 1 then gt elements and when i == 0 then sm elements with jump of 2\\n                nums[k] = tmp[j] # sorted array tmp reverse order values assignment\\n                j -= 1\\n            i -= 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        tmp = nums.copy()\\n        tmp.sort()        \\n        n = len(nums)\\n        i, j = 1, n - 1\\n        for _ in range(2): \\n            for k in range(i, n, 2): # when i == 1 then gt elements and when i == 0 then sm elements with jump of 2\\n                nums[k] = tmp[j] # sorted array tmp reverse order values assignment\\n                j -= 1\\n            i -= 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659114,
                "title": "java-solution-with-explained-pictures",
                "content": "step1:  sort the array in asc order\\nstep2:  split the sorted array to two parts like part1|part2\\nstep3:  pick the nums from part1 and part2 in below order\\n       part1. largest,  part2. largest,  part1.second_largest,  part2.second_largest, part1.third_largest,        part2.third_largest.......\\n![image](https://assets.leetcode.com/users/images/9655b503-3193-4958-affc-3b67e3bebc1c_1640998521.5820448.png)\\n\\n\\n\\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] newnums = new int[nums.length];\\n        int k = 0;\\n        int s = (nums.length + 1) / 2 - 1;\\n        int e = nums.length - 1;\\n        \\n        while(k < nums.length){\\n            if(k % 2 == 0){\\n                newnums[k++] = nums[s--];\\n            }else{\\n                newnums[k++] = nums[e--];\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            nums[i] = newnums[i];\\n        }\\n    }\\n}\\n```\\n\\n=======also can sort the array in desc order\\n![image](https://assets.leetcode.com/users/images/9819cbcb-2a33-4272-904c-e9546b806966_1640998565.1927898.png)\\n\\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        reverse(nums);\\n        int[] newnums = new int[nums.length];\\n        int k = 0;\\n        int s = 0;\\n        int e = nums.length  / 2;\\n        \\n        while(k < nums.length){\\n            if(k % 2 == 0){\\n                newnums[k++] = nums[e++];\\n            }else{\\n                newnums[k++] = nums[s++];\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            nums[i] = newnums[i];\\n        }\\n    }\\n    private void reverse(int[] nums){\\n        int s = 0;\\n        int e = nums.length - 1;\\n        while(s < e){\\n            int t = nums[s];\\n            nums[s] = nums[e];\\n            nums[e] = t;\\n            s++;\\n            e--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] newnums = new int[nums.length];\\n        int k = 0;\\n        int s = (nums.length + 1) / 2 - 1;\\n        int e = nums.length - 1;\\n        \\n        while(k < nums.length){\\n            if(k % 2 == 0){\\n                newnums[k++] = nums[s--];\\n            }else{\\n                newnums[k++] = nums[e--];\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            nums[i] = newnums[i];\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        reverse(nums);\\n        int[] newnums = new int[nums.length];\\n        int k = 0;\\n        int s = 0;\\n        int e = nums.length  / 2;\\n        \\n        while(k < nums.length){\\n            if(k % 2 == 0){\\n                newnums[k++] = nums[e++];\\n            }else{\\n                newnums[k++] = nums[s++];\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            nums[i] = newnums[i];\\n        }\\n    }\\n    private void reverse(int[] nums){\\n        int s = 0;\\n        int e = nums.length - 1;\\n        while(s < e){\\n            int t = nums[s];\\n            nums[s] = nums[e];\\n            nums[e] = t;\\n            s++;\\n            e--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624720,
                "title": "t-o-nlogn-s-o-n-simple-concise-solution",
                "content": "1. First lets sort the array and instantiate a target array\\n1. We iterate from the back of the sorted array and fill up the target array starting from index=1.\\n1. In the target array, we jump index by 2 in each iteration. On reaching the end of the target array, we reset index back to 0.\\n\\nLet\\'s say the sorted array is like this [a b c d e f] and target is [. . . . . .]\\nHere\\'s how we fill it\\n[. f . . . .]\\n[. f . e . .]\\n[. f . e . d]\\n[c f . e . d]\\n[c f b e . d]\\n[c f b e a d]\\n\\nSince the initial array is sorted, we are assured that [c < f > b < e > a < d]\\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        if(nums.length < 2) {\\n            return;\\n        }\\n        Arrays.sort(nums);\\n        int[] ans = new int[nums.length];\\n        int j = 1;\\n        for(int i = nums.length - 1; i >= 0; i--) {\\n            //System.out.printf(\"ans=%s i=%d%n\", Arrays.toString(ans), i);\\n            ans[j] = nums[i];\\n            j = j + 2;\\n            if(j >= nums.length) {\\n                j = 0;\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++) {\\n            nums[i] = ans[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        if(nums.length < 2) {\\n            return;\\n        }\\n        Arrays.sort(nums);\\n        int[] ans = new int[nums.length];\\n        int j = 1;\\n        for(int i = nums.length - 1; i >= 0; i--) {\\n            //System.out.printf(\"ans=%s i=%d%n\", Arrays.toString(ans), i);\\n            ans[j] = nums[i];\\n            j = j + 2;\\n            if(j >= nums.length) {\\n                j = 0;\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++) {\\n            nums[i] = ans[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012411,
                "title": "javascript-simple-solution-using-extra-o-n-space-with-sort-time-complexity-o-nlgn",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nconst wiggleSort = (nums) => {\\n    nums.sort((a , b) => a - b);\\n    const tmp = [...nums];\\n    let low = Math.floor((nums.length - 1)/2);\\n    let high = nums.length -1;\\n    for(let i = 0; i < nums.length; i++) {\\n        if(i % 2 === 0) {\\n            nums[i] = tmp[low];\\n            low--;\\n        } else {\\n            nums[i] = tmp[high];\\n            high--;\\n        }\\n    }\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nconst wiggleSort = (nums) => {\\n    nums.sort((a , b) => a - b);\\n    const tmp = [...nums];\\n    let low = Math.floor((nums.length - 1)/2);\\n    let high = nums.length -1;\\n    for(let i = 0; i < nums.length; i++) {\\n        if(i % 2 === 0) {\\n            nums[i] = tmp[low];\\n            low--;\\n        } else {\\n            nums[i] = tmp[high];\\n            high--;\\n        }\\n    }\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 125429,
                "title": "python-solution-with-virtual-indexing",
                "content": "```\\nclass Solution(object):\\n    def wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if len(nums) == 1:\\n            return\\n        n = len(nums)\\n\\n        # Index-rewiring.\\n        f = lambda i:(1+2*(i)) % (n|1)\\n        \\n        mid = self.quickselect(0, len(nums) - 1, nums, len(nums) / 2)\\n        \\n        # 3 way partition\\n        i, j, k = 0, 0, n-1\\n\\n        while j <= k:\\n            if (nums[f(j)] > mid):\\n                nums[f(i)], nums[f(j)] = nums[f(j)], nums[f(i)]\\n                i += 1\\n                j += 1\\n            elif nums[f(j)] < mid:\\n                nums[f(j)], nums[f(k)] = nums[f(k)], nums[f(j)]\\n                k -= 1\\n            else:\\n                j += 1\\n\\n        print nums\\n\\n    def quickselect(self, start, end, A, k):\\n        if start == end:\\n            return A[start]\\n            \\n        mid = self.partition(start, end, A)\\n        \\n        if mid == k:\\n            return A[k]\\n        elif mid > k:\\n            return self.quickselect(start, mid - 1, A, k)\\n        else:\\n            return self.quickselect(mid + 1, end, A, k)\\n        \\n    def partition(self, start, end, A):\\n        pivotIndex = random.randrange(start, end + 1)\\n        pivot = A[pivotIndex]\\n        A[end], A[pivotIndex] = A[pivotIndex], A[end]\\n        mid = start\\n        for i in xrange(start, end):\\n            if A[i] >= pivot:\\n                A[mid], A[i] = A[i], A[mid]\\n                mid += 1\\n        A[mid], A[end] = A[end], A[mid]\\n        return mid\\n \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if len(nums) == 1:\\n            return\\n        n = len(nums)\\n\\n        # Index-rewiring.\\n        f = lambda i:(1+2*(i)) % (n|1)\\n        \\n        mid = self.quickselect(0, len(nums) - 1, nums, len(nums) / 2)\\n        \\n        # 3 way partition\\n        i, j, k = 0, 0, n-1\\n\\n        while j <= k:\\n            if (nums[f(j)] > mid):\\n                nums[f(i)], nums[f(j)] = nums[f(j)], nums[f(i)]\\n                i += 1\\n                j += 1\\n            elif nums[f(j)] < mid:\\n                nums[f(j)], nums[f(k)] = nums[f(k)], nums[f(j)]\\n                k -= 1\\n            else:\\n                j += 1\\n\\n        print nums\\n\\n    def quickselect(self, start, end, A, k):\\n        if start == end:\\n            return A[start]\\n            \\n        mid = self.partition(start, end, A)\\n        \\n        if mid == k:\\n            return A[k]\\n        elif mid > k:\\n            return self.quickselect(start, mid - 1, A, k)\\n        else:\\n            return self.quickselect(mid + 1, end, A, k)\\n        \\n    def partition(self, start, end, A):\\n        pivotIndex = random.randrange(start, end + 1)\\n        pivot = A[pivotIndex]\\n        A[end], A[pivotIndex] = A[pivotIndex], A[end]\\n        mid = start\\n        for i in xrange(start, end):\\n            if A[i] >= pivot:\\n                A[mid], A[i] = A[i], A[mid]\\n                mid += 1\\n        A[mid], A[end] = A[end], A[mid]\\n        return mid\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 77720,
                "title": "o-n-time-o-n-space-it-s-easy-to-understand",
                "content": "\\n\\n    public void wiggleSort(int[] nums) {\\n        int median=findKthLargest(nums,(nums.length+1)/2);\\n        int odd=1;\\n        int even=nums.length%2==0?nums.length-2:nums.length-1;\\n        int[] tmpArr=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>median){\\n                tmpArr[odd]=nums[i];\\n                odd+=2;\\n                continue;\\n            }\\n            if(nums[i]<median){\\n                tmpArr[even]=nums[i];\\n                even-=2;\\n                continue;\\n            }\\n        }\\n        while(odd<nums.length){\\n            tmpArr[odd]=median;\\n            odd+=2;\\n        }\\n        while(even>=0){\\n            tmpArr[even]=median;\\n            even-=2;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=tmpArr[i];\\n        }\\n    }",
                "solutionTags": [],
                "code": "\\n\\n    public void wiggleSort(int[] nums) {\\n        int median=findKthLargest(nums,(nums.length+1)/2);\\n        int odd=1;\\n        int even=nums.length%2==0?nums.length-2:nums.length-1;\\n        int[] tmpArr=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>median){\\n                tmpArr[odd]=nums[i];\\n                odd+=2;\\n                continue;\\n            }\\n            if(nums[i]<median){\\n                tmpArr[even]=nums[i];\\n                even-=2;\\n                continue;\\n            }\\n        }\\n        while(odd<nums.length){\\n            tmpArr[odd]=median;\\n            odd+=2;\\n        }\\n        while(even>=0){\\n            tmpArr[even]=median;\\n            even-=2;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=tmpArr[i];\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 77711,
                "title": "o-n-time-and-cheating-o-1-space-solution-will-there-be-a-real-o-1-solution",
                "content": "    class Solution {\\n    public:\\n        void wiggleSort(vector<int>& nums) {\\n            // Only four Line\\n            if (2>(n = nums.size())) return;\\n            r_start = n/2;\\n            dfs(nums, find_medin(nums));\\n            re_order(nums);\\n        }\\n    private:\\n        int n;\\n        int r_start;\\n            int pivot(vector<int> &nums, int i, int j) {\\n            assert(i<j);\\n            swap(nums[i],nums[(i+j)/2]);\\n            int idx = i++;\\n            int val = nums[idx];\\n            while (i<j) {\\n                if (nums[i]<=val) i++;\\n                else if (nums[j]>=val) j--;\\n                else swap(nums[i],nums[j]);\\n            }\\n            if (nums[i]>val) i--;\\n            if (nums[i] != nums[idx]) swap(nums[i], nums[idx]);\\n            return i;\\n        }\\n        \\n        double find_kth(vector<int> &nums, int k) {\\n            int i = 0, j = n-1;\\n            while (i<j) {\\n                int m = pivot(nums,i,j);\\n                int len = m-i+1;\\n                if (k<len) {\\n                    j = m-1;\\n                } else if (k>len) {\\n                    k-=len;\\n                    i = m+1;\\n                } else {\\n                    return nums[m];\\n                }\\n            }\\n            return nums[i];\\n        }\\n        \\n        double find_medin(vector<int> &nums) {\\n            if (n&1) {\\n                return find_kth(nums, 1+(n>>1));\\n            } else {\\n                return (find_kth(nums,n>>1) + find_kth(nums, 1+(n>>1)))/2;\\n            }\\n        }\\n        \\n        //Dutch Flag Srot (reversed order)\\n        void dfs(vector<int> &nums, double target) {\\n            int i = 0, j = n-1, k = 0;\\n            while (k<=j) {\\n                if (nums[k]>target) {\\n                    swap(nums[i++], nums[k++]);\\n                } else if (nums[k] < target) {\\n                    swap(nums[j--], nums[k]);\\n                } else {\\n                    k++;\\n                }\\n            }\\n        }\\n    \\n        int get_next(int i) {\\n            if (i>=r_start) return (i-r_start)<<1;\\n            else return 1+(i<<1);\\n        }\\n        // giving up to think a legitimate O(1) space solution.\\n        // cheat by using a mask to show whether it has \\n        // been visited or not. This sub-problem is much harder compare\\n        // to array rotation, I cannot use a count and increase\\n        // the start by one whenever count < limit.\\n        void re_order(vector<int> & nums) {\\n            for (int mask = 1<<30, i, temp, start=0; start<n; ++start) {\\n                if (!(nums[start] & mask)) {\\n                    temp = nums[i = start];\\n                    do {swap(temp|=mask, nums[i=get_next(i)]);} while (i!=start);\\n                }\\n                nums[start] ^= mask;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void wiggleSort(vector<int>& nums) {\\n            // Only four Line\\n            if (2>(n = nums.size())) return;\\n            r_start = n/2;\\n            dfs(nums, find_medin(nums));\\n            re_order(nums);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2870136,
                "title": "java-easy-to-understand-code",
                "content": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int[] arr = nums.clone();\\n        Arrays.sort(arr);\\n        int n = nums.length;\\n        int i = (n - 1) >> 1, j = n - 1;\\n        for (int x = 0; x < n; ++x) {\\n            if (x % 2 == 0) {\\n                nums[x] = arr[i--];\\n            } else {\\n                nums[x] = arr[j--];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int[] arr = nums.clone();\\n        Arrays.sort(arr);\\n        int n = nums.length;\\n        int i = (n - 1) >> 1, j = n - 1;\\n        for (int x = 0; x < n; ++x) {\\n            if (x % 2 == 0) {\\n                nums[x] = arr[i--];\\n            } else {\\n                nums[x] = arr[j--];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223304,
                "title": "o-n-time-and-constant-space-using-count-sort-very-simple",
                "content": "- Value Range between 0 and 5000.\\n- Populate the buckets based on available values.\\n- Start Iterating from the end and populate the even places with values.\\n- Then populate the odd places.\\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        //0 <= nums[i] <= 5000\\n        //min = 0, max = 5000\\n        //fill max available value on even positions then on odd positions\\n        \\n        int[] bucket = new int[5001];\\n        \\n        for(int i: nums)\\n            bucket[i]++;\\n        \\n        int max = 5000;\\n        boolean firstPass = true;\\n        for(int i = 1 ; i < nums.length; i+=2){\\n            \\n            \\n            while(bucket[max] == 0)\\n                max--;\\n            \\n            nums[i] = max;\\n            bucket[max]--;\\n            \\n            \\n            if(firstPass && i+2 >= nums.length){\\n                i = -2; // want to set i = 0 but since at the end it does i+2 so making it i = -2 to get resultant = 0\\n                firstPass = false;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        //0 <= nums[i] <= 5000\\n        //min = 0, max = 5000\\n        //fill max available value on even positions then on odd positions\\n        \\n        int[] bucket = new int[5001];\\n        \\n        for(int i: nums)\\n            bucket[i]++;\\n        \\n        int max = 5000;\\n        boolean firstPass = true;\\n        for(int i = 1 ; i < nums.length; i+=2){\\n            \\n            \\n            while(bucket[max] == 0)\\n                max--;\\n            \\n            nums[i] = max;\\n            bucket[max]--;\\n            \\n            \\n            if(firstPass && i+2 >= nums.length){\\n                i = -2; // want to set i = 0 but since at the end it does i+2 so making it i = -2 to get resultant = 0\\n                firstPass = false;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054330,
                "title": "python-o-n-time-and-space-o-1-space-with-thought-process",
                "content": "Both solutions will take the following form:\\n```\\ndef wiggleSort(self, nums: List[int]) -> None:\\n\\t\"\"\"\\n\\tDo not return anything, modify nums in-place instead.\\n\\t\"\"\"\\n\\tmedian = select_median(nums, median)\\n\\twiggle_array(nums, median)\\n```\\n\\nThe purpose of the select functions is not actually to select the median, but to partially sort the `nums` as we do in the classic quickselect algorithm.\\n\\nThe `O(n)` space algorithm for wiggling the partially sorted array is pretty straight forward. Note that `bot` indicates the insertion point in the target array.\\n```\\ndef wiggle_array(nums, median): # note that in this implementation we don\\'t actually use the median\\n    result = [-1]*len(nums)\\n    bot = 1 # start by populating the odd entries\\n    for i in range(len(nums) - 1, -1, -1):\\n        if bot >= len(nums): # odd numbers exhausted\\n            bot = 0 # start populating even entries\\n\\n        result[bot] = nums[i]\\n        bot += 2\\n\\n\\t# copy result to nums\\n    for i in range(len(result)):\\n        nums[i] = result[i] \\n```\\n\\n\\nTo get an `O(1)` space implementation we may look at the classic three color sort algorithm also used in our select algorithm:\\n```\\ndef three_color_sort(nums, pivot, bot, top):\\n    mid = bot\\n    \\n    while mid <= top:\\n        if nums[mid] < pivot:\\n            nums[bot], nums[mid] = nums[mid], nums[bot]\\n            bot += 1\\n            mid += 1\\n        \\n        elif nums[mid] == pivot:\\n            mid += 1\\n        \\n        else:\\n            nums[top], nums[mid] = nums[mid], nums[top]\\n            top -= 1\\n```\\n\\nAnd try mimicking it to construct our wiggle array: [this is a good point to consider trying the rest of the task yourself]\\nWe can do this by using a mapping function for the list indices. The following mapping function `f` does the job:\\nFirst, to populate our odd numbers: `f(n - 1) = 1   ,   f(n - 2) = 3   ,   ...   ,   f(n - i) = 2*i - 1`. This implies `f(i) = 2*(n - i) - 1`, which further implies `n - 1 < 2*i`.\\nSecond, to populate our even numbers: `f(0) = n - 1 - ((n - 1) % 2 != 0)   ,   f(1) = n - 3 - ((n - 3) % 2 != 0)   ,   ...   ,   f(i) = n - 2*i - 1 - ((n - 2*i - 1) % 2 != 0)`. Which implies `2*i <= n - 1`.\\n\\nThis given us the `O(1)` space solution:\\n```\\ndef wiggle_array(nums, median):\\n    n = len(nums)\\n\\n    bot = mid = 0\\n    top = n - 1\\n    \\n    f = lambda x: 2*(n - x) - 1 if 2*x > n - 1 else n - 2*x - 1 - ((n - 2*x - 1) %2 != 0)\\n\\n    while mid <= top:\\n        if nums[f(mid)] < median:\\n            nums[f(bot)], nums[f(mid)] = nums[f(mid)], nums[f(bot)]\\n            bot += 1\\n            mid += 1\\n        \\n        elif nums[f(mid)] == median:\\n            mid += 1\\n        \\n        else:\\n            nums[f(top)], nums[f(mid)] = nums[f(mid)], nums[f(top)]\\n            top -= 1\\n```\\n\\nThe rest of the solution is two functions needed to complete the median selection part.\\n```\\nfrom random import randrange\\n\\ndef get_pivot(nums, bot, top):\\n    return sorted([nums[randrange(bot, top + 1)] for _ in range(3)])[1]\\n\\ndef select_median(nums):\\n    bot = 0\\n    top = len(nums) - 1\\n    median = (bot + top) // 2\\n    while True:\\n        pivot = get_pivot(nums, bot, top)\\n        pivot_bot, pivot_top = three_color_sort(nums, pivot, bot, top)\\n        \\n        if pivot_bot <= median <= pivot_top:\\n            return pivot\\n        \\n        elif median < pivot_bot:\\n            top = pivot_bot - 1\\n        \\n        else:\\n            bot = pivot_top + 1\\n```\\n\\nThanks for reading.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef wiggleSort(self, nums: List[int]) -> None:\\n\\t\"\"\"\\n\\tDo not return anything, modify nums in-place instead.\\n\\t\"\"\"\\n\\tmedian = select_median(nums, median)\\n\\twiggle_array(nums, median)\\n```\n```\\ndef wiggle_array(nums, median): # note that in this implementation we don\\'t actually use the median\\n    result = [-1]*len(nums)\\n    bot = 1 # start by populating the odd entries\\n    for i in range(len(nums) - 1, -1, -1):\\n        if bot >= len(nums): # odd numbers exhausted\\n            bot = 0 # start populating even entries\\n\\n        result[bot] = nums[i]\\n        bot += 2\\n\\n\\t# copy result to nums\\n    for i in range(len(result)):\\n        nums[i] = result[i] \\n```\n```\\ndef three_color_sort(nums, pivot, bot, top):\\n    mid = bot\\n    \\n    while mid <= top:\\n        if nums[mid] < pivot:\\n            nums[bot], nums[mid] = nums[mid], nums[bot]\\n            bot += 1\\n            mid += 1\\n        \\n        elif nums[mid] == pivot:\\n            mid += 1\\n        \\n        else:\\n            nums[top], nums[mid] = nums[mid], nums[top]\\n            top -= 1\\n```\n```\\ndef wiggle_array(nums, median):\\n    n = len(nums)\\n\\n    bot = mid = 0\\n    top = n - 1\\n    \\n    f = lambda x: 2*(n - x) - 1 if 2*x > n - 1 else n - 2*x - 1 - ((n - 2*x - 1) %2 != 0)\\n\\n    while mid <= top:\\n        if nums[f(mid)] < median:\\n            nums[f(bot)], nums[f(mid)] = nums[f(mid)], nums[f(bot)]\\n            bot += 1\\n            mid += 1\\n        \\n        elif nums[f(mid)] == median:\\n            mid += 1\\n        \\n        else:\\n            nums[f(top)], nums[f(mid)] = nums[f(mid)], nums[f(top)]\\n            top -= 1\\n```\n```\\nfrom random import randrange\\n\\ndef get_pivot(nums, bot, top):\\n    return sorted([nums[randrange(bot, top + 1)] for _ in range(3)])[1]\\n\\ndef select_median(nums):\\n    bot = 0\\n    top = len(nums) - 1\\n    median = (bot + top) // 2\\n    while True:\\n        pivot = get_pivot(nums, bot, top)\\n        pivot_bot, pivot_top = three_color_sort(nums, pivot, bot, top)\\n        \\n        if pivot_bot <= median <= pivot_top:\\n            return pivot\\n        \\n        elif median < pivot_bot:\\n            top = pivot_bot - 1\\n        \\n        else:\\n            bot = pivot_top + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1412658,
                "title": "c-using-sorting-t-c-o-nlog-n-o-n-s-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> res(n);\\n        \\n        int i=1,j=n-1;\\n        while(j>=0){\\n            if(i>=n) i=0;\\n            res[i]=nums[j];\\n            j--;\\n            i+=2;\\n        }\\n        \\n        for(int i=0;i<n;++i) nums[i]=res[i];\\n        return;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> res(n);\\n        \\n        int i=1,j=n-1;\\n        while(j>=0){\\n            if(i>=n) i=0;\\n            res[i]=nums[j];\\n            j--;\\n            i+=2;\\n        }\\n        \\n        for(int i=0;i<n;++i) nums[i]=res[i];\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068105,
                "title": "easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        vector<int> tmp=nums;\\n        sort(tmp.begin(),tmp.end());\\n        int x=nums.size()/2;\\n        int y=nums.size()-x;\\n        \\n        int i=1,k=nums.size()-1;\\n        while(x--){\\n            nums[i]=tmp[k--];\\n            i+=2;\\n        }\\n        \\n        i=0;\\n        while(y--){\\n            nums[i]=tmp[k--];\\n            i+=2;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        vector<int> tmp=nums;\\n        sort(tmp.begin(),tmp.end());\\n        int x=nums.size()/2;\\n        int y=nums.size()-x;\\n        \\n        int i=1,k=nums.size()-1;\\n        while(x--){\\n            nums[i]=tmp[k--];\\n            i+=2;\\n        }\\n        \\n        i=0;\\n        while(y--){\\n            nums[i]=tmp[k--];\\n            i+=2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055496,
                "title": "o-nlogn-o-1-c-code-using-and-technique",
                "content": "```\\n#define mod 6000\\n\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& A ) {\\n        \\n        int N = A.size() ;\\n        sort( A.begin() , A.end() );\\n        int l = (N-1)/2 ;\\n        int h = N-1 ; \\n    \\n        for( int i = 0 ; i < N ; i++ )\\n        {\\n            if( !(i&1) ) A[i] = A[i] + (A[l--]%mod)*mod;\\n            else A[i] = A[i] + (A[h--]%mod)*mod; \\n        }\\n        for( auto &x : A ) x /= mod ; \\n    }\\n};\\n\\n```\\n\\nPS -\\ntime complexity   -- NlogN \\nspace complexity -- O(1) \\n\\n",
                "solutionTags": [],
                "code": "```\\n#define mod 6000\\n\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& A ) {\\n        \\n        int N = A.size() ;\\n        sort( A.begin() , A.end() );\\n        int l = (N-1)/2 ;\\n        int h = N-1 ; \\n    \\n        for( int i = 0 ; i < N ; i++ )\\n        {\\n            if( !(i&1) ) A[i] = A[i] + (A[l--]%mod)*mod;\\n            else A[i] = A[i] + (A[h--]%mod)*mod; \\n        }\\n        for( auto &x : A ) x /= mod ; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933799,
                "title": "python3-compact-sort-solution",
                "content": "```\\ndef wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        tmp = sorted(nums)\\n        mid = (len(nums) + 1) // 2\\n        nums[0::2] = tmp[:mid][::-1]\\n        nums[1::2] = tmp[mid:][::-1]\\n            \\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\ndef wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        tmp = sorted(nums)\\n        mid = (len(nums) + 1) // 2\\n        nums[0::2] = tmp[:mid][::-1]\\n        nums[1::2] = tmp[mid:][::-1]\\n            \\n        return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 484552,
                "title": "c-simple-o-n-time-and-o-1-space-solution-using-partitioning-detailed-explanation",
                "content": "```\\n// TC: avg O(N)\\nvoid wiggleSort(vector<int>& nums) {\\n\\tif(nums.size() <= 1)\\n\\t\\treturn;\\n\\n\\t// find the median element\\n\\tconst int N = nums.size();\\n\\t// since K in partition algo is 0-indexed, so for odd numbers if we want middle of floor(N/2), add 1\\n\\tconst int median_idx = N % 2 != 0 ? N/2 + 1 : N/2;\\n\\n\\t// place the elements greater than median at odd positions\\n\\t// place the elements smaller than median at even positions\\n\\tint median_val = kthLargestPartition(nums, median_idx);\\n\\n\\t// After partitioning the array can be(not always) like this: smaller_median | equal_median | greater_median\\n\\t// Now with that, we need to place the greater numbers at all the odd positions and smaller ones\\n\\t// at even positions, the problem is with numbers equal to median, they need to be put apart from each other\\n\\t// So just like Dutch Flag problem, we use three pointers, one will be used for writing smaller and other for larger\\n\\t// than median elements. The third one will be for traversing the array.\\n\\t// We start traversing from left and index for writing larger starts from right, so in time we will start moving the\\n\\t// equal elements at even indices towards left for the larger odd positions and for equal elements\\n\\t// at odd positions will be moved to even positions towards right, making the qual separated.\\n\\n\\t// writes the larger numbers at each odd position \\n\\tint greater_odd = 1;\\n\\t// writes the smaller number at each even position\\n\\tint smaller_even =  N % 2 == 0 ? N - 2 : N - 1; \\n\\tfor(int i = 0; i < N;) {\\n\\t\\t// smaller element at odd position or anything before currently processed\\n\\t\\t// smaller writer index\\n\\t\\tif(nums[i] < median_val && (i < smaller_even || (i % 2 != 0))) {\\n\\t\\t\\tswap(nums[smaller_even], nums[i]);\\n\\t\\t\\tsmaller_even -= 2;\\n\\t\\t}\\n\\t\\t// greater value at even position or anything after currently processed\\n\\t\\t// greater writer index\\n\\t\\telse if(nums[i] > median_val && (i > greater_odd || (i % 2 == 0))) {\\n\\t\\t\\tswap(nums[greater_odd], nums[i]);\\n\\t\\t\\tgreater_odd += 2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\t++i;\\n\\t}\\n}\\n```\\n\\n**Partition Algorithm used:**\\n```\\n// Partition the array\\n// TC: O(N), SC: O(1)\\ntemplate<typename Comparator>\\nint partitionArray(vector<int>& arr, int pivot_idx, int l, int r, Comparator comp) {\\n\\tint pivot_val = arr[pivot_idx];\\n\\t// index where the elements will be written\\n\\tint write_idx = l;\\n\\n\\tif(l <= r) {\\n\\t\\t// swap the pivot with the last element\\n\\t\\tswap(arr[pivot_idx], arr[r]);\\n\\t\\t// place all smaller values on left and larger values on right\\n\\t\\tfor(int i = l; i < r; i++) {\\n\\t\\t\\t// Use the comparator to decide what kind of element should go to left\\n\\t\\t\\tif(comp(arr[i], pivot_val))\\n\\t\\t\\t\\tswap(arr[write_idx++], arr[i]);\\n\\t\\t}\\n\\t\\t// place the pivot at its correct position\\n\\t\\tswap(arr[write_idx], arr[r]);\\n\\t}\\n\\treturn write_idx;\\n}\\n\\n// Using partitioning algorithm, k is 0 indexed\\n// Avg TC: O(N)\\n// Worst case TC: O(N^2)\\nint kthLargestPartition(vector<int>& arr, int k) {\\n\\t// random number generator\\n\\tdefault_random_engine gen((random_device())());\\n\\n\\tint l = 0, r = arr.size() - 1;\\n\\twhile(l <= r) {\\n\\t\\t// generate a random index in [l, r]\\n\\t\\tint pivot_idx = uniform_int_distribution<int>{l, r}(gen);    \\n\\t\\t// partition the array wrt pivot element\\n\\t\\tint partition_idx = partitionArray(arr, pivot_idx, l, r, less<>());\\n\\t\\t// if the pivot is the kth element return\\n\\t\\tif(partition_idx == k-1)\\n\\t\\t\\treturn arr[partition_idx];\\n\\t\\t// if pivot index is greater than k, go to left side of pivot\\n\\t\\telse if(partition_idx < k)\\n\\t\\t\\tl = partition_idx + 1;\\n\\t\\t// if pivot index is smaller than k, go to right side of pivot\\n\\t\\telse\\n\\t\\t\\tr = partition_idx - 1;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// TC: avg O(N)\\nvoid wiggleSort(vector<int>& nums) {\\n\\tif(nums.size() <= 1)\\n\\t\\treturn;\\n\\n\\t// find the median element\\n\\tconst int N = nums.size();\\n\\t// since K in partition algo is 0-indexed, so for odd numbers if we want middle of floor(N/2), add 1\\n\\tconst int median_idx = N % 2 != 0 ? N/2 + 1 : N/2;\\n\\n\\t// place the elements greater than median at odd positions\\n\\t// place the elements smaller than median at even positions\\n\\tint median_val = kthLargestPartition(nums, median_idx);\\n\\n\\t// After partitioning the array can be(not always) like this: smaller_median | equal_median | greater_median\\n\\t// Now with that, we need to place the greater numbers at all the odd positions and smaller ones\\n\\t// at even positions, the problem is with numbers equal to median, they need to be put apart from each other\\n\\t// So just like Dutch Flag problem, we use three pointers, one will be used for writing smaller and other for larger\\n\\t// than median elements. The third one will be for traversing the array.\\n\\t// We start traversing from left and index for writing larger starts from right, so in time we will start moving the\\n\\t// equal elements at even indices towards left for the larger odd positions and for equal elements\\n\\t// at odd positions will be moved to even positions towards right, making the qual separated.\\n\\n\\t// writes the larger numbers at each odd position \\n\\tint greater_odd = 1;\\n\\t// writes the smaller number at each even position\\n\\tint smaller_even =  N % 2 == 0 ? N - 2 : N - 1; \\n\\tfor(int i = 0; i < N;) {\\n\\t\\t// smaller element at odd position or anything before currently processed\\n\\t\\t// smaller writer index\\n\\t\\tif(nums[i] < median_val && (i < smaller_even || (i % 2 != 0))) {\\n\\t\\t\\tswap(nums[smaller_even], nums[i]);\\n\\t\\t\\tsmaller_even -= 2;\\n\\t\\t}\\n\\t\\t// greater value at even position or anything after currently processed\\n\\t\\t// greater writer index\\n\\t\\telse if(nums[i] > median_val && (i > greater_odd || (i % 2 == 0))) {\\n\\t\\t\\tswap(nums[greater_odd], nums[i]);\\n\\t\\t\\tgreater_odd += 2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\t++i;\\n\\t}\\n}\\n```\n```\\n// Partition the array\\n// TC: O(N), SC: O(1)\\ntemplate<typename Comparator>\\nint partitionArray(vector<int>& arr, int pivot_idx, int l, int r, Comparator comp) {\\n\\tint pivot_val = arr[pivot_idx];\\n\\t// index where the elements will be written\\n\\tint write_idx = l;\\n\\n\\tif(l <= r) {\\n\\t\\t// swap the pivot with the last element\\n\\t\\tswap(arr[pivot_idx], arr[r]);\\n\\t\\t// place all smaller values on left and larger values on right\\n\\t\\tfor(int i = l; i < r; i++) {\\n\\t\\t\\t// Use the comparator to decide what kind of element should go to left\\n\\t\\t\\tif(comp(arr[i], pivot_val))\\n\\t\\t\\t\\tswap(arr[write_idx++], arr[i]);\\n\\t\\t}\\n\\t\\t// place the pivot at its correct position\\n\\t\\tswap(arr[write_idx], arr[r]);\\n\\t}\\n\\treturn write_idx;\\n}\\n\\n// Using partitioning algorithm, k is 0 indexed\\n// Avg TC: O(N)\\n// Worst case TC: O(N^2)\\nint kthLargestPartition(vector<int>& arr, int k) {\\n\\t// random number generator\\n\\tdefault_random_engine gen((random_device())());\\n\\n\\tint l = 0, r = arr.size() - 1;\\n\\twhile(l <= r) {\\n\\t\\t// generate a random index in [l, r]\\n\\t\\tint pivot_idx = uniform_int_distribution<int>{l, r}(gen);    \\n\\t\\t// partition the array wrt pivot element\\n\\t\\tint partition_idx = partitionArray(arr, pivot_idx, l, r, less<>());\\n\\t\\t// if the pivot is the kth element return\\n\\t\\tif(partition_idx == k-1)\\n\\t\\t\\treturn arr[partition_idx];\\n\\t\\t// if pivot index is greater than k, go to left side of pivot\\n\\t\\telse if(partition_idx < k)\\n\\t\\t\\tl = partition_idx + 1;\\n\\t\\t// if pivot index is smaller than k, go to right side of pivot\\n\\t\\telse\\n\\t\\t\\tr = partition_idx - 1;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 121736,
                "title": "only-one-step-quick-selection-with-virtual-indexing-average-o-n-in-time-and-o-1-in-space",
                "content": "I\\'m inspired by the solution of @stefanpochmann at [https://leetcode.com/problems/wiggle-sort-ii/discuss/77677/O(n)+O(1)-after-median-Virtual-Indexing] and then optimized it.\\n\\nThe original solution takes two steps:\\n\\t1. Get the median of the input list/array\\n\\t2. Do the wiggle sort by three-way partitioning according to the median\\n\\nActually, we can do it in **only one step** because in-place swappings happen in the input list/array throughout the process of calculating the median by quick selection and the original list/array will be finally divided into 3 parts (numbers greater than the median, numbers equal to the median, numbers less than the median). So, if we do the quick selection by the virtual indexing instead of the original indexing, we will end up with wigglely sorted list/array.\\n\\nBelow is my Python code. Initially, I did the quick selection in the naive single pivot, but it errored out due to TLE. Then I applied the 3-way-partition, and it runs much faster. Any suggestion is more than welcome. Thanks!\\n```\\nclass Solution(object):    \\n    def wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if not nums:\\n            return []\\n\\n        srt = 0\\n        end = limit = len(nums)\\n        target = end / 2\\n        div = limit | 1\\n\\n        while True:\\n            left_wall = srt\\n            right_wall = end - 1\\n            temp_left_wall = temp_srt = (srt * 2 + 1) % div\\n            pivot = nums[temp_srt]\\n            idx = srt + 1\\n\\n            while idx <= right_wall:\\n                temp_idx = (idx * 2 + 1) % div\\n\\n                if nums[temp_idx] > pivot:\\n                    left_wall += 1\\n                    temp_left_wall = (left_wall * 2 + 1) % div\\n                    nums[temp_idx], nums[temp_left_wall] = nums[temp_left_wall], nums[temp_idx]\\n                elif nums[temp_idx] < pivot:\\n                    while right_wall >= idx and nums[(right_wall * 2 + 1) % div] < pivot:\\n                        right_wall -= 1\\n\\n                    temp_right_wall = (right_wall * 2 + 1) % div\\n\\n                    if nums[temp_right_wall] == pivot:\\n                        nums[temp_idx], nums[temp_right_wall] = nums[temp_right_wall], nums[temp_idx]\\n                    else:\\n                        left_wall += 1\\n                        temp_left_wall = (left_wall * 2 + 1) % div\\n                        nums[temp_left_wall], nums[temp_idx] = nums[temp_idx], nums[temp_left_wall]\\n                        nums[temp_left_wall], nums[temp_right_wall] = nums[temp_right_wall], nums[temp_left_wall]\\n                        \\n                    right_wall -= 1\\n                else:\\n                    pass\\n\\n                idx += 1\\n\\n            nums[temp_srt], nums[temp_left_wall] = nums[temp_left_wall], nums[temp_srt]\\n\\n            if right_wall < target:\\n                srt = right_wall + 1\\n            elif left_wall > target:\\n                end = left_wall\\n            else:\\n                break\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):    \\n    def wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if not nums:\\n            return []\\n\\n        srt = 0\\n        end = limit = len(nums)\\n        target = end / 2\\n        div = limit | 1\\n\\n        while True:\\n            left_wall = srt\\n            right_wall = end - 1\\n            temp_left_wall = temp_srt = (srt * 2 + 1) % div\\n            pivot = nums[temp_srt]\\n            idx = srt + 1\\n\\n            while idx <= right_wall:\\n                temp_idx = (idx * 2 + 1) % div\\n\\n                if nums[temp_idx] > pivot:\\n                    left_wall += 1\\n                    temp_left_wall = (left_wall * 2 + 1) % div\\n                    nums[temp_idx], nums[temp_left_wall] = nums[temp_left_wall], nums[temp_idx]\\n                elif nums[temp_idx] < pivot:\\n                    while right_wall >= idx and nums[(right_wall * 2 + 1) % div] < pivot:\\n                        right_wall -= 1\\n\\n                    temp_right_wall = (right_wall * 2 + 1) % div\\n\\n                    if nums[temp_right_wall] == pivot:\\n                        nums[temp_idx], nums[temp_right_wall] = nums[temp_right_wall], nums[temp_idx]\\n                    else:\\n                        left_wall += 1\\n                        temp_left_wall = (left_wall * 2 + 1) % div\\n                        nums[temp_left_wall], nums[temp_idx] = nums[temp_idx], nums[temp_left_wall]\\n                        nums[temp_left_wall], nums[temp_right_wall] = nums[temp_right_wall], nums[temp_left_wall]\\n                        \\n                    right_wall -= 1\\n                else:\\n                    pass\\n\\n                idx += 1\\n\\n            nums[temp_srt], nums[temp_left_wall] = nums[temp_left_wall], nums[temp_srt]\\n\\n            if right_wall < target:\\n                srt = right_wall + 1\\n            elif left_wall > target:\\n                end = left_wall\\n            else:\\n                break\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77759,
                "title": "o-n-time-solution-with-median-found-with-quick-selection",
                "content": "First step is to figure out the median with quick selection.\\nThen create two arrays with the first half part and second half part of the origin array.\\nThe last part is to fill nums[2*i] with firstHalf[i], fill nuts[2*i + 1] with secondHalf[secondHalf.length - i - 1].\\n\\nAs @jwangmcd commented on  [4,5,5,6] to [5,4,6,5] test case. Yes my current solution would not resolve this test case. However, my rationale is: the median number should at most appear nuts.length/2 times for a valid input, thus if we put the medians to both sides as much as possible, we would get a valid answer.\\nThat's say, since the start point is always zero, we can fill firstHalf(with medians at its end) reversely at 2*i positions and fill secondHalf(with medians at its end) at 2*i+1 solution, we would pass the test case [4,5,5,6]. Code modified accordingly.\\n\\nAs @StefanPochmann commented on run time complexity. Added random shuffle for quick select in code accordingly. Don't know why it increase the Java time consumption from 15ms to 28ms. Any ideas?\\n\\n    import java.util.Random;\\n    \\n    public class Solution {\\n        public void wiggleSort(int[] nums) {\\n            \\n            if(nums == null || nums.length == 0) return;\\n            randomShuffle(nums);\\n    \\n            double median = findMedian(nums);\\n            int firstHalfLen, secondHalfLen;\\n            if(nums.length % 2 == 0) {\\n                firstHalfLen = nums.length/2;\\n            } else {\\n                firstHalfLen = nums.length/2+1;\\n            }\\n            secondHalfLen = nums.length/2;\\n    \\n            List<Integer> firstHalf  = new ArrayList<Integer>();\\n            List<Integer> secondHalf = new ArrayList<Integer>();\\n            \\n            for(int i = 0; i < nums.length; i++) {\\n                if((double) nums[i] < median) firstHalf.add(nums[i]);\\n                else if((double) nums[i] > median) secondHalf.add(nums[i]);\\n            }\\n    \\n            while(firstHalf.size() < firstHalfLen) {\\n                firstHalf.add((int) median);\\n            }\\n            while(secondHalf.size() < secondHalfLen) {\\n                secondHalf.add((int) median);\\n            }\\n            \\n            for(int i = 0; i < firstHalf.size(); i++) {\\n                nums[i*2] = firstHalf.get(firstHalf.size()-1-i);\\n            }\\n            for(int i = 0; i < secondHalf.size(); i++) {\\n                nums[i*2+1] = secondHalf.get(i);\\n            }\\n        }\\n    \\n        private void randomShuffle(int[] nums) {\\n            Random rm = new Random();\\n            for(int i = 0; i < nums.length-1; i++) {\\n                int j = i + rm.nextInt(nums.length-i);\\n                swap(nums, i, j);\\n            }\\n        }\\n        \\n        private double findMedian(int[] nums) {\\n            if(nums.length % 2 == 1) return (double) findKth(nums, 0, nums.length-1, nums.length/2);\\n            else return ( (double) findKth(nums, 0, nums.length-1, nums.length/2 - 1) + (double) findKth(nums, 0, nums.length-1, nums.length/2) ) / 2;\\n        }\\n    \\n        private int findKth(int[] nums, int low, int high, int k) {\\n            int pivot = nums[low];\\n            int lb = low, hb = high, pt = low+1;;\\n            while(pt <= hb) {\\n                if(nums[pt] < pivot) swap(nums, lb++, pt++);\\n                else if(nums[pt] > pivot) swap(nums, pt, hb--);\\n                else pt++;\\n            }\\n            if(k < lb) return findKth(nums, low, lb-1, k);\\n            else if(k > hb) return findKth(nums, hb+1, high, k);\\n            else return pivot;\\n        }\\n    \\n        private void swap(int[] nums, int i, int j) {\\n            int tmp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = tmp;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void wiggleSort(int[] nums) {\\n            \\n            if(nums == null || nums.length == 0) return;\\n            randomShuffle(nums);\\n    \\n            double median = findMedian(nums);\\n            int firstHalfLen, secondHalfLen;\\n            if(nums.length % 2 == 0) {\\n                firstHalfLen = nums.length/2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2836919,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue<int> q(nums.begin(), nums.end());\\n        for(int i=1; i<n; i+=2) {\\n            nums[i] = q.top();\\n            q.pop();\\n        }\\n        for(int i=0; i<n; i+=2) {\\n            nums[i] = q.top();\\n            q.pop();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue<int> q(nums.begin(), nums.end());\\n        for(int i=1; i<n; i+=2) {\\n            nums[i] = q.top();\\n            q.pop();\\n        }\\n        for(int i=0; i<n; i+=2) {\\n            nums[i] = q.top();\\n            q.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369716,
                "title": "wiggle-sort",
                "content": "class Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int a[50001]={0};\\n        for(auto i:nums)\\n            a[i]++;\\n        int n=nums.size();\\n        int k=5000;\\n        for(int i=1;i<n;i+=2)\\n        {\\n            while(a[k]--==0)\\n                k--;\\n            nums[i]=k;\\n        }\\n        for(int i=0;i<n;i+=2)\\n        {\\n            while(a[k]--==0)\\n                k--;\\n            nums[i]=k;\\n        }\\n            \\n        \\n        //L te bjjo\\n\\t\\t// by Aditya Kumar\\n\\t\\t\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int a[50001]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2342781,
                "title": "very-easy-and-fast-java-soln",
                "content": "if this soln. helps you in anyway then pls upvote. :)\\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int a[]=nums.clone();\\n        Arrays.sort(a);\\n        int left=(nums.length-1)/2;\\n        int right=nums.length-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(i%2==0){\\n                nums[i]=a[left];\\n                left--;\\n            }\\n            else{\\n                nums[i]=a[right];\\n                right--;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public void wiggleSort(int[] nums) {\\n        int a[]=nums.clone();\\n        Arrays.sort(a);\\n        int left=(nums.length-1)/2;\\n        int right=nums.length-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(i%2==0){\\n                nums[i]=a[left];\\n                left--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2183184,
                "title": "priority-queue-easiest-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n\\n               priority_queue<int> pq;\\n       for(int i =0;i<nums.size();i++){\\n           pq.push(nums[i]);\\n             \\n         }\\n        for(int i =1;i<nums.size();i+=2){\\n            nums[i]= pq.top();\\n            pq.pop();\\n        }\\n        for(int i =0;i<nums.size();i+=2){\\n            nums[i]= pq.top();\\n            pq.pop();\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n\\n               priority_queue<int> pq;\\n       for(int i =0;i<nums.size();i++){\\n           pq.push(nums[i]);\\n             \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1696463,
                "title": "couting-sort-because-nums-i-is-between-0-5000",
                "content": "In theory it meets the requirement: O(1) space and O(n) time. Lol\\n\\n```\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> counts(5001, 0);\\n        for (auto x : nums) counts[x]++;\\n        \\n        int maxVal = 5000;\\n        for (int i = 1; i < n; i+= 2) {\\n\\t\\t\\twhile (counts[maxVal] == 0) maxVal--;\\n            nums[i] = maxVal;\\n            counts[maxVal]--;\\n        }\\n        \\n        for (int i = 0; i < n; i+= 2) {\\n\\t\\t\\twhile (counts[maxVal] == 0) maxVal--;\\n            nums[i] = maxVal;\\n            counts[maxVal]--;\\n        }\\n    }\\n```\\n\\nStill trying to wrap my head around the median and index-mapping trick.",
                "solutionTags": [
                    "Counting Sort"
                ],
                "code": "```\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> counts(5001, 0);\\n        for (auto x : nums) counts[x]++;\\n        \\n        int maxVal = 5000;\\n        for (int i = 1; i < n; i+= 2) {\\n\\t\\t\\twhile (counts[maxVal] == 0) maxVal--;\\n            nums[i] = maxVal;\\n            counts[maxVal]--;\\n        }\\n        \\n        for (int i = 0; i < n; i+= 2) {\\n\\t\\t\\twhile (counts[maxVal] == 0) maxVal--;\\n            nums[i] = maxVal;\\n            counts[maxVal]--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563494,
                "title": "python-1-liner-beats-99-and-looks-good-doing-it",
                "content": "```\\nnums[1::2],nums[::2] = (s:=sorted(nums,reverse=True))[:(len(s))//2],s[(len(s))//2:]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b6246b61-41f9-4599-afe5-f0ac710baf00_1636241761.4377625.png)\\n\\n\\nExplanation:\\n\\nThe testcases are not complex enough to really distinguish O(n) from O(nlogn) with this question, so we can make our lives a little easier and settle for an O(nlogn) solution.\\n\\nThe general premise is:\\n\\n1. Sort nums in descending order (ascending can work also with some small tweaks)\\n\\t * s:=sorted(nums,reverse=True)\\n2. Put the largest numbers in the odd indices in descending order\\n\\t* nums[1::2] = s[:(len(s))//2]\\n3. Put the smallest numbers in the even indices in descending order\\n\\t* nums[::2] = [(len(s))//2:]\\n4. Enjoy the wiggle ;).\\n\\t * nums[1::2],nums[::2] = (s:=sorted(nums,reverse=True))[:(len(s))//2],s[(len(s))//2:]\\n\\n",
                "solutionTags": [],
                "code": "```\\nnums[1::2],nums[::2] = (s:=sorted(nums,reverse=True))[:(len(s))//2],s[(len(s))//2:]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1307855,
                "title": "c-quick-select-algo-median-time-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void swap(int &a,int &b){\\n        int temp=a;\\n        a=b;\\n        b=temp;\\n    }\\n    int partitionArray(vector<int>& A,int lo,int hi,int pivot){\\n        int i=lo,j=lo;\\n        \\n        while(i<=hi){\\n            if(A[i]<=pivot){\\n                swap(A[i],A[j]);\\n                i++;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return j-1;\\n    }\\n    int quickSelect(vector<int>& A,int lo,int hi,int k){\\n        int pivot=A[hi];\\n        int pi=partitionArray(A,lo,hi,pivot);\\n        \\n        if(pi==k){\\n            return pivot;\\n        }\\n        else if(pi>k){\\n            return quickSelect(A,lo,pi-1,k);\\n        }\\n        else{\\n            return quickSelect(A,pi+1,hi,k);\\n        }\\n        \\n    }\\n    void wiggleSort(vector<int>& A) {\\n        int n=A.size();\\n        int mid=quickSelect(A,0,n-1,n/2);\\n         vector<int> aux (A.begin(), A.end());\\n        \\n        for (int i = 0, l = 0, r = n - 1; i < r; ){\\n            if (aux[i] == mid) i ++;\\n            else if (aux[i] > mid) swap(aux[i], aux[r --]);\\n            else swap(aux[l ++], aux[i ++]);\\n        }\\n        \\n        int m= (n+1)/2;\\n        \\n        for(int i=0,j=m-1;j>=0;i=i+2,j--) A[i]=aux[j];\\n        for(int i=1,j=n-1;j>=m;i=i+2,j--) A[i]=aux[j];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void swap(int &a,int &b){\\n        int temp=a;\\n        a=b;\\n        b=temp;\\n    }\\n    int partitionArray(vector<int>& A,int lo,int hi,int pivot){\\n        int i=lo,j=lo;\\n        \\n        while(i<=hi){\\n            if(A[i]<=pivot){\\n                swap(A[i],A[j]);\\n                i++;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return j-1;\\n    }\\n    int quickSelect(vector<int>& A,int lo,int hi,int k){\\n        int pivot=A[hi];\\n        int pi=partitionArray(A,lo,hi,pivot);\\n        \\n        if(pi==k){\\n            return pivot;\\n        }\\n        else if(pi>k){\\n            return quickSelect(A,lo,pi-1,k);\\n        }\\n        else{\\n            return quickSelect(A,pi+1,hi,k);\\n        }\\n        \\n    }\\n    void wiggleSort(vector<int>& A) {\\n        int n=A.size();\\n        int mid=quickSelect(A,0,n-1,n/2);\\n         vector<int> aux (A.begin(), A.end());\\n        \\n        for (int i = 0, l = 0, r = n - 1; i < r; ){\\n            if (aux[i] == mid) i ++;\\n            else if (aux[i] > mid) swap(aux[i], aux[r --]);\\n            else swap(aux[l ++], aux[i ++]);\\n        }\\n        \\n        int m= (n+1)/2;\\n        \\n        for(int i=0,j=m-1;j>=0;i=i+2,j--) A[i]=aux[j];\\n        for(int i=1,j=n-1;j>=m;i=i+2,j--) A[i]=aux[j];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155067,
                "title": "java-using-counting-1ms",
                "content": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int[] count = new int[5001];\\n        for(int num: nums)\\n            count[num]++;\\n        \\n        \\n        int index = 5000;\\n        for(int i = 1; i < nums.length; i+=2){\\n            while(count[index] == 0) index--;\\n            nums[i] = index;\\n            count[index]--;\\n        }\\n        \\n        for(int i = 0; i < nums.length; i+=2){\\n            while(count[index] == 0) index--;\\n            nums[i] = index;\\n            count[index]--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int[] count = new int[5001];\\n        for(int num: nums)\\n            count[num]++;\\n        \\n        \\n        int index = 5000;\\n        for(int i = 1; i < nums.length; i+=2){\\n            while(count[index] == 0) index--;\\n            nums[i] = index;\\n            count[index]--;\\n        }\\n        \\n        for(int i = 0; i < nums.length; i+=2){\\n            while(count[index] == 0) index--;\\n            nums[i] = index;\\n            count[index]--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002768,
                "title": "java-o-n-with-explain",
                "content": "Adding my comments and reference of existing solutions to help understand:\\n\\nThe key of this problem is to find the the mid value of the array.  To find the mid value of the array, using kth largest element algorithm(https://leetcode.com/problems/kth-largest-element-in-an-array/). After calculate, loop the array to fill the values using the below magic pattern:\\n```\\nIndex :       0   1   2   3   4   5\\nSmall half:   M       S       S    \\nLarge half:       L       L       M\\n```\\nThe pattern means fill values smaller than mid backward on the even index. Fill values larger than the mid forward on the odd index.\\n\\n(I honestly think the pattern is tricky to figure out during the interview. It should not be the point of the problem.......)\\n\\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int mid=findKthLargest(nums,(nums.length+1)/2);\\n        \\n        int odd=1; //fill values larger than mid from beginning\\n        int even=nums.length%2==0?nums.length-2:nums.length-1; // fill values smaller than mid from back \\n        \\n        int[] temp=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>mid){\\n                temp[odd]=nums[i];\\n                odd+=2;\\n                continue;\\n            }\\n            if(nums[i]<mid){\\n                temp[even]=nums[i];\\n                even-=2;\\n                continue;\\n            }\\n        }\\n        \\n        // the above logic did not consider equal to mid case. Need to fill the empty values with mid \\n        while(odd<nums.length){\\n            temp[odd]=mid;\\n            odd+=2;\\n        }\\n        \\n        while(even>=0){\\n            temp[even]=mid;\\n            even-=2;\\n        }\\n        \\n        //copy the array over\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=temp[i];\\n        }\\n        \\n    }\\n    \\n    public int findKthLargest(int[] nums, int k) {\\n        return divideAndConquer(nums, nums.length - k, 0, nums.length-1);\\n    }\\n    \\n    public int divideAndConquer(int[] nums, int k, int start, int end) {\\n        int pivot = nums[end];\\n        int s = start;\\n        int n = 0; //init value\\n        while (s < end) {\\n            if (nums[s] > pivot) {\\n                n = s + 1;\\n                while (n < end && nums[n] > pivot) {\\n                    n++;\\n                }\\n                if (n == end) {\\n                    break;\\n                }\\n                \\n                swap(nums, s, n);\\n            }\\n            s++;\\n        }\\n        swap(nums, s, end);\\n        if (s == k) {\\n            return nums[k];\\n        } else if (s < k) {\\n            return divideAndConquer(nums, k, s+1, end);\\n        } else {\\n            return divideAndConquer(nums, k, start, s-1);\\n        }\\n    }\\n    \\n    public void swap (int[] nums, int a, int b) {\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nIndex :       0   1   2   3   4   5\\nSmall half:   M       S       S    \\nLarge half:       L       L       M\\n```\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int mid=findKthLargest(nums,(nums.length+1)/2);\\n        \\n        int odd=1; //fill values larger than mid from beginning\\n        int even=nums.length%2==0?nums.length-2:nums.length-1; // fill values smaller than mid from back \\n        \\n        int[] temp=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>mid){\\n                temp[odd]=nums[i];\\n                odd+=2;\\n                continue;\\n            }\\n            if(nums[i]<mid){\\n                temp[even]=nums[i];\\n                even-=2;\\n                continue;\\n            }\\n        }\\n        \\n        // the above logic did not consider equal to mid case. Need to fill the empty values with mid \\n        while(odd<nums.length){\\n            temp[odd]=mid;\\n            odd+=2;\\n        }\\n        \\n        while(even>=0){\\n            temp[even]=mid;\\n            even-=2;\\n        }\\n        \\n        //copy the array over\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=temp[i];\\n        }\\n        \\n    }\\n    \\n    public int findKthLargest(int[] nums, int k) {\\n        return divideAndConquer(nums, nums.length - k, 0, nums.length-1);\\n    }\\n    \\n    public int divideAndConquer(int[] nums, int k, int start, int end) {\\n        int pivot = nums[end];\\n        int s = start;\\n        int n = 0; //init value\\n        while (s < end) {\\n            if (nums[s] > pivot) {\\n                n = s + 1;\\n                while (n < end && nums[n] > pivot) {\\n                    n++;\\n                }\\n                if (n == end) {\\n                    break;\\n                }\\n                \\n                swap(nums, s, n);\\n            }\\n            s++;\\n        }\\n        swap(nums, s, end);\\n        if (s == k) {\\n            return nums[k];\\n        } else if (s < k) {\\n            return divideAndConquer(nums, k, s+1, end);\\n        } else {\\n            return divideAndConquer(nums, k, start, s-1);\\n        }\\n    }\\n    \\n    public void swap (int[] nums, int a, int b) {\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682815,
                "title": "correct-answer-has-been-stated-wrong-plz-help",
                "content": "This is given : \\n```\\ninput : [1,3,2,2,3,1]\\nexpected output : [1,3,1,3,2,3]\\n1 < 3 > 1 < 3 > 2 < 3\\n```\\n\\nMy solution gave this output :\\n```\\n[2,3,1,3,1,2]\\n```\\n\\nThe question says to satisfy : nums[0] < nums[1] > nums[2] < nums[3]...\\n\\nAny my answer also does satisfy it..\\n```\\n[2,3,1,3,1,2]\\n2 < 3 > 1 < 3 > 1 < 2\\n```\\n\\nWhy is it wrong then?\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ninput : [1,3,2,2,3,1]\\nexpected output : [1,3,1,3,2,3]\\n1 < 3 > 1 < 3 > 2 < 3\\n```\n```\\n[2,3,1,3,1,2]\\n```\n```\\n[2,3,1,3,1,2]\\n2 < 3 > 1 < 3 > 1 < 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 653670,
                "title": "avg-tc-o-n-for-median-o-n-for-ordering-elements-o-1-space",
                "content": "We can observe that odd indices should contain bigger values than its neighbors so even indices can contain smaller values. Keeping this in mind, we can first find the median element, which is the element which will be at median position if it were sorted. This will be our mid/pivot element against which we are going to rearrange our elements.\\n1. Using nth_element we rearrange the elements at median position and get that element\\n2. Now using partitioning algorithm we are going to rearrange our elements with slight modification on which indices we have to choose for swapping.\\n\\ta. Elements greater than mid should be at odd indices(starting from 1st odd spot i.e. 1)\\n\\tb. Elements lesser than mid should be at even indices(starting from back so 4 in case of 5 is our last index)\\n\\tc. We can move on to next odd index for elements equal to mid.\\n3. When are done swapping odd indices with even from left and right, we can move on to even indices and repeat the above 3 steps.\\n4. This process will go until we reach an index which is less than right, which is when the cycle has completed i.e. reaching the odd index 1 again.\\n\\n\\nInspired from https://en.wikipedia.org/wiki/Dutch_national_flag_problem\\nInspired from @stefan pochmann\\'s solution.\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    inline int get(int idx) // This technique is inspired from stefan as I was reading the discussions and also from Dutch National Flag problem from BacktoBackSWE and wiki as well.\\n    {\\n        //if n is even then, change it to next odd because when are done processing odd indices, we have to switch to even index starting from zero. When we reach last odd index and try to calculate next odd index then we have to take mod of n with odd number.\\n        //n|1 gives us the closest odd number\\n        \\n        int odd_index = 2*idx+1; // next odd index for a given current index\\n        int sz = n|1; // When odd_index crosses the last odd index then % sz will make it zero\\n        return odd_index%sz;\\n    }\\n    void wiggleSort(vector<int>& nums) \\n    {\\n        n = (int)nums.size();\\n        //Find the value at median index in case if it is sorted, thats why we use nth_element STL\\n        auto itr = nums.begin()+(n>>1);\\n        nth_element(nums.begin(),itr,nums.end()); \\n        int mid = *itr;\\n        \\n        int low = 0; // Pointer to similar to curr(which points to odd indices) but this will always point to next available odd spot where we can swap when we find an element greater than mid (1st partition)\\n        int curr = 0;\\n        int high = n-1; // Pointer to the last element(conceptually, we assume this is the 3rd partition)\\n        \\n        while(curr<=high)\\n        {\\n            if(nums[get(curr)]>mid)\\n                swap(nums[get(low++)],nums[get(curr++)]);\\n            else if(nums[get(curr)]<mid)\\n                swap(nums[get(curr)],nums[get(high--)]);\\n            else\\n                curr++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    inline int get(int idx) // This technique is inspired from stefan as I was reading the discussions and also from Dutch National Flag problem from BacktoBackSWE and wiki as well.\\n    {\\n        //if n is even then, change it to next odd because when are done processing odd indices, we have to switch to even index starting from zero. When we reach last odd index and try to calculate next odd index then we have to take mod of n with odd number.\\n        //n|1 gives us the closest odd number\\n        \\n        int odd_index = 2*idx+1; // next odd index for a given current index\\n        int sz = n|1; // When odd_index crosses the last odd index then % sz will make it zero\\n        return odd_index%sz;\\n    }\\n    void wiggleSort(vector<int>& nums) \\n    {\\n        n = (int)nums.size();\\n        //Find the value at median index in case if it is sorted, thats why we use nth_element STL\\n        auto itr = nums.begin()+(n>>1);\\n        nth_element(nums.begin(),itr,nums.end()); \\n        int mid = *itr;\\n        \\n        int low = 0; // Pointer to similar to curr(which points to odd indices) but this will always point to next available odd spot where we can swap when we find an element greater than mid (1st partition)\\n        int curr = 0;\\n        int high = n-1; // Pointer to the last element(conceptually, we assume this is the 3rd partition)\\n        \\n        while(curr<=high)\\n        {\\n            if(nums[get(curr)]>mid)\\n                swap(nums[get(low++)],nums[get(curr++)]);\\n            else if(nums[get(curr)]<mid)\\n                swap(nums[get(curr)],nums[get(high--)]);\\n            else\\n                curr++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584336,
                "title": "java-simple-readable-with-comments",
                "content": "```\\nclass Solution {\\n    //Take the median\\n    //From the beginning , fill all odd indexes with all values greater than median\\n    //From the end, fill all even indices with all values SMALLEr than median\\n    //Fill the rest with median\\n    \\n    public void wiggleSort(int[] nums) {\\n        int median = findMedian(nums, (nums.length + 1)/2);\\n        Integer[] temp = new Integer[nums.length];\\n        int odd = 1;\\n        int even = nums.length%2 == 0 ? nums.length - 2 : nums.length - 1;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] > median) {\\n                temp[odd] = nums[i]; // bigger than median in odd space from beginning\\n                odd += 2;\\n            } else if(nums[i] < median) {\\n                temp[even] = nums[i]; // Smaller than median from end\\n                even -= 2;\\n            } \\n            //else do nothing\\n        }\\n        \\n        for(int i = 0; i < temp.length; i++) {\\n            if(temp[i] == null) temp[i] = median;\\n            nums[i] = temp[i];\\n        }\\n    }\\n    \\n    private int findMedian(int[] nums, int k) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>();\\n        for(int i =0; i < nums.length; i++) {\\n            if(i < k) {\\n                heap.offer(nums[i]);\\n            } else {\\n                if(nums[i] > heap.peek()) {\\n                    heap.poll();\\n                    heap.offer(nums[i]);\\n                }\\n            }\\n        }\\n        return heap.peek();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    //Take the median\\n    //From the beginning , fill all odd indexes with all values greater than median\\n    //From the end, fill all even indices with all values SMALLEr than median\\n    //Fill the rest with median\\n    \\n    public void wiggleSort(int[] nums) {\\n        int median = findMedian(nums, (nums.length + 1)/2);\\n        Integer[] temp = new Integer[nums.length];\\n        int odd = 1;\\n        int even = nums.length%2 == 0 ? nums.length - 2 : nums.length - 1;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] > median) {\\n                temp[odd] = nums[i]; // bigger than median in odd space from beginning\\n                odd += 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 427303,
                "title": "python-3-solutions-beats-86-83",
                "content": "```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        ## if all the numbers in nums are integer, then sort takes O(n) by radix sort.\\n        if not nums:\\n            return\\n        nums.sort()\\n        \\n        L = len(nums)\\n        boundary = L//2 if L%2 == 0 else L//2+1\\n        small_nums = nums[:boundary]\\n        large_nums = nums[boundary:]\\n        small_nums, large_nums = small_nums[::-1], large_nums[::-1]\\n\\n        j, k = 0, 0\\n        for i in range(L):\\n            if i%2 == 0:\\n                nums[i] = small_nums[j]\\n                j += 1\\n            else:\\n                nums[i] = large_nums[k]\\n                k += 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        ## if all the numbers in nums are integer, then sort takes O(n) by radix sort.\\n        if not nums:\\n            return\\n        nums.sort()\\n        \\n        L = len(nums)\\n        boundary = L//2 if L%2 == 0 else L//2+1\\n        small_nums = nums[:boundary]\\n        large_nums = nums[boundary:]\\n        small_nums, large_nums = small_nums[::-1], large_nums[::-1]\\n\\n        j, k = 0, 0\\n        for i in range(L):\\n            if i%2 == 0:\\n                nums[i] = small_nums[j]\\n                j += 1\\n            else:\\n                nums[i] = large_nums[k]\\n                k += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413977,
                "title": "easy-understand-quick-select-solution-o-n",
                "content": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        if (nums == null || nums.length == 0) return;\\n        int n = nums.length;\\n        int[] temp = new int[n];\\n        for (int i = 0; i < n; i++) temp[i] = nums[i];\\n        int pivot = n / 2, l = 0, r = temp.length - 1;\\n        while (l < r) {\\n            int mid = helper(temp, l, r);\\n            if (mid == pivot) break;\\n            if (mid < pivot) {\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, temp[pivot]);\\n        if (n % 2 == 0) {\\n            l = ans.length - 2;\\n            r = 1;\\n            for (int i = 0; i < nums.length; i++) {\\n                if (nums[i] < temp[pivot]) {\\n                    ans[l] = nums[i];\\n                    l -= 2;\\n                } else if (nums[i] > temp[pivot]) {\\n                    ans[r] = nums[i];\\n                    r += 2;\\n                }\\n            }\\n            \\n        } else {\\n            // 1 5 1 1 6 4 7\\n            l = ans.length - 1;\\n            r = 1;\\n            for (int i = 0; i < nums.length; i++) {\\n                if (nums[i] < temp[pivot]) {\\n                    ans[l] = nums[i];\\n                    l -= 2;\\n                } else if (nums[i] > temp[pivot]) {\\n                    ans[r] = nums[i];\\n                    r += 2;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = ans[i];\\n        }\\n        \\n    }\\n    private int helper(int[] nums, int l, int r) {\\n        int pivot = l;\\n        for (int i = l; i < r; i++) {\\n            if (nums[i] < nums[r]) {\\n                swap(nums, i, pivot++);\\n            }\\n        }\\n        swap(nums, pivot, r);\\n        return pivot;\\n    }\\n    private void swap(int[] nums, int l, int r) {\\n        int temp = nums[l];\\n        nums[l] = nums[r];\\n        nums[r] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        if (nums == null || nums.length == 0) return;\\n        int n = nums.length;\\n        int[] temp = new int[n];\\n        for (int i = 0; i < n; i++) temp[i] = nums[i];\\n        int pivot = n / 2, l = 0, r = temp.length - 1;\\n        while (l < r) {\\n            int mid = helper(temp, l, r);\\n            if (mid == pivot) break;\\n            if (mid < pivot) {\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, temp[pivot]);\\n        if (n % 2 == 0) {\\n            l = ans.length - 2;\\n            r = 1;\\n            for (int i = 0; i < nums.length; i++) {\\n                if (nums[i] < temp[pivot]) {\\n                    ans[l] = nums[i];\\n                    l -= 2;\\n                } else if (nums[i] > temp[pivot]) {\\n                    ans[r] = nums[i];\\n                    r += 2;\\n                }\\n            }\\n            \\n        } else {\\n            // 1 5 1 1 6 4 7\\n            l = ans.length - 1;\\n            r = 1;\\n            for (int i = 0; i < nums.length; i++) {\\n                if (nums[i] < temp[pivot]) {\\n                    ans[l] = nums[i];\\n                    l -= 2;\\n                } else if (nums[i] > temp[pivot]) {\\n                    ans[r] = nums[i];\\n                    r += 2;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = ans[i];\\n        }\\n        \\n    }\\n    private int helper(int[] nums, int l, int r) {\\n        int pivot = l;\\n        for (int i = l; i < r; i++) {\\n            if (nums[i] < nums[r]) {\\n                swap(nums, i, pivot++);\\n            }\\n        }\\n        swap(nums, pivot, r);\\n        return pivot;\\n    }\\n    private void swap(int[] nums, int l, int r) {\\n        int temp = nums[l];\\n        nums[l] = nums[r];\\n        nums[r] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371682,
                "title": "javascript-solution-with-sorting-easy-to-understand",
                "content": "**Algorithm**\\nFirst we sort the array elements in ascending order, compute the mediean index of the sorted array, and divide into two sub-arrays. Then we sort each sub-array in descending order. For example: [1,3,2,2,3,1] -> [1,1,2,2,3,3] -> [2,1,1] & [3,3,2].\\n\\nAt last, we just need to iterate over nums and replace the element with two sub-arrays **in turn**. \\n```\\nvar wiggleSort = function(nums) {\\n    nums.sort(function(a, b) { return a - b; });\\n    var mid = Math.floor((nums.length-1)/2);\\n    \\n    var left = new Array(mid+1);\\n    var right = new Array(nums.length-mid-1);\\n    for(let i = 0; i < left.length; i++) {\\n        left[i] = nums[i];\\n    }\\n    for(let j = 0; j < right.length; j++) {\\n        right[j] = nums[mid+1+j];\\n    }\\n    left.sort(function(a, b) { return b - a; });\\n    right.sort(function(a, b) { return b - a; });\\n    \\n    var turn = \\'left\\';\\n    var i = 0;\\n    var low = 0;\\n    var high = 0;\\n    while(low < left.length || high < right.length) {\\n        if(turn === \\'left\\') {\\n            nums[i] = left[low];\\n            turn = \\'right\\';\\n            i++;\\n            low++;\\n        }\\n        else {\\n            nums[i] = right[high];\\n            turn = \\'left\\';\\n            i++;\\n            high++;\\n        }\\n    }\\n    return nums;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar wiggleSort = function(nums) {\\n    nums.sort(function(a, b) { return a - b; });\\n    var mid = Math.floor((nums.length-1)/2);\\n    \\n    var left = new Array(mid+1);\\n    var right = new Array(nums.length-mid-1);\\n    for(let i = 0; i < left.length; i++) {\\n        left[i] = nums[i];\\n    }\\n    for(let j = 0; j < right.length; j++) {\\n        right[j] = nums[mid+1+j];\\n    }\\n    left.sort(function(a, b) { return b - a; });\\n    right.sort(function(a, b) { return b - a; });\\n    \\n    var turn = \\'left\\';\\n    var i = 0;\\n    var low = 0;\\n    var high = 0;\\n    while(low < left.length || high < right.length) {\\n        if(turn === \\'left\\') {\\n            nums[i] = left[low];\\n            turn = \\'right\\';\\n            i++;\\n            low++;\\n        }\\n        else {\\n            nums[i] = right[high];\\n            turn = \\'left\\';\\n            i++;\\n            high++;\\n        }\\n    }\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362464,
                "title": "c-56mm-beat-100-o-n-speed-o-1-space",
                "content": "1, find the middle element \"firstlast\", by using nth_element() function,\\n2, get all the elements less than middle element \"firstlast\" into the odd positions,\\n3, get all the elements greater than middle element \"firstlast\" into the even positions,\\n4, in all the odd positions, swap all elements that equal to \"firstlast\" to the left,\\n5, in all the even positions, swap all elements that equal to \"firstlast\" to the right.\\n\\n```\\nvoid wiggleSort(vector<int>& nums) {\\n        if (nums.size() < 2) return ;\\n\\n        int size = nums.size();\\n        nth_element(nums.begin(), nums.begin()+ (size-1)/2, nums.end());\\n        int firstLast = nums[(size-1)/2];\\n\\n        int cur0 = 0;\\n        int cur1 = 1;\\n        for (int i = 1; i < size; i += 2) {\\n            while (cur0 < size && nums[cur0] < firstLast) cur0 += 2;\\n            if (cur0 >= size) break;\\n            if (nums[i] < firstLast) swap(nums[i],nums[cur0]);\\n        }\\n\\n        for (int i = 0; i < size; i += 2) {\\n            while (cur1 < size && nums[cur1] > firstLast) cur1 += 2;\\n            if (cur1 >= size) break;\\n            if (nums[i] > firstLast) {swap(nums[i],nums[cur1]);}\\n        }\\n\\n        cur0 = 0;\\n        int front = size - 1;\\n        if (size%2 == 0) front = size - 2;\\n        while (cur0 < front) {\\n            if (nums[cur0] == firstLast) {\\n                cur0 += 2;\\n                continue;\\n            }\\n            else if (nums[front] != firstLast) {\\n                front -= 2;\\n                continue;\\n            }\\n            swap(nums[cur0],nums[front]);\\n        }\\n\\n        cur1 = 1;\\n        front = size - 2;\\n        if (size%2 == 0) front = size - 1;\\n        while (cur1 < front) {\\n            if (nums[cur1] != firstLast) {\\n                cur1 += 2;\\n                continue;\\n            }\\n            else if (nums[front] == firstLast) {\\n                front -= 2;\\n                continue;\\n            }\\n            swap(nums[cur1],nums[front]);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid wiggleSort(vector<int>& nums) {\\n        if (nums.size() < 2) return ;\\n\\n        int size = nums.size();\\n        nth_element(nums.begin(), nums.begin()+ (size-1)/2, nums.end());\\n        int firstLast = nums[(size-1)/2];\\n\\n        int cur0 = 0;\\n        int cur1 = 1;\\n        for (int i = 1; i < size; i += 2) {\\n            while (cur0 < size && nums[cur0] < firstLast) cur0 += 2;\\n            if (cur0 >= size) break;\\n            if (nums[i] < firstLast) swap(nums[i],nums[cur0]);\\n        }\\n\\n        for (int i = 0; i < size; i += 2) {\\n            while (cur1 < size && nums[cur1] > firstLast) cur1 += 2;\\n            if (cur1 >= size) break;\\n            if (nums[i] > firstLast) {swap(nums[i],nums[cur1]);}\\n        }\\n\\n        cur0 = 0;\\n        int front = size - 1;\\n        if (size%2 == 0) front = size - 2;\\n        while (cur0 < front) {\\n            if (nums[cur0] == firstLast) {\\n                cur0 += 2;\\n                continue;\\n            }\\n            else if (nums[front] != firstLast) {\\n                front -= 2;\\n                continue;\\n            }\\n            swap(nums[cur0],nums[front]);\\n        }\\n\\n        cur1 = 1;\\n        front = size - 2;\\n        if (size%2 == 0) front = size - 1;\\n        while (cur1 < front) {\\n            if (nums[cur1] != firstLast) {\\n                cur1 += 2;\\n                continue;\\n            }\\n            else if (nums[front] == firstLast) {\\n                front -= 2;\\n                continue;\\n            }\\n            swap(nums[cur1],nums[front]);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 288230,
                "title": "javascript-solution",
                "content": "``` */\\nfunction wiggleSort(nums) {\\n    nums.sort((a,b) => a-b);\\n    let mid = Math.floor(nums.length / 2)\\n    let count;\\n    count = nums.length % 2 == 0 ? mid-1 : mid\\n\\n    let i = 0;\\n    let j = nums.length-1;\\n    let copy = [...nums];\\n    while (i < nums.length){\\n        nums[i] = copy[count];\\n        if (i < nums.length-1){\\n            nums[i+1] = copy[j];\\n         }\\n        i+=2\\n        j--\\n        count--\\n    }\\n    return nums\\n};\\n```",
                "solutionTags": [],
                "code": "``` */\\nfunction wiggleSort(nums) {\\n    nums.sort((a,b) => a-b);\\n    let mid = Math.floor(nums.length / 2)\\n    let count;\\n    count = nums.length % 2 == 0 ? mid-1 : mid\\n\\n    let i = 0;\\n    let j = nums.length-1;\\n    let copy = [...nums];\\n    while (i < nums.length){\\n        nums[i] = copy[count];\\n        if (i < nums.length-1){\\n            nums[i+1] = copy[j];\\n         }\\n        i+=2\\n        j--\\n        count--\\n    }\\n    return nums\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 184265,
                "title": "3-line-python",
                "content": "```\nnums.sort()\nn = len(nums)//2 if len(nums)%2 == 0 else len(nums)//2 + 1\nnums[::2],nums[1::2] = nums[:n][::-1], nums[n:][::-1]\n```\n\n",
                "solutionTags": [],
                "code": "```\nnums.sort()\nn = len(nums)//2 if len(nums)%2 == 0 else len(nums)//2 + 1\nnums[::2],nums[1::2] = nums[:n][::-1], nums[n:][::-1]\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 77696,
                "title": "c-n-log-n-easy-understand-solution-without-using-virtual-index-and-three-way-partition",
                "content": "there is no build-in nth selection method in c#. so i just sort it. it takes O(nlogn) runtime and o(n) space, but should be much easy to understand.\\n\\n```\\npublic class Solution {\\n    public void WiggleSort(int[] nums) {\\n        if(nums.Length<=1) return ;\\n        Array.Sort(nums);\\n        var copy = nums.Clone() as int[];\\n        var mid = nums.Length%2 ==0? (nums.Length/2-1): (nums.Length/2); // right base mid index\\n        for(var i=0;i<nums.Length;i++){\\n            nums[i] = i%2==0? copy[mid-i/2]: copy[nums.Length-1 - i/2]; // refer to https://discuss.leetcode.com/topic/41464/step-by-step-explanation-of-index-mapping-in-java\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void WiggleSort(int[] nums) {\\n        if(nums.Length<=1) return ;\\n        Array.Sort(nums);\\n        var copy = nums.Clone() as int[];\\n        var mid = nums.Length%2 ==0? (nums.Length/2-1): (nums.Length/2); // right base mid index\\n        for(var i=0;i<nums.Length;i++){\\n            nums[i] = i%2==0? copy[mid-i/2]: copy[nums.Length-1 - i/2]; // refer to https://discuss.leetcode.com/topic/41464/step-by-step-explanation-of-index-mapping-in-java\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77707,
                "title": "my-java-solution-it-is-fast-and-easy-to-understand",
                "content": "hi! every body! this my solution. I am trying to explain how i solve it;\\nwhen we get an array such as [1, 5, 1, 1, 6, 4] ,we know  one possible answer is [1, 4, 1, 5, 1, 6]. and  it  matches  nums[0] < nums[1] > nums[2] < nums[3]...then we split them to pairs ,we find that every pair it satisfy nums[i] < nums[i+1] .and we can sort the array and we divide it to small part[1,1,1] and big part[6,5,4]. then we reorder the array just like that [1,6,1,5,1,4]. Ok,now it has been satisfy the nums[i] < nums[i+1]\\nand also satisfy  nums[i] < nums[i+1] > nums[i+2] (i start from 0)  why? because nums[i+1] it is belong to the  big part[6,5,4] and nums[i] , nums[i+1] are belong to the \\nsmall part[1,1,1]. that is how i solve it!\\nthere is one point should be noticed: the small part and big part order should be  desc not  asc. why?  because the biggest in the small part may be equal to the smallest in the big part.\\n\\n \\n\\n\\n \\n     public static  void wiggleSort(int[] nums) {\\n       \\n       //[1,1,1,4,5,6]\\n        Arrays.sort(nums);\\n        \\n        int len = nums.length;\\n        //the big num index need to move \\n        //when the len is odd the index should be add 1;\\n        //make sure that a1 >= a2\\n        int index = (int)Math.round(new Double(len) / 2);\\n        \\n        \\n        int[] a1 = new int[index];\\n        //[1,1,1]\\n        int k = 0;\\n        for(int i = index - 1; i >= 0; i--){\\n            a1[k++] = nums[i];\\n        }\\n        int[] a2 = new int[len - index];\\n        //[6,5,4]\\n        k = 0;\\n        for(int i = len - 1; i >= index; i--){\\n            a2[k++] = nums[i];\\n        }\\n        \\n        //at last fill the nums array\\n        k = 0;\\n        for(int i = 0; i < index && k < len; i++, k+=2){\\n            nums[k] = a1[i];\\n            if(k < len - 1){\\n              nums[k+1] = a2[i];  \\n            }\\n        }\\n        \\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "hi! every body! this my solution. I am trying to explain how i solve it;\\nwhen we get an array such as [1, 5, 1, 1, 6, 4] ,we know  one possible answer is [1, 4, 1, 5, 1, 6]. and  it  matches  nums[0] < nums[1] > nums[2] < nums[3]...then we split them to pairs ,we find that every pair it satisfy nums[i] < nums[i+1] .and we can sort the array and we divide it to small part[1,1,1] and big part[6,5,4]. then we reorder the array just like that [1,6,1,5,1,4]. Ok,now it has been satisfy the nums[i] < nums[i+1]\\nand also satisfy  nums[i] < nums[i+1] > nums[i+2] (i start from 0)  why? because nums[i+1] it is belong to the  big part[6,5,4] and nums[i] , nums[i+1] are belong to the \\nsmall part[1,1,1]. that is how i solve it!\\nthere is one point should be noticed: the small part and big part order should be  desc not  asc. why?  because the biggest in the small part may be equal to the smallest in the big part.\\n\\n \\n\\n\\n \\n     public static  void wiggleSort(int[] nums) {\\n       \\n       //[1,1,1,4,5,6]\\n        Arrays.sort(nums);\\n        \\n        int len = nums.length;\\n        //the big num index need to move \\n        //when the len is odd the index should be add 1;\\n        //make sure that a1 >= a2\\n        int index = (int)Math.round(new Double(len) / 2);\\n        \\n        \\n        int[] a1 = new int[index];\\n        //[1,1,1]\\n        int k = 0;\\n        for(int i = index - 1; i >= 0; i--){\\n            a1[k++] = nums[i];\\n        }\\n        int[] a2 = new int[len - index];\\n        //[6,5,4]\\n        k = 0;\\n        for(int i = len - 1; i >= index; i--){\\n            a2[k++] = nums[i];\\n        }\\n        \\n        //at last fill the nums array\\n        k = 0;\\n        for(int i = 0; i < index && k < len; i++, k+=2){\\n            nums[k] = a1[i];\\n            if(k < len - 1){\\n              nums[k+1] = a2[i];  \\n            }\\n        }\\n        \\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 77773,
                "title": "o-nlogn-perfect-shuffle-solution",
                "content": "Refer to this paper: [http://arxiv.org/pdf/0805.1598.pdf][1]\\n\\n    class Solution(object):\\n        def reverse(self, start, end):\\n            low, high = start, end\\n            while low < high:\\n                self.nums[low], self.nums[high] = self.nums[high], self.nums[low]\\n                low += 1\\n                high -= 1\\n    \\n        def getK(self, n):\\n            k, square = 1, 3\\n            while square - 1 <= 2 * n:\\n                k += 1\\n                square *= 3\\n            return k - 1\\n    \\n        def shuffle(self, start, end):\\n            n = (end - start + 1) / 2\\n    \\n            k = self.getK(n)\\n            m = (3 ** k - 1) / 2\\n            if m != n:\\n                self.reverse(start + m, start + n - 1)\\n                self.reverse(start + n, start + n + m - 1)\\n                self.reverse(start + m, start + n + m - 1)\\n    \\n            for k in xrange(1, k + 1):\\n                i = cursor = 3 ** (k - 1)\\n                pre, visited = self.nums[i + start - 1], False\\n                while not (i == cursor and visited):\\n                    i = (2 * i) % (2 * m + 1)\\n                    self.nums[i + start - 1], pre = pre, self.nums[i + start - 1]\\n    \\n                    if not visited:\\n                        visited = True\\n    \\n            if n != m:\\n                self.shuffle(start + 2 * m, end)\\n    \\n        def wiggleSort(self, nums):\\n            length = len(nums)\\n            if length < 2:\\n                return\\n    \\n            nums.sort()\\n    \\n            start, end = 1, length - 1\\n            if not length & 1:\\n                end -= 1\\n    \\n            self.nums = nums\\n            self.shuffle(start, end)\\n\\n\\n  [1]: http://arxiv.org/pdf/0805.1598.pdf",
                "solutionTags": [
                    "Python"
                ],
                "code": "Refer to this paper: [http://arxiv.org/pdf/0805.1598.pdf][1]\\n\\n    class Solution(object):\\n        def reverse(self, start, end):\\n            low, high = start, end\\n            while low < high:\\n                self.nums[low], self.nums[high] = self.nums[high], self.nums[low]\\n                low += 1\\n                high -= 1\\n    \\n        def getK(self, n):\\n            k, square = 1, 3\\n            while square - 1 <= 2 * n:\\n                k += 1\\n                square *= 3\\n            return k - 1\\n    \\n        def shuffle(self, start, end):\\n            n = (end - start + 1) / 2\\n    \\n            k = self.getK(n)\\n            m = (3 ** k - 1) / 2\\n            if m != n:\\n                self.reverse(start + m, start + n - 1)\\n                self.reverse(start + n, start + n + m - 1)\\n                self.reverse(start + m, start + n + m - 1)\\n    \\n            for k in xrange(1, k + 1):\\n                i = cursor = 3 ** (k - 1)\\n                pre, visited = self.nums[i + start - 1], False\\n                while not (i == cursor and visited):\\n                    i = (2 * i) % (2 * m + 1)\\n                    self.nums[i + start - 1], pre = pre, self.nums[i + start - 1]\\n    \\n                    if not visited:\\n                        visited = True\\n    \\n            if n != m:\\n                self.shuffle(start + 2 * m, end)\\n    \\n        def wiggleSort(self, nums):\\n            length = len(nums)\\n            if length < 2:\\n                return\\n    \\n            nums.sort()\\n    \\n            start, end = 1, length - 1\\n            if not length & 1:\\n                end -= 1\\n    \\n            self.nums = nums\\n            self.shuffle(start, end)\\n\\n\\n  [1]: http://arxiv.org/pdf/0805.1598.pdf",
                "codeTag": "Java"
            },
            {
                "id": 3886582,
                "title": "u-will-understand-how-to-identify-pattern-beats-97-3",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can see a pattern like if the array is sorted in decending order than starting to mid will be placed in odd index and mid+1 to n will be at even index. This can only possible if array is sorted in decending order.\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\nSort the array in decending order and start to mid will be at odd index and mid+1 to n will be at even. \\nex:---------------1,3,2,2,3,1\\nafter sorting---  : 3 3 2 2 1 1 \\nmid+1 to n nos : 2 1 1\\nstart to mid-----: 3 3 2\\n\\noutput-----------: **2 3 1 3 1 2**\\n\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)(sorting space) + O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![Screenshot 2023-08-09 195609.png](https://assets.leetcode.com/users/images/680bb411-b235-4a71-b192-e71ec5c51b80_1691591225.468745.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int low = 0;\\n        int high = nums.size()/2;\\n        vector<int> ans;\\n        while(low<nums.size()/2 && high<nums.size()){\\n            ans.push_back(nums[high++]);\\n            ans.push_back(nums[low++]);\\n        }\\n        while(high<nums.size()) ans.push_back(nums[high++]);\\n        nums = ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int low = 0;\\n        int high = nums.size()/2;\\n        vector<int> ans;\\n        while(low<nums.size()/2 && high<nums.size()){\\n            ans.push_back(nums[high++]);\\n            ans.push_back(nums[low++]);\\n        }\\n        while(high<nums.size()) ans.push_back(nums[high++]);\\n        nums = ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802579,
                "title": "java-simple-and-easy-solution",
                "content": "# Intuition\\n  Just some observations :\\n  After sorting the array 5,4,3,2,1\\n  We get = 1,2,3,4,5\\n  So, here the condition is arr[0]<arr[1]>arr[2]<arr[3]\\n  All the greater value is on the even indices and in the original  array the greater elements are started from the end after sorting so just store them back in the temperary array from the last of the sorted array our job will be done !! \\n\\n# Approach\\n  Sorting !!!\\n\\n# Complexity\\n- Time complexity:\\n  O(nlogn)+O(n/2)+O(n/2)+O(n) = O(nlogn)\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    Arrays.sort(nums);\\n        int n = nums.length-1;\\n        int []temp = new int[nums.length];\\n        \\n        for(int i=1;i<nums.length;i+=2) temp[i]=nums[n--];\\n        for(int i=0;i<nums.length;i+=2) temp[i]=nums[n--];\\n        for(int i=0;i<nums.length;i++) nums[i]=temp[i];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    Arrays.sort(nums);\\n        int n = nums.length-1;\\n        int []temp = new int[nums.length];\\n        \\n        for(int i=1;i<nums.length;i+=2) temp[i]=nums[n--];\\n        for(int i=0;i<nums.length;i+=2) temp[i]=nums[n--];\\n        for(int i=0;i<nums.length;i++) nums[i]=temp[i];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942644,
                "title": "c-easy-and-simple-solution-using-sorting",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n# Complexity\\n- Time complexity:\\nO(Nlog(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans(nums.size(),0);\\n        ans=nums;\\n\\n        int i=1,j=nums.size()-1;\\n        while(i<nums.size()){\\n            ans[i]=nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        i=0;\\n        while(i<nums.size()){\\n            ans[i]=nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        nums=ans;\\n    }\\n};\\n\\n\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans(nums.size(),0);\\n        ans=nums;\\n\\n        int i=1,j=nums.size()-1;\\n        while(i<nums.size()){\\n            ans[i]=nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        i=0;\\n        while(i<nums.size()){\\n            ans[i]=nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        nums=ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475862,
                "title": "c-using-o-n-extra-space",
                "content": "```\\nvoid wiggleSort(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans(n,0);\\n        int k=1;\\n        int i=n-1;\\n        while(k<n)\\n        {\\n            \\n            ans[k]=nums[i];\\n            i--;\\n            k=k+2;\\n            \\n        }\\n        int j=0;\\n        while(j<n)\\n        {\\n            ans[j]=nums[i];\\n            i--;\\n            j=j+2;\\n        }\\n        nums=ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid wiggleSort(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans(n,0);\\n        int k=1;\\n        int i=n-1;\\n        while(k<n)\\n        {\\n            \\n            ans[k]=nums[i];\\n            i--;\\n            k=k+2;\\n            \\n        }\\n        int j=0;\\n        while(j<n)\\n        {\\n            ans[j]=nums[i];\\n            i--;\\n            j=j+2;\\n        }\\n        nums=ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2460449,
                "title": "python-heapq",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        maxheap = [-x for x in nums]\\n        heapq.heapify(maxheap)\\n        for i in range(1, n, 2):\\n            nums[i] = -heapq.heappop(maxheap)\\n        for i in range(0, n, 2):\\n            nums[i] = -heapq.heappop(maxheap)\\n        # Time: O(nlogn)\\n        # Space: O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        maxheap = [-x for x in nums]\\n        heapq.heapify(maxheap)\\n        for i in range(1, n, 2):\\n            nums[i] = -heapq.heappop(maxheap)\\n        for i in range(0, n, 2):\\n            nums[i] = -heapq.heappop(maxheap)\\n        # Time: O(nlogn)\\n        # Space: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353447,
                "title": "c-tc-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        if (nums.size() <= 1) return;\\n        vector<int> cnt = vector<int>(5001, 0);\\n        \\n        int max_val = -1;\\n        for (int i: nums) {\\n            cnt[i]++;\\n            max_val = max(i, max_val);\\n        }\\n        \\n        int val = max_val;\\n        \\n        for (int i = 1; i < nums.size(); i+=2) {\\n            while (cnt[val] == 0) val--;\\n            nums[i] = val;\\n            cnt[val]--;\\n        }\\n        \\n        for (int i = 0; i < nums.size(); i+=2) {\\n            while (cnt[val] == 0) val--;\\n            nums[i] = val;\\n            cnt[val]--;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        if (nums.size() <= 1) return;\\n        vector<int> cnt = vector<int>(5001, 0);\\n        \\n        int max_val = -1;\\n        for (int i: nums) {\\n            cnt[i]++;\\n            max_val = max(i, max_val);\\n        }\\n        \\n        int val = max_val;\\n        \\n        for (int i = 1; i < nums.size(); i+=2) {\\n            while (cnt[val] == 0) val--;\\n            nums[i] = val;\\n            cnt[val]--;\\n        }\\n        \\n        for (int i = 0; i < nums.size(); i+=2) {\\n            while (cnt[val] == 0) val--;\\n            nums[i] = val;\\n            cnt[val]--;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297918,
                "title": "funny-go-solution-with-heap",
                "content": "```\\nfunc wiggleSort(nums []int)  {\\n    var heap []int\\n    \\n    for _, num := range nums {\\n        heap = append(heap, num)\\n        heapUp(heap, len(heap)-1)\\n    }\\n    \\n    k := len(nums)/2\\n    \\n    var topKLargestElement []int\\n    \\n    for i := 0; i < k; i++ {\\n        topKLargestElement = append(topKLargestElement, heap[0])\\n        heap[0] = heap[len(heap)-1]\\n        heap = heap[:len(heap)-1]\\n        heapDown(heap, 0, len(heap)-1)\\n    }\\n    \\n    sort.Slice(heap, func(i, j int) bool {\\n        return heap[i] > heap[j]\\n    })\\n    \\n    j, k := 0, 0\\n    \\n    for i := 0; i < len(nums); i++ {\\n        if i%2 == 1 {\\n            nums[i] = topKLargestElement[j]\\n            j++\\n        } else {\\n            nums[i] = heap[k]\\n            k++\\n        }\\n    }\\n}\\n\\nfunc heapUp(heap []int, pos int) {\\n    parent := (pos-1)/2\\n    \\n    if parent >= 0 && heap[parent] < heap[pos] {\\n        heap[parent], heap[pos] = heap[pos], heap[parent]\\n        heapUp(heap, parent)\\n    }\\n}\\n\\nfunc heapDown(heap []int, pos, limit int) {\\n    l, r := 2*pos+1, 2*pos+2\\n    larger := pos\\n    \\n    if l <= limit && heap[l] > heap[larger] {\\n        larger = l\\n    }\\n    \\n    if r <= limit && heap[r] > heap[larger] {\\n        larger = r\\n    }\\n    \\n    if larger != pos {\\n        heap[larger], heap[pos] = heap[pos], heap[larger]\\n        heapDown(heap, larger, limit)\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunc wiggleSort(nums []int)  {\\n    var heap []int\\n    \\n    for _, num := range nums {\\n        heap = append(heap, num)\\n        heapUp(heap, len(heap)-1)\\n    }\\n    \\n    k := len(nums)/2\\n    \\n    var topKLargestElement []int\\n    \\n    for i := 0; i < k; i++ {\\n        topKLargestElement = append(topKLargestElement, heap[0])\\n        heap[0] = heap[len(heap)-1]\\n        heap = heap[:len(heap)-1]\\n        heapDown(heap, 0, len(heap)-1)\\n    }\\n    \\n    sort.Slice(heap, func(i, j int) bool {\\n        return heap[i] > heap[j]\\n    })\\n    \\n    j, k := 0, 0\\n    \\n    for i := 0; i < len(nums); i++ {\\n        if i%2 == 1 {\\n            nums[i] = topKLargestElement[j]\\n            j++\\n        } else {\\n            nums[i] = heap[k]\\n            k++\\n        }\\n    }\\n}\\n\\nfunc heapUp(heap []int, pos int) {\\n    parent := (pos-1)/2\\n    \\n    if parent >= 0 && heap[parent] < heap[pos] {\\n        heap[parent], heap[pos] = heap[pos], heap[parent]\\n        heapUp(heap, parent)\\n    }\\n}\\n\\nfunc heapDown(heap []int, pos, limit int) {\\n    l, r := 2*pos+1, 2*pos+2\\n    larger := pos\\n    \\n    if l <= limit && heap[l] > heap[larger] {\\n        larger = l\\n    }\\n    \\n    if r <= limit && heap[r] > heap[larger] {\\n        larger = r\\n    }\\n    \\n    if larger != pos {\\n        heap[larger], heap[pos] = heap[pos], heap[larger]\\n        heapDown(heap, larger, limit)\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945315,
                "title": "java-priorityqueue-5-lines",
                "content": "It\\'s about 5 lines without all the brackets, but the idea is put all the greater elements first, and then put all the lesser elements. Pair max with median - 1, max - 1 with median - 2, etc.\\n\\nThe inspiration behind this idea is that we can\\'t pair max with min because at the end of it, median and gonna be paired with median and they may be equal! So in order to address that, let\\'s pair max with median.\\n```Java\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        PriorityQueue<Integer> maxheap = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int n : nums){\\n            maxheap.offer(n);\\n        }\\n        for (int i = 1; i < nums.length; i+=2){\\n            nums[i] = maxheap.poll();\\n        }\\n        for (int i = 0; i < nums.length; i+=2){\\n            nums[i] = maxheap.poll();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        PriorityQueue<Integer> maxheap = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int n : nums){\\n            maxheap.offer(n);\\n        }\\n        for (int i = 1; i < nums.length; i+=2){\\n            nums[i] = maxheap.poll();\\n        }\\n        for (int i = 0; i < nums.length; i+=2){\\n            nums[i] = maxheap.poll();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798893,
                "title": "java-sorting-two-pointer-solution",
                "content": "# public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] res = new int[nums.length];\\n        int j = nums.length - 1;\\n        int i = 1;\\n        while (j >= 0) {\\n            if (i > nums.length - 1) {\\n                i = 0;\\n            }\\n            res[i++] = nums[j--];\\n            i++;\\n        }\\n        for (i = 0; i < res.length; i++) {\\n            nums[i] = res[i];\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "# public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] res = new int[nums.length];\\n        int j = nums.length - 1;\\n        int i = 1;\\n        while (j >= 0) {\\n            if (i > nums.length - 1) {\\n                i = 0;\\n            }\\n            res[i++] = nums[j--];\\n            i++;\\n        }\\n        for (i = 0; i < res.length; i++) {\\n            nums[i] = res[i];\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1563150,
                "title": "java-wigglesort-ii-beats-98-91",
                "content": "Current Version:\\nRuntime: 2 ms, faster than 98.91% of Java online submissions for Wiggle Sort II.\\nMemory Usage: 41.8 MB, less than 72.08% of Java online submissions for Wiggle Sort II.\\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int[] copy = nums.clone();\\n        Arrays.sort(copy);\\n        int offset = 1;\\n        for(int i = 1; i < nums.length; i+=2)\\n        {\\n            nums[i] = copy[copy.length-offset];\\n            offset++;\\n        }\\n        for(int i = 0; i < nums.length; i+=2)\\n        {\\n            nums[i] = copy[copy.length-offset];\\n            offset++;\\n        }\\n        \\n    }\\n}\\n```\\nMy previous solutions:\\nPriority Queue:\\nRuntime: 19 ms\\nMemory Usage: 41.1 MB\\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < nums.length; i++){pq.add(nums[i]);}\\n        int size = pq.size();\\n        for(int i = 1; i < size; i+=2)\\n        {\\n            nums[i] = pq.poll();\\n        }\\n        for(int i = 0; i < size; i+=2)\\n        {\\n            nums[i] = pq.poll();\\n        }\\n        \\n        \\n        \\n    }\\n}\\n```\\nArrayList PriorityQueue:\\nRuntime: 6 ms\\nMemory Usage: 41.1 MB\\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        List<Integer> pq = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++){pq.add(nums[i]);}\\n        int size = pq.size();\\n        for(int i = 1; i < size; i+=2)\\n        {\\n            nums[i] = pq.get(pq.size()-1);\\n            pq.remove(pq.size()-1);\\n        }\\n        for(int i = 0; i < size; i+=2)\\n        {\\n            nums[i] = pq.get(pq.size()-1);\\n            pq.remove(pq.size()-1);\\n        }\\n        \\n        \\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int[] copy = nums.clone();\\n        Arrays.sort(copy);\\n        int offset = 1;\\n        for(int i = 1; i < nums.length; i+=2)\\n        {\\n            nums[i] = copy[copy.length-offset];\\n            offset++;\\n        }\\n        for(int i = 0; i < nums.length; i+=2)\\n        {\\n            nums[i] = copy[copy.length-offset];\\n            offset++;\\n        }\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < nums.length; i++){pq.add(nums[i]);}\\n        int size = pq.size();\\n        for(int i = 1; i < size; i+=2)\\n        {\\n            nums[i] = pq.poll();\\n        }\\n        for(int i = 0; i < size; i+=2)\\n        {\\n            nums[i] = pq.poll();\\n        }\\n        \\n        \\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        List<Integer> pq = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++){pq.add(nums[i]);}\\n        int size = pq.size();\\n        for(int i = 1; i < size; i+=2)\\n        {\\n            nums[i] = pq.get(pq.size()-1);\\n            pq.remove(pq.size()-1);\\n        }\\n        for(int i = 0; i < size; i+=2)\\n        {\\n            nums[i] = pq.get(pq.size()-1);\\n            pq.remove(pq.size()-1);\\n        }\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545529,
                "title": "java-1ms-efficient-than-99-solution-easy-to-understand",
                "content": "class Solution {\\n    public void wiggleSort(int[] nums) {\\n        \\n        int [] res= new int [nums.length];\\n        \\n        //Sort\\n        Arrays.sort(nums);       // 1  1  1  4  5  6\\n        \\n        \\n        //Add elements at odd idx. and then at even\\n        \\n        int i = nums.length - 1;          // 5\\n        \\n        int idx = 1;\\n        while(idx < nums.length){        \\n            \\n            res[idx] = nums[i];        // res[1] = 6\\n            \\n            --i;\\n            idx += 2;\\n        }\\n        \\n        idx = 0;\\n        while(idx < nums.length){\\n            \\n            res[idx] = nums[i];\\n            \\n            --i;\\n            idx += 2;\\n        }\\n        \\n        \\n        for(int k=0; k<res.length; ++k){\\n            nums[k] = res[k];\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public void wiggleSort(int[] nums) {\\n        \\n        int [] res= new int [nums.length];\\n        \\n        //Sort\\n        Arrays.sort(nums);       // 1  1  1  4  5  6\\n        \\n        \\n        //Add elements at odd idx. and then at even\\n        \\n        int i = nums.length - 1;          // 5\\n        \\n        int idx = 1;\\n        while(idx < nums.length){        \\n            \\n            res[idx] = nums[i];        // res[1] = 6\\n            \\n            --i;\\n            idx += 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1491454,
                "title": "virtual-index-and-quick-select",
                "content": "here is a solution by using virtual index and quick select.  Thanks to [stefanpochmann](https://leetcode.com/problems/wiggle-sort-ii/discuss/77677/O(n)%2BO(1)-after-median-Virtual-Indexing), [fun4LeetCode](https://leetcode.com/problems/wiggle-sort-ii/discuss/77684/Summary-of-the-various-solutions-to-Wiggle-Sort-for-your-reference) and others for their contributions.\\n\\nTODO:\\n\\texplation of the funtion `realIndex`\\n\\texplation  why portion must in desc order and 3-way\\n\\n```go\\nimport (\\n\\t\"math/rand\"\\n)\\n\\nfunc wiggleSort(nums []int) {\\n\\tN := len(nums)\\n\\n\\trealIndex := func(i int) int {\\n\\t\\treturn (1 + 2*i) % (N | 1)\\n\\t}\\n\\n\\t// portion must in desc order and 3-way\\n\\tportion := func(nums []int, lt, rt int) (int, int) {\\n\\t\\tidx := rand.Intn(rt-lt+1) + lt\\n\\t\\tval := nums[realIndex(idx)]\\n\\t\\tnums[realIndex(idx)], nums[realIndex(lt)] = nums[realIndex(lt)], nums[realIndex(idx)]\\n\\n\\t\\ti := lt\\n\\t\\tj := rt\\n\\t\\tk := i\\n\\t\\tfor k <= j {\\n\\t\\t\\tif nums[realIndex(k)] > val {\\n\\t\\t\\t\\tnums[realIndex(k)], nums[realIndex(i)] = nums[realIndex(i)], nums[realIndex(k)]\\n\\t\\t\\t\\tk++\\n\\t\\t\\t\\ti++\\n\\t\\t\\t} else if nums[realIndex(k)] < val {\\n\\t\\t\\t\\tnums[realIndex(k)], nums[realIndex(j)] = nums[realIndex(j)], nums[realIndex(k)]\\n\\t\\t\\t\\tj--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tk++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn i, j\\n\\t}\\n\\n\\tdivideHalf := func(nums []int) {\\n\\t\\tcenter := len(nums) / 2\\n\\t\\tlt := 0\\n\\t\\trt := len(nums) - 1\\n\\t\\tpivotL, pivotR := rt, lt\\n\\t\\tfor pivotR < center || pivotL > center {\\n\\t\\t\\tpivotL, pivotR = portion(nums, lt, rt)\\n\\t\\t\\tif pivotL > center {\\n\\t\\t\\t\\trt = pivotL - 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlt = pivotR + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tshuffle := func(nums []int) {\\n\\t\\tN := len(nums)\\n\\t\\tfor i := N - 1; i > 0; i-- {\\n\\t\\t\\td := rand.Intn(i + 1)\\n\\t\\t\\tnums[d], nums[i] = nums[i], nums[d]\\n\\t\\t}\\n\\t}\\n\\n\\tshuffle(nums)\\n\\tdivideHalf(nums)\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Quickselect"
                ],
                "code": "```go\\nimport (\\n\\t\"math/rand\"\\n)\\n\\nfunc wiggleSort(nums []int) {\\n\\tN := len(nums)\\n\\n\\trealIndex := func(i int) int {\\n\\t\\treturn (1 + 2*i) % (N | 1)\\n\\t}\\n\\n\\t// portion must in desc order and 3-way\\n\\tportion := func(nums []int, lt, rt int) (int, int) {\\n\\t\\tidx := rand.Intn(rt-lt+1) + lt\\n\\t\\tval := nums[realIndex(idx)]\\n\\t\\tnums[realIndex(idx)], nums[realIndex(lt)] = nums[realIndex(lt)], nums[realIndex(idx)]\\n\\n\\t\\ti := lt\\n\\t\\tj := rt\\n\\t\\tk := i\\n\\t\\tfor k <= j {\\n\\t\\t\\tif nums[realIndex(k)] > val {\\n\\t\\t\\t\\tnums[realIndex(k)], nums[realIndex(i)] = nums[realIndex(i)], nums[realIndex(k)]\\n\\t\\t\\t\\tk++\\n\\t\\t\\t\\ti++\\n\\t\\t\\t} else if nums[realIndex(k)] < val {\\n\\t\\t\\t\\tnums[realIndex(k)], nums[realIndex(j)] = nums[realIndex(j)], nums[realIndex(k)]\\n\\t\\t\\t\\tj--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tk++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn i, j\\n\\t}\\n\\n\\tdivideHalf := func(nums []int) {\\n\\t\\tcenter := len(nums) / 2\\n\\t\\tlt := 0\\n\\t\\trt := len(nums) - 1\\n\\t\\tpivotL, pivotR := rt, lt\\n\\t\\tfor pivotR < center || pivotL > center {\\n\\t\\t\\tpivotL, pivotR = portion(nums, lt, rt)\\n\\t\\t\\tif pivotL > center {\\n\\t\\t\\t\\trt = pivotL - 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlt = pivotR + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tshuffle := func(nums []int) {\\n\\t\\tN := len(nums)\\n\\t\\tfor i := N - 1; i > 0; i-- {\\n\\t\\t\\td := rand.Intn(i + 1)\\n\\t\\t\\tnums[d], nums[i] = nums[i], nums[d]\\n\\t\\t}\\n\\t}\\n\\n\\tshuffle(nums)\\n\\tdivideHalf(nums)\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1468128,
                "title": "c-o-n-time-and-o-n-space-using-randomized-quick-sort",
                "content": "Please upvote if you like the Solution.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    //finds kth element using passed random pivot.\\n    int quick_select(vector<int>& v,int l,int r,int pivot)\\n    {\\n        swap(v[r],v[pivot]);\\n        int i,j;\\n        i=j=l;\\n        while(j<=r)\\n        {\\n            if(v[j]<v[r])\\n            {\\n                swap(v[i],v[j]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        swap(v[i],v[r]);\\n        return i;\\n    }\\n    \\n    \\n    void wiggleSort(vector<int>& v) {\\n        int n=v.size();\\n        int k=(n-1)/2;\\n        int l=0,r=n-1;\\n        //finding middle index using randomized quick sort.\\n        while(1)\\n        {\\n            int pivot=(rand()%(r-l+1))+l;\\n            int x=quick_select(v,l,r,pivot);\\n            if(x==k)break;\\n            else if(x>k)r=x-1;\\n            else l=x+1;\\n        }\\n        int it,i,j;\\n        i=0;\\n        it=0;\\n        int m=v[k];\\n        //after finding the middle index we rearrange the elements of the array as in ,\\n        //all the elements less than or equal to middle element comes before\\n        //all the elemets that are greater than middle element.\\n        while(i<n)\\n        {\\n            if(v[i]<=m)\\n            {\\n                swap(v[it],v[i]);\\n                it++;\\n            }\\n            i++;\\n        }\\n        //copying the array to a temp array.\\n        vector<int> l1=v;\\n        j=n-1;\\n        i=k;\\n        it=0;\\n        //rearranging the array to reqired form by just some simple logic.\\n        while(1)\\n        {\\n            if(j==k||i==-1)break;\\n            v[it]=l1[i];\\n            v[it+1]=l1[j];\\n            it+=2;\\n            i--;\\n            j--;\\n        }\\n        if(i==0)v[it]=l1[i];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //finds kth element using passed random pivot.\\n    int quick_select(vector<int>& v,int l,int r,int pivot)\\n    {\\n        swap(v[r],v[pivot]);\\n        int i,j;\\n        i=j=l;\\n        while(j<=r)\\n        {\\n            if(v[j]<v[r])\\n            {\\n                swap(v[i],v[j]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        swap(v[i],v[r]);\\n        return i;\\n    }\\n    \\n    \\n    void wiggleSort(vector<int>& v) {\\n        int n=v.size();\\n        int k=(n-1)/2;\\n        int l=0,r=n-1;\\n        //finding middle index using randomized quick sort.\\n        while(1)\\n        {\\n            int pivot=(rand()%(r-l+1))+l;\\n            int x=quick_select(v,l,r,pivot);\\n            if(x==k)break;\\n            else if(x>k)r=x-1;\\n            else l=x+1;\\n        }\\n        int it,i,j;\\n        i=0;\\n        it=0;\\n        int m=v[k];\\n        //after finding the middle index we rearrange the elements of the array as in ,\\n        //all the elements less than or equal to middle element comes before\\n        //all the elemets that are greater than middle element.\\n        while(i<n)\\n        {\\n            if(v[i]<=m)\\n            {\\n                swap(v[it],v[i]);\\n                it++;\\n            }\\n            i++;\\n        }\\n        //copying the array to a temp array.\\n        vector<int> l1=v;\\n        j=n-1;\\n        i=k;\\n        it=0;\\n        //rearranging the array to reqired form by just some simple logic.\\n        while(1)\\n        {\\n            if(j==k||i==-1)break;\\n            v[it]=l1[i];\\n            v[it+1]=l1[j];\\n            it+=2;\\n            i--;\\n            j--;\\n        }\\n        if(i==0)v[it]=l1[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448400,
                "title": "java-2ms-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int[] res = new int[nums.length];\\n        int i=1,j=nums.length-1;\\n        while(i < nums.length)\\n        {\\n            res[i] = nums[j];\\n            j--;i+=2;\\n        }\\n        i=0;\\n        while(i < nums.length)\\n        {\\n            res[i] = nums[j];\\n            j--;i+=2;\\n        }\\n        \\n        for(int k=0;k<nums.length;k++)\\n            nums[k] = res[k];\\n        \\n        \\n        return ;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int[] res = new int[nums.length];\\n        int i=1,j=nums.length-1;\\n        while(i < nums.length)\\n        {\\n            res[i] = nums[j];\\n            j--;i+=2;\\n        }\\n        i=0;\\n        while(i < nums.length)\\n        {\\n            res[i] = nums[j];\\n            j--;i+=2;\\n        }\\n        \\n        for(int k=0;k<nums.length;k++)\\n            nums[k] = res[k];\\n        \\n        \\n        return ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175629,
                "title": "99-using-sorting",
                "content": "when the size of the array is odd the number of maximums(peaks) we need is **NH= floor(n/2)** wheras the number of valleys we need is **NL = floor(n/2)+1 elements.**\\nwhen the size of the array is even the number of peaks and valleys are equals **NH=NL=n/2**\\nso we sort the array 1st then for valleys we need the first NL elements elements i.e **a[0,1,...,NL-1]** and for the peaks we need **a[NH,..,N]**\\nTo avoid the compilication of repeating elements occuring together we start filling the elements from the back i.e\\nfor valleys we fill in order NL-1-> NL-2 -> ... -> 0\\nfor peaks we fill in order N-1 -> N-2 .... -> NL\\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& a) {\\n        int i,n=a.size();\\n        int l=0,h=n/2,mx=-1,mn=INT_MAX;\\n        sort(a.begin(),a.end());\\n        if(n&1)\\n            h++;\\n        i=h;\\n        l=h-1;\\n        h=n-1;\\n        vector<int> ans;\\n        while(1){\\n            if(l<0&&h<i)\\n                break;\\n            if(l>=0)\\n                ans.push_back(a[l--]);\\n            if(h>=i)\\n                ans.push_back(a[h--]);\\n        }\\n        for(i=0;i<n;i++)\\n            a[i]=ans[i];       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& a) {\\n        int i,n=a.size();\\n        int l=0,h=n/2,mx=-1,mn=INT_MAX;\\n        sort(a.begin(),a.end());\\n        if(n&1)\\n            h++;\\n        i=h;\\n        l=h-1;\\n        h=n-1;\\n        vector<int> ans;\\n        while(1){\\n            if(l<0&&h<i)\\n                break;\\n            if(l>=0)\\n                ans.push_back(a[l--]);\\n            if(h>=i)\\n                ans.push_back(a[h--]);\\n        }\\n        for(i=0;i<n;i++)\\n            a[i]=ans[i];       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870071,
                "title": "from-o-nlogn-to-easy-to-understand-o-n-to-more-clean-o-n",
                "content": "1.  Time: O(nlogn) Space: O(n)\\n\\u7528sort\\u51FD\\u6570\\u627E\\u5230mid\\u540E\\uFF0C\\u4ECE\\u524D\\u534A\\u6BB5\\u7684\\u672B\\u5C3E(i.e. mid)\\u53D6\\u4E00\\u4E2A\\uFF0C\\u518D\\u4ECE\\u540E\\u534A\\u7684\\u672B\\u5C3E(i.e.len-1)\\u53D6\\u4E00\\u4E2A\\uFF0C\\u8FD9\\u6837\\u4FDD\\u8BC1\\u4E86\\u7B2C\\u4E00\\u4E2A\\u6570\\u5C0F\\u4E8E\\u7B2C\\u4E8C\\u4E2A\\u6570\\uFF0C\\u7136\\u540E\\u4ECE\\u524D\\u534A\\u6BB5\\u53D6\\u5012\\u6570\\u7B2C\\u4E8C\\u4E2A\\uFF0C\\u4ECE\\u540E\\u534A\\u6BB5\\u53D6\\u5012\\u6570\\u7B2C\\u4E8C\\u4E2A\\uFF0C\\u8FD9\\u4FDD\\u8BC1\\u4E86\\u7B2C\\u4E8C\\u4E2A\\u6570\\u5927\\u4E8E\\u7B2C\\u4E09\\u4E2A\\u6570\\uFF0C\\u4E14\\u7B2C\\u4E09\\u4E2A\\u6570\\u5C0F\\u4E8E\\u7B2C\\u56DB\\u4E2A\\u6570\\uFF0C\\u4EE5\\u6B64\\u7C7B\\u63A8\\u76F4\\u81F3\\u90FD\\u53D6\\u5B8C\\u3002\\u4E3A\\u4EC0\\u4E48\\u4E0D\\u4ECE\\u524D\\u534A\\u6BB5\\u5F00\\u5934\\u4EE5\\u53CA\\u540E\\u534A\\u6BB5\\u7684\\u5F00\\u5934(\\u672B\\u5C3E)\\u5F00\\u59CB\\u586B\\u5145\\u7ED3\\u679C\\u6570\\u7EC4\\uFF1F\\u90A3\\u662F\\u56E0\\u4E3A\\u8FD9\\u91CC\\u7528\\u4E86greedy\\u7684\\u601D\\u60F3\\u6765\\u505A\\uFF0C\\u5C3D\\u91CF\\u4ECE\\u5F00\\u59CB\\u5C31\\u907F\\u514Dmid\\u9644\\u8FD1\\u90E8\\u5206\\u7684\\u6570\\u65E0\\u6CD5\\u6EE1\\u8DB3\\u8981\\u6C42\\uFF0C\\u6BD4\\u5982 [4, 5, 5, 6], \\u8FD9\\u6837\\u6362\\u51FA\\u6765\\u7ED3\\u679C\\u5C31\\u662F\\u9519\\u7684\\u3002\\n```\\nclass Solution(object):\\n    def wiggleSort(self, nums):\\n        newNums = sorted(nums)\\n        mid  = (len(nums)-1) / 2\\n        s, l= mid, len(nums) -1\\n        for i in range(len(nums)):\\n            if (i+1) % 2 != 0:\\n                nums[i] = newNums[s]\\n                s -= 1\\n            else:\\n                nums[i] = newNums[l]\\n                l -= 1\\n        numNew = sorted(nums)\\n        n = len(nums)\\n        # mid, last = (n - 1) / 2, n - 1\\n        j, k = 0, (n - 1) / 2 + 1\\n        for i in range(n):\\n            if i%2 == 0:\\n                nums[i] = numNew[j]\\n                j += 1\\n            else:\\n                nums[i] = numNew[k]\\n                k += 1\\n```\\n\\n2.  Time: O(n) Space: O(n)\\n\\u5982\\u4F55\\u4ECEO(nlogn)\\u964D\\u5230O(n)\\uFF1F\\u7531\\u4E8E\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u4E00\\u4E2Awiggle\\u7684pattern\\uFF0C\\u6240\\u4EE5\\u987A\\u5E8F\\u5E76\\u4E0D\\u662F\\u5FC5\\u987B\\u8981\\u4FDD\\u8BC1\\u7684\\uFF0C\\u53EA\\u8981\\u5C06\\u6240\\u6709\\u5C0F\\u4E8Emedian\\u7684\\u6570\\u653E\\u5DE6\\u8FB9\\uFF0C\\u5927\\u4E8Emedian\\u7684\\u6570\\u653E\\u53F3\\u8FB9\\uFF0C\\u6309\\u7167\\u4E4B\\u524D\\u7684\\u6446\\u653E\\u987A\\u5E8F\\uFF0C\\u540C\\u6837\\u53EF\\u4EE5\\u89E3\\u51B3\\u8FD9\\u9898\\u3002\\u90A3\\u4E48\\u627Emedian\\u5B9E\\u9645\\u4E0A\\u53EF\\u4EE5\\u7528the kth smallest number\\u7684quicksort\\u7684\\u601D\\u8DEF\\u6765\\u627Emedian\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u77E5\\u9053\\u4E86median\\u7684index\\uFF0C\\u5230\\u65F6\\u5019\\u53EA\\u9700\\u8981\\u8FD4\\u56DE\\u8FD9\\u4E2Aindex\\u6240\\u5BF9\\u5E94\\u7684\\u6570\\u5373\\u53EF\\u3002\\u8FD9\\u91CC\\u9700\\u8981\\u6CE8\\u610F\\uFF0C\\u4E3A\\u4E86\\u7B80\\u5316code\\uFF0Cquicksort\\u7684partition\\u90E8\\u5206\\u9700\\u8981\\u75283-way partition\\u4F7F\\u5F97\\u6240\\u6709median\\u7684duplicates\\u90FD\\u96C6\\u4E2D\\u5728\\u4E00\\u8D77\\uFF0Ci.e.  \\n\\ta) arr[l..i] elements less than pivot.\\n\\tb) arr[i+1..j-1] elements equal to pivot.\\n\\tc) arr[j..r] elements greater than pivot.\\n\\u6240\\u4EE5\\u8FD9\\u91CC\\u4F7F\\u7528\\u8FD9\\u4E2A\\u6765\\u8FDB\\u884Csort\\u3002\\u6700\\u540E\\u51FA\\u6765\\u7684\\u7ED3\\u679C\\u76F4\\u63A5\\u53EF\\u4EE5\\u7528\\u6765\\u4ECE\\u540E\\u5411\\u524D\\u53BB\\u586B\\u8865odd\\u7684\\u4F4D\\u7F6E\\u548Ceven\\u7684\\u4F4D\\u7F6E\\uFF0C\\u65E0\\u9700\\u518D\\u591A\\u5904\\u7406\\u3002\\u4F46\\u662F\\u5982\\u679C\\u6211\\u4EEC\\u7528\\u4F20\\u7EDF\\u7684two-way quick sort\\u7684\\u601D\\u8DEF\\uFF0C\\u5373, \\u4E0D\\u8003\\u8651median\\u7684duplicates\\u7684\\u60C5\\u51B5\\uFF0C\\u5B83\\u7684duplicate\\u4F1A\\u6563\\u843D\\u5728median\\u7684\\u5DE6\\u8FB9\\u6216\\u53F3\\u8FB9\\uFF0C\\u8FD9\\u6837\\u5728\\u6700\\u540E\\u8FDB\\u884C\\u91CD\\u65B0\\u6392\\u5217\\u6570\\u5B57\\u7684\\u65F6\\u5019\\uFF0C\\u4F1A\\u5B58\\u5728\\u521A\\u597D\\u56E0\\u4E3A\\u4E24\\u4E2Aduplicates\\u88AB\\u5B89\\u6392\\u5728\\u4E00\\u8D77\\u800C\\u4E0D\\u6EE1\\u8DB3\\u9898\\u76EE\\u8981\\u6C42nums[0] < nums[1] > nums[2] < nums[3]\\u2026\\uFF0C\\u6240\\u4EE5\\u4E0D\\u5EFA\\u8BAE\\u75282-way\\u7684\\u601D\\u8DEF\\u6765\\u5B9E\\u73B0\\u8FD9\\u91CC\\u7684findKSmallest\\u91CC\\u7684partition\\u51FD\\u6570\\u3002\\n\\nTwo-way Quick Sort Thread\\n\\n```\\nimport random            \\nclass Solution(object):\\n        def wiggleSort(self, nums):\\n            # n is the length, m is the index of the median in this array\\n            n = len(nums)\\n            m = (n-1)/2\\n            \\n            # get the median number of the array using quicksort O(n)\\n            median = self.kSmallerestNumber(nums, m)\\n            copy = nums[:]\\n            i = j = 0\\n            k = n - 1\\n            \\n            # borrow 3-way quick sort thread to make all smaller numbers at the left of the median and greater numbers at the right of the median\\n            while(j < k):\\n                if copy[j] < median:\\n                    copy[i], copy[j] = copy[j], copy[i]\\n                    i += 1\\n                    j += 1\\n                elif copy[j] > median:\\n                    copy[k], copy[j] = copy[j], copy[k]\\n                    k -= 1\\n                else:\\n                    j += 1\\n\\n            # smaller numbers insert to all even indices\\n            i, j = m, 0\\n            while(i >= 0):\\n                nums[j] = copy[i]\\n                i -= 1\\n                j += 2\\n                \\n            # greater numbers insert to all odd indices\\n            i, j = n-1, 1\\n            while(i > m):\\n                nums[j] = copy[i]\\n                i -= 1\\n                j += 2 \\n            return\\n        \\n        def kSmallerestNumber(self, nums, k):\\n            # shuffle to make the computation averaged to O(n)\\n            random.shuffle(nums)\\n            # k -= 1\\n            l, r = 0, len(nums) - 1\\n            \\n            # here is using m as the condition to stop the loop\\n            while l < r:\\n                m = self.partition(nums, l, r)\\n                if m > k:\\n                    r = m - 1\\n                elif m < k:\\n                    l = m + 1\\n                else:\\n                    break\\n            return nums[k]\\n        \\n        def partition(self, nums, l, r):\\n            pivot = nums[r]\\n            i = l\\n            for j in range(l, r + 1):\\n                if nums[j] < pivot:\\n                    nums[j], nums[i] = nums[i], nums[j]\\n                    i += 1\\n            nums[i], nums[r] = nums[r], nums[i]\\n            return i\\n```\\n\\nThree-way Quick Sort Thread\\n\\n```\\nimport random            \\nclass Solution(object):\\n        def wiggleSort(self, nums):\\n            # n is the length, m is the index of the median in this array\\n            n = len(nums)\\n            m = (n-1)/2\\n            \\n            # get the median number of the array using quicksort O(n)\\n            median = self.kSmallerestNumber(nums, m)\\n            copy = nums[:]\\n\\n            # smaller numbers insert to all even indices\\n            i, j = m, 0\\n            while(i >= 0):\\n                nums[j] = copy[i]\\n                i -= 1\\n                j += 2\\n                \\n            # greater numbers insert to all odd indices\\n            i, j = n-1, 1\\n            while(i > m):\\n                nums[j] = copy[i]\\n                i -= 1\\n                j += 2 \\n            return\\n        \\n        def kSmallerestNumber(self, nums, k):\\n            # shuffle to make the computation averaged to O(n)\\n            random.shuffle(nums)\\n            # k -= 1\\n            l, r = 0, len(nums) - 1\\n            \\n            # here is using m as the condition to stop the loop\\n            while l < r:\\n                m = self.partition(nums, l, r)\\n                if m > k:\\n                    r = m - 1\\n                elif m < k:\\n                    l = m + 1\\n                else:\\n                    break\\n            return nums[k]\\n        \\n        def partition(self, nums, l, r):\\n            pivot = nums[r]\\n            i = left = l\\n            right = r\\n            while (left <= right):\\n                if nums[left] < pivot:\\n                    nums[left], nums[i] = nums[i], nums[left]\\n                    i += 1\\n                    left += 1\\n                elif nums[left] > pivot:\\n                    nums[right], nums[left] = nums[left], nums[right]\\n                    right -= 1\\n                else:\\n                    left += 1            \\n            return i\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wiggleSort(self, nums):\\n        newNums = sorted(nums)\\n        mid  = (len(nums)-1) / 2\\n        s, l= mid, len(nums) -1\\n        for i in range(len(nums)):\\n            if (i+1) % 2 != 0:\\n                nums[i] = newNums[s]\\n                s -= 1\\n            else:\\n                nums[i] = newNums[l]\\n                l -= 1\\n        numNew = sorted(nums)\\n        n = len(nums)\\n        # mid, last = (n - 1) / 2, n - 1\\n        j, k = 0, (n - 1) / 2 + 1\\n        for i in range(n):\\n            if i%2 == 0:\\n                nums[i] = numNew[j]\\n                j += 1\\n            else:\\n                nums[i] = numNew[k]\\n                k += 1\\n```\n```\\nimport random            \\nclass Solution(object):\\n        def wiggleSort(self, nums):\\n            # n is the length, m is the index of the median in this array\\n            n = len(nums)\\n            m = (n-1)/2\\n            \\n            # get the median number of the array using quicksort O(n)\\n            median = self.kSmallerestNumber(nums, m)\\n            copy = nums[:]\\n            i = j = 0\\n            k = n - 1\\n            \\n            # borrow 3-way quick sort thread to make all smaller numbers at the left of the median and greater numbers at the right of the median\\n            while(j < k):\\n                if copy[j] < median:\\n                    copy[i], copy[j] = copy[j], copy[i]\\n                    i += 1\\n                    j += 1\\n                elif copy[j] > median:\\n                    copy[k], copy[j] = copy[j], copy[k]\\n                    k -= 1\\n                else:\\n                    j += 1\\n\\n            # smaller numbers insert to all even indices\\n            i, j = m, 0\\n            while(i >= 0):\\n                nums[j] = copy[i]\\n                i -= 1\\n                j += 2\\n                \\n            # greater numbers insert to all odd indices\\n            i, j = n-1, 1\\n            while(i > m):\\n                nums[j] = copy[i]\\n                i -= 1\\n                j += 2 \\n            return\\n        \\n        def kSmallerestNumber(self, nums, k):\\n            # shuffle to make the computation averaged to O(n)\\n            random.shuffle(nums)\\n            # k -= 1\\n            l, r = 0, len(nums) - 1\\n            \\n            # here is using m as the condition to stop the loop\\n            while l < r:\\n                m = self.partition(nums, l, r)\\n                if m > k:\\n                    r = m - 1\\n                elif m < k:\\n                    l = m + 1\\n                else:\\n                    break\\n            return nums[k]\\n        \\n        def partition(self, nums, l, r):\\n            pivot = nums[r]\\n            i = l\\n            for j in range(l, r + 1):\\n                if nums[j] < pivot:\\n                    nums[j], nums[i] = nums[i], nums[j]\\n                    i += 1\\n            nums[i], nums[r] = nums[r], nums[i]\\n            return i\\n```\n```\\nimport random            \\nclass Solution(object):\\n        def wiggleSort(self, nums):\\n            # n is the length, m is the index of the median in this array\\n            n = len(nums)\\n            m = (n-1)/2\\n            \\n            # get the median number of the array using quicksort O(n)\\n            median = self.kSmallerestNumber(nums, m)\\n            copy = nums[:]\\n\\n            # smaller numbers insert to all even indices\\n            i, j = m, 0\\n            while(i >= 0):\\n                nums[j] = copy[i]\\n                i -= 1\\n                j += 2\\n                \\n            # greater numbers insert to all odd indices\\n            i, j = n-1, 1\\n            while(i > m):\\n                nums[j] = copy[i]\\n                i -= 1\\n                j += 2 \\n            return\\n        \\n        def kSmallerestNumber(self, nums, k):\\n            # shuffle to make the computation averaged to O(n)\\n            random.shuffle(nums)\\n            # k -= 1\\n            l, r = 0, len(nums) - 1\\n            \\n            # here is using m as the condition to stop the loop\\n            while l < r:\\n                m = self.partition(nums, l, r)\\n                if m > k:\\n                    r = m - 1\\n                elif m < k:\\n                    l = m + 1\\n                else:\\n                    break\\n            return nums[k]\\n        \\n        def partition(self, nums, l, r):\\n            pivot = nums[r]\\n            i = left = l\\n            right = r\\n            while (left <= right):\\n                if nums[left] < pivot:\\n                    nums[left], nums[i] = nums[i], nums[left]\\n                    i += 1\\n                    left += 1\\n                elif nums[left] > pivot:\\n                    nums[right], nums[left] = nums[left], nums[right]\\n                    right -= 1\\n                else:\\n                    left += 1            \\n            return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808972,
                "title": "leetcode-324-c-booksun",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size(), m = (n + 1) >> 1;\\n        if (n <= 1) return;\\n        int mid = findkthsmallest(nums, m);\\n        vector<int> aux (nums.begin(), nums.end());\\n        \\n        for (int i = 0, l = 0, r = n - 1; i < r; ){\\n            if (aux[i] == mid) i ++;\\n            else if (aux[i] > mid) swap(aux[i --], aux[r --]);\\n            else swap(aux[l ++], aux[i ++]);\\n        }\\n        \\n        // for (int i = 0; i < n; i ++) cout << aux[i] << \" \";\\n        for (int i = 0, j = m - 1; j >= 0; i += 2, j --) nums[i] = aux[j];\\n        for (int i = 1, j = n - 1; j >= m; i += 2, j --) nums[i] = aux[j];\\n    }\\n    \\n    int findkthsmallest(vector<int>& nums, int k){\\n        int l = 0, r = nums.size() - 1;\\n        \\n        while (l < r){\\n            int mid = partition(nums, l, r);\\n            if (mid == k) break;\\n            else if (mid < k) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return nums[k];\\n    }\\n    \\n    int partition(vector<int>& nums, int l, int r){\\n        int i = l, j = r + 1;\\n        while (i < j){\\n            while(i < r && nums[++ i] <= nums[l]) ;\\n            while(j > l && nums[-- j] >= nums[l]) ;\\n            if (i < j) swap(nums[i], nums[j]);\\n        }\\n        swap(nums[l], nums[j]);\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size(), m = (n + 1) >> 1;\\n        if (n <= 1) return;\\n        int mid = findkthsmallest(nums, m);\\n        vector<int> aux (nums.begin(), nums.end());\\n        \\n        for (int i = 0, l = 0, r = n - 1; i < r; ){\\n            if (aux[i] == mid) i ++;\\n            else if (aux[i] > mid) swap(aux[i --], aux[r --]);\\n            else swap(aux[l ++], aux[i ++]);\\n        }\\n        \\n        // for (int i = 0; i < n; i ++) cout << aux[i] << \" \";\\n        for (int i = 0, j = m - 1; j >= 0; i += 2, j --) nums[i] = aux[j];\\n        for (int i = 1, j = n - 1; j >= m; i += 2, j --) nums[i] = aux[j];\\n    }\\n    \\n    int findkthsmallest(vector<int>& nums, int k){\\n        int l = 0, r = nums.size() - 1;\\n        \\n        while (l < r){\\n            int mid = partition(nums, l, r);\\n            if (mid == k) break;\\n            else if (mid < k) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return nums[k];\\n    }\\n    \\n    int partition(vector<int>& nums, int l, int r){\\n        int i = l, j = r + 1;\\n        while (i < j){\\n            while(i < r && nums[++ i] <= nums[l]) ;\\n            while(j > l && nums[-- j] >= nums[l]) ;\\n            if (i < j) swap(nums[i], nums[j]);\\n        }\\n        swap(nums[l], nums[j]);\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 527410,
                "title": "3-lines-python",
                "content": "\\'\\'\\'\\ndef wiggleSort(self, nums: List[int]) -> None:\\n        \\n       # Do not return anything, modify nums in-place instead.\\n        \\n        k = len(nums)//2\\n        nums.sort(reverse = True)\\n        nums[::2], nums[1::2] = nums[k:], nums[0:k]\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\ndef wiggleSort(self, nums: List[int]) -> None:\\n        \\n       # Do not return anything, modify nums in-place instead.\\n        \\n        k = len(nums)//2\\n        nums.sort(reverse = True)\\n        nums[::2], nums[1::2] = nums[k:], nums[0:k]\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 421678,
                "title": "super-easy-solution-c",
                "content": "This is super easy solution, Have  a look:\\n\\n1) Sort the input array\\n2) Divide it in two halves\\n3) Reverse each half\\n4) Merge them and you\\'re done :)\\n\\nI wonder why everyone is doing it in very complex manner, This method will always work if solution is possible:\\n\\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> v1, v2;\\n        for(int i = 0; i < (n>>1) + (n&1); i++)v1.push_back(nums[i]);\\n        for(int i = (n>>1); i < n; i++)v2.push_back(nums[i]);\\n        reverse(v1.begin(), v1.end());\\n        reverse(v2.begin(), v2.end());\\n        \\n        int s1 = 0, s2 = 0;\\n        for(int i= 0; i < n; i++){\\n            if(i&1){\\n                nums[i] = v2[s2++];\\n            }\\n            else nums[i] = v1[s1++];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> v1, v2;\\n        for(int i = 0; i < (n>>1) + (n&1); i++)v1.push_back(nums[i]);\\n        for(int i = (n>>1); i < n; i++)v2.push_back(nums[i]);\\n        reverse(v1.begin(), v1.end());\\n        reverse(v2.begin(), v2.end());\\n        \\n        int s1 = 0, s2 = 0;\\n        for(int i= 0; i < n; i++){\\n            if(i&1){\\n                nums[i] = v2[s2++];\\n            }\\n            else nums[i] = v1[s1++];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363634,
                "title": "python-medium-three-partion",
                "content": "nums[0] < nums[1] > nums[2] < nums[3]\\nequals to \\n1. nums[1] >= nums[3] >= nums[0] >= nums[2] ok\\n2. nums[3] >= **nums[1] >= nums[0]** >= nums[2] wrong\\n3. nums[1] >= **nums[3] >= nums[2]** >= nums[0] wrong\\n4. nums[3] >= **nums[1] >= nums[2]** >= nums[0] wrong\\n\\ne.g. nums = [1,2,2,3]\\ncut into half    => [1,2]  [2,3]\\n1. both reverse     => [2,3,1,2]\\n2. fir no reverse   => [2,2,1,3] \\n3. sec no reverse   => [1,3,2,2] \\n4. no reverse       => [1,2,2,3] \\nbecause of repeated nums\\n        \\nbuild the mapping relationship from index to virtual index\\n1,3,5,7,...,n,0,2,4,6,...n-1\\ne.g. 1,3,5,0,2,4,6 -> 0,1,2,3,4,5,6,7\\nn|1 sets the last bit of n to 1\\nso it will become the smallest even num not smaller than n\\n```\\ndef virtualIndex(i):\\n    k = 2*i+1\\n    if k < n:\\n        return k\\n    else:\\n        return k - (n|1)\\n```\\n\\ndo three-way partition in On,O1\\n1,3,5,7,......,n,0,2,4,6,......n-1\\n| >medium | =medium  | <medium  |\\n...................i.................jk..................\\n```\\nimport numpy\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        if n < 2:\\n            return\\n        \\n        def A(i):\\n            return (2*i+1) % (n|1)\\n\\n            \\n        # find the medium\\n        # quick select On\\n        midIndex = int(n/2)\\n        key = numpy.median(nums)\\n        # i is the start of 2st part\\n        # j is the end of 2nd part\\n        # k is the end of 2rd part\\n        i,j,k=0,0,n-1\\n        \\n        # while True:\\n        #     pivot = random.randint(i,k)\\n        #     nums[A(pivot)],nums[A(k)] = nums[A(k)],nums[A(pivot)]\\n        #     key = nums[A(pivot)]\\n        while j <= k:\\n            if nums[A(j)] > key:\\n                nums[A(j)],nums[A(i)]=nums[A(i)],nums[A(j)]\\n                i,j = i+1,j+1\\n            elif nums[A(j)] < key:\\n                nums[A(j)],nums[A(k)]=nums[A(k)],nums[A(j)]\\n                k -= 1\\n            else:\\n                j += 1\\n            # if midIndex < i:\\n            #     i,j,k = 0,0,i-1\\n            # elif midIndex > k:\\n            #     i,j,k = k+1,k+1,n-1\\n            # else:\\n            #     return\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef virtualIndex(i):\\n    k = 2*i+1\\n    if k < n:\\n        return k\\n    else:\\n        return k - (n|1)\\n```\n```\\nimport numpy\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        if n < 2:\\n            return\\n        \\n        def A(i):\\n            return (2*i+1) % (n|1)\\n\\n            \\n        # find the medium\\n        # quick select On\\n        midIndex = int(n/2)\\n        key = numpy.median(nums)\\n        # i is the start of 2st part\\n        # j is the end of 2nd part\\n        # k is the end of 2rd part\\n        i,j,k=0,0,n-1\\n        \\n        # while True:\\n        #     pivot = random.randint(i,k)\\n        #     nums[A(pivot)],nums[A(k)] = nums[A(k)],nums[A(pivot)]\\n        #     key = nums[A(pivot)]\\n        while j <= k:\\n            if nums[A(j)] > key:\\n                nums[A(j)],nums[A(i)]=nums[A(i)],nums[A(j)]\\n                i,j = i+1,j+1\\n            elif nums[A(j)] < key:\\n                nums[A(j)],nums[A(k)]=nums[A(k)],nums[A(j)]\\n                k -= 1\\n            else:\\n                j += 1\\n            # if midIndex < i:\\n            #     i,j,k = 0,0,i-1\\n            # elif midIndex > k:\\n            #     i,j,k = k+1,k+1,n-1\\n            # else:\\n            #     return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332357,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int n = nums.length;\\n        int[] res = Arrays.copyOf(nums, n);\\n        Arrays.sort(res);\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[(2 * i + 1) % (n | 1)] = res[n - 1 - i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int n = nums.length;\\n        int[] res = Arrays.copyOf(nums, n);\\n        Arrays.sort(res);\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[(2 * i + 1) % (n | 1)] = res[n - 1 - i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309677,
                "title": "java-3ms-6lines",
                "content": "```java\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int []temp = nums.clone();\\n        Arrays.sort(temp);\\n        int l = (temp.length & 1) == 0 ? temp.length / 2 - 1 : temp.length / 2;\\n        int r = temp.length - 1,t = 0;\\n        while(t < temp.length){\\n            nums[t ++] = (t & 1) == 1 ? temp[l --] : temp[r --]; \\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int []temp = nums.clone();\\n        Arrays.sort(temp);\\n        int l = (temp.length & 1) == 0 ? temp.length / 2 - 1 : temp.length / 2;\\n        int r = temp.length - 1,t = 0;\\n        while(t < temp.length){\\n            nums[t ++] = (t & 1) == 1 ? temp[l --] : temp[r --]; \\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201882,
                "title": "python-o-n",
                "content": "```\\n    def wiggleSort(self, nums):\\n        def partition(l, r):\\n            p = r\\n            while l+1 < p:\\n                if nums[l] > nums[p]:\\n                    nums[l], nums[p-1], nums[p] = nums[p-1], nums[p], nums[l]\\n                    p -= 1\\n                else:\\n                    l += 1\\n            if nums[l] > nums[p]:\\n                nums[l], nums[p] = nums[p], nums[l]\\n                p -= 1\\n            return p\\n        \\n        def getMedian(nums):\\n            l = 0\\n            r = len(nums) - 1\\n            m = (l+r)//2\\n            while True:\\n                p = partition(l, r)\\n                if p == m:\\n                    return nums[m]\\n                elif p < m:\\n                    l = p+1\\n                else:\\n                    r = p-1\\n            return m\\n            \\n        mid = getMedian(nums)\\n        l = 0\\n        r = len(nums)-1\\n        m = 0\\n        wig = lambda i, n=len(nums)|1: (2*i + 1) % n\\n        while m <= r:\\n            cur = nums[wig(m)]\\n            if cur == mid:\\n                m += 1\\n            elif cur > mid:\\n                nums[wig(l)], nums[wig(m)] = nums[wig(m)], nums[wig(l)]\\n                l += 1\\n                m += 1\\n            else:\\n                nums[wig(r)], nums[wig(m)] = nums[wig(m)], nums[wig(r)]\\n                r -= 1\\n```",
                "solutionTags": [],
                "code": "```\\n    def wiggleSort(self, nums):\\n        def partition(l, r):\\n            p = r\\n            while l+1 < p:\\n                if nums[l] > nums[p]:\\n                    nums[l], nums[p-1], nums[p] = nums[p-1], nums[p], nums[l]\\n                    p -= 1\\n                else:\\n                    l += 1\\n            if nums[l] > nums[p]:\\n                nums[l], nums[p] = nums[p], nums[l]\\n                p -= 1\\n            return p\\n        \\n        def getMedian(nums):\\n            l = 0\\n            r = len(nums) - 1\\n            m = (l+r)//2\\n            while True:\\n                p = partition(l, r)\\n                if p == m:\\n                    return nums[m]\\n                elif p < m:\\n                    l = p+1\\n                else:\\n                    r = p-1\\n            return m\\n            \\n        mid = getMedian(nums)\\n        l = 0\\n        r = len(nums)-1\\n        m = 0\\n        wig = lambda i, n=len(nums)|1: (2*i + 1) % n\\n        while m <= r:\\n            cur = nums[wig(m)]\\n            if cur == mid:\\n                m += 1\\n            elif cur > mid:\\n                nums[wig(l)], nums[wig(m)] = nums[wig(m)], nums[wig(l)]\\n                l += 1\\n                m += 1\\n            else:\\n                nums[wig(r)], nums[wig(m)] = nums[wig(m)], nums[wig(r)]\\n                r -= 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 168758,
                "title": "4ms-99-java-solution",
                "content": "I made a O(n) average find kth median then partition version in python but it TLEd, so I just sorted, reversed, then partitioned even though it is O(nlogn). We need to reverse since we want to use as many spaces as possible for greater numbers.  We need to match the smallest numbers next to the biggest numbers possible otherwise we can accidently have the same number next to each other near the beginning (this happens in [4,5,5,6] ).  If we don\\'t reverse we will get 4 5 5 6 which is wrong.  If we do, we will get 5 6 4 5\\n```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length/2;++i){\\n            int temp = nums[i];\\n            nums[i]=nums[nums.length-1-i];\\n            nums[nums.length-1-i]=temp;\\n        }\\n        int [] arr = Arrays.copyOf(nums,nums.length);\\n        int j = 0;\\n        for(int i=1; i<nums.length;i+=2){\\n            nums[i]=arr[j];\\n            ++j;\\n        }\\n        for(int i=0; i<nums.length;i+=2){\\n            nums[i]=arr[j];\\n            ++j;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length/2;++i){\\n            int temp = nums[i];\\n            nums[i]=nums[nums.length-1-i];\\n            nums[nums.length-1-i]=temp;\\n        }\\n        int [] arr = Arrays.copyOf(nums,nums.length);\\n        int j = 0;\\n        for(int i=1; i<nums.length;i+=2){\\n            nums[i]=arr[j];\\n            ++j;\\n        }\\n        for(int i=0; i<nums.length;i+=2){\\n            nums[i]=arr[j];\\n            ++j;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77718,
                "title": "no-virtual-index-3-way-partitioning-from-two-ends",
                "content": "```\\nclass Solution(object):\\n    def wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if nums:\\n            median = heapq.nsmallest(len(nums) / 2 + 1, nums)[-1]\\n            large, small = 1, len(nums) - 1 if len(nums) % 2 == 1 else len(nums) - 2\\n            # go through small section\\n            i = small\\n            while i > -1:\\n                if nums[i] < median:\\n                    nums[i], nums[small] = nums[small], nums[i]\\n                    small -= 2\\n                    i -= 2\\n                elif nums[i] > median:\\n                    nums[i], nums[large] = nums[large], nums[i]\\n                    large += 2\\n                else:\\n                    i -= 2\\n            # go through large section\\n            i = large\\n            while i < len(nums):\\n                if nums[i] < median:\\n                    nums[i], nums[small] = nums[small], nums[i]\\n                    small -= 2\\n                elif nums[i] > median:\\n                    nums[i], nums[large] = nums[large], nums[i]\\n                    large += 2\\n                    i += 2\\n                else:\\n                    i += 2\\n```\\nExample:\\nWe need to arrange nums into something resembling this:\\n```\\n0  1  2  3  4  5\\nM     S     S\\n   L     L     M\\n```\\nWe actually need to partition array into 3 sections: large, median and small.\\nHow to do it without virtual indexing?\\nLet's move the first list towards right:\\n```\\n              0   2   4\\n1   3   5\\n              M   S   S\\nL   L   M\\n```\\nNow it is our normal partitioning case. By observation, we know that L starts from 1, so LLM... is 1, 3, 5...; we also know that S starts backwards from len(nums) - 1 if len(nums) is odd, or len(nums) - 2 if len(nums) is even. If we look backwards, SSM is x, x - 2, x - 4...till 0.\\n\\nI named large and small two pointers to record which part is already built. small pointer means all the numbers after it are smaller than median. large pointer means all the numbers before it are bigger than median.\\n\\nWe can go from the end of S to 0 to build small section first, and then we start from the unbuilt position of large section and build the rest of large section. Then medians must be left in the middle.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if nums:\\n            median = heapq.nsmallest(len(nums) / 2 + 1, nums)[-1]\\n            large, small = 1, len(nums) - 1 if len(nums) % 2 == 1 else len(nums) - 2\\n            # go through small section\\n            i = small\\n            while i > -1:\\n                if nums[i] < median:\\n                    nums[i], nums[small] = nums[small], nums[i]\\n                    small -= 2\\n                    i -= 2\\n                elif nums[i] > median:\\n                    nums[i], nums[large] = nums[large], nums[i]\\n                    large += 2\\n                else:\\n                    i -= 2\\n            # go through large section\\n            i = large\\n            while i < len(nums):\\n                if nums[i] < median:\\n                    nums[i], nums[small] = nums[small], nums[i]\\n                    small -= 2\\n                elif nums[i] > median:\\n                    nums[i], nums[large] = nums[large], nums[i]\\n                    large += 2\\n                    i += 2\\n                else:\\n                    i += 2\\n```\n```\\n0  1  2  3  4  5\\nM     S     S\\n   L     L     M\\n```\n```\\n              0   2   4\\n1   3   5\\n              M   S   S\\nL   L   M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77715,
                "title": "a-acceptable-solution-accepted-almost-best-in-c-well-explained",
                "content": "> Can there any true O(n) solution of this problem?\\n\\nI solved this by sorting and using another O(n) space to store the sorted elements and then rearranging them into the original array.\\n\\nThere are several things we should clearly find out:\\n\\n- in the result array, the even index position will contain smaller elements while the odd index position bigger ones;\\n- to avoid the middle part of the sorted array meet each other too quick (for example if we rearrange them like this: the smaller in ascending order, the bigger in descending order -> in different order but filling the result array in the same direction); so we have to rearrange them in the same order to the result array;\\n- but soon we will tumble into a dilemma by this test case <font color=\"#ff0000\">[4, 5, 5, 6]</font> in which if we rearrange them as the rules mentioned above it can be wrong;\\n\\n> how about starting to place them from the end of the result array? then -> 5, 6, 4, 5 should be the result (the smaller: 4, 5; the bigger: 5, 6 and place the bigger first 5 since the last index is 3, an odd index then the first 4 of the smaller and then the second of the bigger 6, and then the second of the smaller 5). Quite right! <font color=\"#0000ff\"> the odd and even position rule -> big : odd, small : even</font>\\n\\nBang! End of Story!\\n\\n- space cost O(n)\\n- time cost O(nlogn)\\n\\n\\n----------\\n\\n    void swap(int* p, int* q)\\n    {\\n        int t=*p; *p=*q; *q=t;\\n    }\\n    \\n    void sort(int* nums, int begin, int end)\\n    {\\n        int l=begin, r=end;\\n        int v = nums[l+(r-l)/2];\\n        while(l <= r)\\n        {\\n            while(nums[l] < v) l++;\\n            while(nums[r] > v) r--;\\n            if(l <= r)\\n            {\\n                swap(nums+l, nums+r);\\n                l++; r--;\\n            }\\n        }\\n        if(begin < r)\\n            sort(nums, begin, r);\\n        if(l < end)\\n            sort(nums, l, end);\\n    }\\n    \\n    //AC - 40ms;\\n    void wiggleSort(int* nums, int size)\\n    {\\n        sort(nums, 0, size-1); //using quick sort to sort the array first;\\n        int *arr = (int*)malloc(sizeof(int)*size);\\n        for(int i = 0; i < size; i++)\\n            arr[i] = nums[i];\\n        int small= 0; //the first of smallers;\\n        int big = (size-1)/2+1; //the first of biggers;\\n        int index = size-1; //start to fill in reverse direction: from right to left;\\n        if(size%2 == 0) //if the size is even then the last should be indexed by odd size-1, so place the bigger one in odd position size-1;\\n            nums[index--] = arr[big++];\\n        while(index > -1)\\n        {\\n            nums[index--] = arr[small++];\\n            if(index > -1) //in case of \"underflow\";\\n                nums[index--] = arr[big++];\\n        }\\n    }",
                "solutionTags": [],
                "code": "> Can there any true O(n) solution of this problem?\\n\\nI solved this by sorting and using another O(n) space to store the sorted elements and then rearranging them into the original array.\\n\\nThere are several things we should clearly find out:\\n\\n- in the result array, the even index position will contain smaller elements while the odd index position bigger ones;\\n- to avoid the middle part of the sorted array meet each other too quick (for example if we rearrange them like this: the smaller in ascending order, the bigger in descending order -> in different order but filling the result array in the same direction); so we have to rearrange them in the same order to the result array;\\n- but soon we will tumble into a dilemma by this test case <font color=\"#ff0000\">[4, 5, 5, 6]</font> in which if we rearrange them as the rules mentioned above it can be wrong;\\n\\n> how about starting to place them from the end of the result array? then -> 5, 6, 4, 5 should be the result (the smaller: 4, 5; the bigger: 5, 6 and place the bigger first 5 since the last index is 3, an odd index then the first 4 of the smaller and then the second of the bigger 6, and then the second of the smaller 5). Quite right! <font color=\"#0000ff\"> the odd and even position rule -> big : odd, small : even</font>\\n\\nBang! End of Story!\\n\\n- space cost O(n)\\n- time cost O(nlogn)\\n\\n\\n----------\\n\\n    void swap(int* p, int* q)\\n    {\\n        int t=*p; *p=*q; *q=t;\\n    }\\n    \\n    void sort(int* nums, int begin, int end)\\n    {\\n        int l=begin, r=end;\\n        int v = nums[l+(r-l)/2];\\n        while(l <= r)\\n        {\\n            while(nums[l] < v) l++;\\n            while(nums[r] > v) r--;\\n            if(l <= r)\\n            {\\n                swap(nums+l, nums+r);\\n                l++; r--;\\n            }\\n        }\\n        if(begin < r)\\n            sort(nums, begin, r);\\n        if(l < end)\\n            sort(nums, l, end);\\n    }\\n    \\n    //AC - 40ms;\\n    void wiggleSort(int* nums, int size)\\n    {\\n        sort(nums, 0, size-1); //using quick sort to sort the array first;\\n        int *arr = (int*)malloc(sizeof(int)*size);\\n        for(int i = 0; i < size; i++)\\n            arr[i] = nums[i];\\n        int small= 0; //the first of smallers;\\n        int big = (size-1)/2+1; //the first of biggers;\\n        int index = size-1; //start to fill in reverse direction: from right to left;\\n        if(size%2 == 0) //if the size is even then the last should be indexed by odd size-1, so place the bigger one in odd position size-1;\\n            nums[index--] = arr[big++];\\n        while(index > -1)\\n        {\\n            nums[index--] = arr[small++];\\n            if(index > -1) //in case of \"underflow\";\\n                nums[index--] = arr[big++];\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3907254,
                "title": "count-beats-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Fill the <b>odd</b> indices (startig from 1)  with values in descending order.\\n After that start filling the  <b>even</b> indices (starting  from 0 ) with next set of remaining  values! \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n# Code\\n```\\nvoid wiggleSort(int* nums, int numsSize){\\n      int arr[5001];\\n      for(int i=0;i<5001;i++) arr[i]=0;\\n      for(int i=0;i<numsSize;i++){\\n          arr[nums[i]]++;\\n      }\\n      int end=5000;\\n      int in=1;   //start to  fill largest value from 1 index\\n       while(in<numsSize && end>-1){\\n          if(arr[end]==0){ end--; continue;}\\n          else{  nums[in]=end;\\n                 in+=2;\\n                 arr[end]--;\\n          }\\n      }\\n      in=0; // start to fill next set of values from index 0\\n        while(in<numsSize && end>-1){\\n          if(arr[end]==0){ end--; continue;}\\n          else{  nums[in]=end;\\n                 in+=2;\\n                 arr[end]--;\\n          }\\n      }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid wiggleSort(int* nums, int numsSize){\\n      int arr[5001];\\n      for(int i=0;i<5001;i++) arr[i]=0;\\n      for(int i=0;i<numsSize;i++){\\n          arr[nums[i]]++;\\n      }\\n      int end=5000;\\n      int in=1;   //start to  fill largest value from 1 index\\n       while(in<numsSize && end>-1){\\n          if(arr[end]==0){ end--; continue;}\\n          else{  nums[in]=end;\\n                 in+=2;\\n                 arr[end]--;\\n          }\\n      }\\n      in=0; // start to fill next set of values from index 0\\n        while(in<numsSize && end>-1){\\n          if(arr[end]==0){ end--; continue;}\\n          else{  nums[in]=end;\\n                 in+=2;\\n                 arr[end]--;\\n          }\\n      }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3741295,
                "title": "python-solution-easy-solution-using-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        nums.sort()\\n        n = len(nums)\\n\\n        # divide the nums into 2 sorted array\\n        # then each time take the maximum from both the heap using max heap\\n        # for even no of terms there will be no prbm\\n        \\'\\'\\'\\n            first max ele in the first half \\n            then max ele in the second half\\n        \\'\\'\\'\\n        # for odd no of terms intially add the mid ele  \\n        \\'\\'\\'\\n            first max ele in the second half \\n            then max ele in the first half\\n        \\'\\'\\'\\n\\n        if n&1 :\\n            ans = []\\n            mid = n//2 \\n            ans += [nums[mid]]\\n            a = [-x for x in nums[:mid]]\\n            b = [-x for x in nums[mid+1:]]\\n            heapq.heapify(a)\\n            heapq.heapify(b)\\n            cnt = mid \\n            while(cnt) :\\n                ans += [-heapq.heappop(b)]\\n                ans += [ -heapq.heappop(a)]\\n                cnt -= 1 \\n            nums[::] = ans[::]\\n        else:\\n            ans = []\\n            mid = n//2 \\n            a = [-x for x in nums[:mid]]\\n            b = [-x for x in nums[mid:]]\\n            heapq.heapify(a)\\n            heapq.heapify(b)\\n            cnt = mid \\n            while(cnt) :\\n                ans += [ -heapq.heappop(a)]\\n                ans += [-heapq.heappop(b)]\\n                cnt -= 1 \\n            nums[::] = ans[::]\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        nums.sort()\\n        n = len(nums)\\n\\n        # divide the nums into 2 sorted array\\n        # then each time take the maximum from both the heap using max heap\\n        # for even no of terms there will be no prbm\\n        \\'\\'\\'\\n            first max ele in the first half \\n            then max ele in the second half\\n        \\'\\'\\'\\n        # for odd no of terms intially add the mid ele  \\n        \\'\\'\\'\\n            first max ele in the second half \\n            then max ele in the first half\\n        \\'\\'\\'\\n\\n        if n&1 :\\n            ans = []\\n            mid = n//2 \\n            ans += [nums[mid]]\\n            a = [-x for x in nums[:mid]]\\n            b = [-x for x in nums[mid+1:]]\\n            heapq.heapify(a)\\n            heapq.heapify(b)\\n            cnt = mid \\n            while(cnt) :\\n                ans += [-heapq.heappop(b)]\\n                ans += [ -heapq.heappop(a)]\\n                cnt -= 1 \\n            nums[::] = ans[::]\\n        else:\\n            ans = []\\n            mid = n//2 \\n            a = [-x for x in nums[:mid]]\\n            b = [-x for x in nums[mid:]]\\n            heapq.heapify(a)\\n            heapq.heapify(b)\\n            cnt = mid \\n            while(cnt) :\\n                ans += [ -heapq.heappop(a)]\\n                ans += [-heapq.heappop(b)]\\n                cnt -= 1 \\n            nums[::] = ans[::]\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568728,
                "title": "wiggle-sort-ii-simple-solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) copy the nums array\\n2) sort the sort array\\n3) itarate nums from index 1 to length and increment by 2 add sorted array of last index and decrement index;\\n4) same for nums from index 0 to length and increment by 2.\\n\\n# Complexity\\n- Time complexity: O(n log n) used sort method\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar wiggleSort = function(nums) {\\n    let copyNums = nums.slice(0,nums.length);\\n    copyNums.sort((a,b)=>a-b);\\n    let id = copyNums.length-1;\\n\\n    for(let i=1; i<copyNums.length; i+=2){\\n        nums[i] = copyNums[id];\\n        id--;\\n    }\\n        // id++;\\n    for(let i=0; i<copyNums.length; i+=2){\\n        nums[i] = copyNums[id];\\n        id--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar wiggleSort = function(nums) {\\n    let copyNums = nums.slice(0,nums.length);\\n    copyNums.sort((a,b)=>a-b);\\n    let id = copyNums.length-1;\\n\\n    for(let i=1; i<copyNums.length; i+=2){\\n        nums[i] = copyNums[id];\\n        id--;\\n    }\\n        // id++;\\n    for(let i=0; i<copyNums.length; i+=2){\\n        nums[i] = copyNums[id];\\n        id--;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3346261,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        length = len(nums)\\n        nums.sort()\\n        mid = (length-1)//2\\n        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        length = len(nums)\\n        nums.sort()\\n        mid = (length-1)//2\\n        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330377,
                "title": "easy-solution-python-divide-and-conquer",
                "content": "# Intuition\\nSlice it mid way and index alternatively.\\n\\n# Approach\\n- Slice the list midway.\\n- Creat two lists [0:mid) and [mid:N)\\n- - index alternatively.\\n\\n# Complexity\\n- Time complexity: NlogN\\n\\n- Space complexity: 1\\n\\n# Code\\n```\\nclass Solution(object):\\n    def wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        N = len(nums)\\n        # sorted array\\n        nums.sort()\\n        # split into 2 parts, [0, mid) and [mid,N)\\n        mid = (N-1)//2\\n        \\n        # alternatively index from each list.\\n        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Divide and Conquer",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def wiggleSort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        N = len(nums)\\n        # sorted array\\n        nums.sort()\\n        # split into 2 parts, [0, mid) and [mid,N)\\n        mid = (N-1)//2\\n        \\n        # alternatively index from each list.\\n        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216181,
                "title": "using-sort",
                "content": "# Code\\n```\\nclass Solution\\n{\\n    /**\\n     * @param Integer[] $nums\\n     * @return NULL\\n     */\\n    function wiggleSort(&$nums) \\n    {\\n        $len = count($nums);\\n        //array of 1 element no need to sort\\n        if ($len <= 1) {\\n            return;\\n        }\\n\\n        sort($nums);\\n\\n        //array of 2 elements cand be desc, so just sorting\\n        if ($len === 2) {\\n            return;\\n        }\\n\\n        //split values to min and max parts\\n        $median = ceil($len / 2);\\n        $min = array_slice($nums, 0, $median);\\n        $max = array_slice($nums, $median);\\n\\n        //if array even length than reversing to avoid case\\n        //where the values of the center identical\\n        if ($len % 2 == 0) {\\n            $min = array_reverse($min);\\n            $max = array_reverse($max);\\n        }\\n\\n        $nums = [];\\n        for ($i = 0; $i < count($min); $i++) {\\n            $nums[] = $min[$i];\\n            if (isset($max[$i])) {\\n                $nums[] = $max[$i];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n    /**\\n     * @param Integer[] $nums\\n     * @return NULL\\n     */\\n    function wiggleSort(&$nums) \\n    {\\n        $len = count($nums);\\n        //array of 1 element no need to sort\\n        if ($len <= 1) {\\n            return;\\n        }\\n\\n        sort($nums);\\n\\n        //array of 2 elements cand be desc, so just sorting\\n        if ($len === 2) {\\n            return;\\n        }\\n\\n        //split values to min and max parts\\n        $median = ceil($len / 2);\\n        $min = array_slice($nums, 0, $median);\\n        $max = array_slice($nums, $median);\\n\\n        //if array even length than reversing to avoid case\\n        //where the values of the center identical\\n        if ($len % 2 == 0) {\\n            $min = array_reverse($min);\\n            $max = array_reverse($max);\\n        }\\n\\n        $nums = [];\\n        for ($i = 0; $i < count($min); $i++) {\\n            $nums[] = $min[$i];\\n            if (isset($max[$i])) {\\n                $nums[] = $max[$i];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968237,
                "title": "python-easy-code-solution-with-approach",
                "content": "# Approach\\nIn wiggle sort 2 we cannot use the logic of wiggle sort 1, as in wiggle sort 1 we can keep the equal value as nums[0] <= nums[1] >= nums[2] <= nums[3] >= ...... This is how the wiggle sort 1 was.\\nBut wiggle sort 2 is differet so we cannot use the same logic as nums[0] < nums[1] > nums[2] < nums[3] > ..........\\n\\nSo will do as follows:\\nStep 1: Sort the Array\\nStep 2: Now make extra space as of new blank array a[0]*len(nums)\\nStep 3: Now at odd index as 1, 3, 5... replace 0 with the decending order of the sorted array then as the odd element is full then fill the even element as 0, 2, 4, ..... with the remaing element in the same decending order.\\n\\neg: \\nnums = [1,5,1,1,6,4]\\nstep 1: sorted array = [1,1,1,4,5,6]\\nstep 2: a = [0,0,0,0,0,0]\\nstep 3: a = [0,6,0,5,0,4]  \\n        a = [1,6,1,5,1,4]   This is the final output\\n\\n# Code\\n```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        nums.sort()\\n        a = [0] * len(nums)\\n        l = len(nums)\\n        j = l-1\\n        for i in range(1,l,2):\\n            a[i] = nums[j]\\n            j -= 1\\n        for i in range(0,l,2):\\n            a[i] = nums[j]\\n            j -= 1\\n        for i in range(l):\\n            nums[i] = a[i]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Divide and Conquer",
                    "Sorting",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        nums.sort()\\n        a = [0] * len(nums)\\n        l = len(nums)\\n        j = l-1\\n        for i in range(1,l,2):\\n            a[i] = nums[j]\\n            j -= 1\\n        for i in range(0,l,2):\\n            a[i] = nums[j]\\n            j -= 1\\n        for i in range(l):\\n            nums[i] = a[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660675,
                "title": "can-we-achieve-this-in-o-n-time-complexity",
                "content": "The sorting solution is quite intuitive and i understood that approach. But just curious to know if there\\'s a way to get this done around  linear complexity? Something similar to the way we did for wiggle sort 1?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2544314,
                "title": "super-easy-o-n-log-n-o-n",
                "content": "```\\npublic void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] ans=new int[nums.length];\\n        int j=nums.length-1;\\n        for(int i=1;i<nums.length;i+=2){\\n            ans[i]=nums[j--];\\n        }\\n        for(int i=0;i<nums.length;i+=2){\\n            ans[i]=nums[j--];\\n        }\\n        for(int i=0;i<ans.length;i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] ans=new int[nums.length];\\n        int j=nums.length-1;\\n        for(int i=1;i<nums.length;i+=2){\\n            ans[i]=nums[j--];\\n        }\\n        for(int i=0;i<nums.length;i+=2){\\n            ans[i]=nums[j--];\\n        }\\n        for(int i=0;i<ans.length;i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2526130,
                "title": "using-sorting-easy-to-understand",
                "content": "```\\npublic void wiggleSort(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0;i<arr.length;i++)\\n            arr[i] = nums[i];\\n        Arrays.sort(arr);\\n        int j = arr.length-1;\\n        for(int i=1;i<arr.length;i+=2)\\n            nums[i] = arr[j--];\\n        for(int i=0;i<arr.length;i+=2)\\n            nums[i] = arr[j--];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic void wiggleSort(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0;i<arr.length;i++)\\n            arr[i] = nums[i];\\n        Arrays.sort(arr);\\n        int j = arr.length-1;\\n        for(int i=1;i<arr.length;i+=2)\\n            nums[i] = arr[j--];\\n        for(int i=0;i<arr.length;i+=2)\\n            nums[i] = arr[j--];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2413964,
                "title": "python-sort-o-nlogn-clean-code",
                "content": "```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        arr = list(reversed(sorted(nums)))\\n        nums[1::2] = arr[:len(arr)//2]\\n        nums[::2] = arr[len(arr)//2:]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        arr = list(reversed(sorted(nums)))\\n        nums[1::2] = arr[:len(arr)//2]\\n        nums[::2] = arr[len(arr)//2:]",
                "codeTag": "Java"
            },
            {
                "id": 2380216,
                "title": "python-simple-sorting",
                "content": "\\n    def wiggleSort(self, nums):\\n        k = len(nums)//2\\n        nums.sort(reverse = True)\\n        nums[::2], nums[1::2] = nums[k:], nums[:k]",
                "solutionTags": [],
                "code": "\\n    def wiggleSort(self, nums):\\n        k = len(nums)//2\\n        nums.sort(reverse = True)\\n        nums[::2], nums[1::2] = nums[k:], nums[:k]",
                "codeTag": "Python3"
            },
            {
                "id": 2309941,
                "title": "java-easy-approach",
                "content": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int num : nums){\\n            pq.offer(num);\\n        }\\n        \\n        for(int i = 1;i<n;i=i+2){\\n            nums[i] = pq.peek();\\n            pq.poll();\\n        }\\n        \\n        for(int i = 0;i<n;i=i+2){\\n            nums[i] = pq.peek();\\n            pq.poll();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int num : nums){\\n            pq.offer(num);\\n        }\\n        \\n        for(int i = 1;i<n;i=i+2){\\n            nums[i] = pq.peek();\\n            pq.poll();\\n        }\\n        \\n        for(int i = 0;i<n;i=i+2){\\n            nums[i] = pq.peek();\\n            pq.poll();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270037,
                "title": "step-by-step-explanation-using-two-pointer-approach-easy-to-understand",
                "content": "We are using two pointer approach and solving it in\\n\\n\\n//CODE\\n```\\nvoid wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());  // sort the array first\\n        \\n        vector<int> temp(n); // creating a temporary array of size n\\n        int i = 1, j = n-1;  // initializing the pointers\\n\\t\\t// in the while loop placing the elements in temp such that nums[i-1]<nums[i]>nums[i+1]\\n        while(i <nums.size()){\\n            temp[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        i = 0;\\n        while(i<nums.size()){\\n            temp[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n\\t\\t//copying back elements in nums\\n        for(int it =0; it<n;it++){\\n            nums[it] = temp[it];\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nvoid wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());  // sort the array first\\n        \\n        vector<int> temp(n); // creating a temporary array of size n\\n        int i = 1, j = n-1;  // initializing the pointers\\n\\t\\t// in the while loop placing the elements in temp such that nums[i-1]<nums[i]>nums[i+1]\\n        while(i <nums.size()){\\n            temp[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        i = 0;\\n        while(i<nums.size()){\\n            temp[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n\\t\\t//copying back elements in nums\\n        for(int it =0; it<n;it++){\\n            nums[it] = temp[it];\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2268642,
                "title": "wiggle-sort-ii",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid wiggleSort(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\n\\t\\t\\tint end = nums.size()-1;\\n\\n\\t\\t\\tint mid = end/2;\\n\\t\\t\\tint i=0;\\n\\t\\t\\tvector<int> ans(nums.size());\\n\\t\\t\\twhile(i<nums.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i%2==0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// cout<<i<<\" \"<<nums[mid]<<endl;\\n\\t\\t\\t\\t\\tans[i]=nums[mid];\\n\\t\\t\\t\\t\\tmid--;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// cout<<i<<\" \"<<nums[end]<<endl;\\n\\t\\t\\t\\t\\tans[i]=nums[end];\\n\\t\\t\\t\\t\\tend--;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnums = ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid wiggleSort(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\n\\t\\t\\tint end = nums.size()-1;\\n\\n\\t\\t\\tint mid = end/2;\\n\\t\\t\\tint i=0;\\n\\t\\t\\tvector<int> ans(nums.size());\\n\\t\\t\\twhile(i<nums.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i%2==0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// cout<<i<<\" \"<<nums[mid]<<endl;\\n\\t\\t\\t\\t\\tans[i]=nums[mid];\\n\\t\\t\\t\\t\\tmid--;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}",
                "codeTag": "C++"
            },
            {
                "id": 2241580,
                "title": "c-solution-o-nlogn-o-n-sloution-median",
                "content": "For Better understanding check that post: O(n) + O(1) after median --- NO indexing required\\nhttps://leetcode.com/problems/wiggle-sort-ii/discuss/755415/O(n)-%2B-O(1)-after-median-NO-indexing-required\\n```\\nclass Solution {\\npublic:\\n    //Brute force, Using Sorting O(nlogn)\\n    void wiggleSort(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        vector<int> ans(n);\\n\\n        int j = n-1;\\n        for(int i = 1;i<n;i += 2){\\n            ans[i] = nums[j--];\\n        }\\n        for(int i = 0;i<n;i += 2){\\n            ans[i] = nums[j--];\\n        }\\n        nums = ans;\\n    }\\n    \\n    //Using quickselect find median O(n)\\n    void wiggleSort(vector<int>& nums) {\\n        int len = nums.size();\\n        if(len==1 || len==0)return;\\n        \\n        nth_element(nums.begin(),nums.begin() + len/2,nums.end());  //median\\n        int mid = nums[len/2];\\n        int largePos = 1;                           //Odd position from start for larger than median numbers\\n        int smallPos = len%2==0 ? len-2: len-1;     //Even position from end for smaller than median numbers\\n        int cur = 0;\\n        while(cur<len) {\\n            \\n\\t\\t\\t//Avoiding already checked even positions from the end\\n            if(nums[cur]<mid && (cur<smallPos || (cur>=smallPos && cur%2!=0))) {\\n                swap(nums[cur],nums[smallPos]);\\n                smallPos-=2;\\n            }\\n            \\n\\t\\t\\t//Avoiding already checked odd positions from the start\\n            else if(nums[cur]>mid && (largePos<cur || (largePos>=cur && cur%2==0))) {\\n                swap(nums[cur],nums[largePos]);\\n                largePos+=2;\\n            }\\n            \\n            else cur++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Brute force, Using Sorting O(nlogn)\\n    void wiggleSort(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        vector<int> ans(n);\\n\\n        int j = n-1;\\n        for(int i = 1;i<n;i += 2){\\n            ans[i] = nums[j--];\\n        }\\n        for(int i = 0;i<n;i += 2){\\n            ans[i] = nums[j--];\\n        }\\n        nums = ans;\\n    }\\n    \\n    //Using quickselect find median O(n)\\n    void wiggleSort(vector<int>& nums) {\\n        int len = nums.size();\\n        if(len==1 || len==0)return;\\n        \\n        nth_element(nums.begin(),nums.begin() + len/2,nums.end());  //median\\n        int mid = nums[len/2];\\n        int largePos = 1;                           //Odd position from start for larger than median numbers\\n        int smallPos = len%2==0 ? len-2: len-1;     //Even position from end for smaller than median numbers\\n        int cur = 0;\\n        while(cur<len) {\\n            \\n\\t\\t\\t//Avoiding already checked even positions from the end\\n            if(nums[cur]<mid && (cur<smallPos || (cur>=smallPos && cur%2!=0))) {\\n                swap(nums[cur],nums[smallPos]);\\n                smallPos-=2;\\n            }\\n            \\n\\t\\t\\t//Avoiding already checked odd positions from the start\\n            else if(nums[cur]>mid && (largePos<cur || (largePos>=cur && cur%2==0))) {\\n                swap(nums[cur],nums[largePos]);\\n                largePos+=2;\\n            }\\n            \\n            else cur++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238175,
                "title": "all-solutions-in-one-o-n-o-1",
                "content": "sort the array and divide it into 2 halfs\\n\\n[ l1,l2,l3,l4]  [r1,r2,r3,r4]\\n\\nnow r1> all elements in left part bcz its given that  a solution exist\\n\\nso [ l4 ,r4 , l3 ,r3, l2, r2, l1 ,r1 ]  ==> is always a solution\\n\\n\\nobservation\\n\\nlength  even -> reapiting elements can\\'t be more that n/2;\\n\\nlength odd\\n\\nreapiting elements can\\'t more that (n+1)/2;\\nand if count of reapiting elements  == (n+1)/2 then on sorting the array these reapiting elements will be first (n+1)/2 elemenst of the sorted array ( the value that is reapiting (n+1)/2 times is the smallest value of the array)\\n\\nsolution 1: O(NlogN)   O(N)\\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        \\n        vector<int>ans;\\n        sort(nums.begin(),nums.end());\\n        \\n        int n=nums.size();\\n        \\n        int start=(n-1)/2;\\n        int end=n-1;\\n        \\n        while(start>=0)\\n        {\\n            ans.push_back(nums[start]);\\n                start--;\\n            \\n            if(end>(n-1)/2)\\n            {\\n                ans.push_back(nums[end]);\\n                end--;\\n            }\\n        }\\n        \\n        nums=ans;\\n        \\n        \\n    }\\n};\\n\\n\\n```\\n\\nSolution 2: O(N)  O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    void partition(vector<int>& nums,int mid) // to understand this so \"sort colors\" leetcode question\\n    {\\n        int i=-1;\\n        int n=nums.size();\\n        int j=nums.size();\\n        \\n        \\n        int k=i+1;\\n        \\n        while(k<j)\\n        {\\n            if(nums[k]==mid)\\n            {\\n                k++;\\n            }\\n            else if(nums[k]<mid)\\n            {\\n                i++;\\n                swap(nums[i],nums[k]);\\n                k++;\\n            }\\n            else if(nums[k]>mid)\\n            {\\n                j--;\\n                swap(nums[j],nums[k]);\\n            }\\n        }\\n    }\\n    void wiggleSort(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        if(n<2)\\n            return;\\n        \\n       \\n        int k=(n+1)/2;\\n        vector<int>ans;\\n        nth_element(nums.begin(),nums.begin()+k,nums.end());\\n        \\n        int mid=*(nums.begin()+k);\\n         \\n        int m=(n-1)/2;\\n        \\n        int l=m;\\n        int r=n-1;\\n        partition(nums,mid);\\n        while(l>=0)\\n        {\\n            ans.push_back(nums[l]);\\n            l--;\\n            \\n            if(r>m)\\n            {\\n                ans.push_back(nums[r]);\\n                r--;\\n            }\\n                \\n        }\\n        \\n       nums=ans;\\n    }\\n};\\n```\\n\\nO(N)  O(1)\\n\\n virtual indexing\\n \\n**FOR ODD LENGHT ARRAY**\\n\\n ...............................M\\n index  0   .1   .2  ..3. 4 .....     5   .6.   .7..    8\\n array   .l1  l2  l3  l4  l5...    .. r1  r2  r3  r4   \\n\\t\\nwiggle array                ..................    l5  r4  l4  r3  l3  r2  l2  r1  l1\\n  index in original array     4  .8.   .3.   .7.   2 .6 .1 .  5 .0\\n\\t\\n\\t\\nk<=m\\n\\tshift is given by ==> 2*m-3*k   by observation (write few examples and observe)\\n\\tso new index of k is give by 2*m-3*k+k;\\n\\t\\nk>m\\n\\tshift is given by ==> 1+4*m-3*k   by observation (write few examples and observe)\\n\\tso new index of k is give by 1+4*m-3*k+k;\\n\\t\\n\\n**FOR EVEN LENGHT ARRAY**\\n\\nk<=m\\nshift =     2*m-3*k\\nnew index = 2*m-3*k+k;\\n\\nk>m\\nshift  =  4*m-3*k+3;\\nnew index = 4*m-3*k+3+k;\\n\\nIN THE PREVIOUS SOLUTION WE WHERE FIRST PARTITIONING THE ARRAY THEN ARRANGING THE ARRAY\\n\\nIN THIS SOLUTION WE ARE PARTITIONING ON THE BASIS OF THE NEW(VIRTUAL INDEXING) THIS ENSURES THAT PARTITIONING AND ARRANGING IS DONE TOGETHER\\n\\n```\\nclass Solution {\\npublic:\\n    int vir(int i,int p,int e)\\n    {\\n        int shift;\\n        if(e)\\n        {\\n            if(i<=p)\\n                shift=2*p-3*i;\\n            else\\n                shift=4*p-3*i+3;\\n        }\\n        else\\n        {\\n            if(i<=p)\\n                shift= 2*p-3*i;\\n            else\\n                shift= 1+4*p-3*i;\\n        }\\n        \\n       \\n        return i+shift;\\n    }\\n    void partition(vector<int>& nums,int mid,int p) //dutch flag algo\\n    {\\n        int i=-1;\\n        int n=nums.size();\\n        int j=nums.size();\\n        \\n        int e=(n+1)%2;\\n      \\n        \\n        int k=i+1;\\n        \\n        while(k<j)\\n        {\\n            if(nums[vir(k,p,e)]==mid)\\n            {\\n                k++;\\n            }\\n            else if(nums[vir(k,p,e)]<mid)\\n            {\\n                i++;\\n                swap(nums[vir(i,p,e)],nums[vir(k,p,e)]);\\n                k++;\\n            }\\n            else if(nums[vir(k,p,e)]>mid)\\n            {\\n                j--;\\n                swap(nums[vir(j,p,e)],nums[vir(k,p,e)]);\\n            }\\n        }\\n    }\\n    void wiggleSort(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        if(n<2)\\n            return;\\n        \\n       \\n        int k=(n+1)/2;\\n      \\n        nth_element(nums.begin(),nums.begin()+k,nums.end());\\n        \\n        int mid=*(nums.begin()+k);\\n         \\n        int m=(n-1)/2;\\n        \\n        int l=m;\\n        int r=n-1;\\n        \\n        partition(nums,mid,m);\\n        \\n    }\\n};\\n```\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        \\n        vector<int>ans;\\n        sort(nums.begin(),nums.end());\\n        \\n        int n=nums.size();\\n        \\n        int start=(n-1)/2;\\n        int end=n-1;\\n        \\n        while(start>=0)\\n        {\\n            ans.push_back(nums[start]);\\n                start--;\\n            \\n            if(end>(n-1)/2)\\n            {\\n                ans.push_back(nums[end]);\\n                end--;\\n            }\\n        }\\n        \\n        nums=ans;\\n        \\n        \\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    void partition(vector<int>& nums,int mid) // to understand this so \"sort colors\" leetcode question\\n    {\\n        int i=-1;\\n        int n=nums.size();\\n        int j=nums.size();\\n        \\n        \\n        int k=i+1;\\n        \\n        while(k<j)\\n        {\\n            if(nums[k]==mid)\\n            {\\n                k++;\\n            }\\n            else if(nums[k]<mid)\\n            {\\n                i++;\\n                swap(nums[i],nums[k]);\\n                k++;\\n            }\\n            else if(nums[k]>mid)\\n            {\\n                j--;\\n                swap(nums[j],nums[k]);\\n            }\\n        }\\n    }\\n    void wiggleSort(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        if(n<2)\\n            return;\\n        \\n       \\n        int k=(n+1)/2;\\n        vector<int>ans;\\n        nth_element(nums.begin(),nums.begin()+k,nums.end());\\n        \\n        int mid=*(nums.begin()+k);\\n         \\n        int m=(n-1)/2;\\n        \\n        int l=m;\\n        int r=n-1;\\n        partition(nums,mid);\\n        while(l>=0)\\n        {\\n            ans.push_back(nums[l]);\\n            l--;\\n            \\n            if(r>m)\\n            {\\n                ans.push_back(nums[r]);\\n                r--;\\n            }\\n                \\n        }\\n        \\n       nums=ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int vir(int i,int p,int e)\\n    {\\n        int shift;\\n        if(e)\\n        {\\n            if(i<=p)\\n                shift=2*p-3*i;\\n            else\\n                shift=4*p-3*i+3;\\n        }\\n        else\\n        {\\n            if(i<=p)\\n                shift= 2*p-3*i;\\n            else\\n                shift= 1+4*p-3*i;\\n        }\\n        \\n       \\n        return i+shift;\\n    }\\n    void partition(vector<int>& nums,int mid,int p) //dutch flag algo\\n    {\\n        int i=-1;\\n        int n=nums.size();\\n        int j=nums.size();\\n        \\n        int e=(n+1)%2;\\n      \\n        \\n        int k=i+1;\\n        \\n        while(k<j)\\n        {\\n            if(nums[vir(k,p,e)]==mid)\\n            {\\n                k++;\\n            }\\n            else if(nums[vir(k,p,e)]<mid)\\n            {\\n                i++;\\n                swap(nums[vir(i,p,e)],nums[vir(k,p,e)]);\\n                k++;\\n            }\\n            else if(nums[vir(k,p,e)]>mid)\\n            {\\n                j--;\\n                swap(nums[vir(j,p,e)],nums[vir(k,p,e)]);\\n            }\\n        }\\n    }\\n    void wiggleSort(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        if(n<2)\\n            return;\\n        \\n       \\n        int k=(n+1)/2;\\n      \\n        nth_element(nums.begin(),nums.begin()+k,nums.end());\\n        \\n        int mid=*(nums.begin()+k);\\n         \\n        int m=(n-1)/2;\\n        \\n        int l=m;\\n        int r=n-1;\\n        \\n        partition(nums,mid,m);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183695,
                "title": "java-priorityqueue-solution-easy-to-understand",
                "content": "The Priority Queue is in reverse order so it will always have the largest number at its peek\\nWe\\'ll first add the largest n / 2 elements of PQ at odd possitions (1, 3, 5, ...) and then add the remaining at even positions (2, 4, 6, ...)\\n```\\npublic static void wiggleSort(int[] arr) {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n    for (int i = 0; i < arr.length; i++)\\n      pq.offer(arr[i]);\\n    \\n    for (int i = 1; i < arr.length; i = i + 2) \\n      arr[i] = pq.poll();\\n    \\n    for (int i = 0; i < arr.length; i = i + 2) \\n      arr[i] = pq.poll();\\n  }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic static void wiggleSort(int[] arr) {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n    for (int i = 0; i < arr.length; i++)\\n      pq.offer(arr[i]);\\n    \\n    for (int i = 1; i < arr.length; i = i + 2) \\n      arr[i] = pq.poll();\\n    \\n    for (int i = 0; i < arr.length; i = i + 2) \\n      arr[i] = pq.poll();\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2174703,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 :-  (Brute Force) :- Using Sorting And Two Pointer***\\n\\n* ***Time Complexity : O(NlogN)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        \\n        vector<int> arr = nums;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int n = arr.size();\\n        \\n        int low;\\n        \\n        if(n % 2 == 0)  // total elements are even in number\\n        {\\n            low = n / 2 - 1;\\n        }\\n        else   // total elements are odd in number\\n        {\\n            low = n / 2;\\n        }\\n        \\n        int high = n - 1;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                nums[i] = arr[low--];\\n            }\\n            else\\n            {\\n                nums[i] = arr[high--];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        \\n        vector<int> arr = nums;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int n = arr.size();\\n        \\n        int low;\\n        \\n        if(n % 2 == 0)  // total elements are even in number\\n        {\\n            low = n / 2 - 1;\\n        }\\n        else   // total elements are odd in number\\n        {\\n            low = n / 2;\\n        }\\n        \\n        int high = n - 1;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                nums[i] = arr[low--];\\n            }\\n            else\\n            {\\n                nums[i] = arr[high--];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143754,
                "title": "java-priority-queue",
                "content": "```\\npublic void wiggleSort(int[] arr) {\\n        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>(Collections.reverseOrder());\\n        for (int n : arr) priorityQueue.add(n);\\n        for (int i = 1; i < arr.length; i += 2) arr[i] = priorityQueue.poll();\\n        for (int i = 0; i < arr.length; i += 2) arr[i] = priorityQueue.poll();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic void wiggleSort(int[] arr) {\\n        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>(Collections.reverseOrder());\\n        for (int n : arr) priorityQueue.add(n);\\n        for (int i = 1; i < arr.length; i += 2) arr[i] = priorityQueue.poll();\\n        for (int i = 0; i < arr.length; i += 2) arr[i] = priorityQueue.poll();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2103659,
                "title": "solved-using-priority-queue-easy-understanding",
                "content": "```class Solution {\\n    public void wiggleSort(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i =0; i < nums.length; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        int size = pq.size();\\n        for(int i=1; i < size; i+=2){\\n           nums[i] = pq.poll();\\n        }\\n        for(int i =0; i < size; i+=2){\\n            nums[i] = pq.poll();\\n        }\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```class Solution {\\n    public void wiggleSort(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i =0; i < nums.length; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        int size = pq.size();\\n        for(int i=1; i < size; i+=2){\\n           nums[i] = pq.poll();\\n        }\\n        for(int i =0; i < size; i+=2){\\n            nums[i] = pq.poll();\\n        }\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2089884,
                "title": "python-o-n-quick-sort-for-median-virtual-indexing-with-key-concepts",
                "content": "1. Virtual Indexing: By accessing the array with m(i) if the array is partial sorted into 3 sets. **[<median][median][>median]**. m(i) will take care of alternately arranging elements of the array into odd and even locations\\n\\n2. Generating [<median][median][>median]: Running quicksort with partial calls i.e only the side of the pivot which has median is recursed on instead of both sides. Median is returned in O(n) average complexity\\n3. For cases where multiple numbers are present with median value, for the algo. to work they must all be in the together in the middle of our partially sorted array\\nex. 5 5 5 1 6\\nmust be 1 5 5 5 6\\nand not 5 1 5 6 5\\nSo the generic quick sort partition module must be modified to always partition in a way that pivot equivalent numbers come to the middle of the array. This is done by running two pointers from low and high for swapping.\\n\\n\\'\\'\\'\\n\\n\\timport random\\n\\n\\tdef partition(nums, low, high):\\n\\n\\t\\tpi = random.randint(low, high)\\n\\t\\tpivot = nums[m(pi)]\\n\\n\\t\\ti = low         # points to smaller elements cur idx\\n\\t\\tj = high\\n\\t\\tk = low\\n\\t\\twhile k <= j:\\n\\t\\t\\tif nums[m(k)] > pivot:\\n\\t\\t\\t\\tnums[m(k)], nums[m(i)] = nums[m(i)], nums[m(k)]\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tk += 1\\n\\t\\t\\telif nums[m(k)] < pivot:\\n\\t\\t\\t\\tnums[m(k)], nums[m(j)] = nums[m(j)], nums[m(k)]\\n\\t\\t\\t\\tj -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tk += 1\\n\\n\\t\\treturn i, j\\n\\n\\n\\tdef quicksort(nums, low, high, median):\\n\\n\\t\\twhile True:\\n\\t\\t\\tpi, pj = partition(nums, low, high)\\n\\t\\t\\tif pi <= median <= pj:\\n\\t\\t\\t\\treturn\\n\\t\\t\\telif median < pi:\\n\\t\\t\\t\\thigh = pi - 1\\n\\t\\t\\telif median > pj:\\n\\t\\t\\t\\tlow = pj + 1\\n\\n\\t\\treturn\\n\\n\\tdef m(i):\\n\\t\\treturn (1 + 2*i) % (N | 1)\\n\\n\\tclass Solution:\\n\\t\\tdef wiggleSort(self, nums: List[int]) -> None:\\n\\t\\t\\tglobal N\\n\\t\\t\\tN = len(nums)\\n\\t\\t\\tquicksort(nums, 0, len(nums)-1, len(nums)//2)\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "1. Virtual Indexing: By accessing the array with m(i) if the array is partial sorted into 3 sets. **[<median][median][>median]**. m(i) will take care of alternately arranging elements of the array into odd and even locations\\n\\n2. Generating [<median][median][>median]: Running quicksort with partial calls i.e only the side of the pivot which has median is recursed on instead of both sides. Median is returned in O(n) average complexity\\n3. For cases where multiple numbers are present with median value, for the algo. to work they must all be in the together in the middle of our partially sorted array\\nex. 5 5 5 1 6\\nmust be 1 5 5 5 6\\nand not 5 1 5 6 5\\nSo the generic quick sort partition module must be modified to always partition in a way that pivot equivalent numbers come to the middle of the array. This is done by running two pointers from low and high for swapping.\\n\\n\\'\\'\\'\\n\\n\\timport random\\n\\n\\tdef partition(nums, low, high):\\n\\n\\t\\tpi = random.randint(low, high)\\n\\t\\tpivot = nums[m(pi)]\\n\\n\\t\\ti = low         # points to smaller elements cur idx\\n\\t\\tj = high\\n\\t\\tk = low\\n\\t\\twhile k <= j:\\n\\t\\t\\tif nums[m(k)] > pivot:\\n\\t\\t\\t\\tnums[m(k)], nums[m(i)] = nums[m(i)], nums[m(k)]\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tk += 1\\n\\t\\t\\telif nums[m(k)] < pivot:\\n\\t\\t\\t\\tnums[m(k)], nums[m(j)] = nums[m(j)], nums[m(k)]\\n\\t\\t\\t\\tj -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tk += 1\\n\\n\\t\\treturn i, j\\n\\n\\n\\tdef quicksort(nums, low, high, median):\\n\\n\\t\\twhile True:\\n\\t\\t\\tpi, pj = partition(nums, low, high)\\n\\t\\t\\tif pi <= median <= pj:\\n\\t\\t\\t\\treturn\\n\\t\\t\\telif median < pi:\\n\\t\\t\\t\\thigh = pi - 1\\n\\t\\t\\telif median > pj:\\n\\t\\t\\t\\tlow = pj + 1\\n\\n\\t\\treturn\\n\\n\\tdef m(i):\\n\\t\\treturn (1 + 2*i) % (N | 1)\\n\\n\\tclass Solution:\\n\\t\\tdef wiggleSort(self, nums: List[int]) -> None:\\n\\t\\t\\tglobal N\\n\\t\\t\\tN = len(nums)\\n\\t\\t\\tquicksort(nums, 0, len(nums)-1, len(nums)//2)\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2070912,
                "title": "java-solution-using-maxheap",
                "content": "class Solution {\\n    public void wiggleSort(int[] nums) {\\n      PriorityQueue<Integer> pqInMaxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for (int num : nums) {\\n            pqInMaxHeap.add(num);\\n        }\\n        \\n        for(int i = 1; i < nums.length; i += 2){\\n            nums[i] = pqInMaxHeap.remove();\\n        }\\n\\n        for(int i = 0; i < nums.length; i += 2){\\n            nums[i] = pqInMaxHeap.remove();\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void wiggleSort(int[] nums) {\\n      PriorityQueue<Integer> pqInMaxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for (int num : nums) {\\n            pqInMaxHeap.add(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2060176,
                "title": "c-easy-solution-with-explanation",
                "content": "Approach : \\n        1. sort the array then divide array on the two halves [0-n/2] and (n/2-n]   {n = nums.size()-1}\\n        2. pick one element from the first half starting from n/2 and move left.\\n        3. pick one element from the second half starting from n and move left. \\n       \\n        \\n```\\nvoid wiggleSort(vector<int>& nums) {\\n       vector<int> ans;\\n        int n=nums.size()-1;\\n        int start=n/2;\\n        int end = n;\\n\\n        sort(nums.begin(),nums.end());\\n        \\n        while(start>=0){\\n            ans.push_back(nums[start--]);\\n            if(end>n/2)\\n                ans.push_back(nums[end--]);\\n        }\\n        nums=ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvoid wiggleSort(vector<int>& nums) {\\n       vector<int> ans;\\n        int n=nums.size()-1;\\n        int start=n/2;\\n        int end = n;\\n\\n        sort(nums.begin(),nums.end());\\n        \\n        while(start>=0){\\n            ans.push_back(nums[start--]);\\n            if(end>n/2)\\n                ans.push_back(nums[end--]);\\n        }\\n        nums=ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2006991,
                "title": "easy-java-o-n-space-and-o-nlogn-time",
                "content": "```\\nclass Solution {\\n    \\n    public void wiggleSort(int[] nums) {\\n        int prev = nums[0], n = nums.length, j = n-1;\\n        Arrays.sort(nums);\\n        int[] temp = new int[n];\\n        for(int i=1;i<n;i+=2){\\n            temp[i] = nums[j--];\\n        }\\n        \\n        for(int i=0;i<n;i+=2){\\n            temp[i] = nums[j--];\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i] = temp[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public void wiggleSort(int[] nums) {\\n        int prev = nums[0], n = nums.length, j = n-1;\\n        Arrays.sort(nums);\\n        int[] temp = new int[n];\\n        for(int i=1;i<n;i+=2){\\n            temp[i] = nums[j--];\\n        }\\n        \\n        for(int i=0;i<n;i+=2){\\n            temp[i] = nums[j--];\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i] = temp[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840368,
                "title": "go-simple-with-o-n-space",
                "content": "Traverse from max to min inserting at every other index (1, 3, 5...). When index is out of bounds, start over at index 0 for lower half (0, 2, 4...).\\n\\n```go\\nfunc wiggleSort(nums []int)  {\\n    seen := make([]int, 5001)\\n    for _, num := range nums {\\n        seen[num]++\\n    }\\n    index := 1\\n    for i := len(seen) - 1; i >= 0; i-- {\\n        for ; seen[i] > 0; seen[i]-- {\\n            if index >= len(nums) {\\n                index = 0\\n            }\\n            nums[index] = i\\n            index += 2\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc wiggleSort(nums []int)  {\\n    seen := make([]int, 5001)\\n    for _, num := range nums {\\n        seen[num]++\\n    }\\n    index := 1\\n    for i := len(seen) - 1; i >= 0; i-- {\\n        for ; seen[i] > 0; seen[i]-- {\\n            if index >= len(nums) {\\n                index = 0\\n            }\\n            nums[index] = i\\n            index += 2\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1837540,
                "title": "c-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        priority_queue<int>pq(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i+=2){\\n            nums[i]=pq.top();\\n            pq.pop();\\n        }\\n        for(int i=0;i<nums.size();i+=2){\\n            nums[i]=pq.top();\\n            pq.pop();\\n        }\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        priority_queue<int>pq(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i+=2){\\n            nums[i]=pq.top();\\n            pq.pop();\\n        }\\n        for(int i=0;i<nums.size();i+=2){\\n            nums[i]=pq.top();\\n            pq.pop();\\n        }\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800232,
                "title": "step-by-step-explaination-please-upvote-guys",
                "content": "***see guys what i do in here\\nif u observe pattern like in wiggle sort u can easily solve this\\njust put all numbers in temperary vector sort it and then place it alternatively in the original vector*\\n\\n# HERE IS THE CODE\\nTIME COMPLEXITY IS 0(N) AND SPACE COMPLECXITY IS O(N)\\n\\n\\n\\n\\n```\\n\\n```class Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp.push_back(nums[i]);\\n        }\\n        sort(temp.begin(),temp.end());\\n        int c=n-1;\\n        for(int i=1;i<nums.size();i=i+2)\\n        {\\n            nums[i]=temp[c];\\n            c--;\\n        }\\n        \\n        for(int i=0;i<nums.size();i=i+2)\\n        {\\n            nums[i]=temp[c];\\n            c--;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795743,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        vector<int> temp=nums; int n=nums.size();\\n        sort(temp.begin(), temp.end());\\n        int j=n-1;\\n        for(int i=1;i<n;i=i+2)\\n        {\\n            nums[i]=temp[j--];\\n        }\\n        for(int i=0;i<n;i=i+2)\\n        {\\n            nums[i]=temp[j--];\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        vector<int> temp=nums; int n=nums.size();\\n        sort(temp.begin(), temp.end());\\n        int j=n-1;\\n        for(int i=1;i<n;i=i+2)\\n        {\\n            nums[i]=temp[j--];\\n        }\\n        for(int i=0;i<n;i=i+2)\\n        {\\n            nums[i]=temp[j--];\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794800,
                "title": "this-is-what-they-expect-in-interview",
                "content": "class Solution {\\npublic:\\n```\\n    void wiggleSort(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]=nums[i];\\n        }\\n        sort(v.begin(),v.end());\\n        int j=n-1;\\n        for(int i=1;i<n;i+=2)\\n        {\\n            nums[i]=v[j--];\\n        }\\n          for(int i=0;i<n;i+=2)\\n        {\\n            nums[i]=v[j--];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    void wiggleSort(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]=nums[i];\\n        }\\n        sort(v.begin(),v.end());\\n        int j=n-1;\\n        for(int i=1;i<n;i+=2)\\n        {\\n            nums[i]=v[j--];\\n        }\\n          for(int i=0;i<n;i+=2)\\n        {\\n            nums[i]=v[j--];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1721711,
                "title": "java-solution-time-o-n-space-o-1",
                "content": "\\n```\\nclass Solution {\\n    \\n    int index = 5000;\\n    int[] count = new int[index+1];\\n    public void wiggleSort(int[] nums) {\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            count[nums[i]]++;\\n        }\\n        \\n        for(int i=1; i<nums.length; i+=2){\\n            nums[i] = nextVal();\\n        }\\n        \\n        for(int i=0; i<nums.length; i+=2){\\n            nums[i] = nextVal();\\n        }\\n    }\\n    \\n    private int nextVal(){\\n        while(count[index] == 0){\\n            index--;\\n        }\\n        count[index]--;\\n        return index;\\n    }\\n}\\n```\\n\\nNote: Defining a constant space array of 5000 is consider constant space.",
                "solutionTags": [
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int index = 5000;\\n    int[] count = new int[index+1];\\n    public void wiggleSort(int[] nums) {\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            count[nums[i]]++;\\n        }\\n        \\n        for(int i=1; i<nums.length; i+=2){\\n            nums[i] = nextVal();\\n        }\\n        \\n        for(int i=0; i<nums.length; i+=2){\\n            nums[i] = nextVal();\\n        }\\n    }\\n    \\n    private int nextVal(){\\n        while(count[index] == 0){\\n            index--;\\n        }\\n        count[index]--;\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715037,
                "title": "java-solution-time-o-nlogn",
                "content": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int[] res = new int[nums.length];\\n        int n = nums.length;\\n        \\n        // odd indexes\\n        int i = 1;\\n        int k = n - 1;\\n        \\n        while(i < nums.length){\\n            res[i] = nums[k];\\n            i += 2;\\n            k--;\\n        }\\n        \\n        // even indexes\\n        i = 0;\\n        \\n        while(i < nums.length){\\n            res[i] = nums[k];\\n            i += 2;\\n            k--;\\n        }\\n        \\n        // copy res to nums\\n        for(int j = 0 ; j < nums.length ; j++){\\n            nums[j] = res[j];\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int[] res = new int[nums.length];\\n        int n = nums.length;\\n        \\n        // odd indexes\\n        int i = 1;\\n        int k = n - 1;\\n        \\n        while(i < nums.length){\\n            res[i] = nums[k];\\n            i += 2;\\n            k--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1643506,
                "title": "c-solution-o-1-space-o-nlogn-time",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return;\\n        sort(nums.begin(),nums.end());\\n        int it1=(n%2!=0)?n/2:(n/2)-1;\\n        int it2=n-1,max=nums[it2]+1;;\\n        for(int i=0;i<n;i+=2)\\n            nums[i]=(nums[it1--]%max)*max+nums[i];\\n        for(int i=1;i<n;i+=2)\\n            nums[i]=(nums[it2--]%max)*max+nums[i];\\n        for(int i=0;i<n;i++)\\n            nums[i]/=max;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return;\\n        sort(nums.begin(),nums.end());\\n        int it1=(n%2!=0)?n/2:(n/2)-1;\\n        int it2=n-1,max=nums[it2]+1;;\\n        for(int i=0;i<n;i+=2)\\n            nums[i]=(nums[it1--]%max)*max+nums[i];\\n        for(int i=1;i<n;i+=2)\\n            nums[i]=(nums[it2--]%max)*max+nums[i];\\n        for(int i=0;i<n;i++)\\n            nums[i]/=max;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630808,
                "title": "simple-java-using-sort-with-explanation-2ms-97-91",
                "content": "```\\n public void wiggleSort(int[] nums) {\\n    Arrays.sort(nums);\\n    int[] result = new int[nums.length];\\n    int index = nums.length -1, i = 1;\\n    // Start filling all peaks (which is all at odd indexes) from start\\n    for (; i < nums.length; i+= 2) {\\n      result[i] = nums[index];\\n      --index;\\n    }\\n\\n    // Start filling all valleys (which is all at even indexes) from end\\n    // why from end, as the last peak index may have smallest largest value, so to\\n    // make sure, that is also \\'>\\', fill in the smallest element near it.\\n    i = ((nums.length -1) % 2 == 0) ? nums.length -1: nums.length - 2;\\n    index = 0;\\n    for (; i >= 0; i-= 2) {\\n      result[i] = nums[index];\\n      ++index;\\n    }\\n    System.arraycopy(result, 0, nums, 0, nums.length);\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n public void wiggleSort(int[] nums) {\\n    Arrays.sort(nums);\\n    int[] result = new int[nums.length];\\n    int index = nums.length -1, i = 1;\\n    // Start filling all peaks (which is all at odd indexes) from start\\n    for (; i < nums.length; i+= 2) {\\n      result[i] = nums[index];\\n      --index;\\n    }\\n\\n    // Start filling all valleys (which is all at even indexes) from end\\n    // why from end, as the last peak index may have smallest largest value, so to\\n    // make sure, that is also \\'>\\', fill in the smallest element near it.\\n    i = ((nums.length -1) % 2 == 0) ? nums.length -1: nums.length - 2;\\n    index = 0;\\n    for (; i >= 0; i-= 2) {\\n      result[i] = nums[index];\\n      ++index;\\n    }\\n    System.arraycopy(result, 0, nums, 0, nums.length);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1622525,
                "title": "py3-py-simple-solution-using-deque",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        # Init\\n        x = sorted(nums)\\n        m = len(x)\\n        n = m // 2\\n        nums.clear()\\n        \\n        # Split\\n        if m%2:\\n            y,z = deque(x[:n+1]), deque(x[n+1:]) # Odd Split\\n        else: \\n            y,z = deque(x[:n]), deque(x[n:]) # Even split\\n            \\n        # Wiggle sort\\n        while y or z:\\n            if y:\\n                nums.append(y.pop())\\n            if z:\\n                nums.append(z.pop())\\n            \\n        return \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        # Init\\n        x = sorted(nums)\\n        m = len(x)\\n        n = m // 2\\n        nums.clear()\\n        \\n        # Split\\n        if m%2:\\n            y,z = deque(x[:n+1]), deque(x[n+1:]) # Odd Split\\n        else: \\n            y,z = deque(x[:n]), deque(x[n:]) # Even split\\n            \\n        # Wiggle sort\\n        while y or z:\\n            if y:\\n                nums.append(y.pop())\\n            if z:\\n                nums.append(z.pop())\\n            \\n        return \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619490,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> temp = nums;\\n        \\n        sort(temp.begin( ),temp.end( ));\\n        \\n\\n        \\n        int i = n-1;\\n        \\n      int  j = i / 2;\\n        \\n        int k = 0;\\n        \\n        while(k < n)\\n        {\\n            if(k & 1){\\n                \\n                nums[k++] = temp[i--];\\n            }\\n            else{\\n                \\n                nums[k++] = temp[j--];\\n            }\\n            \\n        }\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> temp = nums;\\n        \\n        sort(temp.begin( ),temp.end( ));\\n        \\n\\n        \\n        int i = n-1;\\n        \\n      int  j = i / 2;\\n        \\n        int k = 0;\\n        \\n        while(k < n)\\n        {\\n            if(k & 1){\\n                \\n                nums[k++] = temp[i--];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1587463,
                "title": "324-wiggle-sort-ii",
                "content": "---\\n\\n- All are almost same\\n  - Round / Trunc\\n  - Sort ascending / descending\\n  - For loop left to right, or right to left\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar wiggleSort = function (nums) {\\n    let n = nums.length;\\n    let half = Math.round(n / 2);\\n\\n    nums.sort((a, b) => a - b);\\n\\n    let alternating = [];\\n    for (let i = half - 1, j = n - 1; i >= 0; i--, j--) {\\n        alternating.push(nums[i]);\\n        alternating.push(nums[j]); // last one may be undefined\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        nums[i] = alternating[i];\\n    }\\n    return nums;\\n};\\n```\\n\\n---\\n\\n```\\nvar wiggleSort = function (nums) {\\n    let n = nums.length;\\n    let half = Math.trunc(n / 2);\\n\\n    nums.sort((a, b) => b - a);\\n\\n    let alternating = [];\\n    for (let i = 0, j = half; j < n; i++, j++) {\\n        alternating.push(nums[j]);\\n        alternating.push(nums[i]);\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        nums[i] = alternating[i];\\n    }\\n\\n    return nums;\\n};\\n```\\n\\n---\\n\\n```\\nvar wiggleSort = function (nums) {\\n    let n = nums.length;\\n    let half = Math.trunc(n / 2);\\n\\n    nums.sort((a, b) => b - a);\\n\\n    let alternating = [];\\n    for (let i = half, j = 0; i < n; i++, j++) {\\n        alternating.push(nums[i]);\\n        alternating.push(nums[j]);\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        nums[i] = alternating[i];\\n    }\\n\\n    return nums;\\n};\\n```\\n\\n---\\n\\n```\\nvar wiggleSort = function (nums) {\\n    let n = nums.length;\\n    let half = Math.trunc(n / 2);\\n\\n    let copy = [...nums].sort((a, b) => b - a);\\n\\n    for (let i = 0, j = half; j < n; i++, j++) {\\n                      nums[2 * i] = copy[j];\\n        if (i < half) nums[2 * i + 1] = copy[i];\\n    }\\n\\n    return nums;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar wiggleSort = function (nums) {\\n    let n = nums.length;\\n    let half = Math.round(n / 2);\\n\\n    nums.sort((a, b) => a - b);\\n\\n    let alternating = [];\\n    for (let i = half - 1, j = n - 1; i >= 0; i--, j--) {\\n        alternating.push(nums[i]);\\n        alternating.push(nums[j]); // last one may be undefined\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        nums[i] = alternating[i];\\n    }\\n    return nums;\\n};\\n```\n```\\nvar wiggleSort = function (nums) {\\n    let n = nums.length;\\n    let half = Math.trunc(n / 2);\\n\\n    nums.sort((a, b) => b - a);\\n\\n    let alternating = [];\\n    for (let i = 0, j = half; j < n; i++, j++) {\\n        alternating.push(nums[j]);\\n        alternating.push(nums[i]);\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        nums[i] = alternating[i];\\n    }\\n\\n    return nums;\\n};\\n```\n```\\nvar wiggleSort = function (nums) {\\n    let n = nums.length;\\n    let half = Math.trunc(n / 2);\\n\\n    nums.sort((a, b) => b - a);\\n\\n    let alternating = [];\\n    for (let i = half, j = 0; i < n; i++, j++) {\\n        alternating.push(nums[i]);\\n        alternating.push(nums[j]);\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        nums[i] = alternating[i];\\n    }\\n\\n    return nums;\\n};\\n```\n```\\nvar wiggleSort = function (nums) {\\n    let n = nums.length;\\n    let half = Math.trunc(n / 2);\\n\\n    let copy = [...nums].sort((a, b) => b - a);\\n\\n    for (let i = 0, j = half; j < n; i++, j++) {\\n                      nums[2 * i] = copy[j];\\n        if (i < half) nums[2 * i + 1] = copy[i];\\n    }\\n\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576802,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if len(nums) <= 1:\\n            return nums \\n        n = len(nums)\\n        l = 0\\n        r = n\\n        m = (n+1) // 2\\n        \\n        self.nums = nums\\n        self.n = n\\n        \\n        while l < r:\\n            p = self.get(m)\\n            \\n            lcnt = 0\\n            ecnt = 0\\n            hcnt = 0\\n            for i in range(l, r):\\n                v = self.get(i)\\n                if v < p:\\n                    lcnt += 1\\n                elif v == p:\\n                    ecnt += 1\\n                else:\\n                    hcnt += 1\\n\\n            lc = 0\\n            for i in range(l, r):\\n                if self.get(i) < p:\\n                    self.swap(i, lc + l)\\n                    lc += 1\\n            assert lc == lcnt\\n            \\n            ec = 0\\n            for i in range(l + lcnt, r):\\n                if self.get(i) == p:\\n                    self.swap(i, ec + lcnt + l)\\n                    ec += 1\\n            assert ec == ecnt\\n\\n            assert l <= m and m < r\\n            if m < l + lcnt:\\n                r = l + lcnt\\n            elif m < l + lcnt + ecnt:\\n                break\\n            else:\\n                l = l + lcnt + ecnt\\n            \\n                \\n    def swap(self, i, j):\\n        self.nums[self.im_re(i)], self.nums[self.im_re(j)] = self.nums[self.im_re(j)], self.nums[self.im_re(i)]\\n        \\n        \\n    def get(self, i):\\n        return self.nums[self.im_re(i)]\\n    \\n    \\n    def im_re(self, i):\\n\\t\\t\"\"\"\\n\\t\\tThis is a mapping that allows us to do the imaginary problem:\\n\\t\\t\\tFind median and put everything below it on the left and everything above it on the right (This is a well-known O(n) problem)\\n\\t\\t\"\"\"\\n        n = self.n\\n        m = (n + 1) // 2\\n        if i < m:\\n            return (m - i - 1) * 2\\n        else:\\n            return (n - i - 1) * 2 + 1\\n        \\n        \\n    def disp(self):\\n        print(\\'re:\\', self.nums, \\'im:\\', [self.get(i) for i in range(self.n)])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wiggleSort(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if len(nums) <= 1:\\n            return nums \\n        n = len(nums)\\n        l = 0\\n        r = n\\n        m = (n+1) // 2\\n        \\n        self.nums = nums\\n        self.n = n\\n        \\n        while l < r:\\n            p = self.get(m)\\n            \\n            lcnt = 0\\n            ecnt = 0\\n            hcnt = 0\\n            for i in range(l, r):\\n                v = self.get(i)\\n                if v < p:\\n                    lcnt += 1\\n                elif v == p:\\n                    ecnt += 1\\n                else:\\n                    hcnt += 1\\n\\n            lc = 0\\n            for i in range(l, r):\\n                if self.get(i) < p:\\n                    self.swap(i, lc + l)\\n                    lc += 1\\n            assert lc == lcnt\\n            \\n            ec = 0\\n            for i in range(l + lcnt, r):\\n                if self.get(i) == p:\\n                    self.swap(i, ec + lcnt + l)\\n                    ec += 1\\n            assert ec == ecnt\\n\\n            assert l <= m and m < r\\n            if m < l + lcnt:\\n                r = l + lcnt\\n            elif m < l + lcnt + ecnt:\\n                break\\n            else:\\n                l = l + lcnt + ecnt\\n            \\n                \\n    def swap(self, i, j):\\n        self.nums[self.im_re(i)], self.nums[self.im_re(j)] = self.nums[self.im_re(j)], self.nums[self.im_re(i)]\\n        \\n        \\n    def get(self, i):\\n        return self.nums[self.im_re(i)]\\n    \\n    \\n    def im_re(self, i):\\n\\t\\t\"\"\"\\n\\t\\tThis is a mapping that allows us to do the imaginary problem:\\n\\t\\t\\tFind median and put everything below it on the left and everything above it on the right (This is a well-known O(n) problem)\\n\\t\\t\"\"\"\\n        n = self.n\\n        m = (n + 1) // 2\\n        if i < m:\\n            return (m - i - 1) * 2\\n        else:\\n            return (n - i - 1) * 2 + 1\\n        \\n        \\n    def disp(self):\\n        print(\\'re:\\', self.nums, \\'im:\\', [self.get(i) for i in range(self.n)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504744,
                "title": "c-solution-best-explanations-step-by-step-faster-than-97-83",
                "content": "A solution that doesn\\'t need to calculate the index:\\n\\nUse the nth_element that comes with c++ to divide the entire array by the median, and take the median as pivot\\n\\nThe three pointers are: the loop pointer i, which is less than the median pointer e, because the number less than the median must be at an even index, named e, which means even, starting from the last even index. Greater than the median pointer o, because the number greater than the median must be at an odd index, named o, which means odd, starting from 1.\\n\\nBy traversing the entire array i, when it is found that the element i is greater than pivot, there are two cases. First: i is an even number, but the value greater than pivot should be at an odd index, so exchange the value of i and the current o, and add two to o and move to The next odd index. This is to ensure that o and the odd index before it are both greater than the median.\\n\\nSecond: We found that i has surpassed o and forced the exchange to ensure that o and its previous odd index are both greater than the median.\\n\\nThe judgment of e is similar, but from back to front.\\n\\n```\\nvoid wiggleSort(vector<int> &nums) {\\n        // write your code here\\n        int m = (nums.size() -1)/2;\\n        nth_element(nums.begin(), nums.begin()+m, nums.end());\\n        int pivot = nums[m];\\n        \\n        int i = 0;\\n        int o = 1;\\n        int e = (nums.size()-1) % 2 == 0 ? nums.size()-1 : nums.size()-2;\\n        //cout << m;\\n        while (i < nums.size()) {\\n            if (nums[i] > pivot && (i % 2 == 0 || i > o)) {\\n                swap(nums[i], nums[o]);\\n                o += 2;\\n                continue;\\n            }\\n            if (nums[i] < pivot && (i % 2 == 1 || i < e)) {\\n                swap(nums[i], nums[e]);\\n                e -= 2;\\n                continue;\\n            }\\n            i++;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid wiggleSort(vector<int> &nums) {\\n        // write your code here\\n        int m = (nums.size() -1)/2;\\n        nth_element(nums.begin(), nums.begin()+m, nums.end());\\n        int pivot = nums[m];\\n        \\n        int i = 0;\\n        int o = 1;\\n        int e = (nums.size()-1) % 2 == 0 ? nums.size()-1 : nums.size()-2;\\n        //cout << m;\\n        while (i < nums.size()) {\\n            if (nums[i] > pivot && (i % 2 == 0 || i > o)) {\\n                swap(nums[i], nums[o]);\\n                o += 2;\\n                continue;\\n            }\\n            if (nums[i] < pivot && (i % 2 == 1 || i < e)) {\\n                swap(nums[i], nums[e]);\\n                e -= 2;\\n                continue;\\n            }\\n            i++;\\n        }\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1502757,
                "title": "o-nlogn-time-o-n-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        sort(nums.begin() , nums.end() );\\n        \\n        vector<int> result(nums.size(),0);\\n        \\n        \\n        int start = (nums.size()%2==0)? nums.size()-2:nums.size()-1;\\n        int i , k ;\\n        for( i = 0 , k = start ; k >= 0 ; k-= 2 , i++ ){\\n            //cout << k << endl;\\n            result[k] = nums[i];\\n        }\\n        \\n        start = (nums.size()%2==0)? nums.size()-1:nums.size()-2;\\n        for( k= start ; k > 0 ; k-=2 , i++ ){\\n            result[k] = nums[i];\\n        }\\n       \\n        nums = result;\\n        \\n        return;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        sort(nums.begin() , nums.end() );\\n        \\n        vector<int> result(nums.size(),0);\\n        \\n        \\n        int start = (nums.size()%2==0)? nums.size()-2:nums.size()-1;\\n        int i , k ;\\n        for( i = 0 , k = start ; k >= 0 ; k-= 2 , i++ ){\\n            //cout << k << endl;\\n            result[k] = nums[i];\\n        }\\n        \\n        start = (nums.size()%2==0)? nums.size()-1:nums.size()-2;\\n        for( k= start ; k > 0 ; k-=2 , i++ ){\\n            result[k] = nums[i];\\n        }\\n       \\n        nums = result;\\n        \\n        return;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1472307,
                "title": "java-easy-solution",
                "content": "\\'\\'\\'\\n\\tclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int narr[] = new int[n];\\n        \\n        int i = 1;\\n        int j = n-1;\\n        \\n        while(i<n){\\n            narr[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        \\n        \\n        i = 0;\\n        while(i<n){\\n            narr[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }\\n        \\n        for (int k = 0; k<n; k++){\\n            nums[k] = narr[k];\\n        }\\n    }\\n}\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public void wiggleSort(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int narr[] = new int[n];\\n        \\n        int i = 1;\\n        int j = n-1;\\n        \\n        while(i<n){\\n            narr[i] = nums[j];\\n            i+=2;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1408635,
                "title": "php",
                "content": "class Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return NULL\\n     */\\n    function wiggleSort(&$nums) {\\n        sort($nums);\\n        $count = count($nums);\\n        $data1 = [];\\n        $data2 = [];\\n        $k = 0;\\n        $check = -1;\\n        $count1 = ceil($count / 2);\\n        if ($count % 2 != 0) {\\n            $k = 1;\\n            $check = $nums[0];\\n            $count1 = ceil($count / 2);\\n        }\\n        for ($i = $k; $i < $count1; $i++) {\\n            $data1[] = $nums[$i];\\n        }\\n        for ($i = $count1; $i < $count; $i++) {\\n            $data2[] = $nums[$i];\\n        }\\n        $nums = [];\\n        for ($i = count($data1) - 1; $i >= 0; $i--) {\\n            $nums[] = $data1[$i];\\n            $nums[] = $data2[$i];\\n        }\\n\\n        if ($check != -1) {\\n            array_push($nums, $check);\\n        }\\n\\n        return $nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return NULL\\n     */\\n    function wiggleSort(&$nums) {\\n        sort($nums);\\n        $count = count($nums);\\n        $data1 = [];\\n        $data2 = [];\\n        $k = 0;\\n        $check = -1;\\n        $count1 = ceil($count / 2);\\n        if ($count % 2 != 0) {\\n            $k = 1;\\n            $check = $nums[0];\\n            $count1 = ceil($count / 2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1394506,
                "title": "c-easy-but-not-constant-space-t-o-nlogn-s-o-n",
                "content": "class Solution {\\npublic:\\n    \\n    void wiggleSort(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size() - 1;\\n        int half = n/2;\\n        int j = 0;\\n        vector<int> t = nums;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if((i & 1) == 0) {\\n                nums[i] = t[half--];\\n            }\\n            else nums[i] = t[n--];\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void wiggleSort(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size() - 1;\\n        int half = n/2;\\n        int j = 0;\\n        vector<int> t = nums;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if((i & 1) == 0) {\\n                nums[i] = t[half--];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1392532,
                "title": "java-solution-time-o-nlogn-space-o-n",
                "content": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        int arr[] = new int[nums.length];\\n        \\n        int i=nums.length-1, j=1;\\n        while(j<nums.length){\\n            arr[j]=nums[i];\\n            i--;\\n            j=j+2;\\n        }\\n        \\n        j=0;\\n        while(i>=0){\\n            arr[j]=nums[i];\\n            i--;\\n            j=j+2;\\n        }\\n        \\n        for(int it=0; it<nums.length; it++){\\n            nums[it]=arr[it];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void wiggleSort(int[] nums) {\\n        Arrays.sort(nums);\\n        int arr[] = new int[nums.length];\\n        \\n        int i=nums.length-1, j=1;\\n        while(j<nums.length){\\n            arr[j]=nums[i];\\n            i--;\\n            j=j+2;\\n        }\\n        \\n        j=0;\\n        while(i>=0){\\n            arr[j]=nums[i];\\n            i--;\\n            j=j+2;\\n        }\\n        \\n        for(int it=0; it<nums.length; it++){\\n            nums[it]=arr[it];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566257,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1567569,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1566360,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1573127,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1568417,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1569076,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1957366,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1733704,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1573321,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1569077,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1566257,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1567569,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1566360,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1573127,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1568417,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1569076,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1957366,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1733704,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1573321,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            },
            {
                "id": 1569077,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "As [pointed out by jwangmcd](https://leetcode.com/discuss/76939/o-n-time-solution-with-median-found-with-quick-selection?show=76951#c76951) in a comment, [4,5,5,6] is troublesome. Several (most?) solutions, including the judge's solution, don't solve it correctly. They leave [4,5,5,6], which is wrong. The only correct order is [5,6,4,5].\\n\\n**Edit:** The judge's solution has been fixed and the test case included. Thanks, @1337c0d3r."
                    },
                    {
                        "username": "dominatus",
                        "content": "Since the maximum element is 5000, we can sort with a counting sort.\\n\\nOnce ordered we will fill all the odd positions from the index 1 of the vector with the numbers in descending form.\\n\\nOnce we have filled all the odd positions, we will continue to fill in descending order all the even positions from the 0 index.\\n\\nWhy is O (n)?\\n\\nBecause the counting sort orders in O (n) with a high cost in memory and the other operations are O(n) .\\n\\nWhy is O (1) extra space?\\n\\nHere\\'s a trick, if you create the vector with a size of 5001 it will have a constant space. However in Most of the tests you will waste a lot of space.\\n\\nThe solution to this is to find the largest number within the array and create it accordingly. You will lose the O (1) in space and it will become an O (maxNumberInVector) but the use of space will improve a lot.\\n"
                    },
                    {
                        "username": "something_meta",
                        "content": "The question mentions O(n) time and O(1) space but does not state if it is worst-case or average case. The final solutions are either O(n) average time (with O(1) space) or O(n) worst case time (with O(n) space). It would be great if that is mentioned explicitly so people can avoid wasting time thinking of alternative ways to achieve a worst case time of O(n) with O(1) space which is not even possible."
                    },
                    {
                        "username": "cswartzell",
                        "content": "When doing analysis, unless mentioned otherwise, we almost exclusively mean worst case unless something about the algorithm manipulates the input so worst case is *very* unlikely. As the input is randomized, it is no less likely for it to be the worst case than any other ordering, so we should assume it *is:* worst case. "
                    },
                    {
                        "username": "nkg123",
                        "content": "Time/Space Complexity mentioned in questions are mostly for the worst case scenarios. Our code should take maximum that mentioned complexity in worst case. For Some inputs it may take lesser time, based on nature of it. "
                    },
                    {
                        "username": "huowa222",
                        "content": "this question is nonsense and meaningless."
                    },
                    {
                        "username": "Vulfgang11",
                        "content": "100% agreed!"
                    },
                    {
                        "username": "dhvit",
                        "content": "Test Case 38:\\n\\nInput:\\n[5,3,1,2,6,7,8,5,5]\\nOutput:\\n[5,8,3,7,2,6,1,5,1]\\nExpected:\\n[5,8,5,7,3,6,2,5,1]\\n\\nIf all possible answers are accepted this should be too.\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "your output has an extra 1. why is that?"
                    },
                    {
                        "username": "merryChris",
                        "content": "I had to  admit that I spent a lot of time thinking about 'Color Sort' and 'findKthLargest' problems. Here are tips  about the relations.\\n\\n 1. Three different colors are similar to elements smaller than pivot, elements equal to pivot, and elements larger than pivot;\\n 2. The mapping indices is just the order to traverse the numbers;\\n 3. There cannot be an element appears more than (len+1)/2 times, so we must find the median at fist;"
                    },
                    {
                        "username": "anonydon89",
                        "content": "While select sort is the picked answer here, I really wonder how often it gets used in practice due to its limiting use case. "
                    },
                    {
                        "username": "savagesaket",
                        "content": "Although sorting seems to not be useful but the sorting algorithms gives faster results. \\nSo think about sorting then it will be an easy level question."
                    },
                    {
                        "username": "dparry",
                        "content": "The final state of the array requires arr[1]<arr[3]<...arr[(n/2)] which forces us to put half the array in sorted order. Any algorithm that does this in O(n) time can be run twice (with the evens) and merged (in O(n) time) to produce an O(n) sorting algorithm which contradicts the theorem that states the minimum runtime for a comparason sort is O(nlog(n)).  \\n\\nAm I missing something?"
                    },
                    {
                        "username": "karshh",
                        "content": "yes you are"
                    },
                    {
                        "username": "dragonpw",
                        "content": "I haven't begun writing code for this problem yet. But I tested the input of [6,5,4,1,1,1], and It gives the following expected answer.\\n\\nSpecial Judge: No expected output available.\\n\\nInteresting."
                    },
                    {
                        "username": "zhhackk",
                        "content": "seems fixed now."
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Repeating Character Replacement",
        "question_content": "<p>You are given a string <code>s</code> and an integer <code>k</code>. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most <code>k</code> times.</p>\n\n<p>Return <em>the length of the longest substring containing the same letter you can get after performing the above operations</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ABAB&quot;, k = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;AABABBA&quot;, k = 1\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Replace the one &#39;A&#39; in the middle with &#39;B&#39; and form &quot;AABBBBA&quot;.\nThe substring &quot;BBBB&quot; has the longest repeating letters, which is 4.\nThere may exists other ways to achive this answer too.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of only uppercase English letters.</li>\n\t<li><code>0 &lt;= k &lt;= s.length</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 91271,
                "title": "java-12-lines-o-n-sliding-window-solution-with-explanation",
                "content": "```\\n    public int characterReplacement(String s, int k) {\\n        int len = s.length();\\n        int[] count = new int[26];\\n        int start = 0, maxCount = 0, maxLength = 0;\\n        for (int end = 0; end < len; end++) {\\n            maxCount = Math.max(maxCount, ++count[s.charAt(end) - 'A']);\\n            while (end - start + 1 - maxCount > k) {\\n                count[s.charAt(start) - 'A']--;\\n                start++;\\n            }\\n            maxLength = Math.max(maxLength, end - start + 1);\\n        }\\n        return maxLength;\\n    }\\n```\\n\\nThere's no edge case for this question. The initial step is to extend the window to its limit, that is, the longest we can get to with maximum number of modifications. Until then the variable **start** will remain at 0.\\n\\nThen as **end** increase, the whole substring from 0 to **end** will violate the rule, so we need to update **start** accordingly (slide the window). We move **start** to the right until the whole string satisfy the constraint again. Then each time we reach such situation, we update our max length.",
                "solutionTags": [],
                "code": "```\\n    public int characterReplacement(String s, int k) {\\n        int len = s.length();\\n        int[] count = new int[26];\\n        int start = 0, maxCount = 0, maxLength = 0;\\n        for (int end = 0; end < len; end++) {\\n            maxCount = Math.max(maxCount, ++count[s.charAt(end) - 'A']);\\n            while (end - start + 1 - maxCount > k) {\\n                count[s.charAt(start) - 'A']--;\\n                start++;\\n            }\\n            maxLength = Math.max(maxLength, end - start + 1);\\n        }\\n        return maxLength;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91285,
                "title": "sliding-window-similar-to-finding-longest-substring-with-k-distinct-characters",
                "content": "The problem says that we can make at most k changes to the string (any character can be replaced with any other character). So, let's say there were no constraints like the k. Given a string convert it to a string with all same characters with minimal changes. The answer to this is \\n>length of the entire string - number of times of the maximum occurring character in the string\\n\\nGiven this, we can apply the at most k changes constraint and maintain a sliding window such that\\n> (length of substring - number of times of the maximum occurring character in the substring) <= k\\n\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        vector<int> counts(26, 0);\\n        int start = 0;\\n        int maxCharCount = 0;\\n        int n = s.length();\\n        int result = 0;\\n        for(int end = 0; end < n; end++){\\n            counts[s[end]-'A']++;\\n            if(maxCharCount < counts[s[end]-'A']){\\n                maxCharCount = counts[s[end]-'A'];\\n            }\\n            while(end-start-maxCharCount+1 > k){\\n                counts[s[start]-'A']--;\\n                start++;\\n                for(int i = 0; i < 26; i++){\\n                    if(maxCharCount < counts[i]){\\n                        maxCharCount = counts[i];\\n                    }\\n                }\\n            }\\n            result = max(result, end-start+1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        vector<int> counts(26, 0);\\n        int start = 0;\\n        int maxCharCount = 0;\\n        int n = s.length();\\n        int result = 0;\\n        for(int end = 0; end < n; end++){\\n            counts[s[end]-'A']++;\\n            if(maxCharCount < counts[s[end]-'A']){\\n                maxCharCount = counts[s[end]-'A'];\\n            }\\n            while(end-start-maxCharCount+1 > k){\\n                counts[s[start]-'A']--;\\n                start++;\\n                for(int i = 0; i < 26; i++){\\n                    if(maxCharCount < counts[i]){\\n                        maxCharCount = counts[i];\\n                    }\\n                }\\n            }\\n            result = max(result, end-start+1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358879,
                "title": "java-solution-explained-easy-to-understand-for-interviews",
                "content": "***Check out my youtube ->:*** www.youtube.com/channel/UCpPemQ80aZnquPbaaMxw85A\\n\\n**Intution:**\\n\\nThe question asks to find the longest substring that contains the same characters. It also says that we can change k characters to make a substring longer and valid.\\n\\nEx:\\n```\\n\"ABAB\" k = 1\\n```\\n\\nHere we know that we can change 1 character to make a substring that is a valid answer \\nAKA: a substring with all the same characters.\\n\\nSo a valid substring answer would be s.substring(0, 3) -> \"ABA\" because with can replace 1 character.\\n\\nAnother answer could be \"BAB\".\\n\\nUsing the sliding window technique, we set up pointers ```left = 0``` and ```right = 0```\\nWe know that a our current window / substring is valid when the number of characters that need to be replaced is <= k.\\n\\nLets take the example below to understand it better:\\nEx:\\n\\n```\\n\"AABABCC\" k = 2\\nleft = 0\\nright = 4 inclusive\\n```\\n\\nThis is example above shows a valid substring window because we have enough k changes to change the B\\'s to A\\'s and match the rest of the string.\\n\\n\"AABAB\" with 2 changes is valid\\n\\nWe will need to know how many letters in our substring that we need to replace.\\nTo find out the ```lettersToReplace = (end - start + 1) - mostFreqLetter;```\\nPretty much you take the size of the window minus the most freq letter that is in the current window.\\n\\nNow that we know how many characters that need to be replaced in our window, we can deduce that if ```lettersToReplace > k``` than the window is invalid and we decrease the window size from the left.\\n\\nPulling the whole algorithm together we get:\\n\\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int[] freq = new int[26];\\n        int mostFreqLetter = 0;\\n        int left = 0;\\n        int max = 0;\\n        \\n        for(int right = 0; right < s.length(); right++){\\n            freq[s.charAt(right) - \\'A\\']++;\\n            mostFreqLetter = Math.max(mostFreqLetter, freq[s.charAt(right) - \\'A\\']);\\n            \\n            int lettersToChange = (right - left + 1) - mostFreqLetter;\\n            if(lettersToChange > k){\\n                freq[s.charAt(left) - \\'A\\']--;\\n                left++;\\n            }\\n            \\n            max = Math.max(max, right - left + 1);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\\n\\n```Time Complexity: O(N)```\\n```Space Complexity: O(26) = O(1)```",
                "solutionTags": [],
                "code": "```\\n\"ABAB\" k = 1\\n```\n```left = 0```\n```right = 0```\n```\\n\"AABABCC\" k = 2\\nleft = 0\\nright = 4 inclusive\\n```\n```lettersToReplace = (end - start + 1) - mostFreqLetter;```\n```lettersToReplace > k```\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int[] freq = new int[26];\\n        int mostFreqLetter = 0;\\n        int left = 0;\\n        int max = 0;\\n        \\n        for(int right = 0; right < s.length(); right++){\\n            freq[s.charAt(right) - \\'A\\']++;\\n            mostFreqLetter = Math.max(mostFreqLetter, freq[s.charAt(right) - \\'A\\']);\\n            \\n            int lettersToChange = (right - left + 1) - mostFreqLetter;\\n            if(lettersToChange > k){\\n                freq[s.charAt(left) - \\'A\\']--;\\n                left++;\\n            }\\n            \\n            max = Math.max(max, right - left + 1);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\n```Time Complexity: O(N)```\n```Space Complexity: O(26) = O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 765776,
                "title": "python-two-pointers-process-for-coding-interviews",
                "content": "Hello,\\n\\nHere is my solution with my process for coding interview. All feedbacks are welcome.\\n\\n1. Problem Summary / Clarifications / TDD:\\n         `Ouput(ABAB, 2): 4`\\n         `Ouput(AABABBA, 1): 4`\\n         `Ouput(BAAAABBA, 1): 5`\\n         `Ouput(BAAAABBA, 3): 8`\\n         `Ouput(BAAAABBBBBA, 1): 6`\\n         `Ouput(CBAAAABBBBBA, 2): 6`\\n         `Ouput(CBAAAABBBBBA, 1): 6`\\n\\t\\t `Ouput(CABAAAABBBBBA, 2): 7`\\t\\t \\n         \\n2. Intuition:\\n        - Scan the array with 2 pointers: `left` and `right`\\n        - Store the frequency of each character\\n        - Compute the replacement cost:  `cells count between left and right pointers - the highest frequency`\\n        - if the `replacement cost <= k`: update longest string size\\n        - if the `replacement cost > k`: decrease frequency of character at `left pointer`; increase `left pointer` and repeat\\n        - - - Since we are looking for the longest sub-string, we don\\'t need to shrink the sliding window by more than 1 character:\\n        - - - When we reach a window of size `W`, we know that our target window size is higher or equal to the current one ( `>= W`).\\n\\t\\t- - - Therefore, we could continue sliding with a window of `W` cells until we find a larger window `> W`.\\n        \\n        0   1   2   3   4   5   6   7   8   9   10  11  12\\n        C   A   B   A   A   A   A   B   B   B   B   B   A,  k,  Replacement Cost,    max len\\n\\t   l^r                                                  2   1 - 1 = 0 <=k           1    => increase r\\n\\t   l^  ^r                                               2   2 - 1 = 1 <=k           2    => increase r\\n\\t   l^       ^r                                          2   3 - 1 = 2 <=k           3    => increase r\\n\\t   l^           ^r                                      2   4 - 2 = 2 <=k           4    => increase r\\n\\t   l^               ^r                                  2   5 - 3 = 2 <=k           5    => increase r\\n\\t   l^                   ^r                              2   6 - 4 = 2 <=k           6    => increase r\\n       l^                      r^                           2   7 - 5 = 2 <=k           7    => increase r\\n\\t   l^                          r^                       2   8 - 5 = 3 > k           7    => increase l,r\\n           l^                          r^                   2   8 - 5 = 3 > k           7    => increase l,r\\n               l^                           r^              2   8 - 4 = 4 > k           7    => increase l,r\\n                   l^                           r^          2   8 - 4 = 4 > k           7    => increase l,r\\n                       l^                           r^      2   8 - 5 = 3 > k           7    => increase l,r\\n                            l^                          r^  2   8 - 4 = 4 > k           7    => STOP\\n    \\n3. Tests: you may want to:\\n\\t\\t- to use all test cases above\\n\\t\\t- to add test cases based on your code (coverage): test your code as soon as you can\\n\\t\\t- to test edge & special cases:\\n\\t- An empty string, \\n\\t- A string with 1 character, `A`\\n\\t- A string with same character: `AAAAA`\\n\\t- A string that containing distinct characters: `ABCDEFGHI`\\n\\n4. Analysis:\\n        - Time Complexity: O(26 |s|) =  O(|s|)\\n        - Space Complexity: O(26) = O(1)\\n    \\n```\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        l = 0\\n        c_frequency = {}\\n        longest_str_len = 0\\n        for r in range(len(s)):\\n            \\n            if not s[r] in c_frequency:\\n                c_frequency[s[r]] = 0\\n            c_frequency[s[r]] += 1\\n            \\n            # Replacements cost = cells count between left and right - highest frequency\\n            cells_count = r - l + 1\\n            if cells_count - max(c_frequency.values()) <= k:\\n                longest_str_len = max(longest_str_len, cells_count)\\n                \\n            else:\\n                c_frequency[s[l]] -= 1\\n                if not c_frequency[s[l]]:\\n                    c_frequency.pop(s[l])\\n                l += 1\\n        \\n        return longest_str_len\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        l = 0\\n        c_frequency = {}\\n        longest_str_len = 0\\n        for r in range(len(s)):\\n            \\n            if not s[r] in c_frequency:\\n                c_frequency[s[r]] = 0\\n            c_frequency[s[r]] += 1\\n            \\n            # Replacements cost = cells count between left and right - highest frequency\\n            cells_count = r - l + 1\\n            if cells_count - max(c_frequency.values()) <= k:\\n                longest_str_len = max(longest_str_len, cells_count)\\n                \\n            else:\\n                c_frequency[s[l]] -= 1\\n                if not c_frequency[s[l]]:\\n                    c_frequency.pop(s[l])\\n                l += 1\\n        \\n        return longest_str_len\\n\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 278271,
                "title": "java-c-python-sliding-window-just-o-n",
                "content": "# Explanation\\n`maxf` means the max frequency of the same character in the sliding window.\\nTo better understand the solution,\\nyou can firstly replace `maxf` with `max(count.values())`,\\nNow I improve from `O(26n)` to `O(n)` using a just variable `maxf`.\\n<br>\\n\\n# Complexity\\nTime `O(n)`\\nSpace `O(128)`\\n<br>\\n\\n**Java**\\n```java\\n    public int characterReplacement(String s, int k) {\\n        int res = 0, maxf = 0, count[] = new int[128];\\n        for (int i = 0; i < s.length(); ++i) {\\n            maxf = Math.max(maxf, ++count[s.charAt(i)]);\\n            if (res - maxf < k)\\n                res++;\\n            else\\n                count[s.charAt(i - res)]--;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int characterReplacement(string s, int k) {\\n        int res = 0, maxf = 0;\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < s.length(); ++i) {\\n            maxf = max(maxf, ++count[s[i]]);\\n            if (res - maxf < k)\\n                res++;\\n            else\\n                count[s[i - res]]--;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def characterReplacement(self, s, k):\\n        maxf = res = 0\\n        count = collections.Counter()\\n        for i in range(len(s)):\\n            count[s[i]] += 1\\n            maxf = max(maxf, count[s[i]])\\n            if res - maxf < k:\\n                res += 1\\n            else:\\n                count[s[i - res]] -= 1\\n        return res\\n```\\n\\n# Solution 2\\nAnother version of same idea.\\nIn a more standard format of sliding window.\\nMaybe easier to understand\\n\\nTime `O(N)`\\nSpace `O(26)`\\n\\n**Java**\\n```java\\n    public int characterReplacement(String s, int k) {\\n        int maxf = 0, i = 0, n = s.length(), count[] = new int[26];\\n        for (int j = 0; j < n; ++j) {\\n            maxf = Math.max(maxf, ++count[s.charAt(j) - \\'A\\']);\\n            if (j - i + 1 > maxf + k)\\n                --count[s.charAt(i++) - \\'A\\'];\\n        }\\n        return n - i;\\n    }\\n```\\n**C++**\\n```cpp\\n    int characterReplacement(string s, int k) {\\n        int maxf = 0, i = 0, n = s.length();\\n        vector<int> count(26);\\n        for (int j = 0; j < n; ++j) {\\n            maxf = max(maxf, ++count[s[j] - \\'A\\']);\\n            if (j - i + 1 > maxf + k)\\n                --count[s[i++] - \\'A\\'];\\n        }\\n        return n - i;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def characterReplacement(self, s, k):\\n        maxf = i = 0\\n        count = collections.Counter()\\n        for j in range(len(s)):\\n            count[s[j]] += 1\\n            maxf = max(maxf, count[s[j]])\\n            if j - i + 1 > maxf + k:\\n                count[s[i]] -= 1\\n                i += 1\\n        return len(s) - i\\n```\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public int characterReplacement(String s, int k) {\\n        int res = 0, maxf = 0, count[] = new int[128];\\n        for (int i = 0; i < s.length(); ++i) {\\n            maxf = Math.max(maxf, ++count[s.charAt(i)]);\\n            if (res - maxf < k)\\n                res++;\\n            else\\n                count[s.charAt(i - res)]--;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int characterReplacement(string s, int k) {\\n        int res = 0, maxf = 0;\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < s.length(); ++i) {\\n            maxf = max(maxf, ++count[s[i]]);\\n            if (res - maxf < k)\\n                res++;\\n            else\\n                count[s[i - res]]--;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def characterReplacement(self, s, k):\\n        maxf = res = 0\\n        count = collections.Counter()\\n        for i in range(len(s)):\\n            count[s[i]] += 1\\n            maxf = max(maxf, count[s[i]])\\n            if res - maxf < k:\\n                res += 1\\n            else:\\n                count[s[i - res]] -= 1\\n        return res\\n```\n```java\\n    public int characterReplacement(String s, int k) {\\n        int maxf = 0, i = 0, n = s.length(), count[] = new int[26];\\n        for (int j = 0; j < n; ++j) {\\n            maxf = Math.max(maxf, ++count[s.charAt(j) - \\'A\\']);\\n            if (j - i + 1 > maxf + k)\\n                --count[s.charAt(i++) - \\'A\\'];\\n        }\\n        return n - i;\\n    }\\n```\n```cpp\\n    int characterReplacement(string s, int k) {\\n        int maxf = 0, i = 0, n = s.length();\\n        vector<int> count(26);\\n        for (int j = 0; j < n; ++j) {\\n            maxf = max(maxf, ++count[s[j] - \\'A\\']);\\n            if (j - i + 1 > maxf + k)\\n                --count[s[i++] - \\'A\\'];\\n        }\\n        return n - i;\\n    }\\n```\n```py\\n    def characterReplacement(self, s, k):\\n        maxf = i = 0\\n        count = collections.Counter()\\n        for j in range(len(s)):\\n            count[s[j]] += 1\\n            maxf = max(maxf, count[s[j]])\\n            if j - i + 1 > maxf + k:\\n                count[s[i]] -= 1\\n                i += 1\\n        return len(s) - i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2524523,
                "title": "easy-100-fully-explained-c-java-python-javascript-python3-sliding-window",
                "content": "# **PROBLEM STATEMENT:**\\nGiven a string s and an integer k. Choose any character of the string and change it to any other uppercase English character. Perform this operation at most k times.\\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\\n# **Example 1:**\\n# Input: \\ns = \"ABAB\", k = 2\\n# Output: \\n4\\nExplanation: Replace the two \\'A\\'s with two \\'B\\'s or vice versa.\\n\\n# **Example 2:**\\n# Input: \\ns = \"AABABBA\",  k = 1\\n# Output: \\n4\\n# Explanation:\\nReplace the one \\'A\\' in the middle with \\'B\\' and form \"AABBBBA\". \\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\\n\\n\\n# **C++ Solution:**\\n```\\n// Time Complexity :  O(n)\\n// Space Complexity : O(1)\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        // Base case...\\n        if (s.size() == 0) return 0;\\n        // Make an array...\\n        vector <int> arr(128);\\n        // Initialize largestCount & beg pointer...\\n        int beg = 0, largestCount = 0;\\n        // Traverse all characters through the loop...\\n        for (int end = 0; end < s.size(); end++) {\\n            // Get the largest count of a single, unique character in the current window...\\n            largestCount = max(largestCount, ++arr[s[end]]);\\n            // We are allowed to have at most k replacements in the window...\\n            // So, if max character frequency + distance between beg and end is greater than k...\\n            // That means we have met a largest possible sequence, we can move the window to right...\\n            if (end - beg + 1 - largestCount > k)       // The main equation is: end - beg + 1 - largestCount...\\n                arr[s[beg++]]--;\\n        }\\n        // Return the sequence we have passes, which is s.length() - beg...\\n        return s.length() - beg;\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\n// Time Complexity :  O(n)\\n// Space Complexity : O(1)\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        // Make an array of size 26...\\n        int[] arr = new int[26];\\n        // Initialize largestCount, maxlen & beg pointer...\\n        int largestCount = 0, beg = 0, maxlen = 0;\\n        // Traverse all characters through the loop...\\n        for(int end = 0; end < s.length(); end ++){\\n            arr[s.charAt(end) - \\'A\\']++;\\n            // Get the largest count of a single, unique character in the current window...\\n            largestCount = Math.max(largestCount, arr[s.charAt(end) - \\'A\\']);\\n            // We are allowed to have at most k replacements in the window...\\n            // So, if max character frequency + distance between beg and end is greater than k...\\n            // this means we have considered changing more than k charactres. So time to shrink window...\\n            // Then there are more characters in the window than we can replace, and we need to shrink the window...\\n            if(end - beg + 1 - largestCount > k){     // The main equation is: end - beg + 1 - largestCount...\\n                arr[s.charAt(beg) - \\'A\\']--;\\n                beg ++;\\n            }\\n            // Get the maximum length of repeating character...\\n            maxlen = Math.max(maxlen, end - beg + 1);     // end - beg + 1 = size of the current window...\\n        }\\n        return maxlen;      // Return the maximum length of repeating character...\\n    }\\n}\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\n# Time Complexity :  O(n)\\n# Space Complexity : O(1)\\nclass Solution(object):\\n    def characterReplacement(self, s, k):\\n        maxlen, largestCount = 0, 0\\n        arr = collections.Counter()\\n        for idx in xrange(len(s)):\\n            arr[s[idx]] += 1\\n            largestCount = max(largestCount, arr[s[idx]])\\n            if maxlen - largestCount >= k:\\n                arr[s[idx - maxlen]] -= 1\\n            else:\\n                maxlen += 1\\n        return maxlen\\n```\\n        \\n# **JavaScript Solution:**\\n```\\n// Time Complexity :  O(n)\\n// Space Complexity : O(1)\\nvar characterReplacement = function(s, k) {\\n    // Make a map of size 26...\\n    var map = [26]\\n    // Initialize largestCount, maxlen & beg pointer...\\n    let largestCount = 0, beg = 0, maxlen = 0;\\n    // Traverse all characters through the loop...\\n    for(let end = 0; end < s.length; end++){\\n        const c = s[end]\\n        map[c] = (map[c] || 0) + 1\\n        // Get the largest count of a single, unique character in the current window...\\n        largestCount = Math.max(largestCount, map[c])\\n        // We are allowed to have at most k replacements in the window...\\n        // So, if max character frequency + distance between beg and end is greater than k...\\n        // this means we have considered changing more than k charactres. So time to shrink window...\\n        // Then there are more characters in the window than we can replace, and we need to shrink the window...\\n        if(end - beg + 1 - largestCount > k){     // The main equation is: end - beg + 1 - largestCount...\\n            map[s[beg]] -= 1\\n            beg += 1\\n        }\\n        // Get the maximum length of repeating character...\\n        maxlen = Math.max(maxlen, end - beg + 1);     // end - beg + 1 = size of the current window...\\n    }\\n    return maxlen;      // Return the maximum length of repeating character...\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\n// Time Complexity :  O(n)\\n// Space Complexity : O(1)\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        // Base case...\\n        if (s.size() == 0) return 0;\\n        // Make an array...\\n        vector <int> arr(128);\\n        // Initialize largestCount & beg pointer...\\n        int beg = 0, largestCount = 0;\\n        // Traverse all characters through the loop...\\n        for (int end = 0; end < s.size(); end++) {\\n            // Get the largest count of a single, unique character in the current window...\\n            largestCount = max(largestCount, ++arr[s[end]]);\\n            // We are allowed to have at most k replacements in the window...\\n            // So, if max character frequency + distance between beg and end is greater than k...\\n            // That means we have met a largest possible sequence, we can move the window to right...\\n            if (end - beg + 1 - largestCount > k)       // The main equation is: end - beg + 1 - largestCount...\\n                arr[s[beg++]]--;\\n        }\\n        // Return the sequence we have passes, which is s.length() - beg...\\n        return s.length() - beg;\\n    }\\n};\\n```\n```\\n// Time Complexity :  O(n)\\n// Space Complexity : O(1)\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        // Make an array of size 26...\\n        int[] arr = new int[26];\\n        // Initialize largestCount, maxlen & beg pointer...\\n        int largestCount = 0, beg = 0, maxlen = 0;\\n        // Traverse all characters through the loop...\\n        for(int end = 0; end < s.length(); end ++){\\n            arr[s.charAt(end) - \\'A\\']++;\\n            // Get the largest count of a single, unique character in the current window...\\n            largestCount = Math.max(largestCount, arr[s.charAt(end) - \\'A\\']);\\n            // We are allowed to have at most k replacements in the window...\\n            // So, if max character frequency + distance between beg and end is greater than k...\\n            // this means we have considered changing more than k charactres. So time to shrink window...\\n            // Then there are more characters in the window than we can replace, and we need to shrink the window...\\n            if(end - beg + 1 - largestCount > k){     // The main equation is: end - beg + 1 - largestCount...\\n                arr[s.charAt(beg) - \\'A\\']--;\\n                beg ++;\\n            }\\n            // Get the maximum length of repeating character...\\n            maxlen = Math.max(maxlen, end - beg + 1);     // end - beg + 1 = size of the current window...\\n        }\\n        return maxlen;      // Return the maximum length of repeating character...\\n    }\\n}\\n```\n```\\n# Time Complexity :  O(n)\\n# Space Complexity : O(1)\\nclass Solution(object):\\n    def characterReplacement(self, s, k):\\n        maxlen, largestCount = 0, 0\\n        arr = collections.Counter()\\n        for idx in xrange(len(s)):\\n            arr[s[idx]] += 1\\n            largestCount = max(largestCount, arr[s[idx]])\\n            if maxlen - largestCount >= k:\\n                arr[s[idx - maxlen]] -= 1\\n            else:\\n                maxlen += 1\\n        return maxlen\\n```\n```\\n// Time Complexity :  O(n)\\n// Space Complexity : O(1)\\nvar characterReplacement = function(s, k) {\\n    // Make a map of size 26...\\n    var map = [26]\\n    // Initialize largestCount, maxlen & beg pointer...\\n    let largestCount = 0, beg = 0, maxlen = 0;\\n    // Traverse all characters through the loop...\\n    for(let end = 0; end < s.length; end++){\\n        const c = s[end]\\n        map[c] = (map[c] || 0) + 1\\n        // Get the largest count of a single, unique character in the current window...\\n        largestCount = Math.max(largestCount, map[c])\\n        // We are allowed to have at most k replacements in the window...\\n        // So, if max character frequency + distance between beg and end is greater than k...\\n        // this means we have considered changing more than k charactres. So time to shrink window...\\n        // Then there are more characters in the window than we can replace, and we need to shrink the window...\\n        if(end - beg + 1 - largestCount > k){     // The main equation is: end - beg + 1 - largestCount...\\n            map[s[beg]] -= 1\\n            beg += 1\\n        }\\n        // Get the maximum length of repeating character...\\n        maxlen = Math.max(maxlen, end - beg + 1);     // end - beg + 1 = size of the current window...\\n    }\\n    return maxlen;      // Return the maximum length of repeating character...\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181382,
                "title": "java-sliding-window-with-explanation",
                "content": "``` left: ``` left index thats in window\\n``` right: ``` right index thats in window\\n``` count: ``` character count thats in window\\n``` uniqueCount: ``` count of most unique characters in window\\n``` replaceCount: ``` number of replacement needed for all characters in window to be the same\\n\\nEach time we expand right, we include a new character in window.\\nIf ``` replaceCount ``` is bigger than k, we got an invalid window, we should skip it until window is valid again, but only expands window size, never shrink (because even if we got a smaller window thats valid, it doesn\\'t matter because we already found a window thats bigger and valid)\\n\\n\\n```\\nclass Solution {\\n    \\n    public int characterReplacement(String s, int k) {\\n        int uniqueCount = 0;\\n        int left = 0;\\n        int max = 0;\\n        int[] count = new int[26];\\n        for (int right = 0; right < s.length(); right++) {\\n            char c = s.charAt(right);\\n            uniqueCount = Math.max(uniqueCount, ++count[c - \\'A\\']);\\n            int replaceCount = right - left + 1 - uniqueCount;\\n            if (replaceCount > k) {\\n                // invalid window\\n                count[s.charAt(left++) - \\'A\\']--;\\n            } else {\\n                max = Math.max(max, right - left + 1);\\n            }\\n        }\\n        return max;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "``` left: ```\n``` right: ```\n``` count: ```\n``` uniqueCount: ```\n``` replaceCount: ```\n``` replaceCount ```\n```\\nclass Solution {\\n    \\n    public int characterReplacement(String s, int k) {\\n        int uniqueCount = 0;\\n        int left = 0;\\n        int max = 0;\\n        int[] count = new int[26];\\n        for (int right = 0; right < s.length(); right++) {\\n            char c = s.charAt(right);\\n            uniqueCount = Math.max(uniqueCount, ++count[c - \\'A\\']);\\n            int replaceCount = right - left + 1 - uniqueCount;\\n            if (replaceCount > k) {\\n                // invalid window\\n                count[s.charAt(left++) - \\'A\\']--;\\n            } else {\\n                max = Math.max(max, right - left + 1);\\n            }\\n        }\\n        return max;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208284,
                "title": "c-sliding-window-with-detailed-explanation-and-thinking-process",
                "content": "If we want to replace the characters in a substring and make it into the longest repeating, then we definitely want to find the character with maximum frequency and then replace all the other characters by this one, hence in this way, we can minimize the number of replacement.\\n\\nHence, with such idea within mind, when we build a sliding window **[start, end]**, we want this window to have this property: **(the length of the window) - (the maximum frequency of the character in this window) > k**. Then we can see that [start, end-1] can be fit into k replacement.\\n\\nIf we can find such a sliding window, then how to we move this window? We can simply shift the **start to start+1**, since in this way this window will no longer hold the property **(the length of the window) - (the maximum frequency of the character in this window) > k**, and then we can keep moving **end to end+1** to see if we have a longer  window.\\n\\nBelow, we use localMaxFreq to record the maximum frequency seen so far in the current window.\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int size = s.size(); int ret = 0;\\n        vector<int> count(26, 0);\\n        int start = 0; int end = 0; int localMaxFreq = 0; \\n        for(; end<size; end++){\\n            count[s[end]-\\'A\\'] += 1;\\n            localMaxFreq = max(localMaxFreq, count[s[end]-\\'A\\']);\\n            if((end-start+1)-localMaxFreq > k) {\\n                ret = max(ret, (end-start));\\n                count[s[start]-\\'A\\'] -= 1;\\n                start += 1;\\n                localMaxFreq = *(max_element(count.begin(), count.end()));\\n            }\\n        }\\n        return max(ret, end-start);\\n    }\\n};\\n```\\n\\nThe above code uses localMaxFreq to keep track the maximum frequency of each current window. However, if we think carefully, we can find that if **localMaxFreq of window A >=  localMaxFreq of window B**, then the A window must have longer length than the B window, this is because since both window A and window B hold this property **(the length of the window) - (the maximum frequency of the character in this window) > k**, and if **localMaxFreq of window A >=  localMaxFreq of window B**, then **(the length of the window A) >= (the length of the window B)** by simple algebra . \\n\\nHence, we only need to keep track of a **globalMaxFreq** to record the globally maximum frequency of each window what has been seen so far.\\n\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int size = s.size(); int ret = 0;\\n        vector<int> count(26, 0);\\n        int start = 0; int end = 0; int globalMaxFreq = 0; \\n        for(; end<size; end++){\\n            count[s[end]-\\'A\\'] += 1;\\n            globalMaxFreq = max(globalMaxFreq, count[s[end]-\\'A\\']);\\n            if((end-start+1)-globalMaxFreq > k) {\\n                ret = max(ret, (end-start));\\n                count[s[start]-\\'A\\'] -= 1;\\n                start += 1;\\n            }\\n        }\\n        return max(ret, end-start);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int size = s.size(); int ret = 0;\\n        vector<int> count(26, 0);\\n        int start = 0; int end = 0; int localMaxFreq = 0; \\n        for(; end<size; end++){\\n            count[s[end]-\\'A\\'] += 1;\\n            localMaxFreq = max(localMaxFreq, count[s[end]-\\'A\\']);\\n            if((end-start+1)-localMaxFreq > k) {\\n                ret = max(ret, (end-start));\\n                count[s[start]-\\'A\\'] -= 1;\\n                start += 1;\\n                localMaxFreq = *(max_element(count.begin(), count.end()));\\n            }\\n        }\\n        return max(ret, end-start);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int size = s.size(); int ret = 0;\\n        vector<int> count(26, 0);\\n        int start = 0; int end = 0; int globalMaxFreq = 0; \\n        for(; end<size; end++){\\n            count[s[end]-\\'A\\'] += 1;\\n            globalMaxFreq = max(globalMaxFreq, count[s[end]-\\'A\\']);\\n            if((end-start+1)-globalMaxFreq > k) {\\n                ret = max(ret, (end-start));\\n                count[s[start]-\\'A\\'] -= 1;\\n                start += 1;\\n            }\\n        }\\n        return max(ret, end-start);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165332,
                "title": "easy-understanding-sliding-window-approach-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.size();\\n        int i = 0, j = 0, maxi = 0;\\n        unordered_map<char,int>mp;\\n        int ans = -1;\\n        while(j < n)\\n        {\\n            mp[s[j]]++;\\n            maxi = max(maxi, mp[s[j]]);\\n            if((j-i+1) - maxi > k){\\n                mp[s[i]]--;\\n                i++;\\n            }\\n            ans = max(ans, (j-i+1));\\n            j++;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.size();\\n        int i = 0, j = 0, maxi = 0;\\n        unordered_map<char,int>mp;\\n        int ans = -1;\\n        while(j < n)\\n        {\\n            mp[s[j]]++;\\n            maxi = max(maxi, mp[s[j]]);\\n            if((j-i+1) - maxi > k){\\n                mp[s[i]]--;\\n                i++;\\n            }\\n            ans = max(ans, (j-i+1));\\n            j++;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91301,
                "title": "awesome-python-solution",
                "content": "\\nuse dict instead of counter:\\n```\\n    def characterReplacement(self, s, k):\\n        count = {}\\n        max_count = start = result = 0\\n        for end in range(len(s)):\\n            count[s[end]] = count.get(s[end], 0) + 1\\n            max_count = max(max_count, count[s[end]])\\n            if end - start + 1 - max_count > k:\\n                count[s[start]] -= 1\\n                start += 1\\n            result = max(result, end - start + 1)\\n        return result\\n```\\nuse counter:\\n```\\n    def characterReplacement(self, s, k):\\n        count = collections.Counter()\\n        start = result = 0\\n        for end in range(len(s)):\\n            count[s[end]] += 1\\n            max_count = count.most_common(1)[0][1]\\n            if end - start + 1 - max_count > k:\\n                count[s[start]] -= 1\\n                start += 1\\n            result = max(result, end - start + 1)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n    def characterReplacement(self, s, k):\\n        count = {}\\n        max_count = start = result = 0\\n        for end in range(len(s)):\\n            count[s[end]] = count.get(s[end], 0) + 1\\n            max_count = max(max_count, count[s[end]])\\n            if end - start + 1 - max_count > k:\\n                count[s[start]] -= 1\\n                start += 1\\n            result = max(result, end - start + 1)\\n        return result\\n```\n```\\n    def characterReplacement(self, s, k):\\n        count = collections.Counter()\\n        start = result = 0\\n        for end in range(len(s)):\\n            count[s[end]] += 1\\n            max_count = count.most_common(1)[0][1]\\n            if end - start + 1 - max_count > k:\\n                count[s[start]] -= 1\\n                start += 1\\n            result = max(result, end - start + 1)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1577162,
                "title": "easy-sliding-window-intution-explained-c-hashmap",
                "content": "**Intution** : We traverse from each char of the string if the curr char exists on the map we increase the count else we put it in the map .\\nNow since we can only replace at most K no of items so if at any time the curr window has more than k replacable items we have to shrink that window . \\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n=s.length();\\n        int i=0;//->window start\\n        int j=0;//->window end\\n        int maxC=0;//->max no of repeating elements \\n        int ans=-1;\\n        unordered_map<char,int> mp;\\n        while(j<n)\\n        {\\n            mp[s[j]]++;\\n            maxC=max(maxC,mp[s[j]]);\\n            \\n            int curr_len=j-i+1;//Curr Len of the window\\n            if(curr_len-maxC>k) //the curr window has more than k replacable items case\\n            {\\n                mp[s[i]]--;\\n                i++;// shrinking the window\\n            }\\n            curr_len=j-i+1;// just in case i is changed\\n            ans=max(ans,curr_len);\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**If you Find this Helpful pls leave an upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n=s.length();\\n        int i=0;//->window start\\n        int j=0;//->window end\\n        int maxC=0;//->max no of repeating elements \\n        int ans=-1;\\n        unordered_map<char,int> mp;\\n        while(j<n)\\n        {\\n            mp[s[j]]++;\\n            maxC=max(maxC,mp[s[j]]);\\n            \\n            int curr_len=j-i+1;//Curr Len of the window\\n            if(curr_len-maxC>k) //the curr window has more than k replacable items case\\n            {\\n                mp[s[i]]--;\\n                i++;// shrinking the window\\n            }\\n            curr_len=j-i+1;// just in case i is changed\\n            ans=max(ans,curr_len);\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363071,
                "title": "simple-python-two-pointer-solution",
                "content": "Please see and vote for my solutions for these similar problems.\\n[1208. Get Equal Substrings Within Budget](https://leetcode.com/problems/get-equal-substrings-within-budget/discuss/392901/Simple-Python-moving-window)\\n[3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/348137/Simple-Python-two-pointer-solution-(52ms-beat-97.94))\\n[159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/348157/Simple-Python-two-pointer-solution)\\n[340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/348216/Simple-Python-two-pointer-solution-(72-ms-beat-94.93))\\n[992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/348984/Different-Python-two-pointer-solutions)\\n[424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/discuss/363071/Simple-Python-two-pointer-solution)\\n[209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/344476/Simple-Python-two-pointer-solution)\\n[713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/discuss/344245/Simple-Python-solution-(beat-94.59))\\n[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/discuss/344533/Simple-Python-two-pointer-solution)\\n\\nSolution 1:\\nFor a window s[l:r+1], if r - l + 1 - max_freq of s[l:r+1] <= k, we can perform\\nat most k operation and change it to a string with repeating characters.\\nKeep a moving window expand while r - l + 1 - max_freq of s[l:r+1] <= k , \\nthen shrink while r - l + 1 - max_freq of s[l:r+1] > k.\\n\\n```\\n    def characterReplacement(self, s, k):        \\n        longest_window = 0\\n        window_counts = collections.defaultdict(int)\\n        l = 0\\n        for r in range(len(s)):\\n            window_counts[s[r]] += 1\\n            while r - l + 1 - max(window_counts.values()) > k:\\n                window_counts[s[l]] -= 1 \\n                l += 1\\n            longest_window = max(longest_window, r - l + 1)\\n        return longest_window\\n```\\n\\nSolution 2:\\nAdding tricks:\\n(1) change while to if\\n(2) change max(window_counts.values()) to a variable freq_max and don\\'t decrement freq_max\\n```\\n    def characterReplacement(self, s, k):        \\n        longest_window = 0\\n        window_counts = defaultdict(int)\\n        freq_max = 0\\n        l = 0\\n        for r in range(len(s)):\\n            window_counts[s[r]] += 1\\n            freq_max = max(freq_max, window_counts[s[r]])\\n            if r - l + 1 - freq_max > k:\\n                window_counts[s[l]] -= 1 \\n                l += 1\\n            longest_window = max(longest_window, r - l + 1)\\n        return longest_window\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def characterReplacement(self, s, k):        \\n        longest_window = 0\\n        window_counts = collections.defaultdict(int)\\n        l = 0\\n        for r in range(len(s)):\\n            window_counts[s[r]] += 1\\n            while r - l + 1 - max(window_counts.values()) > k:\\n                window_counts[s[l]] -= 1 \\n                l += 1\\n            longest_window = max(longest_window, r - l + 1)\\n        return longest_window\\n```\n```\\n    def characterReplacement(self, s, k):        \\n        longest_window = 0\\n        window_counts = defaultdict(int)\\n        freq_max = 0\\n        l = 0\\n        for r in range(len(s)):\\n            window_counts[s[r]] += 1\\n            freq_max = max(freq_max, window_counts[s[r]])\\n            if r - l + 1 - freq_max > k:\\n                window_counts[s[l]] -= 1 \\n                l += 1\\n            longest_window = max(longest_window, r - l + 1)\\n        return longest_window\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 872604,
                "title": "99-javascript-solution-with-explanation",
                "content": "- Maintain left and right pointer, max instances of a single char, and visit counts for each char.\\n - for each char in string\\n    - increment visit count for this char\\n    - if new visit count is higher  than max, update max\\n    - if length of current string without max char count is  greater than k,\\n       - then we know the new char made it such that there are more chars missing than can be replaced by k,\\n       - so we will remove the first char\\n       - and increment left pointer\\n    - increment right pointer to look at next char.\\n - In the end, the answer is whatever the window size is. This is because we never shrink the window size.\\n    - As we look at new chars, we increase the window size.\\n    - Once we see we can no longer increase due to limitation of k, we slide the window forward.\\n       - In these inbetween states, it\\'s possible the window doesn\\'t span a valid subset,\\n          - but that doesn\\'t matter because the window size at one point did span a valid set.\\n       - Instead, we wait until there\\'s a possibility of a better set, which is when there is a substring with more instances of some char.\\n\\n\\n```\\nconst characterReplacement = (s, k) => {\\n  let left = 0;\\n  let right = 0;\\n  let maxCharCount = 0;\\n  const visited = {};\\n\\n  while (right < s.length) {\\n    const char = s[right];\\n    visited[char] = visited[char] ? visited[char] + 1 : 1;\\n\\n    if (visited[char] > maxCharCount) maxCharCount = visited[char];\\n\\n    if (right - left + 1 - maxCharCount > k) {\\n      visited[s[left]]--;\\n      left++;\\n    }\\n\\n    right++;\\n  }\\n\\n  return right - left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nconst characterReplacement = (s, k) => {\\n  let left = 0;\\n  let right = 0;\\n  let maxCharCount = 0;\\n  const visited = {};\\n\\n  while (right < s.length) {\\n    const char = s[right];\\n    visited[char] = visited[char] ? visited[char] + 1 : 1;\\n\\n    if (visited[char] > maxCharCount) maxCharCount = visited[char];\\n\\n    if (right - left + 1 - maxCharCount > k) {\\n      visited[s[left]]--;\\n      left++;\\n    }\\n\\n    right++;\\n  }\\n\\n  return right - left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 700321,
                "title": "python-simple-o-n-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        ## RC ##\\n\\t\\t## APPROACH : SLIDING WINDOW ##\\n        # Logic #\\n        # 1. Increase the window if the substring is valid else,\\n        # 2. slide the window with the same length. No need to shrink the window\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        freqDict = defaultdict(int)\\n        maxFreq = 0\\n        maxLength = 0\\n        start = end = 0\\n        while end < len(s):\\n            freqDict[s[end]] += 1\\n            \\n            # maxFreq may be invalid at some points, but this doesn\\'t matter\\n            # maxFreq will only store the maxFreq reached till now\\n            maxFreq = max(maxFreq, freqDict[s[end]])\\n            \\n            # maintain the substring length and slide the window if the substring is invalid\\n            if ((end-start+1) - maxFreq) > k:\\n                freqDict[s[start]] -= 1\\n                start += 1\\n            else:\\n                maxLength = max(maxLength, end-start+1)\\n            end += 1\\n        return maxLength\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        ## RC ##\\n\\t\\t## APPROACH : SLIDING WINDOW ##\\n        # Logic #\\n        # 1. Increase the window if the substring is valid else,\\n        # 2. slide the window with the same length. No need to shrink the window\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        freqDict = defaultdict(int)\\n        maxFreq = 0\\n        maxLength = 0\\n        start = end = 0\\n        while end < len(s):\\n            freqDict[s[end]] += 1\\n            \\n            # maxFreq may be invalid at some points, but this doesn\\'t matter\\n            # maxFreq will only store the maxFreq reached till now\\n            maxFreq = max(maxFreq, freqDict[s[end]])\\n            \\n            # maintain the substring length and slide the window if the substring is invalid\\n            if ((end-start+1) - maxFreq) > k:\\n                freqDict[s[start]] -= 1\\n                start += 1\\n            else:\\n                maxLength = max(maxLength, end-start+1)\\n            end += 1\\n        return maxLength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91287,
                "title": "python-o-n-sliding-window",
                "content": "Here ```i``` and ```j``` are the left and right boundaries of our ```window```, and ```best``` is the best candidate to form the longest repeating substring. Also I used a counter called ```count``` to store all the number of all characters in current ```window```. (Can use a list instead, I'm just kind of lazy...)\\n\\nEvery time when we explore a new character ```s[j]```, we increment ```count[s[j]]``` by 1 first. Then, we pick the ```best``` candidates we have. Since we only update ```count[s[j]]``` in current loop, ```best = max(best, count[s[j]])```. As long as our window length ```j - i + 1``` is smaller or equal to ```best + k```, we keep exploring new character. Otherwise, we know we have to update our left boundary ```i``` cause we've run out of our budget ```k```.\\n```\\nclass Solution(object):\\n    def characterReplacement(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        count = collections.Counter()\\n        best = i = 0\\n        for j in range(len(s)):\\n            count[s[j]] += 1\\n            best = max(best, count[s[j]])\\n            if best + k < j - i + 1:\\n                count[s[i]] -= 1\\n                i += 1\\n        return len(s) - i\\n```",
                "solutionTags": [],
                "code": "```i```\n```j```\n```window```\n```best```\n```count```\n```window```\n```s[j]```\n```count[s[j]]```\n```best```\n```count[s[j]]```\n```best = max(best, count[s[j]])```\n```j - i + 1```\n```best + k```\n```i```\n```k```\n```\\nclass Solution(object):\\n    def characterReplacement(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        count = collections.Counter()\\n        best = i = 0\\n        for j in range(len(s)):\\n            count[s[j]] += 1\\n            best = max(best, count[s[j]])\\n            if best + k < j - i + 1:\\n                count[s[i]] -= 1\\n                i += 1\\n        return len(s) - i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591288,
                "title": "java-o-n-solution-using-sliding-window-with-explanation",
                "content": "Ref: https://leetcode.com/problems/longest-repeating-character-replacement/discuss/91271/Java-12-lines-O(n)-sliding-window-solution-with-explanation helps.\\n\\nKey Idea: Adding characters to the window and use the map to track the number of dominant char(meaning the character that counts the most in the window). Expanding the window as wide as it can be until `window size - number of dominant character > k` which means there are at least k characters are not same as the dominant character, so we need shrink the window from the left side and also update the character count in the map.\\n\\nOne key point that causes confusion is when we remove the left side character in the map, the maxRepeat becomes inaccurate. But in this particular case, we do not care about the maxRepeat gets smaller because it won\\'t affect the max window size, we only care about when maxRepeat gets greater.\\n\\n       public int characterReplacement(String s, int k) {\\n\\t\\t\\tMap<Character, Integer> map = new HashMap<>(); \\n\\n\\t\\t   int left = 0, maxRepeat = 0, maxWindow = 0;\\n\\n\\t\\t\\tfor(int right = 0; right < s.length(); right++) {\\n\\t\\t\\t\\tchar ch = s.charAt(right);\\n\\t\\t\\t\\tif(!map.containsKey(ch)) {\\n\\t\\t\\t\\t\\tmap.put(ch, 0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.put(ch, map.get(ch) + 1);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// IMPORTANT: maxRepeat is not the accurate number of dominant character, It is the historical maximum count \\n\\t\\t\\t\\t// We do not care about it because unless it gets greater, it won\\'t affect our final max window size.\\n\\t\\t\\t\\tmaxRepeat = Math.max(maxRepeat, map.get(ch));\\n\\n\\t\\t\\t\\tif(right - left + 1 - maxRepeat > k) {\\n\\t\\t\\t\\t\\tchar remove = s.charAt(left);\\n\\t\\t\\t\\t\\tmap.put(remove, map.get(remove) - 1);\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n            \\n            maxWindow = Math.max(maxWindow, right - left + 1);\\n        }\\n        \\n        return maxWindow;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "Ref: https://leetcode.com/problems/longest-repeating-character-replacement/discuss/91271/Java-12-lines-O(n)-sliding-window-solution-with-explanation helps.\\n\\nKey Idea: Adding characters to the window and use the map to track the number of dominant char(meaning the character that counts the most in the window). Expanding the window as wide as it can be until `window size - number of dominant character > k` which means there are at least k characters are not same as the dominant character, so we need shrink the window from the left side and also update the character count in the map.\\n\\nOne key point that causes confusion is when we remove the left side character in the map, the maxRepeat becomes inaccurate. But in this particular case, we do not care about the maxRepeat gets smaller because it won\\'t affect the max window size, we only care about when maxRepeat gets greater.\\n\\n       public int characterReplacement(String s, int k) {\\n\\t\\t\\tMap<Character, Integer> map = new HashMap<>(); \\n\\n\\t\\t   int left = 0, maxRepeat = 0, maxWindow = 0;\\n\\n\\t\\t\\tfor(int right = 0; right < s.length(); right++) {\\n\\t\\t\\t\\tchar ch = s.charAt(right);\\n\\t\\t\\t\\tif(!map.containsKey(ch)) {\\n\\t\\t\\t\\t\\tmap.put(ch, 0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.put(ch, map.get(ch) + 1);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// IMPORTANT: maxRepeat is not the accurate number of dominant character, It is the historical maximum count \\n\\t\\t\\t\\t// We do not care about it because unless it gets greater, it won\\'t affect our final max window size.\\n\\t\\t\\t\\tmaxRepeat = Math.max(maxRepeat, map.get(ch));\\n\\n\\t\\t\\t\\tif(right - left + 1 - maxRepeat > k) {\\n\\t\\t\\t\\t\\tchar remove = s.charAt(left);\\n\\t\\t\\t\\t\\tmap.put(remove, map.get(remove) - 1);\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n            \\n            maxWindow = Math.max(maxWindow, right - left + 1);\\n        }\\n        \\n        return maxWindow;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 91278,
                "title": "7-lines-c",
                "content": "Based on the Python [solution](https://discuss.leetcode.com/topic/63448/consise-python-sliding-window) by @dalwise. Use a sliding window `s[i:j]`, always add the new character, and remove the first window character if the extension isn't ok. So in each step, either extend the window by one or move it by one.\\n\\n    int characterReplacement(string s, int k) {\\n        int i = 0, j = 0, ctr[91] = {};\\n        while (j < s.size()) {\\n            ctr[s[j++]]++;\\n            if (j-i - *max_element(ctr+65, ctr+91) > k)\\n                ctr[s[i++]]--;\\n        }\\n        return j - i;\\n    }",
                "solutionTags": [],
                "code": "Based on the Python [solution](https://discuss.leetcode.com/topic/63448/consise-python-sliding-window) by @dalwise. Use a sliding window `s[i:j]`, always add the new character, and remove the first window character if the extension isn't ok. So in each step, either extend the window by one or move it by one.\\n\\n    int characterReplacement(string s, int k) {\\n        int i = 0, j = 0, ctr[91] = {};\\n        while (j < s.size()) {\\n            ctr[s[j++]]++;\\n            if (j-i - *max_element(ctr+65, ctr+91) > k)\\n                ctr[s[i++]]--;\\n        }\\n        return j - i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2032968,
                "title": "javascript-solution-with-explanation-and-code-comments",
                "content": "\\nThis problem has always been a real challenge for me. It\\'s a pretty classic sliding window problem, and there are two versions of the solution. Here\\'s the crux of it, though:\\n\\n1. You have to put together what a \"valid\" window would be. In this case, the key insight is that any set of characters in the string could fit the requirements if: `Length of the substring - count of the most frequent character in substring <= k`. This basically means, for any given substring in the string, find the most frequent character (since it\\'s the best candidate to use in substitutions of other letters). Then see how many letters in that substring are *not* the most frequent character. If that number is less than or equal to our allowed number of substitutions, this window *could* be a candidate for longest window. \\n1. Finding the `count of the most frequent character in substring` is where we can make two choices in our algorithm. In one case, we can recalculate the most frequent letter we\\'ve seen. Since the problem says the input is made of only uppercase English letters, this means our runtime would be O(26n), which reduces to O(n). But there\\'s a trick: we don\\'t have to recalculate this every time. If we reduce the size of a window, there\\'s no way that it\\'ll be the *longest* window. So we can just keep track of the frequency of the most frequent character we\\'ve ever seen, and use that in our calculations.\\n\\nThat second point is a little tricky, so you\\'ll want to pay attention to the inline code comments about it. I had to do this problem about four or five times to really *see* why that works. \\n\\nWith those insights, we can piece together our algorithm, which is:\\n\\n1. Create a window, and grow it in the right-hand direction.\\n1. Every time you move the right side of the window up by one, keep track of the frequency of that letter that you\\'ve seen so far.\\n1. Then, either keep track of the most frequent character you\\'ve seen, or move on to the next step\\n1. Check if `Length of the substring - count of the most frequent character in substring <= k`. If it is, log this as a candidate for longest window, and keep incrementing the right side.\\n1. If this is invalid, i.e. `Length of the substring - count of the most frequent character in substring > k`, we want to increment the left pointer until it becomes valid. \\n1. If you\\'re just keeping track of the most frequent character, all you have to do is decrement the frequency of the old left window character.\\n1. If you\\'re doing the O(26n) solution, you\\'ll need to decrement that letter\\'s frequency, and recalculate the most frequent letter (by checking some hashmap of frequencies, which may be as large as 26 items, and finding the most frequent element).\\n1. After that, return the longest valid window size.\\n\\nHere\\'s how to do the O(n) solution, in JavaScript, along with some code comments that explain our decisions, and why we don\\'t need to recalculate the most frequent character. \\n\\n```js\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar characterReplacement = function(s, k) {\\n    // We\\'re going to track a few things here: \\n    // First, set up a hashmap to track the frequency of letters\\n    const frequencies = {}\\n    // Then, set up a variable to track the most frequent letter we\\'ve seen.\\n    let highestFrequency = 0\\n    // Finally, set up a variable to track the size of the longest valid window we encounter.\\n    let longest = 0\\n    \\n    // Then we\\'ll start a window with a left and right side pointer, both beginning at position 0,\\n    // because we want to grow our window as much as possible, and shrink when we have to.\\n    let left = 0\\n    let right = 0\\n    \\n    // Then we will increment the right pointer until it hits the end of the input string s\\n    while (right < s.length) {\\n        // For every character the right side of the window encounters,\\n        // we either add it to the frequencies hashmap with a frequency of 1,\\n        // or we increment its existing value\\n        const rightCharacter = s.charAt(right)\\n        frequencies[rightCharacter] = frequencies[rightCharacter] + 1 || 1\\n        \\n        // Then we check if this newly encountered character is also the most frequent\\n        // we have ever seen in the string (even outside of the current window)\\n        highestFrequency = Math.max(highestFrequency, frequencies[rightCharacter])\\n        \\n        // A window is valid if the length of the window,\\n        // minus the count of the most frequent character we\\'ve ever seen,\\n        // is less than or equal to k. \\n        // That means if the current window has the most frequent character in it, \\n        // and we did k replacements of the other letters in that window,\\n        // we would have enough k replacements to make the entire window that most frequent letter.\\n        // \\n        // If the current window is not valid, we want to increment the left pointer until we get\\n        // to a valid window\\n        //\\n        // Each time we do this, decrement the frequency of the character we\\'re truncating,\\n        // since it\\'s no longer part of the window.\\n        // \\n        // We do not, however, have to update highestFrequency, \\n        // because we\\'ll only get a longer valid window when we encounter a letter that is \\n        // more frequent in its window than the last highestFrequency count was.\\n        // In all other cases, even when we find valid windows, they will necessarily be shorter\\n        // than the last time the highestFrequency gave us a valid result.\\n        while ((right - left + 1) - highestFrequency > k) {\\n            const leftCharacter = s.charAt(left)\\n            frequencies[leftCharacter] -= 1\\n            left++\\n        }\\n        \\n        // Once we have a valid window, check if it\\'s longer than the previous longest valid window,\\n        // and store that in our longest variable.\\n        longest = Math.max(longest, right - left + 1)\\n        \\n        // Finally, increment the right pointer to shift the window to the right\\n        right++\\n    }\\n    \\n    // Return the longest valid window we\\'ve seen\\n    return longest\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar characterReplacement = function(s, k) {\\n    // We\\'re going to track a few things here: \\n    // First, set up a hashmap to track the frequency of letters\\n    const frequencies = {}\\n    // Then, set up a variable to track the most frequent letter we\\'ve seen.\\n    let highestFrequency = 0\\n    // Finally, set up a variable to track the size of the longest valid window we encounter.\\n    let longest = 0\\n    \\n    // Then we\\'ll start a window with a left and right side pointer, both beginning at position 0,\\n    // because we want to grow our window as much as possible, and shrink when we have to.\\n    let left = 0\\n    let right = 0\\n    \\n    // Then we will increment the right pointer until it hits the end of the input string s\\n    while (right < s.length) {\\n        // For every character the right side of the window encounters,\\n        // we either add it to the frequencies hashmap with a frequency of 1,\\n        // or we increment its existing value\\n        const rightCharacter = s.charAt(right)\\n        frequencies[rightCharacter] = frequencies[rightCharacter] + 1 || 1\\n        \\n        // Then we check if this newly encountered character is also the most frequent\\n        // we have ever seen in the string (even outside of the current window)\\n        highestFrequency = Math.max(highestFrequency, frequencies[rightCharacter])\\n        \\n        // A window is valid if the length of the window,\\n        // minus the count of the most frequent character we\\'ve ever seen,\\n        // is less than or equal to k. \\n        // That means if the current window has the most frequent character in it, \\n        // and we did k replacements of the other letters in that window,\\n        // we would have enough k replacements to make the entire window that most frequent letter.\\n        // \\n        // If the current window is not valid, we want to increment the left pointer until we get\\n        // to a valid window\\n        //\\n        // Each time we do this, decrement the frequency of the character we\\'re truncating,\\n        // since it\\'s no longer part of the window.\\n        // \\n        // We do not, however, have to update highestFrequency, \\n        // because we\\'ll only get a longer valid window when we encounter a letter that is \\n        // more frequent in its window than the last highestFrequency count was.\\n        // In all other cases, even when we find valid windows, they will necessarily be shorter\\n        // than the last time the highestFrequency gave us a valid result.\\n        while ((right - left + 1) - highestFrequency > k) {\\n            const leftCharacter = s.charAt(left)\\n            frequencies[leftCharacter] -= 1\\n            left++\\n        }\\n        \\n        // Once we have a valid window, check if it\\'s longer than the previous longest valid window,\\n        // and store that in our longest variable.\\n        longest = Math.max(longest, right - left + 1)\\n        \\n        // Finally, increment the right pointer to shift the window to the right\\n        right++\\n    }\\n    \\n    // Return the longest valid window we\\'ve seen\\n    return longest\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91272,
                "title": "consise-python-sliding-window",
                "content": "Re: [Sliding window](similar to finding longest substring with k distinct characters)\\n\\nSimilar idea in Python but allowing any character, not just uppercase English letters [Updated based on comments below]:\\n```\\ndef characterReplacement(self, s, k):\\n    res = lo = hi = 0\\n    counts = collections.Counter()\\n    for hi in range(1, len(s)+1):\\n        counts[s[hi-1]] += 1\\n        max_char_n = counts.most_common(1)[0][1]\\n        if hi - lo - max_char_n > k:\\n            counts[s[lo]] -= 1\\n            lo += 1\\n    return hi - lo\\n```\\n\\n[Original code in order to understand comment from @StefanPochmann was:]\\n```   \\ndef characterReplacement(self, s, k):\\n    res = lo = 0\\n    counts = collections.Counter()\\n    for hi in range(len(s)):\\n        counts[s[hi]] += 1\\n        max_char_n = counts.most_common(1)[0][1]\\n        while (hi - lo - max_char_n + 1 > k):\\n            counts[s[lo]] -= 1\\n            lo += 1\\n        res = max(res, hi - lo + 1)\\n    return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef characterReplacement(self, s, k):\\n    res = lo = hi = 0\\n    counts = collections.Counter()\\n    for hi in range(1, len(s)+1):\\n        counts[s[hi-1]] += 1\\n        max_char_n = counts.most_common(1)[0][1]\\n        if hi - lo - max_char_n > k:\\n            counts[s[lo]] -= 1\\n            lo += 1\\n    return hi - lo\\n```\n```   \\ndef characterReplacement(self, s, k):\\n    res = lo = 0\\n    counts = collections.Counter()\\n    for hi in range(len(s)):\\n        counts[s[hi]] += 1\\n        max_char_n = counts.most_common(1)[0][1]\\n        while (hi - lo - max_char_n + 1 > k):\\n            counts[s[lo]] -= 1\\n            lo += 1\\n        res = max(res, hi - lo + 1)\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 328058,
                "title": "c-0ms-100-concise-sliding-windows-solution-with-explanation",
                "content": "The intuition is to apply the sliding windows method to this problem, under the constraint that the window size does not decrease. In this case, the criteria for the windows is that the window is a string that has \"k\" other characters besides the maximum count character, which is what the solution is looking for. We can check if this criteria is satisfied by keeping track of the count of each character in the window in a table (m), and save/update the maximum count character (same in this case). We can get the number of characters besides the maximum count by using the fact that length of windows minus number of maximum count character must equal to the number of other characters.\\n\\nBecause size does not decrease, for every iteration of sliding windows, we will always increase the right bound ( j in this case). Thus, if the window matches the requirement, we just increase j, and if it doesn\\'t, we increase the left bound, and because the right bound also increases, the size stays the same. This means that the final windows size is also the maximum length of repeated characters. \\n\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int size = s.size(), i = 0, j = 0, same = 0;\\n        vector<int> m(128, 0);\\n        while(j < size) {\\n            same = max(same, ++m[s[j++]]); // Update table, count for maximum character in window, and increment right bound\\n            if(j - i - same > k) --m[s[i++]]; // If criteria is not satisfied, increment left bound, update table\\n        }\\n        return j-i;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int size = s.size(), i = 0, j = 0, same = 0;\\n        vector<int> m(128, 0);\\n        while(j < size) {\\n            same = max(same, ++m[s[j++]]); // Update table, count for maximum character in window, and increment right bound\\n            if(j - i - same > k) --m[s[i++]]; // If criteria is not satisfied, increment left bound, update table\\n        }\\n        return j-i;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1734823,
                "title": "java-time-o-n-space-o-1-slide-window-explain",
                "content": "##### The conditions are:\\n1. All characters are uppercase English letters.\\n2. The length of the string is greater than 1.\\n3. The k times can be 0.\\n\\n##### List some examples:\\n1. s = AAABBABB, k = 1\\n2. s = A, k = 0\\n3. s = ABA, k = 0\\n4. s = AABBAA, k = 2\\n\\n##### Think aloud:\\n1. If k = 0, we just find out which letter has longest repeating.\\n2. If k = 1, finding out which letter has longest repeating is not working.\\n For example, AAABBABB. The first sight for this string, letter A has longest repeating. \\nHowever, if the letter A (AAABB **A** BB) becomes the letter B (AAABB **B** BB) . The letter B will be the longest repeating letter.\\n3. We can use the slide window to go through the string and find out the answer.\\nTake \\u201Cs= AAABBABB, k = 1\\u201D for example:\\nMax window size is valid letter repeating length plus k length\\n\\t- **A** AABBABB => max window size is 2\\n\\t- **AA** ABBABB => max window size is 3\\n\\t- **AAA** BBABB => max window size is 4\\n\\t- **AAAB** BABB => max window size is 4\\n\\t- **AAABB** ABB => max window size is 4 => A **AABB** ABB\\n\\t- A **AABBA** BB => max window size is 4 => AA **ABBA** BB\\n\\t- AA **ABBAB** B => max window size is 4 => AAA **BBAB** B\\n\\t- AAA **BBABB** => max window size is 5\\n4. So, we got the max window size is 5. This is the answer of the longest repeating letter.\\n\\n```\\n/**\\n * Time O(n)\\n * Space O(26)\\n */\\nclass Solution {\\n  public int characterReplacement(String s, int k) {\\n    // Space O(26)\\n    int[] dic = new int[26];\\n    int start = 0;\\n    int maxLen = 0;\\n    // Time O(n)\\n    for (int end = 0; end < s.length(); end++) {\\n      maxLen = Math.max(maxLen, ++dic[s.charAt(end) - \\'A\\']);\\n      if (end - start + 1 > maxLen + k) {\\n        dic[s.charAt(start) - \\'A\\']--;\\n        start++;\\n      }\\n    }\\n    return s.length() - start;\\n  }\\n}\\n```\\n\\nIf my explanation can help you. Please give me a thumbs up.",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * Time O(n)\\n * Space O(26)\\n */\\nclass Solution {\\n  public int characterReplacement(String s, int k) {\\n    // Space O(26)\\n    int[] dic = new int[26];\\n    int start = 0;\\n    int maxLen = 0;\\n    // Time O(n)\\n    for (int end = 0; end < s.length(); end++) {\\n      maxLen = Math.max(maxLen, ++dic[s.charAt(end) - \\'A\\']);\\n      if (end - start + 1 > maxLen + k) {\\n        dic[s.charAt(start) - \\'A\\']--;\\n        start++;\\n      }\\n    }\\n    return s.length() - start;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91286,
                "title": "java-sliding-window-easy-to-understand",
                "content": "The problem is similar to longest substring with most K distinct characte. But this time, the constraint is we can only have most K characters that is different with the most frequent character in the substring. For example in the sliding window:\\n```\\n\"ABBBAC\" most frequent character is B with count 3, all other character is count as different to B, \\n    which is A and C, and the result is 2 + 1 = 3. \\n````\\nEach time we count the different characters. If it is not bigger than k we extend the sliding window. \\nSince we only have 26 characters, keep the count in a integer array is good enough.\\nComplete code:\\n```\\npublic class Solution {\\n    public int characterReplacement(String s, int k) {\\n        if(s == null || s.length() == 0){\\n            return 0;\\n        }\\n        int max = 0;\\n        int[] ch = new int[26];\\n        char[] str = s.toCharArray();\\n        for(int i=0, j=0; i<s.length(); i++){\\n            while(j < s.length()){\\n                ch[str[j] - 'A']++;\\n                if(count(ch) > k){  //If exceed k, break\\n                    ch[str[j] - 'A']--;\\n                    break;\\n                }\\n                j++;\\n            }\\n            max = Math.max(max, j-i);\\n            ch[str[i] - 'A']--;\\n        }\\n        return max;\\n    }\\n    //Count the number of character that is different to the longest character\\n    public int count(int[] ch){\\n        int max = 0;\\n        int sum = 0;\\n        for(int val:ch){\\n            sum += val;\\n            max = Math.max(max, val);\\n        }\\n        return sum - max;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\n\"ABBBAC\" most frequent character is B with count 3, all other character is count as different to B, \\n    which is A and C, and the result is 2 + 1 = 3. \\n```\n```\\npublic class Solution {\\n    public int characterReplacement(String s, int k) {\\n        if(s == null || s.length() == 0){\\n            return 0;\\n        }\\n        int max = 0;\\n        int[] ch = new int[26];\\n        char[] str = s.toCharArray();\\n        for(int i=0, j=0; i<s.length(); i++){\\n            while(j < s.length()){\\n                ch[str[j] - 'A']++;\\n                if(count(ch) > k){  //If exceed k, break\\n                    ch[str[j] - 'A']--;\\n                    break;\\n                }\\n                j++;\\n            }\\n            max = Math.max(max, j-i);\\n            ch[str[i] - 'A']--;\\n        }\\n        return max;\\n    }\\n    //Count the number of character that is different to the longest character\\n    public int count(int[] ch){\\n        int max = 0;\\n        int sum = 0;\\n        for(int val:ch){\\n            sum += val;\\n            max = Math.max(max, val);\\n        }\\n        return sum - max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254892,
                "title": "best-solution-in-c-using-sliding-window-o-n-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use the sliding window technique where we keep expanding the window until we have k characters different from the most frequent character in the window, and then slide the window to the right until we have fewer than k different characters. We can keep track of the maximum length of the window we encounter during this process and return it as the answer.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialize variables  to point at head(i) , tail(j) of the window array, ans, res to 0, where i and j represent the start and end of the current window, ans represents the maximum frequency of any character in the current window, and res represents the maximum length of the substring containing the same character seen so far.\\n\\n2.Initialize an unordered map mp to keep track of the frequency of characters in the current window\\n\\n3.Iterate over the string s using the variable i.\\n\\n4.Increment the frequency of the character s[i] in the map mp.\\n\\n5.Update the variable ans to the maximum frequency of any character seen so far.\\n\\n6.If the number of characters in the current window that are different from the most frequent character (i-j+1-ans) is greater than k, slide the window to the right by decrementing the frequency of the leftmost character (s[j]) and incrementing j.\\n\\n7.While sliding the window, update the maximum length of the substring containing the same character seen so far in the variable res.\\n\\n8.After iterating over the entire string, return the variable res as the maximum length of the substring containing the same character.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(n),\\n(Where n is the length of the input string s.)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int i=0, j=0, ans=0, res=0;\\n        unordered_map<char, int>mp;\\n        for(i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n            ans=max(ans,mp[s[i]]);\\n            if(i-j+1-ans>k){\\n                mp[s[j]]--;\\n                j++;\\n            }\\n            res=max(res, i-j+1);\\n        }\\n       return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int i=0, j=0, ans=0, res=0;\\n        unordered_map<char, int>mp;\\n        for(i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n            ans=max(ans,mp[s[i]]);\\n            if(i-j+1-ans>k){\\n                mp[s[j]]--;\\n                j++;\\n            }\\n            res=max(res, i-j+1);\\n        }\\n       return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503011,
                "title": "java-sliding-window-o-n-with-detailed-explanation",
                "content": "```\\n    public int characterReplacement(String s, int k) {\\n        \\n        /*\\n        Approach: Sliding window approach. Start a window from start of the string. In each step, increase it to one step right.\\n                  Have a cache (charCountCache) which will store count of each char in current window.\\n                  In each step, we will add a char to our window (newChar). Increment the new char count in cache.\\n                  Then calculate the max num of same chars in current window (maxNumOfSameCharsInCurrentWindow).\\n                  The maxNumOfSameCharsInCurrentWindow value can be calculated by taking the max of its old value, and\\n                  count (in cache) of newly encountered char (newChar).\\n                  Suppose we will consider the char with max count in current window as max-char.\\n                  Number of other characters in current window = window length - max-char count.\\n                  Now check if we can replace these other chars with max char (numOfOtherChars <= k), to maximize max-char count.\\n                  If we can, and the window will only have all max-chars, the window is valid.\\n                  If the window is valid, check and update max length of possible repetitive subsequence (maxRepSubseqLen).\\n                  If we cannot replace all other chars with max-char (numOfOtherChars > k), the window can\\'t have all max-chars.\\n                  So the window is invalid. If so, slide the window (move the starting of the window to one step right),\\n                  in cache decrement the count of leftmost char which we just excluded from window,\\n                  reset max num of same chars in current window (not needed though).\\n        \\n        Complexity analysis: Time: O(n)\\n                             Space: O(1), as used cache is fixed (26) size, irrespective of input string lenght.\\n        \\n        */\\n        \\n        int[] charCountCache = new int[26];  //Will be used to store the number of each char in current window\\n        \\n        int windowStartIndex = 0;       //Starting index of the window\\n        int windowEndIndex = 0;         //Ending index of the window\\n        \\n        int maxNumOfSameCharsInCurrentWindow = 0;           //Max num of same chars in current window\\n        \\n        int maxRepSubseqLen = 0;                            //Max length of possible repetitive subsequence\\n        \\n        for(windowEndIndex = 0; windowEndIndex<s.length(); windowEndIndex++){  //Window will keep expanding to right in each step\\n            char newChar = s.charAt(windowEndIndex);               //The newly added char to right because of window expansion\\n            \\n            charCountCache[newChar-\\'A\\']++;                                         //Increment the new char count\\n            \\n            //Check and update max number of same chars in current window\\n            maxNumOfSameCharsInCurrentWindow = Math.max(maxNumOfSameCharsInCurrentWindow, charCountCache[newChar-\\'A\\']);\\n            \\n            //Number of other (non-max char) in current window = Window size - num of max chars\\n            int numOfOtherChars = (windowEndIndex - windowStartIndex + 1) - maxNumOfSameCharsInCurrentWindow;\\n            \\n            if(numOfOtherChars<=k){             //Valid window, where the num of max-chars can be maximized by filling gaps\\n                \\n                //Since we can fill the gaps, the whole window can be filled with max-char. Check and update maxRepSubseqLen\\n                maxRepSubseqLen = Math.max(maxRepSubseqLen, windowEndIndex - windowStartIndex + 1);    \\n            }\\n            else {       //Invalid window. Slide one step to right\\n                \\n                //Decrease count of left char, since we are excluding it from window\\n                charCountCache[s.charAt(windowStartIndex)-\\'A\\']--;    \\n                \\n                //Move start of window to one step right\\n                windowStartIndex++;\\n                \\n                //Reset max num of same chars in current window (Not needed though. Included just for understanding)\\n                maxNumOfSameCharsInCurrentWindow = 0;\\n            }\\n        }\\n        \\n        return maxRepSubseqLen;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n    public int characterReplacement(String s, int k) {\\n        \\n        /*\\n        Approach: Sliding window approach. Start a window from start of the string. In each step, increase it to one step right.\\n                  Have a cache (charCountCache) which will store count of each char in current window.\\n                  In each step, we will add a char to our window (newChar). Increment the new char count in cache.\\n                  Then calculate the max num of same chars in current window (maxNumOfSameCharsInCurrentWindow).\\n                  The maxNumOfSameCharsInCurrentWindow value can be calculated by taking the max of its old value, and\\n                  count (in cache) of newly encountered char (newChar).\\n                  Suppose we will consider the char with max count in current window as max-char.\\n                  Number of other characters in current window = window length - max-char count.\\n                  Now check if we can replace these other chars with max char (numOfOtherChars <= k), to maximize max-char count.\\n                  If we can, and the window will only have all max-chars, the window is valid.\\n                  If the window is valid, check and update max length of possible repetitive subsequence (maxRepSubseqLen).\\n                  If we cannot replace all other chars with max-char (numOfOtherChars > k), the window can\\'t have all max-chars.\\n                  So the window is invalid. If so, slide the window (move the starting of the window to one step right),\\n                  in cache decrement the count of leftmost char which we just excluded from window,\\n                  reset max num of same chars in current window (not needed though).\\n        \\n        Complexity analysis: Time: O(n)\\n                             Space: O(1), as used cache is fixed (26) size, irrespective of input string lenght.\\n        \\n        */\\n        \\n        int[] charCountCache = new int[26];  //Will be used to store the number of each char in current window\\n        \\n        int windowStartIndex = 0;       //Starting index of the window\\n        int windowEndIndex = 0;         //Ending index of the window\\n        \\n        int maxNumOfSameCharsInCurrentWindow = 0;           //Max num of same chars in current window\\n        \\n        int maxRepSubseqLen = 0;                            //Max length of possible repetitive subsequence\\n        \\n        for(windowEndIndex = 0; windowEndIndex<s.length(); windowEndIndex++){  //Window will keep expanding to right in each step\\n            char newChar = s.charAt(windowEndIndex);               //The newly added char to right because of window expansion\\n            \\n            charCountCache[newChar-\\'A\\']++;                                         //Increment the new char count\\n            \\n            //Check and update max number of same chars in current window\\n            maxNumOfSameCharsInCurrentWindow = Math.max(maxNumOfSameCharsInCurrentWindow, charCountCache[newChar-\\'A\\']);\\n            \\n            //Number of other (non-max char) in current window = Window size - num of max chars\\n            int numOfOtherChars = (windowEndIndex - windowStartIndex + 1) - maxNumOfSameCharsInCurrentWindow;\\n            \\n            if(numOfOtherChars<=k){             //Valid window, where the num of max-chars can be maximized by filling gaps\\n                \\n                //Since we can fill the gaps, the whole window can be filled with max-char. Check and update maxRepSubseqLen\\n                maxRepSubseqLen = Math.max(maxRepSubseqLen, windowEndIndex - windowStartIndex + 1);    \\n            }\\n            else {       //Invalid window. Slide one step to right\\n                \\n                //Decrease count of left char, since we are excluding it from window\\n                charCountCache[s.charAt(windowStartIndex)-\\'A\\']--;    \\n                \\n                //Move start of window to one step right\\n                windowStartIndex++;\\n                \\n                //Reset max num of same chars in current window (Not needed though. Included just for understanding)\\n                maxNumOfSameCharsInCurrentWindow = 0;\\n            }\\n        }\\n        \\n        return maxRepSubseqLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 900524,
                "title": "simple-python-solution-moving-window-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        # Maintain a dictionary that keeps track of last \\'window\\' characters\\n        # See if \\'window\\' size minus occurrences of the most common char is <= k, if so it\\'s valid\\n        # Run time is O(length of string * size of alphabet)\\n\\t\\t# Space is O(size of alphabet)\\n        \\n        d = {}\\n        window = 0\\n        \\n        for i, char in enumerate(s):\\n            d[char] = d.get(char, 0) + 1\\n            if window+1 - max(d.values()) <= k:\\n                window += 1\\n            else:\\n                d[s[i-window]] -= 1\\n        \\n        return window\\n        \\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        # Maintain a dictionary that keeps track of last \\'window\\' characters\\n        # See if \\'window\\' size minus occurrences of the most common char is <= k, if so it\\'s valid\\n        # Run time is O(length of string * size of alphabet)\\n\\t\\t# Space is O(size of alphabet)\\n        \\n        d = {}\\n        window = 0\\n        \\n        for i, char in enumerate(s):\\n            d[char] = d.get(char, 0) + 1\\n            if window+1 - max(d.values()) <= k:\\n                window += 1\\n            else:\\n                d[s[i-window]] -= 1\\n        \\n        return window\\n        \\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056729,
                "title": "python-o-n-detailed-step-by-step-explanation",
                "content": "We notice immediately that this is a sliding window problem. If you\\'ve done these kinds of things in the past, you\\'ll immediately know that whenever we need something to do with substrings with a constraint - we employ the sliding window. \\n\\nIn these problems it\\u2019s useful to figure out this -> what constraint - if violated - causes me to move the start of the window and if valid causes me to increment the end of the window?\\n\\n\\nIn this case we need to find the largest window which satisfies that constraint \\n\\n\\nNow what is this constraint? \\n\\n\\nLet\\'s say that at some point in time we have a sliding window  which contains the string \"ABAA\" \\n\\nWhat do I need to do to make this sliding window such that it contains only 1 kind of letter? Well for \"ABAA\" I just need to swap B on index 1 to an A\\n\\nAsk yourself the question - how many swaps do we need to make to convert a sliding window into a window which only has 1 kind of letter? \\n\\nThe answer is \\n\\nLENGTH OF WINDOW  -  COUNT OF MOST FREQUENT LETTER\\n\\nI.E\\n\\nFor ABAA we can do 4 - 3 = 1 swap  to make it AAAA\\n\\nFor BBAB we can do 4 - 3 = 1 swap to make it BBBB\\n\\n\\nIt follows naturally from this that we need to find a longest window such that: \\n\\nLENGTH OF WINDOW - COUNT OF MOST FREQUENT LETTER <= k \\n\\nI.E FIND THE LONGEST WINDOW WHICH YOU CAN CONVERT INTO A WINDOW WITH ONLY 1 KIND OF CHARACTER BY DOING AT MOST K SWAP OPERATIONS\\n\\nNow that you know the logic - you should be able to follow the code below easily\\n\\n```\\n    def characterReplacement(self, s, k):\\n        if not s:\\n            return 0\\n\\n        n = len(s)\\n        if n == 1:\\n            return 1\\n\\n        start = 0\\n        end = 0\\n        ans = 0\\n        most_frequent_character_count = 0\\n\\n        window_char_counts = [0] * 27\\n        window_char_counts[ord(s[0]) - ord(\\'A\\')] += 1\\n\\n        while end < n:\\n            curr_len = end - start + 1\\n\\n            most_frequent_character_count = max(window_char_counts)\\n\\n            # constraint curr_len - count of most frequent character in window <= k for window to advance\\n\\n            # check constraint\\n\\n            if curr_len - most_frequent_character_count <= k:\\n                ans = max(ans, end - start + 1)\\n                end += 1\\n                if end < n:\\n                    window_char_counts[ord(s[end]) - ord(\\'A\\')] +=1\\n\\n            else:\\n                window_char_counts[ord(s[start]) - ord(\\'A\\')] -=1\\n                start += 1\\n\\n\\n        return ans\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    def characterReplacement(self, s, k):\\n        if not s:\\n            return 0\\n\\n        n = len(s)\\n        if n == 1:\\n            return 1\\n\\n        start = 0\\n        end = 0\\n        ans = 0\\n        most_frequent_character_count = 0\\n\\n        window_char_counts = [0] * 27\\n        window_char_counts[ord(s[0]) - ord(\\'A\\')] += 1\\n\\n        while end < n:\\n            curr_len = end - start + 1\\n\\n            most_frequent_character_count = max(window_char_counts)\\n\\n            # constraint curr_len - count of most frequent character in window <= k for window to advance\\n\\n            # check constraint\\n\\n            if curr_len - most_frequent_character_count <= k:\\n                ans = max(ans, end - start + 1)\\n                end += 1\\n                if end < n:\\n                    window_char_counts[ord(s[end]) - ord(\\'A\\')] +=1\\n\\n            else:\\n                window_char_counts[ord(s[start]) - ord(\\'A\\')] -=1\\n                start += 1\\n\\n\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2492615,
                "title": "c-optimized-solution-explanation-complexity-analysis",
                "content": "***Explanation :*** \\uD83D\\uDCCA\\u2714\\uFE0F\\nThis could be hard to come up with a O(n) sliding window solution if you have encountered this kind of problem for the first time .\\n***Naive Way :*** To  run a double for loop  and find the max subarray for every element by replacing at most k elelments . It will be a n^2 solution.\\n***Efficient Way :*** So , we are supposed to find the max length and swaps should be<=k.\\nEg : ***string s= \"ABABBA\"  ,  k=2***\\nLet\\'s say sliding window at an instant is from index ***1 to  4 . ( length =4 ) -> i-j+1***\\n***Occurances( Map ) :\\nB->3\\nA->1***\\nMaximum Occurance in current window : B\\nCalculation : If ***length of window - max Occurance <=k***\\ni.e. ***(4-3)=1*** (which  is count of elements  not similar to maxOccuring element) ***<=2***\\nThus ,our current sliding window is valid , so currently we have a ***result we get =  4 ( size of window )*** within k operations.\\nLets, say If , ***len. of window - max Occurance > K*** , then : \\nwe will first decrement the count of last character in the map , and increament the last of the sliding window, \\n\\n***NOTE - We donot need to  find max Occurance again(when we dcrease  the window) as it will not lead to a batter result*** . First try to visualize it by Dry Running the code . (for you own logic building )\\n***REASON  :\\nUpon seeing that (i - lo + 1) - maxOccurence > k, wouldn\\'t we want to shrink the window until that condition becomes true? \\nWe don\\'t actually need to, and here\\'s why***. \\nThe iteration before we enter that \"else\" will save the longest valid substring we\\'ve found so far. This implies that we have no reason to look at any windows smaller than that best length substring we\\'ve found. \\n\\nAt end , we  ***return*** result .\\n\\n***Complexity  Analysis :\\nTC : O(n)\\nSC : O(26)*** ( at max we have 26 alphabets in english language )\\n\\n**UPVOTE IF YOU LIKE** \\uD83D\\uDE0A\\u2705\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        map<char,int>m;  // storing characters  and their count\\n        int l =0,max_Occurance=0,res=0;\\n        \\n        for(int i =0 ;i < s.size() ; i++){\\n            \\n            m[s[i]]++;  // adding value to map\\n            max_Occurance=max(max_Occurance,m[s[i]]);  // updating the maximum occuring element\\n            \\n            if(i-l+1-max_Occurance > k){  // if we get more operations in sliding window (invalid)\\n                m[s[l]]--; // decreasing count from map\\n                l++;  // increment  previous pointer\\n            }\\n            else res=max(res,i-l+1);    //update result\\n        }        \\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        map<char,int>m;  // storing characters  and their count\\n        int l =0,max_Occurance=0,res=0;\\n        \\n        for(int i =0 ;i < s.size() ; i++){\\n            \\n            m[s[i]]++;  // adding value to map\\n            max_Occurance=max(max_Occurance,m[s[i]]);  // updating the maximum occuring element\\n            \\n            if(i-l+1-max_Occurance > k){  // if we get more operations in sliding window (invalid)\\n                m[s[l]]--; // decreasing count from map\\n                l++;  // increment  previous pointer\\n            }\\n            else res=max(res,i-l+1);    //update result\\n        }        \\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331380,
                "title": "sliding-window-blind-75-solution",
                "content": "\\n# Sliding Window ----->O(26*N)\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        output,left,dic=0,0,{}\\n        for right in range(len(s)):\\n            dic[s[right]]=1+dic.get(s[right],0)\\n            while (right-left+1)-max(dic.values())>k:\\n                dic[s[left]]-=1\\n                left+=1\\n            output=max(output,right-left+1)\\n        return output\\n```\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        left,maxf=0,0\\n        dic=defaultdict(int)\\n        for right in range(len(s)):\\n            dic[s[right]]+=1\\n            maxf=max(maxf,dic[s[right]])\\n            if (right-left+1)>maxf+k:\\n                dic[s[left]]-=1\\n                left+=1\\n        return len(s)-left\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        output,left,dic=0,0,{}\\n        for right in range(len(s)):\\n            dic[s[right]]=1+dic.get(s[right],0)\\n            while (right-left+1)-max(dic.values())>k:\\n                dic[s[left]]-=1\\n                left+=1\\n            output=max(output,right-left+1)\\n        return output\\n```\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        left,maxf=0,0\\n        dic=defaultdict(int)\\n        for right in range(len(s)):\\n            dic[s[right]]+=1\\n            maxf=max(maxf,dic[s[right]])\\n            if (right-left+1)>maxf+k:\\n                dic[s[left]]-=1\\n                left+=1\\n        return len(s)-left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965712,
                "title": "python-easiest-solution-with-explanation-96-68-faster-beg-to-adv-sliding-window",
                "content": "\\n```python\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        maxf = l = 0\\n        count = collections.Counter() # counting the occurance of the character in the string. \\n\\t\\t# instead of using \"count = collections.Counter()\", we can do the following:-\\n\\t\\t\"\"\"\\n\\t\\tfor r, n in enumerate(s):\\n            if n in hashmap:\\n                hashmap[n] += 1\\n            else:\\n                hashmap[n] = 1\\n\\t\\t\"\"\"\\n        for r in range(len(s)):\\n            count[s[r]] += 1 # increasing the count of the character as per its occurance. \\n            maxf = max(maxf, count[s[r]]) # having a max freq of the character that is yet occurred. \\n            if r - l + 1 > maxf + k:  # if length of sliding window is greater than max freq of the character and the allowed number of replacement.\\n                count[s[l]] -= 1 # then we have to decrease the occurrance of the character by 1 are we will be sliding the window. \\n                l += 1 # and we have to slide our window\\n        return len(s) - l  # this will provide the length of the longest substring containing the same letter with the replacement allowed. \\n```\\n\\n***Found helpful, Do upvote!!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        maxf = l = 0\\n        count = collections.Counter() # counting the occurance of the character in the string. \\n\\t\\t# instead of using \"count = collections.Counter()\", we can do the following:-\\n\\t\\t\"\"\"\\n\\t\\tfor r, n in enumerate(s):\\n            if n in hashmap:\\n                hashmap[n] += 1\\n            else:\\n                hashmap[n] = 1\\n\\t\\t\"\"\"\\n        for r in range(len(s)):\\n            count[s[r]] += 1 # increasing the count of the character as per its occurance. \\n            maxf = max(maxf, count[s[r]]) # having a max freq of the character that is yet occurred. \\n            if r - l + 1 > maxf + k:  # if length of sliding window is greater than max freq of the character and the allowed number of replacement.\\n                count[s[l]] -= 1 # then we have to decrease the occurrance of the character by 1 are we will be sliding the window. \\n                l += 1 # and we have to slide our window\\n        return len(s) - l  # this will provide the length of the longest substring containing the same letter with the replacement allowed. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 838635,
                "title": "python-sliding-window-solution-with-explanation",
                "content": "Inspired by these explanations:\\n- https://leetcode.com/problems/longest-repeating-character-replacement/discuss/91271/Java-12-lines-O(n)-sliding-window-solution-with-explanation/95822\\n- https://leetcode.com/problems/longest-repeating-character-replacement/discuss/91271/Java-12-lines-O(n)-sliding-window-solution-with-explanation/95833\\n- https://leetcode.com/problems/longest-repeating-character-replacement/discuss/91271/Java-12-lines-O(n)-sliding-window-solution-with-explanation/137008\\n\\nIntuition: We first handle our base case and return 0 if the string is empty or a None. Then we move onto the core of the algorithm. This algorithm relies on a few key insights:\\n- Insight 1: For a given sliding window, s[start:end+1], the window is valid if the number of operations to make the window valid is less than or equal to the number of operations we have (k). \\n- Insight 2: We are only looking for the length of longest possible substring, so we define our sliding window such that it never shrinks. Its size either remains stagnant (both the end and start ptr progress) or its size increases by 1 (only the end ptr progresses, start ptr stays stagnant). Because we\\'ve defined our sliding window this way, sometimes our sliding window will span a substring s1, such that s1 is not a valid substring. But we do not care about this happening because the key insight with our solution setup is that if a sliding window reaches a length n, then at some point there was a substring of length n that was indeed valid (or else the window would not have expanded to that size). \\n- Insight 3: Since we defined our sliding window such that it never shrinks (its size either remains stagnant or increases), at the end of our algorithm, we know that the sliding window is as big as it can be. The size of the sliding window at the end of our algorithm represents the length of the longest valid substring we\\'ve seen, which is why we return the size of our sliding window. \\n\\nIncluded below are two solutions. Solution 1 uses the straightforward mechanism from counter.most_common in order to keep track of the most common character in any given sliding window. This is not optimal because most_common(1) takes O(N) time (I found this out by reading these [two](https://stackoverflow.com/questions/29240807/python-collections-counter-most-common-complexity) [links](https://stackoverflow.com/questions/23038756/how-does-heapq-nlargest-work)). Basically, the idea is that counter\\'s most_common, [under the hood](https://github.com/python/cpython/blob/1b85f4ec45a5d63188ee3866bd55eb29fdec7fbf/Lib/collections/__init__.py#L575), uses heapq\\'s nlargest method. And heapq\\'s nlargest method, [under the hood](https://svn.python.org/projects/python/trunk/Lib/heapq.py),\\n- heapifies t (where t represents the t largest elements we want to know) elements: `O(t)`\\n- does heappushpop on the remaining n-t elements (where n is the total number of elements in our iterable): `O((n-t)*log(t))`\\n- at the end, we sort the heap and return: `O(t*logt)`\\n\\nSo heapq\\'s nlargest takes `O(t)+O((n-t)*log(t))+O(t*logt)` time. If we substitute t=1 and simplify, it will reduce to `O(n)`. Hence, counter\\'s most_common(1) invocation will always cost O(n) where n is the number of elements in our iterable. This is why using counter\\'s most_common will not allow us to get O(n) runtime. Hopefully this is enough explanation to motivate the need for a further optimization (shown in solution 2). \\n\\nIn order to move from solution 1 to solution 2, we search for a way to get rid of the counter.most_common(1) method invocation that occurs on every iteration of the for loop. In order to do this, we have to think about what we are getting from this invocation and whether there is a less computationally expensive way to maintain that knowledge. counter.most_common(1) tells us, for a given sliding window, what is the most frequently occuring character in the window. In solution two, we replace the method invocation of counter.most_common(1) with a variable called countOfMostCommonChar, where we maintain the countOfMostCommonChar throughout the iterations. \\n\\n------------------------------------------------------------------------------------------------------------------------\\n\\nSolution 1 (using counter.most_common) -- not optimal, including it here for learning purposes\\n\\n**Analysis for Solution 1 (not optimal)**\\nN=len(s)\\nRuntime: O(N^2), since our for loop runs O(N) times, and for each of those O(N) iterations, a O(N) invocation of counter.most_common(1) is made. \\nSpace: O(N), for when counter needs to hold every character in s (s has no duplicate characters), and every character in s is part of the largest valid substring\\n\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\'\\'\\'\\n        brainstorm: \\n        - continue to move end pointer toward the end, regardless\\n        - move start pointer only if it\\'s invalid, by moving the start pointer along, we basically make it so that the window doesn\\'t get enlargened. \\n        - and then at the end of our algorithm, we have the biggest window possible. \\n        \\'\\'\\'\\n        if not s: return 0\\n        N=len(s)\\n        start=0\\n        c=Counter(s[0])\\n        for end in range(1,N):\\n            c[s[end]] += 1\\n            countOfMostCommonChar = c.most_common(1)[0][1]\\n            lengthOfWindow = end-start+1\\n            numOpsToMakeWindowValid = lengthOfWindow - countOfMostCommonChar\\n            # do we have enough operations to make this window a valid string?\\n            # is length of window - countofMostCommonChar <= k?\\n            if numOpsToMakeWindowValid > k:\\n                c[s[start]]-=1\\n                start+=1\\n                \\n        return N - start\\n```\\n\\nSolution 2 (removes use of counter.most_common) -- optimal\\n\\n**Analysis for Solution 2 (optimal)**\\nN=len(s)\\nRuntime: O(N), since the for loop runs O(N) times, and we do O(1) time work in each iteration. \\nSpace: O(N), for when counter needs to hold every character in s (s has no duplicate characters), and every character in s is part of the largest valid substring\\n\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\'\\'\\'\\n        brainstorm: \\n        - continue to move end pointer toward the end, regardless\\n        - move start pointer only if it\\'s invalid, by moving the start pointer along, we basically make it so that the window doesn\\'t get enlargened. \\n        - and then at the end of our algorithm, we have the biggest window possible. \\n        \\'\\'\\'\\n        if not s: return 0\\n        N=len(s)\\n        countOfMostCommonChar=start=0\\n        c=Counter(s[0])\\n        for end in range(1,N):\\n            c[s[end]] += 1\\n            countOfMostCommonChar = max(countOfMostCommonChar, c[s[end]])\\n            lengthOfWindow = end-start+1\\n            numOpsToMakeWindowValid = lengthOfWindow - countOfMostCommonChar\\n            # do we have enough operations to make this window a valid string?\\n            # is length of window - countofMostCommonChar <= k?\\n            if numOpsToMakeWindowValid > k:\\n                c[s[start]]-=1\\n                start+=1\\n                \\n        return N - start\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\'\\'\\'\\n        brainstorm: \\n        - continue to move end pointer toward the end, regardless\\n        - move start pointer only if it\\'s invalid, by moving the start pointer along, we basically make it so that the window doesn\\'t get enlargened. \\n        - and then at the end of our algorithm, we have the biggest window possible. \\n        \\'\\'\\'\\n        if not s: return 0\\n        N=len(s)\\n        start=0\\n        c=Counter(s[0])\\n        for end in range(1,N):\\n            c[s[end]] += 1\\n            countOfMostCommonChar = c.most_common(1)[0][1]\\n            lengthOfWindow = end-start+1\\n            numOpsToMakeWindowValid = lengthOfWindow - countOfMostCommonChar\\n            # do we have enough operations to make this window a valid string?\\n            # is length of window - countofMostCommonChar <= k?\\n            if numOpsToMakeWindowValid > k:\\n                c[s[start]]-=1\\n                start+=1\\n                \\n        return N - start\\n```\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\'\\'\\'\\n        brainstorm: \\n        - continue to move end pointer toward the end, regardless\\n        - move start pointer only if it\\'s invalid, by moving the start pointer along, we basically make it so that the window doesn\\'t get enlargened. \\n        - and then at the end of our algorithm, we have the biggest window possible. \\n        \\'\\'\\'\\n        if not s: return 0\\n        N=len(s)\\n        countOfMostCommonChar=start=0\\n        c=Counter(s[0])\\n        for end in range(1,N):\\n            c[s[end]] += 1\\n            countOfMostCommonChar = max(countOfMostCommonChar, c[s[end]])\\n            lengthOfWindow = end-start+1\\n            numOpsToMakeWindowValid = lengthOfWindow - countOfMostCommonChar\\n            # do we have enough operations to make this window a valid string?\\n            # is length of window - countofMostCommonChar <= k?\\n            if numOpsToMakeWindowValid > k:\\n                c[s[start]]-=1\\n                start+=1\\n                \\n        return N - start\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 287688,
                "title": "python-sliding-window-time-o-n-space-o-1-with-explanation",
                "content": "I post explanations for problems where I don\\'t understand other solutions so that others might be able to understand faster. It would be nice for other posters to explain their code, because sometimes it takes a while for me to understand the reasoning if there is no explanation. \\n\\nThe start and end are the start and end indexes of the sliding window you are looking at. MaxChar is the maximum characters you can have in your window of a SINGLE letter so that you can replace up to k other letters to get the longest subarray possible. In the if statement, i`f end - start + 1 - maxChar > k:`, if we have too many characters in our window, we move our `start` index. We will only ever move `start` by 1 increment each time. \\n\\nThe thing that tripped me up with this problem was trying to do a contracting window, whereas in this problem, it is best to always have the window be maxChar + k long until the end, with maxChar updating whenever it gets bigger. \\n\\nSpace is O(1) because the dictionary can only be 26 items long, bc each key is a letter in the alphabet. \\n\\n```\\nclass Solution:\\n    def characterReplacement(self, s, k):\\n        d = collections.defaultdict(int)\\n        start, res, maxChar = 0, 0, 0\\n        for end in range(len(s)):\\n            d[s[end]] += 1\\n            maxChar = max(maxChar, d[s[end]])\\n            if end - start + 1 - maxChar > k:\\n                d[s[start]] -= 1\\n                start += 1 \\n            res = max(res, end - start + 1)\\n        return res \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s, k):\\n        d = collections.defaultdict(int)\\n        start, res, maxChar = 0, 0, 0\\n        for end in range(len(s)):\\n            d[s[end]] += 1\\n            maxChar = max(maxChar, d[s[end]])\\n            if end - start + 1 - maxChar > k:\\n                d[s[start]] -= 1\\n                start += 1 \\n            res = max(res, end - start + 1)\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351600,
                "title": "c-simple-with-explanation-sliding-window",
                "content": "This might be an example of a pattern to keep in mind while solving sliding window problems with optimisation (min/max). \\n\\nOne can see that we need to keep a count of the element which occurs the maximum times in a window, and keep extending the window till the elements within the window except the one with maximum count are <= k. The moment we exceed k, start should be incremented, and max count should be updated for the new window.\\n\\nThis is intuitive and correctly solves the problem, however this will give TLE. The insight/trick here is that max count within a window does not actually need to be updated every time start is updated, because:\\n\\n* The largest window possible (after the present window) will always have **greater** than the present max count of elements in it, so if we just update the total count of elements while incrementing start, and not the max count, we will still get the correct answer\\n\\nI do think this is difficult to come up with spontaneously in an interview, hence the idea can be memorized as a pattern in sliding window problems.\\n\\nThe code using the above logic:\\n\\n```\\n    int characterReplacement(string s, int k) {\\n        int end = 0;\\n        int start = 0;\\n        \\n        int max_len = 0;\\n        int max_count_in_window = 0; // the name is misleading, it is actually the max number of times a character appears in s[0..end]\\n        \\n        unordered_map<char,int> count;\\n        \\n        for(end = 0; end < s.size(); end++)\\n        {\\n            count[s[end]]++;\\n            max_count_in_window = max(count[s[end]], max_count_in_window);\\n            if(end - start + 1 - max_count_in_window > k)\\n            {\\n                count[s[start]]--;\\n                start++;\\n            }\\n            max_len = max(max_len, end - start + 1);\\n        }\\n        \\n        return max_len;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n    int characterReplacement(string s, int k) {\\n        int end = 0;\\n        int start = 0;\\n        \\n        int max_len = 0;\\n        int max_count_in_window = 0; // the name is misleading, it is actually the max number of times a character appears in s[0..end]\\n        \\n        unordered_map<char,int> count;\\n        \\n        for(end = 0; end < s.size(); end++)\\n        {\\n            count[s[end]]++;\\n            max_count_in_window = max(count[s[end]], max_count_in_window);\\n            if(end - start + 1 - max_count_in_window > k)\\n            {\\n                count[s[start]]--;\\n                start++;\\n            }\\n            max_len = max(max_len, end - start + 1);\\n        }\\n        \\n        return max_len;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1306848,
                "title": "c-explained-sliding-window-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    // Forget about k for a while, how will you find the length of the longest substring containing the same letter?\\n    // X = (length of the string - freq of maximum occuring character in the string)\\n    // This will give us the number of characters which are \"NOT\" the maximum freq character, we can replace all of them \\n    // so that the string becomes the same char which is the max occuring character.\\n    \\n    // Now, how to do the same thing given that we can\\'t change all of X chars but only K chars at max\\n    // We iterate over the string like sliding window and for all possible substrings we check for the condition:\\n    // (length of substring - freq of maximum occuring character in THIS substring) <= k \\n    // If this condition holds true, then we can replace the OTHER characters to max freq characterto get the same character in the substring,\\n    // Then, we increase the window by 1 size and check if this condition still holds true, if yes, then increase the max same character result.\\n    // After some time, the condition will not hold true since the number of OTHER chars > k and then we cant replace all of them to max freq since they are > k\\n    // Then, we shorten the window from the start and keep checking if the cond. holds true now?\\n    \\n    // OTHER chars = characters which are not the max freq character.\\n    \\n    int characterReplacement(string s, int k) {\\n        if (s.size() == 0) return 0;\\n        \\n        int i=0; // start of sliding window (i.. j-1)\\n        int j=0; // next char of the window\\n        int maxCharCount=0, result=0;\\n        unordered_map<char, int> freq;\\n        \\n        // Till we reach the end of the string\\n        while(j!=s.size()){\\n            // increase the freq and hold the freq of the maxchar in maxCharCount\\n            freq[s[j]]++;\\n            maxCharCount = max(maxCharCount, freq[s[j]]);\\n            \\n            // If the number of OTHER chars > k, then we need to reduce this window and keep updating the maxCharCount till the OTHER characters <=k\\n            // If the OTHER chars <= k, then we can replace all of them into the max Freq character and then all of them will be same.\\n            while(j-i-maxCharCount+1 > k){\\n                freq[s[i]]--;\\n                i++;\\n                for(auto m: freq)\\n                    maxCharCount = max(maxCharCount, m.second);\\n            }\\n            \\n            // After the character is adjusted in the window, check if this is the largest window?\\n            result = max(result, j-i+1);\\n            j++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Forget about k for a while, how will you find the length of the longest substring containing the same letter?\\n    // X = (length of the string - freq of maximum occuring character in the string)\\n    // This will give us the number of characters which are \"NOT\" the maximum freq character, we can replace all of them \\n    // so that the string becomes the same char which is the max occuring character.\\n    \\n    // Now, how to do the same thing given that we can\\'t change all of X chars but only K chars at max\\n    // We iterate over the string like sliding window and for all possible substrings we check for the condition:\\n    // (length of substring - freq of maximum occuring character in THIS substring) <= k \\n    // If this condition holds true, then we can replace the OTHER characters to max freq characterto get the same character in the substring,\\n    // Then, we increase the window by 1 size and check if this condition still holds true, if yes, then increase the max same character result.\\n    // After some time, the condition will not hold true since the number of OTHER chars > k and then we cant replace all of them to max freq since they are > k\\n    // Then, we shorten the window from the start and keep checking if the cond. holds true now?\\n    \\n    // OTHER chars = characters which are not the max freq character.\\n    \\n    int characterReplacement(string s, int k) {\\n        if (s.size() == 0) return 0;\\n        \\n        int i=0; // start of sliding window (i.. j-1)\\n        int j=0; // next char of the window\\n        int maxCharCount=0, result=0;\\n        unordered_map<char, int> freq;\\n        \\n        // Till we reach the end of the string\\n        while(j!=s.size()){\\n            // increase the freq and hold the freq of the maxchar in maxCharCount\\n            freq[s[j]]++;\\n            maxCharCount = max(maxCharCount, freq[s[j]]);\\n            \\n            // If the number of OTHER chars > k, then we need to reduce this window and keep updating the maxCharCount till the OTHER characters <=k\\n            // If the OTHER chars <= k, then we can replace all of them into the max Freq character and then all of them will be same.\\n            while(j-i-maxCharCount+1 > k){\\n                freq[s[i]]--;\\n                i++;\\n                for(auto m: freq)\\n                    maxCharCount = max(maxCharCount, m.second);\\n            }\\n            \\n            // After the character is adjusted in the window, check if this is the largest window?\\n            result = max(result, j-i+1);\\n            j++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994997,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int left = 0;\\n        int max = 0;\\n        int maxRepeatChar = 0;\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n        for(int right = 0; right < s.length(); right++){\\n            char c = s.charAt(right);\\n            freqMap.put(c, freqMap.getOrDefault(c,0)+1);\\n            // Get Window having maximum repeating Character\\n            maxRepeatChar = Math.max(maxRepeatChar, freqMap.get(c));\\n            //check if the remaining chars in maxrepeating window are greater than k, if yes - shrink the window \\n            if(right -left +1 - maxRepeatChar >k){\\n                char leftchar = s.charAt(left);\\n                freqMap.put(leftchar, freqMap.get(leftchar)-1);\\n                left++;\\n            }\\n            max = Math.max(max, right-left+1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int left = 0;\\n        int max = 0;\\n        int maxRepeatChar = 0;\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n        for(int right = 0; right < s.length(); right++){\\n            char c = s.charAt(right);\\n            freqMap.put(c, freqMap.getOrDefault(c,0)+1);\\n            // Get Window having maximum repeating Character\\n            maxRepeatChar = Math.max(maxRepeatChar, freqMap.get(c));\\n            //check if the remaining chars in maxrepeating window are greater than k, if yes - shrink the window \\n            if(right -left +1 - maxRepeatChar >k){\\n                char leftchar = s.charAt(left);\\n                freqMap.put(leftchar, freqMap.get(leftchar)-1);\\n                left++;\\n            }\\n            max = Math.max(max, right-left+1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087664,
                "title": "easy-algorithm-explanation-pictorial-with-code-c",
                "content": "**Approach:**\\nThis question is pretty much similar to [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)\\n1. We take two variables, start and end, indicating the starting and ending indices of our required longest substring.\\n2. At first, keeping the start variable fixed, we keep moving end variable, one at a time towards the end of the string s.\\n3. While moving end, we keep a frequency check of the number of times a particular alphabet is occuring using freq vector. \\n4. We then find out the frequency of the maximum occuring alphabet (max_char) \\n5. Now we have a substring whose starting position is indicated by start and ending by end. The length of which is *end-start+1*.\\n6. In this substring, we have to replace ***end-start+1-max_char*** characters, to make all of them equal.\\n (Why end-start+1-max_char ??....see figure below).\\n7. Only if this end-start+1-max_char is lesser or equal than k, then we can replace,... else we keep moving start, until condition is fulfilled.\\n\\n![image](https://assets.leetcode.com/users/images/00ec5cc1-164d-4c76-bd4c-7139411bb397_1614581857.9339428.png)\\n\\n\\nPS: Do upvote, if its helpful : )\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k)\\n    {\\n        int start = 0, end = 0, max_char = 0, length = 0;\\n        vector<int> freq(26, 0);\\n        int n = s.size();\\n        \\n        for(int end=0;end<n;end++)\\n        {\\n            freq[s[end]-  \\'A\\']++;\\n            int x = freq[s[end] - \\'A\\'];\\n            \\n            max_char = max(max_char, x);\\n            \\n            while(end-start+1-max_char > k)\\n            {\\n                freq[s[start] - \\'A\\']--;\\n                start++;\\n            }\\n            \\n            length = max(length, end-start+1);\\n        }\\n        \\n        return length;\\n    }\\n};\\n```\\nGet more Leetcode Solution [HERE](https://github.com/noob-hu-yaar/Leetcode/tree/master/nandincpp)\\n****",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k)\\n    {\\n        int start = 0, end = 0, max_char = 0, length = 0;\\n        vector<int> freq(26, 0);\\n        int n = s.size();\\n        \\n        for(int end=0;end<n;end++)\\n        {\\n            freq[s[end]-  \\'A\\']++;\\n            int x = freq[s[end] - \\'A\\'];\\n            \\n            max_char = max(max_char, x);\\n            \\n            while(end-start+1-max_char > k)\\n            {\\n                freq[s[start] - \\'A\\']--;\\n                start++;\\n            }\\n            \\n            length = max(length, end-start+1);\\n        }\\n        \\n        return length;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695812,
                "title": "python-faster-than-97-sliding-window-with-detailed-explanation",
                "content": "\\tclass Solution:\\n\\t\\tdef characterReplacement(self, s: str, k: int) -> int:\\n\\t\\t\\tvisited = {}\\n\\t\\t\\tres = 0\\n\\t\\t\\tl = 0\\n\\t\\t\\tfreq = 0\\n\\n\\t\\t\\tfor r in range(len(s)):\\n\\t\\t\\t\\tvisited[s[r]] = 1 + visited.get(s[r], 0)\\n\\t\\t\\t\\tfreq = max(freq, visited[s[r]])\\n\\n\\t\\t\\t\\twhile (r - l + 1) - freq> k:\\n\\t\\t\\t\\t\\tvisited[s[l]] -= 1\\n\\t\\t\\t\\t\\tl += 1\\n\\n\\t\\t\\t\\tres = max(res, r - l + 1)\\n\\n\\t\\t\\treturn res\\n\\nEssentially in this sliding window solution, we want to expand our window while updating our result simutaneously until the window is no longer valid. How do we determine whether a window is valid or not? From the premise, we know that the # of characters being switched out cannot be greater than k. So in our window, we are going to take the max value of the # needed to switch out from the group of characters. For example:\\n\\nAABA, the maximum # is 3, and 4 - 3 = 1, which is less than 2.\\n\\nSo why do we need the maximum value? This takes a bit of inverse thinking, if we take subtract the max value with the length of the window, that prompts us the minimum # of characters needed to switch out.\\n\\nTo keep track of the maximum frequence, I\\'ve created the variable called \"freq\". freq will capture the maximum number of times a character appears by comparing it with the most recently inserted character\\n\\nWe could update the maximum size of the subarray by subtracting the right pointer with the left.",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "class Solution:\\n\\t\\tdef characterReplacement(self, s: str, k: int) -> int:\\n\\t\\t\\tvisited = {}",
                "codeTag": "Java"
            },
            {
                "id": 578125,
                "title": "c-fastest-minimalizm",
                "content": "It\\'s a bit tricky to get an intuition for this question:\\n- This problem follows the sliding window pattern.\\n- Track count of the most frequent character in our window `m_cnt`. The count of all other characters cannot exceed `k`.\\n- This is a tricky part. As we shrink our window, we do not need to decrease/recompute `m_cnt`. We do not care if `m_cnt` is incorrect for a given window, as it won\\'t affect the result. What matters is the largest `m_cnt` we can achieve, which will result in the largest window - `m_cnt + k`. \\n\\n```cpp\\nint characterReplacement(string &s, int k) {\\n    size_t cnt[128] = {}, m_cnt = 0;\\n    for (int i = 0, j = 0; i < s.size(); ++i) {\\n        m_cnt = max(m_cnt, ++cnt[s[i]]);\\n        if (i - j + 1 - m_cnt > k)\\n          --cnt[s[j++]];\\n    }\\n    return min(s.size(), k + m_cnt);\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n) - 0 ms runtime\\n- Memory: O(1) - 6.9 MB memory",
                "solutionTags": [],
                "code": "```cpp\\nint characterReplacement(string &s, int k) {\\n    size_t cnt[128] = {}, m_cnt = 0;\\n    for (int i = 0, j = 0; i < s.size(); ++i) {\\n        m_cnt = max(m_cnt, ++cnt[s[i]]);\\n        if (i - j + 1 - m_cnt > k)\\n          --cnt[s[j++]];\\n    }\\n    return min(s.size(), k + m_cnt);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 491486,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Use Sliding Window Technique with `left` and `right` pointers\\n2. Within the winodw, we define its length using `right - left + 1`, in addition, we define the most frequent character\\'s count using `mostFreq`. If the `length - mostFreq > k`, this means we exceeded our operation limit to make the current window a valid string. Thus, we need to shrink left pointers.\\n``` javascript\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar characterReplacement = function(s, k) {\\n    let left = 0, right = 0, max = 0, mostFreq = 0;\\n    let freqHash = {};\\n    \\n    for (let right=0;right<s.length;right++) {\\n        freqHash[s[right]] = freqHash[s[right]] + 1 || 1;\\n        mostFreq = Math.max(mostFreq, freqHash[s[right]]);\\n        while(right - left + 1 - mostFreq > k) {\\n            freqHash[s[left]]-=1;\\n            left++;\\n        }\\n        max = Math.max(max, right - left + 1);\\n    }\\n    \\n    return max;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar characterReplacement = function(s, k) {\\n    let left = 0, right = 0, max = 0, mostFreq = 0;\\n    let freqHash = {};\\n    \\n    for (let right=0;right<s.length;right++) {\\n        freqHash[s[right]] = freqHash[s[right]] + 1 || 1;\\n        mostFreq = Math.max(mostFreq, freqHash[s[right]]);\\n        while(right - left + 1 - mostFreq > k) {\\n            freqHash[s[left]]-=1;\\n            left++;\\n        }\\n        max = Math.max(max, right - left + 1);\\n    }\\n    \\n    return max;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499834,
                "title": "c-sliding-window-cheat-sheet",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Sliding Window\\nCheck out \"[C++ Maximum Sliding Window Cheatsheet Template!](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!)\".\\n\\nShrinkable Sliding Window:\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/longest-repeating-character-replacement/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int i = 0, j = 0, cnt[26] = {}, ans = 0, N = s.size();\\n        while (j < N) {\\n            cnt[s[j++] - \\'A\\']++;\\n            while (j - i - *max_element(cnt, cnt + 26) > k) cnt[s[i++] - \\'A\\']--;\\n            ans = max(ans, j - i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nNon-shrinkable Sliding Window:\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/longest-repeating-character-replacement/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int i = 0, j = 0, cnt[26] = {}, N = s.size();\\n        while (j < N) {\\n            cnt[s[j++] - \\'A\\']++;\\n            if (j - i - *max_element(cnt, cnt + 26) > k) cnt[s[i++] - \\'A\\']--;\\n        }\\n        return j - i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/longest-repeating-character-replacement/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int i = 0, j = 0, cnt[26] = {}, ans = 0, N = s.size();\\n        while (j < N) {\\n            cnt[s[j++] - \\'A\\']++;\\n            while (j - i - *max_element(cnt, cnt + 26) > k) cnt[s[i++] - \\'A\\']--;\\n            ans = max(ans, j - i);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/longest-repeating-character-replacement/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int i = 0, j = 0, cnt[26] = {}, N = s.size();\\n        while (j < N) {\\n            cnt[s[j++] - \\'A\\']++;\\n            if (j - i - *max_element(cnt, cnt + 26) > k) cnt[s[i++] - \\'A\\']--;\\n        }\\n        return j - i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494712,
                "title": "c-sliding-window",
                "content": "**Best possible explanation I found:** https://leetcode.com/problems/longest-repeating-character-replacement/discuss/91285/Sliding-window-similar-to-finding-longest-substring-with-k-distinct-characters\\n\\n**Code:**\\n```\\n    int characterReplacement(string a, int k) {\\n        int i=0,j=0, maxRepeating = 0, maxLen = 0;\\n        unordered_map<char, int> m;\\n        \\n        //Character other than maximum repeating character should at most be k, becuase we can make only k changes in the string.\\n        //(length of substring - number of times of the maximum occurring character in the substring) <= k\\n\\t\\t\\n        for(j=0; j<a.size(); j++){\\n            m[a[j]]++;\\n            maxRepeating = max(maxRepeating, m[a[j]]);\\n            //When other characters become greater than k, we move window ahead.\\n            if(j-i+1 - maxRepeating > k){\\n                m[a[i]]--;\\n                i++;\\n            }\\n            maxLen = max(maxLen, j-i+1);\\n        }\\n        return maxLen;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n    int characterReplacement(string a, int k) {\\n        int i=0,j=0, maxRepeating = 0, maxLen = 0;\\n        unordered_map<char, int> m;\\n        \\n        //Character other than maximum repeating character should at most be k, becuase we can make only k changes in the string.\\n        //(length of substring - number of times of the maximum occurring character in the substring) <= k\\n\\t\\t\\n        for(j=0; j<a.size(); j++){\\n            m[a[j]]++;\\n            maxRepeating = max(maxRepeating, m[a[j]]);\\n            //When other characters become greater than k, we move window ahead.\\n            if(j-i+1 - maxRepeating > k){\\n                m[a[i]]--;\\n                i++;\\n            }\\n            maxLen = max(maxLen, j-i+1);\\n        }\\n        return maxLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126159,
                "title": "python-sliding-window-using-dictionary-and-comments",
                "content": "```\\nclass Solution(object):\\n    def characterReplacement(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \\n        Given a string s that consists of only uppercase English letters,\\n        you can perform at most k operations on that string.\\n\\n        In one operation, you can choose any character of the string and\\n        change it to any other uppercase English character.\\n\\n        Find the length of the longest sub-string containing all repeating\\n        letters you can get after performing the above operations.\\n        \"\"\"\\n        # Maximum number of repeated characters.\\n        max_repeats = 0\\n        \\n        # Use two pointers `start` and `end` to track a sliding/caterpillar window.\\n        start = 0\\n        \\n        # Track how many times you see a character in the current window.\\n        char_freq = {}\\n\\t\\t\\n\\t\\t# Length of longest valid substring in the current window.\\n        max_length = 0\\n\\t\\t\\n        # Expand the window to the right until the end of the string.\\n        for end in range(len(s)):\\n            current_char = s[end]\\n            \\n            # Update `char_freq` by incrementing `current_char` count.\\n            char_freq[current_char] = char_freq.get(current_char, 0) + 1\\n            \\n            # If `current_char` now has the most repeating characters,\\n            # update `max_repeats`.\\n            max_repeats = max(max_repeats, char_freq[current_char])\\n            \\n            current_length = end - start + 1\\n            \\n            # If the number of replacements in order to maximize repeats\\n            # is less than or equal to `k` operations, update `max_length`.\\n            if current_length - max_repeats <= k:\\n                max_length = max(max_length, current_length)\\n            \\n            # Otherwise, slide the window by moving the `start` pointer\\n            # to the right and update `char_freq` to reflect the new window.  \\n            else:\\n                char_freq[s[start]] -= 1\\n                start += 1\\n                \\n        return max_length\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def characterReplacement(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \\n        Given a string s that consists of only uppercase English letters,\\n        you can perform at most k operations on that string.\\n\\n        In one operation, you can choose any character of the string and\\n        change it to any other uppercase English character.\\n\\n        Find the length of the longest sub-string containing all repeating\\n        letters you can get after performing the above operations.\\n        \"\"\"\\n        # Maximum number of repeated characters.\\n        max_repeats = 0\\n        \\n        # Use two pointers `start` and `end` to track a sliding/caterpillar window.\\n        start = 0\\n        \\n        # Track how many times you see a character in the current window.\\n        char_freq = {}\\n\\t\\t\\n\\t\\t# Length of longest valid substring in the current window.\\n        max_length = 0\\n\\t\\t\\n        # Expand the window to the right until the end of the string.\\n        for end in range(len(s)):\\n            current_char = s[end]\\n            \\n            # Update `char_freq` by incrementing `current_char` count.\\n            char_freq[current_char] = char_freq.get(current_char, 0) + 1\\n            \\n            # If `current_char` now has the most repeating characters,\\n            # update `max_repeats`.\\n            max_repeats = max(max_repeats, char_freq[current_char])\\n            \\n            current_length = end - start + 1\\n            \\n            # If the number of replacements in order to maximize repeats\\n            # is less than or equal to `k` operations, update `max_length`.\\n            if current_length - max_repeats <= k:\\n                max_length = max(max_length, current_length)\\n            \\n            # Otherwise, slide the window by moving the `start` pointer\\n            # to the right and update `char_freq` to reflect the new window.  \\n            else:\\n                char_freq[s[start]] -= 1\\n                start += 1\\n                \\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865723,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        int length = s.length();\\n        \\n        if (length == 0) {\\n            return 0;\\n        }\\n        \\n        int[] charToCountMap = new int[26];\\n        int i = 0;\\n        int j = 0;\\n        int maxCount = 0;\\n        \\n        while (i < length) {\\n\\t\\t    // Increase the count of the alphabet encountered at i\\n            int count = ++charToCountMap[s.charAt(i)-\\'A\\'];\\n            \\n\\t\\t\\t// If the count of this alphabet is greater than the maxCount, then update\\n\\t\\t\\t// otherwise remove this alphabet\\n            if (count > maxCount) {\\n                maxCount = count;\\n            } else {\\n                k--;\\n            }\\n            \\n\\t\\t\\t// shorten the window by increasing j\\n\\t\\t\\t// also reduce the count of alphabet at j\\n            if (k < 0) {\\n                --charToCountMap[s.charAt(j)-\\'A\\'];\\n                k++;\\n                j++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return i-j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        int length = s.length();\\n        \\n        if (length == 0) {\\n            return 0;\\n        }\\n        \\n        int[] charToCountMap = new int[26];\\n        int i = 0;\\n        int j = 0;\\n        int maxCount = 0;\\n        \\n        while (i < length) {\\n\\t\\t    // Increase the count of the alphabet encountered at i\\n            int count = ++charToCountMap[s.charAt(i)-\\'A\\'];\\n            \\n\\t\\t\\t// If the count of this alphabet is greater than the maxCount, then update\\n\\t\\t\\t// otherwise remove this alphabet\\n            if (count > maxCount) {\\n                maxCount = count;\\n            } else {\\n                k--;\\n            }\\n            \\n\\t\\t\\t// shorten the window by increasing j\\n\\t\\t\\t// also reduce the count of alphabet at j\\n            if (k < 0) {\\n                --charToCountMap[s.charAt(j)-\\'A\\'];\\n                k++;\\n                j++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return i-j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066495,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        unordered_map<char, int> mp;\\n        int ans=0, j=0, mx=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            mp[s[i]]++;\\n            mx=max(mx, mp[s[i]]);\\n            if(i-j+1-mx > k)\\n            {\\n                mp[s[j]]--;\\n                j++;\\n            }\\n            ans=max(ans, i-j+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        unordered_map<char, int> mp;\\n        int ans=0, j=0, mx=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            mp[s[i]]++;\\n            mx=max(mx, mp[s[i]]);\\n            if(i-j+1-mx > k)\\n            {\\n                mp[s[j]]--;\\n                j++;\\n            }\\n            ans=max(ans, i-j+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195048,
                "title": "confused-read-this-simple-c-sliding-window-logic-with-example",
                "content": "**The article is big, but its simple to understand and won\\'t require 2nd read.**\\nBefore moving to solution, let rule out cases that might create problem.\\n-> couting the max freq of character is not a way to go, as they might be scattered.\\n**Example**\\n``` AABCBCBCAA  and k = 3```\\nhere A is occuring 4 times but since it is scattered we cannot use it. We can either get \\n```AAAAACBCAA which result in ans as 5``` or\\n``` AABCBAAAAA that too will result in ans 5 ``` but\\nanswer is if we replace C with B **or** B with C.\\n```AABBBBBBAA which will give ans = 6```\\n\\n**Logic**\\n1. Use a sliding window to keep track of current working set.\\n2. keep a frequency array that will store the count of each character within our sliding window.\\n3. use a variable to store the character with highest frequency within our sliding window.\\n4. So let say if our sliding window size is 10, a character maxi frequency count is 6, means we have 4 character that need to be replaced.\\n5. Now we can use this difference(4) to check if it is greater than or less than k. \\n6. if k is above this, than our sliding window is good to go, and we will keep on expanding it from right end.\\n7. if k is below this difference, meaning we have overshoot the requirement and we will shrink our window from left end.\\n8. Keep a variable to store the maximum window size ever reached, that will be our answer.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n      \\n        \\n        /* Store the occurence of each charater in our window */\\n        vector<int> frequency(26,0);    \\n        \\n        \\n        int end = 0;     // End pointer of our window\\n        int start = 0;   // Start pointer of our window\\n        \\n        \\n        /* Store max frequency within window */\\n        int max_freq_within_window = 0; \\n        \\n        int ans = 0;  // our final answer to return\\n        \\n        while(end < s.length())\\n        {\\n            frequency[s[end] - \\'A\\']++;  // updating frequency of character\\n            \\n            max_freq_within_window = max(max_freq_within_window, frequency[s[end] - \\'A\\']);\\n            \\n            /* if our window size - max_freq > k \\n            *    meaning -> we change more character then needed, we will shrink our window.\\n            *    See example below.\\n            *     \\n            *    end - start + 1 = current window size.\\n            */\\n            \\n            while(end - start + 1 - max_freq_within_window > k)\\n            {\\n                ans = max(ans, end-start);\\n                frequency[s[start] - \\'A\\']--;\\n                start++; // reducing window.\\n                \\n                /* since we removed one element from window, we should update our \\n                   max_freq_within_window variable too.\\n                */\\n                max_freq_within_window = *max_element(frequency.begin(),frequency.end());\\n            }\\n            end++;\\n        }\\n        ans = max(ans, end-start);\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\nExample:\\n```AABCBCC```\\n```k = 2```\\n\\nat end = 3, start = 0,\\nCount of A = 2\\nCount of B = 1\\nCount of C = 1\\nsize of window = end - start + 1 = 3 - 0 + 1 = 4\\nmax_freq_within_window = 2 (frequency of A)\\ndifference = 4-2 = 2 \\nsince it is not greater than k, we are okay with it and do not reduce our window size.\\n\\nnow at end = 4, start = 0\\nCount of A = 2\\nCount of B = 2\\nCount of C = 1\\nsize of window = end - start + 1 = 4 - 0 + 1 = 5\\nmax_freq_within_window = 2 (frequency of A or frequency of B)\\ndifference = 5-2 = 3\\n\\nSince this time difference if more than k, we need to shrink our window from start.\\nso\\n-> store the current valid window size in ans variable.\\n-> reduce the frequency of character present at start location.\\n-> increment start\\n-> update max_freq_within_window to keep count valid all the time.\\n-> repeat these steps till our window becomes valid again ( i.e difference <= k)\\n\\nrepeat the process till we reach end of array, return ans, as this contain the maximum size a window reached at any point.\\nthe  last ```ans = max(ans, end-start);```  after the loop is to check the cases if our correct window is present at the end and we might not have went into inside while loop.\\n\\n\\nTime Complexity ```O(26n)```\\n\\nNow, further modification: Reading other solution, somehow i came to realize that, using maximum frequeucy will also work\\n- we do not need to find maximum frequency within window, we can use the maximum frequency found so far. The reason being: The window size obtained by using the maximum frequency will always be greater than or equal to any other window size, and since we are returning max window size as answer, we can can use maximum frequency obtained so far in our loop.\\n\\nExample :\\n```AABCDEC ```\\n```k = 2```\\n\\nat end = 3, start = 0,\\nCount of A = 2\\nCount of B = 1\\nCount of C = 1\\nsize of window = end - start + 1 = 3 - 0 + 1 = 4\\nmax_freq = 2 (frequency of A)\\ndifference = 4-2 = 2 \\nsince it is not greater than k, we are okay with it and do not reduce our window size.\\n\\nnow at end = 4, start = 0\\nCount of A = 2\\nCount of B = 1\\nCount of C = 1\\nCount of D = 1\\nsize of window = end - start + 1 = 4 - 0 + 1 = 5\\nmax_freq= 2 (frequency of A)\\ndifference = 5-2 = 3\\n\\nSince this time difference if more than k, we need to shrink our window from start.\\nso\\n-> store the current valid window size in ans variable.\\n-> reduce the frequency of character present at start location.\\n-> increment start. (start = 1)\\n\\n```AABCDEC```\\nnow at end = 5 start = 1,\\nCount of A = 1\\nCount of B = 1\\nCount of C = 1\\nCount of D = 1\\nCount of E = 1\\nsize of window = end - start + 1 = 5 - 1 + 1 = 5\\nmax_freq= 2  = max(frequency of C,max_freq)\\ndifference = 5-2 = 3\\n\\nSince this time difference if more than k, we need to shrink our window from start.\\nso\\n-> store the current valid window size in ans variable. (end - start) = (5-1) = 4 (which was already found)\\n-> reduce the frequency of character present at start location.\\n-> increment start. (start = 2)\\n\\n**Note**\\nThis time we are not updating max_freq, because reducing max_freq value cannot give us better result, thus saving our O(26) time of finding maximum amoung currently present frequency count. Also there is no while loop, as this will only run when we are at k+1, and reducing once will be sufficient. \\n\\nThe code will go like this:\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n      \\n        \\n        /* Store the occurence of each charater in our window */\\n        vector<int> frequency(26,0);    \\n        \\n        \\n        int end = 0;     // Start pointer of our window\\n        int start = 0;   // End pointer of our window\\n        \\n        \\n        /* Store max frequency overall */\\n        int max_freq = 0; \\n        \\n        int ans = 0;\\n        \\n        while(end < s.length())\\n        {\\n            frequency[s[end] - \\'A\\']++;  // updating frequency of character\\n            \\n            max_freq = max(max_freq, frequency[s[end] - \\'A\\']);\\n            \\n            /* if our window size - max_freq > k \\n            *    meaning -> we change more character then needed, we will shrink our window.\\n            *     \\n            *    end - start + 1 = current window size.\\n            */\\n            \\n\\t\\t\\t/* The while loop is removed as this will run only once */\\n            if(end - start + 1 - max_freq > k)\\n            {\\n                ans = max(ans, end-start);\\n                frequency[s[start] - \\'A\\']--;\\n                start++; // reducing window.\\n            }\\n            end++;\\n        }\\n        \\n        ans = max(ans, end-start);\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "``` AABCBCBCAA  and k = 3```\n```AAAAACBCAA which result in ans as 5```\n``` AABCBAAAAA that too will result in ans 5 ```\n```AABBBBBBAA which will give ans = 6```\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n      \\n        \\n        /* Store the occurence of each charater in our window */\\n        vector<int> frequency(26,0);    \\n        \\n        \\n        int end = 0;     // End pointer of our window\\n        int start = 0;   // Start pointer of our window\\n        \\n        \\n        /* Store max frequency within window */\\n        int max_freq_within_window = 0; \\n        \\n        int ans = 0;  // our final answer to return\\n        \\n        while(end < s.length())\\n        {\\n            frequency[s[end] - \\'A\\']++;  // updating frequency of character\\n            \\n            max_freq_within_window = max(max_freq_within_window, frequency[s[end] - \\'A\\']);\\n            \\n            /* if our window size - max_freq > k \\n            *    meaning -> we change more character then needed, we will shrink our window.\\n            *    See example below.\\n            *     \\n            *    end - start + 1 = current window size.\\n            */\\n            \\n            while(end - start + 1 - max_freq_within_window > k)\\n            {\\n                ans = max(ans, end-start);\\n                frequency[s[start] - \\'A\\']--;\\n                start++; // reducing window.\\n                \\n                /* since we removed one element from window, we should update our \\n                   max_freq_within_window variable too.\\n                */\\n                max_freq_within_window = *max_element(frequency.begin(),frequency.end());\\n            }\\n            end++;\\n        }\\n        ans = max(ans, end-start);\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\n```AABCBCC```\n```k = 2```\n```ans = max(ans, end-start);```\n```O(26n)```\n```AABCDEC ```\n```k = 2```\n```AABCDEC```\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n      \\n        \\n        /* Store the occurence of each charater in our window */\\n        vector<int> frequency(26,0);    \\n        \\n        \\n        int end = 0;     // Start pointer of our window\\n        int start = 0;   // End pointer of our window\\n        \\n        \\n        /* Store max frequency overall */\\n        int max_freq = 0; \\n        \\n        int ans = 0;\\n        \\n        while(end < s.length())\\n        {\\n            frequency[s[end] - \\'A\\']++;  // updating frequency of character\\n            \\n            max_freq = max(max_freq, frequency[s[end] - \\'A\\']);\\n            \\n            /* if our window size - max_freq > k \\n            *    meaning -> we change more character then needed, we will shrink our window.\\n            *     \\n            *    end - start + 1 = current window size.\\n            */\\n            \\n\\t\\t\\t/* The while loop is removed as this will run only once */\\n            if(end - start + 1 - max_freq > k)\\n            {\\n                ans = max(ans, end-start);\\n                frequency[s[start] - \\'A\\']--;\\n                start++; // reducing window.\\n            }\\n            end++;\\n        }\\n        \\n        ans = max(ans, end-start);\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699751,
                "title": "c-sliding-window-solution",
                "content": "**Intuition**\\n![image](https://assets.leetcode.com/users/images/a4cabf08-67e9-4658-81db-7ef9dfac37fe_1650525885.9727912.png)\\n\\n**Complexity**\\n- Time: O(n)\\n- Space: O(1). Dictionary has at most 26 characters.\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public int CharacterReplacement(string s, int k) {\\n        \\n        if(s == null || s.Length == 0)\\n            return 0;\\n        \\n        Dictionary<char,int> dic = new Dictionary<char,int>();\\n        \\n        // maxCnt: number of occurrence of the most frequenct character historically\\n        int left = 0, right = 0, cnt = 0, maxCnt = 0, maxlen = 0;\\n               \\n        while(right < s.Length)\\n        {            \\n            char rightChar = s[right];\\n            if(dic.ContainsKey(rightChar))\\n                dic[rightChar]++;\\n            else\\n                dic.Add(rightChar, 1);\\n            right++;    \\n                        \\n            // update maxCnt. Only newly added character (rightChar) could change the maxCnt.\\n            maxCnt = Math.Max(maxCnt, dic[rightChar]);\\n            \\n            // right - left - maxCnt: number of chars in the substring need to be replaced to keep the sliding window valid.\\n            // right - left - maxCnt <= k  --> right - left <= k + maxCnt\\n            // so the size of valid sliding window is determined by maxCnt. It increases only when maxCnt increases.  \\n            if(right - left - maxCnt > k)\\n            {\\n                // Sliding window becomes invalid, we need to move the left boundary.\\n                // This will shrink the current sliding window. But this won\\'t impact the historical maximum sliding window.\\n                // In the next round of loop, maxCnt will updated to explore the next maximum sliding window.\\n                char leftChar = s[left];      \\n                dic[leftChar]--;\\n                left++;\\n            }\\n            \\n            maxlen = Math.Max(maxlen, right - left);   \\n        }\\n        \\n        return maxlen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CharacterReplacement(string s, int k) {\\n        \\n        if(s == null || s.Length == 0)\\n            return 0;\\n        \\n        Dictionary<char,int> dic = new Dictionary<char,int>();\\n        \\n        // maxCnt: number of occurrence of the most frequenct character historically\\n        int left = 0, right = 0, cnt = 0, maxCnt = 0, maxlen = 0;\\n               \\n        while(right < s.Length)\\n        {            \\n            char rightChar = s[right];\\n            if(dic.ContainsKey(rightChar))\\n                dic[rightChar]++;\\n            else\\n                dic.Add(rightChar, 1);\\n            right++;    \\n                        \\n            // update maxCnt. Only newly added character (rightChar) could change the maxCnt.\\n            maxCnt = Math.Max(maxCnt, dic[rightChar]);\\n            \\n            // right - left - maxCnt: number of chars in the substring need to be replaced to keep the sliding window valid.\\n            // right - left - maxCnt <= k  --> right - left <= k + maxCnt\\n            // so the size of valid sliding window is determined by maxCnt. It increases only when maxCnt increases.  \\n            if(right - left - maxCnt > k)\\n            {\\n                // Sliding window becomes invalid, we need to move the left boundary.\\n                // This will shrink the current sliding window. But this won\\'t impact the historical maximum sliding window.\\n                // In the next round of loop, maxCnt will updated to explore the next maximum sliding window.\\n                char leftChar = s[left];      \\n                dic[leftChar]--;\\n                left++;\\n            }\\n            \\n            maxlen = Math.Max(maxlen, right - left);   \\n        }\\n        \\n        return maxlen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91311,
                "title": "sliding-window-java-easy-explanation-15-lines",
                "content": "```\\n/*\\n    The whole idea is that if we have a string of length N out of which M characters are same,\\n    we can replace (N - M) characters to get a continueous string of N characters. \\n    If M <= K. N is the local maximum for this window.\\n    If this length is greater than K. Slide the window.\\n    */\\n    public int characterReplacement(String s, int k) {\\n        int[] charCount = new int[26];\\n        \\n        int left, right, maxCount, maxLen;\\n        left = right = maxCount = maxLen = 0;\\n    \\n        while(right < s.length()){\\n            charCount[s.charAt(right) - 'A']++;\\n            maxCount = Math.max(maxCount, charCount[s.charAt(right) - 'A']);\\n            if(right - left + 1 - maxCount > k) charCount[s.charAt(left++) - 'A']--;\\n            maxLen = Math.max(right++ - left + 1, maxLen);\\n        }\\n        return maxLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    The whole idea is that if we have a string of length N out of which M characters are same,\\n    we can replace (N - M) characters to get a continueous string of N characters. \\n    If M <= K. N is the local maximum for this window.\\n    If this length is greater than K. Slide the window.\\n    */\\n    public int characterReplacement(String s, int k) {\\n        int[] charCount = new int[26];\\n        \\n        int left, right, maxCount, maxLen;\\n        left = right = maxCount = maxLen = 0;\\n    \\n        while(right < s.length()){\\n            charCount[s.charAt(right) - 'A']++;\\n            maxCount = Math.max(maxCount, charCount[s.charAt(right) - 'A']);\\n            if(right - left + 1 - maxCount > k) charCount[s.charAt(left++) - 'A']--;\\n            maxLen = Math.max(right++ - left + 1, maxLen);\\n        }\\n        return maxLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934637,
                "title": "clear-concise-c-solution-sliding-window-better-than-99-time-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int right = 0, left = 0, maxLetter = 0;\\n        int alphabet[26] = {0};\\n        while(right < s.length()) {\\n            alphabet[s[right] - \\'A\\']++;\\n            maxLetter = max(maxLetter, alphabet[s[right] - \\'A\\']);\\n            right++;\\n            \\n            if(right - left - maxLetter > k) {\\n                alphabet[s[left] - \\'A\\']--;\\n                left++;\\n            }\\n        }\\n        return right - left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int right = 0, left = 0, maxLetter = 0;\\n        int alphabet[26] = {0};\\n        while(right < s.length()) {\\n            alphabet[s[right] - \\'A\\']++;\\n            maxLetter = max(maxLetter, alphabet[s[right] - \\'A\\']);\\n            right++;\\n            \\n            if(right - left - maxLetter > k) {\\n                alphabet[s[left] - \\'A\\']--;\\n                left++;\\n            }\\n        }\\n        return right - left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 370281,
                "title": "javascript-sliding-window-solution-with-comments",
                "content": "```\\nvar characterReplacement = function(s, k) {\\n    const dict = {};\\n    let start = 0;\\n    let numRepeatingChar = 0;\\n    let longestSubstr = 0;\\n    \\n    for (let end = 0; end < s.length; end++) {\\n        // Increment count of letter (expanding the window)\\n        dict[s[end]] = dict[s[end]] || 0;\\n        dict[s[end]]++;\\n        \\n        // Number of the most frequent letter in the window\\n        numRepeatingChar = Math.max(numRepeatingChar, dict[s[end]]);\\n        \\n        // Window length - number of most frequent letter gives us\\n        // number of letters that need to be replaced. If that\\'s\\n        // greater than k, we need to shrink the window\\n        if ((end - start + 1) - numRepeatingChar > k) {\\n            dict[s[start]]--;\\n            start++;\\n        }\\n        \\n        // See if the current window is longer than the current max\\n        longestSubstr = Math.max(longestSubstr, (end - start + 1));\\n    }\\n    return longestSubstr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar characterReplacement = function(s, k) {\\n    const dict = {};\\n    let start = 0;\\n    let numRepeatingChar = 0;\\n    let longestSubstr = 0;\\n    \\n    for (let end = 0; end < s.length; end++) {\\n        // Increment count of letter (expanding the window)\\n        dict[s[end]] = dict[s[end]] || 0;\\n        dict[s[end]]++;\\n        \\n        // Number of the most frequent letter in the window\\n        numRepeatingChar = Math.max(numRepeatingChar, dict[s[end]]);\\n        \\n        // Window length - number of most frequent letter gives us\\n        // number of letters that need to be replaced. If that\\'s\\n        // greater than k, we need to shrink the window\\n        if ((end - start + 1) - numRepeatingChar > k) {\\n            dict[s[start]]--;\\n            start++;\\n        }\\n        \\n        // See if the current window is longer than the current max\\n        longestSubstr = Math.max(longestSubstr, (end - start + 1));\\n    }\\n    return longestSubstr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91314,
                "title": "binary-search-slower-but-still-interesting",
                "content": "Unlike most brilliant existing linear solutions, I solve this problem by a slower approach using binary search.\\n\\nWhy binary search? If we can convert a substring of length `x` into a valid one (a string with all unique letters) using no more than `k` replacements, then it is clear that we can also convert a substring of length no more than `x` into a valid one. Thus, if we know how to answer the following **decision** problem efficiently, we can use binary search to guess the final answer.\\n\\n**The decision problem:**\\nIs there a substring of length `x` such that we can make it consist of some unique letter with no more than `k` replacements?\\n\\nThe solution to this question is simple. We enumerate all substring of length `x`. For each substring, we denote the frequency of the most frequent letters in it as `mode`. Then, if `x - mode <= k`, the answer is **yes**. If `x - mode > k` holds for all substrings of length `x`, the answer is **no**. This process can be done via a sliding-window in `O(26 * n) = O(n)` time.\\n\\nTherefore, the total runtime is `O(n log n)`.\\n\\n```Java\\nprivate boolean ok(char[] ch, int k, int len) {\\n\\tint[] cnt = new int[26];\\n\\tfor (int i = 0; i < ch.length; i++) {\\n\\t\\tif (i >= len) cnt[ch[i - len] - 'A']--;\\n\\t\\tcnt[ch[i] - 'A']++;\\n\\t\\tif (i >= len - 1) {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\tfor (int j : cnt) max = Math.max(max, j);\\n\\t\\t\\tif (len - max <= k) return true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n\\npublic int characterReplacement(String s, int k) {\\n\\tif (s.length() == 0 || k >= s.length() - 1) return s.length();\\n\\tint left = 1, right = s.length() + 1;\\n\\tchar[] ch = s.toCharArray();\\n\\twhile (left + 1 < right) {\\n\\t\\tint mid = (left + right) / 2;\\n\\t\\tif (ok(ch, k, mid)) left = mid;\\n\\t\\telse right = mid;\\n\\t}\\n\\treturn left;\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nprivate boolean ok(char[] ch, int k, int len) {\\n\\tint[] cnt = new int[26];\\n\\tfor (int i = 0; i < ch.length; i++) {\\n\\t\\tif (i >= len) cnt[ch[i - len] - 'A']--;\\n\\t\\tcnt[ch[i] - 'A']++;\\n\\t\\tif (i >= len - 1) {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\tfor (int j : cnt) max = Math.max(max, j);\\n\\t\\t\\tif (len - max <= k) return true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n\\npublic int characterReplacement(String s, int k) {\\n\\tif (s.length() == 0 || k >= s.length() - 1) return s.length();\\n\\tint left = 1, right = s.length() + 1;\\n\\tchar[] ch = s.toCharArray();\\n\\twhile (left + 1 < right) {\\n\\t\\tint mid = (left + right) / 2;\\n\\t\\tif (ok(ch, k, mid)) left = mid;\\n\\t\\telse right = mid;\\n\\t}\\n\\treturn left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218400,
                "title": "java-0ms-beat",
                "content": "# Code\\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n                int[] arr = new int[26];\\n        int largestCount = 0, start = 0, maxlen = 0;\\n        for(int end = 0; end < s.length(); end ++){\\n            arr[s.charAt(end) - \\'A\\']++;\\n            // largestCount = unique character in the current window...\\n            largestCount = Math.max(largestCount, arr[s.charAt(end) - \\'A\\']);\\n            if(end - start + 1 - largestCount > k){ \\n                arr[s.charAt(start) - \\'A\\']--;\\n                start ++;\\n            }\\n            // maxlen = maximum length of repeating character & end - start + 1 = size of the current window...\\n            maxlen = Math.max(maxlen, end - start + 1);\\n        }\\n        return maxlen;\\n    }\\n}\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/51c5d06c-3d13-45c2-ba34-30a776403d2e_1677074362.401763.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n                int[] arr = new int[26];\\n        int largestCount = 0, start = 0, maxlen = 0;\\n        for(int end = 0; end < s.length(); end ++){\\n            arr[s.charAt(end) - \\'A\\']++;\\n            // largestCount = unique character in the current window...\\n            largestCount = Math.max(largestCount, arr[s.charAt(end) - \\'A\\']);\\n            if(end - start + 1 - largestCount > k){ \\n                arr[s.charAt(start) - \\'A\\']--;\\n                start ++;\\n            }\\n            // maxlen = maximum length of repeating character & end - start + 1 = size of the current window...\\n            maxlen = Math.max(maxlen, end - start + 1);\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662411,
                "title": "java-easy-uderstanding-sliding-window-hash-map-with-explanation",
                "content": "To crack this problem, we need to understand that **k operations are applicable if the current window size minus the frequency of the most frequent character is less or equal to k** :\\n```\\nwindowSize - mostFreqCharacter <= k\\n```\\n\\nHashMap is a good approach to record the highest frequency character in the current window.\\n```\\n    public int characterReplacement(String s, int k) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        \\n        int left = 0, right = 0, maxL = 0;\\n        int mostFreq = 0;\\n        \\n        while(right < s.length()) {\\n            char c = s.charAt(right);\\n            \\n            // Store each character along with its frequency\\n            // and get the most freq char in the current window\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n            mostFreq = Math.max(map.get(c), mostFreq);\\n            \\n            if(right - left + 1 - mostFreq <= k) {\\n                maxL = Math.max(maxL, right - left + 1);\\n            }\\n            else {\\n                // Move the left pointer to the next charater\\n                // and update its frequency in map\\n                map.put(s.charAt(left), map.get(s.charAt(left)) - 1);\\n                left++;\\n            }\\n            \\n            right++;\\n        }\\n        \\n        return maxL;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nwindowSize - mostFreqCharacter <= k\\n```\n```\\n    public int characterReplacement(String s, int k) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        \\n        int left = 0, right = 0, maxL = 0;\\n        int mostFreq = 0;\\n        \\n        while(right < s.length()) {\\n            char c = s.charAt(right);\\n            \\n            // Store each character along with its frequency\\n            // and get the most freq char in the current window\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n            mostFreq = Math.max(map.get(c), mostFreq);\\n            \\n            if(right - left + 1 - mostFreq <= k) {\\n                maxL = Math.max(maxL, right - left + 1);\\n            }\\n            else {\\n                // Move the left pointer to the next charater\\n                // and update its frequency in map\\n                map.put(s.charAt(left), map.get(s.charAt(left)) - 1);\\n                left++;\\n            }\\n            \\n            right++;\\n        }\\n        \\n        return maxL;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2565757,
                "title": "java-easy-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        if(s.length()==1) return 1;\\n        int[] array=new int[26];\\n        int start=0;\\n        int maxCount=0;\\n        int ans=0;\\n        for(int end=0;end<s.length();end++){\\n            array[s.charAt(end)-\\'A\\']++;\\n            maxCount=Math.max(array[s.charAt(end)-\\'A\\'],maxCount);\\n            if((end-start+1)-maxCount>k){\\n                array[s.charAt(start)-\\'A\\']--;\\n                start++;\\n            }\\n            ans=Math.max(ans,end-start+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        if(s.length()==1) return 1;\\n        int[] array=new int[26];\\n        int start=0;\\n        int maxCount=0;\\n        int ans=0;\\n        for(int end=0;end<s.length();end++){\\n            array[s.charAt(end)-\\'A\\']++;\\n            maxCount=Math.max(array[s.charAt(end)-\\'A\\'],maxCount);\\n            if((end-start+1)-maxCount>k){\\n                array[s.charAt(start)-\\'A\\']--;\\n                start++;\\n            }\\n            ans=Math.max(ans,end-start+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035835,
                "title": "6-ms-simple-java-solution-classic-sliding-window-technique-simple-explanation",
                "content": "CODE:\\n```\\npublic int characterReplacement(String s, int k){\\n        int left=0;\\n        int freq[] = new int[26];\\n        int res=0;\\n        for(int right=0;right<s.length();right++){\\n            char c = s.charAt(right);\\n            freq[c-\\'A\\']++;\\n            int maxf=0;\\n            for(int i=0;i<26;i++){\\n                if (freq[i]>maxf) maxf=freq[i];\\n            }\\n            \\n            if((right-left+1)-maxf > k){\\n                char starting=s.charAt(left);\\n                freq[starting-\\'A\\']--;\\n                left++;\\n            }\\n            res=Math.max(res,right-left+1);\\n            \\n        }\\n        return res;\\n    }\\n\\n```\\n\\n\\nLogic : \\na) Sliding Window : left and right pointer will be at the same position\\n\\t\\t\\t\\t\\t\\t\\t\\tin favourable condition we increase the size of window i,e right++\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\twe decrease the size of window i,e left++\\n\\tb) The condition here is: No. of Replacements should be less than or equal to k , per window\\n\\t\\tNo. of Replacements can be found by \\n\\t\\tlength of window - maximum frequency of the character in the window\\n\\ti,e( (right- left +1) - maxf )  this value should be less than or equal to k\\n\\tif so we increase right [increasing size of window]\\n\\telse we increase left  [decreaseing size of window]\\n\\tc) simple by hand array hashing is used to maintain the frequency of elements \\n\\t\\n\\tTime Complexity : O( n *26) which is O(n)\\n\\tSpace Complexity is O(1) , as only constant space of 26 integer bytes is needed\\n\\t\\n\\t",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\npublic int characterReplacement(String s, int k){\\n        int left=0;\\n        int freq[] = new int[26];\\n        int res=0;\\n        for(int right=0;right<s.length();right++){\\n            char c = s.charAt(right);\\n            freq[c-\\'A\\']++;\\n            int maxf=0;\\n            for(int i=0;i<26;i++){\\n                if (freq[i]>maxf) maxf=freq[i];\\n            }\\n            \\n            if((right-left+1)-maxf > k){\\n                char starting=s.charAt(left);\\n                freq[starting-\\'A\\']--;\\n                left++;\\n            }\\n            res=Math.max(res,right-left+1);\\n            \\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1843197,
                "title": "go-sliding-window-o-n-time",
                "content": "Posting this, because I had a hard time figuering it out.\\nWhat really wouldn\\'t get into my head, was, that everytime the window would extend to the right (pushing the end one index further), \\nonly the new char needs to be checked for exceeding the maxiumRepetition count. \\nOnly this recent char was every changed, making it far easier to track the char having the highest repetition count\\ninside of the window. \\n```\\nfunc characterReplacement(s string, k int) int {\\n    m := map[byte]int{}\\n    maxLen := 0\\n    maxRepeat := byte(0)\\n    start := 0\\n    end := 0\\n    \\n    // first iterate over s by incremeting end (and sometimes start) \\n    for end < len(s) {\\n        // store/increment count for recently added char\\n        char := s[end]\\n        m[char]++\\n        count := m[char]\\n        \\n        // since only the char just added could have changed the status quo of the char with the highest repetition count\\n        // we just need to check if the recently added char has a greater repetition count, than the previous one\\n        if maxRepeat == 0 || m[maxRepeat] < count {\\n            maxRepeat = char\\n        }\\n\\n        // if the window size minus the dominant character becomes bigger than k (meaning that we cannot swap all different chars)\\n        // start shifting the window by increasing start index (and decrementing counter for char)\\n        if end-start + 1 - m[maxRepeat] > k {\\n            m[s[start]]--\\n            start++\\n        }\\n        \\n        // monitor if a new maxLen was reached\\n        if maxLen < end-start +1 {\\n            maxLen = end-start+1\\n        }\\n        end++ // increment end for next iteration\\n    }\\n\\n    return maxLen\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sliding Window"
                ],
                "code": "```\\nfunc characterReplacement(s string, k int) int {\\n    m := map[byte]int{}\\n    maxLen := 0\\n    maxRepeat := byte(0)\\n    start := 0\\n    end := 0\\n    \\n    // first iterate over s by incremeting end (and sometimes start) \\n    for end < len(s) {\\n        // store/increment count for recently added char\\n        char := s[end]\\n        m[char]++\\n        count := m[char]\\n        \\n        // since only the char just added could have changed the status quo of the char with the highest repetition count\\n        // we just need to check if the recently added char has a greater repetition count, than the previous one\\n        if maxRepeat == 0 || m[maxRepeat] < count {\\n            maxRepeat = char\\n        }\\n\\n        // if the window size minus the dominant character becomes bigger than k (meaning that we cannot swap all different chars)\\n        // start shifting the window by increasing start index (and decrementing counter for char)\\n        if end-start + 1 - m[maxRepeat] > k {\\n            m[s[start]]--\\n            start++\\n        }\\n        \\n        // monitor if a new maxLen was reached\\n        if maxLen < end-start +1 {\\n            maxLen = end-start+1\\n        }\\n        end++ // increment end for next iteration\\n    }\\n\\n    return maxLen\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1609669,
                "title": "javascript",
                "content": "\\n**[1. Brute Force]**\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar characterReplacement = function(s, k) {\\n    const units = new Set(s.split(\\'\\'));\\n    let maxLength = 0;\\n    \\n    function findMaxRepeatingSubstring (ch, k) {\\n        let left = 0, right = 0, max = 0;\\n        \\n        for (right = 0; right < s.length; right++) {\\n            if (s[right] !== ch) k--;\\n            \\n            while (k < 0 && left < right) {\\n                if (s[left] !== ch) k++;\\n                left++;\\n            }\\n            \\n            max = Math.max(right-left+1, max);\\n        }\\n        return max;\\n    }\\n    \\n    for (const char of units) {\\n        maxLength = Math.max(findMaxRepeatingSubstring(char, k), maxLength)\\n    }\\n    \\n    return maxLength;\\n};\\n```\\n\\n**[2. Sliding Window]**\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar characterReplacement = function(s, k) {\\n    let left = 0, right = 0, max = 0, freqMap = {}, freqMax = 0;\\n    \\n    for (right = 0; right < s.length; right++) {\\n        freqMap[s[right]] = freqMap[s[right]] + 1 || 1;\\n        freqMax = Math.max(freqMap[s[right]], freqMax);\\n        \\n        while (right - left + 1 - freqMax > k) {\\n            freqMap[s[left]] -= 1;\\n            left++;\\n        }\\n        max = Math.max(right-left+1, max)\\n    }\\n    return max;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar characterReplacement = function(s, k) {\\n    const units = new Set(s.split(\\'\\'));\\n    let maxLength = 0;\\n    \\n    function findMaxRepeatingSubstring (ch, k) {\\n        let left = 0, right = 0, max = 0;\\n        \\n        for (right = 0; right < s.length; right++) {\\n            if (s[right] !== ch) k--;\\n            \\n            while (k < 0 && left < right) {\\n                if (s[left] !== ch) k++;\\n                left++;\\n            }\\n            \\n            max = Math.max(right-left+1, max);\\n        }\\n        return max;\\n    }\\n    \\n    for (const char of units) {\\n        maxLength = Math.max(findMaxRepeatingSubstring(char, k), maxLength)\\n    }\\n    \\n    return maxLength;\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar characterReplacement = function(s, k) {\\n    let left = 0, right = 0, max = 0, freqMap = {}, freqMax = 0;\\n    \\n    for (right = 0; right < s.length; right++) {\\n        freqMap[s[right]] = freqMap[s[right]] + 1 || 1;\\n        freqMax = Math.max(freqMap[s[right]], freqMax);\\n        \\n        while (right - left + 1 - freqMax > k) {\\n            freqMap[s[left]] -= 1;\\n            left++;\\n        }\\n        max = Math.max(right-left+1, max)\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 971458,
                "title": "o-n-sliding-window-simple-with-explanation-kotlin-solution",
                "content": "- The idea here is to find a window that satisfies the condition -\\n\\t *count of most repeatable character + no. of allowed replacements <= length of the window*\\n- Since the no. of allowed replacements is fixed, then the window size is directly proportional to the count of the most repeating character.\\n- Initially the window keeps growing from the end, until all the allowed replacements are added up in the window until it reaches the max size. \\n- The moment the condition is not satisfied (*i.e., count of most repeatable character + no. of allowed replacements > size of the window*), then we need to slide the window (not shrink) to the right and decrement the frequency of the character that is moved out of the window. \\n- If the next character coming in is the most repeating character, then the window grows or else it simply slides again.\\n\\n```\\nclass Solution {\\n    fun characterReplacement(s: String, k: Int): Int {\\n        var mostFreqCharCount = 0; var start = 0; var max=0\\n        val map = mutableMapOf<Char, Int>()\\n        \\n        for(end in 0 until s.length){\\n            map.put(s[end], map.getOrDefault(s[end], 0) + 1)\\n            mostFreqCharCount = Math.max(map.get(s[end])!!, mostFreqCharCount)\\n            if(end - start + 1 > mostFreqCharCount + k){\\n                map.put(s[start], map.get(s[start])!! - 1)\\n                start++                \\n            }\\n            max = Math.max(max, end - start + 1)\\n        }\\n        return max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    fun characterReplacement(s: String, k: Int): Int {\\n        var mostFreqCharCount = 0; var start = 0; var max=0\\n        val map = mutableMapOf<Char, Int>()\\n        \\n        for(end in 0 until s.length){\\n            map.put(s[end], map.getOrDefault(s[end], 0) + 1)\\n            mostFreqCharCount = Math.max(map.get(s[end])!!, mostFreqCharCount)\\n            if(end - start + 1 > mostFreqCharCount + k){\\n                map.put(s[start], map.get(s[start])!! - 1)\\n                start++                \\n            }\\n            max = Math.max(max, end - start + 1)\\n        }\\n        return max\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671813,
                "title": "javascript-2-sliding-window-approaches",
                "content": "## Solution 1\\n#### Time Complexity: O(26N)\\n```javascript\\nvar characterReplacement = function(s, k) {\\n    const unique = new Set(s.split(\\'\\'));\\n    let maxLen = 0;\\n    \\n    function longestRepeat(char, c) {\\n        let left = 0, right = 0;\\n        \\n        for(right = 0; right < s.length; right++) {\\n            if(s[right] !== char) c--;\\n            if(c < 0) {\\n                if(s[left] !== char) c++;\\n                left++\\n            }\\n        }\\n        return right-left;       \\n    }\\n\\n    for(let char of unique) {\\n        maxLen = Math.max(longestRepeat(char, k), maxLen);\\n    }\\n  \\n    return maxLen;\\n};\\n```\\n\\n## Solution 2\\n#### Time Complexity: O(N)\\n```javascript\\nvar characterReplacement = function(s, k) {\\n    let left = 0, right = 0, mostFreq = 0, maxLen = 0;\\n    let freqMap = {};\\n    \\n    for(right = 0; right < s.length; right++) {\\n        freqMap[s[right]] = freqMap[s[right]] + 1 || 1;\\n        mostFreq = Math.max(freqMap[s[right]], mostFreq);\\n        \\n        while(right-left+1 - mostFreq > k) {\\n            freqMap[s[left]] -= 1;\\n            left++;\\n        }\\n        maxLen = Math.max(right-left+1, maxLen);\\n    }\\n    return maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```javascript\\nvar characterReplacement = function(s, k) {\\n    const unique = new Set(s.split(\\'\\'));\\n    let maxLen = 0;\\n    \\n    function longestRepeat(char, c) {\\n        let left = 0, right = 0;\\n        \\n        for(right = 0; right < s.length; right++) {\\n            if(s[right] !== char) c--;\\n            if(c < 0) {\\n                if(s[left] !== char) c++;\\n                left++\\n            }\\n        }\\n        return right-left;       \\n    }\\n\\n    for(let char of unique) {\\n        maxLen = Math.max(longestRepeat(char, k), maxLen);\\n    }\\n  \\n    return maxLen;\\n};\\n```\n```javascript\\nvar characterReplacement = function(s, k) {\\n    let left = 0, right = 0, mostFreq = 0, maxLen = 0;\\n    let freqMap = {};\\n    \\n    for(right = 0; right < s.length; right++) {\\n        freqMap[s[right]] = freqMap[s[right]] + 1 || 1;\\n        mostFreq = Math.max(freqMap[s[right]], mostFreq);\\n        \\n        while(right-left+1 - mostFreq > k) {\\n            freqMap[s[left]] -= 1;\\n            left++;\\n        }\\n        maxLen = Math.max(right-left+1, maxLen);\\n    }\\n    return maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 653597,
                "title": "c-sliding-window-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        \\n        int n = s.length();\\n        unordered_map<char, int>mp;\\n        int mx = 0, i = 0, j = 0, res = 0;\\n        \\n        for (i = 0; i < n; i++) {\\n            mx = max(mx, ++mp[s[i]]);\\n            while (j < n && i-j-mx+1 > k) {\\n                mp[s[j]]--;\\n                j++;\\n            }\\n            res = max(res, i-j+1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        \\n        int n = s.length();\\n        unordered_map<char, int>mp;\\n        int mx = 0, i = 0, j = 0, res = 0;\\n        \\n        for (i = 0; i < n; i++) {\\n            mx = max(mx, ++mp[s[i]]);\\n            while (j < n && i-j-mx+1 > k) {\\n                mp[s[j]]--;\\n                j++;\\n            }\\n            res = max(res, i-j+1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619135,
                "title": "swift-solution-o-n-sliding-window-dictionary",
                "content": "The key to sliding window here is to \\n* Keep track of the character with highest count in window\\n* EXPAND WINDOW while windowSize - maxCount is less than k \\n* SHRINK WINDOW while windowSize - maxCount is greater than k \\n--the reason we shrink is because we have too many characters to replace\\n----i.e 6 - 4 =2 so we need to replace two characters, lets say k is 1\\n* Lastly keep track of the maxLength of windowSize.\\n* SIde Note - b/c the window only expands when the maxCount increases there is no need to decrease the maxCount\\n```\\nfunc characterReplacement(_ s: String, _ k: Int) -> Int {\\n        var dict = [Character: Int]()\\n        var maxCount = 0\\n        var maxLength = 0\\n        var start = 0\\n\\n        let sArr = Array(s)\\n        \\n        for end in 0 ..< sArr.count {\\n            dict[sArr[end]] = dict[sArr[end], default: 0] + 1\\n            maxCount = max(maxCount, dict[sArr[end]]!)\\n            while end - start + 1 - maxCount > k {\\n                dict[sArr[start]] = dict[sArr[start]]! - 1\\n                start += 1\\n            }\\n            maxLength = max(maxLength, end - start + 1)\\n        }\\n        return maxLength\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc characterReplacement(_ s: String, _ k: Int) -> Int {\\n        var dict = [Character: Int]()\\n        var maxCount = 0\\n        var maxLength = 0\\n        var start = 0\\n\\n        let sArr = Array(s)\\n        \\n        for end in 0 ..< sArr.count {\\n            dict[sArr[end]] = dict[sArr[end], default: 0] + 1\\n            maxCount = max(maxCount, dict[sArr[end]]!)\\n            while end - start + 1 - maxCount > k {\\n                dict[sArr[start]] = dict[sArr[start]]! - 1\\n                start += 1\\n            }\\n            maxLength = max(maxLength, end - start + 1)\\n        }\\n        return maxLength\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 606986,
                "title": "python-sliding-window-o-n-solution-with-detailed-explanation-and-pseudocode",
                "content": "## Longest repeating character replacement\\n**Pattern**: Sliding Window\\n**Sub-pattern**: Longest subarray with atmost k distinct elements (Variation)\\n**Similar Problem**: [Fruits Into Baskets](https://leetcode.com/problems/fruit-into-baskets/)\\n\\n**Pseudocode**:\\n```\\nFUNCTION CharacterReplacement(Input STRING S, Swaps INT K)\\n\\tIntialize two pointers INT left and INT right\\n\\tInitialize Counter object - type HASHMAP\\n\\tFOR right=0 to LENGTH(STRING S)\\n\\t\\tAdd S[right] to Memory\\n\\t\\t\\n\\t\\tIF (length of window) - (maximum character count in Memory) > Swaps K\\n\\t\\t\\tRemove S[left] from Memory\\n\\t\\t\\tIncrement left\\n\\tRETURN (length of window)\\n\\t\\n\\t\\n\\t\\n```\\n\\n## **Detailed explanation with comments below in Python code**\\n**Python 3:**\\n```\\ndef characterReplacement(self, s, k):\\n\\t\\t# initiating left and right pointer\\n        l = 0\\n        r=-1\\n        # Right pointer initialised to -1 so that if empty string is passed, \\n\\t\\t# it will return r(-1)+1-l(0) at the end which is 0. In short, only for empty string edge case\\n        \\n        # Initialising a Counter object from collections to memory, \\n\\t\\t# this eases adding new element to dict, and in finding most common element in dict\\n        memory = collections.Counter()\\n\\n        # iterating through s, r is the right pointer\\n        for r,v in enumerate(s):\\n          \\t# on each loop, adding s[r] i.e v to the Counter dict \\n            memory[v]+=1\\n\\n            \\'\\'\\'\\n            max_char_count stores the count of the maximum occuring character for eg, \\n            if memory = {\"A\": 2, \"B\": 3, \"C\": 1}, max_char_count has value 3 i.e count of maximum occuring character (i.e, B)\\n            alternatives like max(memory.values()) can also be used\\n            \\'\\'\\'\\n            max_char_count = memory.most_common(1)[0][1]\\n\\n            \\'\\'\\'\\n            Note that r+1-l gives the length of the current window. i.e if r=3, l=0, \\n\\t\\t\\tthen length of array under consideration is r+1(4)-l(0) = 4\\n\\n\\t\\t\\tThe key to this problem is, our substring length can be maximised if we apply k swaps, but the problem is \\n\\t\\t\\tfinding the right character to swap. i.e We can maximize length if we find the largest recurring character \\n\\t\\t\\t(most_common_char) and replace other characters in substring with that most_common_char.\\n\\n\\t\\t\\tIn short, the difference between length of substring and maximum repeating character count will give \\n\\t\\t\\tthe next frequent characters, if it is <=k, we can consider it and increase our length\\n\\n\\t\\t\\tHere, we are doing the opposite, if it is >k, we are moving the left pointer +1 position\\n\\t\\t\\t\\'\\'\\'\\n            if (r +1 - l) - max_char_count > k:\\n                memory[s[l]] -= 1\\n                l += 1\\n        return r+1-l\\n```\\nNote: No need to use `while` loop and `res` variable and update if the window length is constant and wouldn\\'t vary after reaching condition. Here once we achieve our condition, we wouldn\\'t lower/increase our length, and we carry forward from there.\\n\\nReference: [@lee215](https://leetcode.com/lee215/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nFUNCTION CharacterReplacement(Input STRING S, Swaps INT K)\\n\\tIntialize two pointers INT left and INT right\\n\\tInitialize Counter object - type HASHMAP\\n\\tFOR right=0 to LENGTH(STRING S)\\n\\t\\tAdd S[right] to Memory\\n\\t\\t\\n\\t\\tIF (length of window) - (maximum character count in Memory) > Swaps K\\n\\t\\t\\tRemove S[left] from Memory\\n\\t\\t\\tIncrement left\\n\\tRETURN (length of window)\\n\\t\\n\\t\\n\\t\\n```\n```\\ndef characterReplacement(self, s, k):\\n\\t\\t# initiating left and right pointer\\n        l = 0\\n        r=-1\\n        # Right pointer initialised to -1 so that if empty string is passed, \\n\\t\\t# it will return r(-1)+1-l(0) at the end which is 0. In short, only for empty string edge case\\n        \\n        # Initialising a Counter object from collections to memory, \\n\\t\\t# this eases adding new element to dict, and in finding most common element in dict\\n        memory = collections.Counter()\\n\\n        # iterating through s, r is the right pointer\\n        for r,v in enumerate(s):\\n          \\t# on each loop, adding s[r] i.e v to the Counter dict \\n            memory[v]+=1\\n\\n            \\'\\'\\'\\n            max_char_count stores the count of the maximum occuring character for eg, \\n            if memory = {\"A\": 2, \"B\": 3, \"C\": 1}, max_char_count has value 3 i.e count of maximum occuring character (i.e, B)\\n            alternatives like max(memory.values()) can also be used\\n            \\'\\'\\'\\n            max_char_count = memory.most_common(1)[0][1]\\n\\n            \\'\\'\\'\\n            Note that r+1-l gives the length of the current window. i.e if r=3, l=0, \\n\\t\\t\\tthen length of array under consideration is r+1(4)-l(0) = 4\\n\\n\\t\\t\\tThe key to this problem is, our substring length can be maximised if we apply k swaps, but the problem is \\n\\t\\t\\tfinding the right character to swap. i.e We can maximize length if we find the largest recurring character \\n\\t\\t\\t(most_common_char) and replace other characters in substring with that most_common_char.\\n\\n\\t\\t\\tIn short, the difference between length of substring and maximum repeating character count will give \\n\\t\\t\\tthe next frequent characters, if it is <=k, we can consider it and increase our length\\n\\n\\t\\t\\tHere, we are doing the opposite, if it is >k, we are moving the left pointer +1 position\\n\\t\\t\\t\\'\\'\\'\\n            if (r +1 - l) - max_char_count > k:\\n                memory[s[l]] -= 1\\n                l += 1\\n        return r+1-l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 487300,
                "title": "c-sliding-window-solution",
                "content": "```csharp\\npublic int CharacterReplacement(string s, int k) \\n{\\n\\tint maxLength = 0;\\n\\tint start = 0, maxCount = 0;            \\n\\tint maxStart = 0;\\n\\n\\tint[] count = new int[26];\\n\\n\\tfor(int end = 0; end < s.Length; end++)\\n\\t{\\n\\t\\tcount[s[end] - \\'A\\']++;\\n\\t\\tmaxCount = Math.Max(maxCount, count[s[end] - \\'A\\']);\\n\\n\\t\\twhile(end - start + 1 - maxCount > k)\\n\\t\\t{\\n\\t\\t\\tcount[s[start] - \\'A\\']--;\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tint length = end - start + 1;\\n\\t\\tif(length > maxLength)\\n\\t\\t{\\n\\t\\t\\tmaxLength = length;\\n\\t\\t\\tmaxStart = start;\\n\\t\\t}            \\n\\t}\\n\\n\\t// This gives substring\\n\\t// Console.WriteLine(s.Substring(maxStart, maxLength));\\n\\treturn maxLength;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int CharacterReplacement(string s, int k) \\n{\\n\\tint maxLength = 0;\\n\\tint start = 0, maxCount = 0;            \\n\\tint maxStart = 0;\\n\\n\\tint[] count = new int[26];\\n\\n\\tfor(int end = 0; end < s.Length; end++)\\n\\t{\\n\\t\\tcount[s[end] - \\'A\\']++;\\n\\t\\tmaxCount = Math.Max(maxCount, count[s[end] - \\'A\\']);\\n\\n\\t\\twhile(end - start + 1 - maxCount > k)\\n\\t\\t{\\n\\t\\t\\tcount[s[start] - \\'A\\']--;\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tint length = end - start + 1;\\n\\t\\tif(length > maxLength)\\n\\t\\t{\\n\\t\\t\\tmaxLength = length;\\n\\t\\t\\tmaxStart = start;\\n\\t\\t}            \\n\\t}\\n\\n\\t// This gives substring\\n\\t// Console.WriteLine(s.Substring(maxStart, maxLength));\\n\\treturn maxLength;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91298,
                "title": "from-brute-force-to-slide-window",
                "content": "I start with the brute force methods, and improve it with sliding window.\\n\\n```if substring's length - mostFreqNumCount <= k,  update the result```\\n```if substring's length - mostFreqNumCount > k, change the substring to match  ```\\n```mostFreqNumCount  is the count of maximum occurring character```\\n\\n    // Method 1: Time limit(O(26 * n^2))    \\n    public int characterReplacement(String s, int k) {\\n        if (s.length() == 0) return 0;\\n        int ret = 1;\\n        for (int i = 0 ; i < s.length() ; i++) {\\n            int[] hist = new int[26];\\n            for (int j = i ; j < s.length() ; j++) {\\n                hist[s.charAt(j) - 'A']++;\\n                int mostFreqNumCount = compuateMaxFreqCount(hist);\\n                int len = j - i + 1;\\n                if (len - mostFreqNumCount > k) {\\n                    break;\\n                }\\n                ret = Math.max(ret, len);\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    private int compuateMaxFreqCount(int[] hist) {\\n        int max = 0;\\n        for (int c : hist) {\\n            max = Math.max(c, max);\\n        }\\n        return max;\\n    }\\n\\n        // Method 2 :  Similar to method 1. Don't need to keep calling compuateMaxFreqCount\\n    // beats 2.43% of java submissions\\\\\\\\\\n\\n    public void characterReplacement(String s, int k)() {\\n        if (s.length() == 0) return 0;\\n        int ret = 1;\\n        int[] hist = new int[26];\\n        int mostFreqNumCount = 0;\\n        for (int i = 0 ; i < s.length() ; i++) {\\n            for (int j = i ; j < s.length() ; j++) {\\n                hist[s.charAt(j) - 'A']++;\\n                mostFreqNumCount = Math.max(hist[s.charAt(j) - 'A'], mostFreqNumCount);\\n                int len = j - i + 1;\\n                if (len - mostFreqNumCount > k) {\\n                    hist[s.charAt(i) - 'A']--;\\n                    i++;\\n                    continue;\\n                }\\n                ret = Math.max(ret, len);\\n            }\\n        }\\n        return ret;\\n    }\\n \\n    // O(n) : Sliding window. var  i is left, var j is right\\n     // runtime beats 51.59% of java submissions.\\n    public int characterReplacement(String s, int k) {\\n        if (s.length() == 0) return 0;\\n        int ret = 1;\\n        int[] hist = new int[26];\\n        int mostFreqNumCount = 0;\\n        int i = 0, j = 0;\\n        while (j < s.length()) {\\n            hist[s.charAt(j) - 'A']++;\\n            int currMostFreqNumCount = Math.max(hist[s.charAt(j) - 'A'], mostFreqNumCount);\\n            int len = j - i + 1;\\n            while (len - currMostFreqNumCount > k) {\\n                hist[s.charAt(i) - 'A']--;\\n                currMostFreqNumCount = Math.max(hist[s.charAt(i) - 'A'], mostFreqNumCount);\\n                i++;\\n                len = j - i + 1;\\n            }\\n            mostFreqNumCount = Math.max(mostFreqNumCount, currMostFreqNumCount);\\n            ret = Math.max(ret, len);\\n            j++;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "```if substring's length - mostFreqNumCount <= k,  update the result```\n```if substring's length - mostFreqNumCount > k, change the substring to match  ```\n```mostFreqNumCount  is the count of maximum occurring character```",
                "codeTag": "Unknown"
            },
            {
                "id": 3767294,
                "title": "c-using-sliding-window-t-c-o-n-s-c-o-1",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(26) == O(1) \\n    */\\n    \\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.length(), res = 0;\\n        int start = 0, end = 0, maxFreq = 0;\\n        map<int, int> freq;\\n        \\n        for(end=0; end<n; end++){\\n            freq[s[end]]++;\\n            maxFreq = max(maxFreq, freq[s[end]]);\\n            \\n            // len-maxFreq <= k, we have to find if the substring has atmost k different characters which we alter to make all the characters of the string equal\\n            while(end-start+1 - maxFreq > k){\\n                freq[s[start]]--;\\n                start++;\\n            }\\n            \\n            res = max(res, end-start+1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(26) == O(1) \\n    */\\n    \\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.length(), res = 0;\\n        int start = 0, end = 0, maxFreq = 0;\\n        map<int, int> freq;\\n        \\n        for(end=0; end<n; end++){\\n            freq[s[end]]++;\\n            maxFreq = max(maxFreq, freq[s[end]]);\\n            \\n            // len-maxFreq <= k, we have to find if the substring has atmost k different characters which we alter to make all the characters of the string equal\\n            while(end-start+1 - maxFreq > k){\\n                freq[s[start]]--;\\n                start++;\\n            }\\n            \\n            res = max(res, end-start+1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524144,
                "title": "python-code-explained-with-approach-and-time-complexity",
                "content": "Intuition:\\n\\n- Initialize two pointers l and r to 0, and a dictionary count to keep track of the frequency of characters in the current window.\\n- Initialize maxf and res to 0. maxf stores the frequency of the most frequent character in the current window, and res stores the length of the longest substring containing only one character seen so far.\\n- Iterate over the string using the right end r of the window. For each character s[r], update its frequency in the count dictionary. Also, update maxf to be the maximum frequency of any character in the current window.\\n- If the length of the window r-l+1 minus the frequency of the most frequent character maxf is greater than k, shrink the window from the left end l. Decrement the frequency of the character at s[l] in the count dictionary and increment l.\\n- Continue updating res to be the maximum length of a substring containing only one character seen so far.\\n- Once the entire string has been iterated over, return res.\\n\\nApproach:\\n1. Initialize `count` to an empty dictionary, `l` to 0, `maxf` and `res` to 0.\\n2. Iterate over the string using the right end `r` of the window:\\n   a. Update the frequency of the character `s[r]` in the `count` dictionary.\\n   b. Update `maxf` to be the maximum frequency of any character in the current window.\\n   c. If the length of the window `r-l+1` minus the frequency of the most frequent character `maxf` is greater than `k`, we need to shrink the window from the left end `l`. Decrement the frequency of the character at `s[l]` in the `count` dictionary, and increment `l`.\\n   d. Update `res` to be the maximum length of a substring containing only one character seen so far.\\n3. Return `res`.\\n\\nComplexity:\\n\\nTime complexity: The time complexity of the algorithm is O(n), where n is the length of the string `s`. This is because we iterate over the string once using the right end `r` of the window, and each character is processed at most twice (once during expansion, and once during contraction).\\n\\nSpace complexity: The space complexity of the algorithm is O(1), since the size of the `count` dictionary is bounded by the number of distinct characters in the string.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n\\n        count = {}\\n        l=0\\n        maxf=0\\n        res=0\\n\\n       #count.get(s[i], 0) gets the current count of the character s[i] from the count dictionary. If the character s[i] is not already a key in the dictionary, count.get(s[i], 0) returns the default value of 0. \\n        for r in range(len(s)):\\n            count[s[r]]=1+count.get(s[r],0)\\n            maxf = max(maxf, count[s[r]])\\n            \\n\\n            if (r-l+1) - maxf >k:\\n                 \\n                count[s[l]]-=1\\n                l+=1\\n            \\n            res = max(res,r-l+1)\\n        \\n\\n        return res\\n\\n        \\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n\\n        count = {}\\n        l=0\\n        maxf=0\\n        res=0\\n\\n       #count.get(s[i], 0) gets the current count of the character s[i] from the count dictionary. If the character s[i] is not already a key in the dictionary, count.get(s[i], 0) returns the default value of 0. \\n        for r in range(len(s)):\\n            count[s[r]]=1+count.get(s[r],0)\\n            maxf = max(maxf, count[s[r]])\\n            \\n\\n            if (r-l+1) - maxf >k:\\n                 \\n                count[s[l]]-=1\\n                l+=1\\n            \\n            res = max(res,r-l+1)\\n        \\n\\n        return res\\n\\n        \\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269707,
                "title": "424-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize variables window_start, max_length, max_count, and char_count. window_start is the start index of the sliding window. max_length is the length of the longest substring with repeating characters seen so far. max_count is the maximum count of any character seen so far. char_count is a dictionary that stores the count of each character in the current window.\\n2. Traverse the string s from left to right using a for loop.\\n3. Increment the count of the current character in the char_count dictionary using the get() method.\\n4. Update the maximum count seen so far by taking the maximum of the current count and the previous maximum count.\\n5. If the length of the current window (window_end - window_start + 1) is greater than the sum of the maximum count seen so far and k, then we need to shrink the window. To do this, decrement the count of the leftmost character (s[window_start]) in the char_count dictionary, and move the window_start index one step to the right.\\n6. Update the maximum length of the substring with repeating characters seen so far by taking the maximum of the current length and the previous maximum length (window_end - window_start + 1).\\n7. After the loop completes, return the maximum length of the substring with repeating characters seen so far (max_length).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        # Initialize variables\\n        window_start = 0\\n        max_length = 0\\n        max_count = 0\\n        char_count = {}\\n\\n        # Traverse the string s\\n        for window_end in range(len(s)):\\n            # Increment the count of the current character\\n            char_count[s[window_end]] = char_count.get(s[window_end], 0) + 1\\n            # Update the maximum count seen so far\\n            max_count = max(max_count, char_count[s[window_end]])\\n            \\n            # Shrink the window if required\\n            if window_end - window_start + 1 > max_count + k:\\n                char_count[s[window_start]] -= 1\\n                window_start += 1\\n            \\n            # Update the maximum length of the substring with repeating characters seen so far\\n            max_length = max(max_length, window_end - window_start + 1)\\n        \\n        return max_length\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        # Initialize variables\\n        window_start = 0\\n        max_length = 0\\n        max_count = 0\\n        char_count = {}\\n\\n        # Traverse the string s\\n        for window_end in range(len(s)):\\n            # Increment the count of the current character\\n            char_count[s[window_end]] = char_count.get(s[window_end], 0) + 1\\n            # Update the maximum count seen so far\\n            max_count = max(max_count, char_count[s[window_end]])\\n            \\n            # Shrink the window if required\\n            if window_end - window_start + 1 > max_count + k:\\n                char_count[s[window_start]] -= 1\\n                window_start += 1\\n            \\n            # Update the maximum length of the substring with repeating characters seen so far\\n            max_length = max(max_length, window_end - window_start + 1)\\n        \\n        return max_length\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765508,
                "title": "easy-java-approach",
                "content": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = 0;\\n\\n        int maxLen = 0, mostFreq = 0;\\n\\n        while (right < s.length()) {\\n            // start acquiring\\n            map.put(arr[right], map.getOrDefault(arr[right], 0) + 1);\\n            mostFreq = Math.max(mostFreq, map.get(arr[right]));\\n\\n            int canBeReplaced = (right - left + 1) - mostFreq;\\n\\n            // release from the left\\n            if (canBeReplaced > k) {\\n                map.put(arr[left], map.get(arr[left]) - 1);\\n                left++;\\n            }\\n\\n            maxLen = Math.max(maxLen, right - left + 1);\\n            right++;\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = 0;\\n\\n        int maxLen = 0, mostFreq = 0;\\n\\n        while (right < s.length()) {\\n            // start acquiring\\n            map.put(arr[right], map.getOrDefault(arr[right], 0) + 1);\\n            mostFreq = Math.max(mostFreq, map.get(arr[right]));\\n\\n            int canBeReplaced = (right - left + 1) - mostFreq;\\n\\n            // release from the left\\n            if (canBeReplaced > k) {\\n                map.put(arr[left], map.get(arr[left]) - 1);\\n                left++;\\n            }\\n\\n            maxLen = Math.max(maxLen, right - left + 1);\\n            right++;\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269827,
                "title": "very-detailed-video-explanation",
                "content": "I posted a very detailed video explanation here: https://www.youtube.com/watch?v=VqYz3kXXAMg\\nIt contains the intuition on how to approach the problem, explains the algorithm in depth, and gives general tips.\\nHope it helps!",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "I posted a very detailed video explanation here: https://www.youtube.com/watch?v=VqYz3kXXAMg\\nIt contains the intuition on how to approach the problem, explains the algorithm in depth, and gives general tips.\\nHope it helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 1264075,
                "title": "two-pointer-sliding-window-java-solution-o-n",
                "content": "Algorithm - Basic idea is to get the maximum frequency of the character in the window (using left and right pointers/references)\\n\\n1) Create an array of size 26. As we know in question it defined that string consist of only UPPERCASE English characters.\\n2) Define a start and walker pointers, initialize both to 0. At the start of the algorithm both will point to same character.\\n3) Increment the walker and calculate the max frequnency of the window formed by start and walker. \\n\\t3.1) If difference between window length ( `walker - start + 1` (adding 1 to get the length take an example and you will get it))  and the max frequency (`maxcount`) is greater than `k` (allowed number of replacement) then that means we have reached a position where we will not able to replace character within allowed number of replacement. We have to change the window by doing below \\n\\t\\t\\t\\t`cache[arr[start]-\\'A\\'] = cache[arr[start]-\\'A\\'] - 1;`\\n                `start++;`\\n\\tAs we have moved the start pointer/reference we have to decrease the frequency of that particular character from our cache.\\n\\t3.2) if the difference is not greater than `k` that means we can still replace the charater so will calulate the max for the result.\\n\\nThe idea is not to actualy find which character to replace it\\'s just to find the length of substring. This is the key to understand the problem and get the solution\\n\\nAlso the reason we are subtracting with \\u2018A\\u2019 is so that we can map English letter to array index 0-25 as char \\u2018A\\u2019 -\\u2018A\\u2019 will give 0, \\u2018B\\u2019 - \\u2018A\\u2019 will give 1 likewise.\\n\\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        int n = s.length();\\n        int[] cache = new int[26];\\n        int start = 0, maxcount = 0, res = 0;\\n        char[] arr = s.toCharArray();\\n        for(int walker=0; walker<n;walker++) {\\n            cache[arr[walker] - \\'A\\'] =  cache[arr[walker] - \\'A\\'] + 1;\\n            maxcount = Math.max(maxcount, cache[arr[walker]-\\'A\\']);\\n            if(walker - start + 1 - maxcount > k) {\\n                cache[arr[start]-\\'A\\'] = cache[arr[start]-\\'A\\'] - 1;\\n                start++;\\n            } else {\\n                res = Math.max(res, walker - start + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nReference - [LeetCode Discussion](https://leetcode.com/problems/longest-repeating-character-replacement/discuss/1228751/10-lines-C%2B%2B-two-pointerstp://)",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        int n = s.length();\\n        int[] cache = new int[26];\\n        int start = 0, maxcount = 0, res = 0;\\n        char[] arr = s.toCharArray();\\n        for(int walker=0; walker<n;walker++) {\\n            cache[arr[walker] - \\'A\\'] =  cache[arr[walker] - \\'A\\'] + 1;\\n            maxcount = Math.max(maxcount, cache[arr[walker]-\\'A\\']);\\n            if(walker - start + 1 - maxcount > k) {\\n                cache[arr[start]-\\'A\\'] = cache[arr[start]-\\'A\\'] - 1;\\n                start++;\\n            } else {\\n                res = Math.max(res, walker - start + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945743,
                "title": "why-you-don-t-have-to-update-max-substring-length-most-frequent-element-count",
                "content": "@MuMustafa95  had [this](https://leetcode.com/problems/longest-repeating-character-replacement/discuss/934637/Clear-concise-C%2B%2B-solution-no-explanation-needed-(Sliding-window-better-than-99-time-O(n))) great solutions, I want to add an explanation to things that might look strange\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int right = 0, left = 0, maxLetter = 0;\\n        int alphabet[26] = {0};\\n        while(right < s.length()){\\n            alphabet[s[right] - \\'A\\']++;\\n            maxLetter = max(maxLetter, alphabet[s[right] - \\'A\\']);\\n            right++;\\n            \\n            if(right - left - maxLetter > k){\\n                alphabet[s[left] - \\'A\\']--;\\n                left++;\\n            }\\n        }\\n        return right - left;\\n    }\\n};\\n```\\n\\n**What are the strange things?**\\n1) You don\\'t update your `maxLetter` \\n2) You don\\'t mantain a result length, simply return `right - left` at the end.\\n\\nThis works because of the following:\\n**Longest substing must have the maximum `maxLetter`.**\\n- you best result is `(maxLetter + k)`,\\n- k stays the same for any substring so `maxLetter` must be the maximum over all `maxLetter`s you encountered during runtime.\\n\\n**Why the wrong `maxLetter` won\\'t mess your result?**\\n- if your `maxLetter` is bigger than it should be, you gonna skip left increments and make your current valid substring longer than it actually is\\n- it doesn\\'t matter since you gonna return the length of the longest, and we showed that it\\'s `maxLetter` is gonna be correct\\n\\n**Why it\\'s enough to return `right-left`?**\\n- will always grow, so we might make `right` larger and wrongly inflate our output\\n- if `maxLetter` doesn\\'t grow along with `right`, `left` is gonna grow as well!! (offsetting the mistaken `right` growth)\\n- this way the `right - left` gap is the actual longest substring\\n\\nHope this helps\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int right = 0, left = 0, maxLetter = 0;\\n        int alphabet[26] = {0};\\n        while(right < s.length()){\\n            alphabet[s[right] - \\'A\\']++;\\n            maxLetter = max(maxLetter, alphabet[s[right] - \\'A\\']);\\n            right++;\\n            \\n            if(right - left - maxLetter > k){\\n                alphabet[s[left] - \\'A\\']--;\\n                left++;\\n            }\\n        }\\n        return right - left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91323,
                "title": "java-o-n-solution-using-sliding-window",
                "content": "The idea is to find maximum valid substring with repeated character 'A' to 'Z' respectively. For each case, use sliding window to determine its maximum length, update the global maximum length if needed. \\n\\n```\\npublic class Solution {\\n    public int characterReplacement(String s, int k) {\\n        int maxLen = 0;\\n        for(int l = 0 ; l<26;l++){\\n            char c = (char)('A' + l); //repeated char we are looking for\\n            int i = 0, j = 0, count = 0;\\n            while(j<s.length()){\\n                char cur = s.charAt(j);\\n                if(cur != c) count++;\\n                \\n                //make the substring valid again\\n                while(count > k){\\n                    if(s.charAt(i) != c) count--;\\n                    i++;\\n                }\\n                \\n                //update maximun len\\n                maxLen = Math.max(maxLen,j-i+1);\\n                j++;\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int characterReplacement(String s, int k) {\\n        int maxLen = 0;\\n        for(int l = 0 ; l<26;l++){\\n            char c = (char)('A' + l); //repeated char we are looking for\\n            int i = 0, j = 0, count = 0;\\n            while(j<s.length()){\\n                char cur = s.charAt(j);\\n                if(cur != c) count++;\\n                \\n                //make the substring valid again\\n                while(count > k){\\n                    if(s.charAt(i) != c) count--;\\n                    i++;\\n                }\\n                \\n                //update maximun len\\n                maxLen = Math.max(maxLen,j-i+1);\\n                j++;\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122059,
                "title": "c-concise-solution-sliding-window-using-hashmap-aditya-bhaiya-s-approach",
                "content": "# Approach \\nRefer Inline comments for explanation. If you have any doubt then feel free to comment below.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- Space complexity: $$O(26) ~= O(1)$$ (coz alphabets are 26 in number)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code - with logic and concise\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int i = 0, j = 0,maxFreq = 0, maxLen = 0;\\n        unordered_map<char, int> mp; // storing the frequency of all the elements\\n        while(j < s.size()){ // format of sliding window\\n            mp[s[j]]++; // updating our hash map\\n            maxFreq = max(maxFreq, mp[s[j]]); // storing element with highest frequency\\n            if((j-i+1) - maxFreq <= k){ // it our answer coz we can delete at most k element \\n                maxLen = max(maxLen, j-i+1);\\n                j++; // why increment coz need highest length which is possible\\n            }\\n            else if((j-i+1) - maxFreq > k){\\n                while((j-i+1) - maxFreq > k){\\n                    mp[s[i]]--; // we can replace more than k elements than we have to shrink our string\\n                    i++;\\n                }\\n                j++; // slide the window\\n            }\\n        }\\n        return maxLen;\\n    }\\n};\\n```\\n\\n# Code - optimal or shorter version\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int i = 0, j = 0,maxFreq = 0, maxLen = 0;\\n        unordered_map<char, int> mp;\\n        while(j < s.size()){\\n            mp[s[j]]++;\\n            maxFreq = max(maxFreq, mp[s[j]]);\\n            if((j-i+1) - maxFreq > k){\\n                mp[s[i]]--;\\n                i++;\\n            }\\n            maxLen = max(maxLen, j-i+1);\\n            j++;\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int i = 0, j = 0,maxFreq = 0, maxLen = 0;\\n        unordered_map<char, int> mp; // storing the frequency of all the elements\\n        while(j < s.size()){ // format of sliding window\\n            mp[s[j]]++; // updating our hash map\\n            maxFreq = max(maxFreq, mp[s[j]]); // storing element with highest frequency\\n            if((j-i+1) - maxFreq <= k){ // it our answer coz we can delete at most k element \\n                maxLen = max(maxLen, j-i+1);\\n                j++; // why increment coz need highest length which is possible\\n            }\\n            else if((j-i+1) - maxFreq > k){\\n                while((j-i+1) - maxFreq > k){\\n                    mp[s[i]]--; // we can replace more than k elements than we have to shrink our string\\n                    i++;\\n                }\\n                j++; // slide the window\\n            }\\n        }\\n        return maxLen;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int i = 0, j = 0,maxFreq = 0, maxLen = 0;\\n        unordered_map<char, int> mp;\\n        while(j < s.size()){\\n            mp[s[j]]++;\\n            maxFreq = max(maxFreq, mp[s[j]]);\\n            if((j-i+1) - maxFreq > k){\\n                mp[s[i]]--;\\n                i++;\\n            }\\n            maxLen = max(maxLen, j-i+1);\\n            j++;\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683335,
                "title": "python-counter-solution-beats-90-60",
                "content": "**O(N) Counter Solution**\\n```\\ndef characterReplacement(self, s, k):\\n\\tleft,right = 0,k # left and right of our sliding window\\n\\tsubstring = Counter(s[:k]) # we know we can have at least k elements\\n\\tmaxCount = 0 # maximum count of a single element we have had in a window\\n\\tans = k # answer is at least k\\n\\n\\tn = len(s) \\n\\twhile right < n:\\n\\t\\tsubstring[s[right]] += 1 # add the next element\\n\\t\\tmaxCount = max(maxCount, substring[s[right]]) # update the maxCount if necessary\\n\\t\\tif ans < maxCount + k: # if we have space for another element that we can replace\\n\\t\\t\\tans += 1 # increment the answer\\n\\t\\telse:\\n\\t\\t\\tsubstring[s[left]] -= 1 # otherwise, remove the last element in our window\\n\\t\\t\\tleft += 1 # move the end forward\\n\\t\\tright += 1 # move forward\\n\\n\\treturn ans\\n```\\n\\n**Explanation**\\nIn this solution we use a sliding window to analyze ```s[left:right+1]```. We keep track of the maximum number of a single character we have seen in a window using ```maxCount```. If we are ever able to add more characters to our counter (```ans < maxCount + k```) then we increment ```ans```. ```right - left == ans```, so we could reallly solve this with only ```left``` or only ```right```, but I think the code is more intuitive when using both. If we don\\'t have space for another element, we remove the last element, ```s[left]``` from our sliding window to make space for the next element in our next iteration of the while loop. \\n\\n**Complexity Analysis**\\nThis solution takes ```O(N)``` space and time where ```N == len(s)``` since we need to look at every character once and it is possible that the whole string is the longest substring which satisfies our conditions, which would mean we have to store every character in ```substring```. \\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! If you have any questions, please feel free to ask in the comments and I will try to answer them. Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\ndef characterReplacement(self, s, k):\\n\\tleft,right = 0,k # left and right of our sliding window\\n\\tsubstring = Counter(s[:k]) # we know we can have at least k elements\\n\\tmaxCount = 0 # maximum count of a single element we have had in a window\\n\\tans = k # answer is at least k\\n\\n\\tn = len(s) \\n\\twhile right < n:\\n\\t\\tsubstring[s[right]] += 1 # add the next element\\n\\t\\tmaxCount = max(maxCount, substring[s[right]]) # update the maxCount if necessary\\n\\t\\tif ans < maxCount + k: # if we have space for another element that we can replace\\n\\t\\t\\tans += 1 # increment the answer\\n\\t\\telse:\\n\\t\\t\\tsubstring[s[left]] -= 1 # otherwise, remove the last element in our window\\n\\t\\t\\tleft += 1 # move the end forward\\n\\t\\tright += 1 # move forward\\n\\n\\treturn ans\\n```\n```s[left:right+1]```\n```maxCount```\n```ans < maxCount + k```\n```ans```\n```right - left == ans```\n```left```\n```right```\n```s[left]```\n```O(N)```\n```N == len(s)```\n```substring```",
                "codeTag": "Python3"
            },
            {
                "id": 2385086,
                "title": "ruby-sliding-window-o-n",
                "content": "```\\ndef character_replacement(s, k)\\n  char_counts = Hash.new(0)\\n  longest_string, left = 0, 0\\n  \\n  s.chars.each_index do |i|\\n    char_counts[s[i]] += 1\\n    sliding_window_size = i - left + 1\\n    character_change_cap = char_counts.values.max + k\\n    \\n    if sliding_window_size > character_change_cap\\n      char_counts[s[left]] -= 1\\n      left += 1\\n    end\\n      \\n    longest_string = [longest_string, i-left+1].max\\n  end\\n  \\n  longest_string\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Sliding Window"
                ],
                "code": "```\\ndef character_replacement(s, k)\\n  char_counts = Hash.new(0)\\n  longest_string, left = 0, 0\\n  \\n  s.chars.each_index do |i|\\n    char_counts[s[i]] += 1\\n    sliding_window_size = i - left + 1\\n    character_change_cap = char_counts.values.max + k\\n    \\n    if sliding_window_size > character_change_cap\\n      char_counts[s[left]] -= 1\\n      left += 1\\n    end\\n      \\n    longest_string = [longest_string, i-left+1].max\\n  end\\n  \\n  longest_string\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2335674,
                "title": "c-solution-by-filling-the-gaps",
                "content": "```\\nclass Solution {\\npublic:map<char,vector>mp;\\n    int characterReplacement(string s, int k) {\\n        map<char,vector<int>>mp;\\n        \\n        for(int i = 0;i<s.size();i++){\\n            mp[s[i]].push_back(i);\\n        }\\n        \\n        \\n        int ans = 0;\\n        for(char c = \\'A\\';c<=\\'Z\\';c++){\\n            vector<int>gaps;\\n            if(mp[c].size() == 0)continue;\\n            int extra = mp[c][0];\\n            \\n            for(int j = 1;j<mp[c].size();j++){\\n                if(j == mp[c].size() - 1){\\n                    // gaps.push_back(s.size() - mp[c][j] - 1);\\n                    extra += s.size() - mp[c][j] - 1;\\n                }\\n                gaps.push_back(mp[c][j] - mp[c][j - 1] - 1);\\n            }\\n            \\n            //jitne poore liye + 1\\n            int low = 0,high = 0;\\n            int max_take = 0;\\n            \\n            int tot = extra;\\n            for(auto j : gaps){\\n                tot+=j;\\n            }\\n            // cout << tot << \\'\\\\n\\';\\n            int cur = 0;\\n            \\n            while(low < gaps.size()){\\n                while(high<gaps.size() && cur + gaps[high] <= k){\\n                    cur += gaps[high];\\n                    high++;\\n                    max_take++;\\n                }\\n                ans = max(ans,max_take + 1 + cur + min(tot - cur,(k - cur)));\\n                \\n                if(high > low){\\n                    cur -= gaps[low];\\n                    max_take--;                    \\n                }\\n                low++;\\n                high = max(high,low);\\n            }\\n            \\n            ans = max(ans,1 + min(k,tot));\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:map<char,vector>mp;\\n    int characterReplacement(string s, int k) {\\n        map<char,vector<int>>mp;\\n        \\n        for(int i = 0;i<s.size();i++){\\n            mp[s[i]].push_back(i);\\n        }\\n        \\n        \\n        int ans = 0;\\n        for(char c = \\'A\\';c<=\\'Z\\';c++){\\n            vector<int>gaps;\\n            if(mp[c].size() == 0)continue;\\n            int extra = mp[c][0];\\n            \\n            for(int j = 1;j<mp[c].size();j++){\\n                if(j == mp[c].size() - 1){\\n                    // gaps.push_back(s.size() - mp[c][j] - 1);\\n                    extra += s.size() - mp[c][j] - 1;\\n                }\\n                gaps.push_back(mp[c][j] - mp[c][j - 1] - 1);\\n            }\\n            \\n            //jitne poore liye + 1\\n            int low = 0,high = 0;\\n            int max_take = 0;\\n            \\n            int tot = extra;\\n            for(auto j : gaps){\\n                tot+=j;\\n            }\\n            // cout << tot << \\'\\\\n\\';\\n            int cur = 0;\\n            \\n            while(low < gaps.size()){\\n                while(high<gaps.size() && cur + gaps[high] <= k){\\n                    cur += gaps[high];\\n                    high++;\\n                    max_take++;\\n                }\\n                ans = max(ans,max_take + 1 + cur + min(tot - cur,(k - cur)));\\n                \\n                if(high > low){\\n                    cur -= gaps[low];\\n                    max_take--;                    \\n                }\\n                low++;\\n                high = max(high,low);\\n            }\\n            \\n            ans = max(ans,1 + min(k,tot));\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2331294,
                "title": "python-template-to-solve-most-of-sliding-window-question",
                "content": "## First, here\\'s the solution + explanation for this problem using sliding window and hash map\\n### We\\'ll use a hash map to keep track the count of each letter in the string, and make sure that the **length of current window - highest value in our map <= given K**\\n\\n**Time: O(N), N is number of letters in strings**\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        myDict = {}\\n        maxLength = 0\\n        windowStart = 0\\n        for windowEnd in range(len(s)):\\n            myDict[s[windowEnd]] = myDict.get(s[windowEnd],0)+1\\n            length = (windowEnd - windowStart) + 1\\n            if length - max(myDict.values()) > k:\\n                myDict[s[windowStart]] = myDict.get(s[windowStart],0)-1\\n                if myDict[s[windowStart]] == 0:\\n                    del myDict[s[windowStart]]\\n                windowStart += 1\\n            else:\\n                maxLength = max(maxLength,length)\\n        return maxLength\\n```\\n\\n## Finally, Template to solve most of Sliding Window question\\n```\\nclass Solution:\\n    def somefunction(self, s: str, k: int) -> int:\\n        # Use a hash map or a set for question that ask about repeating\\n        # Use a max count or min count for question ask about longest/shortest substring\\n        # A variable for the start of our window\\n\\t\\t\\n        for windowEnd in range(len(s)):\\n\\t\\t\\t# Perform something to our map/set or anything that\\'ll be used for the result\\n\\t\\t\\t# Condition to stop our window and move to the next window\\n            # Calculate the window max/min length if question asking about length, sum if question about sum and so on\\n\\t\\t\\t\\n        # Return what the question want\\n```\\n\\n## Here\\'re some problems that I\\'ve solved using this template:\\n\\n\\n### [904. Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/)\\n```\\nclass Solution:\\n    def totalFruit(self, fruits: List[int]) -> int:\\n        myDict = {}\\n        maxLength = 0\\n        windowStart = 0\\n        for windowEnd in range(len(fruits)):\\n            myDict[fruits[windowEnd]] = myDict.get(fruits[windowEnd],0)+1\\n            while len(myDict) > 2:\\n                myDict[fruits[windowStart]] = myDict.get(fruits[windowStart],0)-1\\n                if myDict[fruits[windowStart]] == 0:\\n                    del myDict[fruits[windowStart]]\\n                windowStart += 1\\n            length = (windowEnd - windowStart) + 1\\n            maxLength = max(maxLength,length)\\n            \\n        return maxLength\\n```\\n\\t \\n### [643. Maximum Average SubArray I](https://leetcode.com/problems/maximum-average-subarray-i/)\\n\\n```\\nclass Solution:\\n    def findMaxAverage(self, nums: List[int], k: int) -> float:\\n        maxAvg = float(\\'-inf\\')\\n        windowSum, windowStart = 0.0,0\\n        for windowEnd in range(len(nums)):\\n            windowSum += nums[windowEnd]\\n            if windowEnd >= k-1:\\n                avg = windowSum / k\\n                maxAvg = max(maxAvg,avg)\\n                windowSum -= nums[windowStart]\\n                windowStart += 1\\n                \\n        return maxAvg\\n```\\n\\n### 340. [Longest Substring with at most K-Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/)\\n\\n```\\nclass Solution:\\n    def length_of_longest_substring_k_distinct(self, s: str, k: int) -> int:\\n        myDict = {}\\n        maxLength = 0\\n        windowStart = 0\\n        for windowEnd in range(len(s)):\\n            myDict[s[windowEnd]] = myDict.get(s[windowEnd],0)+1\\n            while len(myDict) > k:\\n                myDict[s[windowStart]] = myDict.get(s[windowStart],0)-1\\n                if myDict[s[windowStart]] == 0:\\n                    del myDict[s[windowStart]]\\n                windowStart += 1\\n            length = (windowEnd - windowStart ) + 1\\n            maxLength = max(maxLength,length)\\n        \\n        return maxLength\\n```\\n\\n### Hope this helps :D\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        myDict = {}\\n        maxLength = 0\\n        windowStart = 0\\n        for windowEnd in range(len(s)):\\n            myDict[s[windowEnd]] = myDict.get(s[windowEnd],0)+1\\n            length = (windowEnd - windowStart) + 1\\n            if length - max(myDict.values()) > k:\\n                myDict[s[windowStart]] = myDict.get(s[windowStart],0)-1\\n                if myDict[s[windowStart]] == 0:\\n                    del myDict[s[windowStart]]\\n                windowStart += 1\\n            else:\\n                maxLength = max(maxLength,length)\\n        return maxLength\\n```\n```\\nclass Solution:\\n    def somefunction(self, s: str, k: int) -> int:\\n        # Use a hash map or a set for question that ask about repeating\\n        # Use a max count or min count for question ask about longest/shortest substring\\n        # A variable for the start of our window\\n\\t\\t\\n        for windowEnd in range(len(s)):\\n\\t\\t\\t# Perform something to our map/set or anything that\\'ll be used for the result\\n\\t\\t\\t# Condition to stop our window and move to the next window\\n            # Calculate the window max/min length if question asking about length, sum if question about sum and so on\\n\\t\\t\\t\\n        # Return what the question want\\n```\n```\\nclass Solution:\\n    def totalFruit(self, fruits: List[int]) -> int:\\n        myDict = {}\\n        maxLength = 0\\n        windowStart = 0\\n        for windowEnd in range(len(fruits)):\\n            myDict[fruits[windowEnd]] = myDict.get(fruits[windowEnd],0)+1\\n            while len(myDict) > 2:\\n                myDict[fruits[windowStart]] = myDict.get(fruits[windowStart],0)-1\\n                if myDict[fruits[windowStart]] == 0:\\n                    del myDict[fruits[windowStart]]\\n                windowStart += 1\\n            length = (windowEnd - windowStart) + 1\\n            maxLength = max(maxLength,length)\\n            \\n        return maxLength\\n```\n```\\nclass Solution:\\n    def findMaxAverage(self, nums: List[int], k: int) -> float:\\n        maxAvg = float(\\'-inf\\')\\n        windowSum, windowStart = 0.0,0\\n        for windowEnd in range(len(nums)):\\n            windowSum += nums[windowEnd]\\n            if windowEnd >= k-1:\\n                avg = windowSum / k\\n                maxAvg = max(maxAvg,avg)\\n                windowSum -= nums[windowStart]\\n                windowStart += 1\\n                \\n        return maxAvg\\n```\n```\\nclass Solution:\\n    def length_of_longest_substring_k_distinct(self, s: str, k: int) -> int:\\n        myDict = {}\\n        maxLength = 0\\n        windowStart = 0\\n        for windowEnd in range(len(s)):\\n            myDict[s[windowEnd]] = myDict.get(s[windowEnd],0)+1\\n            while len(myDict) > k:\\n                myDict[s[windowStart]] = myDict.get(s[windowStart],0)-1\\n                if myDict[s[windowStart]] == 0:\\n                    del myDict[s[windowStart]]\\n                windowStart += 1\\n            length = (windowEnd - windowStart ) + 1\\n            maxLength = max(maxLength,length)\\n        \\n        return maxLength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323176,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\n public int characterReplacement(String s, int k) {\\n\\t\\tMap<Character, Integer> map = new HashMap<>(); \\n\\n\\t   int left = 0, maxRepeat = 0, maxWindow = 0;\\n\\n\\t\\tfor(int right = 0; right < s.length(); right++) {\\n\\t\\t\\tchar ch = s.charAt(right);\\n\\t\\t\\tif(!map.containsKey(ch)) {\\n\\t\\t\\t\\tmap.put(ch, 0);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(ch, map.get(ch) + 1);\\n\\t\\t\\t\\n\\t\\t\\t// IMPORTANT: maxRepeat is not the accurate number of dominant character, It is the historical maximum count \\n\\t\\t\\t// We do not care about it because unless it gets greater, it won\\'t affect our final max window size.\\n\\t\\t\\tmaxRepeat = Math.max(maxRepeat, map.get(ch));\\n\\n\\t\\t\\tif(right - left + 1 - maxRepeat > k) {\\n\\t\\t\\t\\tchar remove = s.charAt(left);\\n\\t\\t\\t\\tmap.put(remove, map.get(remove) - 1);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n        \\n        maxWindow = Math.max(maxWindow, right - left + 1);\\n    }\\n    \\n    return maxWindow;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\n  int characterReplacement(string a, int k) {\\n        int i=0,j=0, maxRepeating = 0, maxLen = 0;\\n        unordered_map<char, int> m;\\n        \\n        //Character other than maximum repeating character should at most be k, becuase we can make only k changes in the string.\\n        //(length of substring - number of times of the maximum occurring character in the substring) <= k\\n\\t\\t\\n        for(j=0; j<a.size(); j++){\\n            m[a[j]]++;\\n            maxRepeating = max(maxRepeating, m[a[j]]);\\n            //When other characters become greater than k, we move window ahead.\\n            if(j-i+1 - maxRepeating > k){\\n                m[a[i]]--;\\n                i++;\\n            }\\n            maxLen = max(maxLen, j-i+1);\\n        }\\n        return maxLen;\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        l = 0\\n        c_frequency = {}\\n        longest_str_len = 0\\n        for r in range(len(s)):\\n            \\n            if not s[r] in c_frequency:\\n                c_frequency[s[r]] = 0\\n            c_frequency[s[r]] += 1\\n            \\n            # Replacements cost = cells count between left and right - highest frequency\\n            cells_count = r - l + 1\\n            if cells_count - max(c_frequency.values()) <= k:\\n                longest_str_len = max(longest_str_len, cells_count)\\n                \\n            else:\\n                c_frequency[s[l]] -= 1\\n                if not c_frequency[s[l]]:\\n                    c_frequency.pop(s[l])\\n                l += 1\\n        \\n        return longest_str_len\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nconst characterReplacement = (s, k) => {\\n  let left = 0;\\n  let right = 0;\\n  let maxCharCount = 0;\\n  const visited = {};\\n\\n  while (right < s.length) {\\n    const char = s[right];\\n    visited[char] = visited[char] ? visited[char] + 1 : 1;\\n\\n    if (visited[char] > maxCharCount) maxCharCount = visited[char];\\n\\n    if (right - left + 1 - maxCharCount > k) {\\n      visited[s[left]]--;\\n      left++;\\n    }\\n\\n    right++;\\n  }\\n\\n  return right - left;\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun characterReplacement(s: String, k: Int): Int {\\n        var mostFreqCharCount = 0; var start = 0; var max=0\\n        val map = mutableMapOf<Char, Int>()\\n        \\n        for(end in 0 until s.length){\\n            map.put(s[end], map.getOrDefault(s[end], 0) + 1)\\n            mostFreqCharCount = Math.max(map.get(s[end])!!, mostFreqCharCount)\\n            if(end - start + 1 > mostFreqCharCount + k){\\n                map.put(s[start], map.get(s[start])!! - 1)\\n                start++                \\n            }\\n            max = Math.max(max, end - start + 1)\\n        }\\n        return max\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    \\n    func characterReplacement(_ s: String, _ k: Int) -> Int {\\n        var windowStart = 0, mx = 0, maxChar = 0\\n        var inputString = Array(s)\\n        var dict = [Character: Int]()\\n        \\n        for windowEnd in 0..<inputString.count{\\n            dict[inputString[windowEnd], default: 0 ] += 1\\n            maxChar = max(maxChar, dict[inputString[windowEnd], default: 0])\\n            let replaceCharCount = (windowEnd - windowStart + 1) - maxChar\\n            if replaceCharCount <= k{\\n                mx = max(mx, windowEnd - windowStart + 1 )\\n            }else{\\n                while( ((windowEnd - windowStart + 1) - maxChar) > k){\\n                    dict[inputString[windowStart], default: 0 ] -= 1\\n                    windowStart += 1\\n                }\\n            }\\n    \\n        }\\n        return mx\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\n public int characterReplacement(String s, int k) {\\n\\t\\tMap<Character, Integer> map = new HashMap<>(); \\n\\n\\t   int left = 0, maxRepeat = 0, maxWindow = 0;\\n\\n\\t\\tfor(int right = 0; right < s.length(); right++) {\\n\\t\\t\\tchar ch = s.charAt(right);\\n\\t\\t\\tif(!map.containsKey(ch)) {\\n\\t\\t\\t\\tmap.put(ch, 0);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(ch, map.get(ch) + 1);\\n\\t\\t\\t\\n\\t\\t\\t// IMPORTANT: maxRepeat is not the accurate number of dominant character, It is the historical maximum count \\n\\t\\t\\t// We do not care about it because unless it gets greater, it won\\'t affect our final max window size.\\n\\t\\t\\tmaxRepeat = Math.max(maxRepeat, map.get(ch));\\n\\n\\t\\t\\tif(right - left + 1 - maxRepeat > k) {\\n\\t\\t\\t\\tchar remove = s.charAt(left);\\n\\t\\t\\t\\tmap.put(remove, map.get(remove) - 1);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n        \\n        maxWindow = Math.max(maxWindow, right - left + 1);\\n    }\\n    \\n    return maxWindow;\\n}\\n```\n```\\n```\n```\\n```\n```\\n  int characterReplacement(string a, int k) {\\n        int i=0,j=0, maxRepeating = 0, maxLen = 0;\\n        unordered_map<char, int> m;\\n        \\n        //Character other than maximum repeating character should at most be k, becuase we can make only k changes in the string.\\n        //(length of substring - number of times of the maximum occurring character in the substring) <= k\\n\\t\\t\\n        for(j=0; j<a.size(); j++){\\n            m[a[j]]++;\\n            maxRepeating = max(maxRepeating, m[a[j]]);\\n            //When other characters become greater than k, we move window ahead.\\n            if(j-i+1 - maxRepeating > k){\\n                m[a[i]]--;\\n                i++;\\n            }\\n            maxLen = max(maxLen, j-i+1);\\n        }\\n        return maxLen;\\n    }\\n```\n```\\n```\n```\\n```\n```\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        l = 0\\n        c_frequency = {}\\n        longest_str_len = 0\\n        for r in range(len(s)):\\n            \\n            if not s[r] in c_frequency:\\n                c_frequency[s[r]] = 0\\n            c_frequency[s[r]] += 1\\n            \\n            # Replacements cost = cells count between left and right - highest frequency\\n            cells_count = r - l + 1\\n            if cells_count - max(c_frequency.values()) <= k:\\n                longest_str_len = max(longest_str_len, cells_count)\\n                \\n            else:\\n                c_frequency[s[l]] -= 1\\n                if not c_frequency[s[l]]:\\n                    c_frequency.pop(s[l])\\n                l += 1\\n        \\n        return longest_str_len\\n```\n```\\n```\n```\\n```\n```\\nconst characterReplacement = (s, k) => {\\n  let left = 0;\\n  let right = 0;\\n  let maxCharCount = 0;\\n  const visited = {};\\n\\n  while (right < s.length) {\\n    const char = s[right];\\n    visited[char] = visited[char] ? visited[char] + 1 : 1;\\n\\n    if (visited[char] > maxCharCount) maxCharCount = visited[char];\\n\\n    if (right - left + 1 - maxCharCount > k) {\\n      visited[s[left]]--;\\n      left++;\\n    }\\n\\n    right++;\\n  }\\n\\n  return right - left;\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun characterReplacement(s: String, k: Int): Int {\\n        var mostFreqCharCount = 0; var start = 0; var max=0\\n        val map = mutableMapOf<Char, Int>()\\n        \\n        for(end in 0 until s.length){\\n            map.put(s[end], map.getOrDefault(s[end], 0) + 1)\\n            mostFreqCharCount = Math.max(map.get(s[end])!!, mostFreqCharCount)\\n            if(end - start + 1 > mostFreqCharCount + k){\\n                map.put(s[start], map.get(s[start])!! - 1)\\n                start++                \\n            }\\n            max = Math.max(max, end - start + 1)\\n        }\\n        return max\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    \\n    func characterReplacement(_ s: String, _ k: Int) -> Int {\\n        var windowStart = 0, mx = 0, maxChar = 0\\n        var inputString = Array(s)\\n        var dict = [Character: Int]()\\n        \\n        for windowEnd in 0..<inputString.count{\\n            dict[inputString[windowEnd], default: 0 ] += 1\\n            maxChar = max(maxChar, dict[inputString[windowEnd], default: 0])\\n            let replaceCharCount = (windowEnd - windowStart + 1) - maxChar\\n            if replaceCharCount <= k{\\n                mx = max(mx, windowEnd - windowStart + 1 )\\n            }else{\\n                while( ((windowEnd - windowStart + 1) - maxChar) > k){\\n                    dict[inputString[windowStart], default: 0 ] -= 1\\n                    windowStart += 1\\n                }\\n            }\\n    \\n        }\\n        return mx\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225035,
                "title": "how-will-you-solve-this-in-an-interview-explained-brute-force-to-optimal-solution",
                "content": "# **Longest Repeating Character Replacement**\\n\\n## Question\\n\\n---\\n\\nYou are given a string\\xA0`s`\\xA0and an integer\\xA0`k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most\\xA0`k`\\xA0times.\\n\\nReturn\\xA0*the length of the longest substring containing the same letter you can get after performing the above operations*.\\n\\n## Inputs\\n\\n---\\n\\n### How will you do it by hand?\\n\\nCases : 2-3\\n\\nTrue/Found/etc\\n\\n```python\\nInput: s = \"ABAB\", k = 2\\nOutput: 4\\nExplanation: Replace the two \\'A\\'s with two \\'B\\'s or vice versa.\\n\\nABAB = AAAA k = 2 replaced B with A or we can do the same with B.\\n```\\n\\nFalse/not Found etc\\n\\n```python\\nInput: s = \"AABABBA\", k = 1\\nOutput: 4\\nExplanation: Replace the one \\'A\\' in the middle with \\'B\\' and form \"AABBBBA\".\\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\\n```\\n\\n## Brute-force (If any)\\n\\n---\\n\\n### Explanation\\n\\n1. We are given a string with multiple characters. We have returned the length of the longest string by replacing k elements.\\n    1. let\\'s go with an example to clear things up\\n        1. Our starting point is one character and will be \\n        same *longest substring containing the same letter*\\n            \\n            ```python\\n            s =\"ABCD\"\\n            [A]BCD window window size = 1 k = 2 \\n            ```\\n            \\n        2. We need to replace a B to make the sliding window legal can replace B? yes as we have 2 replacements left\\n            \\n            ```python\\n            [AB]CD window size = 2,k = 2\\n            ```\\n            \\n        3. We need to replace a C to make the sliding window legal can we replace C? yes as we have 1 replacement left.\\n            \\n            ```python\\n            [AAC]D window window size= 3,k = 1\\n            ```\\n            \\n        4. We need to replace a D to make the sliding window legal can we replace C? NO as we have 0 replacements left.\\n            \\n            ```python\\n            [AAAD] window size = 4,k = 0\\n            # this is not possible so the max window length is three\\n            ```\\n            \\n    2. Will reset the characters as we move the sliding window from the left to \\n    calculate again, will keep going.\\n        \\n        ```python\\n        \\n        A[BCD] window size = 3,k = 2\\n        ```\\n        \\n    3. Another question you might ask is which character we are going to decide to keep.And which ones are we going to replace? Like in the example s = \"ABAB\". Let me show you.\\n        1. What is the best legal longest string with the same characters we can \\n        get from both with k = 1\\n            \\n            ```python\\n            1. [AAB]\\n            2. [ABC]\\n            \\n            ```\\n            \\n        2. The best from the first where we have the Two A\\'s, \\n        What does that tell you? We will replace the character with the most frequency in\\n        the sliding window. This will allow us to maximize the size of the window.\\n        3. For this we need to keep track of the frequency of each character, what is the best way we can do that? A dictionary\\n            \\n            ```python\\n            count = {}\\n            ```\\n            \\n    4. We will keep moving and keep adding the characters to the count. In a brute force way we will start from each character and try to see how far we can go until we either run out of the string or until we can keep changing the characters.\\n        \\n        ```python\\n        for starting in range(len(s)):\\n                    \\n                    \\n          characterAtStarting = s[starting]\\n          count[characterAtStarting] = 1 + count.get(characterAtStarting,0)\\n               \\n           for continuing in range(starting+1,len(s)):\\n                characterAtContinuing = s[continuing]\\n                count[characterAtContinuing] = 1 + count.get(characterAtContinuing,0)\\n        ```\\n        \\n    5. Looking at a. we might ask mathematically up-till when will we be able to increase the length of the window.For that, we might ask What is a valid sliding window?\\n        1. length Of The Sliding Window <= the element with the most Frequency + k \\n            1. We can update any other characters anywhere in the sliding window \\n            by using k. Let\\u2019s check our assumption.\\n            \\n            ```python\\n            [ABC] \\n            length of the window = 3, k = 2, \\n            element with most frequency(can be A or B or C) = 1 \\n            #valid? YES\\n            3 <= 2 + 1\\n            \\n            #What if we reduced k\\n            [ABC] \\n            length of the window = 3, k = 1, \\n            element with most frequency(can be A or B or C) = 1 \\n            #valid? No \\n            3 <= 1 + 1 \\n            #not valid as we can\\'t replace all the characters to make\\n            *#substring containing the same letter*\\n            ```\\n            \\n        2. What will we do in this case, we will reduce the window.\\n            \\n            ```python\\n            A[BC] #now it is possible.\\n            ```\\n            \\n    6. how will we formalize it in code?\\n        \\n        ```python\\n        #after two for loops\\n        windowLenght = continuing - starting + 1\\n        characterWithMaxFrequencyInSequence = max(count.values())\\n            \\n            if not(windowLenght <= characterWithMaxFrequencyInSequence + k):\\n                            break\\n        ```\\n        \\n    7. One more thing to go Update the longestSequence.\\n        \\n        ```python\\n        longestSequence = 0\\n        \\n        # calculation done\\n        longestSequence = max(longestSequence,windowLenght)\\n        ```\\n        \\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        longestSequence = 0\\n        #O(N) Space\\n        # will be clearing the count with \\n        # each starting point so at max\\n        # will be storing N items\\n        count = {}\\n        \\n        #O(N^2)\\n        for starting in range(len(s)):\\n            #count clear so we can start with a new subsequence\\n            count.clear()\\n            \\n            characterAtStarting = s[starting]\\n            count[characterAtStarting] = 1 + count.get(characterAtStarting,0)\\n            \\n            \\n            for continuing in range(starting+1,len(s)):\\n                characterAtContinuing = s[continuing]\\n                count[characterAtContinuing] = 1 + count.get(characterAtContinuing,0)\\n                windowLenght = continuing - starting + 1\\n\\t\\t\\t\\t#O(26) time\\n                characterWithMaxFrequencyInSequence = max(count.values())\\n                \\n                \\n                \\n                if not(windowLenght <= characterWithMaxFrequencyInSequence + k):\\n                    break\\n                 #O(1) time\\n                longestSequence = max(longestSequence,windowLenght)\\n                \\n        return longestSequence\\n```\\n\\n### Time Complexity\\n\\n> Time \\u23F0\\xA0O(N^2) Space \\uD83D\\uDCBE\\xA0O(N)\\n> \\n\\nWill give TLE error on leetcode as it is slow.\\n\\n## Optimized Solution\\n\\n---\\n\\nCan we do better?\\n\\n1. Instead of two loops we can use two pointers. Its simple once you understand the brute force method\\n\\n```python\\n [A]BCD k = 1\\nl^ ^r\\n\\n# keep increasing the window until the window is legal.\\n [AB]CD k = 1\\nl^  ^r\\n\\n# on and on till it becomes illegal \\n [ABC]D k = 1\\nl^   ^r\\n#Once it becomes illegal like the above one \\n#the left pointer. So the window is legal\\n A[BC]D k = 1\\n l^  ^r\\n\\n#keep a max of the longest Sequence and return that\\n```\\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        #O(N) Space\\n        count = {}\\n        left = 0\\n        \\n        maxLenghtOfTheSequence = 0\\n        \\n        \\n        #O(N) time\\n        for right in range(len(s)):\\n            characterAtRightPointer = s[right]\\n            characterAtLeftPointer = s[left]\\n\\n         \\n            #add the character at the right pointer to the counter\\n            count[characterAtRightPointer] = 1 + count.get(characterAtRightPointer,0)\\n            \\n        \\n            lenghtOfTheWindow = (right-left+1)\\n\\t\\t\\t#O(26) time\\n            charWithMaxfrequency = max(count.values())\\n            \\n            \\n            if not((lenghtOfTheWindow - charWithMaxfrequency) <= k):\\n                \\n                count[characterAtLeftPointer] -= 1\\n                left +=1 \\n                \\n                \\n                #lenght will be updated as a result of left pointer moving.\\n                lenghtOfTheWindow = (right-left+1)\\n            \\n            \\n            \\n            #O(1) time\\n            maxLenghtOfTheSequence = max(maxLenghtOfTheSequence,lenghtOfTheWindow)\\n            \\n            \\n          \\n        return  maxLenghtOfTheSequence\\n```\\n\\n> Time \\u23F0\\xA0O(N) Space \\uD83D\\uDCBE\\xA0O(N)\\n> \\n\\n## Links\\n\\n---\\n\\n### [PythonTutor(Visualized)](https://pythontutor.com/render.html#code=class%20Solution%3A%0A%20%20%20%20def%20characterReplacement%28self,%20s%3A%20str,%20k%3A%20int%29%20-%3E%20int%3A%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%23SOLUTION%201%20BRUTE%20FORCE%0A%20%20%0A%20%20%20%20%20%20%20%20%23%20longestSequence%20%3D%200%0A%20%20%20%20%20%20%20%20%23%20%23O%28N%29%20Space%0A%20%20%20%20%20%20%20%20%23%20%23%20will%20be%20clearing%20the%20count%20with%20%0A%20%20%20%20%20%20%20%20%23%20%23%20each%20starting%20point%20so%20at%20max%0A%20%20%20%20%20%20%20%20%23%20%23%20will%20be%20storing%20N%20items%0A%20%20%20%20%20%20%20%20%23%20count%20%3D%20%7B%7D%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%23%20%23O%28N%5E2%29%0A%20%20%20%20%20%20%20%20%23%20for%20starting%20in%20range%28len%28s%29%29%3A%0A%20%20%20%20%20%20%20%20%23%20%20%20%20%20%23count%20clear%20so%20we%20can%20start%20with%20a%20new%20subsequence%0A%20%20%20%20%20%20%20%20%23%20%20%20%20%20count.clear%28%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%23%20%20%20%20%20characterAtStarting%20%3D%20s%5Bstarting%5D%0A%20%20%20%20%20%20%20%20%23%20%20%20%20%20count%5BcharacterAtStarting%5D%20%3D%201%20%2B%20count.get%28characterAtStarting,0%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%23%20%20%20%20%20for%20continuing%20in%20range%28starting%2B1,len%28s%29%29%3A%0A%20%20%20%20%20%20%20%20%23%20%20%20%20%20%20%20%20%20characterAtContinuing%20%3D%20s%5Bcontinuing%5D%0A%20%20%20%20%20%20%20%20%23%20%20%20%20%20%20%20%20%20count%5BcharacterAtContinuing%5D%20%3D%201%20%2B%20count.get%28characterAtContinuing,0%29%0A%20%20%20%20%20%20%20%20%23%20%20%20%20%20%20%20%20%20windowLenght%20%3D%20continuing%20-%20starting%20%2B%201%0A%20%20%20%20%20%20%20%20%23%20%20%20%20%20%20%20%20%20characterWithMaxFrequencyInSequence%20%3D%20max%28count.values%28%29%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%23%20%20%20%20%20%20%20%20%20if%20not%28windowLenght%20%3C%3D%20characterWithMaxFrequencyInSequence%20%2B%20k%29%3A%0A%20%20%20%20%20%20%20%20%23%20%20%20%20%20%20%20%20%20%20%20%20%20break%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%23%20%20%20%20%20%20%20%20%20longestSequence%20%3D%20max%28longestSequence,windowLenght%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%23%20return%20longestSequence%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%23%20%23SOLUTION%202%20OPTIMIZED%0A%20%20%20%20%20%20%20%20%23O%28N%29%20Space%0A%20%20%20%20%20%20%20%20count%20%3D%20%7B%7D%0A%20%20%20%20%20%20%20%20left%20%3D%200%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20maxLenghtOfTheSequence%20%3D%200%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%23O%28N%29%20time%0A%20%20%20%20%20%20%20%20for%20right%20in%20range%28len%28s%29%29%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20characterAtRightPointer%20%3D%20s%5Bright%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20characterAtLeftPointer%20%3D%20s%5Bleft%5D%0A%0A%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%23add%20the%20character%20at%20the%20right%20pointer%20to%20the%20counter%0A%20%20%20%20%20%20%20%20%20%20%20%20count%5BcharacterAtRightPointer%5D%20%3D%201%20%2B%20count.get%28characterAtRightPointer,0%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20lenghtOfTheWindow%20%3D%20%28right-left%2B1%29%0A%20%20%20%20%20%20%20%20%20%20%20%20charWithMaxfrequency%20%3D%20max%28count.values%28%29%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20not%28%28lenghtOfTheWindow%20-%20charWithMaxfrequency%29%20%3C%3D%20k%29%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20count%5BcharacterAtLeftPointer%5D%20-%3D%201%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20left%20%2B%3D1%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23lenght%20will%20be%20updated%20as%20a%20result%20of%20left%20pointer%20moving.%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20lenghtOfTheWindow%20%3D%20%28right-left%2B1%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20maxLenghtOfTheSequence%20%3D%20max%28maxLenghtOfTheSequence,lenghtOfTheWindow%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20return%20%20maxLenghtOfTheSequence%0A%0AS%20%3D%20Solution%28%29%0AS.characterReplacement%28%22ABAB%22,2%29%0AS.characterReplacement%28%22AABABBA%22,1%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)\\n![image](https://assets.leetcode.com/users/images/67c02cc8-b9c8-43b2-9de1-139771787c2d_1656726193.3026001.png)\\n\\n### [Blind 75 Beginner-Friendly Solutions](https://leetcode.com/discuss/general-discussion/2210574/Blind-75-with-solutions.)\\n\\n- A list in progress for solutions from the blind 75, a list of the most asked interview questions.",
                "solutionTags": [],
                "code": "```python\\nInput: s = \"ABAB\", k = 2\\nOutput: 4\\nExplanation: Replace the two \\'A\\'s with two \\'B\\'s or vice versa.\\n\\nABAB = AAAA k = 2 replaced B with A or we can do the same with B.\\n```\n```python\\nInput: s = \"AABABBA\", k = 1\\nOutput: 4\\nExplanation: Replace the one \\'A\\' in the middle with \\'B\\' and form \"AABBBBA\".\\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\\n```\n```python\\n            s =\"ABCD\"\\n            [A]BCD window window size = 1 k = 2 \\n            ```\n```python\\n            [AB]CD window size = 2,k = 2\\n            ```\n```python\\n            [AAC]D window window size= 3,k = 1\\n            ```\n```python\\n            [AAAD] window size = 4,k = 0\\n            # this is not possible so the max window length is three\\n            ```\n```python\\n        \\n        A[BCD] window size = 3,k = 2\\n        ```\n```python\\n            1. [AAB]\\n            2. [ABC]\\n            \\n            ```\n```python\\n            count = {}\\n            ```\n```python\\n        for starting in range(len(s)):\\n                    \\n                    \\n          characterAtStarting = s[starting]\\n          count[characterAtStarting] = 1 + count.get(characterAtStarting,0)\\n               \\n           for continuing in range(starting+1,len(s)):\\n                characterAtContinuing = s[continuing]\\n                count[characterAtContinuing] = 1 + count.get(characterAtContinuing,0)\\n        ```\n```python\\n            [ABC] \\n            length of the window = 3, k = 2, \\n            element with most frequency(can be A or B or C) = 1 \\n            #valid? YES\\n            3 <= 2 + 1\\n            \\n            #What if we reduced k\\n            [ABC] \\n            length of the window = 3, k = 1, \\n            element with most frequency(can be A or B or C) = 1 \\n            #valid? No \\n            3 <= 1 + 1 \\n            #not valid as we can\\'t replace all the characters to make\\n            *#substring containing the same letter*\\n            ```\n```python\\n            A[BC] #now it is possible.\\n            ```\n```python\\n        #after two for loops\\n        windowLenght = continuing - starting + 1\\n        characterWithMaxFrequencyInSequence = max(count.values())\\n            \\n            if not(windowLenght <= characterWithMaxFrequencyInSequence + k):\\n                            break\\n        ```\n```python\\n        longestSequence = 0\\n        \\n        # calculation done\\n        longestSequence = max(longestSequence,windowLenght)\\n        ```\n```python\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        longestSequence = 0\\n        #O(N) Space\\n        # will be clearing the count with \\n        # each starting point so at max\\n        # will be storing N items\\n        count = {}\\n        \\n        #O(N^2)\\n        for starting in range(len(s)):\\n            #count clear so we can start with a new subsequence\\n            count.clear()\\n            \\n            characterAtStarting = s[starting]\\n            count[characterAtStarting] = 1 + count.get(characterAtStarting,0)\\n            \\n            \\n            for continuing in range(starting+1,len(s)):\\n                characterAtContinuing = s[continuing]\\n                count[characterAtContinuing] = 1 + count.get(characterAtContinuing,0)\\n                windowLenght = continuing - starting + 1\\n\\t\\t\\t\\t#O(26) time\\n                characterWithMaxFrequencyInSequence = max(count.values())\\n                \\n                \\n                \\n                if not(windowLenght <= characterWithMaxFrequencyInSequence + k):\\n                    break\\n                 #O(1) time\\n                longestSequence = max(longestSequence,windowLenght)\\n                \\n        return longestSequence\\n```\n```python\\n [A]BCD k = 1\\nl^ ^r\\n\\n# keep increasing the window until the window is legal.\\n [AB]CD k = 1\\nl^  ^r\\n\\n# on and on till it becomes illegal \\n [ABC]D k = 1\\nl^   ^r\\n#Once it becomes illegal like the above one \\n#the left pointer. So the window is legal\\n A[BC]D k = 1\\n l^  ^r\\n\\n#keep a max of the longest Sequence and return that\\n```\n```python\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        #O(N) Space\\n        count = {}\\n        left = 0\\n        \\n        maxLenghtOfTheSequence = 0\\n        \\n        \\n        #O(N) time\\n        for right in range(len(s)):\\n            characterAtRightPointer = s[right]\\n            characterAtLeftPointer = s[left]\\n\\n         \\n            #add the character at the right pointer to the counter\\n            count[characterAtRightPointer] = 1 + count.get(characterAtRightPointer,0)\\n            \\n        \\n            lenghtOfTheWindow = (right-left+1)\\n\\t\\t\\t#O(26) time\\n            charWithMaxfrequency = max(count.values())\\n            \\n            \\n            if not((lenghtOfTheWindow - charWithMaxfrequency) <= k):\\n                \\n                count[characterAtLeftPointer] -= 1\\n                left +=1 \\n                \\n                \\n                #lenght will be updated as a result of left pointer moving.\\n                lenghtOfTheWindow = (right-left+1)\\n            \\n            \\n            \\n            #O(1) time\\n            maxLenghtOfTheSequence = max(maxLenghtOfTheSequence,lenghtOfTheWindow)\\n            \\n            \\n          \\n        return  maxLenghtOfTheSequence\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060855,
                "title": "python-o-n-with-detailed-explanation-for-noobs-like-me",
                "content": "In these questions we should think about two things \\n\\n1) What is the condition that makes the sliding window valid? \\n2) What do I do to the left pointer when the window becomes invalid? \\n\\nIn our case - the condition that makes the sliding window valid is that you should have enough \"k\" available such that all of the letters in the sliding window can be of the same kind. For example this means if the window is AABC and k = 2 - this is a valid window because we can flip B and C to A and the window will become AAAA. \\n\\nReally if you look at a bunch of these windows you\\'ll see that it boils down to this:\\n\\nA window is valid if and only if  (total_freq - max_freq) <= k where:\\n\\t**total_freq** is the length of the window/total number of characters in the window. For the window AABC this is 4\\n\\t**max_freq** is the frequency of the character occuring the most times in the window. For the window AABC the most frequent character is A and so **max_freq** is 2\\n\\t\\nWhy is this true? Just draw a few windows and you\\'ll see - the intuition is that if any character let\\'s say \\'A\\' is the most frequent character in the window - the most efficient use of k is to flip all the others to \\'A\\'.\\n\\nIn any case - now that we know what the definition for a valid window is the code is fairly simple\\n\\n\\n```\\nclass Solution(object):\\n    def characterReplacement(self, s, k):\\n        \\n        i = 0 \\n        j = 0\\n        \\n        res = 0\\n        \\n        freqs = {}\\n        max_freq = 0\\n        total_freq = 0\\n        \\n        while j < len(s):\\n            if s[j] in freqs:\\n                freqs[s[j]] +=1\\n            else:\\n                freqs[s[j]] = 1 \\n                \\n            total_freq+=1\\n            max_freq = max(max_freq,freqs[s[j]])\\n            \\n            while not self.checkWindowValid(total_freq,max_freq,k):\\n                freqs[s[i]] -= 1\\n                total_freq-=1\\n                max_freq = max(max_freq,freqs[s[i]])\\n                i+=1\\n                \\n            res = max(res,j-i+1)\\n            j+=1\\n        \\n        return res\\n            \\n    def checkWindowValid(self,total_freq,max_freq,k):\\n        return total_freq - max_freq <= k \\n```\\n\\nLmk if that helped\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def characterReplacement(self, s, k):\\n        \\n        i = 0 \\n        j = 0\\n        \\n        res = 0\\n        \\n        freqs = {}\\n        max_freq = 0\\n        total_freq = 0\\n        \\n        while j < len(s):\\n            if s[j] in freqs:\\n                freqs[s[j]] +=1\\n            else:\\n                freqs[s[j]] = 1 \\n                \\n            total_freq+=1\\n            max_freq = max(max_freq,freqs[s[j]])\\n            \\n            while not self.checkWindowValid(total_freq,max_freq,k):\\n                freqs[s[i]] -= 1\\n                total_freq-=1\\n                max_freq = max(max_freq,freqs[s[i]])\\n                i+=1\\n                \\n            res = max(res,j-i+1)\\n            j+=1\\n        \\n        return res\\n            \\n    def checkWindowValid(self,total_freq,max_freq,k):\\n        return total_freq - max_freq <= k \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995554,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\n public int characterReplacement(String s, int k) {\\n\\t\\tMap<Character, Integer> map = new HashMap<>(); \\n\\n\\t   int left = 0, maxRepeat = 0, maxWindow = 0;\\n\\n\\t\\tfor(int right = 0; right < s.length(); right++) {\\n\\t\\t\\tchar ch = s.charAt(right);\\n\\t\\t\\tif(!map.containsKey(ch)) {\\n\\t\\t\\t\\tmap.put(ch, 0);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(ch, map.get(ch) + 1);\\n\\t\\t\\t\\n\\t\\t\\t// IMPORTANT: maxRepeat is not the accurate number of dominant character, It is the historical maximum count \\n\\t\\t\\t// We do not care about it because unless it gets greater, it won\\'t affect our final max window size.\\n\\t\\t\\tmaxRepeat = Math.max(maxRepeat, map.get(ch));\\n\\n\\t\\t\\tif(right - left + 1 - maxRepeat > k) {\\n\\t\\t\\t\\tchar remove = s.charAt(left);\\n\\t\\t\\t\\tmap.put(remove, map.get(remove) - 1);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n        \\n        maxWindow = Math.max(maxWindow, right - left + 1);\\n    }\\n    \\n    return maxWindow;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\n  int characterReplacement(string a, int k) {\\n        int i=0,j=0, maxRepeating = 0, maxLen = 0;\\n        unordered_map<char, int> m;\\n        \\n        //Character other than maximum repeating character should at most be k, becuase we can make only k changes in the string.\\n        //(length of substring - number of times of the maximum occurring character in the substring) <= k\\n\\t\\t\\n        for(j=0; j<a.size(); j++){\\n            m[a[j]]++;\\n            maxRepeating = max(maxRepeating, m[a[j]]);\\n            //When other characters become greater than k, we move window ahead.\\n            if(j-i+1 - maxRepeating > k){\\n                m[a[i]]--;\\n                i++;\\n            }\\n            maxLen = max(maxLen, j-i+1);\\n        }\\n        return maxLen;\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        l = 0\\n        c_frequency = {}\\n        longest_str_len = 0\\n        for r in range(len(s)):\\n            \\n            if not s[r] in c_frequency:\\n                c_frequency[s[r]] = 0\\n            c_frequency[s[r]] += 1\\n            \\n            # Replacements cost = cells count between left and right - highest frequency\\n            cells_count = r - l + 1\\n            if cells_count - max(c_frequency.values()) <= k:\\n                longest_str_len = max(longest_str_len, cells_count)\\n                \\n            else:\\n                c_frequency[s[l]] -= 1\\n                if not c_frequency[s[l]]:\\n                    c_frequency.pop(s[l])\\n                l += 1\\n        \\n        return longest_str_len\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nconst characterReplacement = (s, k) => {\\n  let left = 0;\\n  let right = 0;\\n  let maxCharCount = 0;\\n  const visited = {};\\n\\n  while (right < s.length) {\\n    const char = s[right];\\n    visited[char] = visited[char] ? visited[char] + 1 : 1;\\n\\n    if (visited[char] > maxCharCount) maxCharCount = visited[char];\\n\\n    if (right - left + 1 - maxCharCount > k) {\\n      visited[s[left]]--;\\n      left++;\\n    }\\n\\n    right++;\\n  }\\n\\n  return right - left;\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun characterReplacement(s: String, k: Int): Int {\\n        var mostFreqCharCount = 0; var start = 0; var max=0\\n        val map = mutableMapOf<Char, Int>()\\n        \\n        for(end in 0 until s.length){\\n            map.put(s[end], map.getOrDefault(s[end], 0) + 1)\\n            mostFreqCharCount = Math.max(map.get(s[end])!!, mostFreqCharCount)\\n            if(end - start + 1 > mostFreqCharCount + k){\\n                map.put(s[start], map.get(s[start])!! - 1)\\n                start++                \\n            }\\n            max = Math.max(max, end - start + 1)\\n        }\\n        return max\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    \\n    func characterReplacement(_ s: String, _ k: Int) -> Int {\\n        var windowStart = 0, mx = 0, maxChar = 0\\n        var inputString = Array(s)\\n        var dict = [Character: Int]()\\n        \\n        for windowEnd in 0..<inputString.count{\\n            dict[inputString[windowEnd], default: 0 ] += 1\\n            maxChar = max(maxChar, dict[inputString[windowEnd], default: 0])\\n            let replaceCharCount = (windowEnd - windowStart + 1) - maxChar\\n            if replaceCharCount <= k{\\n                mx = max(mx, windowEnd - windowStart + 1 )\\n            }else{\\n                while( ((windowEnd - windowStart + 1) - maxChar) > k){\\n                    dict[inputString[windowStart], default: 0 ] -= 1\\n                    windowStart += 1\\n                }\\n            }\\n    \\n        }\\n        return mx\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\n public int characterReplacement(String s, int k) {\\n\\t\\tMap<Character, Integer> map = new HashMap<>(); \\n\\n\\t   int left = 0, maxRepeat = 0, maxWindow = 0;\\n\\n\\t\\tfor(int right = 0; right < s.length(); right++) {\\n\\t\\t\\tchar ch = s.charAt(right);\\n\\t\\t\\tif(!map.containsKey(ch)) {\\n\\t\\t\\t\\tmap.put(ch, 0);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(ch, map.get(ch) + 1);\\n\\t\\t\\t\\n\\t\\t\\t// IMPORTANT: maxRepeat is not the accurate number of dominant character, It is the historical maximum count \\n\\t\\t\\t// We do not care about it because unless it gets greater, it won\\'t affect our final max window size.\\n\\t\\t\\tmaxRepeat = Math.max(maxRepeat, map.get(ch));\\n\\n\\t\\t\\tif(right - left + 1 - maxRepeat > k) {\\n\\t\\t\\t\\tchar remove = s.charAt(left);\\n\\t\\t\\t\\tmap.put(remove, map.get(remove) - 1);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n        \\n        maxWindow = Math.max(maxWindow, right - left + 1);\\n    }\\n    \\n    return maxWindow;\\n}\\n```\n```\\n```\n```\\n```\n```\\n  int characterReplacement(string a, int k) {\\n        int i=0,j=0, maxRepeating = 0, maxLen = 0;\\n        unordered_map<char, int> m;\\n        \\n        //Character other than maximum repeating character should at most be k, becuase we can make only k changes in the string.\\n        //(length of substring - number of times of the maximum occurring character in the substring) <= k\\n\\t\\t\\n        for(j=0; j<a.size(); j++){\\n            m[a[j]]++;\\n            maxRepeating = max(maxRepeating, m[a[j]]);\\n            //When other characters become greater than k, we move window ahead.\\n            if(j-i+1 - maxRepeating > k){\\n                m[a[i]]--;\\n                i++;\\n            }\\n            maxLen = max(maxLen, j-i+1);\\n        }\\n        return maxLen;\\n    }\\n```\n```\\n```\n```\\n```\n```\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        l = 0\\n        c_frequency = {}\\n        longest_str_len = 0\\n        for r in range(len(s)):\\n            \\n            if not s[r] in c_frequency:\\n                c_frequency[s[r]] = 0\\n            c_frequency[s[r]] += 1\\n            \\n            # Replacements cost = cells count between left and right - highest frequency\\n            cells_count = r - l + 1\\n            if cells_count - max(c_frequency.values()) <= k:\\n                longest_str_len = max(longest_str_len, cells_count)\\n                \\n            else:\\n                c_frequency[s[l]] -= 1\\n                if not c_frequency[s[l]]:\\n                    c_frequency.pop(s[l])\\n                l += 1\\n        \\n        return longest_str_len\\n```\n```\\n```\n```\\n```\n```\\nconst characterReplacement = (s, k) => {\\n  let left = 0;\\n  let right = 0;\\n  let maxCharCount = 0;\\n  const visited = {};\\n\\n  while (right < s.length) {\\n    const char = s[right];\\n    visited[char] = visited[char] ? visited[char] + 1 : 1;\\n\\n    if (visited[char] > maxCharCount) maxCharCount = visited[char];\\n\\n    if (right - left + 1 - maxCharCount > k) {\\n      visited[s[left]]--;\\n      left++;\\n    }\\n\\n    right++;\\n  }\\n\\n  return right - left;\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun characterReplacement(s: String, k: Int): Int {\\n        var mostFreqCharCount = 0; var start = 0; var max=0\\n        val map = mutableMapOf<Char, Int>()\\n        \\n        for(end in 0 until s.length){\\n            map.put(s[end], map.getOrDefault(s[end], 0) + 1)\\n            mostFreqCharCount = Math.max(map.get(s[end])!!, mostFreqCharCount)\\n            if(end - start + 1 > mostFreqCharCount + k){\\n                map.put(s[start], map.get(s[start])!! - 1)\\n                start++                \\n            }\\n            max = Math.max(max, end - start + 1)\\n        }\\n        return max\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    \\n    func characterReplacement(_ s: String, _ k: Int) -> Int {\\n        var windowStart = 0, mx = 0, maxChar = 0\\n        var inputString = Array(s)\\n        var dict = [Character: Int]()\\n        \\n        for windowEnd in 0..<inputString.count{\\n            dict[inputString[windowEnd], default: 0 ] += 1\\n            maxChar = max(maxChar, dict[inputString[windowEnd], default: 0])\\n            let replaceCharCount = (windowEnd - windowStart + 1) - maxChar\\n            if replaceCharCount <= k{\\n                mx = max(mx, windowEnd - windowStart + 1 )\\n            }else{\\n                while( ((windowEnd - windowStart + 1) - maxChar) > k){\\n                    dict[inputString[windowStart], default: 0 ] -= 1\\n                    windowStart += 1\\n                }\\n            }\\n    \\n        }\\n        return mx\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705860,
                "title": "python-intuitive-and-clean-o-n-time-approach-and-big-o-explained",
                "content": "**Approach**\\nFor this problem we can use a sliding window to find the longest repeating character replacement. The trick here is to use a hashmap to keep track of the counts of each of the characters. The most efficient use of our \"k\" or character replacements is to change characters that are not the maximum characters for that sliding window. So, if we use a hashmap, we can find the count of the maximum to see if our current window is the longest length. If we have surpassed the number of character replacements we can make for the window, we can increment the leftPointer to find the next possible window.\\n\\n**Big O Analysis**\\nThis is a single loop that iterates through the string one time. The calculations are all O(1) except for max(currentCharDict.values()) which is O(a) where a is the length of the alphabet (possible characters in s). However, O(a) is at maximum 26 which will be grossly overtaken by n. So, we can consider O(a) to be O(1) in this case which would yield a final time complexity of O(n). The space complexity is O(1). It is constant for the same reasons that the space was O(na), the alphabet of the string does not increase with the length of the array, so it is constant.\\n\\nLeave a like if this helped! If you have any questions/issues with the code, let me know in the comments!\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        leftPointer = 0\\n        currentCharDict = {}\\n        longestLength = 0\\n        for rightPointer,rightValue in enumerate(s):\\n            leftValue = s[leftPointer]\\n            \\n            if rightValue not in currentCharDict:\\n                currentCharDict[rightValue] = 0\\n            currentCharDict[rightValue] += 1\\n            \\n            currentLength = rightPointer - leftPointer + 1\\n            if currentLength - max(currentCharDict.values()) <= k:\\n                longestLength = max(longestLength, currentLength)\\n            else:\\n                currentCharDict[leftValue] -= 1\\n                if currentCharDict[leftValue] == 0:\\n                    del currentCharDict[leftValue]\\n                leftPointer += 1\\n        return longestLength\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        leftPointer = 0\\n        currentCharDict = {}\\n        longestLength = 0\\n        for rightPointer,rightValue in enumerate(s):\\n            leftValue = s[leftPointer]\\n            \\n            if rightValue not in currentCharDict:\\n                currentCharDict[rightValue] = 0\\n            currentCharDict[rightValue] += 1\\n            \\n            currentLength = rightPointer - leftPointer + 1\\n            if currentLength - max(currentCharDict.values()) <= k:\\n                longestLength = max(longestLength, currentLength)\\n            else:\\n                currentCharDict[leftValue] -= 1\\n                if currentCharDict[leftValue] == 0:\\n                    del currentCharDict[leftValue]\\n                leftPointer += 1\\n        return longestLength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095929,
                "title": "c-simple-sliding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string &s, int k) {                \\n\\t\\tunordered_map<char,int> m;\\n        int l=0,r=0,maxCount=0,ans=0;\\n\\t\\t\\n        while(r < s.length()) {\\n            m[s[r]]++;\\n            maxCount=max(maxCount,m[s[r]]);\\n\\n            while(r-l+1 - maxCount > k) m[s[l++]]--;\\n\\n            ans=max(ans,r-l+1);\\n            r++;\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string &s, int k) {                \\n\\t\\tunordered_map<char,int> m;\\n        int l=0,r=0,maxCount=0,ans=0;\\n\\t\\t\\n        while(r < s.length()) {\\n            m[s[r]]++;\\n            maxCount=max(maxCount,m[s[r]]);\\n\\n            while(r-l+1 - maxCount > k) m[s[l++]]--;\\n\\n            ans=max(ans,r-l+1);\\n            r++;\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045007,
                "title": "are-you-stuck",
                "content": "let me explain :) think about this question in that way like you want to find the **longest substring** in which all elements are the **same**, for that you can change some element of string (max changes is **k**) so..........................are you able to solve now?   \\n ***NO***? do not worry I will explain the whole process here ...............\\nSo I will continue from the above statement.................\\nAccording to us, all elements will be same in the resultant string; wait wait, can you think for all possible answers? ***YES*** definitely resultant string will be AAAAAAAAA, BBBBBBBB,CCCCCCC, DDDDDD  .....ZZZZ right!!!\\nso we will check all possible ans :) \\nif still you have a doubt, let me take one example here \\ns=\"AAABACDAADBBBBAABBB\" k=3\\nlet suppose ans will start with \"A\"....... are you getting my point ... updated s =\"AAAAAAAAADBBBBAABBB\" and length =9\\nsame for \"B\" s=\"AAABCDAABBBBBBBBBB\"  length =10\\nfor C ??\\nfor D ??\\n  finally, ans will be10\\n  i am damn sure now you have a solution\\n***if you like my explanation, then vote for my post***\\n\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n=s.size(),res=0;\\n        vector<int>check(26,0);\\n        for(int i=0;i<n;i++){\\n            check[s[i]-\\'A\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            char x=i+\\'A\\';\\n            if(!check[i]){\\n                continue;\\n            }\\n            int j=0,start=0,count=0;\\n            while(j<n){\\n                if(count+(s[j]!=x? 1:0)<=k){\\n                    count+=(s[j]!=x? 1:0);\\n                    res=max(res,j-start+1);\\n                    j+=1;\\n                }else{\\n                    count-=(s[start]!=x ? 1:0);\\n                    start+=1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n=s.size(),res=0;\\n        vector<int>check(26,0);\\n        for(int i=0;i<n;i++){\\n            check[s[i]-\\'A\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            char x=i+\\'A\\';\\n            if(!check[i]){\\n                continue;\\n            }\\n            int j=0,start=0,count=0;\\n            while(j<n){\\n                if(count+(s[j]!=x? 1:0)<=k){\\n                    count+=(s[j]!=x? 1:0);\\n                    res=max(res,j-start+1);\\n                    j+=1;\\n                }else{\\n                    count-=(s[start]!=x ? 1:0);\\n                    start+=1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026063,
                "title": "some-explanation-about-why-the-max-count-isnt-changed",
                "content": "https://massivealgorithms.blogspot.com/2016/10/leetcode-424-longest-repeating.html\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n=s.size();\\n        int l=0,res=0, maxRepeatingSoFar=0;\\n        unordered_map<char,int> m;\\n        for(int r=0; r<n; r++){\\n            char c=s[r];\\n            m[c]++;\\n            maxRepeatingSoFar= max(maxRepeatingSoFar,m[c]);\\n            while( r-l+1 - maxRepeatingSoFar > k) //no of non repeating elements\\n            {\\n                m[s[l]]--;\\n                l++;\\n            }\\n            res=max(res, r-l+1 );\\n        }\\n        return res;\\n    }\\n};\\n/*\\nNOTE:\\nSince we are only interested in the longest valid substring, our sliding windows need not shrink, even if a window may cover an invalid substring. We either grow the window by appending one char on the right, or shift the whole window to the right by one. And we only grow the window when the count of the new char exceeds the historical max count (from a previous window that covers a valid substring).\\n\\nwe do not need to update the maxRepeatingSoFar as we do not need the accurate max count of the current window; we only care if the max count exceeds the historical max count; and that can only happen because of the new char of same type as max\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n=s.size();\\n        int l=0,res=0, maxRepeatingSoFar=0;\\n        unordered_map<char,int> m;\\n        for(int r=0; r<n; r++){\\n            char c=s[r];\\n            m[c]++;\\n            maxRepeatingSoFar= max(maxRepeatingSoFar,m[c]);\\n            while( r-l+1 - maxRepeatingSoFar > k) //no of non repeating elements\\n            {\\n                m[s[l]]--;\\n                l++;\\n            }\\n            res=max(res, r-l+1 );\\n        }\\n        return res;\\n    }\\n};\\n/*\\nNOTE:\\nSince we are only interested in the longest valid substring, our sliding windows need not shrink, even if a window may cover an invalid substring. We either grow the window by appending one char on the right, or shift the whole window to the right by one. And we only grow the window when the count of the new char exceeds the historical max count (from a previous window that covers a valid substring).\\n\\nwe do not need to update the maxRepeatingSoFar as we do not need the accurate max count of the current window; we only care if the max count exceeds the historical max count; and that can only happen because of the new char of same type as max\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714330,
                "title": "intiution-behind-the-problem-sliding-window-c",
                "content": "Only thing we have to keep in mind that *We have to find the longest substring where maximum repeating character satisfy this condition*\\n**Size of curWindow-maxFreq of character<=K**\\nBecause we can replace at max K character at any time \\n**Please Upvote the solution if you find it useful**\\n```\\nint findMax(int count[])\\n    {\\n        int m=0;\\n        for(int i=0;i<26;i++)\\n            m=max(m,count[i]);\\n        return m;\\n    }\\n    \\n    int characterReplacement(string s, int k) {\\n        int n=s.size();\\n        int count[26]={0};\\n        int l=0;\\n        int i=0;\\n        int maxFreq=0;    // Character which is repeating at most in our proper curWindow\\n        int window=0;     // Output Window\\n        int curWindow=0;  // Proper or Current Window\\n        while(i<n)\\n        {\\n            count[s[i]-\\'A\\']++;\\n            if(count[s[i]-\\'A\\']>maxFreq)\\n            {\\n                maxFreq=count[s[i]-\\'A\\'];\\n                \\n            }\\n            \\n            curWindow=i-l+1;    // Curreent size\\n           \\n            while(l<n&& curWindow-maxFreq>k)   \\n                {\\n                   count[s[l]-\\'A\\']--;\\n                   maxFreq=findMax(count);\\n                   l++;\\n                   curWindow=i-l+1;\\n                }\\n             window=max(curWindow,window);     \\n           \\n            i++;\\n        }\\n        return window;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "Only thing we have to keep in mind that *We have to find the longest substring where maximum repeating character satisfy this condition*\\n**Size of curWindow-maxFreq of character<=K**\\nBecause we can replace at max K character at any time \\n**Please Upvote the solution if you find it useful**\\n```\\nint findMax(int count[])\\n    {\\n        int m=0;\\n        for(int i=0;i<26;i++)\\n            m=max(m,count[i]);\\n        return m;\\n    }\\n    \\n    int characterReplacement(string s, int k) {\\n        int n=s.size();\\n        int count[26]={0};\\n        int l=0;\\n        int i=0;\\n        int maxFreq=0;    // Character which is repeating at most in our proper curWindow\\n        int window=0;     // Output Window\\n        int curWindow=0;  // Proper or Current Window\\n        while(i<n)\\n        {\\n            count[s[i]-\\'A\\']++;\\n            if(count[s[i]-\\'A\\']>maxFreq)\\n            {\\n                maxFreq=count[s[i]-\\'A\\'];\\n                \\n            }\\n            \\n            curWindow=i-l+1;    // Curreent size\\n           \\n            while(l<n&& curWindow-maxFreq>k)   \\n                {\\n                   count[s[l]-\\'A\\']--;\\n                   maxFreq=findMax(count);\\n                   l++;\\n                   curWindow=i-l+1;\\n                }\\n             window=max(curWindow,window);     \\n           \\n            i++;\\n        }\\n        return window;\\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 418727,
                "title": "easy-to-understand-c-solution",
                "content": "Runtime: 28 ms, faster than 27.48% of C++ online submissions for Longest Repeating Character Replacement.\\nMemory Usage: 9.3 MB, less than 65.52% of C++ online submissions for Longest Repeating Character Replacement.\\n\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        \\n        int maxLen = 0;\\n        vector<int> freq(26,0);\\n        \\n        for(int i=0, j=0; j<s.size(); j++)\\n        {\\n            freq[s[j]-\\'A\\']++;\\n            while(!isValid(freq,k))\\n            {\\n                freq[s[i++] - \\'A\\']--;\\n            }\\n            maxLen = max(maxLen, j - i + 1);\\n        }\\n        return maxLen;\\n    }\\n    \\n    bool isValid(vector<int>& freq, int k)\\n    {\\n        int sum = 0;\\n        int maxFreq = 0;\\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            sum += freq[i];\\n            maxFreq = max(maxFreq, freq[i]);\\n        }\\n        return sum - maxFreq <= k;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        \\n        int maxLen = 0;\\n        vector<int> freq(26,0);\\n        \\n        for(int i=0, j=0; j<s.size(); j++)\\n        {\\n            freq[s[j]-\\'A\\']++;\\n            while(!isValid(freq,k))\\n            {\\n                freq[s[i++] - \\'A\\']--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3130935,
                "title": "java-very-easy-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        HashMap<Character,Integer>map=new HashMap<>();\\n        int start=0;\\n        int maxCountRepeatingCh=0;\\n        int maxLength=0;\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            maxCountRepeatingCh=Math.max(maxCountRepeatingCh,map.get(s.charAt(i)));\\n\\n            while(i-start+1-maxCountRepeatingCh>k){\\n                map.put(s.charAt(start),map.get(s.charAt(start))-1);\\n                start++;\\n            }\\n\\n            maxLength=Math.max(maxLength,i-start+1);\\n\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        HashMap<Character,Integer>map=new HashMap<>();\\n        int start=0;\\n        int maxCountRepeatingCh=0;\\n        int maxLength=0;\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            maxCountRepeatingCh=Math.max(maxCountRepeatingCh,map.get(s.charAt(i)));\\n\\n            while(i-start+1-maxCountRepeatingCh>k){\\n                map.put(s.charAt(start),map.get(s.charAt(start))-1);\\n                start++;\\n            }\\n\\n            maxLength=Math.max(maxLength,i-start+1);\\n\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130445,
                "title": "sliding-window-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int[] arr = new int[26];\\n        int largestCount = 0, start = 0, maxlen = 0;\\n        for(int end = 0; end < s.length(); end ++){\\n            arr[s.charAt(end) - \\'A\\']++;\\n            // largestCount = unique character in the current window...\\n            largestCount = Math.max(largestCount, arr[s.charAt(end) - \\'A\\']);\\n            if(end - start + 1 - largestCount > k){ \\n                arr[s.charAt(start) - \\'A\\']--;\\n                start ++;\\n            }\\n            // maxlen = maximum length of repeating character & end - start + 1 = size of the current window...\\n            maxlen = Math.max(maxlen, end - start + 1);\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int[] arr = new int[26];\\n        int largestCount = 0, start = 0, maxlen = 0;\\n        for(int end = 0; end < s.length(); end ++){\\n            arr[s.charAt(end) - \\'A\\']++;\\n            // largestCount = unique character in the current window...\\n            largestCount = Math.max(largestCount, arr[s.charAt(end) - \\'A\\']);\\n            if(end - start + 1 - largestCount > k){ \\n                arr[s.charAt(start) - \\'A\\']--;\\n                start ++;\\n            }\\n            // maxlen = maximum length of repeating character & end - start + 1 = size of the current window...\\n            maxlen = Math.max(maxlen, end - start + 1);\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905786,
                "title": "needcode-s-solution-in-golang-way-with-explanation-beats-92-5",
                "content": "```\\nfunc characterReplacement(s string, k int) int {\\n\\t// We can also use a  count := make([]int, 91) and it will do exact same Job (\"Z\"\\'s ASCII value is 90)\\n    count := make(map[byte]int)\\n    res, maxf, left := 0, 0, 0\\n\\t\\n    for right := 0; right < len(s); right++ {\\n        count[s[right]] += 1    // s[right] will return a byte. Incase we used slice instead of hashmap this byte is the same as that element\\'s position in the count slice\\n\\n        maxf = max(maxf, count[s[right]])\\n        \\n        // Move left pointer\\n        if (right - left + 1) - maxf > k  {\\n            count[s[left]] -= 1  // When we decrement, we dont have to update max variable as reducing max variable wont have any effect on end result\\n            left += 1\\n        }\\n\\n        res = max(res, right - left + 1)\\n    }\\n\\n    return res\\n}\\n\\nfunc max(a,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nfunc characterReplacement(s string, k int) int {\\n\\t// We can also use a  count := make([]int, 91) and it will do exact same Job (\"Z\"\\'s ASCII value is 90)\\n    count := make(map[byte]int)\\n    res, maxf, left := 0, 0, 0\\n\\t\\n    for right := 0; right < len(s); right++ {\\n        count[s[right]] += 1    // s[right] will return a byte. Incase we used slice instead of hashmap this byte is the same as that element\\'s position in the count slice\\n\\n        maxf = max(maxf, count[s[right]])\\n        \\n        // Move left pointer\\n        if (right - left + 1) - maxf > k  {\\n            count[s[left]] -= 1  // When we decrement, we dont have to update max variable as reducing max variable wont have any effect on end result\\n            left += 1\\n        }\\n\\n        res = max(res, right - left + 1)\\n    }\\n\\n    return res\\n}\\n\\nfunc max(a,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2566116,
                "title": "python-solution-explained",
                "content": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int: \\n        d={} #to calculate the frquency of elements present in the particular substring or sliding window\\n        a=0 #for counting the length of the longest substring\\n        l=0 #the left pointer (starts from the left index of the s)\\n        for r in range(len(s)): # r is taken as the right pointer and it will go to the end of the substring or sliding window which will be chosen\\n            #now calulating te frequency of the elements present in the particular chosen substring\\n            if s[r] in d: \\n                d[s[r]]+=1 \\n            else: \\n                d[s[r]]=1 \\n            #now checking how many less fequency element present in d so that it can be replaced and converted to the max frequency element\\n            # (r-l+1) indicates the total length of the sliding window chosen\\n            #max(d.values() it takes the maximum frequency element so that after subtracting\\n            #it from the length of the sliding window can give how many elements need to\\n            #be converted into max frequency elements (it should be greater than k)\\n            while (r-l+1)-max(d.values()) >k: \\n                #if greater than k then the current window will move one step forward and \\n                #the starting of the element of the window need to be decrement by 1\\n                #as its frequency will decrement once its gone from window\\n                d[s[l]]-=1\\n                l+=1 \\n                #moving forward the left pointer(shifting window forward) \\n            #a storing the length of longest substring\\n            a=max(a,r-l+1) \\n        return a\\n        \\n``` \\n**Please upvote if you found it helpful**",
                "solutionTags": [
                    "Python",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int: \\n        d={} #to calculate the frquency of elements present in the particular substring or sliding window\\n        a=0 #for counting the length of the longest substring\\n        l=0 #the left pointer (starts from the left index of the s)\\n        for r in range(len(s)): # r is taken as the right pointer and it will go to the end of the substring or sliding window which will be chosen\\n            #now calulating te frequency of the elements present in the particular chosen substring\\n            if s[r] in d: \\n                d[s[r]]+=1 \\n            else: \\n                d[s[r]]=1 \\n            #now checking how many less fequency element present in d so that it can be replaced and converted to the max frequency element\\n            # (r-l+1) indicates the total length of the sliding window chosen\\n            #max(d.values() it takes the maximum frequency element so that after subtracting\\n            #it from the length of the sliding window can give how many elements need to\\n            #be converted into max frequency elements (it should be greater than k)\\n            while (r-l+1)-max(d.values()) >k: \\n                #if greater than k then the current window will move one step forward and \\n                #the starting of the element of the window need to be decrement by 1\\n                #as its frequency will decrement once its gone from window\\n                d[s[l]]-=1\\n                l+=1 \\n                #moving forward the left pointer(shifting window forward) \\n            #a storing the length of longest substring\\n            a=max(a,r-l+1) \\n        return a\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346350,
                "title": "c-easy-sliding-window-map-o-n",
                "content": "class Solution {\\npublic:\\n\\n    // Sliding Window and Map Approach\\n    // Time Complexity:- O(N)\\n    // Space Complexity:- O(N)\\n    \\n    int characterReplacement(string s, int k) {\\n        int maxFreq=0;    // For storing max frequency character\\n        int st=0;         // Starting point of sliding window\\n        int maxi=0;       // For storing max length subarray\\n        map<char,int> mp; // Map for maintaing frequency of each character\\n        \\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n            \\n            maxFreq=max(maxFreq,mp[s[i]]);\\n            \\n            if(((i-st+1)-maxFreq)>k){\\n                mp[s[st]]--;  \\n                \\n                st++;\\n            }\\n            \\n            maxi=max(maxi,i-st+1);\\n        }\\n        \\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    // Sliding Window and Map Approach\\n    // Time Complexity:- O(N)\\n    // Space Complexity:- O(N)\\n    \\n    int characterReplacement(string s, int k) {\\n        int maxFreq=0;    // For storing max frequency character\\n        int st=0;         // Starting point of sliding window\\n        int maxi=0;       // For storing max length subarray\\n        map<char,int> mp; // Map for maintaing frequency of each character\\n        \\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n            \\n            maxFreq=max(maxFreq,mp[s[i]]);\\n            \\n            if(((i-st+1)-maxFreq)>k){\\n                mp[s[st]]--;  \\n                \\n                st++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2053753,
                "title": "please-read-key-observation-on-why-the-o-n-solution-works-without-o-26-getmax",
                "content": "I would like to add a key observation on why this works and most importantly, why the inner `while` that you see in other solutions should be replaced with an `if` instead. No offense to anyone, but I think whoever uses an inner `while` loop has not fully understood the algorithm. That loop is executed at most once anyway, and understanding why is important in order to explain the algorithm to the interviewer successfully.\\n\\nOnce we get a **valid, new and longer** window two things can happen at the next iteration:\\n\\n* we can get a even longer window, and in this case things are straigforward. The `maxFreq` will be equal to the `maxFreq` of the previous iteration `+1`. Why? We can extend the string only by adding a character that is the same as the most frequent one, otherwise we break the window rule.\\n\\n* we are not able to extend the window. So are we going to shrink it now and make it valid again? **NO!**. I bet that\\'s what most of the people think when they see that inner `while` loop. In fact they ask why isn\\'t the `maxFreq` updated? What happens instead, is that we want to move the window just one step to the right. When we increment both `left` and `right` by one, we basically keep the window of the same size and slide it by one step.\\n\\n\\nYou might ask now two questions:\\n\\n* Why moving one step to the right is enough (without shrinking the window)? Answer: We have a \"longest\" window already so finding another one of the same size is not helpful. Yeah, we might shrink the window, then extend it, then find another window of the same size as `longest` but in the end we will see no improvement as long as it it\\'s just as long as `longest`.\\n\\n* Ok, so you are going to keep the window of the same size and move it to the right. Isn\\'t there a risk at some point to have characters in your window that break the rule of \"at most k replacements\"? Answer: Yes, we might have an invalid window of size `longest` but the good news is that this is not \"harmful\" for us. The `Math.max` statement has no effect if we keep doing `Math.max(longest, longest)`.  However, **once the window will move enough to the right to become valid again, we will be able to extend it (if possible)**.  In other words, we will only extend a **valid** window. That\\'s why shrinking the window is not necessary, because we want to find **another window that is just as long `longest` AND that can be extended**.\\n\\nHope this was helpful and made the algorithm more intuitive for you :)\\n\\nFinally, here is the code\\n\\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int freq[] = new int[\\'Z\\' - \\'A\\' + 1];\\n        int left = 0, right = 0, longest = 0, maxFreq = 0;\\n        \\n        while(right < s.length()) {\\n            char rightChar = s.charAt(right);\\n            freq[rightChar - \\'A\\']++;\\n            maxFreq = Math.max(maxFreq, freq[rightChar - \\'A\\']);\\n            right++;\\n            \\n            if(right - left - maxFreq <= k) {\\n                longest = Math.max(longest, right - left);\\n            }\\n            \\n            if(right - left - maxFreq > k) {\\n                char leftChar = s.charAt(left);\\n                freq[leftChar - \\'A\\']--;\\n                left++;\\n            }\\n        }\\n        \\n        return longest;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int freq[] = new int[\\'Z\\' - \\'A\\' + 1];\\n        int left = 0, right = 0, longest = 0, maxFreq = 0;\\n        \\n        while(right < s.length()) {\\n            char rightChar = s.charAt(right);\\n            freq[rightChar - \\'A\\']++;\\n            maxFreq = Math.max(maxFreq, freq[rightChar - \\'A\\']);\\n            right++;\\n            \\n            if(right - left - maxFreq <= k) {\\n                longest = Math.max(longest, right - left);\\n            }\\n            \\n            if(right - left - maxFreq > k) {\\n                char leftChar = s.charAt(left);\\n                freq[leftChar - \\'A\\']--;\\n                left++;\\n            }\\n        }\\n        \\n        return longest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953541,
                "title": "python-sliding-window",
                "content": "```\\nfrom collections import defaultdict\\n\\ndef replace(s, k):\\n    count = defaultdict(int)\\n    back = 0\\n    for front, char in enumerate(s):\\n        count[char] += 1\\n        if front - back + 1 > k + max(count.values()):\\n            count[s[back]] -= 1\\n            back += 1\\n    return front - back + 1\\n```\\n\\nUpdate: Attention! The above solution has bad complexity O(25*n) because of max(count.values())\\n\\nThe following fix gives O(n), beats 99%:\\n```\\nfrom collections import defaultdict\\n\\ndef replace(s, k):\\n    d = defaultdict(int)\\n    back = max_count = 0\\n    for front, char in enumerate(s):\\n        d[char] += 1\\n        max_count = max(d[char], max_count)\\n        if front - back + 1 > k + max_count:\\n            d[s[back]] -= 1\\n            back += 1\\n    return front - back + 1\\n\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\ndef replace(s, k):\\n    count = defaultdict(int)\\n    back = 0\\n    for front, char in enumerate(s):\\n        count[char] += 1\\n        if front - back + 1 > k + max(count.values()):\\n            count[s[back]] -= 1\\n            back += 1\\n    return front - back + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1846543,
                "title": "sliding-window-pattern",
                "content": "This problem follows the Sliding Window pattern and we can use a dynamic sliding window strategy to solve it.\\n\\nHere, in the code below, we\\'ll iterate through the string to add one letter at a time in the window. We\\u2019ll also keep track of the count of the maximum repeating letter in any window as **max_char_count**. So at any time, we know that we can have a window which has one letter repeating **max_char_count** times, this means we should try to replace the remaining letters. If we have more than **\\u2018k\\u2019** remaining letters, we will shrink the window as we are not allowed to replace more than **\\u2018k\\u2019** letters. \\n \\n```\\n\\tdef characterReplacement(self, s: str, k: int) -> int:\\n        win_start, max_length, max_char_count = 0, 0, 0\\n        freq = {}\\n        \\n        for win_end in range(len(s)):\\n            \\n            right_char = s[win_end]\\n            if right_char not in freq:\\n                freq[right_char] = 0\\n            freq[right_char] += 1\\n            \\n            max_char_count = max(max_char_count, freq[right_char])\\n            \\n            if (win_end - win_start + 1 - max_char_count) > k:\\n                left_char = s[win_start]\\n                freq[left_char] -= 1\\n                win_start += 1\\n            \\n            max_length = max(max_length, win_end - win_start + 1)\\n        \\n        return max_length\\n```\\n\\nThe time complexity of the above algorithm will be **O(N)** where **\\u2018N\\u2019** is the number of letters in the input string.",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n\\tdef characterReplacement(self, s: str, k: int) -> int:\\n        win_start, max_length, max_char_count = 0, 0, 0\\n        freq = {}\\n        \\n        for win_end in range(len(s)):\\n            \\n            right_char = s[win_end]\\n            if right_char not in freq:\\n                freq[right_char] = 0\\n            freq[right_char] += 1\\n            \\n            max_char_count = max(max_char_count, freq[right_char])\\n            \\n            if (win_end - win_start + 1 - max_char_count) > k:\\n                left_char = s[win_start]\\n                freq[left_char] -= 1\\n                win_start += 1\\n            \\n            max_length = max(max_length, win_end - win_start + 1)\\n        \\n        return max_length\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1781894,
                "title": "java-sliding-window-o-n",
                "content": "Time: O(n)\\nSpace: O(26) = O(1)\\n```\\npublic int characterReplacement(String s, int k) {\\n        int [] window = new int[26];\\n        \\n        int ans = 0;\\n        int maxFreqChar = 0;\\n        int left = 0, right = 0;\\n        \\n        while (right < s.length()) {\\n            char c = s.charAt(right++);\\n\\t\\t\\twindow[c-\\'A\\']++;\\n            maxFreqChar = Math.max(maxFreqChar, window[c-\\'A\\']);\\n            \\n            // it\\'s only to shrink the window by one\\n            // so we can make at most k replacements \\n            if (right-left-maxFreqChar  > k)  {\\n\\t\\t\\t\\tc = s.charAt(left++);\\n                window[c-\\'A\\']--;\\n\\t\\t\\t}\\n            ans = Math.max(ans, right-left);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\npublic int characterReplacement(String s, int k) {\\n        int [] window = new int[26];\\n        \\n        int ans = 0;\\n        int maxFreqChar = 0;\\n        int left = 0, right = 0;\\n        \\n        while (right < s.length()) {\\n            char c = s.charAt(right++);\\n\\t\\t\\twindow[c-\\'A\\']++;\\n            maxFreqChar = Math.max(maxFreqChar, window[c-\\'A\\']);\\n            \\n            // it\\'s only to shrink the window by one\\n            // so we can make at most k replacements \\n            if (right-left-maxFreqChar  > k)  {\\n\\t\\t\\t\\tc = s.charAt(left++);\\n                window[c-\\'A\\']--;\\n\\t\\t\\t}\\n            ans = Math.max(ans, right-left);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1536954,
                "title": "python-o-n-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        mapping = defaultdict(int) #map for each character and its count\\n        i, j = 0, 0\\n        res = 0\\n        \\n        while j < len(s):\\n\\t\\t\\t#increment count of current character\\n            mapping[s[j]] += 1\\n            \\n\\t\\t\\t#if the total of all seen characters - max of all seen characters is greater than k,\\n\\t\\t\\t#it means we have utilized all k replacements and we will have to move the left pointer \\n\\t\\t\\t#until there are more replacements available\\n            while sum(mapping.values()) - max(mapping.values()) > k:\\n                mapping[s[i]] -= 1\\n                i += 1\\n                \\n\\t\\t\\t#update the max length at every stage\\n            res = max(res, j - i + 1)\\n            j += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        mapping = defaultdict(int) #map for each character and its count\\n        i, j = 0, 0\\n        res = 0\\n        \\n        while j < len(s):\\n\\t\\t\\t#increment count of current character\\n            mapping[s[j]] += 1\\n            \\n\\t\\t\\t#if the total of all seen characters - max of all seen characters is greater than k,\\n\\t\\t\\t#it means we have utilized all k replacements and we will have to move the left pointer \\n\\t\\t\\t#until there are more replacements available\\n            while sum(mapping.values()) - max(mapping.values()) > k:\\n                mapping[s[i]] -= 1\\n                i += 1\\n                \\n\\t\\t\\t#update the max length at every stage\\n            res = max(res, j - i + 1)\\n            j += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327742,
                "title": "c-solution-using-sliding-window-pattern-o-n-time-complexity",
                "content": "``` \\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int windowStart = 0, maxLength = 0, maxRepeatLetter = 0;\\n        unordered_map<char, int> dict;\\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char currChar = s[windowEnd];\\n            dict[currChar]++;\\n            maxRepeatLetter = max(maxRepeatLetter, dict[currChar]);\\n            if ((windowEnd - windowStart + 1 - maxRepeatLetter) > k) {\\n                char leftChar = s[windowStart];\\n                dict[leftChar]--;\\n                windowStart++;\\n            }\\n            maxLength = max(maxLength, windowEnd - windowStart + 1);\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int windowStart = 0, maxLength = 0, maxRepeatLetter = 0;\\n        unordered_map<char, int> dict;\\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char currChar = s[windowEnd];\\n            dict[currChar]++;\\n            maxRepeatLetter = max(maxRepeatLetter, dict[currChar]);\\n            if ((windowEnd - windowStart + 1 - maxRepeatLetter) > k) {\\n                char leftChar = s[windowStart];\\n                dict[leftChar]--;\\n                windowStart++;\\n            }\\n            maxLength = max(maxLength, windowEnd - windowStart + 1);\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519566,
                "title": "c-with-thought-process",
                "content": "First, think about brute force: for each window (i, j), find the major element and check if there is no more than k other elements. The answers is to take the maximum over all O(n^2) windows. \\n\\nSecond, improve the brute forece. For each j, there will be an \"optimal\" but valid window. What is the relationship between the optimal window of j and that of j+1? If s[j+1] is major element, increase the window length by 1; if not, the window may not be valid, and i should be increased.  Initially, i = 0 and slide j to the right, keeping a record on the maximum frequency. Upon the condition \"other elements <= k\" violated, we move i to the right by one step, keeping the length of the window. After this move, there is at most k + 1 other elements in the window. \\n\\nThis leads to a dynamic programming flavored sliding window algorithm, where the value function is the the widest window length by element j. On each step, take the maximum of (1) previous best, and (2) the best ending at j. \\n\\nTherefore, this algorithm is a simplification on dynamic programming, just like Kadane\\'s algorithm. Indeed, its logic is similar to Kadane\\'s algorithm. \\n\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int cnt[26] = {}; \\n        int ans = 0, major = 0; \\n        for (int i = 0, j = 0; j < s.size(); ++j){\\n            major = max(major, ++cnt[s[j] - \\'A\\']); \\n            if (j - i + 1 > k + major) \\n                cnt[s[i] - \\'A\\']--, i++; \\n            ans = max(j - i + 1, ans);\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int cnt[26] = {}; \\n        int ans = 0, major = 0; \\n        for (int i = 0, j = 0; j < s.size(); ++j){\\n            major = max(major, ++cnt[s[j] - \\'A\\']); \\n            if (j - i + 1 > k + major) \\n                cnt[s[i] - \\'A\\']--, i++; \\n            ans = max(j - i + 1, ans);\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357966,
                "title": "sliding-window-with-clear-explanations-python",
                "content": "I looked at some of the most voted solutions and I find them hard to understand at first glance. Here is my solution and clarification as follows. Hope it helps anyone who are confused.\\n\\nVariables:\\n1. left, right: two endpoints of our sliding window\\n2. res: longest repeating characters found so far, by using less than or equal to k replacements.\\n3. d: counts of all elements in the current sliding window\\n4. right - left + 1 - max_freq : the remaining elements besides the elements with most counts\\n\\nKey:\\nMove left endpoint when we have more than k remaining elements, because we cannot make this window of the same character any more.\\n\\nThe code: O(N) time. O(N) space.\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        left = right = 0\\n        res = 0\\n\\t\\t\\n        # count for the sliding window\\n        d = collections.Counter()\\n        max_freq = 0\\n\\t\\t\\n        while right < len(s):\\n            d[s[right]] += 1\\n            max_freq = max(max_freq, d[s[right]])\\n            while right - left + 1 - max_freq > k:\\n                d[s[left]] -= 1\\n                left += 1\\n            res = max(res, right - left + 1)\\n            right += 1\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        left = right = 0\\n        res = 0\\n\\t\\t\\n        # count for the sliding window\\n        d = collections.Counter()\\n        max_freq = 0\\n\\t\\t\\n        while right < len(s):\\n            d[s[right]] += 1\\n            max_freq = max(max_freq, d[s[right]])\\n            while right - left + 1 - max_freq > k:\\n                d[s[left]] -= 1\\n                left += 1\\n            res = max(res, right - left + 1)\\n            right += 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475021,
                "title": "java-sliding-window-o-n-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int maxWindow = 0;\\n        int left = 0;\\n        int maxRepeat = 0;\\n\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int right = 0; right < s.length(); right++) {\\n            char curr = s.charAt(right);\\n            map.put(curr, map.getOrDefault(curr, 0) + 1);            \\n            maxRepeat = Math.max(maxRepeat, map.get(curr));\\n            if(right - left - maxRepeat >= k) {\\n                char remove = s.charAt(left);\\n                map.put(remove, map.get(remove) -1);\\n                left ++;\\n            }\\n            maxWindow = Math.max(maxWindow, right - left + 1);\\n\\n        }\\n        return maxWindow;\\n    }\\n}\\n```\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/89022d1a-0437-4062-898c-60d13d9d40ea_1682969608.037905.png)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int maxWindow = 0;\\n        int left = 0;\\n        int maxRepeat = 0;\\n\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int right = 0; right < s.length(); right++) {\\n            char curr = s.charAt(right);\\n            map.put(curr, map.getOrDefault(curr, 0) + 1);            \\n            maxRepeat = Math.max(maxRepeat, map.get(curr));\\n            if(right - left - maxRepeat >= k) {\\n                char remove = s.charAt(left);\\n                map.put(remove, map.get(remove) -1);\\n                left ++;\\n            }\\n            maxWindow = Math.max(maxWindow, right - left + 1);\\n\\n        }\\n        return maxWindow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739209,
                "title": "java-hashmap-frequency-array-sliding-window",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = 0;\\n\\n        int maxLen = 0, mostFreq = 0;\\n\\n        while (right < s.length()) {\\n            // start acquiring\\n            map.put(arr[right], map.getOrDefault(arr[right], 0) + 1);\\n            mostFreq = Math.max(mostFreq, map.get(arr[right]));\\n\\n            int canBeReplaced = (right - left + 1) - mostFreq;\\n\\n            // release from the left\\n            if (canBeReplaced > k) {\\n                map.put(arr[left], map.get(arr[left]) - 1);\\n                left++;\\n            }\\n\\n            maxLen = Math.max(maxLen, right - left + 1);\\n            right++;\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n##### Same solution but using frequency array instead:\\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int[] freq = new int[26];\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = 0;\\n\\n        int maxLen = 0, mostFreq = 0;\\n\\n        while (right < s.length()) {\\n            mostFreq = Math.max(mostFreq, ++freq[arr[right] - \\'A\\']);\\n            int canBeReplaced = (right - left + 1) - mostFreq;\\n\\n            if (canBeReplaced > k) {\\n                freq[arr[left++] - \\'A\\']--;\\n            }\\n\\n            maxLen = Math.max(maxLen, right - left + 1);\\n            right++;\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = 0;\\n\\n        int maxLen = 0, mostFreq = 0;\\n\\n        while (right < s.length()) {\\n            // start acquiring\\n            map.put(arr[right], map.getOrDefault(arr[right], 0) + 1);\\n            mostFreq = Math.max(mostFreq, map.get(arr[right]));\\n\\n            int canBeReplaced = (right - left + 1) - mostFreq;\\n\\n            // release from the left\\n            if (canBeReplaced > k) {\\n                map.put(arr[left], map.get(arr[left]) - 1);\\n                left++;\\n            }\\n\\n            maxLen = Math.max(maxLen, right - left + 1);\\n            right++;\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int[] freq = new int[26];\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = 0;\\n\\n        int maxLen = 0, mostFreq = 0;\\n\\n        while (right < s.length()) {\\n            mostFreq = Math.max(mostFreq, ++freq[arr[right] - \\'A\\']);\\n            int canBeReplaced = (right - left + 1) - mostFreq;\\n\\n            if (canBeReplaced > k) {\\n                freq[arr[left++] - \\'A\\']--;\\n            }\\n\\n            maxLen = Math.max(maxLen, right - left + 1);\\n            right++;\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702208,
                "title": "simple-o-n-time-o-1-space-java-solution",
                "content": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) \\n    {\\n        int[] chars = new int[26];\\n        \\n        int max =0,count=0,start=0;\\n        \\n        for(int end =0; end<s.length();end++)\\n        {\\n            chars[s.charAt(end) - \\'A\\']++;\\n            int current = chars[s.charAt(end) - \\'A\\'];\\n            count = Math.max(count , current);\\n            \\n            while(end - start - count +1 > k)\\n            {\\n                chars[s.charAt(start) - \\'A\\']--;\\n                start++;\\n            }\\n            max = Math.max(max , end-start+1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) \\n    {\\n        int[] chars = new int[26];\\n        \\n        int max =0,count=0,start=0;\\n        \\n        for(int end =0; end<s.length();end++)\\n        {\\n            chars[s.charAt(end) - \\'A\\']++;\\n            int current = chars[s.charAt(end) - \\'A\\'];\\n            count = Math.max(count , current);\\n            \\n            while(end - start - count +1 > k)\\n            {\\n                chars[s.charAt(start) - \\'A\\']--;\\n                start++;\\n            }\\n            max = Math.max(max , end-start+1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659582,
                "title": "c-commented-sliding-window-simple-and-easy-to-understand",
                "content": "I highly encourage you to solve this problem ([2024. Maximize the Confusion of an Exam](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/)) yourself using sliding window as this is the easier version of this question. \\n```\\nclass Solution {\\npublic:\\n    int helper(string s,int k,char ch)\\n    {\\n\\t// Sliding Window method\\n        int i=0; // Intializing the value to traverse this acts as the right end of window \\n        int count = 0; // To count the length \\n        int j =0; // This acts as the left end of window\\n        int n = s.length();\\n        while(i<n){\\n\\t\\t// If we have K(we can use K to change s[i] to ch ) or the char s[i] is equal to ch then we traverse the string further \\n            while(i<n && (k||s[i]==ch))\\n            {\\n                if(s[i]!=ch){\\n                    k--;\\n                }\\n                i++;\\n            }\\n            count= max(count,i-j);// Total length\\n\\t\\t\\t// Now we have a window from j to i so, slide this window by increasing j \\n\\t\\t\\t//if s[j] is not equal to ch then we used 1k to convert this to ch so \\n\\t\\t\\t//we get back this value of k as we are checking the next window. Similarly, loop goes...... \\n            if(s[j]!=ch){  \\n                k++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n    int characterReplacement(string s, int k) {\\n        int ans = INT_MIN;\\n\\t\\t// Checking length for all the alphabet (A-Z) \\n        for(int i=0;i<26;i++)\\n        {\\n            ans = max(ans,helper(s,k,\\'A\\'+i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string s,int k,char ch)\\n    {\\n\\t// Sliding Window method\\n        int i=0; // Intializing the value to traverse this acts as the right end of window \\n        int count = 0; // To count the length \\n        int j =0; // This acts as the left end of window\\n        int n = s.length();\\n        while(i<n){\\n\\t\\t// If we have K(we can use K to change s[i] to ch ) or the char s[i] is equal to ch then we traverse the string further \\n            while(i<n && (k||s[i]==ch))\\n            {\\n                if(s[i]!=ch){\\n                    k--;\\n                }\\n                i++;\\n            }\\n            count= max(count,i-j);// Total length\\n\\t\\t\\t// Now we have a window from j to i so, slide this window by increasing j \\n\\t\\t\\t//if s[j] is not equal to ch then we used 1k to convert this to ch so \\n\\t\\t\\t//we get back this value of k as we are checking the next window. Similarly, loop goes...... \\n            if(s[j]!=ch){  \\n                k++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n    int characterReplacement(string s, int k) {\\n        int ans = INT_MIN;\\n\\t\\t// Checking length for all the alphabet (A-Z) \\n        for(int i=0;i<26;i++)\\n        {\\n            ans = max(ans,helper(s,k,\\'A\\'+i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2559188,
                "title": "java-solution-with-explanation-o-n-solution",
                "content": "```\\nclass Solution {\\n\\n    public int characterReplacement(String s, int k) {\\n        // get a character counter array\\n        int[] arr = new int[26];\\n        int ans = 0;\\n        int max = 0;\\n        int left = 0;\\n        for (int right = 0; right < s.length(); right++) {\\n            // increase every right character count in the array\\n            arr[s.charAt(right) - \\'A\\']++;\\n            // find max between current max and the count of right character\\n            max = Math.max(max, arr[s.charAt(right) - \\'A\\']);\\n            // see if ( right - left + 1 )[total sliding window length] \\n            //           - max count of right character is greater than \\'k\\'\\n            if (right - left + 1 - max > k) {\\n                // if not then reduce left count and slide right(add one to left window) \\n                arr[s.charAt(left) - \\'A\\']--;\\n                left++;\\n            }\\n            // ans = ans or windowSize (whichever is greater)\\n            ans = Math.max(ans, right - left + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int characterReplacement(String s, int k) {\\n        // get a character counter array\\n        int[] arr = new int[26];\\n        int ans = 0;\\n        int max = 0;\\n        int left = 0;\\n        for (int right = 0; right < s.length(); right++) {\\n            // increase every right character count in the array\\n            arr[s.charAt(right) - \\'A\\']++;\\n            // find max between current max and the count of right character\\n            max = Math.max(max, arr[s.charAt(right) - \\'A\\']);\\n            // see if ( right - left + 1 )[total sliding window length] \\n            //           - max count of right character is greater than \\'k\\'\\n            if (right - left + 1 - max > k) {\\n                // if not then reduce left count and slide right(add one to left window) \\n                arr[s.charAt(left) - \\'A\\']--;\\n                left++;\\n            }\\n            // ans = ans or windowSize (whichever is greater)\\n            ans = Math.max(ans, right - left + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537328,
                "title": "python-o-n-and-o-1-with-list-and-explanation",
                "content": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        if len(s) == 1:\\n            return 1\\n        \\n        l, r, max_length, max_num_of_repeating_char = 0, 0, 0, 0\\n        char_count_list = [0] * 26\\n        \\n        for char in s:\\n            # Find the char index and increment the count of this char in the list\\n            char_index = ord(char) - ord(\\'A\\')\\n            char_count_list[char_index] += 1\\n            \\n            # Every time the count of a char is incremented, check to see if it\\'s the leading repeated char\\n            max_num_of_repeating_char = max(max_num_of_repeating_char, char_count_list[char_index])\\n            \\n            # Find the number of character to replace by subtracting the count of the repeating char from the length of the current window\\n            #                    The length of the current window -> r - l + 1\\n            # If: the number of char needed to be replaced is <= the total number of replacement k, update the max_length\\n            # Else: move the left pointer 1 unit to the right but before that, decrement the count of the char l is currently looking at\\n            num_of_char_to_replace = (r - l + 1) - max_num_of_repeating_char\\n            if num_of_char_to_replace <= k:\\n                max_length = (r - l + 1)\\n            else:\\n                char_count_list[ord(s[l]) - ord(\\'A\\')] -= 1\\n                l += 1\\n            \\n            r += 1\\n            \\n        return max_length\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        if len(s) == 1:\\n            return 1\\n        \\n        l, r, max_length, max_num_of_repeating_char = 0, 0, 0, 0\\n        char_count_list = [0] * 26\\n        \\n        for char in s:\\n            # Find the char index and increment the count of this char in the list\\n            char_index = ord(char) - ord(\\'A\\')\\n            char_count_list[char_index] += 1\\n            \\n            # Every time the count of a char is incremented, check to see if it\\'s the leading repeated char\\n            max_num_of_repeating_char = max(max_num_of_repeating_char, char_count_list[char_index])\\n            \\n            # Find the number of character to replace by subtracting the count of the repeating char from the length of the current window\\n            #                    The length of the current window -> r - l + 1\\n            # If: the number of char needed to be replaced is <= the total number of replacement k, update the max_length\\n            # Else: move the left pointer 1 unit to the right but before that, decrement the count of the char l is currently looking at\\n            num_of_char_to_replace = (r - l + 1) - max_num_of_repeating_char\\n            if num_of_char_to_replace <= k:\\n                max_length = (r - l + 1)\\n            else:\\n                char_count_list[ord(s[l]) - ord(\\'A\\')] -= 1\\n                l += 1\\n            \\n            r += 1\\n            \\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508523,
                "title": "easy-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int[] count=new int[26];\\n        int res=0 ,maxCount=0,l=0;\\n        //l = left, r = right\\n        //(r-l+1) window size\\n        for(int r=0;r< s.length(); r++){\\n            \\n            //to calc most occuring char\\n            //increase the count of the char at the pos\\n            //max of maxCount and count of that char\\n            maxCount= Math.max(maxCount, ++count[s.charAt(r)-\\'A\\']);\\n            \\n            //window size - maxCount = number of char to be replaced\\n            while((r-l+1) - maxCount > k){\\n                \\n                //decrease count of that char and decrease window size\\n                count[s.charAt(l)-\\'A\\']--;\\n                l++;\\n                \\n            }\\n            \\n            //max of window\\n            res= Math.max(res, r-l+1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int[] count=new int[26];\\n        int res=0 ,maxCount=0,l=0;\\n        //l = left, r = right\\n        //(r-l+1) window size\\n        for(int r=0;r< s.length(); r++){\\n            \\n            //to calc most occuring char\\n            //increase the count of the char at the pos\\n            //max of maxCount and count of that char\\n            maxCount= Math.max(maxCount, ++count[s.charAt(r)-\\'A\\']);\\n            \\n            //window size - maxCount = number of char to be replaced\\n            while((r-l+1) - maxCount > k){\\n                \\n                //decrease count of that char and decrease window size\\n                count[s.charAt(l)-\\'A\\']--;\\n                l++;\\n                \\n            }\\n            \\n            //max of window\\n            res= Math.max(res, r-l+1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497159,
                "title": "o-n-hashmap-sliding-window-python",
                "content": "# **Sliding window**\\n\\n**Complexity**\\n* Time: O(26n) = O(n)\\n* Space: O(n)\\n\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        res = 0\\n        left = 0\\n        count = {}\\n        \\n        for right in range(len(s)):\\n            count[s[right]] = 1 + count.get(s[right], 0)\\n\\n            # Check this is a valid window\\n\\t\\t\\twhile (right - left + 1) - max(count.values()) > k:\\n                count[s[left]] -= 1\\n                left += 1\\n            \\n            res = max(res, right - left + 1)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        res = 0\\n        left = 0\\n        count = {}\\n        \\n        for right in range(len(s)):\\n            count[s[right]] = 1 + count.get(s[right], 0)\\n\\n            # Check this is a valid window\\n\\t\\t\\twhile (right - left + 1) - max(count.values()) > k:\\n                count[s[left]] -= 1\\n                left += 1\\n            \\n            res = max(res, right - left + 1)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454059,
                "title": "javascript-o-n-solution-with-comments",
                "content": "For this solution, only the maximimum ever frequency is recorded, since a longer valid substring can only be created with more characters that don\\'t need flipped\\n\\nThis solution is O(n) for both time and O(1) for space where n is the length of the string\\n```\\nconst characterReplacement = function (str, maxFlipCount) {\\n\\t//if every char or all but one char can be flipped, return the length of the string \\n\\tif (maxFlipCount >= str.length - 1) {\\n\\t\\treturn str.length\\n\\t}\\n\\n\\tconst hashMap = {}\\n\\tlet maxLetterFrequency = 0\\n\\tlet left = 0\\n\\n\\t//iterate from left to right until the right pointer is at the end of the string\\n\\tfor (right = left; right < str.length; right++) {\\n\\t\\tconst rightLetter = str[right];\\n\\t\\t//add the current letter to  the hashmap\\n\\t\\tif (hashMap[rightLetter] === undefined) hashMap[rightLetter] = 1\\n\\t\\telse hashMap[rightLetter]++\\n\\n\\t\\tmaxLetterFrequency = Math.max(maxLetterFrequency, hashMap[rightLetter])\\n\\n\\t\\t//if too many characters need flipped, move the left pointer right\\n\\t\\tlet windowSize = right - left + 1\\n\\t\\tif (windowSize - maxLetterFrequency > maxFlipCount) {\\n\\t\\t\\tconst leftLetter = str[left]\\n\\t\\t\\t//decrement the count of the left letter in the hashmap\\n\\t\\t\\thashMap[leftLetter]--\\n\\t\\t\\t//move the left pointer right\\n\\t\\t\\tleft++\\n\\t\\t}\\n\\t}\\n\\t//return the size of the window\\n\\treturn str.length - left\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nconst characterReplacement = function (str, maxFlipCount) {\\n\\t//if every char or all but one char can be flipped, return the length of the string \\n\\tif (maxFlipCount >= str.length - 1) {\\n\\t\\treturn str.length\\n\\t}\\n\\n\\tconst hashMap = {}\\n\\tlet maxLetterFrequency = 0\\n\\tlet left = 0\\n\\n\\t//iterate from left to right until the right pointer is at the end of the string\\n\\tfor (right = left; right < str.length; right++) {\\n\\t\\tconst rightLetter = str[right];\\n\\t\\t//add the current letter to  the hashmap\\n\\t\\tif (hashMap[rightLetter] === undefined) hashMap[rightLetter] = 1\\n\\t\\telse hashMap[rightLetter]++\\n\\n\\t\\tmaxLetterFrequency = Math.max(maxLetterFrequency, hashMap[rightLetter])\\n\\n\\t\\t//if too many characters need flipped, move the left pointer right\\n\\t\\tlet windowSize = right - left + 1\\n\\t\\tif (windowSize - maxLetterFrequency > maxFlipCount) {\\n\\t\\t\\tconst leftLetter = str[left]\\n\\t\\t\\t//decrement the count of the left letter in the hashmap\\n\\t\\t\\thashMap[leftLetter]--\\n\\t\\t\\t//move the left pointer right\\n\\t\\t\\tleft++\\n\\t\\t}\\n\\t}\\n\\t//return the size of the window\\n\\treturn str.length - left\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2363952,
                "title": "best-explanation-with-video-reference-and-comments-c",
                "content": "Firstly, try to understand the ***algorithm*** from this video:\\nhttps://www.youtube.com/watch?v=gqXU1UyA8pk&t=\\n\\n**Key points**:\\n\\n* We move the window and check for ```windowLength - maxFreq <= k``` everytime.\\n* At every step I increase ```r```, so it increases towards right everytime.\\n* ```l``` will increase when ```windowLength - maxFreq > k```.\\n```windowLength - maxFreq``` is the no. of characters we need to replace.\\n\\nThis is how the window will slide.\\n \\n\\n```\\n\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        // we move the window and check for windowLength - maxFreq <= k everytime\\n\\t\\t// windowLength - maxFreq is the no. of characters we need to replace\\n        unordered_map<char, int> mp;\\n\\n        int l = 0, r = 0;\\n        int mxFreq = 0;\\n        int windowLength = 0;\\n        int ans = windowLength;\\n\\n        while (r < s.size()) {\\n\\n            mp[s[r]]++;\\n\\n            windowLength = r - l + 1;\\n\\n            // at every step I increase r, so rightwise it increases\\n            // I will increase l when I find windowLength - mxFreq crosses k\\n\\n            mxFreq = max(mxFreq, mp[s[r]]);\\n\\n            if (windowLength - mxFreq <= k) {\\n                // no need to move l\\n                ans = max(ans, windowLength);\\n            }\\n            else {\\n                // need to move l when it crosses k\\n                mp[s[l]]--; // since I am shifting l, I need to omit the presence of the current character at l\\n                l++;\\n\\n            }\\n            // r will always move\\n            r++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```windowLength - maxFreq <= k```\n```r```\n```l```\n```windowLength - maxFreq > k```\n```windowLength - maxFreq```\n```\\n\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        // we move the window and check for windowLength - maxFreq <= k everytime\\n\\t\\t// windowLength - maxFreq is the no. of characters we need to replace\\n        unordered_map<char, int> mp;\\n\\n        int l = 0, r = 0;\\n        int mxFreq = 0;\\n        int windowLength = 0;\\n        int ans = windowLength;\\n\\n        while (r < s.size()) {\\n\\n            mp[s[r]]++;\\n\\n            windowLength = r - l + 1;\\n\\n            // at every step I increase r, so rightwise it increases\\n            // I will increase l when I find windowLength - mxFreq crosses k\\n\\n            mxFreq = max(mxFreq, mp[s[r]]);\\n\\n            if (windowLength - mxFreq <= k) {\\n                // no need to move l\\n                ans = max(ans, windowLength);\\n            }\\n            else {\\n                // need to move l when it crosses k\\n                mp[s[l]]--; // since I am shifting l, I need to omit the presence of the current character at l\\n                l++;\\n\\n            }\\n            // r will always move\\n            r++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295089,
                "title": "java-solution-with-sliding-window",
                "content": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int l = 0;\\n        int[] count = new int[26];\\n        int maxf = 0;\\n        int max = 0;\\n        \\n        for(int r = 0; r < s.length(); r++){\\n            int current_char = s.charAt(r) - \\'A\\';\\n            count[current_char]++;\\n            \\n            maxf = Math.max(maxf, count[current_char]);\\n            \\n            while(r - l + 1 - maxf > k){  // actually, if case is enough here\\n                count[s.charAt(l) - \\'A\\']--;\\n                l++;\\n            }\\n            \\n            max = Math.max(max, r - l + 1);\\n            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int l = 0;\\n        int[] count = new int[26];\\n        int maxf = 0;\\n        int max = 0;\\n        \\n        for(int r = 0; r < s.length(); r++){\\n            int current_char = s.charAt(r) - \\'A\\';\\n            count[current_char]++;\\n            \\n            maxf = Math.max(maxf, count[current_char]);\\n            \\n            while(r - l + 1 - maxf > k){  // actually, if case is enough here\\n                count[s.charAt(l) - \\'A\\']--;\\n                l++;\\n            }\\n            \\n            max = Math.max(max, r - l + 1);\\n            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263422,
                "title": "java-easy-sliding-window",
                "content": "**if you like the solution, please upvote, Happy learning!**\\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int[] freq = new int[26];\\n        int windowEnd = 0, windowStart = 0, maxFreqLetterLength = 0, longest = 0;\\n        for (; windowEnd < s.length(); windowEnd++) {\\n            freq[s.charAt(windowEnd) - \\'A\\']++;\\n            maxFreqLetterLength = Math.max(maxFreqLetterLength, freq[s.charAt(windowEnd) - \\'A\\']);\\n            \\n            int currentSegmentedWindow = windowEnd - windowStart + 1;\\n            if (currentSegmentedWindow - maxFreqLetterLength > k) {\\n                // replacement done beyond k letters\\n                // hence decrement the current freq\\n                freq[s.charAt(windowStart) - \\'A\\']--;\\n                windowStart++;\\n            }\\n            longest = Math.max(longest, windowEnd - windowStart + 1);\\n        }\\n        return longest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int[] freq = new int[26];\\n        int windowEnd = 0, windowStart = 0, maxFreqLetterLength = 0, longest = 0;\\n        for (; windowEnd < s.length(); windowEnd++) {\\n            freq[s.charAt(windowEnd) - \\'A\\']++;\\n            maxFreqLetterLength = Math.max(maxFreqLetterLength, freq[s.charAt(windowEnd) - \\'A\\']);\\n            \\n            int currentSegmentedWindow = windowEnd - windowStart + 1;\\n            if (currentSegmentedWindow - maxFreqLetterLength > k) {\\n                // replacement done beyond k letters\\n                // hence decrement the current freq\\n                freq[s.charAt(windowStart) - \\'A\\']--;\\n                windowStart++;\\n            }\\n            longest = Math.max(longest, windowEnd - windowStart + 1);\\n        }\\n        return longest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219248,
                "title": "simple-js-solution-w-comments-sliding-window",
                "content": "```\\nconst characterReplacement = (s, k) => {\\n\\tconst map = {};\\n\\tlet max = 0; // max window\\n\\tlet maxCount = 0; // count of most frequent element\\n\\n\\tlet L = 0;\\n\\tlet R = 0;\\n\\n\\twhile (R < s.length) {\\n\\t\\tconst cv = s[R];\\n\\n\\t\\tmap[cv] = map[cv] + 1 || 1; // add/update count\\n\\t\\tmaxCount = Math.max(maxCount, map[cv]); // update max count\\n\\n    // length of window -- count of most frequent > k\\n    // character replacement threshold is capped\\n\\t\\twhile (R - L + 1 - maxCount > k) {\\n\\t\\t\\tmap[s[L]]--; // decrement count of left most character\\n\\t\\t\\tL++; // move window\\n\\t\\t}\\n\\n\\t\\tmax = Math.max(max, R - L + 1);\\n\\t\\tR++;\\n\\t}\\n\\n\\treturn max;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nconst characterReplacement = (s, k) => {\\n\\tconst map = {};\\n\\tlet max = 0; // max window\\n\\tlet maxCount = 0; // count of most frequent element\\n\\n\\tlet L = 0;\\n\\tlet R = 0;\\n\\n\\twhile (R < s.length) {\\n\\t\\tconst cv = s[R];\\n\\n\\t\\tmap[cv] = map[cv] + 1 || 1; // add/update count\\n\\t\\tmaxCount = Math.max(maxCount, map[cv]); // update max count\\n\\n    // length of window -- count of most frequent > k\\n    // character replacement threshold is capped\\n\\t\\twhile (R - L + 1 - maxCount > k) {\\n\\t\\t\\tmap[s[L]]--; // decrement count of left most character\\n\\t\\t\\tL++; // move window\\n\\t\\t}\\n\\n\\t\\tmax = Math.max(max, R - L + 1);\\n\\t\\tR++;\\n\\t}\\n\\n\\treturn max;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2167634,
                "title": "c-easy-to-understand-with-main-catch-explained-sliding-window-o-n",
                "content": "Main thing to understand is : **maxCount**  will be wrong at many times but we don\\'t care. Because main goal of this question is to find maximum length which satifies the condition i.e **sum of maxFreqLetter + no of letters we need to replace** will be the answer. Right? So if maxCount will be wrong at the moment also when we discard the letter it will not change the answer as maxCount is not increasing. It will increase, only when we add a new letter and if it\\'s freq becomes highest then the answer will be changed and we are taking care of it:\\n\\t\\t\\t `maxCount = max(maxCount, freqLetters[s[right]]);`. Hope it helps!\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n         int maxCount = 0, maxLength = 0, left = 0, right = 0;\\n         unordered_map<char, int> freqLetters;     // to maintain the freq of the occurence of each letter\\n         while(right < s.size())\\n         {\\n             freqLetters[s[right]]++;\\n             maxCount = max(maxCount, freqLetters[s[right]]);  //maximum letter freq encountered so far\\n             if(right - left + 1 - maxCount > k)   //when condition violates\\n             {\\n                 freqLetters[s[left]]--;\\n                 left++;\\n             }\\n             maxLength = max(maxLength, right - left + 1);    //maximum window length that satifies the condition\\n             right++;\\n         }\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n         int maxCount = 0, maxLength = 0, left = 0, right = 0;\\n         unordered_map<char, int> freqLetters;     // to maintain the freq of the occurence of each letter\\n         while(right < s.size())\\n         {\\n             freqLetters[s[right]]++;\\n             maxCount = max(maxCount, freqLetters[s[right]]);  //maximum letter freq encountered so far\\n             if(right - left + 1 - maxCount > k)   //when condition violates\\n             {\\n                 freqLetters[s[left]]--;\\n                 left++;\\n             }\\n             maxLength = max(maxLength, right - left + 1);    //maximum window length that satifies the condition\\n             right++;\\n         }\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868319,
                "title": "python-sliding-window-the-most-standard-template-for-sliding-window",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n                    \\n        left = 0\\n        res = 0\\n\\n        mapp = defaultdict(int)\\n\\n        for i in range(len(s)):\\n\\n            cur = s[i]\\n\\n            # 1, in\\n            mapp[cur] += 1\\n            \\n# (the length of current window)  -  (the most frequency of the symbol in the current window)\\n# judge whether this value is > k. if > k, it means the left pointer needs to shrink\\n\\n# For example, AAABBB, k = 2 (can only change 2 times). \\n# Then AAABB is OK since we have 3 A and 2 B, the most frequent symbol is A. \\n# we compute as 5 - 3 = 2, not > 2, so it will not go into while loop.\\n# After this, when we have AAABBB, then 6 - 3 > 2. We go into the loop to update the window.\\n            \\n            while (i - left + 1) - max(mapp.values()) > k:\\n                \\n                # 2, out\\n                mapp[s[left]] -= 1\\n                \\n                left += 1\\n            \\n\\t\\t\\t# 3, compute\\n            res = max(res, i - left + 1)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n                    \\n        left = 0\\n        res = 0\\n\\n        mapp = defaultdict(int)\\n\\n        for i in range(len(s)):\\n\\n            cur = s[i]\\n\\n            # 1, in\\n            mapp[cur] += 1\\n            \\n# (the length of current window)  -  (the most frequency of the symbol in the current window)\\n# judge whether this value is > k. if > k, it means the left pointer needs to shrink\\n\\n# For example, AAABBB, k = 2 (can only change 2 times). \\n# Then AAABB is OK since we have 3 A and 2 B, the most frequent symbol is A. \\n# we compute as 5 - 3 = 2, not > 2, so it will not go into while loop.\\n# After this, when we have AAABBB, then 6 - 3 > 2. We go into the loop to update the window.\\n            \\n            while (i - left + 1) - max(mapp.values()) > k:\\n                \\n                # 2, out\\n                mapp[s[left]] -= 1\\n                \\n                left += 1\\n            \\n\\t\\t\\t# 3, compute\\n            res = max(res, i - left + 1)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517308,
                "title": "sliding-window-with-detailed-explaination-and-dry-run",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n    \\n    ALGO:------\\n    \\n    \\n       1:- take a vector for count the frequncy of the char\\n       \\n       2:- run a loop from 0 to n {\\n       \\n         A:-   increase the frequncy of each char in the vector by v[s[j]-\\'A\\']++; this;\\n            \\n          B:- then check if the highest frequency -window size is greater than k\\n          that means one extra char that is diffrent and we dont have k to change \\n          \\n          C:- now decrease the frequency and increase the i\\n          \\n          D:- and every time count the size of the window..\\n       }\\n       \\n       \\n       \\n       DRY RUN...........\\n       \\n       for example :-   s = \"AABABBA\", k = 1\\n       \\n      for j=0,,,,,, v=[1,0,0,0,0,0,0,0,0,.....]  window size=1\\n      \\n      for j=1,,,,,, v=[2,0,0,0,0,0,0,0,0,.....]  window size=2\\n      \\n      for j=2,,,,,, v=[2,1,0,0,0,0,0,0,0,.....]  window size=3\\n      \\n      for j=3,,,,,, v=[3,1,0,0,0,0,0,0,0,.....]  window size=4\\n      \\n      for j=4,,,,,, v=[3,2,0,0,0,0,0,0,0,.....]  window size=5\\n      \\n      now (window size-highest frequency){ 5-3 which is >k}\\n      {\\n        so increase i..\\n      \\n        for j=4,,,,,, v=[2,2,0,0,0,0,0,0,0,.....]  window size=4\\n        \\n         for j=4,,,,,, v=[1,2,0,0,0,0,0,0,0,.....]  window size=3\\n         \\n       }  \\n        for j=5,,,,,, v=[1,3,0,0,0,0,0,0,0,.....]  window size=4\\n    */\\npublic:\\n    int characterReplacement(string s, int k) {\\n        \\n        int i=0;\\n       \\n        vector<int>v(26,0);\\n        \\n        int ans=INT_MIN;\\n        \\n       for(int j=0;j<s.size();j++)\\n        {\\n            v[s[j]-\\'A\\']++;\\n           \\n            while(j-i+1-*max_element(v.begin(),v.end())>k)\\n            {\\n                v[s[i]-\\'A\\']--;\\n                \\n                i++;\\n            }\\n           \\n            ans=max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n    \\n    ALGO:------\\n    \\n    \\n       1:- take a vector for count the frequncy of the char\\n       \\n       2:- run a loop from 0 to n {\\n       \\n         A:-   increase the frequncy of each char in the vector by v[s[j]-\\'A\\']++; this;\\n            \\n          B:- then check if the highest frequency -window size is greater than k\\n          that means one extra char that is diffrent and we dont have k to change \\n          \\n          C:- now decrease the frequency and increase the i\\n          \\n          D:- and every time count the size of the window..\\n       }\\n       \\n       \\n       \\n       DRY RUN...........\\n       \\n       for example :-   s = \"AABABBA\", k = 1\\n       \\n      for j=0,,,,,, v=[1,0,0,0,0,0,0,0,0,.....]  window size=1\\n      \\n      for j=1,,,,,, v=[2,0,0,0,0,0,0,0,0,.....]  window size=2\\n      \\n      for j=2,,,,,, v=[2,1,0,0,0,0,0,0,0,.....]  window size=3\\n      \\n      for j=3,,,,,, v=[3,1,0,0,0,0,0,0,0,.....]  window size=4\\n      \\n      for j=4,,,,,, v=[3,2,0,0,0,0,0,0,0,.....]  window size=5\\n      \\n      now (window size-highest frequency){ 5-3 which is >k}\\n      {\\n        so increase i..\\n      \\n        for j=4,,,,,, v=[2,2,0,0,0,0,0,0,0,.....]  window size=4\\n        \\n         for j=4,,,,,, v=[1,2,0,0,0,0,0,0,0,.....]  window size=3\\n         \\n       }  \\n        for j=5,,,,,, v=[1,3,0,0,0,0,0,0,0,.....]  window size=4\\n    */\\npublic:\\n    int characterReplacement(string s, int k) {\\n        \\n        int i=0;\\n       \\n        vector<int>v(26,0);\\n        \\n        int ans=INT_MIN;\\n        \\n       for(int j=0;j<s.size();j++)\\n        {\\n            v[s[j]-\\'A\\']++;\\n           \\n            while(j-i+1-*max_element(v.begin(),v.end())>k)\\n            {\\n                v[s[i]-\\'A\\']--;\\n                \\n                i++;\\n            }\\n           \\n            ans=max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388678,
                "title": "python-with-full-explanation",
                "content": "I see the discussion and there were many questions about the logic of the answer. \\nI will presented 3 working versions, with the later version slightly improved upon the previous version. Most of the solutions will fall into (or similar with) 1 of them.\\n\\n**Version 1**: \\nIdea:\\n- Use two poitner l, r (left, right) to represent the current window\\n- Keep a hashmap to record the count of each character in current window\\n- Keep a max_count to record the highest frequency in current window. The window is valid if ```window_length <= max_count + k``` (else, there is no way to make it repeating chacrater with k replacement).\\n- If the window is valid, we update the maximum length and update if necessary.\\n- If the window is not valid, that means we have too many minority character already. With current left pointer, expanding the window wont do any help. That is, we are done with this left position. Move this left pointer. Since the window is contracted, it wont become longer even if it is valid, hence no need to check the length.\\n- Complexity: O(26N) time, O(26) space\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        counter = {}\\n        l = 0\\n        max_count = 0\\n        res = 0\\n        for r, ch in enumerate(s):\\n            counter[ch] = counter.get(ch, 0) + 1\\n            # Update max_count, count of the most frequent\\n            max_count = max(counter.values())            \\n            \\n            # Valid window\\n            if r+1 - l <= max_count + k:\\n                res = max(res, r+1 - l)\\n            # Invalid window (too may minority character)\\n            else:\\n                counter[s[l]] -= 1\\n                l += 1\\n        return res\\n```\\n\\n**Version 2**: \\nIdea:\\n- We only need to update max_count if it is increased. If it decreases, the valid window will have smaller length anyway. SO: max_count only need updation if we increase the frequency of a character (POSSIBLY the most frequent character), and we only need to see if the new frequency is actually higher than the current max_count. That is, we dont need to scan our hashmap!\\n- Complexity: O(N) time, O(26) space\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        counter = {}\\n        l = 0\\n        max_count = 0\\n        res = 0\\n        for r, ch in enumerate(s):\\n            counter[ch] = counter.get(ch, 0) + 1\\n            # Update max_count, count of the most frequent\\n            max_count = max(max_count, counter[ch])            \\n            \\n            # Valid window\\n            if r+1 - l <= max_count + k:\\n                res = max(res, r+1 - l)\\n            # Invalid window (too may minority character)\\n            else:\\n                counter[s[l]] -= 1\\n                l += 1\\n        return res\\n```\\n**Version 3**:  Not much different from version 2, it saves 1 variable but weakens readability\\nAs we keep the max_count increasing, the window will NEVER contract. Hence, we simply use the final window as return value\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        counter = {}\\n        l = 0\\n        max_count = 0\\n        for r, ch in enumerate(s):\\n            counter[ch] = counter.get(ch, 0) + 1\\n            # Update max_count, count of the most frequent\\n            max_count = max(max_count, counter[ch])            \\n            \\n            # Invalid window\\n            if r+1 - l > max_count + k:\\n                counter[s[l]] -= 1\\n                l += 1\\n        return r+1 - l\\n```",
                "solutionTags": [],
                "code": "```window_length <= max_count + k```\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        counter = {}\\n        l = 0\\n        max_count = 0\\n        res = 0\\n        for r, ch in enumerate(s):\\n            counter[ch] = counter.get(ch, 0) + 1\\n            # Update max_count, count of the most frequent\\n            max_count = max(counter.values())            \\n            \\n            # Valid window\\n            if r+1 - l <= max_count + k:\\n                res = max(res, r+1 - l)\\n            # Invalid window (too may minority character)\\n            else:\\n                counter[s[l]] -= 1\\n                l += 1\\n        return res\\n```\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        counter = {}\\n        l = 0\\n        max_count = 0\\n        res = 0\\n        for r, ch in enumerate(s):\\n            counter[ch] = counter.get(ch, 0) + 1\\n            # Update max_count, count of the most frequent\\n            max_count = max(max_count, counter[ch])            \\n            \\n            # Valid window\\n            if r+1 - l <= max_count + k:\\n                res = max(res, r+1 - l)\\n            # Invalid window (too may minority character)\\n            else:\\n                counter[s[l]] -= 1\\n                l += 1\\n        return res\\n```\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        counter = {}\\n        l = 0\\n        max_count = 0\\n        for r, ch in enumerate(s):\\n            counter[ch] = counter.get(ch, 0) + 1\\n            # Update max_count, count of the most frequent\\n            max_count = max(max_count, counter[ch])            \\n            \\n            # Invalid window\\n            if r+1 - l > max_count + k:\\n                counter[s[l]] -= 1\\n                l += 1\\n        return r+1 - l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194629,
                "title": "a-different-and-simpler-approach-sliding-window-c",
                "content": "We find the total unique elements in the string, and then we iterate the string with intention of maximizing the window for that character.\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        unordered_set<char> uniqueLetters;\\n        int answer=0;\\n        for (auto c: s)\\n            uniqueLetters.insert(c);\\n        for (auto c: uniqueLetters){\\n            int i=0; \\n            int j=0;\\n            int allowedChanges=k;\\n            for (; j<s.size(); j++){\\n                if (s[j]!=c)allowedChanges--;\\n                if (allowedChanges<0) {\\n                    if (s[i]!=c)allowedChanges++;\\n                    i++;\\n                }    \\n            }\\n            answer=max(answer, j-i);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        unordered_set<char> uniqueLetters;\\n        int answer=0;\\n        for (auto c: s)\\n            uniqueLetters.insert(c);\\n        for (auto c: uniqueLetters){\\n            int i=0; \\n            int j=0;\\n            int allowedChanges=k;\\n            for (; j<s.size(); j++){\\n                if (s[j]!=c)allowedChanges--;\\n                if (allowedChanges<0) {\\n                    if (s[i]!=c)allowedChanges++;\\n                    i++;\\n                }    \\n            }\\n            answer=max(answer, j-i);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175952,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        \\n        int left = 0;\\n        vector<int> count(26,0);\\n        int max_char = INT_MIN;\\n        int maxVal = 0;\\n        for(int right = 0;right < s.size();right++)\\n        {\\n            int windowSize = right - left + 1;\\n            count[s[right] - \\'A\\']++;\\n            max_char = max(max_char,count[s[right]-\\'A\\']);\\n            int  replacedCount = windowSize - max_char;\\n            if(replacedCount > k)\\n            {\\n                count[s[left] - \\'A\\']--;\\n                left++;\\n            }\\n            else\\n                maxVal = max(maxVal,windowSize);\\n        }\\n        return maxVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        \\n        int left = 0;\\n        vector<int> count(26,0);\\n        int max_char = INT_MIN;\\n        int maxVal = 0;\\n        for(int right = 0;right < s.size();right++)\\n        {\\n            int windowSize = right - left + 1;\\n            count[s[right] - \\'A\\']++;\\n            max_char = max(max_char,count[s[right]-\\'A\\']);\\n            int  replacedCount = windowSize - max_char;\\n            if(replacedCount > k)\\n            {\\n                count[s[left] - \\'A\\']--;\\n                left++;\\n            }\\n            else\\n                maxVal = max(maxVal,windowSize);\\n        }\\n        return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942872,
                "title": "java-concise-solution-sliding-window",
                "content": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        int i = 0 , j = 0;\\n        int N = s.length();\\n        int[]count = new int[128];\\n        int maxCharCount = 0;\\n        int max = 0;\\n        \\n        while(i < N)\\n        {   \\n            char ch = s.charAt(i);\\n            count[ch]++;\\n            \\n            maxCharCount = Math.max(maxCharCount , count[ch]);\\n            \\n            while(i - j - maxCharCount + 1  > k)\\n            {\\n                count[s.charAt(j)]--;\\n                j++;\\n            }\\n            \\n         max = Math.max(max,i - j + 1);   \\n         i++;\\n        }\\n      return max;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        int i = 0 , j = 0;\\n        int N = s.length();\\n        int[]count = new int[128];\\n        int maxCharCount = 0;\\n        int max = 0;\\n        \\n        while(i < N)\\n        {   \\n            char ch = s.charAt(i);\\n            count[ch]++;\\n            \\n            maxCharCount = Math.max(maxCharCount , count[ch]);\\n            \\n            while(i - j - maxCharCount + 1  > k)\\n            {\\n                count[s.charAt(j)]--;\\n                j++;\\n            }\\n            \\n         max = Math.max(max,i - j + 1);   \\n         i++;\\n        }\\n      return max;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 666249,
                "title": "simple-sliding-window-solution-c-with-explaination",
                "content": "Dry run is shown in the image ![image](https://assets.leetcode.com/users/surbhisharma7/image_1591100532.png)\\n\\n\\n```\\n int characterReplacement(string s, int k) {\\n        int size = s.size();\\n        int ret=0;\\n        vector<int>count(26,0);\\n        int start=0,end=0;\\n        int globalMax_fre = 0;\\n        for(;end<size;end++){\\n            \\n            count[s[end]-\\'A\\']++;\\n            globalMax_fre = max(globalMax_fre,count[s[end]-\\'A\\']);\\n            \\n            if((end-start+1)-globalMax_fre > k){\\n                ret = max(ret,(end-start));\\n                count[s[start]-\\'A\\']--;\\n                start++;\\n            }\\n        }\\n        return max(ret,(end-start));\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n int characterReplacement(string s, int k) {\\n        int size = s.size();\\n        int ret=0;\\n        vector<int>count(26,0);\\n        int start=0,end=0;\\n        int globalMax_fre = 0;\\n        for(;end<size;end++){\\n            \\n            count[s[end]-\\'A\\']++;\\n            globalMax_fre = max(globalMax_fre,count[s[end]-\\'A\\']);\\n            \\n            if((end-start+1)-globalMax_fre > k){\\n                ret = max(ret,(end-start));\\n                count[s[start]-\\'A\\']--;\\n                start++;\\n            }\\n        }\\n        return max(ret,(end-start));\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 641911,
                "title": "java-o-n-easy-to-understand-also-answering-a-hidden-question",
                "content": "Well, This problem is an intresting one. \\n\\nObjective is:\\nFind a longest substring where you can replace only k chars with another character and it becomes all repeating characters.\\n\\nApproach:\\nAs its sliding window, you need left and right index variables.\\n\\n1. Start scanning by increment right.\\n\\n2. Maintain a character count strategy by hashmap or arrays etc.\\n\\n3. Maintain a variable **maxCountForMostRepetetiveChar** containg the value of a character which got encountered most number of time.\\n\\n4. If we have a window where we can replace k or less than k characters other than maxCountForMostRepetetiveChar character  then its a candidate for max window size, \\nor \\nWindow Size - maxCountForMostRepetetiveChar <= k\\n\\n\\tfor example,\\nif you have string AAABBC and k = 2\\nA    A    A   B   B  C\\n^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^\\nLeft&nbsp;&nbsp;&nbsp;&nbsp;Right\\nmaxCountForMostRepetetiveChar = 3\\nk = 2\\nWindow Size = 4\\n4 - 3 <= 2  --> this holds true\\n\\nHere we can replace B with A and windo size 4 is the candidate for max window,\\n\\n5. Once you find while scanning that the equation\\n(maxCountForMostRepetetiveChar + k (not of replacable characers) = Window Size \\ndoes not hold true.\\n\\n\\ti .e. you have  k+1 different character Other than maxCountForMostRepetetiveChar then you need to increment left.\\n\\t\\n\\tExample.\\nif you have string AAABBCAAA and k = 2\\nA    A    A   B   B  C\\n^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^\\nLeft&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right\\n\\n\\tNow \\nmaxCountForMostRepetetiveChar = 3 (count of A)\\nOther Character Count = 3  (Count of B and C)\\nWindow size = 6\\n3 + 2 = 6  --> This does not hold true.\\n\\nNow, increment left untill you find the sutiable window again, where our equation \\n\\tWindow Size - maxCountForMostRepetetiveChar <= k holds true. \\n\\tfor example,\\n\\nif you have string AAABBCAAA and k = 2\\nA    A    A   B   B  C\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;&nbsp;&nbsp;&nbsp;Right\\nWe need to incremnet till we find a window where we can replace 2 character and find another suitable candidate.\\n\\ndoing so maintain the max window you encountered.\\n\\nSample code,\\n\\n```\\npublic int characterReplacement(String s, int k)\\n   {\\n      int left = 0, right = 0, maxCountForMostRepetetiveChar = 0;\\n\\n      int maxWindowKReplacableCharSize = 0;\\n\\n      // A map to count characters encountered during traversal\\n      Map<Character, Integer> charCountMap = new HashMap<Character, Integer>();\\n\\n      // Traverse Untill the end\\n      while (right < s.length())\\n      {\\n         char currentChar = s.charAt(right);\\n\\n         // Increment the count for current character\\n         int currentCharCount = 1 + charCountMap.getOrDefault(currentChar, 0);\\n\\n         // Update in the character count map\\n         charCountMap.put(currentChar, currentCharCount);\\n\\n         // Check if the current char is the max occuring character\\n         maxCountForMostRepetetiveChar = Math.max(maxCountForMostRepetetiveChar, currentCharCount);\\n\\n         // Initialize the window size\\n         int windowSize = right - left + 1;\\n\\n         // This compaision tells that if we have a window where there are at most\\n         // k character other than maxCountForMostRepetetiveChar.\\n         // If those k character are replaced then its a candidate window for the solution.\\n         if (windowSize - maxCountForMostRepetetiveChar <= k)\\n         {\\n            // If the candidate window is the max window, then update the window.\\n            maxWindowKReplacableCharSize = Math.max(maxWindowKReplacableCharSize, windowSize);\\n         }\\n\\n         // Start sliding the window from left untill we arrive at a situation from\\n         // where we can start looking for the pattern again.\\n         // i.e increment left untill we arrive at a position where window contains\\n         // k replacable characters other than the maxCountForMostRepetetiveChar\\n\\n         while (windowSize - maxCountForMostRepetetiveChar > k)\\n         {\\n            char poppedChar = s.charAt(left);\\n            // While sliding from the left reduce the count of character which is removed.\\n            charCountMap.put(poppedChar, charCountMap.get(poppedChar) - 1);\\n\\n            // **NOTE**\\n            // Ideally we should be recalculating the the max reoccuring character (maxCountForMostRepetetiveChar) again,\\n            // as we are reducing the count of the character.\\n            // We can do that and still the solution will work, but it will be needless step.\\n            // As to the context of the problem we already have found,\\n            // (max reoccuring character) while scanning.\\n            // Now the result max window will only update if we find a character (same or diffrent) which is\\n            // occuring more than max reoccuring character (maxCountForMostRepetetiveChar).\\n            // This will be autocalcuated while scanning the array at line 30.\\n            // This took some time to understand.\\n\\n            // Slide the window from left\\n            left++;\\n            windowSize = right - left + 1;\\n         }\\n\\n         // Slide the window from right\\n         right++;\\n      }\\n      return maxWindowKReplacableCharSize;\\n   }\\n   ```\\n\\nThe solution can be futher optimzed to use arrays insted of maps and reducing the number of variable i\\'ve taken for explanation for better timing calculations.\\n\\nSomething like,\\n\\n```\\npublic int characterReplacement(String s, int k)\\n   {\\n      char[] chars = s.toCharArray();\\n      int[] charCountArray = new int[128];\\n      int maxCountForMostRepetetiveChar = 0, maxWindowKReplacableCharSize = 0;\\n      int left = 0, right = 0;\\n\\n      while (right < chars.length)\\n      {\\n         maxCountForMostRepetetiveChar = Math.max(maxCountForMostRepetetiveChar, ++charCountArray[chars[right]]);\\n\\n         while (right - left + 1 - maxCountForMostRepetetiveChar > k)\\n            charCountArray[chars[left++]]--;\\n\\n         maxWindowKReplacableCharSize = Math.max(maxWindowKReplacableCharSize, right - left + 1);\\n         right++;\\n      }\\n\\n      return maxWindowKReplacableCharSize;\\n   }\\n   ```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int characterReplacement(String s, int k)\\n   {\\n      int left = 0, right = 0, maxCountForMostRepetetiveChar = 0;\\n\\n      int maxWindowKReplacableCharSize = 0;\\n\\n      // A map to count characters encountered during traversal\\n      Map<Character, Integer> charCountMap = new HashMap<Character, Integer>();\\n\\n      // Traverse Untill the end\\n      while (right < s.length())\\n      {\\n         char currentChar = s.charAt(right);\\n\\n         // Increment the count for current character\\n         int currentCharCount = 1 + charCountMap.getOrDefault(currentChar, 0);\\n\\n         // Update in the character count map\\n         charCountMap.put(currentChar, currentCharCount);\\n\\n         // Check if the current char is the max occuring character\\n         maxCountForMostRepetetiveChar = Math.max(maxCountForMostRepetetiveChar, currentCharCount);\\n\\n         // Initialize the window size\\n         int windowSize = right - left + 1;\\n\\n         // This compaision tells that if we have a window where there are at most\\n         // k character other than maxCountForMostRepetetiveChar.\\n         // If those k character are replaced then its a candidate window for the solution.\\n         if (windowSize - maxCountForMostRepetetiveChar <= k)\\n         {\\n            // If the candidate window is the max window, then update the window.\\n            maxWindowKReplacableCharSize = Math.max(maxWindowKReplacableCharSize, windowSize);\\n         }\\n\\n         // Start sliding the window from left untill we arrive at a situation from\\n         // where we can start looking for the pattern again.\\n         // i.e increment left untill we arrive at a position where window contains\\n         // k replacable characters other than the maxCountForMostRepetetiveChar\\n\\n         while (windowSize - maxCountForMostRepetetiveChar > k)\\n         {\\n            char poppedChar = s.charAt(left);\\n            // While sliding from the left reduce the count of character which is removed.\\n            charCountMap.put(poppedChar, charCountMap.get(poppedChar) - 1);\\n\\n            // **NOTE**\\n            // Ideally we should be recalculating the the max reoccuring character (maxCountForMostRepetetiveChar) again,\\n            // as we are reducing the count of the character.\\n            // We can do that and still the solution will work, but it will be needless step.\\n            // As to the context of the problem we already have found,\\n            // (max reoccuring character) while scanning.\\n            // Now the result max window will only update if we find a character (same or diffrent) which is\\n            // occuring more than max reoccuring character (maxCountForMostRepetetiveChar).\\n            // This will be autocalcuated while scanning the array at line 30.\\n            // This took some time to understand.\\n\\n            // Slide the window from left\\n            left++;\\n            windowSize = right - left + 1;\\n         }\\n\\n         // Slide the window from right\\n         right++;\\n      }\\n      return maxWindowKReplacableCharSize;\\n   }\\n   ```\n```\\npublic int characterReplacement(String s, int k)\\n   {\\n      char[] chars = s.toCharArray();\\n      int[] charCountArray = new int[128];\\n      int maxCountForMostRepetetiveChar = 0, maxWindowKReplacableCharSize = 0;\\n      int left = 0, right = 0;\\n\\n      while (right < chars.length)\\n      {\\n         maxCountForMostRepetetiveChar = Math.max(maxCountForMostRepetetiveChar, ++charCountArray[chars[right]]);\\n\\n         while (right - left + 1 - maxCountForMostRepetetiveChar > k)\\n            charCountArray[chars[left++]]--;\\n\\n         maxWindowKReplacableCharSize = Math.max(maxWindowKReplacableCharSize, right - left + 1);\\n         right++;\\n      }\\n\\n      return maxWindowKReplacableCharSize;\\n   }\\n   ```",
                "codeTag": "Unknown"
            },
            {
                "id": 482941,
                "title": "c-11-lines-easy-to-understand-sliding-window-solution",
                "content": "```\\n int characterReplacement(string s, int k) {\\n        if(s.length()==0) return 0;\\n        int low = 0, most_frequent_count = 0, max_length = 1;\\n        unordered_map<char, int> letters; \\n        for(int high = 0; high < s.length(); high++) {\\n            int current_letter_count = ++letters[s[high]];\\n            most_frequent_count = max(most_frequent_count, current_letter_count); \\n            while(high-low+1 - most_frequent_count > k) {\\n                letters[s[low]]--;\\n                low++;\\n            }\\n            max_length = max(max_length, high-low+1);\\n        }\\n        return max_length;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n int characterReplacement(string s, int k) {\\n        if(s.length()==0) return 0;\\n        int low = 0, most_frequent_count = 0, max_length = 1;\\n        unordered_map<char, int> letters; \\n        for(int high = 0; high < s.length(); high++) {\\n            int current_letter_count = ++letters[s[high]];\\n            most_frequent_count = max(most_frequent_count, current_letter_count); \\n            while(high-low+1 - most_frequent_count > k) {\\n                letters[s[low]]--;\\n                low++;\\n            }\\n            max_length = max(max_length, high-low+1);\\n        }\\n        return max_length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275013,
                "title": "simple-c-solution-faster-than-100-of-submissions",
                "content": "In a window of characters, if we want to convert all the characters to the same type, then we convert every character to the most frequent character in that window. So we start with a window, use a vector to keep track of frequencies of characters in current window, this helps us to know the most frequent character in current window. Then we move the right position of window we check if the no. of switches required in current window is <= K or not. If yes then continue expanding else we start shrinking from left.\\n```\\nint characterReplacement(string s, int k) {\\n\\tif(s.empty())\\n\\t\\treturn 0;\\n\\n\\t// for keeping track of freq of chars\\n\\tvector<int> dict(128, 0);\\n\\tint flips = k;\\n\\tint max_len = 0;\\n\\tint max_freq = 0;\\n\\n\\tint i = 0, j = 0;\\n\\twhile(i < s.size()) {\\n\\t\\t// increment frequency of current char and check if it\\n\\t\\t// is has the most frequency or not\\n\\t\\t++dict[s[i]];\\n\\t\\tmax_freq = max(max_freq, dict[s[i]]);\\n\\t\\t++i;\\n\\n\\t\\t// calculate the no. of chars which needs to be changed\\n\\t\\t// to the most frequent char\\n\\t\\tint flips_req = i - j - max_freq;\\n\\n\\t\\t// if no. of changes that can be made is not enough\\n\\t\\t// to convert every diff char in current window, then we start shrinking\\n\\t\\t// the current window from left\\n\\t\\twhile(flips_req > k) {\\n\\t\\t\\t--dict[s[j]];\\n\\t\\t\\t++j;\\n\\t\\t\\t// update changes required\\n\\t\\t\\tflips_req = i - j - max_freq;\\n\\t\\t}\\n\\t\\t// update max length if applicable\\n\\t\\tmax_len = max(max_len, i - j);\\n\\t}\\n\\n\\treturn max_len;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint characterReplacement(string s, int k) {\\n\\tif(s.empty())\\n\\t\\treturn 0;\\n\\n\\t// for keeping track of freq of chars\\n\\tvector<int> dict(128, 0);\\n\\tint flips = k;\\n\\tint max_len = 0;\\n\\tint max_freq = 0;\\n\\n\\tint i = 0, j = 0;\\n\\twhile(i < s.size()) {\\n\\t\\t// increment frequency of current char and check if it\\n\\t\\t// is has the most frequency or not\\n\\t\\t++dict[s[i]];\\n\\t\\tmax_freq = max(max_freq, dict[s[i]]);\\n\\t\\t++i;\\n\\n\\t\\t// calculate the no. of chars which needs to be changed\\n\\t\\t// to the most frequent char\\n\\t\\tint flips_req = i - j - max_freq;\\n\\n\\t\\t// if no. of changes that can be made is not enough\\n\\t\\t// to convert every diff char in current window, then we start shrinking\\n\\t\\t// the current window from left\\n\\t\\twhile(flips_req > k) {\\n\\t\\t\\t--dict[s[j]];\\n\\t\\t\\t++j;\\n\\t\\t\\t// update changes required\\n\\t\\t\\tflips_req = i - j - max_freq;\\n\\t\\t}\\n\\t\\t// update max length if applicable\\n\\t\\tmax_len = max(max_len, i - j);\\n\\t}\\n\\n\\treturn max_len;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91281,
                "title": "two-concise-c-solution-9ms-11-lines-and-20ms-7-lines",
                "content": "1.  9ms Sliding window solution.\\nmodified max(res, j - i) to max(res, j - i + min(i, times)), as it might also extend to the left.\\n\\n```\\nint characterReplacement(string s, int k) {\\n    int i = 0, j = 0, times = k, res = 0, cache[26] = {};\\n    for (; j < s.size(); j++) {\\n        cache[s[j] - 'A']++;\\n        if (s[j] != s[i] && times-- == 0) {\\n            res = max(res, j - i);\\n            while (i < j && j - i - cache[s[i] - 'A'] >= k) \\n                cache[s[i++] - 'A']--;\\n            times = k - j + i - 1 + cache[s[i] - 'A'];\\n        }\\n    }\\n    return max(res, j - i + min(i, times));\\n}\\n```\\n\\n2. 20ms Solution based on @StefanPochmann [solution](https://discuss.leetcode.com/topic/63456/7-lines-c), Thanks\\n```\\nint characterReplacement(string s, int k) {\\n    int i = 0, j = 0, maxCount = 0, cache[26] = {};\\n    while (j < s.size()) {\\n        maxCount = max(maxCount, ++cache[s[j++] - 'A']);\\n        if (j - i - maxCount > k && cache[s[i++] - 'A']-- == maxCount) \\n            maxCount = *max_element(cache, cache + 26);\\n    }\\n    return j - i;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint characterReplacement(string s, int k) {\\n    int i = 0, j = 0, times = k, res = 0, cache[26] = {};\\n    for (; j < s.size(); j++) {\\n        cache[s[j] - 'A']++;\\n        if (s[j] != s[i] && times-- == 0) {\\n            res = max(res, j - i);\\n            while (i < j && j - i - cache[s[i] - 'A'] >= k) \\n                cache[s[i++] - 'A']--;\\n            times = k - j + i - 1 + cache[s[i] - 'A'];\\n        }\\n    }\\n    return max(res, j - i + min(i, times));\\n}\\n```\n```\\nint characterReplacement(string s, int k) {\\n    int i = 0, j = 0, maxCount = 0, cache[26] = {};\\n    while (j < s.size()) {\\n        maxCount = max(maxCount, ++cache[s[j++] - 'A']);\\n        if (j - i - maxCount > k && cache[s[i++] - 'A']-- == maxCount) \\n            maxCount = *max_element(cache, cache + 26);\\n    }\\n    return j - i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91328,
                "title": "o-n-sliding-window-approach",
                "content": "```\\nvar characterReplacementLetter = function(s, k, l) {\\n    let res = 0, from = 0, to = -1, notEqual = 0;\\n    while (to < s.length - 1) {\\n        if (s[to + 1] === l || notEqual < k) {\\n            if (s[to + 1] !== l)\\n                notEqual++;\\n            to++;\\n            res = Math.max(res, to - from + 1);\\n        } else {\\n            if (s[from] !== l)\\n                notEqual--;\\n            from++;\\n        }\\n    }\\n    return res;\\n};\\n\\nvar characterReplacement = function(s, k) {\\n    let res = 0;\\n    for (let i = 0; i < 26; i++) {\\n        const l = String.fromCharCode('A'.charCodeAt(0) + i);\\n        res = Math.max(res, characterReplacementLetter(s, k, l));\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar characterReplacementLetter = function(s, k, l) {\\n    let res = 0, from = 0, to = -1, notEqual = 0;\\n    while (to < s.length - 1) {\\n        if (s[to + 1] === l || notEqual < k) {\\n            if (s[to + 1] !== l)\\n                notEqual++;\\n            to++;\\n            res = Math.max(res, to - from + 1);\\n        } else {\\n            if (s[from] !== l)\\n                notEqual--;\\n            from++;\\n        }\\n    }\\n    return res;\\n};\\n\\nvar characterReplacement = function(s, k) {\\n    let res = 0;\\n    for (let i = 0; i < 26; i++) {\\n        const l = String.fromCharCode('A'.charCodeAt(0) + i);\\n        res = Math.max(res, characterReplacementLetter(s, k, l));\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936568,
                "title": "simple-c-sliding-window-map",
                "content": "\\n# Intuition\\n\\nFor each number character x in s, create a sorted list indicesx of all indices i such that s[i] == x.\\nOn every indicesx, execute a sliding window technique.\\nFor each indicesx, find i, j such that (indicesx[j] - indicesx[i]) - (j - i) <= k and j - i + 1 is maximized. with extra value remaing with k\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n         unordered_map<int,vector<int>> m;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            m[s[i]].push_back(i);\\n        }\\n        int ans=0;\\n        for(auto it:m)\\n        {\\n            \\n            int sz=it.second.size();\\n            int i=0,j=0;\\n            while(j<sz)\\n            {\\n\\n                while(it.second[j]-it.second[i]-(j-i)>k) i++;\\n                int extra=k-(it.second[j]-it.second[i]-(j-i));\\n                // cout<<extra<<\" \";\\n                int curr=it.second[j]-it.second[i]+1;\\n\\n                if(it.second[i]>0)\\n                {\\n                    curr+=min(it.second[i],extra);\\n                    extra-=min(it.second[i],extra);\\n                }\\n                if(it.second[j]<n)\\n                {\\n                    curr+=min(n-it.second[j]-1,extra);\\n                    extra-=min(n-it.second[j]-1,extra);\\n                }\\n                // cout<<it.second[i]<<\"->\"<<it.second[j]<<\" \"<<endl;\\n                ans=max(ans,curr);\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n         unordered_map<int,vector<int>> m;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            m[s[i]].push_back(i);\\n        }\\n        int ans=0;\\n        for(auto it:m)\\n        {\\n            \\n            int sz=it.second.size();\\n            int i=0,j=0;\\n            while(j<sz)\\n            {\\n\\n                while(it.second[j]-it.second[i]-(j-i)>k) i++;\\n                int extra=k-(it.second[j]-it.second[i]-(j-i));\\n                // cout<<extra<<\" \";\\n                int curr=it.second[j]-it.second[i]+1;\\n\\n                if(it.second[i]>0)\\n                {\\n                    curr+=min(it.second[i],extra);\\n                    extra-=min(it.second[i],extra);\\n                }\\n                if(it.second[j]<n)\\n                {\\n                    curr+=min(n-it.second[j]-1,extra);\\n                    extra-=min(n-it.second[j]-1,extra);\\n                }\\n                // cout<<it.second[i]<<\"->\"<<it.second[j]<<\" \"<<endl;\\n                ans=max(ans,curr);\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3465122,
                "title": "python3-solution-with-explanation-quibler7",
                "content": "# Algorithm \\n\\n- Initialise `count` dict to keep count of occuring char in given string. initialise `res` to keep track of length of maximum repeating window as we have to return this as ouput. set left and right pointer to 0 and `maxf` to keep count of freq of char that is occuring most in our sliding window.\\n\\n- Using `r` pointer we will iterate through the given string and we will update the count of chars in our dict `count`. \\n\\n- We will also update the `maxf` as we go along. \\n\\n- While number of characters need to be replaced in our window are greater than number of characters we are allowed to replace i.e. `k` , we will shrink the size of the window and and we will dec the value of that char in our hashmap. \\n\\n- Number of characters allowed to replace is given i.e `k` and number of characters need to be replaced from out window is found using this formula. \\nSize of the current window `(r-l+1)` - max occuring char `(maxf)`\\nThis gives us number of char to be replaced. \\n\\n- we will update the max size `res` of our window as we iterate through the string.\\n\\n- Lastly we will return the max length `res` of sliding window. \\n\\n# Code\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        # initialize dict to count freq of char in given string\\n        count = {}\\n        # length of maximum window in order to return later as output\\n        res = 0\\n        # left pointer\\n        l = 0 \\n        # count of most frequently occuring character \\n        maxf = 0\\n        for r in range(len(s)):\\n            # add each char of string to dict\\n            count[s[r]] = 1 + count.get(s[r], 0)\\n            # update the max count as we go along \\n            maxf = max(maxf, count[s[r]])\\n            # while number of characters to be replaced from window are greater than \\n            # number of characters we are allowed to replace\\n            # shrink our sliding window\\n            while (r-l+1)-maxf > k:\\n                count[s[l]] -= 1\\n                l += 1\\n            # update the length of maximum repeating char window\\n            res = max(res, (r-l+1))\\n        # return res \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        # initialize dict to count freq of char in given string\\n        count = {}\\n        # length of maximum window in order to return later as output\\n        res = 0\\n        # left pointer\\n        l = 0 \\n        # count of most frequently occuring character \\n        maxf = 0\\n        for r in range(len(s)):\\n            # add each char of string to dict\\n            count[s[r]] = 1 + count.get(s[r], 0)\\n            # update the max count as we go along \\n            maxf = max(maxf, count[s[r]])\\n            # while number of characters to be replaced from window are greater than \\n            # number of characters we are allowed to replace\\n            # shrink our sliding window\\n            while (r-l+1)-maxf > k:\\n                count[s[l]] -= 1\\n                l += 1\\n            # update the length of maximum repeating char window\\n            res = max(res, (r-l+1))\\n        # return res \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280519,
                "title": "o-n-python3-easy-solution",
                "content": "\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        left = right = 0\\n        freq = {}\\n        max_count = 0\\n        longest = 0\\n        while right < len(s):\\n            freq[s[right]] = freq.get(s[right], 0) + 1\\n            max_count = max(max_count, freq[s[right]])\\n            if right - left + 1 - max_count > k:\\n                freq[s[left]] -= 1\\n                left += 1\\n            longest = max(longest, right - left + 1)\\n            right += 1\\n        return longest \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        left = right = 0\\n        freq = {}\\n        max_count = 0\\n        longest = 0\\n        while right < len(s):\\n            freq[s[right]] = freq.get(s[right], 0) + 1\\n            max_count = max(max_count, freq[s[right]])\\n            if right - left + 1 - max_count > k:\\n                freq[s[left]] -= 1\\n                left += 1\\n            longest = max(longest, right - left + 1)\\n            right += 1\\n        return longest \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871344,
                "title": "sliding-window-solution-python",
                "content": "Hi, here is a intuitive python solution.\\nCore ideas:\\n1. window requirement: letters inside window - most frequency letter inside window < k\\n2. For every valid window, we compare the current window size to previous best answer.\\n\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        l, r = 0, 0\\n        req = {}\\n        ans = 0\\n        while r < len(s):\\n\\t\\t\\t#update hashmap because our window changed\\n            req[s[r]] = 1 + req.get(s[r], 0)\\n            \\n\\t\\t\\t# check window requirement because window might no longer be valid\\n            while sum(req.values()) - max(req.values()) > k:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#tighten our window and update our window\\n                req[s[l]] -= 1\\n                l += 1\\n            \\n\\t\\t\\t#update our answer\\n            ans = max(ans, r - l + 1)\\n            \\n\\t\\t\\t#increase our window\\n            r += 1\\n                    \\n        return ans\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        l, r = 0, 0\\n        req = {}\\n        ans = 0\\n        while r < len(s):\\n\\t\\t\\t#update hashmap because our window changed\\n            req[s[r]] = 1 + req.get(s[r], 0)\\n            \\n\\t\\t\\t# check window requirement because window might no longer be valid\\n            while sum(req.values()) - max(req.values()) > k:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#tighten our window and update our window\\n                req[s[l]] -= 1\\n                l += 1\\n            \\n\\t\\t\\t#update our answer\\n            ans = max(ans, r - l + 1)\\n            \\n\\t\\t\\t#increase our window\\n            r += 1\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801868,
                "title": "c-easy-to-understand-using-sliding-window-intuition",
                "content": "```\\nclass Solution {\\npublic:\\n    // TC:O(N*26) SC:O(N)\\n    int characterReplacement(string s, int k) {\\n        // first think like we have to replace all the distinct characters to make a single longest repeating string. We can do this by replacing all the chars excpet the one whose freq is highest, i.e., length of string- freq of most repeating char. Now we can put the contstraint of k i.e length of string- freq of most repeating char <=k.\\n        vector<int> freq(26,0);\\n        int maxCharCount=0,i=0,j=0,res=0,n=s.length();\\n        while(j<n){\\n            freq[s[j]-\\'A\\']++;\\n            if(maxCharCount < freq[s[j]-\\'A\\']){\\n                maxCharCount=freq[s[j]-\\'A\\'];\\n            }\\n            // Checking if we havent consumed k fully\\n            while(j-i+1-maxCharCount>k){\\n                freq[s[i]-\\'A\\']--;\\n                i++;\\n                for(int i=0;i<26;i++){\\n                    maxCharCount=max(maxCharCount,freq[i]);\\n                }\\n            }\\n            res=max(res,j-i+1);\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```\\nGuys please like if you understand the approach. And if any doubt ask me in comments. ;)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // TC:O(N*26) SC:O(N)\\n    int characterReplacement(string s, int k) {\\n        // first think like we have to replace all the distinct characters to make a single longest repeating string. We can do this by replacing all the chars excpet the one whose freq is highest, i.e., length of string- freq of most repeating char. Now we can put the contstraint of k i.e length of string- freq of most repeating char <=k.\\n        vector<int> freq(26,0);\\n        int maxCharCount=0,i=0,j=0,res=0,n=s.length();\\n        while(j<n){\\n            freq[s[j]-\\'A\\']++;\\n            if(maxCharCount < freq[s[j]-\\'A\\']){\\n                maxCharCount=freq[s[j]-\\'A\\'];\\n            }\\n            // Checking if we havent consumed k fully\\n            while(j-i+1-maxCharCount>k){\\n                freq[s[i]-\\'A\\']--;\\n                i++;\\n                for(int i=0;i<26;i++){\\n                    maxCharCount=max(maxCharCount,freq[i]);\\n                }\\n            }\\n            res=max(res,j-i+1);\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764749,
                "title": "rust-sliding-window-keep-char-counts",
                "content": "# Intuition\\nMaintain a sliding window such that the counts of characters other than most frequent character is less than or equal to k. Consider the length of this candidate for k replacements with the length of other sliding windows.\\n\\n# Approach\\nKeep char counts for the sliding window, growing on the right in every iteration.\\nMaintain max frequency counter, updating it only when a new max is found.\\nWhen sliding window shrinks due to advancing left (since we cannot satisfy with k replacements), we don\\'t need to update max frequency because we already know the max window result len achievable with replacements on top of current max frequency, hence a decrease in max frequency cannot lead to a larger window. So we wait for next window that has a max frequency counter greater that\\'s greater than current max frequency, to check the update the max sliding window length.\\n\\n\\n# Complexity\\n- Time Complexity\\nO(N)\\n\\n- Space Complexity\\nO(1) since auxillary space consists of array of size 26 corresponding to number of uppercase alphabets, plus accumulators\\n\\n\\n# Code \\n\\n```\\nuse std::cmp::max;\\nconst NUM_ALPHA : usize = 26;\\n\\nimpl Solution {\\n    pub fn character_replacement(s: String, k: i32) -> i32 {\\n        let mut counts : [usize;NUM_ALPHA] = [0;NUM_ALPHA];\\n        let s = s.chars().collect::<Vec<_>>();\\n        (0..s.len()).fold((0, 0, 0), |(res_len, mut maxf, mut l), r| {\\n            counts[(s[r] as u8 - b\\'A\\') as usize] += 1;\\n            maxf = max(maxf, counts[(s[r] as u8 - b\\'A\\') as usize]);\\n            if (r - l + 1 ) - maxf > k as usize {\\n                counts[(s[l] as u8 - b\\'A\\') as usize] -= 1;\\n                l += 1;\\n            }\\n            (max(res_len, r - l  + 1), maxf, l)\\n        }).0 as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::max;\\nconst NUM_ALPHA : usize = 26;\\n\\nimpl Solution {\\n    pub fn character_replacement(s: String, k: i32) -> i32 {\\n        let mut counts : [usize;NUM_ALPHA] = [0;NUM_ALPHA];\\n        let s = s.chars().collect::<Vec<_>>();\\n        (0..s.len()).fold((0, 0, 0), |(res_len, mut maxf, mut l), r| {\\n            counts[(s[r] as u8 - b\\'A\\') as usize] += 1;\\n            maxf = max(maxf, counts[(s[r] as u8 - b\\'A\\') as usize]);\\n            if (r - l + 1 ) - maxf > k as usize {\\n                counts[(s[l] as u8 - b\\'A\\') as usize] -= 1;\\n                l += 1;\\n            }\\n            (max(res_len, r - l  + 1), maxf, l)\\n        }).0 as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2750877,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        d = {}\\n        slow = 0\\n        ans = 0\\n        for fast in range(len(s)):\\n            if s[fast] in d:\\n                d[s[fast]] += 1\\n            else:\\n                d[s[fast]] = 1\\n            \\n            # get max of the window and check if \\n            # length of the window - max valued key <= k\\n            \\n            if ((fast-slow+1) - max(d.values())) <= k:\\n                pass\\n            else:\\n                # shrink the window\\n                while ((fast-slow+1) - max(d.values())) > k:\\n                    d[s[slow]] -= 1\\n                    if d[s[slow]] == 0:\\n                        del d[s[slow]]\\n                    slow += 1\\n            # calculate the length of the window\\n            ans = max(ans, fast - slow + 1)\\n        return ans\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 2604073,
                "title": "my-understanding-of-one-pass-o-n-solution",
                "content": "This is an one pass solution. The idea is to use a sliding window. \\n\\n**We try to extend the window as wide as possible and keep searching a wider window.**(I don\\'t know if it can be regarded as greedy algo)\\n\\nLet\\'s call the subarrays that satisfy the condition `good subarrays`.\\n\\nThe window will not always be a `good subarray`, but it will never decrease its length(`sublen`).\\nThis is to make sure that we are able to find the `sublen+1` length good subarray.\\n\\nWe update the frequency of each character in the window and keep track of the most frequent character (can be done by comparing the max freq with the frequency of newly added element).\\nIf `maxfreq + k > sublen`, then we can extend the window (we find a new good subarray!). Otherwise, we need to pop the leftmost element.\\nFinally, return the max length of good subarray.\\n\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        counter = collections.defaultdict( int )  # use a dict to record the frequency of char in window\\n        sublen = 0  # the length of window\\n        maxfreq = 0  # max freq of char in window\\n        for i in range(len(s)):\\n            counter[s[i]] += 1\\n            maxfreq = max(maxfreq, counter[s[i]])\\n            if maxfreq + k > sublen:\\n                sublen += 1\\n            else:\\n                counter[s[i - sublen]] -= 1\\n        return sublen\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        counter = collections.defaultdict( int )  # use a dict to record the frequency of char in window\\n        sublen = 0  # the length of window\\n        maxfreq = 0  # max freq of char in window\\n        for i in range(len(s)):\\n            counter[s[i]] += 1\\n            maxfreq = max(maxfreq, counter[s[i]])\\n            if maxfreq + k > sublen:\\n                sublen += 1\\n            else:\\n                counter[s[i - sublen]] -= 1\\n        return sublen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468953,
                "title": "sliding-window-o-n",
                "content": "# Explanation\\n* maxf means the max frequency of the same character in the sliding window.\\n* To better understand the solution,\\n* you can firstly replace maxf with max(count.values()),\\n* Now I improve from O(26n) to O(n) using a just variable maxf.\\n\\n**Complexity**\\n*  Time O(n)\\n*  Space O(128)\\n\\n```\\nint characterReplacement(string s, int k) {\\n        int res = 0, maxf = 0;\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < s.length(); ++i) {\\n            maxf = max(maxf, ++count[s[i]]);\\n            if (res - maxf < k)\\n                res++;\\n            else\\n                count[s[i - res]]--;\\n        }\\n        return res;\\n    }\\n```\\n# Sliding Window:\\n* Another version of same idea.\\n* In a more standard format of sliding window.\\n* Maybe easier to understand\\n\\n```\\n int characterReplacement(string s, int k) {\\n        int maxf = 0, i = 0, n = s.length();\\n        vector<int> count(26);\\n        for (int j = 0; j < n; ++j) {\\n            maxf = max(maxf, ++count[s[j] - \\'A\\']);\\n            if (j - i + 1 > maxf + k)\\n                --count[s[i++] - \\'A\\'];\\n        }\\n        return n - i;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nint characterReplacement(string s, int k) {\\n        int res = 0, maxf = 0;\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < s.length(); ++i) {\\n            maxf = max(maxf, ++count[s[i]]);\\n            if (res - maxf < k)\\n                res++;\\n            else\\n                count[s[i - res]]--;\\n        }\\n        return res;\\n    }\\n```\n```\\n int characterReplacement(string s, int k) {\\n        int maxf = 0, i = 0, n = s.length();\\n        vector<int> count(26);\\n        for (int j = 0; j < n; ++j) {\\n            maxf = max(maxf, ++count[s[j] - \\'A\\']);\\n            if (j - i + 1 > maxf + k)\\n                --count[s[i++] - \\'A\\'];\\n        }\\n        return n - i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2403992,
                "title": "typescript-with-comments-sliding-window",
                "content": "```\\nfunction characterReplacement(s: string, k: number): number {\\n  let mostFrequentCharCount = 0;\\n  let ans = 0;\\n  const frequencyHash = {};\\n  \\n  for(let windowStart = 0, windowEnd = 0; windowEnd < s.length ; windowEnd++){\\n    \\n    // increase window size by adding new character\\n    const currentChar = s[windowEnd];\\n    if(!(currentChar in frequencyHash))\\n      frequencyHash[currentChar] = 0;\\n    frequencyHash[currentChar] += 1;\\n    \\n    // get the most frequent character count\\n    mostFrequentCharCount = Math.max(mostFrequentCharCount, frequencyHash[currentChar]);\\n    \\n    // decrease window size if number \\n    // of characters that need to be  \\n    // replaced is greater than k\\n    // Note that the +1 is needed because \\n    // we are dealing with 0 indexed counter\\n    let numberOfReplacements = windowEnd - windowStart - mostFrequentCharCount + 1;\\n    while(numberOfReplacements > k){\\n      const leftChar = s[windowStart];\\n      frequencyHash[leftChar] -= 1;\\n      windowStart++;\\n      numberOfReplacements = windowEnd - windowStart - mostFrequentCharCount + 1;\\n    }\\n    \\n    // take the max value between our previous\\n    // max and the current max\\n    ans = Math.max(ans, windowEnd - windowStart + 1);\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sliding Window"
                ],
                "code": "```\\nfunction characterReplacement(s: string, k: number): number {\\n  let mostFrequentCharCount = 0;\\n  let ans = 0;\\n  const frequencyHash = {};\\n  \\n  for(let windowStart = 0, windowEnd = 0; windowEnd < s.length ; windowEnd++){\\n    \\n    // increase window size by adding new character\\n    const currentChar = s[windowEnd];\\n    if(!(currentChar in frequencyHash))\\n      frequencyHash[currentChar] = 0;\\n    frequencyHash[currentChar] += 1;\\n    \\n    // get the most frequent character count\\n    mostFrequentCharCount = Math.max(mostFrequentCharCount, frequencyHash[currentChar]);\\n    \\n    // decrease window size if number \\n    // of characters that need to be  \\n    // replaced is greater than k\\n    // Note that the +1 is needed because \\n    // we are dealing with 0 indexed counter\\n    let numberOfReplacements = windowEnd - windowStart - mostFrequentCharCount + 1;\\n    while(numberOfReplacements > k){\\n      const leftChar = s[windowStart];\\n      frequencyHash[leftChar] -= 1;\\n      windowStart++;\\n      numberOfReplacements = windowEnd - windowStart - mostFrequentCharCount + 1;\\n    }\\n    \\n    // take the max value between our previous\\n    // max and the current max\\n    ans = Math.max(ans, windowEnd - windowStart + 1);\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2327129,
                "title": "sliding-window-python-code-with-proper-explanation",
                "content": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \"\"\"\\n        \\n        s = ABAB\\n        k = 2\\n        \\n        If we have no limit on k then we can say that \\n        (no of replacements to be done  = \\n        length of string - count of character with maximum occurence)\\n        \\n        AAAAAABB -  Here 2 replacements to be done\\n        ABABABABAA - Here 4 replacements to be done\\n        \\n        Let\\'s say there is a restriction on the number of updates done\\n        no. of replacements = len of str - min (count chars with max occur , k )\\n        \\n        If we change the problem statement from String to substring then we have to\\n        find the sustring of max length where atmost K repelacements can be done\\n        \\n        \\n        s = \"AABABBA\"\\n        k = 1\\n        \\n        i\\n        AABABBA count of max occur = 1 length of the substr = 1 repl = 0\\n        j\\n        \\n        i\\n        AABABBA count of max occur = 2 length of substr = 2 repl = 0\\n         j\\n         \\n        i\\n        AABABBA count max occur = 2 length of substr = 3 repl = 1\\n          j\\n        \\n        i\\n        AABABBA count max occur = 3 length of substr = 4 repl = 1\\n           j\\n           \\n        i\\n        AABABBA count max occur = 3 length of substr = 5 repl = 2\\n            j                       Here 2 > k => 2 > 1\\n                                    decrease window till repl becomes 1 again\\n         i\\n        AABABBA count max occur = 2 length of substr = 4 repl = 2\\n            j                          further decrease the window\\n            \\n          i   \\n        AABABBA count max occur = 2 length of substr = 3 repl = 1\\n            j\\n            \\n          i  \\n        AABABBA count max occur = 3 length of substr = 4 repl = 1\\n             j\\n             \\n          i\\n        AABABBA count max occur = 3 length of susbstr = 5 repl = 2 increase i\\n              j\\n            i  \\n        AABABBA    length of substr = 3\\n              j\\n              \\n              \\n    \\n        maximum length of substring with replacements that can be done = 1 is 4\\n        \\n        At any particular moment we need (max occur,length of substr,repl)\\n        \\n        \"\"\"\\n        # In the below line we are keeping the count of each character in the string\\n        count = collections.Counter()\\n        # i : start of the window\\n        # j : end of the window\\n        i = j = 0\\n        # maxLen : maximum length of the substring\\n        maxLen = 0\\n        # maxOccur will store the count of max occurring character in the window\\n        maxOccur = None\\n        while j < len(s):\\n            # Increase the count of characters as we are increasing the window\\n            count[s[j]] += 1\\n            # maxOccur : count maximum occurring character in the window\\n            maxOccur = count[max(count , key = lambda x: count[x])]\\n            j += 1\\n            # length of substring - count of character with maximum occurence <= k\\n            while j - i - maxOccur > k :\\n                # We are decreasing the count here \\n                count[s[i]] -= 1\\n                # Here we are again updating maxOccur\\n                maxOccur = count[max(count , key = lambda x: count[x])]\\n                # and then we are decreasing the window\\n                i += 1\\n            maxLen = max(maxLen , j - i)\\n        return maxLen\\n    \\n    # Time complexity is nearly O(n) as max operation can run for atmost 26 characters\\n            \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \"\"\"\\n        \\n        s = ABAB\\n        k = 2\\n        \\n        If we have no limit on k then we can say that \\n        (no of replacements to be done  = \\n        length of string - count of character with maximum occurence)\\n        \\n        AAAAAABB -  Here 2 replacements to be done\\n        ABABABABAA - Here 4 replacements to be done\\n        \\n        Let\\'s say there is a restriction on the number of updates done\\n        no. of replacements = len of str - min (count chars with max occur , k )\\n        \\n        If we change the problem statement from String to substring then we have to\\n        find the sustring of max length where atmost K repelacements can be done\\n        \\n        \\n        s = \"AABABBA\"\\n        k = 1\\n        \\n        i\\n        AABABBA count of max occur = 1 length of the substr = 1 repl = 0\\n        j\\n        \\n        i\\n        AABABBA count of max occur = 2 length of substr = 2 repl = 0\\n         j\\n         \\n        i\\n        AABABBA count max occur = 2 length of substr = 3 repl = 1\\n          j\\n        \\n        i\\n        AABABBA count max occur = 3 length of substr = 4 repl = 1\\n           j\\n           \\n        i\\n        AABABBA count max occur = 3 length of substr = 5 repl = 2\\n            j                       Here 2 > k => 2 > 1\\n                                    decrease window till repl becomes 1 again\\n         i\\n        AABABBA count max occur = 2 length of substr = 4 repl = 2\\n            j                          further decrease the window\\n            \\n          i   \\n        AABABBA count max occur = 2 length of substr = 3 repl = 1\\n            j\\n            \\n          i  \\n        AABABBA count max occur = 3 length of substr = 4 repl = 1\\n             j\\n             \\n          i\\n        AABABBA count max occur = 3 length of susbstr = 5 repl = 2 increase i\\n              j\\n            i  \\n        AABABBA    length of substr = 3\\n              j\\n              \\n              \\n    \\n        maximum length of substring with replacements that can be done = 1 is 4\\n        \\n        At any particular moment we need (max occur,length of substr,repl)\\n        \\n        \"\"\"\\n        # In the below line we are keeping the count of each character in the string\\n        count = collections.Counter()\\n        # i : start of the window\\n        # j : end of the window\\n        i = j = 0\\n        # maxLen : maximum length of the substring\\n        maxLen = 0\\n        # maxOccur will store the count of max occurring character in the window\\n        maxOccur = None\\n        while j < len(s):\\n            # Increase the count of characters as we are increasing the window\\n            count[s[j]] += 1\\n            # maxOccur : count maximum occurring character in the window\\n            maxOccur = count[max(count , key = lambda x: count[x])]\\n            j += 1\\n            # length of substring - count of character with maximum occurence <= k\\n            while j - i - maxOccur > k :\\n                # We are decreasing the count here \\n                count[s[i]] -= 1\\n                # Here we are again updating maxOccur\\n                maxOccur = count[max(count , key = lambda x: count[x])]\\n                # and then we are decreasing the window\\n                i += 1\\n            maxLen = max(maxLen , j - i)\\n        return maxLen\\n    \\n    # Time complexity is nearly O(n) as max operation can run for atmost 26 characters\\n            \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275002,
                "title": "detailed-explanation-for-o-n-implementation-with-python",
                "content": "Dear all,\\n\\nSliding window and hashtable are the key methods used in solving this problem, but maybe the most tricky problem lies in how to decide when should the \"window\" slides. So that\\'s why I want to do some explanations here.\\n\\n# 1. General Idea\\nTo find the longest substring containing the same letter after k changes, the most straight-forward idea is: \\n\\n**Step1.** Iterate every possible substring\\n**Step2.** Check whether it contains the same letter after k changes\\nif yes, record the length\\n\\nOf course **brute force** is ok to do the two steps. But here we can optimize step1 with **sliding window**, and we can also optimize step2 with **hash table**! Here we go!\\n\\n# 2. Why  \"sliding window\"?\\nSliding window is the most common one used in array and string. Of course it\\'s ok to iterate every possible substring by brute force, but we don\\'t have to. The point is that, we want to find the **LONGEST** substring. So when a long substring satisfies, we don\\'t need to look for anything shorter than that. They won\\'t make any difference to the anwser!\\n\\nTherefore, sliding window helps us to do that. The right pointer moves to the end as uaual. But as for the left pointer, we don\\'t need to move it from 0 to the right pointer each time. In a certain sliding window, if this window satisfies the requirement, there is no need to check for a smaller window (which means moving the left pointer to right). We need to look for longer window that could possibly get a larger result (which means moving the right pointer to right). \\n\\n# 3. Why  \"hash table\"?\\nHash table is also a common used method in array and string. The biggest advantage is its O(1) time complexity if we want to search for something in it. In **step2**, we find that the number of charaters in the substring matters, so we use hashtable to record the most frequent character in the sliding window. \\n\\n# 4. How should the sliding window move?\\nThe length of the substring is (right pointer - left pinter + 1). Also, with the help of hashtable, we know the most frequent character number (max_count) in the substring. So when (max_count >= right pointer - left pinter + 1  - k), it is ok to change at least k characters to make all letters the same. This may be the most important formula in this problem.\\n\\n**For (max_count >= right pointer - left pinter + 1  - k)**\\nIf it is True, Great! We don\\'t need to move left pointer. We just go ahead moving right pointer to look for longer substring like that. \\nIf it is False, Oops! Maybe some shorter substring ending in right pointer would still satisfies the requirement. So don\\'t hurry to move the right pointer now, we still need to move the left pointer to check. \\n\\n# 5. Python Implementation\\nWith explainations above, I believe the code below could be more understandable.\\n\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        l,r = 0,0 # initiate left and right pointers\\n        counter = {} # initiate a counter for charactors between the s[left pointer] and s[right pointer]\\n        max_len = 0 # the result, longest length we could possibly achieve\\n        max_count = 0 # the largest number in counter (to avoid using \"max\" for counter, which results in O(n) time complexity)\\n        while r < len(s): \\n            # add the new charactor s[r] into the counter\\n            if not s[r] in counter:\\n                counter[s[r]] = 1\\n            else:\\n                counter[s[r]] += 1\\n            max_count = max(max_count,counter[s[r]])# as mentioned above, to avoid using \"max\"\\n            if max_count >= r - l + 1 - k: # Great, go ahead moving right pointer to look for longer substring\\n                max_len = max(max_len,r - l + 1)\\n            else: # Oops! Maybe some shorter substring ending in right pointer would still satisfies the requirement. So don\\'t hurry to move the right pointer now, we still need to move the left pointer to check. \\n                counter[s[l]] -= 1\\n                l += 1 \\n            r += 1\\n        return max_len\\n```\\n\\nThank you for reading.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Hash Table",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        l,r = 0,0 # initiate left and right pointers\\n        counter = {} # initiate a counter for charactors between the s[left pointer] and s[right pointer]\\n        max_len = 0 # the result, longest length we could possibly achieve\\n        max_count = 0 # the largest number in counter (to avoid using \"max\" for counter, which results in O(n) time complexity)\\n        while r < len(s): \\n            # add the new charactor s[r] into the counter\\n            if not s[r] in counter:\\n                counter[s[r]] = 1\\n            else:\\n                counter[s[r]] += 1\\n            max_count = max(max_count,counter[s[r]])# as mentioned above, to avoid using \"max\"\\n            if max_count >= r - l + 1 - k: # Great, go ahead moving right pointer to look for longer substring\\n                max_len = max(max_len,r - l + 1)\\n            else: # Oops! Maybe some shorter substring ending in right pointer would still satisfies the requirement. So don\\'t hurry to move the right pointer now, we still need to move the left pointer to check. \\n                counter[s[l]] -= 1\\n                l += 1 \\n            r += 1\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274025,
                "title": "c-solution",
                "content": "```\\nint characterReplacement(char * s, int k){\\n    \\n    int sLen=strlen(s);\\n    \\n    unsigned table[255] = {0};\\n\\n    unsigned diff=0;\\n    unsigned max_same=0;\\n    for( unsigned left = 0, right=0; right<sLen; right++){\\n        \\n        // Move right pointer \\n        table[s[right]]++;\\n        \\n        // Update max_same\\n        if(table[s[right]]>max_same)\\n           max_same = table[s[right]];\\n        \\n        // Or update diff\\n        else if(diff<k) diff++;\\n        \\n        // Or move left pointer\\n        else table[s[left++]]--; \\n        \\n    }    \\n    return max_same+diff;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint characterReplacement(char * s, int k){\\n    \\n    int sLen=strlen(s);\\n    \\n    unsigned table[255] = {0};\\n\\n    unsigned diff=0;\\n    unsigned max_same=0;\\n    for( unsigned left = 0, right=0; right<sLen; right++){\\n        \\n        // Move right pointer \\n        table[s[right]]++;\\n        \\n        // Update max_same\\n        if(table[s[right]]>max_same)\\n           max_same = table[s[right]];\\n        \\n        // Or update diff\\n        else if(diff<k) diff++;\\n        \\n        // Or move left pointer\\n        else table[s[left++]]--; \\n        \\n    }    \\n    return max_same+diff;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2266380,
                "title": "c-hash-map-sliding-window-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int res = 0, maxf = 0;\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < s.length(); ++i) {\\n            maxf = max(maxf, ++count[s[i]]);\\n            if (res - maxf < k)\\n                res++;\\n            else\\n                count[s[i - res]]--;\\n        }\\n        return res;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int res = 0, maxf = 0;\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < s.length(); ++i) {\\n            maxf = max(maxf, ++count[s[i]]);\\n            if (res - maxf < k)\\n                res++;\\n            else\\n                count[s[i - res]]--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2241866,
                "title": "c-90-faster",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int ans = 0;\\n        int n = s.length();\\n        int win_start=0;\\n        int win_end=0;\\n        vector<int> char_count(26,0);\\n        int count_of_max_freq_char=0;\\n        \\n        for(win_end=0;win_end<n;win_end++) {\\n            char_count[s[win_end]-\\'A\\']++;\\n            count_of_max_freq_char = max(count_of_max_freq_char, char_count[s[win_end]-\\'A\\']);\\n            if(win_end - win_start + 1 - count_of_max_freq_char > k) {\\n                char_count[s[win_start]-\\'A\\']--;\\n                win_start++;\\n            }\\n            ans = max(ans, win_end-win_start+1);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int ans = 0;\\n        int n = s.length();\\n        int win_start=0;\\n        int win_end=0;\\n        vector<int> char_count(26,0);\\n        int count_of_max_freq_char=0;\\n        \\n        for(win_end=0;win_end<n;win_end++) {\\n            char_count[s[win_end]-\\'A\\']++;\\n            count_of_max_freq_char = max(count_of_max_freq_char, char_count[s[win_end]-\\'A\\']);\\n            if(win_end - win_start + 1 - count_of_max_freq_char > k) {\\n                char_count[s[win_start]-\\'A\\']--;\\n                win_start++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2212936,
                "title": "c-sliding-window-o-n-map",
                "content": "**Algorithm**\\nIn this algorithm, I used a sliding window. Its right limit increases (increasing window size) if the validation criterea is met, and its left window increases otherwise (reducing size).\\n\\n**Validation Criterea**\\nI keep track of the count of each character in a map and in the validation character I check in a loop (with max iterations of 26) that the total count of all characters - count of maximum repeated character is less than k. This indicates that the lowest repeating characters sum up to a number less than k which means that we can change them to the other character which is repeated more.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(map<char, int> m, int k){\\n        int total =0, mx=-1;\\n        for(auto i=m.begin();i!=m.end();i++){\\n            mx = max(i->second,mx);\\n            total+=i->second;\\n        }\\n        return total-mx <= k;\\n    }\\n    int characterReplacement(string s, int k) {\\n        map<char, int> m;\\n        int l=0,r=1,mx=-1;\\n        m[s[0]]++;\\n        while(r<=s.length()){\\n            if(isValid(m,k)){//if size = 1, valid\\n                mx=max(mx,r-l);\\n                r++;\\n                m[s[r-1]]++; \\n            }else{\\n                l++;\\n                m[s[l-1]]--;\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(map<char, int> m, int k){\\n        int total =0, mx=-1;\\n        for(auto i=m.begin();i!=m.end();i++){\\n            mx = max(i->second,mx);\\n            total+=i->second;\\n        }\\n        return total-mx <= k;\\n    }\\n    int characterReplacement(string s, int k) {\\n        map<char, int> m;\\n        int l=0,r=1,mx=-1;\\n        m[s[0]]++;\\n        while(r<=s.length()){\\n            if(isValid(m,k)){//if size = 1, valid\\n                mx=max(mx,r-l);\\n                r++;\\n                m[s[r-1]]++; \\n            }else{\\n                l++;\\n                m[s[l-1]]--;\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185024,
                "title": "java-standard-sliding-window-very-easy-to-understand",
                "content": "```\\n class Solution {\\n    public int characterReplacement(String s, int k) {\\n        int maxLen = 0, maxf = 0;\\n        Map<Character, Integer> map = new HashMap<Character, Integer>();\\n        for(int l = 0, r = 0; r < s.length(); r++){ //left and right pointers\\n            map.put(s.charAt(r), map.getOrDefault(s.charAt(r),0)+1); //put character and the number of this character into map\\n            maxf = Math.max(maxf, map.get(s.charAt(r))); //the number of the most frequency number between left and right pointer\\n            if(maxf + k < r - l + 1)  {\\n                map.put(s.charAt(l), map.getOrDefault(s.charAt(l),0)-1); //if it is too long(has exceeded number), let left++ , and number of left character --\\n                l++;\\n            }\\n            maxLen = Math.max(maxLen, r - l + 1); //update maxLength\\n        }\\n        return maxLen;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n class Solution {\\n    public int characterReplacement(String s, int k) {\\n        int maxLen = 0, maxf = 0;\\n        Map<Character, Integer> map = new HashMap<Character, Integer>();\\n        for(int l = 0, r = 0; r < s.length(); r++){ //left and right pointers\\n            map.put(s.charAt(r), map.getOrDefault(s.charAt(r),0)+1); //put character and the number of this character into map\\n            maxf = Math.max(maxf, map.get(s.charAt(r))); //the number of the most frequency number between left and right pointer\\n            if(maxf + k < r - l + 1)  {\\n                map.put(s.charAt(l), map.getOrDefault(s.charAt(l),0)-1); //if it is too long(has exceeded number), let left++ , and number of left character --\\n                l++;\\n            }\\n            maxLen = Math.max(maxLen, r - l + 1); //update maxLength\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059762,
                "title": "simple-c-solution-unordered-map-and-sliding-window",
                "content": "```\\n unordered_map<char,int>m;\\n        int cal()//calculates the maxmum occuring character in the window\\n        {\\n                int maxi=1;\\n                for(auto p:m)\\n                {\\n                        maxi=max(maxi,p.second);\\n                }\\n                return maxi;\\n        }\\n    int characterReplacement(string s, int k) {\\n       \\n            int n=s.length();\\n            int i=0;\\n            int j=0;\\n            int ans=1;\\n            while(j<n)\\n            {\\n                  m[s[j]]++;\\n                    int maxi=cal();//maximum ocurring character\\n                    int win=j-i+1;//window size\\n                    if(win-maxi<=k)\\n                    {\\n                            ans=max(ans,j-i+1);\\n                    }\\n                    else\\n                    {\\n                            m[s[i]]--;\\n                            if(m[s[i]]==0)\\n                                    m.erase(s[i]);\\n                            i++;\\n                    }\\n                    j++;\\n            }\\n            return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n unordered_map<char,int>m;\\n        int cal()//calculates the maxmum occuring character in the window\\n        {\\n                int maxi=1;\\n                for(auto p:m)\\n                {\\n                        maxi=max(maxi,p.second);\\n                }\\n                return maxi;\\n        }\\n    int characterReplacement(string s, int k) {\\n       \\n            int n=s.length();\\n            int i=0;\\n            int j=0;\\n            int ans=1;\\n            while(j<n)\\n            {\\n                  m[s[j]]++;\\n                    int maxi=cal();//maximum ocurring character\\n                    int win=j-i+1;//window size\\n                    if(win-maxi<=k)\\n                    {\\n                            ans=max(ans,j-i+1);\\n                    }\\n                    else\\n                    {\\n                            m[s[i]]--;\\n                            if(m[s[i]]==0)\\n                                    m.erase(s[i]);\\n                            i++;\\n                    }\\n                    j++;\\n            }\\n            return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2027715,
                "title": "java-brute-force-sliding-window-explained",
                "content": "Similar problems:\\n[longest-substring-without-repeating-characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/2027343/java-brute-force-sliding-window-explained)\\n# Brute-Force\\nThe problem asks us to find the longest substring such that, there are at most `k` characters which must be changed, after which point the substring will consist entirely of the same character. So we can try to expand a substring from each character as the head. The easiest way to convert a string to one which is composed of only one character, is to know which character appears most frequently in that string, and convert every other character in the string which is NOT that char, to that character. Thus we maintain `mostFrequent`, which tells us how many times the most frequent character appears in the given substring. We don\\'t need to know what that character is exactly - we just need to know if the substring is within `k` replacements of being a substring comprised of only that character.\\n\\n`TC: O(N^2)`\\n`SC: O(26)= O(1)`. Number of possible keys in hashmap.\\n\\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        if (k == s.length()) return s.length();\\n        \\n        Map<Character, Integer> freq; \\n\\n        int max = 0;\\n        \\n        for (int left = 0; left < s.length(); left++) {\\n            \\n            freq = new HashMap();\\n            int mostFrequent = 1;\\n            \\n            for (int right = left; right < s.length(); right++) {\\n                \\n                if (!freq.containsKey(s.charAt(right))) freq.put(s.charAt(right), 0);\\n                freq.put(s.charAt(right), freq.get(s.charAt(right)) + 1);\\n                mostFrequent = Math.max(mostFrequent, freq.get(s.charAt(right)));\\n                \\n                if ((right - left + 1) - mostFrequent > k) break;\\n                else max = Math.max(max, right - left + 1);\\n                \\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\\n# Sliding-Window\\nInstead of restarting the substring extension from the next head character each time we fail to extend the current substring, we can try to \\'correct\\' the current substring as soon as right refers to a repeated character by removing characters from the start, until we remove enough characters such that the number of characters in the window which are not the character associated with `mostFrequent`, is `<= k`; i.e., the substring is within `k` replacements of being a substring comprised of only that character.\\n\\nAlthought `mostFrequent` becomes inaccurate after we start removing characters, it is acceptable because it is guaranteed that the window after removals will be a valid window, and because `max` will not get updated with this new window size. When `mostFrequent` is updated again at start of next iteration, it is guaranteed to be the right value because we were updating `freq` while removing characters.\\n\\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        if (k == s.length()) return s.length();\\n        \\n        Map<Character, Integer> freq = new HashMap();\\n\\n        int left = 0, right = 0, max = 1;\\n        int mostFrequent = 1;\\n        \\n        while (right < s.length()) {\\n            \\n            if (!freq.containsKey(s.charAt(right))) freq.put(s.charAt(right), 0);\\n            freq.put(s.charAt(right), freq.get(s.charAt(right)) + 1);\\n            mostFrequent = Math.max(mostFrequent, freq.get(s.charAt(right)));\\n\\n            while ((right - left + 1) - mostFrequent > k) freq.put(s.charAt(left), freq.get(s.charAt(left++)) - 1);\\n            max = Math.max(max, right - left + 1);\\n            right++;\\n\\n        }\\n        \\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        if (k == s.length()) return s.length();\\n        \\n        Map<Character, Integer> freq; \\n\\n        int max = 0;\\n        \\n        for (int left = 0; left < s.length(); left++) {\\n            \\n            freq = new HashMap();\\n            int mostFrequent = 1;\\n            \\n            for (int right = left; right < s.length(); right++) {\\n                \\n                if (!freq.containsKey(s.charAt(right))) freq.put(s.charAt(right), 0);\\n                freq.put(s.charAt(right), freq.get(s.charAt(right)) + 1);\\n                mostFrequent = Math.max(mostFrequent, freq.get(s.charAt(right)));\\n                \\n                if ((right - left + 1) - mostFrequent > k) break;\\n                else max = Math.max(max, right - left + 1);\\n                \\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        if (k == s.length()) return s.length();\\n        \\n        Map<Character, Integer> freq = new HashMap();\\n\\n        int left = 0, right = 0, max = 1;\\n        int mostFrequent = 1;\\n        \\n        while (right < s.length()) {\\n            \\n            if (!freq.containsKey(s.charAt(right))) freq.put(s.charAt(right), 0);\\n            freq.put(s.charAt(right), freq.get(s.charAt(right)) + 1);\\n            mostFrequent = Math.max(mostFrequent, freq.get(s.charAt(right)));\\n\\n            while ((right - left + 1) - mostFrequent > k) freq.put(s.charAt(left), freq.get(s.charAt(left++)) - 1);\\n            max = Math.max(max, right - left + 1);\\n            right++;\\n\\n        }\\n        \\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999913,
                "title": "easy-java-solution-using-sliding-window-and-hashmap",
                "content": "class Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        int left=0;\\n        int result=0;\\n        int maxFreq=0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n        //increase the window by incrementing the right pointer\\n        for(int right=0;right<s.length();right++){\\n            char right_char = s.charAt(right);\\n            map.put(right_char,map.getOrDefault(right_char,0)+1);\\n            maxFreq = Math.max(maxFreq,map.get(right_char));\\n            \\n            int window= right-left+1;\\n            if(window-maxFreq>k)\\n            {\\n                char left_char = s.charAt(left);\\n                map.put(left_char, map.get(left_char)-1);  \\n                left++;\\n            }\\n            result = Math.max(result,right-left+1);\\n        }\\n       return result; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int characterReplacement(String s, int k) {\\n        \\n        int left=0;\\n        int result=0;\\n        int maxFreq=0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n        //increase the window by incrementing the right pointer\\n        for(int right=0;right<s.length();right++){\\n            char right_char = s.charAt(right);\\n            map.put(right_char,map.getOrDefault(right_char,0)+1);\\n            maxFreq = Math.max(maxFreq,map.get(right_char));\\n            \\n            int window= right-left+1;\\n            if(window-maxFreq>k)\\n            {\\n                char left_char = s.charAt(left);\\n                map.put(left_char, map.get(left_char)-1);  \\n                left++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1982960,
                "title": "java-easy-explains-why-not-to-update-maxrepeatcharcount-sliding-window-o-n",
                "content": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int left = 0 , n = s.length();\\n        char[] sArray = s.toCharArray();\\n        int maxRepeatCharCount = 0;\\n        int[] count = new int[26];\\n        int longest = 0;\\n        \\n        for(int right = 0; right < n; right++) {\\n            char ch = sArray[right];\\n            count[ch-\\'A\\']++;\\n            maxRepeatCharCount = Math.max(maxRepeatCharCount, count[ch-\\'A\\']);\\n            int windowSize = right - left + 1;\\n            int replaceCount = windowSize - maxRepeatCharCount;\\n            while(replaceCount > k){\\n                count[sArray[left]-\\'A\\']--;\\n                left++;\\n                replaceCount--;\\n            }\\n            if(right-left + 1 > longest) {\\n                longest = right-left + 1;\\n            }\\n        }\\n        return longest;\\n    }\\n}\\n\\n// Q: Why we don\\'t update maxRepeatCharCount while shrinking the window?\\n// A: We can, but it won\\'t effect the result longest = right - left + 1. Here\\'s why:\\n\\n// longest is recorded while this inequation stays true: windowSize - maxRepeatCharCount <= k\\n// Let\\'s say the we record longest = 6, with the inequation being 6 - 4 <= 2\\n// during sliding window we expand the window and say it becomes 7, then there are 3 possibilities:\\n\\n// maxRepeatCharCount decreases:\\n// 7 - 3 <= 2 => false\\n\\n// maxRepeatCharCount stays the same:\\n// 7 - 4 <= 2 => false\\n\\n// maxRepeatCharCount increases:\\n// 7 - 5 <= 2 => true\\n\\n// this means the only case when we can get a longer window is when maxRepeatCharCount also increases alongside. \\n// If maxRepeatCharCount doesn\\'t increase, the line Math.max(longest, right - left + 1) will not update longest. \\n// Therefore, there\\'s no value in updating maxRepeatCharCount when its not increasing.\\n// If this still doesn\\'t make sense, then feel free to always update maxRepeatCharCount and store all counts of all chars in a max heap.\\n//Retrieve the top of the heap everytime its required. Alternatively you can scan the frequency map linearly to find the max, but that\\'d be less efficient.\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n        int left = 0 , n = s.length();\\n        char[] sArray = s.toCharArray();\\n        int maxRepeatCharCount = 0;\\n        int[] count = new int[26];\\n        int longest = 0;\\n        \\n        for(int right = 0; right < n; right++) {\\n            char ch = sArray[right];\\n            count[ch-\\'A\\']++;\\n            maxRepeatCharCount = Math.max(maxRepeatCharCount, count[ch-\\'A\\']);\\n            int windowSize = right - left + 1;\\n            int replaceCount = windowSize - maxRepeatCharCount;\\n            while(replaceCount > k){\\n                count[sArray[left]-\\'A\\']--;\\n                left++;\\n                replaceCount--;\\n            }\\n            if(right-left + 1 > longest) {\\n                longest = right-left + 1;\\n            }\\n        }\\n        return longest;\\n    }\\n}\\n\\n// Q: Why we don\\'t update maxRepeatCharCount while shrinking the window?\\n// A: We can, but it won\\'t effect the result longest = right - left + 1. Here\\'s why:\\n\\n// longest is recorded while this inequation stays true: windowSize - maxRepeatCharCount <= k\\n// Let\\'s say the we record longest = 6, with the inequation being 6 - 4 <= 2\\n// during sliding window we expand the window and say it becomes 7, then there are 3 possibilities:\\n\\n// maxRepeatCharCount decreases:\\n// 7 - 3 <= 2 => false\\n\\n// maxRepeatCharCount stays the same:\\n// 7 - 4 <= 2 => false\\n\\n// maxRepeatCharCount increases:\\n// 7 - 5 <= 2 => true\\n\\n// this means the only case when we can get a longer window is when maxRepeatCharCount also increases alongside. \\n// If maxRepeatCharCount doesn\\'t increase, the line Math.max(longest, right - left + 1) will not update longest. \\n// Therefore, there\\'s no value in updating maxRepeatCharCount when its not increasing.\\n// If this still doesn\\'t make sense, then feel free to always update maxRepeatCharCount and store all counts of all chars in a max heap.\\n//Retrieve the top of the heap everytime its required. Alternatively you can scan the frequency map linearly to find the max, but that\\'d be less efficient.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884666,
                "title": "simple-python-solution-beats-99-o-n",
                "content": "- **if the window size (right-left+1) is bigger than the num of most repeating chars(k+max_freq)**\\n  -  then it means there is more than k of not repeating chars \\n- **so window should be moved (left += 1)**\\n- **the window size(right-left-1) keeps remaining max_size**\\n- **which is equivalent to Num of Longest Repeating Character**\\n\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        ans, left, max_freq = 0, 0, 0\\n        counter = collections.defaultdict(int)\\n        \\n        for right in range(len(s)):\\n            counter[s[right]] += 1\\n            max_freq = max(max_freq, counter[s[right]])\\n\\n            if right - left + 1 > k + max_freq: \\n                counter[s[left]] -= 1\\n                left += 1\\n\\t\\t\\t\\n\\t\\t\\tans = right - left + 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        ans, left, max_freq = 0, 0, 0\\n        counter = collections.defaultdict(int)\\n        \\n        for right in range(len(s)):\\n            counter[s[right]] += 1\\n            max_freq = max(max_freq, counter[s[right]])\\n\\n            if right - left + 1 > k + max_freq: \\n                counter[s[left]] -= 1\\n                left += 1\\n\\t\\t\\t\\n\\t\\t\\tans = right - left + 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794227,
                "title": "java-using-sliding-window-and-hashmap-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n\\t\\t//To record current max repeated counts of character\\n        int maxRepeat = 0;\\n        int start = 0;\\n        int longest = 0;\\n        Map<Character, Integer> charMap = new HashMap<>();        \\n        for(int end = 0; end < s.length(); end++){\\n            char right = s.charAt(end);\\n            charMap.put(right, charMap.getOrDefault(right, 0) + 1);\\n\\t\\t\\t//Update the maxRepeat counts\\n            maxRepeat = Math.max(maxRepeat, charMap.get(right));\\n            if(end - start + 1 - maxRepeat > k){\\n                char left = s.charAt(start);\\n                charMap.put(left, charMap.get(left) - 1);\\n                if(charMap.get(left) == 0){\\n                    charMap.remove(left);\\n                }\\n                start++;\\n            }\\n\\t\\t\\t//Update the longest substring\\n            longest = Math.max(longest, end - start + 1);\\n        }\\n        return longest;        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int characterReplacement(String s, int k) {\\n\\t\\t//To record current max repeated counts of character\\n        int maxRepeat = 0;\\n        int start = 0;\\n        int longest = 0;\\n        Map<Character, Integer> charMap = new HashMap<>();        \\n        for(int end = 0; end < s.length(); end++){\\n            char right = s.charAt(end);\\n            charMap.put(right, charMap.getOrDefault(right, 0) + 1);\\n\\t\\t\\t//Update the maxRepeat counts\\n            maxRepeat = Math.max(maxRepeat, charMap.get(right));\\n            if(end - start + 1 - maxRepeat > k){\\n                char left = s.charAt(start);\\n                charMap.put(left, charMap.get(left) - 1);\\n                if(charMap.get(left) == 0){\\n                    charMap.remove(left);\\n                }\\n                start++;\\n            }\\n\\t\\t\\t//Update the longest substring\\n            longest = Math.max(longest, end - start + 1);\\n        }\\n        return longest;        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774181,
                "title": "java-sliding-window-explained",
                "content": "**Idea:** Use Sliding Window template explained [here](https://leetcode.com/discuss/study-guide/1773891/Sliding-Window-Technique-and-Question-Bank)\\n>**T/S:** O(n)/O(1), where n = size(s)\\n```\\npublic int characterReplacement(String s, int k) {\\n\\tvar longest = Integer.MIN_VALUE;\\n\\n\\tfor (int left = 0, right = 0, maxRepeatCharCount = 0, charCount[] = new int[26]; right < s.length(); right++) {\\n\\t\\n\\t\\tmaxRepeatCharCount = Math.max(maxRepeatCharCount, ++charCount[s.charAt(right) - \\'A\\']);\\n\\n\\t\\twhile (right - left + 1 - maxRepeatCharCount > k) // while replaceable chars > k, shrink the window\\n\\t\\t\\tcharCount[s.charAt(left++) - \\'A\\']--;\\n\\t\\t\\n\\t\\tlongest = Math.max(longest, right - left + 1);\\n\\t}\\n\\treturn longest == Integer.MIN_VALUE ? 0 : longest;\\n}\\n```\\n\\nQ: Why we don\\'t update `maxRepeatCharCount` while shrinking the window? \\nA: We can, but it won\\'t effect the result `longest = right - left + 1`. Here\\'s why:\\n* `longest` is recorded while this inequation stays true: `windowLength - maxRepeatCharCount <= k`\\n* Let\\'s say the we record `longest` = 6, with the inequation being 6 - 4 <= 2\\n* during sliding window we expand the window and say it becomes 7, then there are 3 possibilities:\\n\\t* `maxRepeatCharCount` decreases:\\n\\t\\t* 7 - 3 <= 2 => false\\n\\t* `maxRepeatCharCount` stays the same: \\n\\t\\t* 7 - 4 <= 2 => false\\n\\t* `maxRepeatCharCount` increases:\\n\\t\\t* 7 - 4 <= 2 => true\\n\\t* this means the only case when we can get a longer window is when `maxRepeatCharCount` also increases alongside. If `maxRepeatCharCount` doesn\\'t increase, the line `Math.max(longest, right - left + 1)` will not update `longest`. Therefore, there\\'s no value in updating `maxRepeatCharCount` when its not increasing.\\n\\t* If this still doesn\\'t make sense, then feel free to always update `maxRepeatCharCount` and store all counts of all chars in a max heap. Retrieve the top of the heap everytime its required. Alternatively you can scan the frequency map linearly to find the max, but that\\'d be less efficient.\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int characterReplacement(String s, int k) {\\n\\tvar longest = Integer.MIN_VALUE;\\n\\n\\tfor (int left = 0, right = 0, maxRepeatCharCount = 0, charCount[] = new int[26]; right < s.length(); right++) {\\n\\t\\n\\t\\tmaxRepeatCharCount = Math.max(maxRepeatCharCount, ++charCount[s.charAt(right) - \\'A\\']);\\n\\n\\t\\twhile (right - left + 1 - maxRepeatCharCount > k) // while replaceable chars > k, shrink the window\\n\\t\\t\\tcharCount[s.charAt(left++) - \\'A\\']--;\\n\\t\\t\\n\\t\\tlongest = Math.max(longest, right - left + 1);\\n\\t}\\n\\treturn longest == Integer.MIN_VALUE ? 0 : longest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688152,
                "title": "c-sliding-window",
                "content": "```\\n//sliding window approach\\nint characterReplacement(string s, int k) {\\n\\tvector<int> freq(26, 0); //keeps frequency of character of the window\\n\\n\\tint l = 0;\\n\\tint maxLength = 0, maxFreq = 0;\\n\\n\\tfor (int r = 0; r < s.size(); ++r){\\n\\t\\tfreq[s[r] - \\'A\\']++;\\n\\t\\tmaxFreq = max (maxFreq, freq[s[r] - \\'A\\']);\\n\\n\\t\\tint windowSize = r - l + 1;\\n\\n\\t\\tif (windowSize - maxFreq > k){\\n\\t\\t\\t//character replacement not affordable\\n\\t\\t\\tfreq[s[l] - \\'A\\']--;\\n\\t\\t\\tl++;\\n\\t\\t}else{\\n\\t\\t\\tmaxLength = max(maxLength, windowSize);\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxLength;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//sliding window approach\\nint characterReplacement(string s, int k) {\\n\\tvector<int> freq(26, 0); //keeps frequency of character of the window\\n\\n\\tint l = 0;\\n\\tint maxLength = 0, maxFreq = 0;\\n\\n\\tfor (int r = 0; r < s.size(); ++r){\\n\\t\\tfreq[s[r] - \\'A\\']++;\\n\\t\\tmaxFreq = max (maxFreq, freq[s[r] - \\'A\\']);\\n\\n\\t\\tint windowSize = r - l + 1;\\n\\n\\t\\tif (windowSize - maxFreq > k){\\n\\t\\t\\t//character replacement not affordable\\n\\t\\t\\tfreq[s[l] - \\'A\\']--;\\n\\t\\t\\tl++;\\n\\t\\t}else{\\n\\t\\t\\tmaxLength = max(maxLength, windowSize);\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxLength;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585789,
                "title": "python-sliding-window-approach",
                "content": "The sliding window approach is great for this problem\\n\\nI use a HashMap to count the frequency of each letter\\n1. Then iterate through the string to add 1 letter at a time in the window\\n2. I also keep track of the count of the maximum repeating letter in **any** window -> `maxRepeatLetterCount`\\n3. So, at any time, we know that we do have a window with 1 letter repeating `maxRepeatLetterCount` times; this means we should try to replace the remaining letters\\n\\t- If the remaining letters are less than or equal to `k`, we can replace them all\\n\\t- If we have more than `k` remaining letters, we should shrink the window as we cannot replace more than `k` letters\\n\\nWhile shrinking the window, we don\\'t need to update `maxRepeatLetterCount` (hence, it represents the maximum repeating count of **any** letter for **any** window\\nWe don\\'t need to update this count, since we have to replace all the remaining letters to get the longest substring having the same letter in any window, we can\\'t get a better answer from any other window even though all occurrences of the letter with frequency `maxRepeatLetterCount` is not in the current window\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        windowStart = 0\\n        maxRepeatLetterCount = 0\\n        maxLength = 0\\n        \\n        char_freq = {}\\n        \\n        for windowEnd in range(len(s)):\\n            rightChar = s[windowEnd]\\n            if rightChar not in char_freq:\\n                char_freq[rightChar] = 0\\n            char_freq[rightChar] += 1\\n            \\n            maxRepeatLetterCount = max(maxRepeatLetterCount, char_freq[rightChar])\\n            \\n            if (windowEnd-windowStart+1 - maxRepeatLetterCount) > k:\\n                leftChar = s[windowStart]\\n                char_freq[leftChar] -= 1\\n                windowStart += 1\\n            \\n            \\n            maxLength = max(maxLength, windowEnd-windowStart+1)\\n        return maxLength\\n```            \\n`Time: O(n) ` - where `n` is the number of letters in the input string\\n`Space: O(1)` - Since we can only expect uppercase letters in the input string, we can conclude that the space complexity will be `O(26)` to store each letter\\'s frequency in the **HashMap**, which is asymptotically equal to `O(1)`\\n\\nHope my solution was easy to follow!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        windowStart = 0\\n        maxRepeatLetterCount = 0\\n        maxLength = 0\\n        \\n        char_freq = {}\\n        \\n        for windowEnd in range(len(s)):\\n            rightChar = s[windowEnd]\\n            if rightChar not in char_freq:\\n                char_freq[rightChar] = 0\\n            char_freq[rightChar] += 1\\n            \\n            maxRepeatLetterCount = max(maxRepeatLetterCount, char_freq[rightChar])\\n            \\n            if (windowEnd-windowStart+1 - maxRepeatLetterCount) > k:\\n                leftChar = s[windowStart]\\n                char_freq[leftChar] -= 1\\n                windowStart += 1\\n            \\n            \\n            maxLength = max(maxLength, windowEnd-windowStart+1)\\n        return maxLength\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568732,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1565503,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1564933,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1724391,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1567439,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1894589,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1567086,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1567041,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1798529,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1719042,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1568732,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1565503,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1564933,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1724391,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1567439,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1894589,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1567086,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1567041,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1798529,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1719042,
                "content": [
                    {
                        "username": "gtfoamzn",
                        "content": "Since I feel like many solutions didn\\'t explain clearly why it was called \"sliding window\" (or I was too dumb to understand), here\\'s my attempt to explain in simplest of terms: \\n\\nFirst, if you start from the beginning (first character of string), intuitively you know that we want to keep looking down the string until there are `k` characters that are different from the most popular. This is \"expanding the window until it\\'s not a valid window anymore\". This means moving the right pointer to the right, one by one, until `(length of the substring) - (the \"count of most popular character\") = k`. We monitor the condition by keeping track of the most popular character with `maxCount`. Simply, when we see a character, we increment its count, and check if it\\'s greater than `maxCount`. If it is, we update `maxCount`. \\n\\nAt this point, we have a window from `start` to `end`, and it has `maxCount` + `k` characters in it. We know we can\\'t keep expanding the window (since there are already `k` characters different from our most popular one). So what do we do? We just slide the entire window down. **Why?** Because the window represents our best answer so far, and anything less than this window we don\\'t care about (remember, we\\'re trying to find the largest window in this string). So it doesn\\'t make sense to shrink the window. While we slide the window, we do 2 things: 1) we see a new character at `end`, and add that to the `count` array. 2) We also decrement the count of the character at `start`, which is now out of the window. \\n\\nAt this point, we only need to know whether the total count of the new character at `end` (which represents the accurate count of this character within the window) is greater than our `maxCount`, which represents the most popular character count **for the current window size** that we have seen. If any new character\\'s count exceeds the `maxCount`, that means: we have found a character in the current window that is even more popular for **this given window size**. Which means, we should now expand the window until we have `k` \"weirdos\" again! We do this be extending out `end` by 1, and now we have a bigger window and a new `maxCount`. Any new character we see will have to beat this `maxCount` for us to expand the window again. Every step, you move the `end` pointer down the string. If you can expand the window, then you move the `end` and nothing else. If you can\\'t expand the window without violating the rule, then you slide the window by also moving the `start` forward. \\n\\nDon\\'t forget, the \"size of the window\" is basically the value that we are trying to find the biggest value for. As you slide the window down, you\\'re basically saying something like: \"I have a window of length 4, where 2 of the characters were the same (the `maxCount` characters). Can I find any other window with the same length, but more characters that are the same? If so, then I can expand my window and I\\'ve found a larger window. Save this window length as my current best answer. Now repeat until I get to the end. Then return the largest window I saw in this string.\""
                    },
                    {
                        "username": "Hariharan98",
                        "content": "You sir deserve a golden medallion!"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "U saved my life! Thanks"
                    },
                    {
                        "username": "ahmedhjaj",
                        "content": "Thank you so much! What a great explaination. Please, upvote everybody."
                    },
                    {
                        "username": "Dishank_Baid05",
                        "content": "Explained Nicely...Appreciated!"
                    },
                    {
                        "username": "Ankita1129",
                        "content": "Best Explanation! Please upvote the above explanation so that it will be on the top. Thank you very much [@lcgtfoamzn](/gtfoamzn)"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This explanation is amazing! Thank you for writing it! I also recommend anyone who\\'s struggling with this question reading it! "
                    },
                    {
                        "username": "Last-Autumn-Leaf",
                        "content": "Great explanation Thank you very much !"
                    },
                    {
                        "username": "Petersburg",
                        "content": "This feels hard..."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt) I thought that question was much easier than this one. They do feel similar though"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "[@Cdr_Rjt](/Cdr_Rjt)  Thanks! Youre legendary"
                    },
                    {
                        "username": "mauro23",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "i think u should try this question first, Max Consecutive Ones III \\n. And then try this question . And then thank me later.  ;)"
                    },
                    {
                        "username": "newcodingage",
                        "content": " it took me 5 hours, and I still gave up to look for an explanation for learning."
                    },
                    {
                        "username": "Phil123095",
                        "content": "[@kathuriarahul93](/kathuriarahul93) This comment made me cry hahahah"
                    },
                    {
                        "username": "kathuriarahul93",
                        "content": "Life is hard as well :\\'("
                    },
                    {
                        "username": "Joy4fun",
                        "content": "Given a string that consists of only uppercase English letters, **you can replace any letter in the string with another letter at most k times.** Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\\n\\nThe bold line above is confusing.\\n\\nInterpretation 1: Does it means to allow us replace every single letter for at most K times? \\nHumm well it's not, if it is then I think just by mentioning 1 times is enough and there's no need to emphasis K times.\\n\\ninterpretation 2: Does it means to allow us replace every unique letter for at most K times?\\nThis interpretation works for both example 1 and 2.\\nInput:\\ns = \"ABAB\", k = 2\\nOutput:\\n4\\nWe change letter A in this string for 2 times/We can change letter B in this string for 2 times\\n\\nBut when I was thinking how about the input is:\\ns = \"ACBABBE\", k = 1\\nThen I was thinking we can change letter C to B for once and change A to B for once and finally E to B for once to get \"ABBBBBB\", the output is 6. \\n\\nHowever I was wrong again...\\n\\nAnd after seeing other posts here, I finally realized that this question actually wants you **to replace at most k letters in this string** , that's it:)\\n\\nI strongly advice to avoid ambiguous definition/interpretation using broken english in question description."
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Thank you for clarifying description!"
                    },
                    {
                        "username": "pyush98",
                        "content": "6 years later I confirm that bolded part is written horribly"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "exactly! Thought it\\'s just me!"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "wtf is this\\n"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "That\\'s what she said"
                    },
                    {
                        "username": "jiangtianh",
                        "content": "i feel you "
                    },
                    {
                        "username": "156k",
                        "content": "When I first saw this problem, DP came to my mind. Does anyone have a DP solution?"
                    },
                    {
                        "username": "dhaliman",
                        "content": "I wrote a DP solution with time complexity Theta(n^2*k) in the worst case. Not much better than brute force."
                    },
                    {
                        "username": "SightVanish",
                        "content": "No clue the first time I saw this. This should be marked as hard."
                    },
                    {
                        "username": "tianxin117",
                        "content": "I\\'ve read so many explanations for this problem but I\\'m still confused. I understand that we want to subtract the count of the most frequent repeating character in the window from the total length of the window. However, in all of the optimal solutions, we keep track of the _global_ maximum instead of the maximum in the current window. Why are we able to do that?"
                    },
                    {
                        "username": "leeminze214",
                        "content": "its because the global maximum is what will ultimately give the best/longest result. So even if we do encounter a new substring's maximum frequently repeated character, that is shorter or the same length as the previous, it wouldn't be able to provide a better/longer answer. Because to satisfy the formula for the number of characters up for replacement (length_of_substring - max_repeating_count <= K), max_repeating_count must be maximized. That's why we just keep track of the global maximum."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@akabdul1](/akabdul1) What do you mean? Let\\'s say there is this string: `\"ABCADEAGHH\"` here there are 3 A and 2 H. If `k=1` and we switch G to H, max result is 3, and this substring \"GHH\" doesn\\'t include \"A\"?"
                    },
                    {
                        "username": "akabdul1",
                        "content": "there doesn\\'t exist a solution where the maximum occurring character in the global sense isn\\'t in the subset with the longest repeating character replacement."
                    },
                    {
                        "username": "sumit_kumar",
                        "content": "Do you mean returning end - start + 1, instead of having a maxLength field which would keep track of maximum length always?"
                    },
                    {
                        "username": "user9801Vf",
                        "content": "At every point we che k if we can increase the length of our sliding window.\\nWe can increase it only if after adding the new character the length of the current sliding window - max frequency in current window <k.\\nOtherwise we add the new character and delete the first character and thus keep the size of the sliding window same."
                    },
                    {
                        "username": "keratonjava",
                        "content": "Oh this is hard, I got the feeling of a solution but it always have an edge case/perf case that rebuke. Finally made it. But not very happy about the performance"
                    },
                    {
                        "username": "mezzichai",
                        "content": "I'll bet you did the procedural approach that involves loop nesting, I did the same initially, until I looked at other solutions. Sliding window is worth getting familiar with for problems like this, you will write way less code and have good time complexity."
                    },
                    {
                        "username": "billyokra",
                        "content": "After watching video, I am more confident on sliding window. Folks, if you need guidance about sliding window, you may watch this video. It gave me the framework to solving this problem.\\n\\n[Sliding Window Technique - Algorithmic Mental Models](https://youtu.be/MK-NZ4hN7rs)"
                    }
                ]
            },
            {
                "id": 1576151,
                "content": [
                    {
                        "username": "jimmywutangclan",
                        "content": "Is there any proof for tracking the most common character that it doesn\\'t have to be updated when the sliding window is moved leftwards?\\n\\nI just can\\'t bring myself to make this assumption without a proof that it works"
                    },
                    {
                        "username": "djslim",
                        "content": "it's because we update max only if it's bigger than previous max, so if we lower it by one, the curr number will be still either bigger or equal to the other characters, Technically you can also keep track of it as it's only 26 letters to iterate over"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I hate sliding window problems. "
                    },
                    {
                        "username": "kropochev",
                        "content": "Same question as:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/"
                    },
                    {
                        "username": "stultiloquator",
                        "content": "Confused by the description? Congrats, that means you read it well. Perhaps this more verbose reformulation will help:\\n\\nYou are given a string `s` consisting of upper case English characters, and an integer `k`. \\n\\nLet `char` be an uppercase English character, a `char`-substitution is an operation that replaces any single character in `s` by `char`.\\n\\nYou are allowed to operate on `s` by fixing a `char`  and performing at most `k` `char`-substitutions.\\n\\nReturn the length of the longest possible substring containing the same letter that is obtainable after performing an allowable operation.\\n"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If an interviewer asks for O(n), s/he is a douchebag."
                    },
                    {
                        "username": "riteshgupta0cam",
                        "content": "If you have solved Max Consecutive Ones III . this should feel easy as this Q some extra addition over that Q. TC might be compromised a little bit i.e (O(26 * N + NlogN) in worst case) but at first glance this could be the solution. "
                    },
                    {
                        "username": "aasthad27",
                        "content": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int j=-1;\\n        int maxi=INT_MIN;\\n        int len=0;\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'A\\')\\n            {\\n                c++;\\n            }\\n            while(c>k)\\n            {\\n                j++;\\n                if(s[j]==\\'A\\')\\n                {\\n                    c--;\\n                }\\n            }\\n            len=i-j;\\n            maxi=max(maxi,len);\\n        }\\n        return maxi;\\n    \\n    }\\n}; It is failing at TC : \\'AAAA\\' k=2 , output :2 , expected:4 "
                    },
                    {
                        "username": "Akshat_0308",
                        "content": "different kind of question seems complex"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Hi, I\\'m confused with this question. How for the test case\\ns= \"IMNJJTRMJEGMSOLSCCQICIHLQIOGBJAEHQOCRAJQMBIBATGLJDTBNCPIFRDLRIJHRABBJGQAOLIKRLHDRIGERENNMJSDSSMESSTR\"\\nk=2\\n\\nThe answer is 6 and not 5\\nI\\'m getting 5 by converting \"CCQIC\" at 16th index (0-indexed) to \"CCCCC\". \\n\\nThanks in advance for help."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Sorry, I got the answer. It\\'s \"SSMESS\" at index 90. I missed it."
                    },
                    {
                        "username": "anirudhata123",
                        "content": "In this question we use the sliding window technique. We take slices of the string and store the frequencies of each element in a HashMap. In that slice of string we subtract the length of the slice of the string with the most frequency repeating character. This gives us the total number of characters that can be replaced in the string. If the total number of replaceable characters is greater than the total permitted number of changes, then the substring is not valid(i.e to get maximum number of repeated characters we will have to make more than permitted number of \\nreplacements. In that case we move the left pointer ahead). On the other hand if the result of subtraction comes out to be less than the permitted number of changes(we can get repeating characters by making less than or equal to number of changes in the slice)we take the max of the length of the current slice and the global maximum after that we update the right pointer"
                    },
                    {
                        "username": "jamesinhel",
                        "content": "The reference to \"operation\" in the phrase \"You perform this operation at most k times\" is ambiguous. It is unclear if subsequent operations need to be tied to the values I had chosen for the first execution of the operation or if I am free to perform the operation without being constrained to the previously used values.\n\nFor example, if k=2 and I chose to replace A with B then, when I do the operation again, am I constrained to change another A to B or, do I get to choose another letter, say C, and change it to B?\n"
                    }
                ]
            },
            {
                "id": 2014665,
                "content": [
                    {
                        "username": "jimmywutangclan",
                        "content": "Is there any proof for tracking the most common character that it doesn\\'t have to be updated when the sliding window is moved leftwards?\\n\\nI just can\\'t bring myself to make this assumption without a proof that it works"
                    },
                    {
                        "username": "djslim",
                        "content": "it's because we update max only if it's bigger than previous max, so if we lower it by one, the curr number will be still either bigger or equal to the other characters, Technically you can also keep track of it as it's only 26 letters to iterate over"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I hate sliding window problems. "
                    },
                    {
                        "username": "kropochev",
                        "content": "Same question as:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/"
                    },
                    {
                        "username": "stultiloquator",
                        "content": "Confused by the description? Congrats, that means you read it well. Perhaps this more verbose reformulation will help:\\n\\nYou are given a string `s` consisting of upper case English characters, and an integer `k`. \\n\\nLet `char` be an uppercase English character, a `char`-substitution is an operation that replaces any single character in `s` by `char`.\\n\\nYou are allowed to operate on `s` by fixing a `char`  and performing at most `k` `char`-substitutions.\\n\\nReturn the length of the longest possible substring containing the same letter that is obtainable after performing an allowable operation.\\n"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If an interviewer asks for O(n), s/he is a douchebag."
                    },
                    {
                        "username": "riteshgupta0cam",
                        "content": "If you have solved Max Consecutive Ones III . this should feel easy as this Q some extra addition over that Q. TC might be compromised a little bit i.e (O(26 * N + NlogN) in worst case) but at first glance this could be the solution. "
                    },
                    {
                        "username": "aasthad27",
                        "content": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int j=-1;\\n        int maxi=INT_MIN;\\n        int len=0;\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'A\\')\\n            {\\n                c++;\\n            }\\n            while(c>k)\\n            {\\n                j++;\\n                if(s[j]==\\'A\\')\\n                {\\n                    c--;\\n                }\\n            }\\n            len=i-j;\\n            maxi=max(maxi,len);\\n        }\\n        return maxi;\\n    \\n    }\\n}; It is failing at TC : \\'AAAA\\' k=2 , output :2 , expected:4 "
                    },
                    {
                        "username": "Akshat_0308",
                        "content": "different kind of question seems complex"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Hi, I\\'m confused with this question. How for the test case\\ns= \"IMNJJTRMJEGMSOLSCCQICIHLQIOGBJAEHQOCRAJQMBIBATGLJDTBNCPIFRDLRIJHRABBJGQAOLIKRLHDRIGERENNMJSDSSMESSTR\"\\nk=2\\n\\nThe answer is 6 and not 5\\nI\\'m getting 5 by converting \"CCQIC\" at 16th index (0-indexed) to \"CCCCC\". \\n\\nThanks in advance for help."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Sorry, I got the answer. It\\'s \"SSMESS\" at index 90. I missed it."
                    },
                    {
                        "username": "anirudhata123",
                        "content": "In this question we use the sliding window technique. We take slices of the string and store the frequencies of each element in a HashMap. In that slice of string we subtract the length of the slice of the string with the most frequency repeating character. This gives us the total number of characters that can be replaced in the string. If the total number of replaceable characters is greater than the total permitted number of changes, then the substring is not valid(i.e to get maximum number of repeated characters we will have to make more than permitted number of \\nreplacements. In that case we move the left pointer ahead). On the other hand if the result of subtraction comes out to be less than the permitted number of changes(we can get repeating characters by making less than or equal to number of changes in the slice)we take the max of the length of the current slice and the global maximum after that we update the right pointer"
                    },
                    {
                        "username": "jamesinhel",
                        "content": "The reference to \"operation\" in the phrase \"You perform this operation at most k times\" is ambiguous. It is unclear if subsequent operations need to be tied to the values I had chosen for the first execution of the operation or if I am free to perform the operation without being constrained to the previously used values.\n\nFor example, if k=2 and I chose to replace A with B then, when I do the operation again, am I constrained to change another A to B or, do I get to choose another letter, say C, and change it to B?\n"
                    }
                ]
            },
            {
                "id": 1959391,
                "content": [
                    {
                        "username": "jimmywutangclan",
                        "content": "Is there any proof for tracking the most common character that it doesn\\'t have to be updated when the sliding window is moved leftwards?\\n\\nI just can\\'t bring myself to make this assumption without a proof that it works"
                    },
                    {
                        "username": "djslim",
                        "content": "it's because we update max only if it's bigger than previous max, so if we lower it by one, the curr number will be still either bigger or equal to the other characters, Technically you can also keep track of it as it's only 26 letters to iterate over"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I hate sliding window problems. "
                    },
                    {
                        "username": "kropochev",
                        "content": "Same question as:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/"
                    },
                    {
                        "username": "stultiloquator",
                        "content": "Confused by the description? Congrats, that means you read it well. Perhaps this more verbose reformulation will help:\\n\\nYou are given a string `s` consisting of upper case English characters, and an integer `k`. \\n\\nLet `char` be an uppercase English character, a `char`-substitution is an operation that replaces any single character in `s` by `char`.\\n\\nYou are allowed to operate on `s` by fixing a `char`  and performing at most `k` `char`-substitutions.\\n\\nReturn the length of the longest possible substring containing the same letter that is obtainable after performing an allowable operation.\\n"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If an interviewer asks for O(n), s/he is a douchebag."
                    },
                    {
                        "username": "riteshgupta0cam",
                        "content": "If you have solved Max Consecutive Ones III . this should feel easy as this Q some extra addition over that Q. TC might be compromised a little bit i.e (O(26 * N + NlogN) in worst case) but at first glance this could be the solution. "
                    },
                    {
                        "username": "aasthad27",
                        "content": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int j=-1;\\n        int maxi=INT_MIN;\\n        int len=0;\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'A\\')\\n            {\\n                c++;\\n            }\\n            while(c>k)\\n            {\\n                j++;\\n                if(s[j]==\\'A\\')\\n                {\\n                    c--;\\n                }\\n            }\\n            len=i-j;\\n            maxi=max(maxi,len);\\n        }\\n        return maxi;\\n    \\n    }\\n}; It is failing at TC : \\'AAAA\\' k=2 , output :2 , expected:4 "
                    },
                    {
                        "username": "Akshat_0308",
                        "content": "different kind of question seems complex"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Hi, I\\'m confused with this question. How for the test case\\ns= \"IMNJJTRMJEGMSOLSCCQICIHLQIOGBJAEHQOCRAJQMBIBATGLJDTBNCPIFRDLRIJHRABBJGQAOLIKRLHDRIGERENNMJSDSSMESSTR\"\\nk=2\\n\\nThe answer is 6 and not 5\\nI\\'m getting 5 by converting \"CCQIC\" at 16th index (0-indexed) to \"CCCCC\". \\n\\nThanks in advance for help."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Sorry, I got the answer. It\\'s \"SSMESS\" at index 90. I missed it."
                    },
                    {
                        "username": "anirudhata123",
                        "content": "In this question we use the sliding window technique. We take slices of the string and store the frequencies of each element in a HashMap. In that slice of string we subtract the length of the slice of the string with the most frequency repeating character. This gives us the total number of characters that can be replaced in the string. If the total number of replaceable characters is greater than the total permitted number of changes, then the substring is not valid(i.e to get maximum number of repeated characters we will have to make more than permitted number of \\nreplacements. In that case we move the left pointer ahead). On the other hand if the result of subtraction comes out to be less than the permitted number of changes(we can get repeating characters by making less than or equal to number of changes in the slice)we take the max of the length of the current slice and the global maximum after that we update the right pointer"
                    },
                    {
                        "username": "jamesinhel",
                        "content": "The reference to \"operation\" in the phrase \"You perform this operation at most k times\" is ambiguous. It is unclear if subsequent operations need to be tied to the values I had chosen for the first execution of the operation or if I am free to perform the operation without being constrained to the previously used values.\n\nFor example, if k=2 and I chose to replace A with B then, when I do the operation again, am I constrained to change another A to B or, do I get to choose another letter, say C, and change it to B?\n"
                    }
                ]
            },
            {
                "id": 1952332,
                "content": [
                    {
                        "username": "jimmywutangclan",
                        "content": "Is there any proof for tracking the most common character that it doesn\\'t have to be updated when the sliding window is moved leftwards?\\n\\nI just can\\'t bring myself to make this assumption without a proof that it works"
                    },
                    {
                        "username": "djslim",
                        "content": "it's because we update max only if it's bigger than previous max, so if we lower it by one, the curr number will be still either bigger or equal to the other characters, Technically you can also keep track of it as it's only 26 letters to iterate over"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I hate sliding window problems. "
                    },
                    {
                        "username": "kropochev",
                        "content": "Same question as:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/"
                    },
                    {
                        "username": "stultiloquator",
                        "content": "Confused by the description? Congrats, that means you read it well. Perhaps this more verbose reformulation will help:\\n\\nYou are given a string `s` consisting of upper case English characters, and an integer `k`. \\n\\nLet `char` be an uppercase English character, a `char`-substitution is an operation that replaces any single character in `s` by `char`.\\n\\nYou are allowed to operate on `s` by fixing a `char`  and performing at most `k` `char`-substitutions.\\n\\nReturn the length of the longest possible substring containing the same letter that is obtainable after performing an allowable operation.\\n"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If an interviewer asks for O(n), s/he is a douchebag."
                    },
                    {
                        "username": "riteshgupta0cam",
                        "content": "If you have solved Max Consecutive Ones III . this should feel easy as this Q some extra addition over that Q. TC might be compromised a little bit i.e (O(26 * N + NlogN) in worst case) but at first glance this could be the solution. "
                    },
                    {
                        "username": "aasthad27",
                        "content": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int j=-1;\\n        int maxi=INT_MIN;\\n        int len=0;\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'A\\')\\n            {\\n                c++;\\n            }\\n            while(c>k)\\n            {\\n                j++;\\n                if(s[j]==\\'A\\')\\n                {\\n                    c--;\\n                }\\n            }\\n            len=i-j;\\n            maxi=max(maxi,len);\\n        }\\n        return maxi;\\n    \\n    }\\n}; It is failing at TC : \\'AAAA\\' k=2 , output :2 , expected:4 "
                    },
                    {
                        "username": "Akshat_0308",
                        "content": "different kind of question seems complex"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Hi, I\\'m confused with this question. How for the test case\\ns= \"IMNJJTRMJEGMSOLSCCQICIHLQIOGBJAEHQOCRAJQMBIBATGLJDTBNCPIFRDLRIJHRABBJGQAOLIKRLHDRIGERENNMJSDSSMESSTR\"\\nk=2\\n\\nThe answer is 6 and not 5\\nI\\'m getting 5 by converting \"CCQIC\" at 16th index (0-indexed) to \"CCCCC\". \\n\\nThanks in advance for help."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Sorry, I got the answer. It\\'s \"SSMESS\" at index 90. I missed it."
                    },
                    {
                        "username": "anirudhata123",
                        "content": "In this question we use the sliding window technique. We take slices of the string and store the frequencies of each element in a HashMap. In that slice of string we subtract the length of the slice of the string with the most frequency repeating character. This gives us the total number of characters that can be replaced in the string. If the total number of replaceable characters is greater than the total permitted number of changes, then the substring is not valid(i.e to get maximum number of repeated characters we will have to make more than permitted number of \\nreplacements. In that case we move the left pointer ahead). On the other hand if the result of subtraction comes out to be less than the permitted number of changes(we can get repeating characters by making less than or equal to number of changes in the slice)we take the max of the length of the current slice and the global maximum after that we update the right pointer"
                    },
                    {
                        "username": "jamesinhel",
                        "content": "The reference to \"operation\" in the phrase \"You perform this operation at most k times\" is ambiguous. It is unclear if subsequent operations need to be tied to the values I had chosen for the first execution of the operation or if I am free to perform the operation without being constrained to the previously used values.\n\nFor example, if k=2 and I chose to replace A with B then, when I do the operation again, am I constrained to change another A to B or, do I get to choose another letter, say C, and change it to B?\n"
                    }
                ]
            },
            {
                "id": 1993715,
                "content": [
                    {
                        "username": "jimmywutangclan",
                        "content": "Is there any proof for tracking the most common character that it doesn\\'t have to be updated when the sliding window is moved leftwards?\\n\\nI just can\\'t bring myself to make this assumption without a proof that it works"
                    },
                    {
                        "username": "djslim",
                        "content": "it's because we update max only if it's bigger than previous max, so if we lower it by one, the curr number will be still either bigger or equal to the other characters, Technically you can also keep track of it as it's only 26 letters to iterate over"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I hate sliding window problems. "
                    },
                    {
                        "username": "kropochev",
                        "content": "Same question as:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/"
                    },
                    {
                        "username": "stultiloquator",
                        "content": "Confused by the description? Congrats, that means you read it well. Perhaps this more verbose reformulation will help:\\n\\nYou are given a string `s` consisting of upper case English characters, and an integer `k`. \\n\\nLet `char` be an uppercase English character, a `char`-substitution is an operation that replaces any single character in `s` by `char`.\\n\\nYou are allowed to operate on `s` by fixing a `char`  and performing at most `k` `char`-substitutions.\\n\\nReturn the length of the longest possible substring containing the same letter that is obtainable after performing an allowable operation.\\n"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If an interviewer asks for O(n), s/he is a douchebag."
                    },
                    {
                        "username": "riteshgupta0cam",
                        "content": "If you have solved Max Consecutive Ones III . this should feel easy as this Q some extra addition over that Q. TC might be compromised a little bit i.e (O(26 * N + NlogN) in worst case) but at first glance this could be the solution. "
                    },
                    {
                        "username": "aasthad27",
                        "content": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int j=-1;\\n        int maxi=INT_MIN;\\n        int len=0;\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'A\\')\\n            {\\n                c++;\\n            }\\n            while(c>k)\\n            {\\n                j++;\\n                if(s[j]==\\'A\\')\\n                {\\n                    c--;\\n                }\\n            }\\n            len=i-j;\\n            maxi=max(maxi,len);\\n        }\\n        return maxi;\\n    \\n    }\\n}; It is failing at TC : \\'AAAA\\' k=2 , output :2 , expected:4 "
                    },
                    {
                        "username": "Akshat_0308",
                        "content": "different kind of question seems complex"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Hi, I\\'m confused with this question. How for the test case\\ns= \"IMNJJTRMJEGMSOLSCCQICIHLQIOGBJAEHQOCRAJQMBIBATGLJDTBNCPIFRDLRIJHRABBJGQAOLIKRLHDRIGERENNMJSDSSMESSTR\"\\nk=2\\n\\nThe answer is 6 and not 5\\nI\\'m getting 5 by converting \"CCQIC\" at 16th index (0-indexed) to \"CCCCC\". \\n\\nThanks in advance for help."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Sorry, I got the answer. It\\'s \"SSMESS\" at index 90. I missed it."
                    },
                    {
                        "username": "anirudhata123",
                        "content": "In this question we use the sliding window technique. We take slices of the string and store the frequencies of each element in a HashMap. In that slice of string we subtract the length of the slice of the string with the most frequency repeating character. This gives us the total number of characters that can be replaced in the string. If the total number of replaceable characters is greater than the total permitted number of changes, then the substring is not valid(i.e to get maximum number of repeated characters we will have to make more than permitted number of \\nreplacements. In that case we move the left pointer ahead). On the other hand if the result of subtraction comes out to be less than the permitted number of changes(we can get repeating characters by making less than or equal to number of changes in the slice)we take the max of the length of the current slice and the global maximum after that we update the right pointer"
                    },
                    {
                        "username": "jamesinhel",
                        "content": "The reference to \"operation\" in the phrase \"You perform this operation at most k times\" is ambiguous. It is unclear if subsequent operations need to be tied to the values I had chosen for the first execution of the operation or if I am free to perform the operation without being constrained to the previously used values.\n\nFor example, if k=2 and I chose to replace A with B then, when I do the operation again, am I constrained to change another A to B or, do I get to choose another letter, say C, and change it to B?\n"
                    }
                ]
            },
            {
                "id": 1983903,
                "content": [
                    {
                        "username": "jimmywutangclan",
                        "content": "Is there any proof for tracking the most common character that it doesn\\'t have to be updated when the sliding window is moved leftwards?\\n\\nI just can\\'t bring myself to make this assumption without a proof that it works"
                    },
                    {
                        "username": "djslim",
                        "content": "it's because we update max only if it's bigger than previous max, so if we lower it by one, the curr number will be still either bigger or equal to the other characters, Technically you can also keep track of it as it's only 26 letters to iterate over"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I hate sliding window problems. "
                    },
                    {
                        "username": "kropochev",
                        "content": "Same question as:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/"
                    },
                    {
                        "username": "stultiloquator",
                        "content": "Confused by the description? Congrats, that means you read it well. Perhaps this more verbose reformulation will help:\\n\\nYou are given a string `s` consisting of upper case English characters, and an integer `k`. \\n\\nLet `char` be an uppercase English character, a `char`-substitution is an operation that replaces any single character in `s` by `char`.\\n\\nYou are allowed to operate on `s` by fixing a `char`  and performing at most `k` `char`-substitutions.\\n\\nReturn the length of the longest possible substring containing the same letter that is obtainable after performing an allowable operation.\\n"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If an interviewer asks for O(n), s/he is a douchebag."
                    },
                    {
                        "username": "riteshgupta0cam",
                        "content": "If you have solved Max Consecutive Ones III . this should feel easy as this Q some extra addition over that Q. TC might be compromised a little bit i.e (O(26 * N + NlogN) in worst case) but at first glance this could be the solution. "
                    },
                    {
                        "username": "aasthad27",
                        "content": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int j=-1;\\n        int maxi=INT_MIN;\\n        int len=0;\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'A\\')\\n            {\\n                c++;\\n            }\\n            while(c>k)\\n            {\\n                j++;\\n                if(s[j]==\\'A\\')\\n                {\\n                    c--;\\n                }\\n            }\\n            len=i-j;\\n            maxi=max(maxi,len);\\n        }\\n        return maxi;\\n    \\n    }\\n}; It is failing at TC : \\'AAAA\\' k=2 , output :2 , expected:4 "
                    },
                    {
                        "username": "Akshat_0308",
                        "content": "different kind of question seems complex"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Hi, I\\'m confused with this question. How for the test case\\ns= \"IMNJJTRMJEGMSOLSCCQICIHLQIOGBJAEHQOCRAJQMBIBATGLJDTBNCPIFRDLRIJHRABBJGQAOLIKRLHDRIGERENNMJSDSSMESSTR\"\\nk=2\\n\\nThe answer is 6 and not 5\\nI\\'m getting 5 by converting \"CCQIC\" at 16th index (0-indexed) to \"CCCCC\". \\n\\nThanks in advance for help."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Sorry, I got the answer. It\\'s \"SSMESS\" at index 90. I missed it."
                    },
                    {
                        "username": "anirudhata123",
                        "content": "In this question we use the sliding window technique. We take slices of the string and store the frequencies of each element in a HashMap. In that slice of string we subtract the length of the slice of the string with the most frequency repeating character. This gives us the total number of characters that can be replaced in the string. If the total number of replaceable characters is greater than the total permitted number of changes, then the substring is not valid(i.e to get maximum number of repeated characters we will have to make more than permitted number of \\nreplacements. In that case we move the left pointer ahead). On the other hand if the result of subtraction comes out to be less than the permitted number of changes(we can get repeating characters by making less than or equal to number of changes in the slice)we take the max of the length of the current slice and the global maximum after that we update the right pointer"
                    },
                    {
                        "username": "jamesinhel",
                        "content": "The reference to \"operation\" in the phrase \"You perform this operation at most k times\" is ambiguous. It is unclear if subsequent operations need to be tied to the values I had chosen for the first execution of the operation or if I am free to perform the operation without being constrained to the previously used values.\n\nFor example, if k=2 and I chose to replace A with B then, when I do the operation again, am I constrained to change another A to B or, do I get to choose another letter, say C, and change it to B?\n"
                    }
                ]
            },
            {
                "id": 1900180,
                "content": [
                    {
                        "username": "jimmywutangclan",
                        "content": "Is there any proof for tracking the most common character that it doesn\\'t have to be updated when the sliding window is moved leftwards?\\n\\nI just can\\'t bring myself to make this assumption without a proof that it works"
                    },
                    {
                        "username": "djslim",
                        "content": "it's because we update max only if it's bigger than previous max, so if we lower it by one, the curr number will be still either bigger or equal to the other characters, Technically you can also keep track of it as it's only 26 letters to iterate over"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I hate sliding window problems. "
                    },
                    {
                        "username": "kropochev",
                        "content": "Same question as:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/"
                    },
                    {
                        "username": "stultiloquator",
                        "content": "Confused by the description? Congrats, that means you read it well. Perhaps this more verbose reformulation will help:\\n\\nYou are given a string `s` consisting of upper case English characters, and an integer `k`. \\n\\nLet `char` be an uppercase English character, a `char`-substitution is an operation that replaces any single character in `s` by `char`.\\n\\nYou are allowed to operate on `s` by fixing a `char`  and performing at most `k` `char`-substitutions.\\n\\nReturn the length of the longest possible substring containing the same letter that is obtainable after performing an allowable operation.\\n"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If an interviewer asks for O(n), s/he is a douchebag."
                    },
                    {
                        "username": "riteshgupta0cam",
                        "content": "If you have solved Max Consecutive Ones III . this should feel easy as this Q some extra addition over that Q. TC might be compromised a little bit i.e (O(26 * N + NlogN) in worst case) but at first glance this could be the solution. "
                    },
                    {
                        "username": "aasthad27",
                        "content": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int j=-1;\\n        int maxi=INT_MIN;\\n        int len=0;\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'A\\')\\n            {\\n                c++;\\n            }\\n            while(c>k)\\n            {\\n                j++;\\n                if(s[j]==\\'A\\')\\n                {\\n                    c--;\\n                }\\n            }\\n            len=i-j;\\n            maxi=max(maxi,len);\\n        }\\n        return maxi;\\n    \\n    }\\n}; It is failing at TC : \\'AAAA\\' k=2 , output :2 , expected:4 "
                    },
                    {
                        "username": "Akshat_0308",
                        "content": "different kind of question seems complex"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Hi, I\\'m confused with this question. How for the test case\\ns= \"IMNJJTRMJEGMSOLSCCQICIHLQIOGBJAEHQOCRAJQMBIBATGLJDTBNCPIFRDLRIJHRABBJGQAOLIKRLHDRIGERENNMJSDSSMESSTR\"\\nk=2\\n\\nThe answer is 6 and not 5\\nI\\'m getting 5 by converting \"CCQIC\" at 16th index (0-indexed) to \"CCCCC\". \\n\\nThanks in advance for help."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Sorry, I got the answer. It\\'s \"SSMESS\" at index 90. I missed it."
                    },
                    {
                        "username": "anirudhata123",
                        "content": "In this question we use the sliding window technique. We take slices of the string and store the frequencies of each element in a HashMap. In that slice of string we subtract the length of the slice of the string with the most frequency repeating character. This gives us the total number of characters that can be replaced in the string. If the total number of replaceable characters is greater than the total permitted number of changes, then the substring is not valid(i.e to get maximum number of repeated characters we will have to make more than permitted number of \\nreplacements. In that case we move the left pointer ahead). On the other hand if the result of subtraction comes out to be less than the permitted number of changes(we can get repeating characters by making less than or equal to number of changes in the slice)we take the max of the length of the current slice and the global maximum after that we update the right pointer"
                    },
                    {
                        "username": "jamesinhel",
                        "content": "The reference to \"operation\" in the phrase \"You perform this operation at most k times\" is ambiguous. It is unclear if subsequent operations need to be tied to the values I had chosen for the first execution of the operation or if I am free to perform the operation without being constrained to the previously used values.\n\nFor example, if k=2 and I chose to replace A with B then, when I do the operation again, am I constrained to change another A to B or, do I get to choose another letter, say C, and change it to B?\n"
                    }
                ]
            },
            {
                "id": 1851938,
                "content": [
                    {
                        "username": "jimmywutangclan",
                        "content": "Is there any proof for tracking the most common character that it doesn\\'t have to be updated when the sliding window is moved leftwards?\\n\\nI just can\\'t bring myself to make this assumption without a proof that it works"
                    },
                    {
                        "username": "djslim",
                        "content": "it's because we update max only if it's bigger than previous max, so if we lower it by one, the curr number will be still either bigger or equal to the other characters, Technically you can also keep track of it as it's only 26 letters to iterate over"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I hate sliding window problems. "
                    },
                    {
                        "username": "kropochev",
                        "content": "Same question as:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/"
                    },
                    {
                        "username": "stultiloquator",
                        "content": "Confused by the description? Congrats, that means you read it well. Perhaps this more verbose reformulation will help:\\n\\nYou are given a string `s` consisting of upper case English characters, and an integer `k`. \\n\\nLet `char` be an uppercase English character, a `char`-substitution is an operation that replaces any single character in `s` by `char`.\\n\\nYou are allowed to operate on `s` by fixing a `char`  and performing at most `k` `char`-substitutions.\\n\\nReturn the length of the longest possible substring containing the same letter that is obtainable after performing an allowable operation.\\n"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If an interviewer asks for O(n), s/he is a douchebag."
                    },
                    {
                        "username": "riteshgupta0cam",
                        "content": "If you have solved Max Consecutive Ones III . this should feel easy as this Q some extra addition over that Q. TC might be compromised a little bit i.e (O(26 * N + NlogN) in worst case) but at first glance this could be the solution. "
                    },
                    {
                        "username": "aasthad27",
                        "content": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int j=-1;\\n        int maxi=INT_MIN;\\n        int len=0;\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'A\\')\\n            {\\n                c++;\\n            }\\n            while(c>k)\\n            {\\n                j++;\\n                if(s[j]==\\'A\\')\\n                {\\n                    c--;\\n                }\\n            }\\n            len=i-j;\\n            maxi=max(maxi,len);\\n        }\\n        return maxi;\\n    \\n    }\\n}; It is failing at TC : \\'AAAA\\' k=2 , output :2 , expected:4 "
                    },
                    {
                        "username": "Akshat_0308",
                        "content": "different kind of question seems complex"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Hi, I\\'m confused with this question. How for the test case\\ns= \"IMNJJTRMJEGMSOLSCCQICIHLQIOGBJAEHQOCRAJQMBIBATGLJDTBNCPIFRDLRIJHRABBJGQAOLIKRLHDRIGERENNMJSDSSMESSTR\"\\nk=2\\n\\nThe answer is 6 and not 5\\nI\\'m getting 5 by converting \"CCQIC\" at 16th index (0-indexed) to \"CCCCC\". \\n\\nThanks in advance for help."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Sorry, I got the answer. It\\'s \"SSMESS\" at index 90. I missed it."
                    },
                    {
                        "username": "anirudhata123",
                        "content": "In this question we use the sliding window technique. We take slices of the string and store the frequencies of each element in a HashMap. In that slice of string we subtract the length of the slice of the string with the most frequency repeating character. This gives us the total number of characters that can be replaced in the string. If the total number of replaceable characters is greater than the total permitted number of changes, then the substring is not valid(i.e to get maximum number of repeated characters we will have to make more than permitted number of \\nreplacements. In that case we move the left pointer ahead). On the other hand if the result of subtraction comes out to be less than the permitted number of changes(we can get repeating characters by making less than or equal to number of changes in the slice)we take the max of the length of the current slice and the global maximum after that we update the right pointer"
                    },
                    {
                        "username": "jamesinhel",
                        "content": "The reference to \"operation\" in the phrase \"You perform this operation at most k times\" is ambiguous. It is unclear if subsequent operations need to be tied to the values I had chosen for the first execution of the operation or if I am free to perform the operation without being constrained to the previously used values.\n\nFor example, if k=2 and I chose to replace A with B then, when I do the operation again, am I constrained to change another A to B or, do I get to choose another letter, say C, and change it to B?\n"
                    }
                ]
            },
            {
                "id": 1775363,
                "content": [
                    {
                        "username": "jimmywutangclan",
                        "content": "Is there any proof for tracking the most common character that it doesn\\'t have to be updated when the sliding window is moved leftwards?\\n\\nI just can\\'t bring myself to make this assumption without a proof that it works"
                    },
                    {
                        "username": "djslim",
                        "content": "it's because we update max only if it's bigger than previous max, so if we lower it by one, the curr number will be still either bigger or equal to the other characters, Technically you can also keep track of it as it's only 26 letters to iterate over"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I hate sliding window problems. "
                    },
                    {
                        "username": "kropochev",
                        "content": "Same question as:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/"
                    },
                    {
                        "username": "stultiloquator",
                        "content": "Confused by the description? Congrats, that means you read it well. Perhaps this more verbose reformulation will help:\\n\\nYou are given a string `s` consisting of upper case English characters, and an integer `k`. \\n\\nLet `char` be an uppercase English character, a `char`-substitution is an operation that replaces any single character in `s` by `char`.\\n\\nYou are allowed to operate on `s` by fixing a `char`  and performing at most `k` `char`-substitutions.\\n\\nReturn the length of the longest possible substring containing the same letter that is obtainable after performing an allowable operation.\\n"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If an interviewer asks for O(n), s/he is a douchebag."
                    },
                    {
                        "username": "riteshgupta0cam",
                        "content": "If you have solved Max Consecutive Ones III . this should feel easy as this Q some extra addition over that Q. TC might be compromised a little bit i.e (O(26 * N + NlogN) in worst case) but at first glance this could be the solution. "
                    },
                    {
                        "username": "aasthad27",
                        "content": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int j=-1;\\n        int maxi=INT_MIN;\\n        int len=0;\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'A\\')\\n            {\\n                c++;\\n            }\\n            while(c>k)\\n            {\\n                j++;\\n                if(s[j]==\\'A\\')\\n                {\\n                    c--;\\n                }\\n            }\\n            len=i-j;\\n            maxi=max(maxi,len);\\n        }\\n        return maxi;\\n    \\n    }\\n}; It is failing at TC : \\'AAAA\\' k=2 , output :2 , expected:4 "
                    },
                    {
                        "username": "Akshat_0308",
                        "content": "different kind of question seems complex"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Hi, I\\'m confused with this question. How for the test case\\ns= \"IMNJJTRMJEGMSOLSCCQICIHLQIOGBJAEHQOCRAJQMBIBATGLJDTBNCPIFRDLRIJHRABBJGQAOLIKRLHDRIGERENNMJSDSSMESSTR\"\\nk=2\\n\\nThe answer is 6 and not 5\\nI\\'m getting 5 by converting \"CCQIC\" at 16th index (0-indexed) to \"CCCCC\". \\n\\nThanks in advance for help."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Sorry, I got the answer. It\\'s \"SSMESS\" at index 90. I missed it."
                    },
                    {
                        "username": "anirudhata123",
                        "content": "In this question we use the sliding window technique. We take slices of the string and store the frequencies of each element in a HashMap. In that slice of string we subtract the length of the slice of the string with the most frequency repeating character. This gives us the total number of characters that can be replaced in the string. If the total number of replaceable characters is greater than the total permitted number of changes, then the substring is not valid(i.e to get maximum number of repeated characters we will have to make more than permitted number of \\nreplacements. In that case we move the left pointer ahead). On the other hand if the result of subtraction comes out to be less than the permitted number of changes(we can get repeating characters by making less than or equal to number of changes in the slice)we take the max of the length of the current slice and the global maximum after that we update the right pointer"
                    },
                    {
                        "username": "jamesinhel",
                        "content": "The reference to \"operation\" in the phrase \"You perform this operation at most k times\" is ambiguous. It is unclear if subsequent operations need to be tied to the values I had chosen for the first execution of the operation or if I am free to perform the operation without being constrained to the previously used values.\n\nFor example, if k=2 and I chose to replace A with B then, when I do the operation again, am I constrained to change another A to B or, do I get to choose another letter, say C, and change it to B?\n"
                    }
                ]
            },
            {
                "id": 1668133,
                "content": [
                    {
                        "username": "jimmywutangclan",
                        "content": "Is there any proof for tracking the most common character that it doesn\\'t have to be updated when the sliding window is moved leftwards?\\n\\nI just can\\'t bring myself to make this assumption without a proof that it works"
                    },
                    {
                        "username": "djslim",
                        "content": "it's because we update max only if it's bigger than previous max, so if we lower it by one, the curr number will be still either bigger or equal to the other characters, Technically you can also keep track of it as it's only 26 letters to iterate over"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I hate sliding window problems. "
                    },
                    {
                        "username": "kropochev",
                        "content": "Same question as:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/"
                    },
                    {
                        "username": "stultiloquator",
                        "content": "Confused by the description? Congrats, that means you read it well. Perhaps this more verbose reformulation will help:\\n\\nYou are given a string `s` consisting of upper case English characters, and an integer `k`. \\n\\nLet `char` be an uppercase English character, a `char`-substitution is an operation that replaces any single character in `s` by `char`.\\n\\nYou are allowed to operate on `s` by fixing a `char`  and performing at most `k` `char`-substitutions.\\n\\nReturn the length of the longest possible substring containing the same letter that is obtainable after performing an allowable operation.\\n"
                    },
                    {
                        "username": "SarKurd",
                        "content": "If an interviewer asks for O(n), s/he is a douchebag."
                    },
                    {
                        "username": "riteshgupta0cam",
                        "content": "If you have solved Max Consecutive Ones III . this should feel easy as this Q some extra addition over that Q. TC might be compromised a little bit i.e (O(26 * N + NlogN) in worst case) but at first glance this could be the solution. "
                    },
                    {
                        "username": "aasthad27",
                        "content": "class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int j=-1;\\n        int maxi=INT_MIN;\\n        int len=0;\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'A\\')\\n            {\\n                c++;\\n            }\\n            while(c>k)\\n            {\\n                j++;\\n                if(s[j]==\\'A\\')\\n                {\\n                    c--;\\n                }\\n            }\\n            len=i-j;\\n            maxi=max(maxi,len);\\n        }\\n        return maxi;\\n    \\n    }\\n}; It is failing at TC : \\'AAAA\\' k=2 , output :2 , expected:4 "
                    },
                    {
                        "username": "Akshat_0308",
                        "content": "different kind of question seems complex"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Hi, I\\'m confused with this question. How for the test case\\ns= \"IMNJJTRMJEGMSOLSCCQICIHLQIOGBJAEHQOCRAJQMBIBATGLJDTBNCPIFRDLRIJHRABBJGQAOLIKRLHDRIGERENNMJSDSSMESSTR\"\\nk=2\\n\\nThe answer is 6 and not 5\\nI\\'m getting 5 by converting \"CCQIC\" at 16th index (0-indexed) to \"CCCCC\". \\n\\nThanks in advance for help."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Sorry, I got the answer. It\\'s \"SSMESS\" at index 90. I missed it."
                    },
                    {
                        "username": "anirudhata123",
                        "content": "In this question we use the sliding window technique. We take slices of the string and store the frequencies of each element in a HashMap. In that slice of string we subtract the length of the slice of the string with the most frequency repeating character. This gives us the total number of characters that can be replaced in the string. If the total number of replaceable characters is greater than the total permitted number of changes, then the substring is not valid(i.e to get maximum number of repeated characters we will have to make more than permitted number of \\nreplacements. In that case we move the left pointer ahead). On the other hand if the result of subtraction comes out to be less than the permitted number of changes(we can get repeating characters by making less than or equal to number of changes in the slice)we take the max of the length of the current slice and the global maximum after that we update the right pointer"
                    },
                    {
                        "username": "jamesinhel",
                        "content": "The reference to \"operation\" in the phrase \"You perform this operation at most k times\" is ambiguous. It is unclear if subsequent operations need to be tied to the values I had chosen for the first execution of the operation or if I am free to perform the operation without being constrained to the previously used values.\n\nFor example, if k=2 and I chose to replace A with B then, when I do the operation again, am I constrained to change another A to B or, do I get to choose another letter, say C, and change it to B?\n"
                    }
                ]
            },
            {
                "id": 1574636,
                "content": [
                    {
                        "username": "user7982l",
                        "content": "Any suggestions on how to return the starting and ending  index positions of string instead of maximum length?\\n\\nI tried multiple approaches like updating the index positions whenever a new maximum length is found but no luck getting it right! obviously I am doing something wrong. Any suggestions on how to acheive this?"
                    },
                    {
                        "username": "Ishan_sharma_66777",
                        "content": "Maybe share your code because people don\\'t know your approach \\n"
                    },
                    {
                        "username": "SaketCodeScribe",
                        "content": "Thinking aloud:\\nIf I do top down approach from i=0, then if I know the longest repeating character replacement(LRCR) for the substring starting from i+1th position then I could get the LRCR for substring starting from i under the constraint that if ith char is same as i+1th char or if the operations done are<k otherwise the LRCR for i will be 1.\\n\\nPlease let me know whats wrong in my thought process and whether it can be solved using dp?\\n\\nThanks alot"
                    },
                    {
                        "username": "yyang5",
                        "content": "Here\\'s my java implementation :) Thanks!\\nhttps://youtu.be/3PjqO8Rl_L8"
                    },
                    {
                        "username": "Sahu_Yogesh",
                        "content": "This question should definitely be tagged hard\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "what the fuck is this question lol"
                    },
                    {
                        "username": "nilestiwari_7",
                        "content": "s =\\n\"ABBB\"\\nk =\\n2\\n\\nUse Testcase\\nOutput\\n3\\nExpected\\n4\\noutput should be 3 ? becuase if replace char with k times our string become AAAB\\nhere repeating char is A which comes 3 times why output is showing 4\\ncan anyone explain"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Brute  Force : 26 * logic of max repeating 1's.\nwhere 26 for the 26 Upper case  alphabets "
                    },
                    {
                        "username": "vishal_2806",
                        "content": "very good questions for sliding window\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The most frequent char in the sliding window can change after adjusting its size, so be sure to check for the new most frequent char and update accordingly after you change the window size."
                    },
                    {
                        "username": "daddyunluck",
                        "content": "probably similar to https://leetcode.com/problems/maximize-the-confusion-of-an-exam/"
                    }
                ]
            },
            {
                "id": 1574192,
                "content": [
                    {
                        "username": "user7982l",
                        "content": "Any suggestions on how to return the starting and ending  index positions of string instead of maximum length?\\n\\nI tried multiple approaches like updating the index positions whenever a new maximum length is found but no luck getting it right! obviously I am doing something wrong. Any suggestions on how to acheive this?"
                    },
                    {
                        "username": "Ishan_sharma_66777",
                        "content": "Maybe share your code because people don\\'t know your approach \\n"
                    },
                    {
                        "username": "SaketCodeScribe",
                        "content": "Thinking aloud:\\nIf I do top down approach from i=0, then if I know the longest repeating character replacement(LRCR) for the substring starting from i+1th position then I could get the LRCR for substring starting from i under the constraint that if ith char is same as i+1th char or if the operations done are<k otherwise the LRCR for i will be 1.\\n\\nPlease let me know whats wrong in my thought process and whether it can be solved using dp?\\n\\nThanks alot"
                    },
                    {
                        "username": "yyang5",
                        "content": "Here\\'s my java implementation :) Thanks!\\nhttps://youtu.be/3PjqO8Rl_L8"
                    },
                    {
                        "username": "Sahu_Yogesh",
                        "content": "This question should definitely be tagged hard\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "what the fuck is this question lol"
                    },
                    {
                        "username": "nilestiwari_7",
                        "content": "s =\\n\"ABBB\"\\nk =\\n2\\n\\nUse Testcase\\nOutput\\n3\\nExpected\\n4\\noutput should be 3 ? becuase if replace char with k times our string become AAAB\\nhere repeating char is A which comes 3 times why output is showing 4\\ncan anyone explain"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Brute  Force : 26 * logic of max repeating 1's.\nwhere 26 for the 26 Upper case  alphabets "
                    },
                    {
                        "username": "vishal_2806",
                        "content": "very good questions for sliding window\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The most frequent char in the sliding window can change after adjusting its size, so be sure to check for the new most frequent char and update accordingly after you change the window size."
                    },
                    {
                        "username": "daddyunluck",
                        "content": "probably similar to https://leetcode.com/problems/maximize-the-confusion-of-an-exam/"
                    }
                ]
            },
            {
                "id": 1574026,
                "content": [
                    {
                        "username": "user7982l",
                        "content": "Any suggestions on how to return the starting and ending  index positions of string instead of maximum length?\\n\\nI tried multiple approaches like updating the index positions whenever a new maximum length is found but no luck getting it right! obviously I am doing something wrong. Any suggestions on how to acheive this?"
                    },
                    {
                        "username": "Ishan_sharma_66777",
                        "content": "Maybe share your code because people don\\'t know your approach \\n"
                    },
                    {
                        "username": "SaketCodeScribe",
                        "content": "Thinking aloud:\\nIf I do top down approach from i=0, then if I know the longest repeating character replacement(LRCR) for the substring starting from i+1th position then I could get the LRCR for substring starting from i under the constraint that if ith char is same as i+1th char or if the operations done are<k otherwise the LRCR for i will be 1.\\n\\nPlease let me know whats wrong in my thought process and whether it can be solved using dp?\\n\\nThanks alot"
                    },
                    {
                        "username": "yyang5",
                        "content": "Here\\'s my java implementation :) Thanks!\\nhttps://youtu.be/3PjqO8Rl_L8"
                    },
                    {
                        "username": "Sahu_Yogesh",
                        "content": "This question should definitely be tagged hard\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "what the fuck is this question lol"
                    },
                    {
                        "username": "nilestiwari_7",
                        "content": "s =\\n\"ABBB\"\\nk =\\n2\\n\\nUse Testcase\\nOutput\\n3\\nExpected\\n4\\noutput should be 3 ? becuase if replace char with k times our string become AAAB\\nhere repeating char is A which comes 3 times why output is showing 4\\ncan anyone explain"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Brute  Force : 26 * logic of max repeating 1's.\nwhere 26 for the 26 Upper case  alphabets "
                    },
                    {
                        "username": "vishal_2806",
                        "content": "very good questions for sliding window\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The most frequent char in the sliding window can change after adjusting its size, so be sure to check for the new most frequent char and update accordingly after you change the window size."
                    },
                    {
                        "username": "daddyunluck",
                        "content": "probably similar to https://leetcode.com/problems/maximize-the-confusion-of-an-exam/"
                    }
                ]
            },
            {
                "id": 2073413,
                "content": [
                    {
                        "username": "user7982l",
                        "content": "Any suggestions on how to return the starting and ending  index positions of string instead of maximum length?\\n\\nI tried multiple approaches like updating the index positions whenever a new maximum length is found but no luck getting it right! obviously I am doing something wrong. Any suggestions on how to acheive this?"
                    },
                    {
                        "username": "Ishan_sharma_66777",
                        "content": "Maybe share your code because people don\\'t know your approach \\n"
                    },
                    {
                        "username": "SaketCodeScribe",
                        "content": "Thinking aloud:\\nIf I do top down approach from i=0, then if I know the longest repeating character replacement(LRCR) for the substring starting from i+1th position then I could get the LRCR for substring starting from i under the constraint that if ith char is same as i+1th char or if the operations done are<k otherwise the LRCR for i will be 1.\\n\\nPlease let me know whats wrong in my thought process and whether it can be solved using dp?\\n\\nThanks alot"
                    },
                    {
                        "username": "yyang5",
                        "content": "Here\\'s my java implementation :) Thanks!\\nhttps://youtu.be/3PjqO8Rl_L8"
                    },
                    {
                        "username": "Sahu_Yogesh",
                        "content": "This question should definitely be tagged hard\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "what the fuck is this question lol"
                    },
                    {
                        "username": "nilestiwari_7",
                        "content": "s =\\n\"ABBB\"\\nk =\\n2\\n\\nUse Testcase\\nOutput\\n3\\nExpected\\n4\\noutput should be 3 ? becuase if replace char with k times our string become AAAB\\nhere repeating char is A which comes 3 times why output is showing 4\\ncan anyone explain"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Brute  Force : 26 * logic of max repeating 1's.\nwhere 26 for the 26 Upper case  alphabets "
                    },
                    {
                        "username": "vishal_2806",
                        "content": "very good questions for sliding window\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The most frequent char in the sliding window can change after adjusting its size, so be sure to check for the new most frequent char and update accordingly after you change the window size."
                    },
                    {
                        "username": "daddyunluck",
                        "content": "probably similar to https://leetcode.com/problems/maximize-the-confusion-of-an-exam/"
                    }
                ]
            },
            {
                "id": 2056301,
                "content": [
                    {
                        "username": "user7982l",
                        "content": "Any suggestions on how to return the starting and ending  index positions of string instead of maximum length?\\n\\nI tried multiple approaches like updating the index positions whenever a new maximum length is found but no luck getting it right! obviously I am doing something wrong. Any suggestions on how to acheive this?"
                    },
                    {
                        "username": "Ishan_sharma_66777",
                        "content": "Maybe share your code because people don\\'t know your approach \\n"
                    },
                    {
                        "username": "SaketCodeScribe",
                        "content": "Thinking aloud:\\nIf I do top down approach from i=0, then if I know the longest repeating character replacement(LRCR) for the substring starting from i+1th position then I could get the LRCR for substring starting from i under the constraint that if ith char is same as i+1th char or if the operations done are<k otherwise the LRCR for i will be 1.\\n\\nPlease let me know whats wrong in my thought process and whether it can be solved using dp?\\n\\nThanks alot"
                    },
                    {
                        "username": "yyang5",
                        "content": "Here\\'s my java implementation :) Thanks!\\nhttps://youtu.be/3PjqO8Rl_L8"
                    },
                    {
                        "username": "Sahu_Yogesh",
                        "content": "This question should definitely be tagged hard\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "what the fuck is this question lol"
                    },
                    {
                        "username": "nilestiwari_7",
                        "content": "s =\\n\"ABBB\"\\nk =\\n2\\n\\nUse Testcase\\nOutput\\n3\\nExpected\\n4\\noutput should be 3 ? becuase if replace char with k times our string become AAAB\\nhere repeating char is A which comes 3 times why output is showing 4\\ncan anyone explain"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Brute  Force : 26 * logic of max repeating 1's.\nwhere 26 for the 26 Upper case  alphabets "
                    },
                    {
                        "username": "vishal_2806",
                        "content": "very good questions for sliding window\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The most frequent char in the sliding window can change after adjusting its size, so be sure to check for the new most frequent char and update accordingly after you change the window size."
                    },
                    {
                        "username": "daddyunluck",
                        "content": "probably similar to https://leetcode.com/problems/maximize-the-confusion-of-an-exam/"
                    }
                ]
            },
            {
                "id": 2052670,
                "content": [
                    {
                        "username": "user7982l",
                        "content": "Any suggestions on how to return the starting and ending  index positions of string instead of maximum length?\\n\\nI tried multiple approaches like updating the index positions whenever a new maximum length is found but no luck getting it right! obviously I am doing something wrong. Any suggestions on how to acheive this?"
                    },
                    {
                        "username": "Ishan_sharma_66777",
                        "content": "Maybe share your code because people don\\'t know your approach \\n"
                    },
                    {
                        "username": "SaketCodeScribe",
                        "content": "Thinking aloud:\\nIf I do top down approach from i=0, then if I know the longest repeating character replacement(LRCR) for the substring starting from i+1th position then I could get the LRCR for substring starting from i under the constraint that if ith char is same as i+1th char or if the operations done are<k otherwise the LRCR for i will be 1.\\n\\nPlease let me know whats wrong in my thought process and whether it can be solved using dp?\\n\\nThanks alot"
                    },
                    {
                        "username": "yyang5",
                        "content": "Here\\'s my java implementation :) Thanks!\\nhttps://youtu.be/3PjqO8Rl_L8"
                    },
                    {
                        "username": "Sahu_Yogesh",
                        "content": "This question should definitely be tagged hard\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "what the fuck is this question lol"
                    },
                    {
                        "username": "nilestiwari_7",
                        "content": "s =\\n\"ABBB\"\\nk =\\n2\\n\\nUse Testcase\\nOutput\\n3\\nExpected\\n4\\noutput should be 3 ? becuase if replace char with k times our string become AAAB\\nhere repeating char is A which comes 3 times why output is showing 4\\ncan anyone explain"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Brute  Force : 26 * logic of max repeating 1's.\nwhere 26 for the 26 Upper case  alphabets "
                    },
                    {
                        "username": "vishal_2806",
                        "content": "very good questions for sliding window\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The most frequent char in the sliding window can change after adjusting its size, so be sure to check for the new most frequent char and update accordingly after you change the window size."
                    },
                    {
                        "username": "daddyunluck",
                        "content": "probably similar to https://leetcode.com/problems/maximize-the-confusion-of-an-exam/"
                    }
                ]
            },
            {
                "id": 2049103,
                "content": [
                    {
                        "username": "user7982l",
                        "content": "Any suggestions on how to return the starting and ending  index positions of string instead of maximum length?\\n\\nI tried multiple approaches like updating the index positions whenever a new maximum length is found but no luck getting it right! obviously I am doing something wrong. Any suggestions on how to acheive this?"
                    },
                    {
                        "username": "Ishan_sharma_66777",
                        "content": "Maybe share your code because people don\\'t know your approach \\n"
                    },
                    {
                        "username": "SaketCodeScribe",
                        "content": "Thinking aloud:\\nIf I do top down approach from i=0, then if I know the longest repeating character replacement(LRCR) for the substring starting from i+1th position then I could get the LRCR for substring starting from i under the constraint that if ith char is same as i+1th char or if the operations done are<k otherwise the LRCR for i will be 1.\\n\\nPlease let me know whats wrong in my thought process and whether it can be solved using dp?\\n\\nThanks alot"
                    },
                    {
                        "username": "yyang5",
                        "content": "Here\\'s my java implementation :) Thanks!\\nhttps://youtu.be/3PjqO8Rl_L8"
                    },
                    {
                        "username": "Sahu_Yogesh",
                        "content": "This question should definitely be tagged hard\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "what the fuck is this question lol"
                    },
                    {
                        "username": "nilestiwari_7",
                        "content": "s =\\n\"ABBB\"\\nk =\\n2\\n\\nUse Testcase\\nOutput\\n3\\nExpected\\n4\\noutput should be 3 ? becuase if replace char with k times our string become AAAB\\nhere repeating char is A which comes 3 times why output is showing 4\\ncan anyone explain"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Brute  Force : 26 * logic of max repeating 1's.\nwhere 26 for the 26 Upper case  alphabets "
                    },
                    {
                        "username": "vishal_2806",
                        "content": "very good questions for sliding window\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The most frequent char in the sliding window can change after adjusting its size, so be sure to check for the new most frequent char and update accordingly after you change the window size."
                    },
                    {
                        "username": "daddyunluck",
                        "content": "probably similar to https://leetcode.com/problems/maximize-the-confusion-of-an-exam/"
                    }
                ]
            },
            {
                "id": 2038485,
                "content": [
                    {
                        "username": "user7982l",
                        "content": "Any suggestions on how to return the starting and ending  index positions of string instead of maximum length?\\n\\nI tried multiple approaches like updating the index positions whenever a new maximum length is found but no luck getting it right! obviously I am doing something wrong. Any suggestions on how to acheive this?"
                    },
                    {
                        "username": "Ishan_sharma_66777",
                        "content": "Maybe share your code because people don\\'t know your approach \\n"
                    },
                    {
                        "username": "SaketCodeScribe",
                        "content": "Thinking aloud:\\nIf I do top down approach from i=0, then if I know the longest repeating character replacement(LRCR) for the substring starting from i+1th position then I could get the LRCR for substring starting from i under the constraint that if ith char is same as i+1th char or if the operations done are<k otherwise the LRCR for i will be 1.\\n\\nPlease let me know whats wrong in my thought process and whether it can be solved using dp?\\n\\nThanks alot"
                    },
                    {
                        "username": "yyang5",
                        "content": "Here\\'s my java implementation :) Thanks!\\nhttps://youtu.be/3PjqO8Rl_L8"
                    },
                    {
                        "username": "Sahu_Yogesh",
                        "content": "This question should definitely be tagged hard\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "what the fuck is this question lol"
                    },
                    {
                        "username": "nilestiwari_7",
                        "content": "s =\\n\"ABBB\"\\nk =\\n2\\n\\nUse Testcase\\nOutput\\n3\\nExpected\\n4\\noutput should be 3 ? becuase if replace char with k times our string become AAAB\\nhere repeating char is A which comes 3 times why output is showing 4\\ncan anyone explain"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Brute  Force : 26 * logic of max repeating 1's.\nwhere 26 for the 26 Upper case  alphabets "
                    },
                    {
                        "username": "vishal_2806",
                        "content": "very good questions for sliding window\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The most frequent char in the sliding window can change after adjusting its size, so be sure to check for the new most frequent char and update accordingly after you change the window size."
                    },
                    {
                        "username": "daddyunluck",
                        "content": "probably similar to https://leetcode.com/problems/maximize-the-confusion-of-an-exam/"
                    }
                ]
            },
            {
                "id": 2008876,
                "content": [
                    {
                        "username": "user7982l",
                        "content": "Any suggestions on how to return the starting and ending  index positions of string instead of maximum length?\\n\\nI tried multiple approaches like updating the index positions whenever a new maximum length is found but no luck getting it right! obviously I am doing something wrong. Any suggestions on how to acheive this?"
                    },
                    {
                        "username": "Ishan_sharma_66777",
                        "content": "Maybe share your code because people don\\'t know your approach \\n"
                    },
                    {
                        "username": "SaketCodeScribe",
                        "content": "Thinking aloud:\\nIf I do top down approach from i=0, then if I know the longest repeating character replacement(LRCR) for the substring starting from i+1th position then I could get the LRCR for substring starting from i under the constraint that if ith char is same as i+1th char or if the operations done are<k otherwise the LRCR for i will be 1.\\n\\nPlease let me know whats wrong in my thought process and whether it can be solved using dp?\\n\\nThanks alot"
                    },
                    {
                        "username": "yyang5",
                        "content": "Here\\'s my java implementation :) Thanks!\\nhttps://youtu.be/3PjqO8Rl_L8"
                    },
                    {
                        "username": "Sahu_Yogesh",
                        "content": "This question should definitely be tagged hard\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "what the fuck is this question lol"
                    },
                    {
                        "username": "nilestiwari_7",
                        "content": "s =\\n\"ABBB\"\\nk =\\n2\\n\\nUse Testcase\\nOutput\\n3\\nExpected\\n4\\noutput should be 3 ? becuase if replace char with k times our string become AAAB\\nhere repeating char is A which comes 3 times why output is showing 4\\ncan anyone explain"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Brute  Force : 26 * logic of max repeating 1's.\nwhere 26 for the 26 Upper case  alphabets "
                    },
                    {
                        "username": "vishal_2806",
                        "content": "very good questions for sliding window\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The most frequent char in the sliding window can change after adjusting its size, so be sure to check for the new most frequent char and update accordingly after you change the window size."
                    },
                    {
                        "username": "daddyunluck",
                        "content": "probably similar to https://leetcode.com/problems/maximize-the-confusion-of-an-exam/"
                    }
                ]
            },
            {
                "id": 2006681,
                "content": [
                    {
                        "username": "user7982l",
                        "content": "Any suggestions on how to return the starting and ending  index positions of string instead of maximum length?\\n\\nI tried multiple approaches like updating the index positions whenever a new maximum length is found but no luck getting it right! obviously I am doing something wrong. Any suggestions on how to acheive this?"
                    },
                    {
                        "username": "Ishan_sharma_66777",
                        "content": "Maybe share your code because people don\\'t know your approach \\n"
                    },
                    {
                        "username": "SaketCodeScribe",
                        "content": "Thinking aloud:\\nIf I do top down approach from i=0, then if I know the longest repeating character replacement(LRCR) for the substring starting from i+1th position then I could get the LRCR for substring starting from i under the constraint that if ith char is same as i+1th char or if the operations done are<k otherwise the LRCR for i will be 1.\\n\\nPlease let me know whats wrong in my thought process and whether it can be solved using dp?\\n\\nThanks alot"
                    },
                    {
                        "username": "yyang5",
                        "content": "Here\\'s my java implementation :) Thanks!\\nhttps://youtu.be/3PjqO8Rl_L8"
                    },
                    {
                        "username": "Sahu_Yogesh",
                        "content": "This question should definitely be tagged hard\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "what the fuck is this question lol"
                    },
                    {
                        "username": "nilestiwari_7",
                        "content": "s =\\n\"ABBB\"\\nk =\\n2\\n\\nUse Testcase\\nOutput\\n3\\nExpected\\n4\\noutput should be 3 ? becuase if replace char with k times our string become AAAB\\nhere repeating char is A which comes 3 times why output is showing 4\\ncan anyone explain"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Brute  Force : 26 * logic of max repeating 1's.\nwhere 26 for the 26 Upper case  alphabets "
                    },
                    {
                        "username": "vishal_2806",
                        "content": "very good questions for sliding window\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The most frequent char in the sliding window can change after adjusting its size, so be sure to check for the new most frequent char and update accordingly after you change the window size."
                    },
                    {
                        "username": "daddyunluck",
                        "content": "probably similar to https://leetcode.com/problems/maximize-the-confusion-of-an-exam/"
                    }
                ]
            },
            {
                "id": 2001725,
                "content": [
                    {
                        "username": "harshyadav11590",
                        "content": "You can copy paste the same code for question [2024](2024)"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "We can use dictionary to keep track of frequencies.\\nlength of slidingwindow - max frequency = allowed operations."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell why this is failing...\\nIt is failing on only 1 tc (testcase 38) and there seems no logical mistake in this method:\\n\\nint characterReplacement(string s, int k) {\\n        int n = s.length();\\n        int alpha = 26, maxLen = 0;\\n        while(alpha--){\\n            int i = 0, j = 0, cnt = 0;\\n            while(i < n){\\n                if(s[i] != \\'A\\' + alpha -1)cnt++;\\n                while(cnt > k){\\n                    if(s[j] != \\'A\\' + alpha -1)cnt--;\\n                    j++;\\n                }\\n                maxLen = max(maxLen, i-j+1);\\n                i++;\\n            }\\n        }\\n        return maxLen;\\n    }"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Please post the test case also."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "\\n*  Would anyOne like to explain me why putting the maxCount variable for counting the maximum repeating chars working properly ,  can\\'t we write (maxRepeats.count(s[end]]) or maxRepeats[s[end]]) instead of it?       \\n\\nint characterReplacement(string s, int k) {\\n        int longestSubstr = 0;\\n        unordered_map<char, int> maxRepeats;\\n        int start = 0;\\n        int end = 0;\\n        int maxCount = 0;\\n        while(end<s.size()){\\n            maxRepeats[s[end]]++;\\n            \\n         /*  ##  */   maxCount = max(maxCount, maxRepeats[s[end]]);   \\n                       \\n            while((end-start+1)-maxCount > k){\\n                maxRepeats[s[start]]--;\\n                if(maxRepeats[s[start]] == 0){\\n                    maxRepeats.erase(s[start]); \\n                }\\n                start++;\\n            }   longestSubstr = max(longestSubstr, end-start+1);\\n            end++;\\n        } return longestSubstr; \\n    }\\n\\nWaiting for You Gentleman\\'s Reply \\n\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "this problem seems to be hard"
                    },
                    {
                        "username": "Subh001",
                        "content": "for those who are troble in understanding this line of code: max=Math.max(max,++freq[s.charAt(i)- \\'A\\']);\\nhere full explanation for s=\"AABABBA\".\\nThe variable \"i\" is initialized to 0, and the loop starts from the first character of the string \"s\".\\n\\nFor the first iteration, the character at index 0 of \"s\" is \\'A\\'. The expression \"s.charAt(i)- \\'A\\'\" will give 0, which is the index of \\'A\\' in the \"freq\" array.\\n\\nThe code then increments the value of \"freq[0]\" (i.e., the frequency of \\'A\\') by 1, using the prefix increment operator \"++freq[0]\". This means the frequency of \\'A\\' becomes 1.\\n\\nThe code then takes the maximum between \"max\" and the frequency of the current character, which is 1. Since \"max\" is initialized to 0, the maximum value will be 1, and \"max\" is updated to 1.\\n\\nThe loop then proceeds to the second iteration, where \"i\" is incremented to 1, and the character at index 1 of \"s\" is \\'A\\' again.\\n\\nThe expression \"s.charAt(i)- \\'A\\'\" will give 0 again, and the frequency of \\'A\\' in the \"freq\" array will be incremented to 2.\\n\\nThe code then takes the maximum between \"max\" (which is currently 1) and the frequency of the current character (which is 2). The maximum value is 2, so \"max\" is updated to 2.\\n\\nThe loop continues in this manner for the remaining characters of the string \"s\".\\nAt the end of this process, the value of \"max\" will be equal to the frequency of the most frequent character in the string \"s\", which is 3 in this case (since there are three \\'A\\'s in the string). "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Too hard."
                    },
                    {
                        "username": "hngbv95",
                        "content": "This one should be hard"
                    },
                    {
                        "username": "skinnyguy",
                        "content": "3D DP soln passes 23/37\\nthis was most intutive soln for me \\n\\n`class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.size();\\n        vector<vector<vector<int> > > dp;\\n        dp.resize(n);\\n        for(int i=0;i<n;i++){\\n            dp[i].resize(27);\\n            for(char j = 0; j<27;j++){\\n                dp[i][j].resize(k+1,0);\\n            }\\n        }\\n        int ans = INT_MIN;\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(char j = 0; j<27;j++){\\n                for(int l = 0;l <=k;l++){\\n                    if(i<n-1){\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = dp[i+1][j][l]+1;\\n                        else dp[i][j][l] = l != 0?dp[i+1][j][l-1]+1: 0;\\n                    }else{\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = 1;\\n                        else dp[i][j][l] = l != 0?1: 0;\\n                    }\\n                    ans = max(ans, dp[i][j][l]);\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};. `"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "does printing something for large tcs, cause TLE on leetcode ?  "
                    },
                    {
                        "username": "code__HARD",
                        "content": "NO.  But sometimes give Output Limit Error if chars are exceeded\\n "
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "https://leetcode.com/problems/longest-repeating-character-replacement/submissions/889642798/\\n ; )"
                    }
                ]
            },
            {
                "id": 1984259,
                "content": [
                    {
                        "username": "harshyadav11590",
                        "content": "You can copy paste the same code for question [2024](2024)"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "We can use dictionary to keep track of frequencies.\\nlength of slidingwindow - max frequency = allowed operations."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell why this is failing...\\nIt is failing on only 1 tc (testcase 38) and there seems no logical mistake in this method:\\n\\nint characterReplacement(string s, int k) {\\n        int n = s.length();\\n        int alpha = 26, maxLen = 0;\\n        while(alpha--){\\n            int i = 0, j = 0, cnt = 0;\\n            while(i < n){\\n                if(s[i] != \\'A\\' + alpha -1)cnt++;\\n                while(cnt > k){\\n                    if(s[j] != \\'A\\' + alpha -1)cnt--;\\n                    j++;\\n                }\\n                maxLen = max(maxLen, i-j+1);\\n                i++;\\n            }\\n        }\\n        return maxLen;\\n    }"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Please post the test case also."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "\\n*  Would anyOne like to explain me why putting the maxCount variable for counting the maximum repeating chars working properly ,  can\\'t we write (maxRepeats.count(s[end]]) or maxRepeats[s[end]]) instead of it?       \\n\\nint characterReplacement(string s, int k) {\\n        int longestSubstr = 0;\\n        unordered_map<char, int> maxRepeats;\\n        int start = 0;\\n        int end = 0;\\n        int maxCount = 0;\\n        while(end<s.size()){\\n            maxRepeats[s[end]]++;\\n            \\n         /*  ##  */   maxCount = max(maxCount, maxRepeats[s[end]]);   \\n                       \\n            while((end-start+1)-maxCount > k){\\n                maxRepeats[s[start]]--;\\n                if(maxRepeats[s[start]] == 0){\\n                    maxRepeats.erase(s[start]); \\n                }\\n                start++;\\n            }   longestSubstr = max(longestSubstr, end-start+1);\\n            end++;\\n        } return longestSubstr; \\n    }\\n\\nWaiting for You Gentleman\\'s Reply \\n\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "this problem seems to be hard"
                    },
                    {
                        "username": "Subh001",
                        "content": "for those who are troble in understanding this line of code: max=Math.max(max,++freq[s.charAt(i)- \\'A\\']);\\nhere full explanation for s=\"AABABBA\".\\nThe variable \"i\" is initialized to 0, and the loop starts from the first character of the string \"s\".\\n\\nFor the first iteration, the character at index 0 of \"s\" is \\'A\\'. The expression \"s.charAt(i)- \\'A\\'\" will give 0, which is the index of \\'A\\' in the \"freq\" array.\\n\\nThe code then increments the value of \"freq[0]\" (i.e., the frequency of \\'A\\') by 1, using the prefix increment operator \"++freq[0]\". This means the frequency of \\'A\\' becomes 1.\\n\\nThe code then takes the maximum between \"max\" and the frequency of the current character, which is 1. Since \"max\" is initialized to 0, the maximum value will be 1, and \"max\" is updated to 1.\\n\\nThe loop then proceeds to the second iteration, where \"i\" is incremented to 1, and the character at index 1 of \"s\" is \\'A\\' again.\\n\\nThe expression \"s.charAt(i)- \\'A\\'\" will give 0 again, and the frequency of \\'A\\' in the \"freq\" array will be incremented to 2.\\n\\nThe code then takes the maximum between \"max\" (which is currently 1) and the frequency of the current character (which is 2). The maximum value is 2, so \"max\" is updated to 2.\\n\\nThe loop continues in this manner for the remaining characters of the string \"s\".\\nAt the end of this process, the value of \"max\" will be equal to the frequency of the most frequent character in the string \"s\", which is 3 in this case (since there are three \\'A\\'s in the string). "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Too hard."
                    },
                    {
                        "username": "hngbv95",
                        "content": "This one should be hard"
                    },
                    {
                        "username": "skinnyguy",
                        "content": "3D DP soln passes 23/37\\nthis was most intutive soln for me \\n\\n`class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.size();\\n        vector<vector<vector<int> > > dp;\\n        dp.resize(n);\\n        for(int i=0;i<n;i++){\\n            dp[i].resize(27);\\n            for(char j = 0; j<27;j++){\\n                dp[i][j].resize(k+1,0);\\n            }\\n        }\\n        int ans = INT_MIN;\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(char j = 0; j<27;j++){\\n                for(int l = 0;l <=k;l++){\\n                    if(i<n-1){\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = dp[i+1][j][l]+1;\\n                        else dp[i][j][l] = l != 0?dp[i+1][j][l-1]+1: 0;\\n                    }else{\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = 1;\\n                        else dp[i][j][l] = l != 0?1: 0;\\n                    }\\n                    ans = max(ans, dp[i][j][l]);\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};. `"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "does printing something for large tcs, cause TLE on leetcode ?  "
                    },
                    {
                        "username": "code__HARD",
                        "content": "NO.  But sometimes give Output Limit Error if chars are exceeded\\n "
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "https://leetcode.com/problems/longest-repeating-character-replacement/submissions/889642798/\\n ; )"
                    }
                ]
            },
            {
                "id": 1951485,
                "content": [
                    {
                        "username": "harshyadav11590",
                        "content": "You can copy paste the same code for question [2024](2024)"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "We can use dictionary to keep track of frequencies.\\nlength of slidingwindow - max frequency = allowed operations."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell why this is failing...\\nIt is failing on only 1 tc (testcase 38) and there seems no logical mistake in this method:\\n\\nint characterReplacement(string s, int k) {\\n        int n = s.length();\\n        int alpha = 26, maxLen = 0;\\n        while(alpha--){\\n            int i = 0, j = 0, cnt = 0;\\n            while(i < n){\\n                if(s[i] != \\'A\\' + alpha -1)cnt++;\\n                while(cnt > k){\\n                    if(s[j] != \\'A\\' + alpha -1)cnt--;\\n                    j++;\\n                }\\n                maxLen = max(maxLen, i-j+1);\\n                i++;\\n            }\\n        }\\n        return maxLen;\\n    }"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Please post the test case also."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "\\n*  Would anyOne like to explain me why putting the maxCount variable for counting the maximum repeating chars working properly ,  can\\'t we write (maxRepeats.count(s[end]]) or maxRepeats[s[end]]) instead of it?       \\n\\nint characterReplacement(string s, int k) {\\n        int longestSubstr = 0;\\n        unordered_map<char, int> maxRepeats;\\n        int start = 0;\\n        int end = 0;\\n        int maxCount = 0;\\n        while(end<s.size()){\\n            maxRepeats[s[end]]++;\\n            \\n         /*  ##  */   maxCount = max(maxCount, maxRepeats[s[end]]);   \\n                       \\n            while((end-start+1)-maxCount > k){\\n                maxRepeats[s[start]]--;\\n                if(maxRepeats[s[start]] == 0){\\n                    maxRepeats.erase(s[start]); \\n                }\\n                start++;\\n            }   longestSubstr = max(longestSubstr, end-start+1);\\n            end++;\\n        } return longestSubstr; \\n    }\\n\\nWaiting for You Gentleman\\'s Reply \\n\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "this problem seems to be hard"
                    },
                    {
                        "username": "Subh001",
                        "content": "for those who are troble in understanding this line of code: max=Math.max(max,++freq[s.charAt(i)- \\'A\\']);\\nhere full explanation for s=\"AABABBA\".\\nThe variable \"i\" is initialized to 0, and the loop starts from the first character of the string \"s\".\\n\\nFor the first iteration, the character at index 0 of \"s\" is \\'A\\'. The expression \"s.charAt(i)- \\'A\\'\" will give 0, which is the index of \\'A\\' in the \"freq\" array.\\n\\nThe code then increments the value of \"freq[0]\" (i.e., the frequency of \\'A\\') by 1, using the prefix increment operator \"++freq[0]\". This means the frequency of \\'A\\' becomes 1.\\n\\nThe code then takes the maximum between \"max\" and the frequency of the current character, which is 1. Since \"max\" is initialized to 0, the maximum value will be 1, and \"max\" is updated to 1.\\n\\nThe loop then proceeds to the second iteration, where \"i\" is incremented to 1, and the character at index 1 of \"s\" is \\'A\\' again.\\n\\nThe expression \"s.charAt(i)- \\'A\\'\" will give 0 again, and the frequency of \\'A\\' in the \"freq\" array will be incremented to 2.\\n\\nThe code then takes the maximum between \"max\" (which is currently 1) and the frequency of the current character (which is 2). The maximum value is 2, so \"max\" is updated to 2.\\n\\nThe loop continues in this manner for the remaining characters of the string \"s\".\\nAt the end of this process, the value of \"max\" will be equal to the frequency of the most frequent character in the string \"s\", which is 3 in this case (since there are three \\'A\\'s in the string). "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Too hard."
                    },
                    {
                        "username": "hngbv95",
                        "content": "This one should be hard"
                    },
                    {
                        "username": "skinnyguy",
                        "content": "3D DP soln passes 23/37\\nthis was most intutive soln for me \\n\\n`class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.size();\\n        vector<vector<vector<int> > > dp;\\n        dp.resize(n);\\n        for(int i=0;i<n;i++){\\n            dp[i].resize(27);\\n            for(char j = 0; j<27;j++){\\n                dp[i][j].resize(k+1,0);\\n            }\\n        }\\n        int ans = INT_MIN;\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(char j = 0; j<27;j++){\\n                for(int l = 0;l <=k;l++){\\n                    if(i<n-1){\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = dp[i+1][j][l]+1;\\n                        else dp[i][j][l] = l != 0?dp[i+1][j][l-1]+1: 0;\\n                    }else{\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = 1;\\n                        else dp[i][j][l] = l != 0?1: 0;\\n                    }\\n                    ans = max(ans, dp[i][j][l]);\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};. `"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "does printing something for large tcs, cause TLE on leetcode ?  "
                    },
                    {
                        "username": "code__HARD",
                        "content": "NO.  But sometimes give Output Limit Error if chars are exceeded\\n "
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "https://leetcode.com/problems/longest-repeating-character-replacement/submissions/889642798/\\n ; )"
                    }
                ]
            },
            {
                "id": 1918648,
                "content": [
                    {
                        "username": "harshyadav11590",
                        "content": "You can copy paste the same code for question [2024](2024)"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "We can use dictionary to keep track of frequencies.\\nlength of slidingwindow - max frequency = allowed operations."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell why this is failing...\\nIt is failing on only 1 tc (testcase 38) and there seems no logical mistake in this method:\\n\\nint characterReplacement(string s, int k) {\\n        int n = s.length();\\n        int alpha = 26, maxLen = 0;\\n        while(alpha--){\\n            int i = 0, j = 0, cnt = 0;\\n            while(i < n){\\n                if(s[i] != \\'A\\' + alpha -1)cnt++;\\n                while(cnt > k){\\n                    if(s[j] != \\'A\\' + alpha -1)cnt--;\\n                    j++;\\n                }\\n                maxLen = max(maxLen, i-j+1);\\n                i++;\\n            }\\n        }\\n        return maxLen;\\n    }"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Please post the test case also."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "\\n*  Would anyOne like to explain me why putting the maxCount variable for counting the maximum repeating chars working properly ,  can\\'t we write (maxRepeats.count(s[end]]) or maxRepeats[s[end]]) instead of it?       \\n\\nint characterReplacement(string s, int k) {\\n        int longestSubstr = 0;\\n        unordered_map<char, int> maxRepeats;\\n        int start = 0;\\n        int end = 0;\\n        int maxCount = 0;\\n        while(end<s.size()){\\n            maxRepeats[s[end]]++;\\n            \\n         /*  ##  */   maxCount = max(maxCount, maxRepeats[s[end]]);   \\n                       \\n            while((end-start+1)-maxCount > k){\\n                maxRepeats[s[start]]--;\\n                if(maxRepeats[s[start]] == 0){\\n                    maxRepeats.erase(s[start]); \\n                }\\n                start++;\\n            }   longestSubstr = max(longestSubstr, end-start+1);\\n            end++;\\n        } return longestSubstr; \\n    }\\n\\nWaiting for You Gentleman\\'s Reply \\n\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "this problem seems to be hard"
                    },
                    {
                        "username": "Subh001",
                        "content": "for those who are troble in understanding this line of code: max=Math.max(max,++freq[s.charAt(i)- \\'A\\']);\\nhere full explanation for s=\"AABABBA\".\\nThe variable \"i\" is initialized to 0, and the loop starts from the first character of the string \"s\".\\n\\nFor the first iteration, the character at index 0 of \"s\" is \\'A\\'. The expression \"s.charAt(i)- \\'A\\'\" will give 0, which is the index of \\'A\\' in the \"freq\" array.\\n\\nThe code then increments the value of \"freq[0]\" (i.e., the frequency of \\'A\\') by 1, using the prefix increment operator \"++freq[0]\". This means the frequency of \\'A\\' becomes 1.\\n\\nThe code then takes the maximum between \"max\" and the frequency of the current character, which is 1. Since \"max\" is initialized to 0, the maximum value will be 1, and \"max\" is updated to 1.\\n\\nThe loop then proceeds to the second iteration, where \"i\" is incremented to 1, and the character at index 1 of \"s\" is \\'A\\' again.\\n\\nThe expression \"s.charAt(i)- \\'A\\'\" will give 0 again, and the frequency of \\'A\\' in the \"freq\" array will be incremented to 2.\\n\\nThe code then takes the maximum between \"max\" (which is currently 1) and the frequency of the current character (which is 2). The maximum value is 2, so \"max\" is updated to 2.\\n\\nThe loop continues in this manner for the remaining characters of the string \"s\".\\nAt the end of this process, the value of \"max\" will be equal to the frequency of the most frequent character in the string \"s\", which is 3 in this case (since there are three \\'A\\'s in the string). "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Too hard."
                    },
                    {
                        "username": "hngbv95",
                        "content": "This one should be hard"
                    },
                    {
                        "username": "skinnyguy",
                        "content": "3D DP soln passes 23/37\\nthis was most intutive soln for me \\n\\n`class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.size();\\n        vector<vector<vector<int> > > dp;\\n        dp.resize(n);\\n        for(int i=0;i<n;i++){\\n            dp[i].resize(27);\\n            for(char j = 0; j<27;j++){\\n                dp[i][j].resize(k+1,0);\\n            }\\n        }\\n        int ans = INT_MIN;\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(char j = 0; j<27;j++){\\n                for(int l = 0;l <=k;l++){\\n                    if(i<n-1){\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = dp[i+1][j][l]+1;\\n                        else dp[i][j][l] = l != 0?dp[i+1][j][l-1]+1: 0;\\n                    }else{\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = 1;\\n                        else dp[i][j][l] = l != 0?1: 0;\\n                    }\\n                    ans = max(ans, dp[i][j][l]);\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};. `"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "does printing something for large tcs, cause TLE on leetcode ?  "
                    },
                    {
                        "username": "code__HARD",
                        "content": "NO.  But sometimes give Output Limit Error if chars are exceeded\\n "
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "https://leetcode.com/problems/longest-repeating-character-replacement/submissions/889642798/\\n ; )"
                    }
                ]
            },
            {
                "id": 1905418,
                "content": [
                    {
                        "username": "harshyadav11590",
                        "content": "You can copy paste the same code for question [2024](2024)"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "We can use dictionary to keep track of frequencies.\\nlength of slidingwindow - max frequency = allowed operations."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell why this is failing...\\nIt is failing on only 1 tc (testcase 38) and there seems no logical mistake in this method:\\n\\nint characterReplacement(string s, int k) {\\n        int n = s.length();\\n        int alpha = 26, maxLen = 0;\\n        while(alpha--){\\n            int i = 0, j = 0, cnt = 0;\\n            while(i < n){\\n                if(s[i] != \\'A\\' + alpha -1)cnt++;\\n                while(cnt > k){\\n                    if(s[j] != \\'A\\' + alpha -1)cnt--;\\n                    j++;\\n                }\\n                maxLen = max(maxLen, i-j+1);\\n                i++;\\n            }\\n        }\\n        return maxLen;\\n    }"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Please post the test case also."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "\\n*  Would anyOne like to explain me why putting the maxCount variable for counting the maximum repeating chars working properly ,  can\\'t we write (maxRepeats.count(s[end]]) or maxRepeats[s[end]]) instead of it?       \\n\\nint characterReplacement(string s, int k) {\\n        int longestSubstr = 0;\\n        unordered_map<char, int> maxRepeats;\\n        int start = 0;\\n        int end = 0;\\n        int maxCount = 0;\\n        while(end<s.size()){\\n            maxRepeats[s[end]]++;\\n            \\n         /*  ##  */   maxCount = max(maxCount, maxRepeats[s[end]]);   \\n                       \\n            while((end-start+1)-maxCount > k){\\n                maxRepeats[s[start]]--;\\n                if(maxRepeats[s[start]] == 0){\\n                    maxRepeats.erase(s[start]); \\n                }\\n                start++;\\n            }   longestSubstr = max(longestSubstr, end-start+1);\\n            end++;\\n        } return longestSubstr; \\n    }\\n\\nWaiting for You Gentleman\\'s Reply \\n\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "this problem seems to be hard"
                    },
                    {
                        "username": "Subh001",
                        "content": "for those who are troble in understanding this line of code: max=Math.max(max,++freq[s.charAt(i)- \\'A\\']);\\nhere full explanation for s=\"AABABBA\".\\nThe variable \"i\" is initialized to 0, and the loop starts from the first character of the string \"s\".\\n\\nFor the first iteration, the character at index 0 of \"s\" is \\'A\\'. The expression \"s.charAt(i)- \\'A\\'\" will give 0, which is the index of \\'A\\' in the \"freq\" array.\\n\\nThe code then increments the value of \"freq[0]\" (i.e., the frequency of \\'A\\') by 1, using the prefix increment operator \"++freq[0]\". This means the frequency of \\'A\\' becomes 1.\\n\\nThe code then takes the maximum between \"max\" and the frequency of the current character, which is 1. Since \"max\" is initialized to 0, the maximum value will be 1, and \"max\" is updated to 1.\\n\\nThe loop then proceeds to the second iteration, where \"i\" is incremented to 1, and the character at index 1 of \"s\" is \\'A\\' again.\\n\\nThe expression \"s.charAt(i)- \\'A\\'\" will give 0 again, and the frequency of \\'A\\' in the \"freq\" array will be incremented to 2.\\n\\nThe code then takes the maximum between \"max\" (which is currently 1) and the frequency of the current character (which is 2). The maximum value is 2, so \"max\" is updated to 2.\\n\\nThe loop continues in this manner for the remaining characters of the string \"s\".\\nAt the end of this process, the value of \"max\" will be equal to the frequency of the most frequent character in the string \"s\", which is 3 in this case (since there are three \\'A\\'s in the string). "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Too hard."
                    },
                    {
                        "username": "hngbv95",
                        "content": "This one should be hard"
                    },
                    {
                        "username": "skinnyguy",
                        "content": "3D DP soln passes 23/37\\nthis was most intutive soln for me \\n\\n`class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.size();\\n        vector<vector<vector<int> > > dp;\\n        dp.resize(n);\\n        for(int i=0;i<n;i++){\\n            dp[i].resize(27);\\n            for(char j = 0; j<27;j++){\\n                dp[i][j].resize(k+1,0);\\n            }\\n        }\\n        int ans = INT_MIN;\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(char j = 0; j<27;j++){\\n                for(int l = 0;l <=k;l++){\\n                    if(i<n-1){\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = dp[i+1][j][l]+1;\\n                        else dp[i][j][l] = l != 0?dp[i+1][j][l-1]+1: 0;\\n                    }else{\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = 1;\\n                        else dp[i][j][l] = l != 0?1: 0;\\n                    }\\n                    ans = max(ans, dp[i][j][l]);\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};. `"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "does printing something for large tcs, cause TLE on leetcode ?  "
                    },
                    {
                        "username": "code__HARD",
                        "content": "NO.  But sometimes give Output Limit Error if chars are exceeded\\n "
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "https://leetcode.com/problems/longest-repeating-character-replacement/submissions/889642798/\\n ; )"
                    }
                ]
            },
            {
                "id": 1850061,
                "content": [
                    {
                        "username": "harshyadav11590",
                        "content": "You can copy paste the same code for question [2024](2024)"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "We can use dictionary to keep track of frequencies.\\nlength of slidingwindow - max frequency = allowed operations."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell why this is failing...\\nIt is failing on only 1 tc (testcase 38) and there seems no logical mistake in this method:\\n\\nint characterReplacement(string s, int k) {\\n        int n = s.length();\\n        int alpha = 26, maxLen = 0;\\n        while(alpha--){\\n            int i = 0, j = 0, cnt = 0;\\n            while(i < n){\\n                if(s[i] != \\'A\\' + alpha -1)cnt++;\\n                while(cnt > k){\\n                    if(s[j] != \\'A\\' + alpha -1)cnt--;\\n                    j++;\\n                }\\n                maxLen = max(maxLen, i-j+1);\\n                i++;\\n            }\\n        }\\n        return maxLen;\\n    }"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Please post the test case also."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "\\n*  Would anyOne like to explain me why putting the maxCount variable for counting the maximum repeating chars working properly ,  can\\'t we write (maxRepeats.count(s[end]]) or maxRepeats[s[end]]) instead of it?       \\n\\nint characterReplacement(string s, int k) {\\n        int longestSubstr = 0;\\n        unordered_map<char, int> maxRepeats;\\n        int start = 0;\\n        int end = 0;\\n        int maxCount = 0;\\n        while(end<s.size()){\\n            maxRepeats[s[end]]++;\\n            \\n         /*  ##  */   maxCount = max(maxCount, maxRepeats[s[end]]);   \\n                       \\n            while((end-start+1)-maxCount > k){\\n                maxRepeats[s[start]]--;\\n                if(maxRepeats[s[start]] == 0){\\n                    maxRepeats.erase(s[start]); \\n                }\\n                start++;\\n            }   longestSubstr = max(longestSubstr, end-start+1);\\n            end++;\\n        } return longestSubstr; \\n    }\\n\\nWaiting for You Gentleman\\'s Reply \\n\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "this problem seems to be hard"
                    },
                    {
                        "username": "Subh001",
                        "content": "for those who are troble in understanding this line of code: max=Math.max(max,++freq[s.charAt(i)- \\'A\\']);\\nhere full explanation for s=\"AABABBA\".\\nThe variable \"i\" is initialized to 0, and the loop starts from the first character of the string \"s\".\\n\\nFor the first iteration, the character at index 0 of \"s\" is \\'A\\'. The expression \"s.charAt(i)- \\'A\\'\" will give 0, which is the index of \\'A\\' in the \"freq\" array.\\n\\nThe code then increments the value of \"freq[0]\" (i.e., the frequency of \\'A\\') by 1, using the prefix increment operator \"++freq[0]\". This means the frequency of \\'A\\' becomes 1.\\n\\nThe code then takes the maximum between \"max\" and the frequency of the current character, which is 1. Since \"max\" is initialized to 0, the maximum value will be 1, and \"max\" is updated to 1.\\n\\nThe loop then proceeds to the second iteration, where \"i\" is incremented to 1, and the character at index 1 of \"s\" is \\'A\\' again.\\n\\nThe expression \"s.charAt(i)- \\'A\\'\" will give 0 again, and the frequency of \\'A\\' in the \"freq\" array will be incremented to 2.\\n\\nThe code then takes the maximum between \"max\" (which is currently 1) and the frequency of the current character (which is 2). The maximum value is 2, so \"max\" is updated to 2.\\n\\nThe loop continues in this manner for the remaining characters of the string \"s\".\\nAt the end of this process, the value of \"max\" will be equal to the frequency of the most frequent character in the string \"s\", which is 3 in this case (since there are three \\'A\\'s in the string). "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Too hard."
                    },
                    {
                        "username": "hngbv95",
                        "content": "This one should be hard"
                    },
                    {
                        "username": "skinnyguy",
                        "content": "3D DP soln passes 23/37\\nthis was most intutive soln for me \\n\\n`class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.size();\\n        vector<vector<vector<int> > > dp;\\n        dp.resize(n);\\n        for(int i=0;i<n;i++){\\n            dp[i].resize(27);\\n            for(char j = 0; j<27;j++){\\n                dp[i][j].resize(k+1,0);\\n            }\\n        }\\n        int ans = INT_MIN;\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(char j = 0; j<27;j++){\\n                for(int l = 0;l <=k;l++){\\n                    if(i<n-1){\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = dp[i+1][j][l]+1;\\n                        else dp[i][j][l] = l != 0?dp[i+1][j][l-1]+1: 0;\\n                    }else{\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = 1;\\n                        else dp[i][j][l] = l != 0?1: 0;\\n                    }\\n                    ans = max(ans, dp[i][j][l]);\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};. `"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "does printing something for large tcs, cause TLE on leetcode ?  "
                    },
                    {
                        "username": "code__HARD",
                        "content": "NO.  But sometimes give Output Limit Error if chars are exceeded\\n "
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "https://leetcode.com/problems/longest-repeating-character-replacement/submissions/889642798/\\n ; )"
                    }
                ]
            },
            {
                "id": 1839994,
                "content": [
                    {
                        "username": "harshyadav11590",
                        "content": "You can copy paste the same code for question [2024](2024)"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "We can use dictionary to keep track of frequencies.\\nlength of slidingwindow - max frequency = allowed operations."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell why this is failing...\\nIt is failing on only 1 tc (testcase 38) and there seems no logical mistake in this method:\\n\\nint characterReplacement(string s, int k) {\\n        int n = s.length();\\n        int alpha = 26, maxLen = 0;\\n        while(alpha--){\\n            int i = 0, j = 0, cnt = 0;\\n            while(i < n){\\n                if(s[i] != \\'A\\' + alpha -1)cnt++;\\n                while(cnt > k){\\n                    if(s[j] != \\'A\\' + alpha -1)cnt--;\\n                    j++;\\n                }\\n                maxLen = max(maxLen, i-j+1);\\n                i++;\\n            }\\n        }\\n        return maxLen;\\n    }"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Please post the test case also."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "\\n*  Would anyOne like to explain me why putting the maxCount variable for counting the maximum repeating chars working properly ,  can\\'t we write (maxRepeats.count(s[end]]) or maxRepeats[s[end]]) instead of it?       \\n\\nint characterReplacement(string s, int k) {\\n        int longestSubstr = 0;\\n        unordered_map<char, int> maxRepeats;\\n        int start = 0;\\n        int end = 0;\\n        int maxCount = 0;\\n        while(end<s.size()){\\n            maxRepeats[s[end]]++;\\n            \\n         /*  ##  */   maxCount = max(maxCount, maxRepeats[s[end]]);   \\n                       \\n            while((end-start+1)-maxCount > k){\\n                maxRepeats[s[start]]--;\\n                if(maxRepeats[s[start]] == 0){\\n                    maxRepeats.erase(s[start]); \\n                }\\n                start++;\\n            }   longestSubstr = max(longestSubstr, end-start+1);\\n            end++;\\n        } return longestSubstr; \\n    }\\n\\nWaiting for You Gentleman\\'s Reply \\n\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "this problem seems to be hard"
                    },
                    {
                        "username": "Subh001",
                        "content": "for those who are troble in understanding this line of code: max=Math.max(max,++freq[s.charAt(i)- \\'A\\']);\\nhere full explanation for s=\"AABABBA\".\\nThe variable \"i\" is initialized to 0, and the loop starts from the first character of the string \"s\".\\n\\nFor the first iteration, the character at index 0 of \"s\" is \\'A\\'. The expression \"s.charAt(i)- \\'A\\'\" will give 0, which is the index of \\'A\\' in the \"freq\" array.\\n\\nThe code then increments the value of \"freq[0]\" (i.e., the frequency of \\'A\\') by 1, using the prefix increment operator \"++freq[0]\". This means the frequency of \\'A\\' becomes 1.\\n\\nThe code then takes the maximum between \"max\" and the frequency of the current character, which is 1. Since \"max\" is initialized to 0, the maximum value will be 1, and \"max\" is updated to 1.\\n\\nThe loop then proceeds to the second iteration, where \"i\" is incremented to 1, and the character at index 1 of \"s\" is \\'A\\' again.\\n\\nThe expression \"s.charAt(i)- \\'A\\'\" will give 0 again, and the frequency of \\'A\\' in the \"freq\" array will be incremented to 2.\\n\\nThe code then takes the maximum between \"max\" (which is currently 1) and the frequency of the current character (which is 2). The maximum value is 2, so \"max\" is updated to 2.\\n\\nThe loop continues in this manner for the remaining characters of the string \"s\".\\nAt the end of this process, the value of \"max\" will be equal to the frequency of the most frequent character in the string \"s\", which is 3 in this case (since there are three \\'A\\'s in the string). "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Too hard."
                    },
                    {
                        "username": "hngbv95",
                        "content": "This one should be hard"
                    },
                    {
                        "username": "skinnyguy",
                        "content": "3D DP soln passes 23/37\\nthis was most intutive soln for me \\n\\n`class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.size();\\n        vector<vector<vector<int> > > dp;\\n        dp.resize(n);\\n        for(int i=0;i<n;i++){\\n            dp[i].resize(27);\\n            for(char j = 0; j<27;j++){\\n                dp[i][j].resize(k+1,0);\\n            }\\n        }\\n        int ans = INT_MIN;\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(char j = 0; j<27;j++){\\n                for(int l = 0;l <=k;l++){\\n                    if(i<n-1){\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = dp[i+1][j][l]+1;\\n                        else dp[i][j][l] = l != 0?dp[i+1][j][l-1]+1: 0;\\n                    }else{\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = 1;\\n                        else dp[i][j][l] = l != 0?1: 0;\\n                    }\\n                    ans = max(ans, dp[i][j][l]);\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};. `"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "does printing something for large tcs, cause TLE on leetcode ?  "
                    },
                    {
                        "username": "code__HARD",
                        "content": "NO.  But sometimes give Output Limit Error if chars are exceeded\\n "
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "https://leetcode.com/problems/longest-repeating-character-replacement/submissions/889642798/\\n ; )"
                    }
                ]
            },
            {
                "id": 1832955,
                "content": [
                    {
                        "username": "harshyadav11590",
                        "content": "You can copy paste the same code for question [2024](2024)"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "We can use dictionary to keep track of frequencies.\\nlength of slidingwindow - max frequency = allowed operations."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell why this is failing...\\nIt is failing on only 1 tc (testcase 38) and there seems no logical mistake in this method:\\n\\nint characterReplacement(string s, int k) {\\n        int n = s.length();\\n        int alpha = 26, maxLen = 0;\\n        while(alpha--){\\n            int i = 0, j = 0, cnt = 0;\\n            while(i < n){\\n                if(s[i] != \\'A\\' + alpha -1)cnt++;\\n                while(cnt > k){\\n                    if(s[j] != \\'A\\' + alpha -1)cnt--;\\n                    j++;\\n                }\\n                maxLen = max(maxLen, i-j+1);\\n                i++;\\n            }\\n        }\\n        return maxLen;\\n    }"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Please post the test case also."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "\\n*  Would anyOne like to explain me why putting the maxCount variable for counting the maximum repeating chars working properly ,  can\\'t we write (maxRepeats.count(s[end]]) or maxRepeats[s[end]]) instead of it?       \\n\\nint characterReplacement(string s, int k) {\\n        int longestSubstr = 0;\\n        unordered_map<char, int> maxRepeats;\\n        int start = 0;\\n        int end = 0;\\n        int maxCount = 0;\\n        while(end<s.size()){\\n            maxRepeats[s[end]]++;\\n            \\n         /*  ##  */   maxCount = max(maxCount, maxRepeats[s[end]]);   \\n                       \\n            while((end-start+1)-maxCount > k){\\n                maxRepeats[s[start]]--;\\n                if(maxRepeats[s[start]] == 0){\\n                    maxRepeats.erase(s[start]); \\n                }\\n                start++;\\n            }   longestSubstr = max(longestSubstr, end-start+1);\\n            end++;\\n        } return longestSubstr; \\n    }\\n\\nWaiting for You Gentleman\\'s Reply \\n\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "this problem seems to be hard"
                    },
                    {
                        "username": "Subh001",
                        "content": "for those who are troble in understanding this line of code: max=Math.max(max,++freq[s.charAt(i)- \\'A\\']);\\nhere full explanation for s=\"AABABBA\".\\nThe variable \"i\" is initialized to 0, and the loop starts from the first character of the string \"s\".\\n\\nFor the first iteration, the character at index 0 of \"s\" is \\'A\\'. The expression \"s.charAt(i)- \\'A\\'\" will give 0, which is the index of \\'A\\' in the \"freq\" array.\\n\\nThe code then increments the value of \"freq[0]\" (i.e., the frequency of \\'A\\') by 1, using the prefix increment operator \"++freq[0]\". This means the frequency of \\'A\\' becomes 1.\\n\\nThe code then takes the maximum between \"max\" and the frequency of the current character, which is 1. Since \"max\" is initialized to 0, the maximum value will be 1, and \"max\" is updated to 1.\\n\\nThe loop then proceeds to the second iteration, where \"i\" is incremented to 1, and the character at index 1 of \"s\" is \\'A\\' again.\\n\\nThe expression \"s.charAt(i)- \\'A\\'\" will give 0 again, and the frequency of \\'A\\' in the \"freq\" array will be incremented to 2.\\n\\nThe code then takes the maximum between \"max\" (which is currently 1) and the frequency of the current character (which is 2). The maximum value is 2, so \"max\" is updated to 2.\\n\\nThe loop continues in this manner for the remaining characters of the string \"s\".\\nAt the end of this process, the value of \"max\" will be equal to the frequency of the most frequent character in the string \"s\", which is 3 in this case (since there are three \\'A\\'s in the string). "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Too hard."
                    },
                    {
                        "username": "hngbv95",
                        "content": "This one should be hard"
                    },
                    {
                        "username": "skinnyguy",
                        "content": "3D DP soln passes 23/37\\nthis was most intutive soln for me \\n\\n`class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.size();\\n        vector<vector<vector<int> > > dp;\\n        dp.resize(n);\\n        for(int i=0;i<n;i++){\\n            dp[i].resize(27);\\n            for(char j = 0; j<27;j++){\\n                dp[i][j].resize(k+1,0);\\n            }\\n        }\\n        int ans = INT_MIN;\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(char j = 0; j<27;j++){\\n                for(int l = 0;l <=k;l++){\\n                    if(i<n-1){\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = dp[i+1][j][l]+1;\\n                        else dp[i][j][l] = l != 0?dp[i+1][j][l-1]+1: 0;\\n                    }else{\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = 1;\\n                        else dp[i][j][l] = l != 0?1: 0;\\n                    }\\n                    ans = max(ans, dp[i][j][l]);\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};. `"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "does printing something for large tcs, cause TLE on leetcode ?  "
                    },
                    {
                        "username": "code__HARD",
                        "content": "NO.  But sometimes give Output Limit Error if chars are exceeded\\n "
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "https://leetcode.com/problems/longest-repeating-character-replacement/submissions/889642798/\\n ; )"
                    }
                ]
            },
            {
                "id": 1789108,
                "content": [
                    {
                        "username": "harshyadav11590",
                        "content": "You can copy paste the same code for question [2024](2024)"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "We can use dictionary to keep track of frequencies.\\nlength of slidingwindow - max frequency = allowed operations."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell why this is failing...\\nIt is failing on only 1 tc (testcase 38) and there seems no logical mistake in this method:\\n\\nint characterReplacement(string s, int k) {\\n        int n = s.length();\\n        int alpha = 26, maxLen = 0;\\n        while(alpha--){\\n            int i = 0, j = 0, cnt = 0;\\n            while(i < n){\\n                if(s[i] != \\'A\\' + alpha -1)cnt++;\\n                while(cnt > k){\\n                    if(s[j] != \\'A\\' + alpha -1)cnt--;\\n                    j++;\\n                }\\n                maxLen = max(maxLen, i-j+1);\\n                i++;\\n            }\\n        }\\n        return maxLen;\\n    }"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Please post the test case also."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "\\n*  Would anyOne like to explain me why putting the maxCount variable for counting the maximum repeating chars working properly ,  can\\'t we write (maxRepeats.count(s[end]]) or maxRepeats[s[end]]) instead of it?       \\n\\nint characterReplacement(string s, int k) {\\n        int longestSubstr = 0;\\n        unordered_map<char, int> maxRepeats;\\n        int start = 0;\\n        int end = 0;\\n        int maxCount = 0;\\n        while(end<s.size()){\\n            maxRepeats[s[end]]++;\\n            \\n         /*  ##  */   maxCount = max(maxCount, maxRepeats[s[end]]);   \\n                       \\n            while((end-start+1)-maxCount > k){\\n                maxRepeats[s[start]]--;\\n                if(maxRepeats[s[start]] == 0){\\n                    maxRepeats.erase(s[start]); \\n                }\\n                start++;\\n            }   longestSubstr = max(longestSubstr, end-start+1);\\n            end++;\\n        } return longestSubstr; \\n    }\\n\\nWaiting for You Gentleman\\'s Reply \\n\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "this problem seems to be hard"
                    },
                    {
                        "username": "Subh001",
                        "content": "for those who are troble in understanding this line of code: max=Math.max(max,++freq[s.charAt(i)- \\'A\\']);\\nhere full explanation for s=\"AABABBA\".\\nThe variable \"i\" is initialized to 0, and the loop starts from the first character of the string \"s\".\\n\\nFor the first iteration, the character at index 0 of \"s\" is \\'A\\'. The expression \"s.charAt(i)- \\'A\\'\" will give 0, which is the index of \\'A\\' in the \"freq\" array.\\n\\nThe code then increments the value of \"freq[0]\" (i.e., the frequency of \\'A\\') by 1, using the prefix increment operator \"++freq[0]\". This means the frequency of \\'A\\' becomes 1.\\n\\nThe code then takes the maximum between \"max\" and the frequency of the current character, which is 1. Since \"max\" is initialized to 0, the maximum value will be 1, and \"max\" is updated to 1.\\n\\nThe loop then proceeds to the second iteration, where \"i\" is incremented to 1, and the character at index 1 of \"s\" is \\'A\\' again.\\n\\nThe expression \"s.charAt(i)- \\'A\\'\" will give 0 again, and the frequency of \\'A\\' in the \"freq\" array will be incremented to 2.\\n\\nThe code then takes the maximum between \"max\" (which is currently 1) and the frequency of the current character (which is 2). The maximum value is 2, so \"max\" is updated to 2.\\n\\nThe loop continues in this manner for the remaining characters of the string \"s\".\\nAt the end of this process, the value of \"max\" will be equal to the frequency of the most frequent character in the string \"s\", which is 3 in this case (since there are three \\'A\\'s in the string). "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Too hard."
                    },
                    {
                        "username": "hngbv95",
                        "content": "This one should be hard"
                    },
                    {
                        "username": "skinnyguy",
                        "content": "3D DP soln passes 23/37\\nthis was most intutive soln for me \\n\\n`class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.size();\\n        vector<vector<vector<int> > > dp;\\n        dp.resize(n);\\n        for(int i=0;i<n;i++){\\n            dp[i].resize(27);\\n            for(char j = 0; j<27;j++){\\n                dp[i][j].resize(k+1,0);\\n            }\\n        }\\n        int ans = INT_MIN;\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(char j = 0; j<27;j++){\\n                for(int l = 0;l <=k;l++){\\n                    if(i<n-1){\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = dp[i+1][j][l]+1;\\n                        else dp[i][j][l] = l != 0?dp[i+1][j][l-1]+1: 0;\\n                    }else{\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = 1;\\n                        else dp[i][j][l] = l != 0?1: 0;\\n                    }\\n                    ans = max(ans, dp[i][j][l]);\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};. `"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "does printing something for large tcs, cause TLE on leetcode ?  "
                    },
                    {
                        "username": "code__HARD",
                        "content": "NO.  But sometimes give Output Limit Error if chars are exceeded\\n "
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "https://leetcode.com/problems/longest-repeating-character-replacement/submissions/889642798/\\n ; )"
                    }
                ]
            },
            {
                "id": 1783842,
                "content": [
                    {
                        "username": "harshyadav11590",
                        "content": "You can copy paste the same code for question [2024](2024)"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "We can use dictionary to keep track of frequencies.\\nlength of slidingwindow - max frequency = allowed operations."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Can anyone tell why this is failing...\\nIt is failing on only 1 tc (testcase 38) and there seems no logical mistake in this method:\\n\\nint characterReplacement(string s, int k) {\\n        int n = s.length();\\n        int alpha = 26, maxLen = 0;\\n        while(alpha--){\\n            int i = 0, j = 0, cnt = 0;\\n            while(i < n){\\n                if(s[i] != \\'A\\' + alpha -1)cnt++;\\n                while(cnt > k){\\n                    if(s[j] != \\'A\\' + alpha -1)cnt--;\\n                    j++;\\n                }\\n                maxLen = max(maxLen, i-j+1);\\n                i++;\\n            }\\n        }\\n        return maxLen;\\n    }"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Please post the test case also."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "\\n*  Would anyOne like to explain me why putting the maxCount variable for counting the maximum repeating chars working properly ,  can\\'t we write (maxRepeats.count(s[end]]) or maxRepeats[s[end]]) instead of it?       \\n\\nint characterReplacement(string s, int k) {\\n        int longestSubstr = 0;\\n        unordered_map<char, int> maxRepeats;\\n        int start = 0;\\n        int end = 0;\\n        int maxCount = 0;\\n        while(end<s.size()){\\n            maxRepeats[s[end]]++;\\n            \\n         /*  ##  */   maxCount = max(maxCount, maxRepeats[s[end]]);   \\n                       \\n            while((end-start+1)-maxCount > k){\\n                maxRepeats[s[start]]--;\\n                if(maxRepeats[s[start]] == 0){\\n                    maxRepeats.erase(s[start]); \\n                }\\n                start++;\\n            }   longestSubstr = max(longestSubstr, end-start+1);\\n            end++;\\n        } return longestSubstr; \\n    }\\n\\nWaiting for You Gentleman\\'s Reply \\n\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "this problem seems to be hard"
                    },
                    {
                        "username": "Subh001",
                        "content": "for those who are troble in understanding this line of code: max=Math.max(max,++freq[s.charAt(i)- \\'A\\']);\\nhere full explanation for s=\"AABABBA\".\\nThe variable \"i\" is initialized to 0, and the loop starts from the first character of the string \"s\".\\n\\nFor the first iteration, the character at index 0 of \"s\" is \\'A\\'. The expression \"s.charAt(i)- \\'A\\'\" will give 0, which is the index of \\'A\\' in the \"freq\" array.\\n\\nThe code then increments the value of \"freq[0]\" (i.e., the frequency of \\'A\\') by 1, using the prefix increment operator \"++freq[0]\". This means the frequency of \\'A\\' becomes 1.\\n\\nThe code then takes the maximum between \"max\" and the frequency of the current character, which is 1. Since \"max\" is initialized to 0, the maximum value will be 1, and \"max\" is updated to 1.\\n\\nThe loop then proceeds to the second iteration, where \"i\" is incremented to 1, and the character at index 1 of \"s\" is \\'A\\' again.\\n\\nThe expression \"s.charAt(i)- \\'A\\'\" will give 0 again, and the frequency of \\'A\\' in the \"freq\" array will be incremented to 2.\\n\\nThe code then takes the maximum between \"max\" (which is currently 1) and the frequency of the current character (which is 2). The maximum value is 2, so \"max\" is updated to 2.\\n\\nThe loop continues in this manner for the remaining characters of the string \"s\".\\nAt the end of this process, the value of \"max\" will be equal to the frequency of the most frequent character in the string \"s\", which is 3 in this case (since there are three \\'A\\'s in the string). "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Too hard."
                    },
                    {
                        "username": "hngbv95",
                        "content": "This one should be hard"
                    },
                    {
                        "username": "skinnyguy",
                        "content": "3D DP soln passes 23/37\\nthis was most intutive soln for me \\n\\n`class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int n = s.size();\\n        vector<vector<vector<int> > > dp;\\n        dp.resize(n);\\n        for(int i=0;i<n;i++){\\n            dp[i].resize(27);\\n            for(char j = 0; j<27;j++){\\n                dp[i][j].resize(k+1,0);\\n            }\\n        }\\n        int ans = INT_MIN;\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(char j = 0; j<27;j++){\\n                for(int l = 0;l <=k;l++){\\n                    if(i<n-1){\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = dp[i+1][j][l]+1;\\n                        else dp[i][j][l] = l != 0?dp[i+1][j][l-1]+1: 0;\\n                    }else{\\n                        if(j+\\'A\\' == s[i])\\n                        dp[i][j][l] = 1;\\n                        else dp[i][j][l] = l != 0?1: 0;\\n                    }\\n                    ans = max(ans, dp[i][j][l]);\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};. `"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "does printing something for large tcs, cause TLE on leetcode ?  "
                    },
                    {
                        "username": "code__HARD",
                        "content": "NO.  But sometimes give Output Limit Error if chars are exceeded\\n "
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "https://leetcode.com/problems/longest-repeating-character-replacement/submissions/889642798/\\n ; )"
                    }
                ]
            }
        ]
    }
]