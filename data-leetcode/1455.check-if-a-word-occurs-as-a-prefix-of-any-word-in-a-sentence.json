[
    {
        "title": "Available Captures for Rook",
        "question_content": "On an 8 x 8 chessboard, there is exactly one white rook 'R' and some number of white bishops 'B', black pawns 'p', and empty squares '.'.\nWhen the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered attacking a pawn if the rook can capture the pawn on the rook's turn. The number of available captures for the white rook is the number of pawns that the rook is attacking.\nReturn the number of available captures for the white rook.\n&nbsp;\nExample 1:\n\nInput: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 3\nExplanation: In this example, the rook is attacking all the pawns.\n\nExample 2:\n\nInput: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 0\nExplanation: The bishops are blocking the rook from attacking any of the pawns.\n\nExample 3:\n\nInput: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 3\nExplanation: The rook is attacking the pawns at positions b5, d6, and f5.\n\n&nbsp;\nConstraints:\n\n\tboard.length == 8\n\tboard[i].length == 8\n\tboard[i][j] is either 'R', '.', 'B', or 'p'\n\tThere is exactly one cell with board[i][j] == 'R'",
        "solutions": [
            {
                "id": 242932,
                "title": "java-c-python-straight-forward-solution",
                "content": "## **Explanation**\\n1. Find index of the white rook\\n2. Search in 4 direction until 8 steps or meet any piece.\\n<br>\\n\\n## **Complexity**\\nTime `O(64)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int numRookCaptures(char[][] board) {\\n        int x0 = 0, y0 = 0, res = 0;\\n        for (int i = 0; i < 8; ++i)\\n            for (int j = 0; j < 8; ++j)\\n                if (board[i][j] == \\'R\\') {\\n                    x0 = i;\\n                    y0 = j;\\n                }\\n\\n        for (int[] d : new int[][] {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}) {\\n            for (int x = x0 + d[0], y = y0 + d[1]; 0 <= x && x < 8 && 0 <= y && y < 8; x += d[0], y += d[1]) {\\n                if (board[x][y] == \\'p\\') res++;\\n                if (board[x][y] != \\'.\\') break;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int x0 = 0, y0 = 0, res = 0;\\n        for (int i = 0; i < 8; ++i)\\n            for (int j = 0; j < 8; ++j)\\n                if (board[i][j] == \\'R\\') {\\n                    x0 = i;\\n                    y0 = j;\\n                }\\n        vector<vector<int>> direction = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        for (auto d : direction) {\\n            for (int x = x0 + d[0], y = y0 + d[1]; 0 <= x && x < 8 && 0 <= y && y < 8; x += d[0], y += d[1]) {\\n                if (board[x][y] == \\'p\\') res++;\\n                if (board[x][y] != \\'.\\') break;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def numRookCaptures(self, board):\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \\'R\\':\\n                    x0, y0 = i, j\\n        res = 0\\n        for i, j in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n            x, y = x0 + i, y0 + j\\n            while 0 <= x < 8 and 0 <= y < 8:\\n                if board[x][y] == \\'p\\': res += 1\\n                if board[x][y] != \\'.\\': break\\n                x, y = x + i, y + j\\n        return res\\n```\\n\\n**Python obligatory 1-line**\\n```py\\n    def numRookCaptures(self, A):\\n        return sum(\\'\\'.join(r).replace(\\'.\\', \\'\\').count(\\'Rp\\') for r in A + zip(*A) for r in [r, r[::-1]])\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int numRookCaptures(char[][] board) {\\n        int x0 = 0, y0 = 0, res = 0;\\n        for (int i = 0; i < 8; ++i)\\n            for (int j = 0; j < 8; ++j)\\n                if (board[i][j] == \\'R\\') {\\n                    x0 = i;\\n                    y0 = j;\\n                }\\n\\n        for (int[] d : new int[][] {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}) {\\n            for (int x = x0 + d[0], y = y0 + d[1]; 0 <= x && x < 8 && 0 <= y && y < 8; x += d[0], y += d[1]) {\\n                if (board[x][y] == \\'p\\') res++;\\n                if (board[x][y] != \\'.\\') break;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int x0 = 0, y0 = 0, res = 0;\\n        for (int i = 0; i < 8; ++i)\\n            for (int j = 0; j < 8; ++j)\\n                if (board[i][j] == \\'R\\') {\\n                    x0 = i;\\n                    y0 = j;\\n                }\\n        vector<vector<int>> direction = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        for (auto d : direction) {\\n            for (int x = x0 + d[0], y = y0 + d[1]; 0 <= x && x < 8 && 0 <= y && y < 8; x += d[0], y += d[1]) {\\n                if (board[x][y] == \\'p\\') res++;\\n                if (board[x][y] != \\'.\\') break;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def numRookCaptures(self, board):\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \\'R\\':\\n                    x0, y0 = i, j\\n        res = 0\\n        for i, j in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n            x, y = x0 + i, y0 + j\\n            while 0 <= x < 8 and 0 <= y < 8:\\n                if board[x][y] == \\'p\\': res += 1\\n                if board[x][y] != \\'.\\': break\\n                x, y = x + i, y + j\\n        return res\\n```\n```py\\n    def numRookCaptures(self, A):\\n        return sum(\\'\\'.join(r).replace(\\'.\\', \\'\\').count(\\'Rp\\') for r in A + zip(*A) for r in [r, r[::-1]])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 242924,
                "title": "c-java-search-and-capture",
                "content": "Search for the rock. From the rock, trace empty spaces in four directions. Return 1 if we hit a pawn, zero otherwise.\\n\\nCount and return captured pawns.\\n```\\nint cap(vector<vector<char>>& b, int x, int y, int dx, int dy) {\\n  while (x >= 0 && x < b.size() && y >= 0 && y < b[x].size() && b[x][y] != \\'B\\') {\\n    if (b[x][y] == \\'p\\') return 1;\\n    x += dx, y += dy;\\n  }\\n  return 0;\\n}\\nint numRookCaptures(vector<vector<char>>& b) {\\n  for (auto i = 0; i < b.size(); ++i)\\n    for (auto j = 0; j < b[i].size(); ++j)\\n      if (b[i][j] == \\'R\\') return cap(b,i,j,0,1)+cap(b,i,j,0,-1)+cap(b,i,j,1,0)+cap(b,i,j,-1,0);\\n  return 0;\\n}\\n```\\nJava version:\\n```\\nint cap(char[][] b, int x, int y, int dx, int dy) {\\n  while (x >= 0 && x < b.length && y >= 0 && y < b[x].length && b[x][y] != \\'B\\') {\\n    if (b[x][y] == \\'p\\') return 1;\\n    x += dx; y += dy;\\n  }\\n  return 0;\\n}\\npublic int numRookCaptures(char[][] b) {\\n  for (int i = 0; i < b.length; ++i)\\n    for (int j = 0; j < b[i].length; ++j)\\n      if (b[i][j] == \\'R\\') return cap(b,i,j,0,1)+cap(b,i,j,0,-1)+cap(b,i,j,1,0)+cap(b,i,j,-1,0);\\n  return 0;\\n}\\n```\\n# Complexity Analysis\\nRuntime: O(n), where n is the total  number of cells. In the worst case, we need to check all cells to find the rock, and then check one row and one column.\\nMemory: O(1).",
                "solutionTags": [],
                "code": "```\\nint cap(vector<vector<char>>& b, int x, int y, int dx, int dy) {\\n  while (x >= 0 && x < b.size() && y >= 0 && y < b[x].size() && b[x][y] != \\'B\\') {\\n    if (b[x][y] == \\'p\\') return 1;\\n    x += dx, y += dy;\\n  }\\n  return 0;\\n}\\nint numRookCaptures(vector<vector<char>>& b) {\\n  for (auto i = 0; i < b.size(); ++i)\\n    for (auto j = 0; j < b[i].size(); ++j)\\n      if (b[i][j] == \\'R\\') return cap(b,i,j,0,1)+cap(b,i,j,0,-1)+cap(b,i,j,1,0)+cap(b,i,j,-1,0);\\n  return 0;\\n}\\n```\n```\\nint cap(char[][] b, int x, int y, int dx, int dy) {\\n  while (x >= 0 && x < b.length && y >= 0 && y < b[x].length && b[x][y] != \\'B\\') {\\n    if (b[x][y] == \\'p\\') return 1;\\n    x += dx; y += dy;\\n  }\\n  return 0;\\n}\\npublic int numRookCaptures(char[][] b) {\\n  for (int i = 0; i < b.length; ++i)\\n    for (int j = 0; j < b[i].length; ++j)\\n      if (b[i][j] == \\'R\\') return cap(b,i,j,0,1)+cap(b,i,j,0,-1)+cap(b,i,j,1,0)+cap(b,i,j,-1,0);\\n  return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427633,
                "title": "python-solution-with-good-performance",
                "content": "Here is a python solution with good performance:\\n```\\nclass Solution:\\n    def numRookCaptures(self, B: List[List[str]]) -> int:\\n        y, x = next((i, j) for j in range(8) for i in range(8) if B[i][j] == \\'R\\')\\n        row = \\'\\'.join(B[y][j] for j in range(8) if B[y][j] != \\'.\\')\\n        col = \\'\\'.join(B[i][x] for i in range(8) if B[i][x] != \\'.\\')\\n        return sum(\\'Rp\\' in s for s in (row, col)) + sum(\\'pR\\' in s for s in (row, col))\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, B: List[List[str]]) -> int:\\n        y, x = next((i, j) for j in range(8) for i in range(8) if B[i][j] == \\'R\\')\\n        row = \\'\\'.join(B[y][j] for j in range(8) if B[y][j] != \\'.\\')\\n        col = \\'\\'.join(B[i][x] for i in range(8) if B[i][x] != \\'.\\')\\n        return sum(\\'Rp\\' in s for s in (row, col)) + sum(\\'pR\\' in s for s in (row, col))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243007,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int[] point = new int[2];\\n        for(int i = 0 ; i < 8 ; i++) {\\n            for(int j = 0 ; j < 8 ; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    point[0] = i;\\n                    point[1] = j;\\n                    break;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        for(int[] dir : dirs) {\\n            int x = point[0] + dir[0];\\n            int y = point[1] + dir[1];\\n            while(x >= 0 && y >= 0 && x < 8 && y < 8 && board[x][y] == \\'.\\') {\\n                x += dir[0];\\n                y += dir[1];\\n            }\\n            if(x < 0 || y < 0 || x >= 8 || y >= 8) continue;\\n            if(board[x][y] == \\'p\\') count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int[] point = new int[2];\\n        for(int i = 0 ; i < 8 ; i++) {\\n            for(int j = 0 ; j < 8 ; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    point[0] = i;\\n                    point[1] = j;\\n                    break;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        for(int[] dir : dirs) {\\n            int x = point[0] + dir[0];\\n            int y = point[1] + dir[1];\\n            while(x >= 0 && y >= 0 && x < 8 && y < 8 && board[x][y] == \\'.\\') {\\n                x += dir[0];\\n                y += dir[1];\\n            }\\n            if(x < 0 || y < 0 || x >= 8 || y >= 8) continue;\\n            if(board[x][y] == \\'p\\') count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845795,
                "title": "easiest-solution-c-plus-plus-dfs-simple-approach-u-must-seen-it-will-be-beneficial",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust using dfs approach to find all the cases that if at any point of the 4 directions p exists or not if it exists count it and remove it and if B in any of that direction then we returns back and hence by recursion of say dfs we can get our ans \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nplease upvote if it is beneficial or helpfull it will take nothing to upvote but it is very helpful for me .........\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count=0;\\n    void solve(vector<vector<char>> &board,int sr,int sc,char ch){\\n        if(sr>=board.size() || sc>= board[0].size() || sr<0 || sc<0 || board[sr][sc]==\\'B\\')    \\n            return;\\n        if(board[sr][sc]==\\'p\\'){\\n            count++;\\n            return;\\n        }\\n        if(board[sr][sc]==\\'.\\'){\\n            if(ch==\\'u\\') solve(board,sr-1,sc,\\'u\\');\\n            if(ch==\\'d\\') solve(board,sr+1,sc,\\'d\\');\\n            if(ch==\\'l\\') solve(board,sr,sc-1,\\'l\\');\\n            if(ch==\\'r\\') solve(board,sr,sc+1,\\'r\\');\\n        }\\n        \\n    }\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==\\'R\\'){ \\n                    solve(board,i-1,j,\\'u\\');\\n                    solve(board,i+1,j,\\'d\\');\\n                    solve(board,i,j-1,\\'l\\');\\n                    solve(board,i,j+1,\\'r\\');\\n                    break;\\n                }\\n            }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nplease upvote if it is beneficial or helpfull it will take nothing to upvote but it is very helpful for me .........\\n```\n```\\nclass Solution {\\npublic:\\n    int count=0;\\n    void solve(vector<vector<char>> &board,int sr,int sc,char ch){\\n        if(sr>=board.size() || sc>= board[0].size() || sr<0 || sc<0 || board[sr][sc]==\\'B\\')    \\n            return;\\n        if(board[sr][sc]==\\'p\\'){\\n            count++;\\n            return;\\n        }\\n        if(board[sr][sc]==\\'.\\'){\\n            if(ch==\\'u\\') solve(board,sr-1,sc,\\'u\\');\\n            if(ch==\\'d\\') solve(board,sr+1,sc,\\'d\\');\\n            if(ch==\\'l\\') solve(board,sr,sc-1,\\'l\\');\\n            if(ch==\\'r\\') solve(board,sr,sc+1,\\'r\\');\\n        }\\n        \\n    }\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==\\'R\\'){ \\n                    solve(board,i-1,j,\\'u\\');\\n                    solve(board,i+1,j,\\'d\\');\\n                    solve(board,i,j-1,\\'l\\');\\n                    solve(board,i,j+1,\\'r\\');\\n                    break;\\n                }\\n            }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415596,
                "title": "java-easy-to-understand-solution-beats-100",
                "content": "```\\npublic int numRookCaptures(char[][] board) {\\n\\tint row = -1, col = -1;    \\n\\tint captures = 0;\\n\\tfor(int i=0; i<8; i++) {\\n\\t\\tfor(int j=0; j<8; j++) {\\n\\t\\t\\tif(board[i][j]==\\'R\\') {\\n\\t\\t\\t\\trow = i;\\n\\t\\t\\t\\tcol = j;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=col-1; i>0; i--) {\\n\\t\\tif(board[row][i]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[row][i]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=col+1; i<8; i++) {\\n\\t\\tif(board[row][i]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[row][i]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=row-1; i>0; i--) {\\n\\t\\tif(board[i][col]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[i][col]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=row+1; i<8; i++) {\\n\\t\\tif(board[i][col]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[i][col]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn captures;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numRookCaptures(char[][] board) {\\n\\tint row = -1, col = -1;    \\n\\tint captures = 0;\\n\\tfor(int i=0; i<8; i++) {\\n\\t\\tfor(int j=0; j<8; j++) {\\n\\t\\t\\tif(board[i][j]==\\'R\\') {\\n\\t\\t\\t\\trow = i;\\n\\t\\t\\t\\tcol = j;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=col-1; i>0; i--) {\\n\\t\\tif(board[row][i]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[row][i]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=col+1; i<8; i++) {\\n\\t\\tif(board[row][i]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[row][i]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=row-1; i>0; i--) {\\n\\t\\tif(board[i][col]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[i][col]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=row+1; i<8; i++) {\\n\\t\\tif(board[i][col]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[i][col]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn captures;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244639,
                "title": "js-concise-and-easy-to-understand-solution",
                "content": "```\\nconst canCapture = (board, i, j) => {\\n    let captures = 0, dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    \\n    for (let dir of dirs) {\\n        let r = i + dir[0], c = j + dir[1];\\n            \\n        while (r >= 0 && r < 8 && c >= 0 && c < 8) {\\n            if (board[r][c] === \\'p\\') { captures++; }\\n            if (board[r][c] !== \\'.\\') { break; }\\n            \\n            r += dir[0];\\n            c += dir[1];\\n        }\\n    }\\n    \\n    return captures;\\n}\\n\\nconst numRookCaptures = board => {\\n    for (let i = 0; i < 8; i++) {\\n        for (let j = 0; j < 8; j++) {\\n            if (board[i][j] === \\'R\\') {\\n                return canCapture(board, i, j);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst canCapture = (board, i, j) => {\\n    let captures = 0, dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    \\n    for (let dir of dirs) {\\n        let r = i + dir[0], c = j + dir[1];\\n            \\n        while (r >= 0 && r < 8 && c >= 0 && c < 8) {\\n            if (board[r][c] === \\'p\\') { captures++; }\\n            if (board[r][c] !== \\'.\\') { break; }\\n            \\n            r += dir[0];\\n            c += dir[1];\\n        }\\n    }\\n    \\n    return captures;\\n}\\n\\nconst numRookCaptures = board => {\\n    for (let i = 0; i < 8; i++) {\\n        for (let j = 0; j < 8; j++) {\\n            if (board[i][j] === \\'R\\') {\\n                return canCapture(board, i, j);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354637,
                "title": "python-3-not-the-shortest-but-neat-and-easy-to-understand",
                "content": "The idea is to find the Rook location and then start looking at 4 directions to find nearest piece. Check if the nearest piece is friend or foe using `isupper()`, `islower()`. \\nRuntime varies from 48 ms (14%) to 32 ms (96%) so i guess it\\'s good enough. Anyways, the most important thing is it\\'s easy to understand\\n```python\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        def check_direction(R,C,direction):\\n            if direction==\"right\":\\n                for col in range(C+1,8): # increasing col \\n                    if board[R][col].islower():return 1\\n                    if board[R][col].isupper():return 0\\n            if direction==\"left\":\\n                for col in range(C-1,-1,-1): # decreasing col \\n                    if board[R][col].islower():return 1\\n                    if board[R][col].isupper():return 0\\n            if direction==\"down\":\\n                for row in range(R+1,8): # increasing row\\n                    if board[row][C].islower():return 1\\n                    if board[row][C].isupper():return 0\\n            if direction==\"up\": \\n                for row in range(R-1,-1,-1): # decreasing col \\n                    if board[row][C].islower():return 1\\n                    if board[row][C].isupper():return 0\\n            return 0 # we reach the edge (nothing was found)\\n                    \\n        for row in range(8):\\n            for col in range(8):\\n                if board[row][col]==\"R\":\\n\\t\\t\\t\\t\\t# sum all directions up\\n                    return sum([check_direction(row,col,\"right\"),\\n                                check_direction(row,col,\"left\"),\\n                                check_direction(row,col,\"up\"),\\n                                check_direction(row,col,\"down\")])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        def check_direction(R,C,direction):\\n            if direction==\"right\":\\n                for col in range(C+1,8): # increasing col \\n                    if board[R][col].islower():return 1\\n                    if board[R][col].isupper():return 0\\n            if direction==\"left\":\\n                for col in range(C-1,-1,-1): # decreasing col \\n                    if board[R][col].islower():return 1\\n                    if board[R][col].isupper():return 0\\n            if direction==\"down\":\\n                for row in range(R+1,8): # increasing row\\n                    if board[row][C].islower():return 1\\n                    if board[row][C].isupper():return 0\\n            if direction==\"up\": \\n                for row in range(R-1,-1,-1): # decreasing col \\n                    if board[row][C].islower():return 1\\n                    if board[row][C].isupper():return 0\\n            return 0 # we reach the edge (nothing was found)\\n                    \\n        for row in range(8):\\n            for col in range(8):\\n                if board[row][col]==\"R\":\\n\\t\\t\\t\\t\\t# sum all directions up\\n                    return sum([check_direction(row,col,\"right\"),\\n                                check_direction(row,col,\"left\"),\\n                                check_direction(row,col,\"up\"),\\n                                check_direction(row,col,\"down\")])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198090,
                "title": "c-runtime-0-ms-faster-than-100-00-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int cap=0,row,col;\\n\\t\\t//Find the position of the rook\\n        for(int i=0; i<8; i++){\\n            for(int j=0; j<8; j++){\\n                if(board[i][j]==\\'R\\'){\\n                    row=i;\\n                    col=j;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Move in upward direction to check for any possible captures\\n        int i=row,j=col;\\n        while(i>=0 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }            \\n            i--;\\n        }\\n\\t\\t\\n\\t\\t//Move in downward direction to check for any possible captures\\n        i=row,j=col;\\n        while(i<=7 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }            \\n            i++;\\n        }\\n\\t\\t\\n\\t\\t//Move in leftward direction to check for any possible captures\\n        i=row,j=col;\\n        while(j>=0 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }            \\n            j--;\\n        }\\n\\t\\t\\n\\t\\t//Move in rightward direction to check for any possible captures\\n        i=row,j=col;\\n        while(j<=7 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }\\n            j++;\\n        }\\n        \\n        return cap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int cap=0,row,col;\\n\\t\\t//Find the position of the rook\\n        for(int i=0; i<8; i++){\\n            for(int j=0; j<8; j++){\\n                if(board[i][j]==\\'R\\'){\\n                    row=i;\\n                    col=j;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Move in upward direction to check for any possible captures\\n        int i=row,j=col;\\n        while(i>=0 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }            \\n            i--;\\n        }\\n\\t\\t\\n\\t\\t//Move in downward direction to check for any possible captures\\n        i=row,j=col;\\n        while(i<=7 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }            \\n            i++;\\n        }\\n\\t\\t\\n\\t\\t//Move in leftward direction to check for any possible captures\\n        i=row,j=col;\\n        while(j>=0 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }            \\n            j--;\\n        }\\n\\t\\t\\n\\t\\t//Move in rightward direction to check for any possible captures\\n        i=row,j=col;\\n        while(j<=7 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }\\n            j++;\\n        }\\n        \\n        return cap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356593,
                "title": "solution-in-python-3-beats-97-three-lines",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, b: List[List[str]]) -> int:\\n        I, J = divmod(sum(b,[]).index(\\'R\\'),8)\\n        C = \"\".join([i for i in [b[I]+[\\'B\\']+[b[i][J] for i in range(8)]][0] if i != \\'.\\'])\\n        return C.count(\\'Rp\\') + C.count(\\'pR\\')\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, b: List[List[str]]) -> int:\\n        I, J = divmod(sum(b,[]).index(\\'R\\'),8)\\n        C = \"\".join([i for i in [b[I]+[\\'B\\']+[b[i][J] for i in range(8)]][0] if i != \\'.\\'])\\n        return C.count(\\'Rp\\') + C.count(\\'pR\\')\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 244129,
                "title": "javascript-solution",
                "content": "```\\nfunction findRook(board) {\\n\\tfor (let i = 0; i < board.length; i++) {\\n\\t\\tfor (let j = 0; j < board[i].length; j++) {\\n\\t\\t\\tif (board[i][j] === \\'R\\') {\\n\\t\\t\\t\\treturn {i, j};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction checkRight(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (j === board[i].length - 1) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tj++;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nfunction checkLeft(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (j === 0) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tj--;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nfunction checkTop(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (i === 0) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\ti--;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nfunction checkDown(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (i === board.length - 1) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\ti++;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nlet numRookCaptures = function(board) {\\n\\tlet rook = findRook(board);\\n\\tlet counter = 0;\\n\\n\\tcounter += checkRight(board, rook.i, rook.j);\\n\\tcounter += checkLeft(board, rook.i, rook.j);\\n\\tcounter += checkTop(board, rook.i, rook.j);\\n\\tcounter += checkDown(board, rook.i, rook.j);\\n\\n\\treturn counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction findRook(board) {\\n\\tfor (let i = 0; i < board.length; i++) {\\n\\t\\tfor (let j = 0; j < board[i].length; j++) {\\n\\t\\t\\tif (board[i][j] === \\'R\\') {\\n\\t\\t\\t\\treturn {i, j};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction checkRight(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (j === board[i].length - 1) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tj++;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nfunction checkLeft(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (j === 0) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tj--;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nfunction checkTop(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (i === 0) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\ti--;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nfunction checkDown(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (i === board.length - 1) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\ti++;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nlet numRookCaptures = function(board) {\\n\\tlet rook = findRook(board);\\n\\tlet counter = 0;\\n\\n\\tcounter += checkRight(board, rook.i, rook.j);\\n\\tcounter += checkLeft(board, rook.i, rook.j);\\n\\tcounter += checkTop(board, rook.i, rook.j);\\n\\tcounter += checkDown(board, rook.i, rook.j);\\n\\n\\treturn counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244315,
                "title": "simple-python-6-lines-and-2-lines",
                "content": "```python\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n    # find \\'R\\'\\n    for row in range(8):\\n        for col in range(8):\\n            if board[row][col] == \\'R\\':\\n\\t\\t\\t    # build two strings for the raw and the column\\n                r = \\'\\'.join(x for x in board[row] if x != \\'.\\')\\n                c = \\'\\'.join(board[i][col] for i in range(8) if board[i][col] != \\'.\\')\\n\\t\\t\\t\\t# count the number of \\'Rp\\' substring \\n                return sum(\\'Rp\\' in x for x in (r, r[::-1], c, c[::-1]))\\n```\\n\\nor, we can go even further, and skip finding part, just convert all rows and columns to string:\\n```python\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n\\tlines = [\\'\\'.join(x for x in row if x != \\'.\\') for row in itertools.chain(board, zip(*board))]\\n\\treturn sum(\\'Rp\\' in x for x in lines) + sum(\\'pR\\' in x for x in lines)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n    # find \\'R\\'\\n    for row in range(8):\\n        for col in range(8):\\n            if board[row][col] == \\'R\\':\\n\\t\\t\\t    # build two strings for the raw and the column\\n                r = \\'\\'.join(x for x in board[row] if x != \\'.\\')\\n                c = \\'\\'.join(board[i][col] for i in range(8) if board[i][col] != \\'.\\')\\n\\t\\t\\t\\t# count the number of \\'Rp\\' substring \\n                return sum(\\'Rp\\' in x for x in (r, r[::-1], c, c[::-1]))\\n```\n```python\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n\\tlines = [\\'\\'.join(x for x in row if x != \\'.\\') for row in itertools.chain(board, zip(*board))]\\n\\treturn sum(\\'Rp\\' in x for x in lines) + sum(\\'pR\\' in x for x in lines)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 955527,
                "title": "python-simple-to-understand",
                "content": "\\'\\'\\'class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        count = 0\\n\\n        for i in range(len(board)):\\n            x = \"\".join(board[i]).replace(\\'.\\', \\'\\')\\n            if \\'Rp\\' in x:\\n                count += 1\\n            if \\'pR\\' in x:\\n                count += 1\\n\\n        board = list(zip(*board))\\n\\n        for i in range(len(board)):\\n            x = \"\".join(board[i]).replace(\\'.\\', \\'\\')\\n            if \\'Rp\\' in x:\\n                count += 1\\n            if \\'pR\\' in x:\\n                count += 1  \\n\\n        return count\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        count = 0\\n\\n        for i in range(len(board)):\\n            x = \"\".join(board[i]).replace(\\'.\\', \\'\\')\\n            if \\'Rp\\' in x:\\n                count += 1\\n            if \\'pR\\' in x:\\n                count += 1\\n\\n        board = list(zip(*board))\\n\\n        for i in range(len(board)):\\n            x = \"\".join(board[i]).replace(\\'.\\', \\'\\')\\n            if \\'Rp\\' in x:\\n                count += 1\\n            if \\'pR\\' in x:\\n                count += 1  \\n\\n        return count\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 765433,
                "title": "c-very-easy-for-beginners-with-explanation",
                "content": "We will first find the location of our rook.\\nNow, we know that max number of captures a rook can make is 4 (Top +Down+ Left+ Right). Now we just have to iterate four times in these directions starting from the rook\\'s coordinates.\\n\\nThere are 3 possibilities:\\n1. We come across a pawn first: In this case, the capture in this direction increases by 1\\n2. We come across a bishop first: in this case, no capture can be done in this direction as bishop is blocking further moves\\n3. We don\\'t come across any piece: In this case, we just use our default(zero) value\\n\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int T=0,D=0,L=0,R=0;\\n        int posX,posY;\\n        for (auto i=0;i<8;i++)\\n            for (auto j=0;j<8;j++)\\n                if(board[i][j]==\\'R\\') {\\n                    posX = i;\\n                    posY = j;\\n                    break;\\n                }\\n        \\n        int x,y;  // x - to traverse rows; y - to traverse columns\\n        x=posX;\\n        y=posY;\\n        while(--x>0) {\\n            if(board[x][y]==\\'p\\') {\\n                T = 1;\\n                break;\\n            }\\n            else if(board[x][y]==\\'B\\') \\n            break;\\n            \\n        }\\n        \\n        x=posX;\\n        y=posY;\\n        while(++x<8) {\\n            if(board[x][y]==\\'p\\') {\\n                D = 1;\\n                break;\\n            }\\n            else if(board[x][y]==\\'B\\')\\n                break;\\n        }\\n        \\n        x=posX;\\n        y=posY;\\n        while(--y>0) {\\n            if(board[x][y]==\\'p\\') {\\n                L = 1;\\n                break;\\n            }\\n            else if(board[x][y]==\\'B\\')\\n                break;\\n        }\\n        \\n        x=posX;\\n        y=posY;\\n        while(++y<8) {\\n            if(board[x][y]==\\'p\\') {\\n                R = 1;\\n                break;\\n            }\\n            else if(board[x][y]==\\'B\\')\\n                break;\\n        }\\n        \\n        return (T+D+L+R);\\n                    \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int T=0,D=0,L=0,R=0;\\n        int posX,posY;\\n        for (auto i=0;i<8;i++)\\n            for (auto j=0;j<8;j++)\\n                if(board[i][j]==\\'R\\') {\\n                    posX = i;\\n                    posY = j;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 384165,
                "title": "javascript-easy-to-understand-36ms",
                "content": "- Traversal the whole chessboard to find the position of rook\\n- Check the 4 directions and counting pawns\\n\\n```js\\nconst numRookCaptures = board => {\\n  let x, y;\\n  let ret = 0;\\n  for (let i = 0; i < 8; ++i) {\\n    for (let j = 0; j < 8; ++j) {\\n      if (board[i][j] === \\'R\\') {\\n        x = i;\\n        y = j;\\n      }\\n    }\\n  }\\n  for (let i = x + 1; i < 8; ++i) {\\n    if (board[i][y] === \\'B\\') break;\\n    if (board[i][y] === \\'p\\') { ++ret; break; }\\n  }\\n  for (let i = x - 1; i >= 0; --i) {\\n    if (board[i][y] === \\'B\\') break;\\n    if (board[i][y] === \\'p\\') { ++ret; break; }\\n  }\\n  for (let i = y + 1; i < 8; ++i) {\\n    if (board[x][i] === \\'B\\') break;\\n    if (board[x][i] === \\'p\\') { ++ret; break; }\\n  }\\n  for (let i = y - 1; i >= 0; --i) {\\n    if (board[x][i] === \\'B\\') break;\\n    if (board[x][i] === \\'p\\') { ++ret; break; }\\n  }\\n  return ret;\\n};\\n```\\n\\nActually, we can do the check for each direction through a loop. The code is like:\\n\\n```js\\nconst numRookCaptures = board => {\\n  let x, y;\\n  let ret = 0;\\n  for (let i = 0; i < 8; ++i) {\\n    for (let j = 0; j < 8; ++j) {\\n      if (board[i][j] === \\'R\\') {\\n        x = i;\\n        y = j;\\n      }\\n    }\\n  }\\n\\n  for (const [xo, yo] of [[0, -1], [0, 1], [-1, 0], [1, 0]]) {\\n    for (let i = x + xo, j = y + yo; i < 8 && i >= 0 && j < 8 && j >= 0; i += xo, j += yo) {\\n      if (board[i][j] === \"B\") break;\\n      if (board[i][j] === \"p\") { ++ret; break; }\\n    }\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst numRookCaptures = board => {\\n  let x, y;\\n  let ret = 0;\\n  for (let i = 0; i < 8; ++i) {\\n    for (let j = 0; j < 8; ++j) {\\n      if (board[i][j] === \\'R\\') {\\n        x = i;\\n        y = j;\\n      }\\n    }\\n  }\\n  for (let i = x + 1; i < 8; ++i) {\\n    if (board[i][y] === \\'B\\') break;\\n    if (board[i][y] === \\'p\\') { ++ret; break; }\\n  }\\n  for (let i = x - 1; i >= 0; --i) {\\n    if (board[i][y] === \\'B\\') break;\\n    if (board[i][y] === \\'p\\') { ++ret; break; }\\n  }\\n  for (let i = y + 1; i < 8; ++i) {\\n    if (board[x][i] === \\'B\\') break;\\n    if (board[x][i] === \\'p\\') { ++ret; break; }\\n  }\\n  for (let i = y - 1; i >= 0; --i) {\\n    if (board[x][i] === \\'B\\') break;\\n    if (board[x][i] === \\'p\\') { ++ret; break; }\\n  }\\n  return ret;\\n};\\n```\n```js\\nconst numRookCaptures = board => {\\n  let x, y;\\n  let ret = 0;\\n  for (let i = 0; i < 8; ++i) {\\n    for (let j = 0; j < 8; ++j) {\\n      if (board[i][j] === \\'R\\') {\\n        x = i;\\n        y = j;\\n      }\\n    }\\n  }\\n\\n  for (const [xo, yo] of [[0, -1], [0, 1], [-1, 0], [1, 0]]) {\\n    for (let i = x + xo, j = y + yo; i < 8 && i >= 0 && j < 8 && j >= 0; i += xo, j += yo) {\\n      if (board[i][j] === \"B\") break;\\n      if (board[i][j] === \"p\") { ++ret; break; }\\n    }\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1149526,
                "title": "java-runtime-0ms-faster-than-100-memory-less-than-97-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        \\n        //loop through the board and fin dthe position of the Rook\\n        //Once we found the position, \\n        //Go Up, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //Go Down, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //Go Left, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //Go Right, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //return the sum of counts.\\n        \\n        int result = 0;\\n        //Looping the board to find the position of \\'R\\'\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    result+=goUp(board, i, j)?1:0;\\n                    result+=goDown(board, i, j)?1:0;\\n                    result+=goLeft(board, i, j)?1:0;\\n                    result+=goRight(board, i, j)?1:0;\\n                    return result;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    //Check by moving up, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goUp(char[][] board, int row, int column){\\n        for(int i= row; i>=0; i--){\\n            if(board[i][column] == \\'p\\'){\\n                return true;\\n            }else if(board[i][column] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //Check by moving down, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goDown(char[][] board, int row, int column){\\n        for(int i= row; i<board.length; i++){\\n            if(board[i][column] == \\'p\\'){\\n                return true;\\n            }else if(board[i][column] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //Check by moving left, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goLeft(char[][] board, int row, int column){\\n        for(int i= column; i>=0; i--){\\n            if(board[row][i] == \\'p\\'){\\n                return true;\\n            }else if(board[row][i] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //Check by moving right, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goRight(char[][] board, int row, int column){\\n        for(int i= column; i<board[0].length; i++){\\n            if(board[row][i] == \\'p\\'){\\n                return true;\\n            }else if(board[row][i] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        \\n        //loop through the board and fin dthe position of the Rook\\n        //Once we found the position, \\n        //Go Up, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //Go Down, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //Go Left, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //Go Right, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //return the sum of counts.\\n        \\n        int result = 0;\\n        //Looping the board to find the position of \\'R\\'\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    result+=goUp(board, i, j)?1:0;\\n                    result+=goDown(board, i, j)?1:0;\\n                    result+=goLeft(board, i, j)?1:0;\\n                    result+=goRight(board, i, j)?1:0;\\n                    return result;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    //Check by moving up, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goUp(char[][] board, int row, int column){\\n        for(int i= row; i>=0; i--){\\n            if(board[i][column] == \\'p\\'){\\n                return true;\\n            }else if(board[i][column] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //Check by moving down, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goDown(char[][] board, int row, int column){\\n        for(int i= row; i<board.length; i++){\\n            if(board[i][column] == \\'p\\'){\\n                return true;\\n            }else if(board[i][column] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //Check by moving left, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goLeft(char[][] board, int row, int column){\\n        for(int i= column; i>=0; i--){\\n            if(board[row][i] == \\'p\\'){\\n                return true;\\n            }else if(board[row][i] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //Check by moving right, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goRight(char[][] board, int row, int column){\\n        for(int i= column; i<board[0].length; i++){\\n            if(board[row][i] == \\'p\\'){\\n                return true;\\n            }else if(board[row][i] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503766,
                "title": "javascript-1-line-regex-solution",
                "content": "I took another stab at it after my last solution had an issue but still gave correct answers.\\n\\nI had other 1-line solutions but wasn\\'t happy with the regex part. So I shifted the complexity from the regex to more string/array operations. This way makes more sense to me.\\n\\n_Runtime: 60 ms, faster than 53.99% of JavaScript online submissions_\\n_Memory Usage: 33.3 MB, less than 80.17% of JavaScript online submissions_\\n\\n```javascript\\n/**\\n * @param {string[][]} board\\n * @return {number}\\n */\\nconst numRookCaptures = board =>\\n  [\\n    board\\n      .map(row => row.join(\\'\\'))\\n      .join(\\'\\')\\n      .indexOf(\\'R\\'),\\n  ]\\n    .reduce(\\n      (_, rIndex) => [\\n        ...board[Math.trunc(rIndex / 8)]\\n          .join(\\'\\')\\n          .split(\\'R\\')\\n          .reduce((left, right) => [left, [...right].reverse().join(\\'\\')]),\\n        ...board\\n          .reduce((col, row) => (col += row[rIndex % 8]), \\'\\')\\n          .split(\\'R\\')\\n          .reduce((up, down) => [up, [...down].reverse().join(\\'\\')]),\\n      ],\\n      null,\\n    )\\n    .reduce((acc, curr) => acc + (/p\\\\.*$/.test(curr) ? 1 : 0), 0);\\n```\\n\\n_Runtime: 68 ms, faster than 30.67% of JavaScript online submissions_\\n_Memory Usage: 33 MB, less than 87.93% of JavaScript online submissions_\\n\\n```javascript\\n/**\\n * @param {string[][]} board\\n * @return {number}\\n */\\nconst numRookCaptures = board => {\\n  const [rows, cols] = [new Array(8).fill(\\'\\'), new Array(8).fill(\\'\\')];\\n  let rookRow, rookCol;\\n  for (let i = 0; i < 8; i++)\\n    for (let j = 0; j < 8; j++) {\\n      rows[i] += board[i][j];\\n      cols[i] += board[j][i];\\n      if (\\'R\\' === board[i][j]) [rookRow, rookCol] = [i, j];\\n    }\\n  let captures = 0;\\n  /* Look left  */ if (/p\\\\.*R/.test(rows[rookRow])) captures++;\\n  /* Look right */ if (/R\\\\.*p/.test(rows[rookRow])) captures++;\\n  /* Look up    */ if (/p\\\\.*R/.test(cols[rookCol])) captures++;\\n  /* Look down  */ if (/R\\\\.*p/.test(cols[rookCol])) captures++;\\n  return captures;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[][]} board\\n * @return {number}\\n */\\nconst numRookCaptures = board =>\\n  [\\n    board\\n      .map(row => row.join(\\'\\'))\\n      .join(\\'\\')\\n      .indexOf(\\'R\\'),\\n  ]\\n    .reduce(\\n      (_, rIndex) => [\\n        ...board[Math.trunc(rIndex / 8)]\\n          .join(\\'\\')\\n          .split(\\'R\\')\\n          .reduce((left, right) => [left, [...right].reverse().join(\\'\\')]),\\n        ...board\\n          .reduce((col, row) => (col += row[rIndex % 8]), \\'\\')\\n          .split(\\'R\\')\\n          .reduce((up, down) => [up, [...down].reverse().join(\\'\\')]),\\n      ],\\n      null,\\n    )\\n    .reduce((acc, curr) => acc + (/p\\\\.*$/.test(curr) ? 1 : 0), 0);\\n```\n```javascript\\n/**\\n * @param {string[][]} board\\n * @return {number}\\n */\\nconst numRookCaptures = board => {\\n  const [rows, cols] = [new Array(8).fill(\\'\\'), new Array(8).fill(\\'\\')];\\n  let rookRow, rookCol;\\n  for (let i = 0; i < 8; i++)\\n    for (let j = 0; j < 8; j++) {\\n      rows[i] += board[i][j];\\n      cols[i] += board[j][i];\\n      if (\\'R\\' === board[i][j]) [rookRow, rookCol] = [i, j];\\n    }\\n  let captures = 0;\\n  /* Look left  */ if (/p\\\\.*R/.test(rows[rookRow])) captures++;\\n  /* Look right */ if (/R\\\\.*p/.test(rows[rookRow])) captures++;\\n  /* Look up    */ if (/p\\\\.*R/.test(cols[rookCol])) captures++;\\n  /* Look down  */ if (/R\\\\.*p/.test(cols[rookCol])) captures++;\\n  return captures;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604440,
                "title": "very-easy-solution-c",
                "content": "**Idea :  We move in 4 direction from the current \\'R\\' row number and col number, and stop when we encounter \\'p\\' if we see \\'B\\' we can\\'t able to move \\'R\\', and also if there is no \\'p\\' and \\'B\\' in the direction in which \\'R\\' is moving , it will stop till the end of chess grid.**\\n\\n- So, we create four functions to move in the direction named as - left(),right(),up(),down();\\n- In the functions parameters are board as reference and \\'R\\' row number and col number to move up,down,left,right from that row or col.\\n\\n```\\nclass Solution {\\n    int up(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        while(row>=0){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            row--;\\n        }\\n        return ans;\\n    }\\n    \\n    int down(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        int totalRows = board.size();\\n        while(row < totalRows){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            row++;\\n        }\\n        return ans;\\n    }\\n    \\n    int right(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        int totalColumn = board[0].size();\\n        while(col < totalColumn){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            col++;\\n        }\\n        return ans;\\n    }\\n    \\n    int left(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        while(col >= 0){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            col--;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int rows = board.size();\\n        int cols = board[0].size();\\n        int ans = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(board[i][j] == \\'R\\'){\\n                    int l,r,u,d;\\n                    l = left(board,i,j);\\n                    r = right(board,i,j);\\n                    u = up(board,i,j);\\n                    d = down(board,i,j);\\n                    ans = l + r + u + d;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n***Upvote, if you like the solution approach.***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int up(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        while(row>=0){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            row--;\\n        }\\n        return ans;\\n    }\\n    \\n    int down(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        int totalRows = board.size();\\n        while(row < totalRows){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            row++;\\n        }\\n        return ans;\\n    }\\n    \\n    int right(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        int totalColumn = board[0].size();\\n        while(col < totalColumn){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            col++;\\n        }\\n        return ans;\\n    }\\n    \\n    int left(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        while(col >= 0){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            col--;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int rows = board.size();\\n        int cols = board[0].size();\\n        int ans = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(board[i][j] == \\'R\\'){\\n                    int l,r,u,d;\\n                    l = left(board,i,j);\\n                    r = right(board,i,j);\\n                    u = up(board,i,j);\\n                    d = down(board,i,j);\\n                    ans = l + r + u + d;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601678,
                "title": "python-3-easy-to-understand-faster-than-96",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        n = 8\\n        for i in range(n):  # find rook location\\n            for j in range(n):\\n                if board[i][j] == \\'R\\':\\n                    x, y = i, j\\n                    break\\n        \\n        res = 0\\n        for i in range(x-1, -1, -1):  # check north\\n            if board[i][y] == \\'p\\':\\n                res += 1\\n                break\\n            if board[i][y] == \\'B\\':\\n                break\\n        \\n        for i in range(x+1, n):  # check south\\n            if board[i][y] == \\'p\\':\\n                res += 1\\n                break\\n            if board[i][y] == \\'B\\':\\n                break\\n        \\n        for j in range(y-1, -1, -1):  # check west\\n            if board[x][j] == \\'p\\':\\n                res += 1\\n                break\\n            if board[x][j] == \\'B\\':\\n                break\\n        \\n        for j in range(y+1, n):  # check east\\n            if board[x][j] == \\'p\\':\\n                res += 1\\n                break\\n            if board[x][j] == \\'B\\':\\n                break\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        n = 8\\n        for i in range(n):  # find rook location\\n            for j in range(n):\\n                if board[i][j] == \\'R\\':\\n                    x, y = i, j\\n                    break\\n        \\n        res = 0\\n        for i in range(x-1, -1, -1):  # check north\\n            if board[i][y] == \\'p\\':\\n                res += 1\\n                break\\n            if board[i][y] == \\'B\\':\\n                break\\n        \\n        for i in range(x+1, n):  # check south\\n            if board[i][y] == \\'p\\':\\n                res += 1\\n                break\\n            if board[i][y] == \\'B\\':\\n                break\\n        \\n        for j in range(y-1, -1, -1):  # check west\\n            if board[x][j] == \\'p\\':\\n                res += 1\\n                break\\n            if board[x][j] == \\'B\\':\\n                break\\n        \\n        for j in range(y+1, n):  # check east\\n            if board[x][j] == \\'p\\':\\n                res += 1\\n                break\\n            if board[x][j] == \\'B\\':\\n                break\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1112858,
                "title": "easiest-recursive-solution-97-6-time-98-2-space",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        def find(rx, ry, direction, count):\\n            if rx == 8 or ry == 8 or rx == -1 or ry == -1: return count\\n            if board[rx][ry] == \"B\": return 0\\n            if board[rx][ry] == \"p\": return count + 1\\n            if direction == \"L\": return find(rx, ry - 1, \"L\", count)\\n            elif direction == \"R\": return find(rx, ry + 1, \"R\", count)\\n            elif direction == \"U\": return find(rx - 1, ry, \"U\", count)\\n            else: return find(rx + 1, ry, \"D\", count)\\n            \\n        rookx = rooky = -1\\n        for i in range(len(board)):\\n            if \"R\" in board[i]:\\n                rookx, rooky = i, board[i].index(\"R\")\\n                break\\n                \\n        return find(rookx, rooky, \"L\", 0) + find(rookx, rooky, \"R\", 0) + find(rookx, rooky, \"U\", 0) + find(rookx, rooky, \"D\", 0)\\n```\\nFor more such questions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        def find(rx, ry, direction, count):\\n            if rx == 8 or ry == 8 or rx == -1 or ry == -1: return count\\n            if board[rx][ry] == \"B\": return 0\\n            if board[rx][ry] == \"p\": return count + 1\\n            if direction == \"L\": return find(rx, ry - 1, \"L\", count)\\n            elif direction == \"R\": return find(rx, ry + 1, \"R\", count)\\n            elif direction == \"U\": return find(rx - 1, ry, \"U\", count)\\n            else: return find(rx + 1, ry, \"D\", count)\\n            \\n        rookx = rooky = -1\\n        for i in range(len(board)):\\n            if \"R\" in board[i]:\\n                rookx, rooky = i, board[i].index(\"R\")\\n                break\\n                \\n        return find(rookx, rooky, \"L\", 0) + find(rookx, rooky, \"R\", 0) + find(rookx, rooky, \"U\", 0) + find(rookx, rooky, \"D\", 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924789,
                "title": "python3-solution-24ms-runtime-and-14mb-memory-usage",
                "content": "class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        for i in range (0,len(board)):\\n            if \\'R\\'in board[i]:\\n                col=i\\n                row=board[i].index(\\'R\\')\\n        op=0\\n        for i in range (row+1,len(board[col])):\\n            if board[col][i]==\\'B\\':\\n                break\\n            elif board[col][i]==\\'p\\':\\n                op+=1\\n                break\\n                \\n        for i in range(row-1,-1,-1):\\n            if board[col][i]==\\'B\\':\\n                break\\n            elif board[col][i]==\\'p\\':\\n                op+=1\\n                break\\n        \\n        for i in range(col,len(board)):\\n            if board[i][row]==\\'B\\':\\n                break\\n            elif board[i][row]==\\'p\\':\\n                op+=1\\n                break\\n                \\n        for i in range(col,-1,-1):\\n            if board[i][row]==\\'B\\':\\n                break\\n            elif board[i][row]==\\'p\\':\\n                op+=1\\n                break\\n        \\n        return op\\n\\t\\t\\n\\t\\t\\n\\n\\n![image](https://assets.leetcode.com/users/images/14653ef7-8eae-452b-9265-dbedfe684a5b_1604603491.4019651.png)\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        for i in range (0,len(board)):\\n            if \\'R\\'in board[i]:\\n                col=i\\n                row=board[i].index(\\'R\\')\\n        op=0\\n        for i in range (row+1,len(board[col])):\\n            if board[col][i]==\\'B\\':\\n                break\\n            elif board[col][i]==\\'p\\':\\n                op+=1\\n                break\\n                \\n        for i in range(row-1,-1,-1):\\n            if board[col][i]==\\'B\\':\\n                break\\n            elif board[col][i]==\\'p\\':\\n                op+=1\\n                break\\n        \\n        for i in range(col,len(board)):\\n            if board[i][row]==\\'B\\':\\n                break\\n            elif board[i][row]==\\'p\\':\\n                op+=1\\n                break\\n                \\n        for i in range(col,-1,-1):\\n            if board[i][row]==\\'B\\':\\n                break\\n            elif board[i][row]==\\'p\\':\\n                op+=1\\n                break\\n        \\n        return op\\n\\t\\t\\n\\t\\t\\n\\n\\n![image](https://assets.leetcode.com/users/images/14653ef7-8eae-452b-9265-dbedfe684a5b_1604603491.4019651.png)\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 301748,
                "title": "beginner-python-runtime-16ms-faster-than-98-73-of-submissions-any-suggestions",
                "content": "class Solution(object):\\n    def numRookCaptures(self, board):\\n        \\n        horizontal = []\\n        vertical = []\\n        for i in range(0,8):\\n            temp_hor = \\'\\'\\n            temp_ver = \\'\\'\\n            for j in range(0,8):\\n                if board[i][j] != \\'.\\':\\n                    temp_hor = temp_hor + board[i][j]\\n                if board[j][i] != \\'.\\':\\n                    temp_ver = temp_ver + board[j][i]\\n            horizontal.append(temp_hor)\\n            vertical.append(temp_ver)\\n        count = 0\\n        new = horizontal + vertical\\n        for i in range(0,len(new)):\\n            if \\'Rp\\' in str(new[i]):\\n                count +=1\\n            if \\'pR\\' in str(new[i]):\\n                count +=1\\n        return(count)\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numRookCaptures(self, board):\\n        \\n        horizontal = []\\n        vertical = []\\n        for i in range(0,8):\\n            temp_hor = \\'\\'\\n            temp_ver = \\'\\'\\n            for j in range(0,8):\\n                if board[i][j] != \\'.\\':\\n                    temp_hor = temp_hor + board[i][j]\\n                if board[j][i] != \\'.\\':\\n                    temp_ver = temp_ver + board[j][i]\\n            horizontal.append(temp_hor)\\n            vertical.append(temp_ver)\\n        count = 0\\n        new = horizontal + vertical\\n        for i in range(0,len(new)):\\n            if \\'Rp\\' in str(new[i]):\\n                count +=1\\n            if \\'pR\\' in str(new[i]):\\n                count +=1\\n        return(count)\\n",
                "codeTag": "Java"
            },
            {
                "id": 243241,
                "title": "detailed-explanation",
                "content": "* Define an instance variable of the class as `captureCount` to store the count of pawns captured.\\n* Create a utility function `should_break` with input parameters as the board, and a particular cell. \\n* If the cell is a bishop, return `true` indicating that you should end your search due to blockage.\\n* If the cell is an empty space, return `false` indictaing that you should not break and keep searching.\\n* If the cell contains a pawn, capture it and update the `captureCount` by 1. Also, return `true` indicating that you cannot go further, as you are allowed only one move.\\n\\n1) Search the board for the position of the rook, and store it as `row_index`, `col_index`.\\n2) Go in all the cardinal direction starting from the position of the rook and see if you should break or not by calling the function `should_break`\\n3) The capture counts would automatically be updated by the function call.\\n4) In 2 of the cardinal directions, `row_index` would remain the same, while in the other 2, `col_index` would remain the same.\\n5) Handle out of bound access by properly defining the terminating codnitions of the for loop,\\n\\n\\n```\\nclass Solution\\n{\\nprivate:\\n    int ROW = 8;\\n    int COL = 8;\\n    int captureCount = 0;\\npublic:\\n    bool should_break(vector<vector<char>>& board, int i, int j);\\n    int numRookCaptures(vector<vector<char>>& board);\\n};\\n\\n/* Function to update the pawns captured and to inform whether to go looking forward or not */\\nbool Solution :: should_break(vector<vector<char>>& board, int i, int j)\\n{\\n    // If the space is empty, keep going, no need to break\\n    if(board[i][j]==\\'.\\') return false;\\n    \\n    // If the piece is a bishop, no capture can happen further, just break\\n    if(board[i][j]==\\'B\\') return true;\\n    \\n    // If the piece is a pawn, capture it and then break\\n    if(board[i][j]==\\'p\\') captureCount++;\\n    \\n    return true;\\n}\\n\\n/* Returns the number of pawn captures possible */\\nint Solution :: numRookCaptures(vector<vector<char>>& board)\\n{\\n    // Variables to store the location of Rook\\n    int row_index;\\n    int col_index;\\n    \\n    // Traverse the board, locating the Rook\\n    for(int i=0; i<ROW; i++)\\n        for(int j=0; j<COL; j++)\\n            if(board[i][j] == \\'R\\')\\n            {\\n                row_index = i;\\n                col_index = j;\\n                break;\\n\\t\\t\\t}\\n\\n    /* Now we know the location of the Rook */\\n    \\n    int i,j;\\n    \\n    // Move in the up direction and capture the pawns. [In the same column]\\n    j = col_index;\\n    for(int i=row_index-1; i>=0; i--)\\n        if(should_break(board,i,j)) break;\\n    \\n    // Move in the down direction [In the same column]\\n    j = col_index;\\n    for(int i=row_index+1; i<ROW; i++)\\n        if(should_break(board,i,j)) break;\\n    \\n    // Move in the left direction [in the same row]\\n    i = row_index;\\n    for(int j=col_index-1; j>=0; j--)\\n        if(should_break(board,i,j)) break;\\n    \\n    // Move in the right direction [in the same row]\\n    i = row_index;\\n    for(int j=col_index+1; j<COL; j++)\\n       if(should_break(board,i,j)) break;\\n    \\n    // Return the max number of pawns captured\\n    return captureCount;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n    int ROW = 8;\\n    int COL = 8;\\n    int captureCount = 0;\\npublic:\\n    bool should_break(vector<vector<char>>& board, int i, int j);\\n    int numRookCaptures(vector<vector<char>>& board);\\n};\\n\\n/* Function to update the pawns captured and to inform whether to go looking forward or not */\\nbool Solution :: should_break(vector<vector<char>>& board, int i, int j)\\n{\\n    // If the space is empty, keep going, no need to break\\n    if(board[i][j]==\\'.\\') return false;\\n    \\n    // If the piece is a bishop, no capture can happen further, just break\\n    if(board[i][j]==\\'B\\') return true;\\n    \\n    // If the piece is a pawn, capture it and then break\\n    if(board[i][j]==\\'p\\') captureCount++;\\n    \\n    return true;\\n}\\n\\n/* Returns the number of pawn captures possible */\\nint Solution :: numRookCaptures(vector<vector<char>>& board)\\n{\\n    // Variables to store the location of Rook\\n    int row_index;\\n    int col_index;\\n    \\n    // Traverse the board, locating the Rook\\n    for(int i=0; i<ROW; i++)\\n        for(int j=0; j<COL; j++)\\n            if(board[i][j] == \\'R\\')\\n            {\\n                row_index = i;\\n                col_index = j;\\n                break;\\n\\t\\t\\t}\\n\\n    /* Now we know the location of the Rook */\\n    \\n    int i,j;\\n    \\n    // Move in the up direction and capture the pawns. [In the same column]\\n    j = col_index;\\n    for(int i=row_index-1; i>=0; i--)\\n        if(should_break(board,i,j)) break;\\n    \\n    // Move in the down direction [In the same column]\\n    j = col_index;\\n    for(int i=row_index+1; i<ROW; i++)\\n        if(should_break(board,i,j)) break;\\n    \\n    // Move in the left direction [in the same row]\\n    i = row_index;\\n    for(int j=col_index-1; j>=0; j--)\\n        if(should_break(board,i,j)) break;\\n    \\n    // Move in the right direction [in the same row]\\n    i = row_index;\\n    for(int j=col_index+1; j<COL; j++)\\n       if(should_break(board,i,j)) break;\\n    \\n    // Return the max number of pawns captured\\n    return captureCount;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449570,
                "title": "perfect-solution-with-java-beat-100-70",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n        int m = 0;\\n        int n = 0;\\n        for(int a = 0; a < board.length; a++){\\n            char[] array = board[a];\\n            for(int b = 0; b < array.length; b++){\\n                if(array[b] == \\'R\\'){\\n                    m = a;\\n                    n = b;\\n                    break;\\n                }\\n            }\\n        }\\n        int d1 = m;\\n        while(d1<7){\\n            d1++;\\n            if(board[d1][n] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[d1][n] == \\'B\\') break;\\n        }\\n        \\n        d1 = m;\\n        while(d1>0){\\n            d1--;\\n            if(board[d1][n] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[d1][n] == \\'B\\') break;\\n        }\\n        \\n        d1 = n;\\n        while(d1<7){\\n            d1++;\\n            if(board[m][d1] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[m][d1] == \\'B\\') break;\\n        }\\n        \\n        d1 = n;\\n        while(d1>0){\\n            d1--;\\n            if(board[m][d1] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[m][d1] == \\'B\\') break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n        int m = 0;\\n        int n = 0;\\n        for(int a = 0; a < board.length; a++){\\n            char[] array = board[a];\\n            for(int b = 0; b < array.length; b++){\\n                if(array[b] == \\'R\\'){\\n                    m = a;\\n                    n = b;\\n                    break;\\n                }\\n            }\\n        }\\n        int d1 = m;\\n        while(d1<7){\\n            d1++;\\n            if(board[d1][n] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[d1][n] == \\'B\\') break;\\n        }\\n        \\n        d1 = m;\\n        while(d1>0){\\n            d1--;\\n            if(board[d1][n] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[d1][n] == \\'B\\') break;\\n        }\\n        \\n        d1 = n;\\n        while(d1<7){\\n            d1++;\\n            if(board[m][d1] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[m][d1] == \\'B\\') break;\\n        }\\n        \\n        d1 = n;\\n        while(d1>0){\\n            d1--;\\n            if(board[m][d1] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[m][d1] == \\'B\\') break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312040,
                "title": "beginner-friendly-approach-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int ans = 0, r = 0, c = 0;\\n        for (int i = 0; i < 8; i++) {\\n            for (int j = 0; j < 8; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    r = i;\\n                    c = j;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = r - 1; i >= 0; i--) {\\n            if (board[i][c] == \\'B\\') {\\n                break;\\n            }\\n            if (board[i][c] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        for (int i = r + 1; i < 8; i++) {\\n            if (board[i][c] == \\'B\\') {\\n                break;\\n            }\\n            if (board[i][c] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        for (int j = c - 1; j >= 0; j--) {\\n            if (board[r][j] == \\'B\\') {\\n                break;\\n            }\\n            if (board[r][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        for (int j = c + 1; j < 8; j++) {\\n            if (board[r][j] == \\'B\\') {\\n                break;\\n            }\\n            if (board[r][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int ans = 0, r = 0, c = 0;\\n        for (int i = 0; i < 8; i++) {\\n            for (int j = 0; j < 8; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    r = i;\\n                    c = j;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = r - 1; i >= 0; i--) {\\n            if (board[i][c] == \\'B\\') {\\n                break;\\n            }\\n            if (board[i][c] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        for (int i = r + 1; i < 8; i++) {\\n            if (board[i][c] == \\'B\\') {\\n                break;\\n            }\\n            if (board[i][c] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        for (int j = c - 1; j >= 0; j--) {\\n            if (board[r][j] == \\'B\\') {\\n                break;\\n            }\\n            if (board[r][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        for (int j = c + 1; j < 8; j++) {\\n            if (board[r][j] == \\'B\\') {\\n                break;\\n            }\\n            if (board[r][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610599,
                "title": "faster-than-98",
                "content": "```class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        co=0\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j]==\"R\":\\n                    left=j-1\\n                    while(left>-1):\\n                        if board[i][left]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[i][left]==\"B\":\\n                            break\\n                        else:\\n                            left-=1\\n                    right=j+1\\n                    while(right<8):\\n                   \\n                        if board[i][right]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[i][right]==\"B\":\\n                            break\\n                        else:\\n                            right+=1\\n                    top=i-1\\n                    while(top>-1):\\n                        if board[top][j]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[top][j]==\"B\":\\n                            break\\n                        else:\\n                            top-=1\\n                    bot=i+1\\n                    while(bot<8):\\n                        if board[bot][j]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[bot][j]==\"B\":\\n                            break\\n                        else:\\n                            bot+=1\\n                    return co\\n        return co",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        co=0\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j]==\"R\":\\n                    left=j-1\\n                    while(left>-1):\\n                        if board[i][left]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[i][left]==\"B\":\\n                            break\\n                        else:\\n                            left-=1\\n                    right=j+1\\n                    while(right<8):\\n                   \\n                        if board[i][right]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[i][right]==\"B\":\\n                            break\\n                        else:\\n                            right+=1\\n                    top=i-1\\n                    while(top>-1):\\n                        if board[top][j]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[top][j]==\"B\":\\n                            break\\n                        else:\\n                            top-=1\\n                    bot=i+1\\n                    while(bot<8):\\n                        if board[bot][j]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[bot][j]==\"B\":\\n                            break\\n                        else:\\n                            bot+=1\\n                    return co\\n        return co",
                "codeTag": "Java"
            },
            {
                "id": 2596440,
                "title": "java-beats-100-simple",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count=0;\\n        for(int i=0;i<board.length;i++)\\n            for(int j=0;j<board[0].length;j++)\\n                if(board[i][j]==\\'R\\'){\\n                    int d=j;\\n                    int u=j;\\n                    int l=i;\\n                    int r=i;\\n                    //down\\n                    while(++d<8){\\n                        if(board[i][d]==\\'p\\'){\\n                            count++;\\n                            break;\\n                        }else if(board[i][d]==\\'B\\'){\\n                            break;\\n                        }\\n                    }\\n                    //up\\n                     while(--u>=0){\\n                        if(board[i][u]==\\'p\\'){\\n                            count++;\\n                            break;\\n                        }else if(board[i][u]==\\'B\\'){\\n                            break;\\n                        }\\n                    }\\n                    //left\\n                      while(++l<8){\\n                        if(board[l][j]==\\'p\\'){\\n                            count++;\\n                            break;\\n                        }else if(board[l][j]==\\'B\\'){\\n                            break;\\n                        }\\n                    }\\n                    //right\\n                     while(--r>=0){\\n                        if(board[r][j]==\\'p\\'){\\n                            count++;\\n                            break;\\n                        }else if(board[r][j]==\\'B\\'){\\n                            break;\\n                        }\\n                    }\\n                    return count;\\n                    \\n                }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count=0;\\n        for(int i=0;i<board.length;i++)\\n            for(int j=0;j<board[0].length;j++)\\n                if(board[i][j]==\\'R\\'){\\n                    int d=j;\\n                    int u=j;\\n                    int l=i;\\n                    int r=i;\\n                    //down\\n                    while(++d<8){\\n                        if(board[i][d]==\\'p\\'){\\n                            count++;\\n                            break;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2581037,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int count(vector<vector<char>>& b,int i,int j,int dx,int dy)\\n    {\\n        while(i>=0&&j>=0&&i<8&&j<8&&b[i][j]!=\\'B\\')\\n        {\\n            if(b[i][j]==\\'p\\')  //small p in question\\n                return 1;\\n            i+=dx;\\n            j+=dy;\\n        }\\n        return 0;\\n    }\\n    int numRookCaptures(vector<vector<char>>& b)\\n    {\\n        for(int i=0;i<8;i++)\\n        {\\n            for(int j=0;j<8;j++)\\n            {\\n                if(b[i][j]==\\'R\\')\\n                {\\n                    return count(b,i,j,1,0)+count(b,i,j,0,1)+count(b,i,j,-1,0)+count(b,i,j,0,-1);\\n                }\\n            }\\n            \\n        }\\n        return 0;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int count(vector<vector<char>>& b,int i,int j,int dx,int dy)\\n    {\\n        while(i>=0&&j>=0&&i<8&&j<8&&b[i][j]!=\\'B\\')\\n        {\\n            if(b[i][j]==\\'p\\')  //small p in question\\n                return 1;\\n            i+=dx;\\n            j+=dy;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2538911,
                "title": "java-matrix-faster-than-100-java-submissions",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ii=0,jj=0;\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    ii=i;\\n                    jj=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int count=0;\\n        for(int i=ii;i>=0;i--){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int i=ii;i<8;i++){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j<8;j++){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j>=0;j--){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ii=0,jj=0;\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    ii=i;\\n                    jj=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int count=0;\\n        for(int i=ii;i>=0;i--){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int i=ii;i<8;i++){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j<8;j++){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j>=0;j--){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048569,
                "title": "c-100-faster-submission",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int rook_row , rook_col ;\\n        for (int i = 0 ; i < 8 ; i ++) {\\n            for (int j = 0 ; j < 8 ; j ++) {\\n                if (board[i][j] == \\'R\\') {\\n                    rook_row = i ;\\n                    rook_col = j ;\\n                    break ;\\n                }\\n            }\\n        }  int count = 0 ;\\n        if (rook_row != 0) {\\n            for (int i = rook_row - 1 ; i >= 0 ; i --) {\\n                if (board[i][rook_col] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[i][rook_col] == \\'p\\') {\\n                    count ++ ;\\n                    break ;\\n                }\\n            }\\n        }\\n        if (rook_row != 7) {\\n            for (int i = rook_row + 1 ; i < 8 ; i ++) {\\n                if (board[i][rook_col] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[i][rook_col] == \\'p\\') {\\n                    count += 1 ;\\n                    break ;\\n                }\\n            }\\n        }\\n        if (rook_col != 0) {\\n            for (int i = rook_col - 1 ; i >= 0 ; i --) {\\n                if (board[rook_row][i] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[rook_row][i] == \\'p\\') {\\n                    count ++ ;\\n                    break ;\\n                }\\n            }\\n        }\\n        if (rook_col != 7) {\\n            for (int i = rook_col + 1 ; i < 8 ; i ++) {\\n                if (board[rook_row][i] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[rook_row][i] == \\'p\\') {\\n                    count ++ ;\\n                    break ;\\n                }\\n            }\\n        } return count ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int rook_row , rook_col ;\\n        for (int i = 0 ; i < 8 ; i ++) {\\n            for (int j = 0 ; j < 8 ; j ++) {\\n                if (board[i][j] == \\'R\\') {\\n                    rook_row = i ;\\n                    rook_col = j ;\\n                    break ;\\n                }\\n            }\\n        }  int count = 0 ;\\n        if (rook_row != 0) {\\n            for (int i = rook_row - 1 ; i >= 0 ; i --) {\\n                if (board[i][rook_col] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[i][rook_col] == \\'p\\') {\\n                    count ++ ;\\n                    break ;\\n                }\\n            }\\n        }\\n        if (rook_row != 7) {\\n            for (int i = rook_row + 1 ; i < 8 ; i ++) {\\n                if (board[i][rook_col] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[i][rook_col] == \\'p\\') {\\n                    count += 1 ;\\n                    break ;\\n                }\\n            }\\n        }\\n        if (rook_col != 0) {\\n            for (int i = rook_col - 1 ; i >= 0 ; i --) {\\n                if (board[rook_row][i] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[rook_row][i] == \\'p\\') {\\n                    count ++ ;\\n                    break ;\\n                }\\n            }\\n        }\\n        if (rook_col != 7) {\\n            for (int i = rook_col + 1 ; i < 8 ; i ++) {\\n                if (board[rook_row][i] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[rook_row][i] == \\'p\\') {\\n                    count ++ ;\\n                    break ;\\n                }\\n            }\\n        } return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008271,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/9dea66f6-7e45-4d86-bcab-9133e216e22c_1651684472.9326024.png)\\n\\n\\n    def numRookCaptures(self, board):\\n        \"\"\" O(NM)TS \"\"\"\\n        ans = 0\\n\\n        for s in [*board, *zip(*board)]:\\n            row = \\'\\'.join(s).replace(\\'.\\', \\'\\')\\n            ans += row.count(\\'pR\\') + row.count(\\'Rp\\')\\n\\n        return ans\\n\\n    def numRookCaptures(self, board):\\n        \"\"\" O(NM)TS \"\"\"\\n        return sum(row.count(\\'pR\\') + row.count(\\'Rp\\') for s in [*board, *zip(*board)] if (row := \\'\\'.join(s).replace(\\'.\\', \\'\\')))\\n",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/9dea66f6-7e45-4d86-bcab-9133e216e22c_1651684472.9326024.png)\\n\\n\\n    def numRookCaptures(self, board):\\n        \"\"\" O(NM)TS \"\"\"\\n        ans = 0\\n\\n        for s in [*board, *zip(*board)]:\\n            row = \\'\\'.join(s).replace(\\'.\\', \\'\\')\\n            ans += row.count(\\'pR\\') + row.count(\\'Rp\\')\\n\\n        return ans\\n\\n    def numRookCaptures(self, board):\\n        \"\"\" O(NM)TS \"\"\"\\n        return sum(row.count(\\'pR\\') + row.count(\\'Rp\\') for s in [*board, *zip(*board)] if (row := \\'\\'.join(s).replace(\\'.\\', \\'\\')))\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1726705,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "PLEASE UPVOTE!\\n```\\nint count=0,r,c;\\n//finding the position of rook and storing the row in r and column in c\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    r=i;\\n                    c=j;\\n                }\\n            }\\n        }\\n\\t\\t//checking if there is any pawn on right of rook, if any bishop break the loop\\n        for(int k=c;k<8;k++){\\n            if(board[r][k]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[r][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\t\\t//checking if there is any pawn on left of rook, if any bishop break the loop\\n        for(int k=c;k>=0;k--){\\n            if(board[r][k]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[r][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\t\\t//checking if there is any pawn below the rook, if any bishop break the loop\\n        for(int k=r;k<8;k++){\\n            if(board[k][c]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[k][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\t\\t//checking if there is any pawn above the  rook, if any bishop break the loop\\n        for(int k=r;k>=0;k--){\\n            if(board[k][c]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[k][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return count;```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nint count=0,r,c;\\n//finding the position of rook and storing the row in r and column in c\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    r=i;\\n                    c=j;\\n                }\\n            }\\n        }\\n\\t\\t//checking if there is any pawn on right of rook, if any bishop break the loop\\n        for(int k=c;k<8;k++){\\n            if(board[r][k]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[r][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\t\\t//checking if there is any pawn on left of rook, if any bishop break the loop\\n        for(int k=c;k>=0;k--){\\n            if(board[r][k]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[r][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\t\\t//checking if there is any pawn below the rook, if any bishop break the loop\\n        for(int k=r;k<8;k++){\\n            if(board[k][c]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[k][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\t\\t//checking if there is any pawn above the  rook, if any bishop break the loop\\n        for(int k=r;k>=0;k--){\\n            if(board[k][c]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[k][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return count;```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588673,
                "title": "python-faster-than-99-dict-hash-map-solution",
                "content": "```\\nclass Solution:        \\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        rows = {}\\n        cols = {}\\n        for i, row in enumerate(board):\\n            for j, figure in enumerate(row):\\n                if figure != \\'.\\':\\n                    if j in cols:\\n                        cols[j] += figure\\n                    else:\\n                        cols[j] = figure\\n                    if i in rows:\\n                        rows[i] += figure\\n                    else:\\n                        rows[i] = figure\\n        attacked = 0\\n        for row in rows.values():\\n            if \\'pR\\' in row:\\n                attacked += 1\\n            if \\'Rp\\' in row:\\n                attacked += 1\\n        for col in cols.values():\\n            if \\'pR\\' in col:\\n                attacked += 1\\n            if \\'Rp\\' in col:\\n                attacked += 1\\n        return attacked\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:        \\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        rows = {}\\n        cols = {}\\n        for i, row in enumerate(board):\\n            for j, figure in enumerate(row):\\n                if figure != \\'.\\':\\n                    if j in cols:\\n                        cols[j] += figure\\n                    else:\\n                        cols[j] = figure\\n                    if i in rows:\\n                        rows[i] += figure\\n                    else:\\n                        rows[i] = figure\\n        attacked = 0\\n        for row in rows.values():\\n            if \\'pR\\' in row:\\n                attacked += 1\\n            if \\'Rp\\' in row:\\n                attacked += 1\\n        for col in cols.values():\\n            if \\'pR\\' in col:\\n                attacked += 1\\n            if \\'Rp\\' in col:\\n                attacked += 1\\n        return attacked\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190574,
                "title": "faster-than-100-of-solutions-runtime-0ms-with-comments-and-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int ri = 0;\\n        int rj = 0;\\n        \\n        //Finding the Bishops Coordinate\\n        for(int i=0;i<8;i++) {\\n            for(int j=0 ;j<8;j++) {\\n                if(board[i][j]  == \\'R\\') {\\n                   ri = i;\\n                   rj = j;\\n                    break;\\n                }\\n            }\\n        }\\n        int numPawns = 0; //Number of Pawns found so far..\\n        \\n        //Finding Pawns in Left Side\\n        for(int i = ri; i>=0; i--) {\\n            if(board[i][rj] == \\'B\\') break;\\n            if(board[i][rj] == \\'p\\') {numPawns++; break;}\\n        }   \\n        \\n        //Finding pawns in Right Side \\n        for(int i=rj; i<8;i++) {\\n          if(board[i][rj] == \\'B\\') break;\\n          if(board[i][rj] == \\'p\\') {numPawns++; break;}\\n        }\\n        \\n        //Finding Pawns in upward direction\\n        for(int j = rj; j>=0; j--) {\\n            if(board[ri][j] == \\'B\\') break;\\n            if(board[ri][j] == \\'p\\') {numPawns++; break;}\\n        }\\n        \\n        //Finding Pawns in downward direction\\n        for(int j=rj;j<8;j++) {\\n            if(board[ri][j] == \\'B\\') break;\\n            if(board[ri][j] == \\'p\\') {numPawns++; break;}\\n        }\\n        \\n        return numPawns;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int ri = 0;\\n        int rj = 0;\\n        \\n        //Finding the Bishops Coordinate\\n        for(int i=0;i<8;i++) {\\n            for(int j=0 ;j<8;j++) {\\n                if(board[i][j]  == \\'R\\') {\\n                   ri = i;\\n                   rj = j;\\n                    break;\\n                }\\n            }\\n        }\\n        int numPawns = 0; //Number of Pawns found so far..\\n        \\n        //Finding Pawns in Left Side\\n        for(int i = ri; i>=0; i--) {\\n            if(board[i][rj] == \\'B\\') break;\\n            if(board[i][rj] == \\'p\\') {numPawns++; break;}\\n        }   \\n        \\n        //Finding pawns in Right Side \\n        for(int i=rj; i<8;i++) {\\n          if(board[i][rj] == \\'B\\') break;\\n          if(board[i][rj] == \\'p\\') {numPawns++; break;}\\n        }\\n        \\n        //Finding Pawns in upward direction\\n        for(int j = rj; j>=0; j--) {\\n            if(board[ri][j] == \\'B\\') break;\\n            if(board[ri][j] == \\'p\\') {numPawns++; break;}\\n        }\\n        \\n        //Finding Pawns in downward direction\\n        for(int j=rj;j<8;j++) {\\n            if(board[ri][j] == \\'B\\') break;\\n            if(board[ri][j] == \\'p\\') {numPawns++; break;}\\n        }\\n        \\n        return numPawns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928246,
                "title": "java-solution-visualizing-steps-taken-by-rookie-hathi",
                "content": "class Solution {\\npublic int numRookCaptures(char[][] board) {\\n    \\n     /*  R-Hathi  :::-R-::: Rook\\n        B-Unth   :::-B-::: Bishops\\n        p-pyade   ::-p-::  pawns    */\\n    \\n    int i1=0,j1=0,count=0;\\n    for(int i=0;i<board.length;i++){        // finding position of Hathi\\n        for(int j=0;j<board[0].length;j++){\\n            if(board[i][j]==\\'R\\'){\\n                i1=i;j1=j;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    //Suppose H hanthi hai ::-Rookie-:: &&& A is blank space\\n\\n    //steps taken by hathi top to bottom \\n    for(int i=i1;i<board[0].length;i++){              //  Top to Bottom\\n        if(board[i][j1]==\\'B\\'){break;}   //  AAA\\n        else if(board[i][j1]==\\'p\\'){     //  AHA\\n            count++;board[i][j1]=\\'X\\';   //  AHA\\n            break;\\n        }\\n        board[i][j1]=\\'X\\';\\n    }\\n    \\n    //steps taken by hathi bottom to top\\n    for(int i=i1;i>=0;i--){               // Bottom to top\\n        if(board[i][j1]==\\'B\\'){break;}     // AHA\\n        else if(board[i][j1]==\\'p\\'){       // AHA\\n            count++;board[i][j1]=\\'X\\';     // AAA\\n            break;\\n        }\\n        board[i][j1]=\\'X\\';\\n    }\\n    \\n    //steps taken by hathi right to left\\n    for(int j=j1;j>=0;j--){               //Right to left\\n        if(board[i1][j]==\\'B\\'){break;}     // AAA\\n        else if(board[i1][j]==\\'p\\'){       // HHA\\n            count++;board[i1][j]=\\'X\\';     // AAA\\n            break;\\n        }\\n        board[i1][j]=\\'X\\';\\n    }\\n    \\n    //steps taken by hathi left to right\\n    for(int j=j1;j<board.length;j++){              //Left to right\\n        if(board[i1][j]==\\'B\\'){break;}     // AAA\\n        else if(board[i1][j]==\\'p\\'){       // AHH\\n            count++;board[i1][j]=\\'X\\';     // AAA\\n            break;\\n        }\\n        board[i1][j]=\\'X\\';\\n    } \\n    \\n    //printing path travel by hathi\\n    for(int i=0;i<board.length;i++){\\n        for(int j=0;j<board[0].length;j++){\\n            System.out.print(board[i][j]+\" \");\\n        }\\n        System.out.println();\\n    }\\n    return count;\\n  }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic int numRookCaptures(char[][] board) {\\n    \\n     /*  R-Hathi  :::-R-::: Rook\\n        B-Unth   :::-B-::: Bishops\\n        p-pyade   ::-p-::  pawns    */\\n    \\n    int i1=0,j1=0,count=0;\\n    for(int i=0;i<board.length;i++){        // finding position of Hathi\\n        for(int j=0;j<board[0].length;j++){\\n            if(board[i][j]==\\'R\\'){\\n                i1=i;j1=j;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 639509,
                "title": "c-solution",
                "content": "```\\nint numRookCaptures(char** board, int boardSize, int* boardColSize){\\nint rook_r, rook_f;\\nint i, j;\\nint pawn_counter = 0;\\n// Find out where the rook is\\nfor (i=0; i<boardSize; i++)\\n    for (j=0; j<*boardColSize; j++)\\n        if (board[i][j]==\\'R\\') { rook_r=i; rook_f=j; break; }\\n\\nfor (i=rook_r-1; i>=0; i--)\\n    if (board[i][rook_f]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[i][rook_f]==\\'B\\') break;\\n\\nfor (i=rook_r+1; i<boardSize; i++)\\n    if (board[i][rook_f]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[i][rook_f]==\\'B\\') break;\\n    \\nfor (i=rook_f-1; i>=0; i--)\\n    if (board[rook_r][i]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[rook_r][i]==\\'B\\') break;\\n\\nfor (i=rook_f+1; i<*boardColSize; i++)\\n    if (board[rook_r][i]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[rook_r][i]==\\'B\\') break;\\n    \\nreturn pawn_counter;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint numRookCaptures(char** board, int boardSize, int* boardColSize){\\nint rook_r, rook_f;\\nint i, j;\\nint pawn_counter = 0;\\n// Find out where the rook is\\nfor (i=0; i<boardSize; i++)\\n    for (j=0; j<*boardColSize; j++)\\n        if (board[i][j]==\\'R\\') { rook_r=i; rook_f=j; break; }\\n\\nfor (i=rook_r-1; i>=0; i--)\\n    if (board[i][rook_f]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[i][rook_f]==\\'B\\') break;\\n\\nfor (i=rook_r+1; i<boardSize; i++)\\n    if (board[i][rook_f]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[i][rook_f]==\\'B\\') break;\\n    \\nfor (i=rook_f-1; i>=0; i--)\\n    if (board[rook_r][i]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[rook_r][i]==\\'B\\') break;\\n\\nfor (i=rook_f+1; i<*boardColSize; i++)\\n    if (board[rook_r][i]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[rook_r][i]==\\'B\\') break;\\n    \\nreturn pawn_counter;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 602385,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nFind the `i`,`j` cell of the Rook.  Then step in each cardinal direction and increment the count `cnt` of black pawns found along the way.\\n\\n---\\n\\n*Javascript*\\n```\\nlet numRookCaptures = (A, i = -1, j = -1, cnt = 0) => {\\n    A.forEach((row, u) =>\\n        row.forEach((col, v) => {\\n            if (A[u][v] == \\'R\\')\\n                i = u,\\n                j = v;\\n    }));\\n    let ok = x => 0 <= x && x < 8;\\n    for (let d of [[-1, 0], [0, 1], [1, 0], [0, -1]]) { // clockwise directions [\\uD83D\\uDC46, \\uD83D\\uDC49, \\uD83D\\uDC47, \\uD83D\\uDC48]\\n        for (let u = i + d[0], v = j + d[1]; ok(u) && ok(v); u += d[0], v += d[1]) {\\n            if (A[u][v] == \\'p\\')\\n                ++cnt; // black pawn \\uD83C\\uDFAF\\n            if (A[u][v] != \\'.\\')\\n                break; // non-empty square\\n        }\\n    }   \\n    return cnt;\\n};\\n```\\n\\n---\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    int numRookCaptures(VVC& A, int i = -1, int j = -1, int cnt = 0) {\\n        for (auto u{ 0 }; u < 8; ++u)\\n            for (auto v{ 0 }; v < 8; ++v)\\n                if (A[u][v] == \\'R\\')\\n                    i = u, j = v;\\n        auto ok = [](auto x) { return 0 <= x && x < 8; };\\n        for (auto d: VVC{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}) { // // clockwise directions {\\uD83D\\uDC46, \\uD83D\\uDC49, \\uD83D\\uDC47, \\uD83D\\uDC48}\\n            for (auto u = i + d[0], v = j + d[1]; ok(u) && ok(v); u += d[0], v += d[1]) {\\n                if (A[u][v] == \\'p\\')\\n                    ++cnt; // black pawn \\uD83C\\uDFAF\\n                if (A[u][v] != \\'.\\')\\n                    break; // non-empty square\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet numRookCaptures = (A, i = -1, j = -1, cnt = 0) => {\\n    A.forEach((row, u) =>\\n        row.forEach((col, v) => {\\n            if (A[u][v] == \\'R\\')\\n                i = u,\\n                j = v;\\n    }));\\n    let ok = x => 0 <= x && x < 8;\\n    for (let d of [[-1, 0], [0, 1], [1, 0], [0, -1]]) { // clockwise directions [\\uD83D\\uDC46, \\uD83D\\uDC49, \\uD83D\\uDC47, \\uD83D\\uDC48]\\n        for (let u = i + d[0], v = j + d[1]; ok(u) && ok(v); u += d[0], v += d[1]) {\\n            if (A[u][v] == \\'p\\')\\n                ++cnt; // black pawn \\uD83C\\uDFAF\\n            if (A[u][v] != \\'.\\')\\n                break; // non-empty square\\n        }\\n    }   \\n    return cnt;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    int numRookCaptures(VVC& A, int i = -1, int j = -1, int cnt = 0) {\\n        for (auto u{ 0 }; u < 8; ++u)\\n            for (auto v{ 0 }; v < 8; ++v)\\n                if (A[u][v] == \\'R\\')\\n                    i = u, j = v;\\n        auto ok = [](auto x) { return 0 <= x && x < 8; };\\n        for (auto d: VVC{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}) { // // clockwise directions {\\uD83D\\uDC46, \\uD83D\\uDC49, \\uD83D\\uDC47, \\uD83D\\uDC48}\\n            for (auto u = i + d[0], v = j + d[1]; ok(u) && ok(v); u += d[0], v += d[1]) {\\n                if (A[u][v] == \\'p\\')\\n                    ++cnt; // black pawn \\uD83C\\uDFAF\\n                if (A[u][v] != \\'.\\')\\n                    break; // non-empty square\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551546,
                "title": "python-95-7-lines-with-detailed-explanation-very-easy-to-follow",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n\\t\\n        rR,rC,sC,sR = 0,0,\\'\\',\\'\\'     \\n\\t\\t\\n        while \\'R\\' not in board[rR]:\\n            rR += 1\\n        rC = board[rR].index(\\'R\\')\\n\\t\\t\\n        sR=\\'\\'.join(board[rR]).replace(\\'.\\',\\'\\')\\n        sC=\\'\\'.join([board[i][rC] for i in range(8)]).replace(\\'.\\',\\'\\')\\n\\t\\t\\n        return  sR.count(\\'pR\\') + sR.count(\\'Rp\\') + sC.count(\\'pR\\') + sC.count(\\'Rp\\')\\n```\\n\\n\\nok, let\\'s start ... First, we want to find the location of the rook (`rR` - rook\\'s row, `rC` - rook\\'s column). Since we know it\\'s there, we can use a while loop  like below:\\n\\n```\\n        while \\'R\\' not in board[rR]:\\n            rR += 1\\n        rC = board[rR].index(\\'R\\')\\n```\\n\\nWe start at 0,0 and check row by row if it\\'s there and once we see it, we set rC to the rook\\'s index.\\n\\nOk, now we know where rook is. The next step is to find the row and the column where rook is and convert them into strings `sR`,`sC`. There is one catch - we want to remove all \\'.\\' s. You\\'ll find out why in a moment. Also, the 8 below is because chess board is 8x8.\\n\\n```\\n        sR=\\'\\'.join(board[rR]).replace(\\'.\\',\\'\\')\\n        sC=\\'\\'.join([board[i][rC] for i in range(8)]).replace(\\'.\\',\\'\\')\\n```\\n\\nOk, so now things are really simple. Rook can take a pawn only if they are next to each other (now it makes sense why we removed \\'.\\' s?), so we need to look for either `Rp`, `pR` or `pRp`. The first two will give 1 point and the last one is worth 2 points. Conviniently, if we have \\'pRp\\' - we\\'ll find one \\'Rp\\' and  one \\'pR\\', so we just need to look for those 2 substrings and return the total count:\\n\\n```\\n        return  sR.count(\\'pR\\') + sR.count(\\'Rp\\') + sC.count(\\'pR\\') + sC.count(\\'Rp\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n\\t\\n        rR,rC,sC,sR = 0,0,\\'\\',\\'\\'     \\n\\t\\t\\n        while \\'R\\' not in board[rR]:\\n            rR += 1\\n        rC = board[rR].index(\\'R\\')\\n\\t\\t\\n        sR=\\'\\'.join(board[rR]).replace(\\'.\\',\\'\\')\\n        sC=\\'\\'.join([board[i][rC] for i in range(8)]).replace(\\'.\\',\\'\\')\\n\\t\\t\\n        return  sR.count(\\'pR\\') + sR.count(\\'Rp\\') + sC.count(\\'pR\\') + sC.count(\\'Rp\\')\\n```\n```\\n        while \\'R\\' not in board[rR]:\\n            rR += 1\\n        rC = board[rR].index(\\'R\\')\\n```\n```\\n        sR=\\'\\'.join(board[rR]).replace(\\'.\\',\\'\\')\\n        sC=\\'\\'.join([board[i][rC] for i in range(8)]).replace(\\'.\\',\\'\\')\\n```\n```\\n        return  sR.count(\\'pR\\') + sR.count(\\'Rp\\') + sC.count(\\'pR\\') + sC.count(\\'Rp\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451494,
                "title": "java-seeking-constructive-feedback",
                "content": "I\\'m looking for constructive feedback on this code. I feel that the code is very readable but it is undeniably longer than other solutions in terms of lines of code. This has a 1 ms runtime and beats only 7.45% of solutions in runtime and 100.00% of solutions in memory usage (34 MB).\\n```\\nimport java.util.*;\\nclass Solution {\\n    static char ROOK = \\'R\\';\\n    static char BISHOP = \\'B\\';\\n    static char PAWN = \\'p\\';\\n    static Map.Entry<Integer, Integer> ERROR_CODE = new AbstractMap.SimpleImmutableEntry<>(-1, -1);\\n    \\n    char[][] board;\\n    Map.Entry<Integer, Integer> rookPosition;\\n    \\n    enum MoveType {\\n        RANK,\\n        FILE;\\n    }\\n    \\n    enum MoveDirection {\\n        TOWARD_A1,\\n        AWAY_FROM_A1;\\n    }\\n    \\n    public int numRookCaptures(char[][] board) {\\n        this.board = board;\\n        this.rookPosition = getRookPosition();\\n        int numRookCaptures = 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.RANK, MoveDirection.TOWARD_A1) ? 1 : 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.RANK, MoveDirection.AWAY_FROM_A1) ? 1 : 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.FILE, MoveDirection.TOWARD_A1) ? 1 : 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.FILE, MoveDirection.AWAY_FROM_A1) ? 1 : 0;\\n        return numRookCaptures;\\n    }\\n    \\n    private boolean isValidPosition(Map.Entry<Integer, Integer> position) {\\n        return inRange(position.getKey()) && inRange(position.getValue());\\n    }\\n    \\n    private boolean inRange(int coordinate) {\\n        return coordinate >= 0 && coordinate <= 7;\\n    }\\n    \\n    private boolean isCapturableByTypeAndDirection(MoveType type, MoveDirection direction) {\\n        if (rookPosition != null) {\\n            Map.Entry<Integer, Integer> unitVector = getUnitVectorByTypeAndDirection(type, direction);\\n            Map.Entry<Integer, Integer> tempRookPosition = getVectorSum(rookPosition, unitVector);\\n            while (isValidPosition(tempRookPosition) && \\n                   getPieceByPosition(tempRookPosition) != BISHOP && \\n                   getPieceByPosition(tempRookPosition) != PAWN) {\\n                tempRookPosition = getVectorSum(tempRookPosition, unitVector);\\n            }\\n            return isValidPosition(tempRookPosition) && getPieceByPosition(tempRookPosition) == PAWN;\\n        }\\n        // No capture available\\n        return false;\\n    }\\n    \\n    private char getPieceByPosition(Map.Entry<Integer, Integer> position) {\\n        return board[position.getKey()][position.getValue()];\\n    }\\n    \\n    private Map.Entry<Integer, Integer> getVectorSum(Map.Entry<Integer, Integer> v, Map.Entry<Integer, Integer> w) {\\n        return new AbstractMap.SimpleImmutableEntry<>(v.getKey() + w.getKey(), v.getValue() + w.getValue());\\n    }\\n    \\n    private Map.Entry<Integer, Integer> getUnitVectorByTypeAndDirection(MoveType type, MoveDirection direction) {\\n        if (rookPosition != null) {\\n            if (type == MoveType.RANK) {\\n                if (direction == MoveDirection.TOWARD_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(0, -1);\\n                } else if (direction == MoveDirection.AWAY_FROM_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(0, 1);\\n                }\\n            } else if (type == MoveType.FILE) {\\n                if (direction == MoveDirection.TOWARD_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(-1, 0);\\n                } else if (direction == MoveDirection.AWAY_FROM_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(1, 0);\\n                }\\n            }\\n        }\\n        // Error code because we have exhausted all combinations of type and direction\\n        return ERROR_CODE;\\n    }\\n    \\n    private Map.Entry<Integer, Integer> getRookPosition() {\\n        int rankIndex = 0;\\n        for (char[] rank : board) {\\n            int fileIndex = 0;\\n            for (char square : rank) {\\n                if (square == ROOK) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(rankIndex, fileIndex);\\n                }\\n                fileIndex++;\\n            }\\n            rankIndex++;\\n        }\\n        // Error code because a valid board will have exactly one rook\\n        return ERROR_CODE;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    static char ROOK = \\'R\\';\\n    static char BISHOP = \\'B\\';\\n    static char PAWN = \\'p\\';\\n    static Map.Entry<Integer, Integer> ERROR_CODE = new AbstractMap.SimpleImmutableEntry<>(-1, -1);\\n    \\n    char[][] board;\\n    Map.Entry<Integer, Integer> rookPosition;\\n    \\n    enum MoveType {\\n        RANK,\\n        FILE;\\n    }\\n    \\n    enum MoveDirection {\\n        TOWARD_A1,\\n        AWAY_FROM_A1;\\n    }\\n    \\n    public int numRookCaptures(char[][] board) {\\n        this.board = board;\\n        this.rookPosition = getRookPosition();\\n        int numRookCaptures = 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.RANK, MoveDirection.TOWARD_A1) ? 1 : 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.RANK, MoveDirection.AWAY_FROM_A1) ? 1 : 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.FILE, MoveDirection.TOWARD_A1) ? 1 : 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.FILE, MoveDirection.AWAY_FROM_A1) ? 1 : 0;\\n        return numRookCaptures;\\n    }\\n    \\n    private boolean isValidPosition(Map.Entry<Integer, Integer> position) {\\n        return inRange(position.getKey()) && inRange(position.getValue());\\n    }\\n    \\n    private boolean inRange(int coordinate) {\\n        return coordinate >= 0 && coordinate <= 7;\\n    }\\n    \\n    private boolean isCapturableByTypeAndDirection(MoveType type, MoveDirection direction) {\\n        if (rookPosition != null) {\\n            Map.Entry<Integer, Integer> unitVector = getUnitVectorByTypeAndDirection(type, direction);\\n            Map.Entry<Integer, Integer> tempRookPosition = getVectorSum(rookPosition, unitVector);\\n            while (isValidPosition(tempRookPosition) && \\n                   getPieceByPosition(tempRookPosition) != BISHOP && \\n                   getPieceByPosition(tempRookPosition) != PAWN) {\\n                tempRookPosition = getVectorSum(tempRookPosition, unitVector);\\n            }\\n            return isValidPosition(tempRookPosition) && getPieceByPosition(tempRookPosition) == PAWN;\\n        }\\n        // No capture available\\n        return false;\\n    }\\n    \\n    private char getPieceByPosition(Map.Entry<Integer, Integer> position) {\\n        return board[position.getKey()][position.getValue()];\\n    }\\n    \\n    private Map.Entry<Integer, Integer> getVectorSum(Map.Entry<Integer, Integer> v, Map.Entry<Integer, Integer> w) {\\n        return new AbstractMap.SimpleImmutableEntry<>(v.getKey() + w.getKey(), v.getValue() + w.getValue());\\n    }\\n    \\n    private Map.Entry<Integer, Integer> getUnitVectorByTypeAndDirection(MoveType type, MoveDirection direction) {\\n        if (rookPosition != null) {\\n            if (type == MoveType.RANK) {\\n                if (direction == MoveDirection.TOWARD_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(0, -1);\\n                } else if (direction == MoveDirection.AWAY_FROM_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(0, 1);\\n                }\\n            } else if (type == MoveType.FILE) {\\n                if (direction == MoveDirection.TOWARD_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(-1, 0);\\n                } else if (direction == MoveDirection.AWAY_FROM_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(1, 0);\\n                }\\n            }\\n        }\\n        // Error code because we have exhausted all combinations of type and direction\\n        return ERROR_CODE;\\n    }\\n    \\n    private Map.Entry<Integer, Integer> getRookPosition() {\\n        int rankIndex = 0;\\n        for (char[] rank : board) {\\n            int fileIndex = 0;\\n            for (char square : rank) {\\n                if (square == ROOK) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(rankIndex, fileIndex);\\n                }\\n                fileIndex++;\\n            }\\n            rankIndex++;\\n        }\\n        // Error code because a valid board will have exactly one rook\\n        return ERROR_CODE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356483,
                "title": "no-brainer-simple-java-solution",
                "content": "```\\npublic int numRookCaptures(char[][] board) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    return find(board, i, j , 0, 1) +\\n                        find(board, i, j, 1, 0) +\\n                        find(board, i, j, 0, -1) +\\n                        find(board, i, j, -1, 0);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public int find(char[][] board, int r, int c, int dx, int dy) {\\n        r = r + dx;\\n        c = c + dy;\\n        while (isValid(board, r, c)) {\\n            if (board[r][c] == \\'p\\') return 1;\\n            r = r + dx;\\n            c = c + dy;\\n        }\\n        return 0;\\n    }\\n    \\n    public boolean isValid(char[][] board, int r, int c) {\\n        return r >= 0 && r < board.length && c >= 0 && c < board[0].length && board[r][c] != \\'B\\';   \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int numRookCaptures(char[][] board) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    return find(board, i, j , 0, 1) +\\n                        find(board, i, j, 1, 0) +\\n                        find(board, i, j, 0, -1) +\\n                        find(board, i, j, -1, 0);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public int find(char[][] board, int r, int c, int dx, int dy) {\\n        r = r + dx;\\n        c = c + dy;\\n        while (isValid(board, r, c)) {\\n            if (board[r][c] == \\'p\\') return 1;\\n            r = r + dx;\\n            c = c + dy;\\n        }\\n        return 0;\\n    }\\n    \\n    public boolean isValid(char[][] board, int r, int c) {\\n        return r >= 0 && r < board.length && c >= 0 && c < board[0].length && board[r][c] != \\'B\\';   \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 339088,
                "title": "ruby-100-100-easy-to-understand",
                "content": "```\\ndef num_rook_captures(board)\\n  @captures = 0\\n    \\n  board.length.times do |i|\\n    board[0].length.times do |j|\\n      if board[i][j] == \\'R\\'  \\n        calculate_captures(\\'up\\', board, i - 1, j)   \\n        calculate_captures(\\'down\\', board, i + 1, j)\\n        calculate_captures(\\'left\\', board, i, j - 1)\\n        calculate_captures(\\'right\\', board, i, j + 1) \\n      end\\n    end\\n  end\\n    \\n  @captures\\nend\\n\\ndef calculate_captures(type, board, i, j)\\n  if i >= 0 && i < board.length && j >= 0 && j < board[0].length\\n    coordinates = case type\\n                  when \\'up\\'\\n                    [ i - 1, j ]\\n                  when \\'down\\'\\n                    [ i + 1, j ]\\n                  when \\'left\\'\\n                    [ i, j - 1 ]\\n                  when \\'right\\'\\n                    [ i, j + 1 ]\\n                  end  \\n         \\n    if board[i][j] == \\'p\\'\\n      @captures += 1\\n      return\\n    elsif board[i][j] == \\'B\\'\\n      return\\n    else\\n      calculate_captures(type, board, *coordinates)\\n    end\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef num_rook_captures(board)\\n  @captures = 0\\n    \\n  board.length.times do |i|\\n    board[0].length.times do |j|\\n      if board[i][j] == \\'R\\'  \\n        calculate_captures(\\'up\\', board, i - 1, j)   \\n        calculate_captures(\\'down\\', board, i + 1, j)\\n        calculate_captures(\\'left\\', board, i, j - 1)\\n        calculate_captures(\\'right\\', board, i, j + 1) \\n      end\\n    end\\n  end\\n    \\n  @captures\\nend\\n\\ndef calculate_captures(type, board, i, j)\\n  if i >= 0 && i < board.length && j >= 0 && j < board[0].length\\n    coordinates = case type\\n                  when \\'up\\'\\n                    [ i - 1, j ]\\n                  when \\'down\\'\\n                    [ i + 1, j ]\\n                  when \\'left\\'\\n                    [ i, j - 1 ]\\n                  when \\'right\\'\\n                    [ i, j + 1 ]\\n                  end  \\n         \\n    if board[i][j] == \\'p\\'\\n      @captures += 1\\n      return\\n    elsif board[i][j] == \\'B\\'\\n      return\\n    else\\n      calculate_captures(type, board, *coordinates)\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 247405,
                "title": "in-search-of-an-elegant-rust-solution",
                "content": "This is an exercise in trying to get an elegant solution.\\n\\nLet\\'s start with a generic Rust solution that is easy to read but is a little repetitive:\\n\\n```\\nimpl Solution {\\n    pub fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        for x in (rook_x+1)..board[rook_y].len() {\\n            match board[rook_y][x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        for x in (0..rook_x).rev() {\\n            match board[rook_y][x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        for y in (rook_y+1)..board.len() {\\n            match board[y][rook_x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        for y in (0..rook_y).rev() {\\n            match board[y][rook_x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        count\\n    }\\n}\\n```\\n\\nIt\\'s easy to follow and about as fast as you are going to get (0ms runtime, 2.3MB memory).\\n\\nBut the match clauses are repetitive and it\\'s easy to make a mistake on the loop bounds, so can we hide the iterators behind a nice and reusable interface and simply provide a function that handles the match?\\n\\nLet\\'s try to do the second part first, i.e. move the match to a function called `rules`:\\n\\n```\\n\\nimpl Solution {\\n    pub fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    pub fn rules(piece: char, count: &mut i32) -> bool {\\n        match piece {\\n            \\'p\\' => {*count += 1; true},\\n            \\'B\\' => true,\\n            _   => false\\n        }\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        for x in (rook_x+1)..board[rook_y].len() {\\n            let piece = board[rook_y][x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        for x in (0..rook_x).rev() {\\n            let piece = board[rook_y][x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        for y in (rook_y+1)..board.len() {\\n            let piece = board[y][rook_x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        for y in (0..rook_y).rev() {\\n            let piece = board[y][rook_x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        count\\n    }\\n}\\n```\\n\\nWe got a whole savings of 1 line (new function is 7 lines and we save 2 lines per direction when we use it)! And the memory usage went from 2.3MB to 2.4MB. Overall not so great, but arguably a step in the right direction.\\n\\nNow an attempt to remove the `for` loop by relying on iterators more:\\n\\n```\\nimpl Solution {\\n    pub fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    pub fn rules(piece: char) -> i32 {\\n        if piece == \\'p\\' {1} else {0}\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        \\n        count +=\\n            ((rook_x+1)..board[rook_y].len())\\n                .map(|x| board[rook_y][x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        count +=\\n            (0..rook_x).rev()\\n                .map(|x| board[rook_y][x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        \\n        count +=\\n            ((rook_y+1)..board.len())\\n                .map(|y| board[y][rook_x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        count +=\\n            (0..rook_y).rev()\\n                .map(|y| board[y][rook_x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        count\\n    }\\n}\\n```\\n\\nIt\\u2019s definitely messier looking and not any shorter. But since the last two lines repeat we can role those into the `rules` function:\\n\\n```\\nimpl Solution {\\n    fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    fn rules<\\'a, I>(iter: I) -> i32\\n        where I: Iterator<Item = char>\\n    {\\n        iter.skip_while(|piece| *piece == \\'.\\')\\n            .next()\\n            .map_or(0, |piece| if piece == \\'p\\' {1} else {0})\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        \\n        count += Self::rules((\\n            (rook_x+1)..board[rook_y].len())\\n                .map(|x| board[rook_y][x]));\\n        \\n        count += Self::rules(\\n            (0..rook_x).rev()\\n                .map(|x| board[rook_y][x]));\\n        \\n        count += Self::rules(\\n            ((rook_y+1)..board.len())\\n                .map(|y| board[y][rook_x]));\\n        \\n        count += Self::rules(\\n            (0..rook_y).rev()\\n                .map(|y| board[y][rook_x]));\\n        \\n        count\\n    }\\n}\\n```\\n\\nI think this is okay-ish, maybe a little \\u201Cbetter\\u201D than the second version but maybe not. It\\u2019s still too fiddly. The initial range index is simple enough but the `map` after contains too many symbols and variables that it\\u2019s easy to get wrong if you don\\u2019t have a full test suite.\\n\\nIdeally I would like to be able to do something like:\\n\\n```\\ndirections = vec![\\n\\tboard.up_from(rook_x),\\n\\tboard.down_from(rook_x),\\n\\tboard.left_from(rook_y),\\n\\tboard.right_from(rook_y)\\n];\\ndirections.iter().map(|dir| Self::rules(dir)).sum()\\n```\\n\\nBy using traits to impl the new methods on `Vec<Vec<T>>`.\\n\\nAfter entirely too much effort I arrived at the below:\\n\\n```\\ntype BoxIter<\\'a, T> = Box<dyn Iterator<Item=&\\'a T> + \\'a>;\\n\\ntrait Board {\\n    type T;\\n    fn right_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n    fn left_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n    fn up_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n    fn down_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n}\\n\\nimpl<D> Board for Vec<Vec<D>>\\nwhere D: std::fmt::Debug\\n{\\n    type T = D;\\n    fn right_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[y][x+1..].iter()\\n        )\\n    }\\n    fn left_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[y][..x].iter().rev()\\n        )\\n    }\\n    fn up_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[..y].iter()\\n                .map(move |row| &row[x])\\n                .rev()\\n        )\\n    }\\n    fn down_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[y+1..].iter()\\n                .map(move |row| &row[x])\\n        )\\n    }\\n}\\n\\nimpl Solution {\\n    fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    fn rules<\\'a, I>(iter: &mut I) -> i32\\n        where I: Iterator<Item = &\\'a char>\\n    {\\n        iter.skip_while(|piece| **piece == \\'.\\')\\n            .next()\\n            .map_or(0, |piece| if *piece == \\'p\\' {1} else {0})\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        [\\n            board.up_from(rook_x, rook_y),\\n            board.down_from(rook_x, rook_y),\\n            board.left_from(rook_x, rook_y),\\n            board.right_from(rook_x, rook_y),\\n        ].iter_mut().map(|mut iter| Self::rules(iter)).sum()\\n    }\\n}\\n```\\n\\nThe issues with this (outside of it being really long and borderline monstrous looking) is that we are boxing the iterators which is causing unnecessary allocations. Ideally we would be able to use `impl Iterator` as the return type but for some reason it seems returning an impl Trait is not allowed from a trait.\\n\\nHowever, seeing how nice slices are and given we are not trying to build a library we can get rid of the trait and just do the following as our last solution:\\n\\n```\\nimpl Solution {\\n    fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    fn rules<\\'a, I>(direction: I) -> i32\\n        where I: IntoIterator<Item = &\\'a char>\\n    {\\n        direction.into_iter().skip_while(|piece| **piece == \\'.\\')\\n            .next()\\n            .map_or(0, |piece| if *piece == \\'p\\' {1} else {0})\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (x, y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        count +=  Self::rules(board[y][x+1..].iter());  // east\\n        count +=  Self::rules((board[y][..x].iter().rev())); // west\\n        count +=  Self::rules(board[..y].iter().map(move |row| &row[x]).rev()); // north\\n        count +=  Self::rules(board[y+1..].iter().map(move |row| &row[x]));  // south\\n        count\\n    }\\n}\\n```\\n\\nAs this is already entirely too much time spent trying to find an elegant solution for a rather simple problem I\\u2019ll stop here, though I wonder if it\\u2019s possible to go further. I tried storing the four iterators into an array and mapping `Self::rules` over them but the iterator types mismatched :-/ .\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        for x in (rook_x+1)..board[rook_y].len() {\\n            match board[rook_y][x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        for x in (0..rook_x).rev() {\\n            match board[rook_y][x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        for y in (rook_y+1)..board.len() {\\n            match board[y][rook_x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        for y in (0..rook_y).rev() {\\n            match board[y][rook_x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        count\\n    }\\n}\\n```\n```\\n\\nimpl Solution {\\n    pub fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    pub fn rules(piece: char, count: &mut i32) -> bool {\\n        match piece {\\n            \\'p\\' => {*count += 1; true},\\n            \\'B\\' => true,\\n            _   => false\\n        }\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        for x in (rook_x+1)..board[rook_y].len() {\\n            let piece = board[rook_y][x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        for x in (0..rook_x).rev() {\\n            let piece = board[rook_y][x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        for y in (rook_y+1)..board.len() {\\n            let piece = board[y][rook_x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        for y in (0..rook_y).rev() {\\n            let piece = board[y][rook_x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        count\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    pub fn rules(piece: char) -> i32 {\\n        if piece == \\'p\\' {1} else {0}\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        \\n        count +=\\n            ((rook_x+1)..board[rook_y].len())\\n                .map(|x| board[rook_y][x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        count +=\\n            (0..rook_x).rev()\\n                .map(|x| board[rook_y][x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        \\n        count +=\\n            ((rook_y+1)..board.len())\\n                .map(|y| board[y][rook_x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        count +=\\n            (0..rook_y).rev()\\n                .map(|y| board[y][rook_x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        count\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    fn rules<\\'a, I>(iter: I) -> i32\\n        where I: Iterator<Item = char>\\n    {\\n        iter.skip_while(|piece| *piece == \\'.\\')\\n            .next()\\n            .map_or(0, |piece| if piece == \\'p\\' {1} else {0})\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        \\n        count += Self::rules((\\n            (rook_x+1)..board[rook_y].len())\\n                .map(|x| board[rook_y][x]));\\n        \\n        count += Self::rules(\\n            (0..rook_x).rev()\\n                .map(|x| board[rook_y][x]));\\n        \\n        count += Self::rules(\\n            ((rook_y+1)..board.len())\\n                .map(|y| board[y][rook_x]));\\n        \\n        count += Self::rules(\\n            (0..rook_y).rev()\\n                .map(|y| board[y][rook_x]));\\n        \\n        count\\n    }\\n}\\n```\n```\\ndirections = vec![\\n\\tboard.up_from(rook_x),\\n\\tboard.down_from(rook_x),\\n\\tboard.left_from(rook_y),\\n\\tboard.right_from(rook_y)\\n];\\ndirections.iter().map(|dir| Self::rules(dir)).sum()\\n```\n```\\ntype BoxIter<\\'a, T> = Box<dyn Iterator<Item=&\\'a T> + \\'a>;\\n\\ntrait Board {\\n    type T;\\n    fn right_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n    fn left_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n    fn up_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n    fn down_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n}\\n\\nimpl<D> Board for Vec<Vec<D>>\\nwhere D: std::fmt::Debug\\n{\\n    type T = D;\\n    fn right_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[y][x+1..].iter()\\n        )\\n    }\\n    fn left_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[y][..x].iter().rev()\\n        )\\n    }\\n    fn up_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[..y].iter()\\n                .map(move |row| &row[x])\\n                .rev()\\n        )\\n    }\\n    fn down_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[y+1..].iter()\\n                .map(move |row| &row[x])\\n        )\\n    }\\n}\\n\\nimpl Solution {\\n    fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    fn rules<\\'a, I>(iter: &mut I) -> i32\\n        where I: Iterator<Item = &\\'a char>\\n    {\\n        iter.skip_while(|piece| **piece == \\'.\\')\\n            .next()\\n            .map_or(0, |piece| if *piece == \\'p\\' {1} else {0})\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        [\\n            board.up_from(rook_x, rook_y),\\n            board.down_from(rook_x, rook_y),\\n            board.left_from(rook_x, rook_y),\\n            board.right_from(rook_x, rook_y),\\n        ].iter_mut().map(|mut iter| Self::rules(iter)).sum()\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    fn rules<\\'a, I>(direction: I) -> i32\\n        where I: IntoIterator<Item = &\\'a char>\\n    {\\n        direction.into_iter().skip_while(|piece| **piece == \\'.\\')\\n            .next()\\n            .map_or(0, |piece| if *piece == \\'p\\' {1} else {0})\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (x, y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        count +=  Self::rules(board[y][x+1..].iter());  // east\\n        count +=  Self::rules((board[y][..x].iter().rev())); // west\\n        count +=  Self::rules(board[..y].iter().map(move |row| &row[x]).rev()); // north\\n        count +=  Self::rules(board[y+1..].iter().map(move |row| &row[x]));  // south\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246691,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        i, j = next((i, j) for i, row in enumerate(board)\\n                           for j, cell in enumerate(row)\\n                           if cell == \\'R\\')\\n        row = \\'\\'.join(board[i])\\n        col = \\'\\'.join(r[j] for r in board)\\n        lines = [row[:j][::-1], row[j+1:], col[:i][::-1], col[i+1:]]\\n        return sum(l.strip(\\'.\\').startswith(\\'p\\') for l in lines)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        i, j = next((i, j) for i, row in enumerate(board)\\n                           for j, cell in enumerate(row)\\n                           if cell == \\'R\\')\\n        row = \\'\\'.join(board[i])\\n        col = \\'\\'.join(r[j] for r in board)\\n        lines = [row[:j][::-1], row[j+1:], col[:i][::-1], col[i+1:]]\\n        return sum(l.strip(\\'.\\').startswith(\\'p\\') for l in lines)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245250,
                "title": "faster-than-100-less-than-100-with-python",
                "content": "Runtime: 24 ms, faster than 100.00% of Python online submissions for Available Captures for Rook.\\nMemory Usage: 10.9 MB, less than 100.00% of Python online submissions for Available Captures for Rook.\\n\\u6211\\u5C31\\u4E0D\\u89E3\\u91CA\\u4E86\\uFF0C\\u8FD9\\u513F\\u6709\\u6CA1\\u6709\\u4E2D\\u56FD\\u4EBA\\u5462\\u54C8\\u54C8\\u54C8\\n```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        result = 0\\n        index = 0\\n        for i in board:\\n            if \\'R\\' in i:\\n                row = \\'\\'.join(z for z in i if z!=\\'.\\')\\n                if \\'Rp\\' in row:\\n                    result += 1\\n                if \\'pR\\' in row:\\n                    result += 1\\n                index = i.index(\"R\")\\n                break\\n        \\n        col = \\'\\'.join(board[i][index] for i in range(8) if board[i][index] !=\\'.\\')\\n        if \\'Rp\\' in col:\\n            result += 1\\n        if \\'pR\\' in col:\\n            result += 1\\n            \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        result = 0\\n        index = 0\\n        for i in board:\\n            if \\'R\\' in i:\\n                row = \\'\\'.join(z for z in i if z!=\\'.\\')\\n                if \\'Rp\\' in row:\\n                    result += 1\\n                if \\'pR\\' in row:\\n                    result += 1\\n                index = i.index(\"R\")\\n                break\\n        \\n        col = \\'\\'.join(board[i][index] for i in range(8) if board[i][index] !=\\'.\\')\\n        if \\'Rp\\' in col:\\n            result += 1\\n        if \\'pR\\' in col:\\n            result += 1\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035930,
                "title": "constant-time-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSteps to solve:\\nstep 1: Find the position of **\"Rook\"**.\\nstep 2: Since the **\"Rook\"** can travel in four directions \\n        We need four loops also the size of the board is 8 * 8 , we dont have to worry about the complexity of loops.\\nstep 3: Count the **\"pawns\"** when you encounter **\\'p\\'** on the board.\\nstep 4: Make sure you break the loop when you encounter the first **\"pawn\"** / **\"Bishop\"**.\\nstep 5: Return the count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$: All the loops run for constant time. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int m = board.size(), n = board[0].size();\\n        int rx, ry;\\n        for(int i = 0 ; i < 8 ; i++) {\\n            for(int j = 0 ; j < 8 ; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    rx = i, ry = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int j = ry + 1 ; j < 8 ; j++) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n        for(int j = ry - 1 ; j >= 0 ; j--) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n \\n        for(int i = rx + 1 ; i < 8 ; i++) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n\\n        for(int i = rx - 1 ; i >= 0 ; i--) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n    \\n\\n        return count;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int m = board.size(), n = board[0].size();\\n        int rx, ry;\\n        for(int i = 0 ; i < 8 ; i++) {\\n            for(int j = 0 ; j < 8 ; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    rx = i, ry = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int j = ry + 1 ; j < 8 ; j++) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n        for(int j = ry - 1 ; j >= 0 ; j--) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n \\n        for(int i = rx + 1 ; i < 8 ; i++) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n\\n        for(int i = rx - 1 ; i >= 0 ; i--) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n    \\n\\n        return count;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954708,
                "title": "easiest-fastest-approach-java",
                "content": "# Code\\n```\\nclass Solution{\\n    public int numRookCaptures(char[][] board){\\n        int x=-1, y=-1;\\n        for(int i=0; i<8; i++){\\n            for(int j=0; j<8; j++){\\n                if(board[i][j]==\\'R\\'){\\n                    x = i;\\n                    y = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int s = 0;\\n        \\n        for(int i=x; i<8; i++){\\n            if(board[i][y]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[i][y]==\\'B\\') break;\\n        }\\n\\n        for(int i=x; i>=0; i--){\\n            if(board[i][y]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[i][y]==\\'B\\') break;\\n        }\\n\\n\\n        for(int j=y; j<8; j++){\\n            if(board[x][j]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[x][j]==\\'B\\') break;\\n        }\\n\\n        for(int j=y; j>=0; j--){\\n            if(board[x][j]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[x][j]==\\'B\\') break;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int numRookCaptures(char[][] board){\\n        int x=-1, y=-1;\\n        for(int i=0; i<8; i++){\\n            for(int j=0; j<8; j++){\\n                if(board[i][j]==\\'R\\'){\\n                    x = i;\\n                    y = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int s = 0;\\n        \\n        for(int i=x; i<8; i++){\\n            if(board[i][y]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[i][y]==\\'B\\') break;\\n        }\\n\\n        for(int i=x; i>=0; i--){\\n            if(board[i][y]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[i][y]==\\'B\\') break;\\n        }\\n\\n\\n        for(int j=y; j<8; j++){\\n            if(board[x][j]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[x][j]==\\'B\\') break;\\n        }\\n\\n        for(int j=y; j>=0; j--){\\n            if(board[x][j]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[x][j]==\\'B\\') break;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925693,
                "title": "java-easy-solution-100-beats-0ms-for-loop-usage-only-beginner-level-by-sethupathi-k",
                "content": "# Intuition\\nKPRIET coimbatore\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        \\n        int m=0,n=0;\\n   \\n        for(int i=0 ; i<=7 ; i++ ){\\n           for(int j=0 ; j<=7 ; j++ ){\\n            \\n            if(board[i][j] == \\'R\\'){\\n\\n                m = i;\\n                n = j;\\n               break;\\n            }\\n        } \\n        }\\n\\n        /*System.out.println(m);\\n        System.out.println(n);*/\\n\\n        int c =0;\\n\\n        for(int i=m ; i<=7 ; i++ ){\\n            if(board[i][n] ==\\'B\\'){\\n               break;\\n            }\\n            else if(board[i][n] == \\'p\\'){\\n               c++;\\n               break;\\n              \\n            }\\n        }\\n\\n        for(int i=m ; i>=0 ; i-- ){\\n             if(board[i][n] == \\'B\\'){\\n               break;\\n            }\\n            else if(board[i][n] == \\'p\\'){\\n                 c++;\\n                break;\\n                 \\n            }\\n        }\\n\\n        for(int i=n ; i<=7 ; i++ ){\\n            if(board[m][i] == \\'B\\'){\\n               break;\\n            }\\n            else if(board[m][i] == \\'p\\'){\\n               c++;\\n               break;\\n              \\n            }\\n        }\\n\\n        for(int i=n ; i>=0 ; i-- ){\\n            if(board[m][i] == \\'B\\'){\\n               break;\\n            }\\n            else if(board[m][i] == \\'p\\'){\\n                 c++;\\n                 break;\\n                \\n            }\\n        }\\n\\n\\n\\n\\n\\n        return c;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        \\n        int m=0,n=0;\\n   \\n        for(int i=0 ; i<=7 ; i++ ){\\n           for(int j=0 ; j<=7 ; j++ ){\\n            \\n            if(board[i][j] == \\'R\\'){\\n\\n                m = i;\\n                n = j;\\n               break;\\n            }\\n        } \\n        }\\n\\n        /*System.out.println(m);\\n        System.out.println(n);*/\\n\\n        int c =0;\\n\\n        for(int i=m ; i<=7 ; i++ ){\\n            if(board[i][n] ==\\'B\\'){\\n               break;\\n            }\\n            else if(board[i][n] == \\'p\\'){\\n               c++;\\n               break;\\n              \\n            }\\n        }\\n\\n        for(int i=m ; i>=0 ; i-- ){\\n             if(board[i][n] == \\'B\\'){\\n               break;\\n            }\\n            else if(board[i][n] == \\'p\\'){\\n                 c++;\\n                break;\\n                 \\n            }\\n        }\\n\\n        for(int i=n ; i<=7 ; i++ ){\\n            if(board[m][i] == \\'B\\'){\\n               break;\\n            }\\n            else if(board[m][i] == \\'p\\'){\\n               c++;\\n               break;\\n              \\n            }\\n        }\\n\\n        for(int i=n ; i>=0 ; i-- ){\\n            if(board[m][i] == \\'B\\'){\\n               break;\\n            }\\n            else if(board[m][i] == \\'p\\'){\\n                 c++;\\n                 break;\\n                \\n            }\\n        }\\n\\n\\n\\n\\n\\n        return c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718174,
                "title": "easy-solution-in-java-runtime-0-ms-100-beats-fully-explained",
                "content": "# Approach\\nTo find the number of available captures for the white rook, we can iterate over the chessboard and locate the position of the rook (\\'R\\'). Once we find the rook, we can check in four cardinal directions (up, down, left, right) for pawns (\\'p\\') and bishops (\\'B\\').\\n\\n1. Initialize a variable `count` to keep track of the number of available captures.\\n2. Use nested loops to iterate over each cell on the chessboard.\\n3. When the rook is found (board[i][j] == \\'R\\'), perform the following steps:\\n   - Initialize variables k and t to represent the row and column indices, respectively.\\n   - Check in the upward direction by decrementing k (k--) until reaching the top edge of the board (k >= 0).\\n     - If a bishop (\\'B\\') is encountered, break the loop as the rook is blocked in this direction.\\n     - If a pawn (\\'p\\') is encountered, increment the `count` and break the loop as the rook can capture the pawn.\\n   - Repeat the same process for the downward direction by incrementing k (k++) until reaching the bottom edge of the board (k < board.length).\\n   - Check in the leftward direction by decrementing t (t--) until reaching the left edge of the board (t >= 0).\\n     - If a bishop (\\'B\\') is encountered, break the loop.\\n     - If a pawn (\\'p\\') is encountered, increment the `count` and break the loop.\\n   - Repeat the same process for the rightward direction by incrementing t (t++) until reaching the right edge of the board (t < board[0].length).\\n   - Break the outer loop using a labeled statement (`break loop;`) to avoid unnecessary iterations once the rook is found and processed.\\n4. After the loops, return the value of `count` as the result.\\n\\nThis approach scans the board in a straightforward manner, checking each direction for pawns and bishops until an obstacle is encountered or the edge of the board is reached. The `count` variable keeps track of the number of captured pawns, which is the final result returned by the function.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n\\n        loop:\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    int k = i - 1;\\n                    while(k >= 0){\\n                        if(board[k][j] == \\'B\\') break;\\n                        if(board[k][j] == \\'p\\'){\\n                            count++;\\n                            break;\\n                        }\\n                        k--;\\n                    }\\n                    k = i + 1;\\n                    while(k < board.length) {\\n                        if(board[k][j] == \\'B\\') break;\\n                        if(board[k][j] == \\'p\\'){\\n                            count++;\\n                            break;\\n                        }\\n                        k++;\\n                    }\\n\\n                    int t = j - 1;\\n                    while(t >= 0){\\n                        if(board[i][t] == \\'B\\') break;\\n                        if(board[i][t] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        }\\n                        t--;\\n                    }\\n                    t = j + 1;\\n                    while(t < board[0].length){\\n                        if(board[i][t] == \\'B\\') break;\\n                        if(board[i][t] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        }\\n                        t++;    \\n                    }\\n\\n                    break loop;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n\\n        loop:\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    int k = i - 1;\\n                    while(k >= 0){\\n                        if(board[k][j] == \\'B\\') break;\\n                        if(board[k][j] == \\'p\\'){\\n                            count++;\\n                            break;\\n                        }\\n                        k--;\\n                    }\\n                    k = i + 1;\\n                    while(k < board.length) {\\n                        if(board[k][j] == \\'B\\') break;\\n                        if(board[k][j] == \\'p\\'){\\n                            count++;\\n                            break;\\n                        }\\n                        k++;\\n                    }\\n\\n                    int t = j - 1;\\n                    while(t >= 0){\\n                        if(board[i][t] == \\'B\\') break;\\n                        if(board[i][t] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        }\\n                        t--;\\n                    }\\n                    t = j + 1;\\n                    while(t < board[0].length){\\n                        if(board[i][t] == \\'B\\') break;\\n                        if(board[i][t] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        }\\n                        t++;    \\n                    }\\n\\n                    break loop;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540686,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        static vector<pair<int, int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n        int r = -1, c = -1;\\n        for (int i = 0; i < 8 && r == -1; ++i) {\\n            for (int j = 0; j < 8; ++j) {\\n                if (board[i][j] == \\'R\\') {\\n                    tie(r, c) = make_pair(i, j);\\n                    break;\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for (const auto& d : directions) {\\n            int nr, nc;\\n            tie(nr, nc) = make_pair(r + d.first, c + d.second);\\n            while (0 <= nr && nr < 8 && 0 <= nc && nc < 8) {\\n                if (board[nr][nc] == \\'p\\') {\\n                    ++result;\\n                }\\n                if (board[nr][nc] != \\'.\\') {\\n                    break;\\n                }\\n                tie(nr, nc) = make_pair(nr + d.first, nc + d.second);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        rook = None\\n        while rook is None:\\n            for i in range(8):\\n                for j in range(8):\\n                    if board[i][j] == \\'R\\':\\n                        rook = (i, j)\\n                        break\\n        \\n        available_captures = 0\\n        for i in range(rook[0] - 1, -1, -1):\\n            if board[i][rook[1]] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[i][rook[1]] == \\'B\\':\\n                break\\n        for i in range(rook[0] + 1, 8):\\n            if board[i][rook[1]] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[i][rook[1]] == \\'B\\':\\n                break\\n        for j in range(rook[1] - 1, -1, -1):\\n            if board[rook[0]][j] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[rook[0]][j] == \\'B\\':\\n                break\\n        for j in range(rook[1] + 1, 8):\\n            if board[rook[0]][j] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[rook[0]][j] == \\'B\\':\\n                break\\n        return available_captures\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ii=0,jj=0;\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    ii=i;\\n                    jj=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int count=0;\\n        for(int i=ii;i>=0;i--){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int i=ii;i<8;i++){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j<8;j++){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j>=0;j--){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        static vector<pair<int, int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n        int r = -1, c = -1;\\n        for (int i = 0; i < 8 && r == -1; ++i) {\\n            for (int j = 0; j < 8; ++j) {\\n                if (board[i][j] == \\'R\\') {\\n                    tie(r, c) = make_pair(i, j);\\n                    break;\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for (const auto& d : directions) {\\n            int nr, nc;\\n            tie(nr, nc) = make_pair(r + d.first, c + d.second);\\n            while (0 <= nr && nr < 8 && 0 <= nc && nc < 8) {\\n                if (board[nr][nc] == \\'p\\') {\\n                    ++result;\\n                }\\n                if (board[nr][nc] != \\'.\\') {\\n                    break;\\n                }\\n                tie(nr, nc) = make_pair(nr + d.first, nc + d.second);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        rook = None\\n        while rook is None:\\n            for i in range(8):\\n                for j in range(8):\\n                    if board[i][j] == \\'R\\':\\n                        rook = (i, j)\\n                        break\\n        \\n        available_captures = 0\\n        for i in range(rook[0] - 1, -1, -1):\\n            if board[i][rook[1]] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[i][rook[1]] == \\'B\\':\\n                break\\n        for i in range(rook[0] + 1, 8):\\n            if board[i][rook[1]] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[i][rook[1]] == \\'B\\':\\n                break\\n        for j in range(rook[1] - 1, -1, -1):\\n            if board[rook[0]][j] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[rook[0]][j] == \\'B\\':\\n                break\\n        for j in range(rook[1] + 1, 8):\\n            if board[rook[0]][j] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[rook[0]][j] == \\'B\\':\\n                break\\n        return available_captures\\n```\n```Java []\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ii=0,jj=0;\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    ii=i;\\n                    jj=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int count=0;\\n        for(int i=ii;i>=0;i--){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int i=ii;i<8;i++){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j<8;j++){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j>=0;j--){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404387,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] b) {\\n        int cnt=0;\\n        for(int i=0;i<b.length;i++){\\n            for(int j=0;j<b[0].length;j++){\\n                if(b[i][j]==\\'R\\'){\\n                    //left\\n                    int l=j-1;\\n                    while(l>=0){\\n                        if(b[i][l]==\\'B\\'){\\n                            break;\\n                        }else if(b[i][l]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                        l--;\\n                    }\\n                    //right\\n                   \\n                    int r=j+1;\\n                    while(r<b.length){\\n                        if(b[i][r]==\\'B\\'){\\n                            break;\\n                        }else if(b[i][r]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                        r++;\\n                    }\\n                    //top\\n                    // if((i-1)>=0 && (b[i-1][j]==\\'.\\' || b[i-1][j]==\\'p\\')) cnt++;\\n                    int t=i-1;\\n                    while(t>=0){\\n                        if(b[t][j]==\\'B\\'){\\n                            break;\\n                        }else if(b[t][j]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                        t--;\\n                    }\\n\\n                    //bottom\\n                    // if((i+1)<b.length && (b[i+1][j]==\\'.\\' && b[i+1][j]==\\'p\\' )) cnt++;\\n                    int u=i+1;\\n                    while(u<b.length){\\n                        if(b[u][j]==\\'B\\'){\\n                            break;\\n                        }else if(b[u][j]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                       u++;\\n                    }\\n                    break;\\n            }\\n        }\\n        \\n    }\\n     return cnt;\\n    }\\n }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] b) {\\n        int cnt=0;\\n        for(int i=0;i<b.length;i++){\\n            for(int j=0;j<b[0].length;j++){\\n                if(b[i][j]==\\'R\\'){\\n                    //left\\n                    int l=j-1;\\n                    while(l>=0){\\n                        if(b[i][l]==\\'B\\'){\\n                            break;\\n                        }else if(b[i][l]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                        l--;\\n                    }\\n                    //right\\n                   \\n                    int r=j+1;\\n                    while(r<b.length){\\n                        if(b[i][r]==\\'B\\'){\\n                            break;\\n                        }else if(b[i][r]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                        r++;\\n                    }\\n                    //top\\n                    // if((i-1)>=0 && (b[i-1][j]==\\'.\\' || b[i-1][j]==\\'p\\')) cnt++;\\n                    int t=i-1;\\n                    while(t>=0){\\n                        if(b[t][j]==\\'B\\'){\\n                            break;\\n                        }else if(b[t][j]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                        t--;\\n                    }\\n\\n                    //bottom\\n                    // if((i+1)<b.length && (b[i+1][j]==\\'.\\' && b[i+1][j]==\\'p\\' )) cnt++;\\n                    int u=i+1;\\n                    while(u<b.length){\\n                        if(b[u][j]==\\'B\\'){\\n                            break;\\n                        }else if(b[u][j]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                       u++;\\n                    }\\n                    break;\\n            }\\n        }\\n        \\n    }\\n     return cnt;\\n    }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336852,
                "title": "available-captures-for-rook-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int i, j, x, y, count=0;\\n        for(i=0 ; i<board.size() ; i++)\\n        {\\n            for(j=0 ; j<board[0].size() ; j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        for(i=x+1 ; i<board[0].size() ; i++)\\n        {\\n            if(board[i][y]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[i][y]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        for(i=x-1 ; i>=0; i--)\\n        {\\n            if(board[i][y]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[i][y]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n\\n        for(i=y+1 ; i<board.size() ; i++)\\n        {\\n            if(board[x][i]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[x][i]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        for(i=y-1 ; i>=0; i--)\\n        {\\n            if(board[x][i]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[x][i]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int i, j, x, y, count=0;\\n        for(i=0 ; i<board.size() ; i++)\\n        {\\n            for(j=0 ; j<board[0].size() ; j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        for(i=x+1 ; i<board[0].size() ; i++)\\n        {\\n            if(board[i][y]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[i][y]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        for(i=x-1 ; i>=0; i--)\\n        {\\n            if(board[i][y]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[i][y]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n\\n        for(i=y+1 ; i<board.size() ; i++)\\n        {\\n            if(board[x][i]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[x][i]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        for(i=y-1 ; i>=0; i--)\\n        {\\n            if(board[x][i]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[x][i]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249884,
                "title": "rust-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let mut rook = (0, 0);\\n        let mut pawns = vec![];\\n        let mut bishops = vec![];\\n        let directions = [(0, -1), (0, 1), (-1, 0), (1, 0)];\\n        let mut count = 0;\\n\\n        (0..8usize).for_each(|i| {\\n            (0..8usize).for_each(|j| match board[i][j] {\\n                \\'R\\' => rook = (i, j),\\n                \\'p\\' => pawns.push((i, j)),\\n                \\'B\\' => bishops.push((i, j)),\\n                _ => (),\\n            })\\n        });\\n\\n        pawns = pawns\\n            .into_iter()\\n            .filter(|&(i, j)| rook.0 == i || rook.1 == j)\\n            .collect();\\n\\n        bishops = bishops\\n            .into_iter()\\n            .filter(|&(i, j)| rook.0 == i || rook.1 == j)\\n            .collect();\\n\\n        for (x, y) in directions {\\n            let (mut i, mut j) = rook;\\n            while (0..8).contains(&i) && (0..8).contains(&j) {\\n                i += x as usize;\\n                j += y as usize;\\n                if bishops.contains(&(i, j)) {\\n                    break;\\n                }\\n                if pawns.contains(&(i, j)) {\\n                    count += 1;\\n                    break;\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let mut rook = (0, 0);\\n        let mut pawns = vec![];\\n        let mut bishops = vec![];\\n        let directions = [(0, -1), (0, 1), (-1, 0), (1, 0)];\\n        let mut count = 0;\\n\\n        (0..8usize).for_each(|i| {\\n            (0..8usize).for_each(|j| match board[i][j] {\\n                \\'R\\' => rook = (i, j),\\n                \\'p\\' => pawns.push((i, j)),\\n                \\'B\\' => bishops.push((i, j)),\\n                _ => (),\\n            })\\n        });\\n\\n        pawns = pawns\\n            .into_iter()\\n            .filter(|&(i, j)| rook.0 == i || rook.1 == j)\\n            .collect();\\n\\n        bishops = bishops\\n            .into_iter()\\n            .filter(|&(i, j)| rook.0 == i || rook.1 == j)\\n            .collect();\\n\\n        for (x, y) in directions {\\n            let (mut i, mut j) = rook;\\n            while (0..8).contains(&i) && (0..8).contains(&j) {\\n                i += x as usize;\\n                j += y as usize;\\n                if bishops.contains(&(i, j)) {\\n                    break;\\n                }\\n                if pawns.contains(&(i, j)) {\\n                    count += 1;\\n                    break;\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3067558,
                "title": "javascript-solution-using-regex-not-that-fast-btw",
                "content": "\\n# Code\\n```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    var pawnCount = 0;\\n    var horizontal;\\n    var vertical = \"\";\\n    \\n    for (let i in board) {\\n        if (board[i].includes(\\'R\\')) {\\n            horizontal = board[i].join(\"\");\\n            for (let j = 0; j < 8; j++) {\\n                vertical += board[j][board[i].indexOf(\\'R\\')]\\n            }\\n        }\\n    }\\n\\n    for (let match of horizontal.matchAll(\"(p[.]*R)\")) pawnCount++;\\n    for (let match of horizontal.matchAll(\"(R[.]*p)\")) pawnCount++;\\n    for (let match of vertical.matchAll(\"(p[.]*R)\")) pawnCount++;\\n    for (let match of vertical.matchAll(\"(R[.]*p)\")) pawnCount++;\\n    \\n    return pawnCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    var pawnCount = 0;\\n    var horizontal;\\n    var vertical = \"\";\\n    \\n    for (let i in board) {\\n        if (board[i].includes(\\'R\\')) {\\n            horizontal = board[i].join(\"\");\\n            for (let j = 0; j < 8; j++) {\\n                vertical += board[j][board[i].indexOf(\\'R\\')]\\n            }\\n        }\\n    }\\n\\n    for (let match of horizontal.matchAll(\"(p[.]*R)\")) pawnCount++;\\n    for (let match of horizontal.matchAll(\"(R[.]*p)\")) pawnCount++;\\n    for (let match of vertical.matchAll(\"(p[.]*R)\")) pawnCount++;\\n    for (let match of vertical.matchAll(\"(R[.]*p)\")) pawnCount++;\\n    \\n    return pawnCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3041614,
                "title": "beats-98-87-solutions-easy-to-understand-python-code-with-explanation-by-bolt-coding",
                "content": "# Explanation:\\nFirst we try to find the position of Rook.\\nOnce we get that we already know that Rook always attacks in straight line i.e. Rows or Columns (not diagonals). So rather than traversing through the whole list we will only traverse through the rows and columns where Rook can attack. So we right 4 different for loops to traverse through rows and columns.\\n\\n# Complexity\\n- **Time complexity**: O(n^2) : As in worst case scenario the ROOK might be at position (7, 7)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        idx = []\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'R\\':\\n                    idx = [i, j]\\n                    break\\n        x, y = idx[0], idx[1]\\n        count = 0\\n        for i in range(x-1, -1, -1):\\n            if board[i][y] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[i][y] == \\'B\\':\\n                break\\n        \\n        for i in range(x+1, 8):\\n            if board[i][y] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[i][y] == \\'B\\':\\n                break\\n\\n        for i in range(y-1, -1, -1):\\n            if board[x][i] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[x][i] == \\'B\\':\\n                break\\n        \\n        for i in range(y+1, 8):\\n            if board[x][i] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[x][i] == \\'B\\':\\n                break\\n        return count\\n\\n```\\n\\n# Learning\\nTo understand problems in simpler ways, need help with projects, want to learn coding from scratch, work on resume level projects, learn data science ...................\\n\\nSubscribe to Bolt Coding Channel - https://www.youtube.com/@boltcoding",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        idx = []\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'R\\':\\n                    idx = [i, j]\\n                    break\\n        x, y = idx[0], idx[1]\\n        count = 0\\n        for i in range(x-1, -1, -1):\\n            if board[i][y] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[i][y] == \\'B\\':\\n                break\\n        \\n        for i in range(x+1, 8):\\n            if board[i][y] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[i][y] == \\'B\\':\\n                break\\n\\n        for i in range(y-1, -1, -1):\\n            if board[x][i] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[x][i] == \\'B\\':\\n                break\\n        \\n        for i in range(y+1, 8):\\n            if board[x][i] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[x][i] == \\'B\\':\\n                break\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963334,
                "title": "999-java-5-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI Suggested for you, easy way to understand read my approach **last to first**;\\nAnd I challenge you **did not understand first approach**;\\n# Approach 1\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 39.9 MB\\n- Beats : 80%\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = -1 , ans = 0;\\n        for(;j == -1;i++)  j = new String(board[i]).indexOf(\\'R\\');\\n        for(char ch : \"lrud\".toCharArray()) ans += find(board,ch,i-1,j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch == \\'l\\' && --row < 0|| ch == \\'u\\' && --col < 0) break;\\n            if(ch == \\'r\\' && ++row > 7|| ch == \\'d\\' && ++col > 7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n# Approach 2\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 39.9 MB\\n- Beats : 80.51%\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = 0 , ans = 0;\\n        for(;i<8;i++){\\n            j = new String(board[i]).indexOf(\\'R\\');\\n            if(j != -1) break;\\n        }\\n        for(char ch : \"lrud\".toCharArray()) ans+=find(board,ch,i,j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch==\\'l\\' && --col<0 || ch==\\'u\\' && --row<0) break;\\n            if(ch==\\'r\\' && ++col>7 || ch==\\'d\\' && ++row>7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n---\\n# Approach 3\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 39.4 MB\\n- Beats : 99.75%\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = 0 , ans = 0;\\n        out :\\n        for(;i<8;i++)  {\\n            for(int k = 0;k<8;k++) {\\n                if(board[i][k] == \\'R\\') {\\n                    j = k;\\n                    break out;\\n                }\\n            }\\n\\n        }\\n        for(char ch : \"lrud\".toCharArray()) ans+=find(board,ch,i,j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch==\\'l\\' && --col<0 || ch==\\'u\\' && --row<0) break;\\n            if(ch==\\'r\\' && ++col>7 || ch==\\'d\\' && ++row>7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n---\\n# Approach 4\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 40.1 MB\\n- Beats : 60.51%\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = 0 , ans = 0;\\n        out :\\n        for(;i<8;i++)  {\\n            for(int k = 0;k<8;k++) {\\n                if(board[i][k] == \\'R\\') {\\n                    j = k;\\n                    break out;\\n                }\\n            }\\n\\n        }\\n        ans += find(board , \\'l\\' , i , j);\\n        ans += find(board , \\'r\\' , i , j);\\n        ans += find(board , \\'u\\' , i , j);\\n        ans += find(board , \\'d\\' , i , j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch==\\'l\\' && --col<0 || ch==\\'u\\' && --row<0) break;\\n            if(ch==\\'r\\' && ++col>7 || ch==\\'d\\' && ++row>7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n# Approach 5\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j= 0 , ans = 0;\\n    out:while(i < 8){\\n            while(j < 8){\\n                if(board[i][j] == \\'R\\') break out;\\n                j++;\\n            }\\n            i++;\\n            j = 0;\\n        }\\n        int i1 = i , j1 = j;\\n        while(i1 >= 0) {\\n            if(board[i1][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i1][j] == \\'B\\') break;\\n            i1--;\\n        }\\n        i1 = i;\\n        while(i1 < 8) {\\n            if(board[i1][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i1][j] == \\'B\\') break;\\n            i1++;\\n        }\\n        while(j1 >= 0) {\\n            if(board[i][j1] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][j1] == \\'B\\') break;\\n            j1--;\\n        }\\n        while(j < 8) {\\n            if(board[i][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][j] == \\'B\\') break;\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = -1 , ans = 0;\\n        for(;j == -1;i++)  j = new String(board[i]).indexOf(\\'R\\');\\n        for(char ch : \"lrud\".toCharArray()) ans += find(board,ch,i-1,j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch == \\'l\\' && --row < 0|| ch == \\'u\\' && --col < 0) break;\\n            if(ch == \\'r\\' && ++row > 7|| ch == \\'d\\' && ++col > 7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = 0 , ans = 0;\\n        for(;i<8;i++){\\n            j = new String(board[i]).indexOf(\\'R\\');\\n            if(j != -1) break;\\n        }\\n        for(char ch : \"lrud\".toCharArray()) ans+=find(board,ch,i,j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch==\\'l\\' && --col<0 || ch==\\'u\\' && --row<0) break;\\n            if(ch==\\'r\\' && ++col>7 || ch==\\'d\\' && ++row>7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = 0 , ans = 0;\\n        out :\\n        for(;i<8;i++)  {\\n            for(int k = 0;k<8;k++) {\\n                if(board[i][k] == \\'R\\') {\\n                    j = k;\\n                    break out;\\n                }\\n            }\\n\\n        }\\n        for(char ch : \"lrud\".toCharArray()) ans+=find(board,ch,i,j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch==\\'l\\' && --col<0 || ch==\\'u\\' && --row<0) break;\\n            if(ch==\\'r\\' && ++col>7 || ch==\\'d\\' && ++row>7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = 0 , ans = 0;\\n        out :\\n        for(;i<8;i++)  {\\n            for(int k = 0;k<8;k++) {\\n                if(board[i][k] == \\'R\\') {\\n                    j = k;\\n                    break out;\\n                }\\n            }\\n\\n        }\\n        ans += find(board , \\'l\\' , i , j);\\n        ans += find(board , \\'r\\' , i , j);\\n        ans += find(board , \\'u\\' , i , j);\\n        ans += find(board , \\'d\\' , i , j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch==\\'l\\' && --col<0 || ch==\\'u\\' && --row<0) break;\\n            if(ch==\\'r\\' && ++col>7 || ch==\\'d\\' && ++row>7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j= 0 , ans = 0;\\n    out:while(i < 8){\\n            while(j < 8){\\n                if(board[i][j] == \\'R\\') break out;\\n                j++;\\n            }\\n            i++;\\n            j = 0;\\n        }\\n        int i1 = i , j1 = j;\\n        while(i1 >= 0) {\\n            if(board[i1][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i1][j] == \\'B\\') break;\\n            i1--;\\n        }\\n        i1 = i;\\n        while(i1 < 8) {\\n            if(board[i1][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i1][j] == \\'B\\') break;\\n            i1++;\\n        }\\n        while(j1 >= 0) {\\n            if(board[i][j1] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][j1] == \\'B\\') break;\\n            j1--;\\n        }\\n        while(j < 8) {\\n            if(board[i][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][j] == \\'B\\') break;\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653423,
                "title": "c-easy-to-understand-faster",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int cap(vector<vector<char>>& b, int x, int y, int dx, int dy) {\\n  while (x >= 0 && x < b.size() && y >= 0 && y < b[x].size() && b[x][y] != \\'B\\') {\\n    if (b[x][y] == \\'p\\') return 1;\\n    x += dx, y += dy;\\n  }\\n  return 0;\\n}\\nint numRookCaptures(vector<vector<char>>& b) {\\n  for (auto i = 0; i < b.size(); ++i)\\n    for (auto j = 0; j < b[i].size(); ++j)\\n      if (b[i][j] == \\'R\\') return cap(b,i,j,0,1)+cap(b,i,j,0,-1)+cap(b,i,j,1,0)+cap(b,i,j,-1,0);\\n  return 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int cap(vector<vector<char>>& b, int x, int y, int dx, int dy) {\\n  while (x >= 0 && x < b.size() && y >= 0 && y < b[x].size() && b[x][y] != \\'B\\') {\\n    if (b[x][y] == \\'p\\') return 1;\\n    x += dx, y += dy;\\n  }\\n  return 0;\\n}\\nint numRookCaptures(vector<vector<char>>& b) {\\n  for (auto i = 0; i < b.size(); ++i)\\n    for (auto j = 0; j < b[i].size(); ++j)\\n      if (b[i][j] == \\'R\\') return cap(b,i,j,0,1)+cap(b,i,j,0,-1)+cap(b,i,j,1,0)+cap(b,i,j,-1,0);\\n  return 0;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492006,
                "title": "python3-dfs",
                "content": "\\n```\\nfrom typing import List\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        #move in the given direction until the edge of the board or pawn or bishop is encountered\\n        def attack(r, c, i, j):\\n            ans = 0\\n            while 0<=r<8 and 0<=c<8:\\n                if board[r][c]==\\'p\\':\\n                    ans += 1\\n                    break\\n                if board[r][c]==\\'B\\':\\n                    break\\n                r, c = r+i, c+j\\n            return ans\\n            \\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j]==\\'R\\':\\n                    #check all 4 directions\\n                    return attack(i, j, 0, 1) + attack(i, j, 0, -1) + attack(i, j, 1, 0) + attack(i, j, -1, 0)\\n        return 0",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Simulation"
                ],
                "code": "\\n```\\nfrom typing import List\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        #move in the given direction until the edge of the board or pawn or bishop is encountered\\n        def attack(r, c, i, j):\\n            ans = 0\\n            while 0<=r<8 and 0<=c<8:\\n                if board[r][c]==\\'p\\':\\n                    ans += 1\\n                    break\\n                if board[r][c]==\\'B\\':\\n                    break\\n                r, c = r+i, c+j\\n            return ans\\n            \\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j]==\\'R\\':\\n                    #check all 4 directions\\n                    return attack(i, j, 0, 1) + attack(i, j, 0, -1) + attack(i, j, 1, 0) + attack(i, j, -1, 0)\\n        return 0",
                "codeTag": "Java"
            },
            {
                "id": 2459684,
                "title": "java-simple-solution-0-seconds",
                "content": "The code is self-explanatory\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int[] rowCol = findRook(board);\\n        int countCaptures = 0;\\n        if (canCaptureUp(rowCol, board)) countCaptures++;\\n        if (canCaptureRight(rowCol, board)) countCaptures++;\\n        if (canCaptureDown(rowCol, board)) countCaptures++;\\n        if (canCaptureLeft(rowCol, board)) countCaptures++;\\n        return countCaptures;\\n    }\\n    \\n    private int[] findRook(char[][] board) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    return new int[]{i, j};\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    private boolean canCaptureUp(int[] rowCol, char[][] board) {\\n        int row = rowCol[0];\\n        int col = rowCol[1];\\n        while (cellExist(--row, col, board)) {\\n            char cell = board[row][col];\\n            if (cell == \\'p\\') {\\n                return true;\\n            } else if (cell == \\'B\\') {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean canCaptureRight(int[] rowCol, char[][] board) {\\n        int row = rowCol[0];\\n        int col = rowCol[1];\\n        while (cellExist(row, ++col, board)) {\\n            char cell = board[row][col];\\n            if (cell == \\'p\\') {\\n                return true;\\n            } else if (cell == \\'B\\') {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean canCaptureDown(int[] rowCol, char[][] board) {\\n        int row = rowCol[0];\\n        int col = rowCol[1];\\n        while (cellExist(++row, col, board)) {\\n            char cell = board[row][col];\\n            if (cell == \\'p\\') {\\n                return true;\\n            } else if (cell == \\'B\\') {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean canCaptureLeft(int[] rowCol, char[][] board) {\\n        int row = rowCol[0];\\n        int col = rowCol[1];\\n        while (cellExist(row, --col, board)) {\\n            char cell = board[row][col];\\n            if (cell == \\'p\\') {\\n                return true;\\n            } else if (cell == \\'B\\') {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean cellExist(int row, int col, char[][] array) {\\n        return (row <= array.length - 1 && row >= 0) && (col <= array[0].length - 1 && col >= 0);\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int[] rowCol = findRook(board);\\n        int countCaptures = 0;\\n        if (canCaptureUp(rowCol, board)) countCaptures++;\\n        if (canCaptureRight(rowCol, board)) countCaptures++;\\n        if (canCaptureDown(rowCol, board)) countCaptures++;\\n        if (canCaptureLeft(rowCol, board)) countCaptures++;\\n        return countCaptures;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2355406,
                "title": "javascript-solution-easy-to-understand",
                "content": "```\\nvar numRookCaptures = function(board) {\\n    let count = 0;\\n    \\n    let rowIndex;\\n    let colIndex;\\n    let flag = false;\\n    //Find the location of R in board\\n    for(let i=0; i<8; i++){\\n        for(let j=0; j<8; j++){\\n            if(board[i][j] === \"R\"){\\n                rowIndex = i;\\n                colIndex = j;\\n                flag = true;\\n                break;\\n            }\\n        }\\n        if(flag === true)\\n            break;\\n    }\\n    \\n    //Move upwards\\n    for(let i=rowIndex; i>=0; i--){\\n        if(board[i][colIndex] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[i][colIndex] === \\'B\\')\\n            break;\\n    }\\n    //Move downwards\\n    for(let i=rowIndex; i<8; i++){\\n        if(board[i][colIndex] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[i][colIndex] === \\'B\\')\\n            break;\\n    }\\n    //Move right\\n    for(let i=colIndex; i<8; i++){\\n        if(board[rowIndex][i] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[rowIndex][i] === \\'B\\')\\n            break;\\n    }\\n    //Move left\\n    for(let i=colIndex; i>=0; i--){\\n        if(board[rowIndex][i] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[rowIndex][i] === \\'B\\')\\n            break;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nvar numRookCaptures = function(board) {\\n    let count = 0;\\n    \\n    let rowIndex;\\n    let colIndex;\\n    let flag = false;\\n    //Find the location of R in board\\n    for(let i=0; i<8; i++){\\n        for(let j=0; j<8; j++){\\n            if(board[i][j] === \"R\"){\\n                rowIndex = i;\\n                colIndex = j;\\n                flag = true;\\n                break;\\n            }\\n        }\\n        if(flag === true)\\n            break;\\n    }\\n    \\n    //Move upwards\\n    for(let i=rowIndex; i>=0; i--){\\n        if(board[i][colIndex] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[i][colIndex] === \\'B\\')\\n            break;\\n    }\\n    //Move downwards\\n    for(let i=rowIndex; i<8; i++){\\n        if(board[i][colIndex] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[i][colIndex] === \\'B\\')\\n            break;\\n    }\\n    //Move right\\n    for(let i=colIndex; i<8; i++){\\n        if(board[rowIndex][i] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[rowIndex][i] === \\'B\\')\\n            break;\\n    }\\n    //Move left\\n    for(let i=colIndex; i>=0; i--){\\n        if(board[rowIndex][i] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[rowIndex][i] === \\'B\\')\\n            break;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326469,
                "title": "c-100-faster-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int res=0;\\n        int p=-1,q=-1;\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]==\\'R\\') // storing position of R\\n                {\\n                    p=i;\\n                    q=j;\\n                    break;\\n                }\\n            }\\n            if(p>=0)\\n                break;\\n        }\\n        // traverse Up, Down, Left and Right from R\\n        for(int i=p+1;i<board.size();i++)\\n        {\\n            if(board[i][q]!=\\'.\\')\\n            {\\n                if(board[i][q]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        for(int i=p-1;i>=0;i--)\\n        {\\n            if(board[i][q]!=\\'.\\')\\n            {\\n                if(board[i][q]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        \\n        for(int j=q+1;j<board[0].size();j++)\\n        {\\n            if(board[p][j]!=\\'.\\')\\n            {\\n                if(board[p][j]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        for(int j=q-1;j>=0;j--)\\n        {\\n            if(board[p][j]!=\\'.\\')\\n            {\\n                if(board[p][j]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int res=0;\\n        int p=-1,q=-1;\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]==\\'R\\') // storing position of R\\n                {\\n                    p=i;\\n                    q=j;\\n                    break;\\n                }\\n            }\\n            if(p>=0)\\n                break;\\n        }\\n        // traverse Up, Down, Left and Right from R\\n        for(int i=p+1;i<board.size();i++)\\n        {\\n            if(board[i][q]!=\\'.\\')\\n            {\\n                if(board[i][q]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        for(int i=p-1;i>=0;i--)\\n        {\\n            if(board[i][q]!=\\'.\\')\\n            {\\n                if(board[i][q]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        \\n        for(int j=q+1;j<board[0].size();j++)\\n        {\\n            if(board[p][j]!=\\'.\\')\\n            {\\n                if(board[p][j]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        for(int j=q-1;j>=0;j--)\\n        {\\n            if(board[p][j]!=\\'.\\')\\n            {\\n                if(board[p][j]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224853,
                "title": "c-0-ms-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n               \\n        int x, y;\\n        \\n        for(int i=0; i<8; i++)\\n            for(int j=0; j<8; j++)\\n                if(board[i][j] == \\'R\\')\\n                {\\n                    x = i, y = j;\\n                    break;\\n                }\\n\\n        int res = 0;\\n        \\n        //up\\n        for(int i=x-1; i>=0; i--)\\n            if (board[i][y] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[i][y] == \\'B\\')\\n                break;\\n        \\n        //down\\n        for(int i=x+1; i < 8; i++)\\n            if (board[i][y] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[i][y] == \\'B\\')\\n                break;        \\n        \\n        //left\\n        for(int j = y-1; j >= 0; j--)\\n            if (board[x][j] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[x][j] == \\'B\\')\\n                break;  \\n        \\n        //right\\n        for(int j = y+1; j < 8; j++)\\n            if (board[x][j] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[x][j] == \\'B\\')\\n                break; \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n               \\n        int x, y;\\n        \\n        for(int i=0; i<8; i++)\\n            for(int j=0; j<8; j++)\\n                if(board[i][j] == \\'R\\')\\n                {\\n                    x = i, y = j;\\n                    break;\\n                }\\n\\n        int res = 0;\\n        \\n        //up\\n        for(int i=x-1; i>=0; i--)\\n            if (board[i][y] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[i][y] == \\'B\\')\\n                break;\\n        \\n        //down\\n        for(int i=x+1; i < 8; i++)\\n            if (board[i][y] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[i][y] == \\'B\\')\\n                break;        \\n        \\n        //left\\n        for(int j = y-1; j >= 0; j--)\\n            if (board[x][j] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[x][j] == \\'B\\')\\n                break;  \\n        \\n        //right\\n        for(int j = y+1; j < 8; j++)\\n            if (board[x][j] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[x][j] == \\'B\\')\\n                break; \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158272,
                "title": "easy-c",
                "content": "In rook\\'s way, two possible pieces-Bishop and Pawn.\\n4 directions(Up,Down,Right,Left)\\nFor every direction:\\n\\tIf Pawn +1 and break loop.\\n\\tIf bishop, break loop.\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int r=0,c=0;\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[i].size();j++) {\\n                if(board[i][j]==\\'R\\'){\\n                    r=i;\\n                    c=j;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        int i=r,j=c;\\n        while(i-->0) {\\n            if(board[i][c]==\\'B\\')\\n                break;\\n            if(board[i][c]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        while(j-->0) {\\n            if(board[r][j]==\\'B\\')\\n                break;\\n            if(board[r][j]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        i=r;\\n        while(i++<7) {\\n            if(board[i][c]==\\'B\\')\\n                break;\\n            if(board[i][c]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        j=c;\\n        while(j++<7) {\\n            if(board[r][j]==\\'B\\')\\n                break;\\n            if(board[r][j]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int r=0,c=0;\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[i].size();j++) {\\n                if(board[i][j]==\\'R\\'){\\n                    r=i;\\n                    c=j;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        int i=r,j=c;\\n        while(i-->0) {\\n            if(board[i][c]==\\'B\\')\\n                break;\\n            if(board[i][c]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        while(j-->0) {\\n            if(board[r][j]==\\'B\\')\\n                break;\\n            if(board[r][j]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        i=r;\\n        while(i++<7) {\\n            if(board[i][c]==\\'B\\')\\n                break;\\n            if(board[i][c]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        j=c;\\n        while(j++<7) {\\n            if(board[r][j]==\\'B\\')\\n                break;\\n            if(board[r][j]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059535,
                "title": "javascript-solution-faster-than-97-33",
                "content": "<img src=\"https://assets.leetcode.com/users/images/f2cab14a-2511-42c0-9e8c-15d850fb283b_1653122499.248853.png\" width=\"600\"/>\\n\\n```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nconst numRookCaptures = board => {\\n    // set checker grids\\n    const rows = new Array(8).fill(\\'\\'), cols = new Array(8).fill(\\'\\');\\n\\n    // set rook and capture travel\\n    let rook = { x: -1, y: -1 }, captures = 0;\\n\\n    for (let i = 0; i < 8; i++) {\\n        for (let j = 0; j < 8; j++) {\\n            rows[i] += board[i][j];\\n            cols[i] += board[j][i];\\n            \\n            if (board[i][j] === `R`) {\\n                rook.x = i;\\n                rook.y = j;\\n            }\\n        }\\n    }\\n\\n    // horizontal\\n    look(rows[rook.x]);\\n    // vertical\\n    look(cols[rook.y]);\\n\\n    // captures after looks\\n    return captures;\\n\\n    /**\\n     * negative: /p\\\\.*R/ - left, up\\n     * positive: /R\\\\.*p/ - right, down\\n     * ======== ======== ========\\n     */\\n    function look(value) {\\n        // negative\\n        if (/p\\\\.*R/.test(value)) {\\n            captures++;\\n        }\\n        // positive\\n        if (/R\\\\.*p/.test(value)) {\\n            captures++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nconst numRookCaptures = board => {\\n    // set checker grids\\n    const rows = new Array(8).fill(\\'\\'), cols = new Array(8).fill(\\'\\');\\n\\n    // set rook and capture travel\\n    let rook = { x: -1, y: -1 }, captures = 0;\\n\\n    for (let i = 0; i < 8; i++) {\\n        for (let j = 0; j < 8; j++) {\\n            rows[i] += board[i][j];\\n            cols[i] += board[j][i];\\n            \\n            if (board[i][j] === `R`) {\\n                rook.x = i;\\n                rook.y = j;\\n            }\\n        }\\n    }\\n\\n    // horizontal\\n    look(rows[rook.x]);\\n    // vertical\\n    look(cols[rook.y]);\\n\\n    // captures after looks\\n    return captures;\\n\\n    /**\\n     * negative: /p\\\\.*R/ - left, up\\n     * positive: /R\\\\.*p/ - right, down\\n     * ======== ======== ========\\n     */\\n    function look(value) {\\n        // negative\\n        if (/p\\\\.*R/.test(value)) {\\n            captures++;\\n        }\\n        // positive\\n        if (/R\\\\.*p/.test(value)) {\\n            captures++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841822,
                "title": "python-solution-999",
                "content": "```\\nclass Solution:\\n  def numRookCaptures(self, board: List[List[str]]) -> int:\\n    ans = 0\\n\\n    for i in range(8):\\n      for j in range(8):\\n        if board[i][j] == \\'R\\':\\n          i0 = i\\n          j0 = j\\n\\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n      i = i0 + d[0]\\n      j = j0 + d[1]\\n      while 0 <= i < 8 and 0 <= j < 8:\\n        if board[i][j] == \\'p\\':\\n          ans += 1\\n        if board[i][j] != \\'.\\':\\n          break\\n        i += d[0]\\n        j += d[1]\\n\\n    return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n  def numRookCaptures(self, board: List[List[str]]) -> int:\\n    ans = 0\\n\\n    for i in range(8):\\n      for j in range(8):\\n        if board[i][j] == \\'R\\':\\n          i0 = i\\n          j0 = j\\n\\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n      i = i0 + d[0]\\n      j = j0 + d[1]\\n      while 0 <= i < 8 and 0 <= j < 8:\\n        if board[i][j] == \\'p\\':\\n          ans += 1\\n        if board[i][j] != \\'.\\':\\n          break\\n        i += d[0]\\n        j += d[1]\\n\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751788,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int xi=0,yj=0,check=0,count=0;\\n        \\n        // get Rook coordinates     \\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[i].length;j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    xi=i;\\n                    yj=j;\\n                    check=1;\\n                    break;\\n                }\\n            }\\n            if(check==1)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        // Check west\\n        for(int j=yj;j>=0;j--)\\n        {\\n            char c=board[xi][j];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        // Check east\\n        for(int j=yj;j<board[xi].length;j++)\\n        {\\n            char c=board[xi][j];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        // Check north\\n        for(int i=xi;i>=0;i--)\\n        {\\n            char c=board[i][yj];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        // Check South\\n        for(int i=xi;i<board.length;i++)\\n        {\\n            char c=board[i][yj];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int xi=0,yj=0,check=0,count=0;\\n        \\n        // get Rook coordinates     \\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[i].length;j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    xi=i;\\n                    yj=j;\\n                    check=1;\\n                    break;\\n                }\\n            }\\n            if(check==1)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        // Check west\\n        for(int j=yj;j>=0;j--)\\n        {\\n            char c=board[xi][j];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        // Check east\\n        for(int j=yj;j<board[xi].length;j++)\\n        {\\n            char c=board[xi][j];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        // Check north\\n        for(int i=xi;i>=0;i--)\\n        {\\n            char c=board[i][yj];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        // Check South\\n        for(int i=xi;i<board.length;i++)\\n        {\\n            char c=board[i][yj];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613578,
                "title": "0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int r=0,c=0,attack=0;\\n        \\n        for(r=0;r<8;r++){\\n            for(c=0;c<8;c++){\\n                if(board[r][c] == \\'R\\')  break;\\n            }\\n            if(c!=8)    break;\\n        }\\n               \\n        for(int i=r+1;i<8;i++){\\n            if(board[i][c] == \\'p\\'){\\n                attack++;\\n                break;\\n            }   \\n            else if(board[i][c] == \\'B\\') break;\\n        }\\n\\n        \\n        for(int i=c+1;i<8;i++){\\n            if(board[r][i] == \\'p\\'){\\n                attack++;\\n                break;\\n            }    \\n            else if(board[r][i] == \\'B\\') break;\\n        }\\n        \\n        for(int i=r-1;i>=0;i--){\\n            if(board[i][c] == \\'p\\'){\\n                attack++;\\n                break;\\n            }    \\n            else if(board[i][c] == \\'B\\') break;\\n        }\\n        \\n        for(int i=c-1;i>=0;i--){\\n            if(board[r][i] == \\'p\\'){\\n                attack++;\\n                break;\\n            }    \\n            else if(board[r][i] == \\'B\\') break;\\n        }\\n        \\n        return attack;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int r=0,c=0,attack=0;\\n        \\n        for(r=0;r<8;r++){\\n            for(c=0;c<8;c++){\\n                if(board[r][c] == \\'R\\')  break;\\n            }\\n            if(c!=8)    break;\\n        }\\n               \\n        for(int i=r+1;i<8;i++){\\n            if(board[i][c] == \\'p\\'){\\n                attack++;\\n                break;\\n            }   \\n            else if(board[i][c] == \\'B\\') break;\\n        }\\n\\n        \\n        for(int i=c+1;i<8;i++){\\n            if(board[r][i] == \\'p\\'){\\n                attack++;\\n                break;\\n            }    \\n            else if(board[r][i] == \\'B\\') break;\\n        }\\n        \\n        for(int i=r-1;i>=0;i--){\\n            if(board[i][c] == \\'p\\'){\\n                attack++;\\n                break;\\n            }    \\n            else if(board[i][c] == \\'B\\') break;\\n        }\\n        \\n        for(int i=c-1;i>=0;i--){\\n            if(board[r][i] == \\'p\\'){\\n                attack++;\\n                break;\\n            }    \\n            else if(board[r][i] == \\'B\\') break;\\n        }\\n        \\n        return attack;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588226,
                "title": "easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int x,y;\\n        for(int i=0;i<8;i++)\\n        {\\n            for(int j=0;j<8;j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    x=i;\\n                    y=j;\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        int count=0;\\n        //upward;\\n        int p=x;\\n        int q=y;\\n        while(p>=0 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            p--;\\n            \\n        }\\n        //down\\n        \\n        p=x;\\n        q=y;\\n        \\n          while(p<8 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            p++;\\n            \\n        }\\n        //right\\n        \\n        p=x;\\n        q=y;\\n        \\n        while(q<8 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            q++;\\n        }\\n        \\n        p=x;\\n        q=y;\\n        //left\\n          while(q>=0 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            q--;\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int x,y;\\n        for(int i=0;i<8;i++)\\n        {\\n            for(int j=0;j<8;j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    x=i;\\n                    y=j;\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        int count=0;\\n        //upward;\\n        int p=x;\\n        int q=y;\\n        while(p>=0 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            p--;\\n            \\n        }\\n        //down\\n        \\n        p=x;\\n        q=y;\\n        \\n          while(p<8 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            p++;\\n            \\n        }\\n        //right\\n        \\n        p=x;\\n        q=y;\\n        \\n        while(q<8 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            q++;\\n        }\\n        \\n        p=x;\\n        q=y;\\n        //left\\n          while(q>=0 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            q--;\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572858,
                "title": "java-very-readable-solution",
                "content": "```\\npublic int numRookCaptures(char[][] board) \\n    {\\n        // Find the rook\\n        int rookRow = 0, rookCol = 0;\\n        for (int row = 0; row < board.length; row++)\\n            for (int col = 0; col < board[0].length; col++)\\n                if (board[row][col] == \\'R\\')\\n                {\\n                    rookRow = row;\\n                    rookCol = col;\\n                    break;\\n                }\\n        \\n        // Setup attacks and hashset of friendly pieces\\n        int attacks = 0;\\n        Set<Character> friendly = new HashSet<Character>(Arrays.asList(\\'B\\', \\'R\\'));\\n        \\n        // Find North attacks\\n        for (int row = rookRow-1; row > -1; row--)\\n        {\\n            if (friendly.contains(board[row][rookCol])) break;\\n            else if (board[row][rookCol] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        // Find South attacks\\n        for (int row = rookRow+1; row < board.length; row++)\\n        {\\n            if (friendly.contains(board[row][rookCol])) break;\\n            else if (board[row][rookCol] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        // Find East attacks\\n        for (int col = rookCol+1; col < board[0].length; col++)\\n        {\\n            if (friendly.contains(board[rookRow][col])) break;\\n            else if (board[rookRow][col] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        // Find West attacks\\n        for (int col = rookCol-1; col > -1; col--)\\n        {\\n            if (friendly.contains(board[rookRow][col])) break;\\n            else if (board[rookRow][col] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        return attacks;\\n    }\\n```\\nThe general idea for my solution was to treat it like a human would play chess.\\n1) Find the rook square, since it\\'s not given\\n2) Identify friendly pieces the rook cannot pass\\n3) Find enemy pieces the rook can attack\\n\\nThe code can definitely be more modular, but is pretty straightforward as is.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numRookCaptures(char[][] board) \\n    {\\n        // Find the rook\\n        int rookRow = 0, rookCol = 0;\\n        for (int row = 0; row < board.length; row++)\\n            for (int col = 0; col < board[0].length; col++)\\n                if (board[row][col] == \\'R\\')\\n                {\\n                    rookRow = row;\\n                    rookCol = col;\\n                    break;\\n                }\\n        \\n        // Setup attacks and hashset of friendly pieces\\n        int attacks = 0;\\n        Set<Character> friendly = new HashSet<Character>(Arrays.asList(\\'B\\', \\'R\\'));\\n        \\n        // Find North attacks\\n        for (int row = rookRow-1; row > -1; row--)\\n        {\\n            if (friendly.contains(board[row][rookCol])) break;\\n            else if (board[row][rookCol] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        // Find South attacks\\n        for (int row = rookRow+1; row < board.length; row++)\\n        {\\n            if (friendly.contains(board[row][rookCol])) break;\\n            else if (board[row][rookCol] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        // Find East attacks\\n        for (int col = rookCol+1; col < board[0].length; col++)\\n        {\\n            if (friendly.contains(board[rookRow][col])) break;\\n            else if (board[rookRow][col] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        // Find West attacks\\n        for (int col = rookCol-1; col > -1; col--)\\n        {\\n            if (friendly.contains(board[rookRow][col])) break;\\n            else if (board[rookRow][col] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        return attacks;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1551631,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        fn calc_cap(it: impl Iterator<Item = char>, rook_pos: usize) -> i32 {\\n            let (mut res, mut num) = (0, 0);\\n            for (pos, fig) in it.enumerate() {\\n                match (fig, pos < rook_pos) {\\n                    (\\'R\\', _) => res += num,\\n                    (\\'p\\', true) => num = 1,\\n                    (\\'B\\', true) => num = 0,\\n                    (\\'p\\', false) => return res + 1,\\n                    (\\'B\\', false) => return res,\\n                    _ => (),\\n                }\\n            }\\n            res\\n        }\\n\\n        for (y, row) in board.iter().enumerate() {\\n            if let Some(x) = row.iter().position(|c| *c == \\'R\\') {\\n                let row_it = row.iter().cloned();\\n                let col_it = (0..8_usize).map(|i| board[i][x]);\\n                return calc_cap(row_it, x) + calc_cap(col_it, y);\\n            }\\n        }\\n\\n        unreachable!()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        fn calc_cap(it: impl Iterator<Item = char>, rook_pos: usize) -> i32 {\\n            let (mut res, mut num) = (0, 0);\\n            for (pos, fig) in it.enumerate() {\\n                match (fig, pos < rook_pos) {\\n                    (\\'R\\', _) => res += num,\\n                    (\\'p\\', true) => num = 1,\\n                    (\\'B\\', true) => num = 0,\\n                    (\\'p\\', false) => return res + 1,\\n                    (\\'B\\', false) => return res,\\n                    _ => (),\\n                }\\n            }\\n            res\\n        }\\n\\n        for (y, row) in board.iter().enumerate() {\\n            if let Some(x) = row.iter().position(|c| *c == \\'R\\') {\\n                let row_it = row.iter().cloned();\\n                let col_it = (0..8_usize).map(|i| board[i][x]);\\n                return calc_cap(row_it, x) + calc_cap(col_it, y);\\n            }\\n        }\\n\\n        unreachable!()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348805,
                "title": "100-efficient-c-sol",
                "content": "int numRookCaptures(vector<vector<char>>& board) {\\n        int i=0,j=0;\\n        int tempi,tempj;\\n        for(i=0;i<=board.size()-1;i++)\\n        {\\n            for(j=0;j<=board[0].size()-1;j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    tempi=i;\\n                    tempj=j;\\n                   break; \\n                }\\n            }\\n        }\\n        int count=0;\\n        for(j=tempj;j<=7;j++)\\n        {\\n            if(board[tempi][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[tempi][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        i=tempi;\\n        for(j=tempj;j>=0;j--)\\n        {\\n            if(board[i][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[i][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        j=tempj;\\n        for(i=tempi;i<=7;i++)\\n        {\\n            if(board[i][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[i][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        j=tempj;\\n        for(i=tempi;i>=0;i--)\\n        {\\n            if(board[i][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[i][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "int numRookCaptures(vector<vector<char>>& board) {\\n        int i=0,j=0;\\n        int tempi,tempj;\\n        for(i=0;i<=board.size()-1;i++)\\n        {\\n            for(j=0;j<=board[0].size()-1;j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    tempi=i;\\n                    tempj=j;\\n                   break; \\n                }\\n            }\\n        }\\n        int count=0;\\n        for(j=tempj;j<=7;j++)\\n        {\\n            if(board[tempi][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[tempi][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        i=tempi;\\n        for(j=tempj;j>=0;j--)\\n        {\\n            if(board[i][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[i][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        j=tempj;\\n        for(i=tempi;i<=7;i++)\\n        {\\n            if(board[i][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[i][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        j=tempj;\\n        for(i=tempi;i>=0;i--)\\n        {\\n            if(board[i][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[i][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1345291,
                "title": "python-solution-97-faster",
                "content": "class Solution:\\n*     def numRookCaptures(self, b: List[List[str]]) -> int:\\n        count=[0]*4\\n        row,col=0,0\\n        for i in range(0,8):\\n            for j in range(0,8):\\n                if(b[i][j]==\\'R\\'):\\n                    row=i\\n                    col=j\\n                    break\\n        for i in range(0,8):\\n            if(i==row):\\n                for j in range(0,8):\\n                    if(j<col):\\n                        if(b[row][j]==\\'B\\'):\\n                            count[0]=0\\n                        elif(b[row][j]==\\'p\\'):\\n                            count[0]=1\\n                    else:\\n                        if(b[row][j]==\\'B\\'):\\n                            break\\n                        elif(b[row][j]==\\'p\\'):\\n                            count[1]=1\\n            else:\\n                if(i<row):\\n                    if(b[i][col]==\\'B\\'):\\n                        count[2]=0\\n                    elif(b[i][col]==\\'p\\'):\\n                        count[2]=1\\n                else:\\n                    if(b[i][col]==\\'B\\'):\\n                        break\\n                    elif(b[i][col]==\\'p\\'):\\n                        count[3]=1\\n        return sum(count)",
                "solutionTags": [],
                "code": "class Solution:\\n*     def numRookCaptures(self, b: List[List[str]]) -> int:\\n        count=[0]*4\\n        row,col=0,0\\n        for i in range(0,8):\\n            for j in range(0,8):\\n                if(b[i][j]==\\'R\\'):\\n                    row=i\\n                    col=j\\n                    break\\n        for i in range(0,8):\\n            if(i==row):\\n                for j in range(0,8):\\n                    if(j<col):\\n                        if(b[row][j]==\\'B\\'):\\n                            count[0]=0\\n                        elif(b[row][j]==\\'p\\'):\\n                            count[0]=1\\n                    else:\\n                        if(b[row][j]==\\'B\\'):\\n                            break\\n                        elif(b[row][j]==\\'p\\'):\\n                            count[1]=1\\n            else:\\n                if(i<row):\\n                    if(b[i][col]==\\'B\\'):\\n                        count[2]=0\\n                    elif(b[i][col]==\\'p\\'):\\n                        count[2]=1\\n                else:\\n                    if(b[i][col]==\\'B\\'):\\n                        break\\n                    elif(b[i][col]==\\'p\\'):\\n                        count[3]=1\\n        return sum(count)",
                "codeTag": "Java"
            },
            {
                "id": 1289087,
                "title": "easy-c-solution-0-ms-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int r,c, i, j, ans = 0;\\n        //Find the position of Rook\\n        for(i = 0; i < 8; i ++){\\n            for(j = 0; j < 8; j ++){\\n                if(board[i][j] == \\'R\\'){\\n                    r = i;\\n                    c = j;\\n                    goto stop;\\n                }\\n            }\\n        }\\n        stop:\\n        // Traverse Right\\n        for(j = c; j < 8; j ++){\\n            if(board[r][j] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[r][j] == \\'B\\')\\n                break;\\n        }\\n        // Traverse Left\\n        for(j = c; j >= 0; j --){\\n            if(board[r][j] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[r][j] == \\'B\\')\\n                break;\\n        }\\n        // Traverse Up\\n        for(i = r; i >=0; i --){\\n            if(board[i][c] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][c] == \\'B\\')\\n                break;\\n        }\\n        // Traverse Down\\n        for(i = r; i < 8; i ++){\\n            if(board[i][c] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][c] == \\'B\\')\\n                break; \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int r,c, i, j, ans = 0;\\n        //Find the position of Rook\\n        for(i = 0; i < 8; i ++){\\n            for(j = 0; j < 8; j ++){\\n                if(board[i][j] == \\'R\\'){\\n                    r = i;\\n                    c = j;\\n                    goto stop;\\n                }\\n            }\\n        }\\n        stop:\\n        // Traverse Right\\n        for(j = c; j < 8; j ++){\\n            if(board[r][j] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[r][j] == \\'B\\')\\n                break;\\n        }\\n        // Traverse Left\\n        for(j = c; j >= 0; j --){\\n            if(board[r][j] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[r][j] == \\'B\\')\\n                break;\\n        }\\n        // Traverse Up\\n        for(i = r; i >=0; i --){\\n            if(board[i][c] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][c] == \\'B\\')\\n                break;\\n        }\\n        // Traverse Down\\n        for(i = r; i < 8; i ++){\\n            if(board[i][c] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][c] == \\'B\\')\\n                break; \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198905,
                "title": "c-faster-than-100-using-only-two-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int x=-1,y=-1;\\n        vector<vector<int>>dir={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if(board[i][j]==\\'R\\'){\\n                    x=i,y=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<4;i++){\\n            int p=x+dir[i][0],q=y+dir[i][1];\\n            while(p>=0&&p<8&&q>=0&&q<8){\\n                \\n                if(board[p][q]==\\'p\\'){\\n                    cnt++;\\n                    break;\\n                }\\n                if(board[p][q]==\\'B\\')\\n                    break;\\n               \\n                p+=dir[i][0];\\n                q+=dir[i][1];\\n            }\\n        }\\n       \\n        return cnt;\\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int x=-1,y=-1;\\n        vector<vector<int>>dir={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if(board[i][j]==\\'R\\'){\\n                    x=i,y=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<4;i++){\\n            int p=x+dir[i][0],q=y+dir[i][1];\\n            while(p>=0&&p<8&&q>=0&&q<8){\\n                \\n                if(board[p][q]==\\'p\\'){\\n                    cnt++;\\n                    break;\\n                }\\n                if(board[p][q]==\\'B\\')\\n                    break;\\n               \\n                p+=dir[i][0];\\n                q+=dir[i][1];\\n            }\\n        }\\n       \\n        return cnt;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170119,
                "title": "java-100-0ms-easy-solution",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int total = 0;\\n        int r = 0;\\n        int c = 0;\\n        for(int i=0; i<8;++i){\\n            for(int j=0; j<8; ++j){\\n                char t = board[i][j];\\n                if(t == \\'R\\'){\\n                    r = i;\\n                    c = j;\\n                    break;\\n                }\\n            }\\n        }\\n        //south\\n        int temp = r;\\n        while(temp >= 0){\\n            if(board[temp][c] == \\'B\\'){\\n                break;\\n            }\\n            if(board[temp][c] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp--;\\n        }\\n        //north\\n        temp = r;\\n        while(temp < 8){\\n            if(board[temp][c] == \\'B\\'){\\n                break;\\n            }\\n            if(board[temp][c] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp++;\\n        }\\n        //east\\n        temp = c;\\n        while(temp < 8){\\n            if(board[r][temp] == \\'B\\'){\\n                break;\\n            }\\n            if(board[r][temp] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp++;\\n        }\\n        //west\\n        temp = c;\\n        while(temp >= 0){\\n            if(board[r][temp] == \\'B\\'){\\n                break;\\n            }\\n            if(board[r][temp] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp--;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int total = 0;\\n        int r = 0;\\n        int c = 0;\\n        for(int i=0; i<8;++i){\\n            for(int j=0; j<8; ++j){\\n                char t = board[i][j];\\n                if(t == \\'R\\'){\\n                    r = i;\\n                    c = j;\\n                    break;\\n                }\\n            }\\n        }\\n        //south\\n        int temp = r;\\n        while(temp >= 0){\\n            if(board[temp][c] == \\'B\\'){\\n                break;\\n            }\\n            if(board[temp][c] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp--;\\n        }\\n        //north\\n        temp = r;\\n        while(temp < 8){\\n            if(board[temp][c] == \\'B\\'){\\n                break;\\n            }\\n            if(board[temp][c] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp++;\\n        }\\n        //east\\n        temp = c;\\n        while(temp < 8){\\n            if(board[r][temp] == \\'B\\'){\\n                break;\\n            }\\n            if(board[r][temp] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp++;\\n        }\\n        //west\\n        temp = c;\\n        while(temp >= 0){\\n            if(board[r][temp] == \\'B\\'){\\n                break;\\n            }\\n            if(board[r][temp] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp--;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143919,
                "title": "simple-solution",
                "content": "```python\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \\'R\\':\\n                    attack = 0\\n                    for di, dj in ((0,1), (1,0), (0,-1), (-1,0)):\\n                        ci, cj = i, j\\n                        while 0 <= ci < 8 and 0 <= cj < 8:\\n                            if board[ci][cj] in (\\'p\\', \\'B\\'):\\n                                attack += board[ci][cj] == \\'p\\'\\n                                break\\n                            ci += di\\n                            cj += dj\\n                    return attack\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \\'R\\':\\n                    attack = 0\\n                    for di, dj in ((0,1), (1,0), (0,-1), (-1,0)):\\n                        ci, cj = i, j\\n                        while 0 <= ci < 8 and 0 <= cj < 8:\\n                            if board[ci][cj] in (\\'p\\', \\'B\\'):\\n                                attack += board[ci][cj] == \\'p\\'\\n                                break\\n                            ci += di\\n                            cj += dj\\n                    return attack\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127901,
                "title": "c-recursion-without-dp-0-faster-than-100",
                "content": "This is a really noob approach from my side, suggestions are welcome on improvements.\\n\\nThought Process:\\n1. Already had the base conditions up par so basic process of recursion was completed.\\n2. Create a recursion which moves the rook up/down/left/right\\n\\n```\\nclass Solution {\\npublic:\\n    int capturePawnUp(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnUp(board, R, C, rowOfRook - 1, columnOfRook);\\n    };\\n    \\n    int capturePawnDown(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnDown(board, R, C, rowOfRook + 1, columnOfRook);\\n    };\\n    \\n    int capturePawnLeft(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnLeft(board, R, C, rowOfRook, columnOfRook - 1);\\n    };\\n    \\n    int capturePawnRight(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnRight(board, R, C, rowOfRook, columnOfRook + 1);\\n    };\\n    \\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int row = 8, column = 8;\\n        int rowOfRook = 0;\\n        int columnOfRook = 0;\\n        \\n        for(int i = 0; i < board.size(); i++) {\\n            for(int j = 0; j < board.size(); j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    rowOfRook = i;\\n                    columnOfRook = j;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        \\n        int value = (capturePawnUp(board, row, column, rowOfRook, columnOfRook) \\n\\t\\t+ capturePawnDown(board, row, column, rowOfRook, columnOfRook) \\n\\t\\t+ capturePawnLeft(board, row, column, rowOfRook, columnOfRook) \\n\\t\\t+ capturePawnRight(board, row, column, rowOfRook, columnOfRook));\\n        return value;\\n    }\\n};                                                                                                                                                                                                                                                                                                                                               \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int capturePawnUp(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnUp(board, R, C, rowOfRook - 1, columnOfRook);\\n    };\\n    \\n    int capturePawnDown(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnDown(board, R, C, rowOfRook + 1, columnOfRook);\\n    };\\n    \\n    int capturePawnLeft(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnLeft(board, R, C, rowOfRook, columnOfRook - 1);\\n    };\\n    \\n    int capturePawnRight(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnRight(board, R, C, rowOfRook, columnOfRook + 1);\\n    };\\n    \\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int row = 8, column = 8;\\n        int rowOfRook = 0;\\n        int columnOfRook = 0;\\n        \\n        for(int i = 0; i < board.size(); i++) {\\n            for(int j = 0; j < board.size(); j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    rowOfRook = i;\\n                    columnOfRook = j;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        \\n        int value = (capturePawnUp(board, row, column, rowOfRook, columnOfRook) \\n\\t\\t+ capturePawnDown(board, row, column, rowOfRook, columnOfRook) \\n\\t\\t+ capturePawnLeft(board, row, column, rowOfRook, columnOfRook) \\n\\t\\t+ capturePawnRight(board, row, column, rowOfRook, columnOfRook));\\n        return value;\\n    }\\n};                                                                                                                                                                                                                                                                                                                                               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067520,
                "title": "python-3-simple-to-understand-beats-97",
                "content": "```\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n        lst=[]\\n        st=\\'\\'\\n        st1=\\'\\'\\n        for i in range(0,8):\\n            for j in range(0,8):\\n                if board[i][j]==\\'R\\':\\n                    m=i\\n                    n=j\\n        for i in range(0,8):\\n            lst.append(board[i][n])\\n        for i in range(0,8):\\n            if lst[i]!=\\'.\\':\\n                st+=lst[i]\\n            if board[m][i]!=\\'.\\':\\n                st1+=board[m][i]\\n        return st.count(\\'Rp\\')+st.count(\\'pR\\')+st1.count(\\'Rp\\')+st1.count(\\'pR\\')\\n        \\n```",
                "solutionTags": [],
                "code": "```\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n        lst=[]\\n        st=\\'\\'\\n        st1=\\'\\'\\n        for i in range(0,8):\\n            for j in range(0,8):\\n                if board[i][j]==\\'R\\':\\n                    m=i\\n                    n=j\\n        for i in range(0,8):\\n            lst.append(board[i][n])\\n        for i in range(0,8):\\n            if lst[i]!=\\'.\\':\\n                st+=lst[i]\\n            if board[m][i]!=\\'.\\':\\n                st1+=board[m][i]\\n        return st.count(\\'Rp\\')+st.count(\\'pR\\')+st1.count(\\'Rp\\')+st1.count(\\'pR\\')\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 956288,
                "title": "java-100-easy-to-understand",
                "content": "\\tclass Solution {\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    public int numRookCaptures(char[][] board) {\\n        int[] Rrc = new int[2]; \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    Rrc[0] = i;\\n                    Rrc[1] = j;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int[] dir : dirs){\\n            int x = dir[0] + Rrc[0];\\n            int y = dir[1] + Rrc[1];\\n            while(x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] == \\'.\\'){\\n                x += dir[0];\\n                y += dir[1];\\n            }\\n            if(x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y] == \\'B\\')\\n                continue;\\n            \\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    int[][] dirs = {{-1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 859534,
                "title": "0ms-faster-than-100-solution-java",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] b) {\\n        for (int i=0;i<b.length;i++){\\n            for (int j=0;j<b[0].length;j++){\\n                if (b[i][j]==\\'R\\')\\n                    return get(b,i,j,0,1)+get(b,i,j,0,-1)+get(b,i,j,1,0)+get(b,i,j,-1,0);\\n            }\\n        }\\n        return 0;\\n    }\\n    public int get(char[][] b,int i,int j,int x,int y){\\n        while (i>=0 && i<b.length && j>=0 && j<b[0].length && b[i][j]!=\\'B\\'){\\n            if (b[i][j]==\\'p\\') return 1;\\n            i+=x;\\n            j+=y;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] b) {\\n        for (int i=0;i<b.length;i++){\\n            for (int j=0;j<b[0].length;j++){\\n                if (b[i][j]==\\'R\\')\\n                    return get(b,i,j,0,1)+get(b,i,j,0,-1)+get(b,i,j,1,0)+get(b,i,j,-1,0);\\n            }\\n        }\\n        return 0;\\n    }\\n    public int get(char[][] b,int i,int j,int x,int y){\\n        while (i>=0 && i<b.length && j>=0 && j<b[0].length && b[i][j]!=\\'B\\'){\\n            if (b[i][j]==\\'p\\') return 1;\\n            i+=x;\\n            j+=y;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846263,
                "title": "go-straightforward-solution-0ms",
                "content": "https://github.com/phea/leetcode-go\\n\\n```go\\nfunc numRookCaptures(board [][]byte) int {\\n    var row, col int\\n    for i := 0; i < 8; i++ {\\n        for j := 0; j < 8; j++ {\\n            if board[i][j] == byte(\\'R\\'){\\n                row, col = i, j\\n            }\\n        }\\n    }\\n    \\n    \\n    var count int\\n    // north\\n    for i := row-1; i >= 0; i-- {\\n        if board[i][col] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[i][col] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    //south\\n    for i := row+1; i < 8; i++ {\\n        if board[i][col] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[i][col] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    // east\\n    for j := col+1; j < 8; j++ {\\n        if board[row][j] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[row][j] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    // west\\n    for j := col-1; j >= 0; j-- {\\n        if board[row][j] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[row][j] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc numRookCaptures(board [][]byte) int {\\n    var row, col int\\n    for i := 0; i < 8; i++ {\\n        for j := 0; j < 8; j++ {\\n            if board[i][j] == byte(\\'R\\'){\\n                row, col = i, j\\n            }\\n        }\\n    }\\n    \\n    \\n    var count int\\n    // north\\n    for i := row-1; i >= 0; i-- {\\n        if board[i][col] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[i][col] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    //south\\n    for i := row+1; i < 8; i++ {\\n        if board[i][col] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[i][col] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    // east\\n    for j := col+1; j < 8; j++ {\\n        if board[row][j] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[row][j] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    // west\\n    for j := col-1; j >= 0; j-- {\\n        if board[row][j] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[row][j] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816547,
                "title": "javascript-short-with-explain",
                "content": "To reduce loops, go only ones through all elements and capture (row, column) position of each.\\nThen testing values on each direction.\\n\\n```\\nvar numRookCaptures = function(b) {\\n    let p=[];    let R =[];    let B = [];    let res=0;\\n    for(let q=0; q<8; q++){\\n        for(let w=0; w<8; w++){\\n            if(b[q][w] == \"p\") p.push([q,w]);\\n            if(b[q][w] == \"R\") R.push(q,w);\\n            if(b[q][w] == \"B\") B.push([q,w]);\\n        }\\n    }\\n\\n    //go up\\n    if(p.some(x => x[1] == R[1] && x[0] < R[0] && !(B.some(y => y[1] == R[1] && y[0] < R[0] && y[0] > x[0]) ))) res++;\\n    //go down\\n    if(p.some(x => x[1] == R[1] && x[0] > R[0] && !(B.some(y => y[1] == R[1] && y[0] > R[0] && y[0] < x[0]) ))) res++;\\n    //go left\\n    if(p.some(x => x[0] == R[0] && x[1] < R[1] && !(B.some(y => y[0] == R[0] && y[1] < R[1] && y[1] > x[1]) ))) res++;\\n    //go right\\n    if(p.some(x => x[0] == R[0] && x[1] > R[1] && !(B.some(y => y[0] == R[0] && y[1] > R[1] && y[1] < x[1]) ))) res++;\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numRookCaptures = function(b) {\\n    let p=[];    let R =[];    let B = [];    let res=0;\\n    for(let q=0; q<8; q++){\\n        for(let w=0; w<8; w++){\\n            if(b[q][w] == \"p\") p.push([q,w]);\\n            if(b[q][w] == \"R\") R.push(q,w);\\n            if(b[q][w] == \"B\") B.push([q,w]);\\n        }\\n    }\\n\\n    //go up\\n    if(p.some(x => x[1] == R[1] && x[0] < R[0] && !(B.some(y => y[1] == R[1] && y[0] < R[0] && y[0] > x[0]) ))) res++;\\n    //go down\\n    if(p.some(x => x[1] == R[1] && x[0] > R[0] && !(B.some(y => y[1] == R[1] && y[0] > R[0] && y[0] < x[0]) ))) res++;\\n    //go left\\n    if(p.some(x => x[0] == R[0] && x[1] < R[1] && !(B.some(y => y[0] == R[0] && y[1] < R[1] && y[1] > x[1]) ))) res++;\\n    //go right\\n    if(p.some(x => x[0] == R[0] && x[1] > R[1] && !(B.some(y => y[0] == R[0] && y[1] > R[1] && y[1] < x[1]) ))) res++;\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 804547,
                "title": "python-2-liner-w-explanation",
                "content": "**1.** Create (join) a string for each row and column(zip rows) without periods (\".\").\\n**2.** Iterate the resulting strings, skipping empty strings.\\n**3.** Add a capture if \"Rp\" is in the string and add a capture if \"pR\" is in the string.\\n* *This could be one line but the readability would suffer (more).*\\n```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        l = [\\'\\'.join([c for c in r if c != \\'.\\']) for r in board + list(zip(*board))]\\n        return sum([1 if t in x else 0 for t in (\\'Rp\\', \\'pR\\') for x in l if x])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        l = [\\'\\'.join([c for c in r if c != \\'.\\']) for r in board + list(zip(*board))]\\n        return sum([1 if t in x else 0 for t in (\\'Rp\\', \\'pR\\') for x in l if x])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803068,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        row, col = 0, 0\\n        num = 0\\n        \\n        for i in range(8) :\\n            for j in range(8) :\\n                if board[i][j] == \\'R\\' :\\n                    row, col = i, j\\n                    break\\n        \\n        for i, j in [(0,-1),(0,1),(1,0),(-1,0)] :\\n            \\n            ci, cj = row+i, col+j\\n            \\n            while 0<=ci<8 and 0<=cj<8 :\\n                \\n                if board[ci][cj] == \\'p\\' :\\n                    num += 1\\n                if board[ci][cj] != \\'.\\' :\\n                    break\\n                \\n                ci += i\\n                cj += j\\n                \\n        return num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        row, col = 0, 0\\n        num = 0\\n        \\n        for i in range(8) :\\n            for j in range(8) :\\n                if board[i][j] == \\'R\\' :\\n                    row, col = i, j\\n                    break\\n        \\n        for i, j in [(0,-1),(0,1),(1,0),(-1,0)] :\\n            \\n            ci, cj = row+i, col+j\\n            \\n            while 0<=ci<8 and 0<=cj<8 :\\n                \\n                if board[ci][cj] == \\'p\\' :\\n                    num += 1\\n                if board[ci][cj] != \\'.\\' :\\n                    break\\n                \\n                ci += i\\n                cj += j\\n                \\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761475,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int row, col;\\n        int count = 0;\\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==\\'R\\'){\\n                    row = i;\\n                    col = j;\\n                }\\n            }\\n        }\\n        int i=row-1, j=col;\\n        while(i>=0 && board[i][j]==\\'.\\') i--;\\n        if(i>=0 && board[i][j]==\\'p\\') count++;\\n\\t\\t\\n        i=row+1, j=col;\\n        while(i<board.size() && board[i][j]==\\'.\\') i++;\\n        if(i<board.size() && board[i][j]==\\'p\\') count++;\\n        \\n        i=row, j=col-1;\\n        while(j>=0 && board[i][j]==\\'.\\') j--;\\n        if(j>=0 && board[i][j]==\\'p\\') count++;\\n\\t\\t\\n        i=row, j=col+1;\\n        while(j<board[0].size() && board[i][j]==\\'.\\') j++;\\n        if(j<board[0].size() && board[i][j]==\\'p\\') count++;\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int row, col;\\n        int count = 0;\\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==\\'R\\'){\\n                    row = i;\\n                    col = j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 760745,
                "title": "goto-solution",
                "content": "```\\nint numRookCaptures(vector<vector<char>>& b) \\n{\\n\\tauto r_i{0}, r_j{0};\\n\\n\\tfor(; r_i < 8; ++r_i)\\n\\t\\tfor(r_j = 0; r_j < 8; ++r_j)\\n\\t\\t\\tif(b[r_i][r_j] == \\'R\\') goto rook_found;\\n\\n\\trook_found:\\n\\n\\tint out{0};\\n\\n\\tfor(auto j{r_j+1}; j < 8; ++j)\\n\\t   if(b[r_i][j] != \\'.\\') \\n\\t   {\\n\\t\\t   out += (b[r_i][j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\tfor(auto j{r_j-1}; j >= 0; --j)\\n\\t   if(b[r_i][j] != \\'.\\')\\n\\t   {\\n\\t\\t   out += (b[r_i][j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\tfor(auto i{r_i+1}; i < 8; ++i)\\n\\t   if(b[i][r_j] != \\'.\\')\\n\\t   {\\n\\t\\t   out += (b[i][r_j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\tfor(auto i{r_i-1}; i >= 0; --i)\\n\\t   if(b[i][r_j] != \\'.\\')\\n\\t   {\\n\\t\\t   out += (b[i][r_j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numRookCaptures(vector<vector<char>>& b) \\n{\\n\\tauto r_i{0}, r_j{0};\\n\\n\\tfor(; r_i < 8; ++r_i)\\n\\t\\tfor(r_j = 0; r_j < 8; ++r_j)\\n\\t\\t\\tif(b[r_i][r_j] == \\'R\\') goto rook_found;\\n\\n\\trook_found:\\n\\n\\tint out{0};\\n\\n\\tfor(auto j{r_j+1}; j < 8; ++j)\\n\\t   if(b[r_i][j] != \\'.\\') \\n\\t   {\\n\\t\\t   out += (b[r_i][j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\tfor(auto j{r_j-1}; j >= 0; --j)\\n\\t   if(b[r_i][j] != \\'.\\')\\n\\t   {\\n\\t\\t   out += (b[r_i][j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\tfor(auto i{r_i+1}; i < 8; ++i)\\n\\t   if(b[i][r_j] != \\'.\\')\\n\\t   {\\n\\t\\t   out += (b[i][r_j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\tfor(auto i{r_i-1}; i >= 0; --i)\\n\\t   if(b[i][r_j] != \\'.\\')\\n\\t   {\\n\\t\\t   out += (b[i][r_j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751047,
                "title": "java-dfs-solution-100-faster-0ms",
                "content": "```\\nclass Solution {\\n    int count;\\n    public int numRookCaptures(char[][] board) {\\n     for(int i=0;i<board.length;i++)\\n         for(int j=0;j<board[i].length;j++)\\n         {\\n             if(board[i][j]==\\'R\\')\\n             { \\n               dfs(board,i-1,j,\\'u\\');\\n               dfs(board,i+1,j,\\'d\\');\\n               dfs(board,i,j-1,\\'l\\');\\n               dfs(board,i,j+1,\\'r\\');\\n                 break;\\n            }\\n         }\\n        return count;\\n    }\\n    public void dfs(char[][] board,int i,int j,char c)\\n    {\\n        if(i<0 || i>=board.length || j<0 || j>=board[i].length || board[i][j]==\\'B\\')\\n            return;\\n        if(board[i][j]==\\'p\\')\\n        {\\n            count+=1;\\n            return;\\n        }\\n        if(board[i][j]==\\'.\\')\\n        {\\n            if(c==\\'u\\')\\n              dfs(board,i-1,j,\\'u\\');\\n            else if(c==\\'d\\')\\n                 dfs(board,i+1,j,\\'d\\');\\n            else if(c==\\'l\\')\\n                 dfs(board,i,j-1,\\'l\\');\\n            else if(c==\\'r\\')\\n                 dfs(board,i,j+1,\\'r\\');\\n                \\n        }\\n      \\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count;\\n    public int numRookCaptures(char[][] board) {\\n     for(int i=0;i<board.length;i++)\\n         for(int j=0;j<board[i].length;j++)\\n         {\\n             if(board[i][j]==\\'R\\')\\n             { \\n               dfs(board,i-1,j,\\'u\\');\\n               dfs(board,i+1,j,\\'d\\');\\n               dfs(board,i,j-1,\\'l\\');\\n               dfs(board,i,j+1,\\'r\\');\\n                 break;\\n            }\\n         }\\n        return count;\\n    }\\n    public void dfs(char[][] board,int i,int j,char c)\\n    {\\n        if(i<0 || i>=board.length || j<0 || j>=board[i].length || board[i][j]==\\'B\\')\\n            return;\\n        if(board[i][j]==\\'p\\')\\n        {\\n            count+=1;\\n            return;\\n        }\\n        if(board[i][j]==\\'.\\')\\n        {\\n            if(c==\\'u\\')\\n              dfs(board,i-1,j,\\'u\\');\\n            else if(c==\\'d\\')\\n                 dfs(board,i+1,j,\\'d\\');\\n            else if(c==\\'l\\')\\n                 dfs(board,i,j-1,\\'l\\');\\n            else if(c==\\'r\\')\\n                 dfs(board,i,j+1,\\'r\\');\\n                \\n        }\\n      \\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748899,
                "title": "java-solution-easy-readable-with-comments",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ans = 0;\\n\\n\\t\\tfor (int i = 0; i < board.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < board[0].length; j++) {\\n\\t\\t\\t\\tif (board[i][j] == \\'R\\') {\\n\\n\\t\\t\\t\\t\\tans = inRow(i, j, board) + inCol(i, j, board);\\n\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n    \\n    public int inRow(int row, int col, char[][] board) {\\n\\n\\t\\tint c = 0;\\n\\n\\t\\t// leftwards\\n\\t\\tfor (int i = col-1; i >= 0; i--)\\n\\t\\t\\tif (board[row][i] != \\'.\\') {\\n\\t\\t\\t\\tif (board[row][i] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n                \\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t// rightwards\\n\\t\\tfor (int i = col+1; i < board[0].length; i++)\\n\\t\\t\\tif (board[row][i] != \\'.\\') {\\n\\t\\t\\t\\tif (board[row][i] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n                \\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\treturn c;\\n\\t}\\n\\t\\n\\tpublic int inCol(int row, int col, char[][] board) {\\n\\n\\t\\tint c = 0;\\n\\n\\t\\t// upwards\\n\\t\\tfor (int i = row-1; i >= 0; i--)\\n\\t\\t\\tif (board[i][col] != \\'.\\') {\\n\\t\\t\\t\\tif (board[i][col] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t// downwards\\n\\t\\tfor (int i = row+1; i < board.length; i++)\\n\\t\\t\\tif (board[i][col] != \\'.\\') {\\n\\t\\t\\t\\tif (board[i][col] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\treturn c;\\n\\t}\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ans = 0;\\n\\n\\t\\tfor (int i = 0; i < board.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < board[0].length; j++) {\\n\\t\\t\\t\\tif (board[i][j] == \\'R\\') {\\n\\n\\t\\t\\t\\t\\tans = inRow(i, j, board) + inCol(i, j, board);\\n\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n    \\n    public int inRow(int row, int col, char[][] board) {\\n\\n\\t\\tint c = 0;\\n\\n\\t\\t// leftwards\\n\\t\\tfor (int i = col-1; i >= 0; i--)\\n\\t\\t\\tif (board[row][i] != \\'.\\') {\\n\\t\\t\\t\\tif (board[row][i] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n                \\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t// rightwards\\n\\t\\tfor (int i = col+1; i < board[0].length; i++)\\n\\t\\t\\tif (board[row][i] != \\'.\\') {\\n\\t\\t\\t\\tif (board[row][i] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n                \\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\treturn c;\\n\\t}\\n\\t\\n\\tpublic int inCol(int row, int col, char[][] board) {\\n\\n\\t\\tint c = 0;\\n\\n\\t\\t// upwards\\n\\t\\tfor (int i = row-1; i >= 0; i--)\\n\\t\\t\\tif (board[i][col] != \\'.\\') {\\n\\t\\t\\t\\tif (board[i][col] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t// downwards\\n\\t\\tfor (int i = row+1; i < board.length; i++)\\n\\t\\t\\tif (board[i][col] != \\'.\\') {\\n\\t\\t\\t\\tif (board[i][col] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\treturn c;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735806,
                "title": "100-faster-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& b) {\\n        int i,j,flag=0,cnt=0,r,c;\\n        \\n        for(i=0;i<8;i++)\\n        {\\n            for(j=0;j<8;j++)\\n            {\\n                if(b[i][j]==\\'R\\'){r=i;c=j;flag=1;break;}\\n                //cout<<i<<\" \"<<j<<\" \"<<b[i][j]<<endl;\\n            }\\n            if(flag==1)break;\\n        }\\n        //cout<<i<<\" \"<<j<<endl;\\n        \\n        while(i<8)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            i++;\\n        }\\n        //cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\\n        i=r;\\n        while(i>=0)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            i--;\\n        }\\n        //cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\\n        i=r;\\n        while(j<8)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            j++;\\n        }\\n        //cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\\n        j=c;\\n        while(j>=0)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            j--;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\nauto speedup=[](){\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& b) {\\n        int i,j,flag=0,cnt=0,r,c;\\n        \\n        for(i=0;i<8;i++)\\n        {\\n            for(j=0;j<8;j++)\\n            {\\n                if(b[i][j]==\\'R\\'){r=i;c=j;flag=1;break;}\\n                //cout<<i<<\" \"<<j<<\" \"<<b[i][j]<<endl;\\n            }\\n            if(flag==1)break;\\n        }\\n        //cout<<i<<\" \"<<j<<endl;\\n        \\n        while(i<8)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            i++;\\n        }\\n        //cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\\n        i=r;\\n        while(i>=0)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            i--;\\n        }\\n        //cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\\n        i=r;\\n        while(j<8)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            j++;\\n        }\\n        //cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\\n        j=c;\\n        while(j>=0)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            j--;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\nauto speedup=[](){\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 729999,
                "title": "simple-easy-solution-by-python-3",
                "content": "1. Find position of the rook.\\n2. If you find the first pawn in each direction from the rook, increase the count.\\n\\n```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        R = next((i, j) for i in range(8) for j in range(8) if board[i][j] == \\'R\\')\\n        count = 0\\n        count += next((board[i][R[1]] == \\'p\\' for i in range(R[0] - 1, -1, -1) if board[i][R[1]] != \\'.\\'), 0)\\n        count += next((board[R[0]][j] == \\'p\\' for j in range(R[1] - 1, -1, -1) if board[R[0]][j] != \\'.\\'), 0)\\n        count += next((board[i][R[1]] == \\'p\\' for i in range(R[0] + 1, 8) if board[i][R[1]] != \\'.\\'), 0)\\n        count += next((board[R[0]][j] == \\'p\\' for j in range(R[1] + 1, 8) if board[R[0]][j] != \\'.\\'), 0)\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        R = next((i, j) for i in range(8) for j in range(8) if board[i][j] == \\'R\\')\\n        count = 0\\n        count += next((board[i][R[1]] == \\'p\\' for i in range(R[0] - 1, -1, -1) if board[i][R[1]] != \\'.\\'), 0)\\n        count += next((board[R[0]][j] == \\'p\\' for j in range(R[1] - 1, -1, -1) if board[R[0]][j] != \\'.\\'), 0)\\n        count += next((board[i][R[1]] == \\'p\\' for i in range(R[0] + 1, 8) if board[i][R[1]] != \\'.\\'), 0)\\n        count += next((board[R[0]][j] == \\'p\\' for j in range(R[1] + 1, 8) if board[R[0]][j] != \\'.\\'), 0)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710396,
                "title": "javascript-short-regex-solution",
                "content": "```\\nvar numRookCaptures = function(board) {\\n    let captures = 0;\\n    let rookRow = board.filter(row => row.includes(\"R\")).flat();\\n    let rookCol = board.map(row => row[rookRow.indexOf(\"R\")]);\\n    rookRow.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g) ? captures += rookRow.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g).length : null;\\n    rookCol.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g) ? captures += rookCol.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g).length : null;\\n    return captures;\\n};\\n```\\n\\nCreate arrays for the row and column that the rook resides in. Use Regex lookhead/lookbehind to see if a clear shot exists between the rook and the pawn (ie. no bishop in between). If there is a match, increase the captures count by 1 (ie. how long the match array is). Return the captures amount.",
                "solutionTags": [],
                "code": "```\\nvar numRookCaptures = function(board) {\\n    let captures = 0;\\n    let rookRow = board.filter(row => row.includes(\"R\")).flat();\\n    let rookCol = board.map(row => row[rookRow.indexOf(\"R\")]);\\n    rookRow.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g) ? captures += rookRow.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g).length : null;\\n    rookCol.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g) ? captures += rookCol.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g).length : null;\\n    return captures;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 710387,
                "title": "python-solution-can-be-used-also-for-queen-and-bishop-easily",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        rook = ()\\n        dim = 8\\n        # Find rook position\\n        for i in range(dim):\\n            if rook != ():\\n                break\\n            for j in range(dim):\\n                if board[i][j] == \\'R\\':\\n                    rook = (i,j)\\n                    break\\n        # Func to step in direction defined by tuple\\n        def godir(rpos, step):\\n            while 0 <= rpos[0] < dim and 0 <= rpos[1] < dim:\\n                cell = board[rpos[0]][rpos[1]]\\n                if cell == \"p\":\\n                    return 1\\n                if cell == \"B\":\\n                    return 0\\n                rpos = (rpos[0]+step[0], rpos[1]+step[1])\\n            return 0\\n        # directions for rook, you can adapt for queen and bishop\\n        steps = (\\n            (0,1),\\n            (0,-1),\\n            (1,0),\\n            (-1,0)\\n        )\\n        took = 0\\n        for step in steps:\\n            took += godir(rook, step)\\n        return took\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        rook = ()\\n        dim = 8\\n        # Find rook position\\n        for i in range(dim):\\n            if rook != ():\\n                break\\n            for j in range(dim):\\n                if board[i][j] == \\'R\\':\\n                    rook = (i,j)\\n                    break\\n        # Func to step in direction defined by tuple\\n        def godir(rpos, step):\\n            while 0 <= rpos[0] < dim and 0 <= rpos[1] < dim:\\n                cell = board[rpos[0]][rpos[1]]\\n                if cell == \"p\":\\n                    return 1\\n                if cell == \"B\":\\n                    return 0\\n                rpos = (rpos[0]+step[0], rpos[1]+step[1])\\n            return 0\\n        # directions for rook, you can adapt for queen and bishop\\n        steps = (\\n            (0,1),\\n            (0,-1),\\n            (1,0),\\n            (-1,0)\\n        )\\n        took = 0\\n        for step in steps:\\n            took += godir(rook, step)\\n        return took\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 707563,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int col=0;\\n        int row=0;\\n        int count=0;\\n        \\n        for(int i=0;i<8;i++)\\n        {\\n            for(int j=0;j<8;j++)\\n            {\\n                \\n                if(board[i][j]==\\'R\\')\\n                {\\n                  col=j;\\n                  row=i;\\n                    \\n                }\\n                \\n                \\n                \\n            }\\n            \\n            \\n        }\\n        \\n        \\n        for(int i=row;i>=0;i--)\\n        {\\n            \\n            if(board[i][col]==\\'B\\')\\n                break;\\n            \\n            else if(board[i][col]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n                \\n                \\n            }\\n        }\\n        \\n        \\n          for(int i=row;i<8;i++)\\n        {\\n            \\n            if(board[i][col]==\\'B\\')\\n                break;\\n            \\n            else if(board[i][col]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        \\n        }\\n        \\n        \\n        \\n        \\n        for(int i=col;i>=0;i--)\\n        {\\n            \\n            if(board[row][i]==\\'B\\')\\n                break;\\n            \\n            else if(board[row][i]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        \\n        }\\n        \\n        \\n        \\n          \\n        for(int i=col;i<8;i++)\\n        {\\n            \\n            if(board[row][i]==\\'B\\')\\n                break;\\n            \\n            else if(board[row][i]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        \\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        return count;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int col=0;\\n        int row=0;\\n        int count=0;\\n        \\n        for(int i=0;i<8;i++)\\n        {\\n            for(int j=0;j<8;j++)\\n            {\\n                \\n                if(board[i][j]==\\'R\\')\\n                {\\n                  col=j;\\n                  row=i;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 706052,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        def findrow(board):\\n            for i in range(8):\\n                if \\'R\\' in board[i]:\\n                    row=board[i]\\n                    break\\n            return row\\n        def findpos(row):\\n            for i in range(8):\\n                if row[i] == \\'R\\':\\n                    val=i\\n            return val\\n        def findans(row,val):\\n            ans=0\\n            for i in range(val-1,0,-1):\\n                if row[i]==\\'p\\':\\n                    ans=1\\n                    break\\n                elif row[i]!=\\'.\\':\\n                    break\\n            for i in range(val+1,8):\\n                if  row[i]==\\'p\\':\\n                    ans+=1\\n                    break\\n                elif row[i]!=\\'.\\':\\n                    break\\n            return ans\\n        def findcol(board,val):\\n            count=0\\n            for i in zip(*board):\\n                if count==val:\\n                    col=i\\n                    break\\n                count+=1\\n            return col\\n        row=findrow(board)\\n        pos=findpos(row)\\n        ans=findans(row,pos)\\n        col=findcol(board,pos)\\n        pos=findpos(col)\\n        ans+=findans(col,pos)\\n        return ans\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        def findrow(board):\\n            for i in range(8):\\n                if \\'R\\' in board[i]:\\n                    row=board[i]\\n                    break\\n            return row\\n        def findpos(row):\\n            for i in range(8):\\n                if row[i] == \\'R\\':\\n                    val=i\\n            return val\\n        def findans(row,val):\\n            ans=0\\n            for i in range(val-1,0,-1):\\n                if row[i]==\\'p\\':\\n                    ans=1\\n                    break\\n                elif row[i]!=\\'.\\':\\n                    break\\n            for i in range(val+1,8):\\n                if  row[i]==\\'p\\':\\n                    ans+=1\\n                    break\\n                elif row[i]!=\\'.\\':\\n                    break\\n            return ans\\n        def findcol(board,val):\\n            count=0\\n            for i in zip(*board):\\n                if count==val:\\n                    col=i\\n                    break\\n                count+=1\\n            return col\\n        row=findrow(board)\\n        pos=findpos(row)\\n        ans=findans(row,pos)\\n        col=findcol(board,pos)\\n        pos=findpos(col)\\n        ans+=findans(col,pos)\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 693377,
                "title": "python-beats-98-in-20ms",
                "content": "``` class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        p1,p2,p3,p4=0,0,0,0\\n        for i in board:\\n            if \"R\" in i:\\n                x=i.index(\"R\")\\n                y=i\\n                break\\n        if \"R\" in y and \"p\" in y:\\n            c=\"\".join(i for i in y if i != \\'.\\')\\n            p2=c.count(\"pR\")\\n            p3=c.count(\"Rp\")\\n        s=\\'\\'\\n        for i in range(8):\\n            if board[i][x]==\"p\" or board[i][x]==\"B\" or board[i][x]==\"R\":\\n                s=s+board[i][x]\\n        p1=s.count(\"pR\")\\n        p4=s.count(\"Rp\")\\n        return p1+p2+p3+p4\\n",
                "solutionTags": [],
                "code": "``` class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        p1,p2,p3,p4=0,0,0,0\\n        for i in board:\\n            if \"R\" in i:\\n                x=i.index(\"R\")\\n                y=i\\n                break\\n        if \"R\" in y and \"p\" in y:\\n            c=\"\".join(i for i in y if i != \\'.\\')\\n            p2=c.count(\"pR\")\\n            p3=c.count(\"Rp\")\\n        s=\\'\\'\\n        for i in range(8):\\n            if board[i][x]==\"p\" or board[i][x]==\"B\" or board[i][x]==\"R\":\\n                s=s+board[i][x]\\n        p1=s.count(\"pR\")\\n        p4=s.count(\"Rp\")\\n        return p1+p2+p3+p4\\n",
                "codeTag": "Java"
            },
            {
                "id": 680754,
                "title": "javascript-solution",
                "content": "```\\nvar numRookCaptures = function(board) {\\n    for (let row = 0; row < 8; row++) {\\n        for (let col = 0; col < 8; col++) {\\n            if (board[row][col] === \\'R\\') {\\n                return countPawns(row, col);\\n            }\\n        }\\n    }\\n    \\n    function countPawns(x, y) {\\n        let count = 0;\\n        const dirs = [-1, 0, 1, 0, -1];\\n        \\n        for (let i = 0; i < dirs.length - 1; i++) {\\n            const dirX = dirs[i];\\n            const dirY = dirs[i + 1];\\n            count += findPawn(x + dirX, y + dirY, dirX, dirY);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    function findPawn(x, y, dirX, dirY) {\\n        if (isValid(x, y)) {\\n            if (board[x][y] == \\'p\\') return 1;\\n            x += dirX;\\n            y += dirY;\\n            return findPawn(x, y, dirX, dirY);\\n        }\\n        return 0;\\n    }\\n    \\n    function isValid(x, y) {\\n        return x >= 0 && y >= 0 && x < 8 && y < 8 && board[x][y] != \\'B\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numRookCaptures = function(board) {\\n    for (let row = 0; row < 8; row++) {\\n        for (let col = 0; col < 8; col++) {\\n            if (board[row][col] === \\'R\\') {\\n                return countPawns(row, col);\\n            }\\n        }\\n    }\\n    \\n    function countPawns(x, y) {\\n        let count = 0;\\n        const dirs = [-1, 0, 1, 0, -1];\\n        \\n        for (let i = 0; i < dirs.length - 1; i++) {\\n            const dirX = dirs[i];\\n            const dirY = dirs[i + 1];\\n            count += findPawn(x + dirX, y + dirY, dirX, dirY);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    function findPawn(x, y, dirX, dirY) {\\n        if (isValid(x, y)) {\\n            if (board[x][y] == \\'p\\') return 1;\\n            x += dirX;\\n            y += dirY;\\n            return findPawn(x, y, dirX, dirY);\\n        }\\n        return 0;\\n    }\\n    \\n    function isValid(x, y) {\\n        return x >= 0 && y >= 0 && x < 8 && y < 8 && board[x][y] != \\'B\\';\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 632989,
                "title": "python-soln",
                "content": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        \\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \\'R\\':\\n                    sr, sc = i, j\\n\\n                    \\n        for i, j in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n            for k in range(1,8):\\n                x = sr + k*i\\n                y = sc + k*j\\n                if not (0 <= x < 8 and 0 <= y < 8):\\n                    break\\n                if board[x][y] == \\'p\\':\\n                    count += 1\\n                    break\\n                elif board[x][y] == \\'B\\':\\n                    break\\n        \\n        return count\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        \\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \\'R\\':\\n                    sr, sc = i, j\\n\\n                    \\n        for i, j in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n            for k in range(1,8):\\n                x = sr + k*i\\n                y = sc + k*j\\n                if not (0 <= x < 8 and 0 <= y < 8):\\n                    break\\n                if board[x][y] == \\'p\\':\\n                    count += 1\\n                    break\\n                elif board[x][y] == \\'B\\':\\n                    break\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619441,
                "title": "python-1-line-o1-video",
                "content": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        return sum([s.count(\\'Rp\\') + s.count(\\'pR\\') for s in [\\'\\'.join(row).replace(\\'.\\', \\'\\') for row in (board + zip(*board)) if \\'R\\' in row]])\\n```\\n\\nvideo: youtube.com/watch?v=o3XmjXZnaUs",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        return sum([s.count(\\'Rp\\') + s.count(\\'pR\\') for s in [\\'\\'.join(row).replace(\\'.\\', \\'\\') for row in (board + zip(*board)) if \\'R\\' in row]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609445,
                "title": "python-solution-converting-to-string",
                "content": "Find the \\'R\\' and convert corresponding cardinals to string and look for \\'pR\\' or \\'Rp\\' in string\\n```\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n        for r in range(8):\\n            for c in range(8):\\n                if \\'R\\' == board[r][c]:\\n                    row, col = r, c\\n        estwst = \"\".join(i for i in board[row] if i!=\\'.\\')\\n        nrtst =  \"\".join(i for i in list(zip(*board))[col] if i!=\\'.\\')\\n        cnt = 0\\n        for strng in [estwst,nrtst]:\\n            if \\'pR\\' in strng:\\n                cnt += 1\\n            if \\'Rp\\' in strng :\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n        for r in range(8):\\n            for c in range(8):\\n                if \\'R\\' == board[r][c]:\\n                    row, col = r, c\\n        estwst = \"\".join(i for i in board[row] if i!=\\'.\\')\\n        nrtst =  \"\".join(i for i in list(zip(*board))[col] if i!=\\'.\\')\\n        cnt = 0\\n        for strng in [estwst,nrtst]:\\n            if \\'pR\\' in strng:\\n                cnt += 1\\n            if \\'Rp\\' in strng :\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 569472,
                "title": "if-if-if-javascript-solution-44ms",
                "content": "```\\n22 / 22 test cases passed.\\nStatus: Accepted\\nRuntime: 44 ms\\nMemory Usage: 33.9 MB\\n\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n  let rook, u = 1, d = 1, l = 1, r = 1, count = 0;\\n  board.forEach((el, i) => el.forEach((el1,i1) => {\\n    if (el1 === \\'R\\') rook = [i,i1];\\n  }));\\n  \\n  for (let i = 1; u || d || l || r; i++) {\\n    if (u && rook[0] - i >= 0) {\\n      if (board[rook[0] - i][rook[1]] === \\'p\\') {\\n        count ++; \\n        u = 0;\\n      }\\n      if (board[rook[0] - i][rook[1]] === \\'B\\' || rook[0] - i === 0) u = 0;\\n    }\\n    if (d && rook[0] + i <= 7) {\\n      if (board[rook[0] + i][rook[1]] === \\'p\\') {\\n        count ++; \\n        d = 0;\\n      }\\n      if (board[rook[0] + i][rook[1]] === \\'B\\' || rook[0] + i === 7) d = 0;\\n    }\\n    if (l && rook[1] - i >= 0) {\\n      if (board[rook[0]][rook[1] - i] === \\'p\\') {\\n        count ++; \\n        l = 0;\\n      }\\n      if (board[rook[0]][rook[1] - i] === \\'B\\' || rook[1] - i === 0) l = 0;\\n    }\\n    if (r && rook[1] + i <= 7) {\\n      if (board[rook[0]][rook[1] + i] === \\'p\\') {\\n        count ++; \\n        r = 0;\\n      }\\n      if (board[rook[0]][rook[1] + i] === \\'B\\' || rook[1] + i === 7) r = 0;\\n    }\\n  }\\n    \\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n22 / 22 test cases passed.\\nStatus: Accepted\\nRuntime: 44 ms\\nMemory Usage: 33.9 MB\\n\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n  let rook, u = 1, d = 1, l = 1, r = 1, count = 0;\\n  board.forEach((el, i) => el.forEach((el1,i1) => {\\n    if (el1 === \\'R\\') rook = [i,i1];\\n  }));\\n  \\n  for (let i = 1; u || d || l || r; i++) {\\n    if (u && rook[0] - i >= 0) {\\n      if (board[rook[0] - i][rook[1]] === \\'p\\') {\\n        count ++; \\n        u = 0;\\n      }\\n      if (board[rook[0] - i][rook[1]] === \\'B\\' || rook[0] - i === 0) u = 0;\\n    }\\n    if (d && rook[0] + i <= 7) {\\n      if (board[rook[0] + i][rook[1]] === \\'p\\') {\\n        count ++; \\n        d = 0;\\n      }\\n      if (board[rook[0] + i][rook[1]] === \\'B\\' || rook[0] + i === 7) d = 0;\\n    }\\n    if (l && rook[1] - i >= 0) {\\n      if (board[rook[0]][rook[1] - i] === \\'p\\') {\\n        count ++; \\n        l = 0;\\n      }\\n      if (board[rook[0]][rook[1] - i] === \\'B\\' || rook[1] - i === 0) l = 0;\\n    }\\n    if (r && rook[1] + i <= 7) {\\n      if (board[rook[0]][rook[1] + i] === \\'p\\') {\\n        count ++; \\n        r = 0;\\n      }\\n      if (board[rook[0]][rook[1] + i] === \\'B\\' || rook[1] + i === 7) r = 0;\\n    }\\n  }\\n    \\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561250,
                "title": "simple-python-solution",
                "content": "Pretty straight forward problem. Just mimic the movement of the rook. Initially the rook is at (x0, y0). After moving k steps he will arrive at (x0 +k* dx, y0 + k* dy)\\n```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        row=len(board)\\n        col=len(board[0])\\n        for i in range(row):\\n            for j in range(col):\\n                if board[i][j]==\\'R\\':\\n                    (rook_x,rook_y) = (i,j)\\n        \\n        \\n        count = 0 \\n        for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n            k = 0\\n            while True:\\n                x = rook_x + k*dx\\n                y = rook_y + k*dy\\n                if x<0 or x>row-1 or y<0 or y>col-1:\\n                    break\\n                if board[x][y] == \\'B\\': \\n                    break\\n                if board[x][y] == \\'p\\':\\n                    count+=1\\n                    break\\n                k+=1\\n                \\n        return count\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        row=len(board)\\n        col=len(board[0])\\n        for i in range(row):\\n            for j in range(col):\\n                if board[i][j]==\\'R\\':\\n                    (rook_x,rook_y) = (i,j)\\n        \\n        \\n        count = 0 \\n        for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n            k = 0\\n            while True:\\n                x = rook_x + k*dx\\n                y = rook_y + k*dy\\n                if x<0 or x>row-1 or y<0 or y>col-1:\\n                    break\\n                if board[x][y] == \\'B\\': \\n                    break\\n                if board[x][y] == \\'p\\':\\n                    count+=1\\n                    break\\n                k+=1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557877,
                "title": "java-solution-faster-than-100-poor-space-complexity",
                "content": "I first locate the coordinates of the Rook and then check cells ot its North,South,East and West by manipulating the array indices.\\n\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int r=0,c=0;\\n        boolean flag=true;\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    flag=false;\\n                    r=i;\\n                    c=j;\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                break;\\n        }\\n        \\n        int count=0;\\n        for(int i=c+1;i<8;i++){\\n            if(board[r][i]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        \\n        for(int i=c-1;i>=0;i--){\\n            if(board[r][i]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        \\n        for(int i=r+1;i<8;i++){\\n            if(board[i][c]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=r-1;i>=0;i--){\\n            if(board[i][c]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int r=0,c=0;\\n        boolean flag=true;\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    flag=false;\\n                    r=i;\\n                    c=j;\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                break;\\n        }\\n        \\n        int count=0;\\n        for(int i=c+1;i<8;i++){\\n            if(board[r][i]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        \\n        for(int i=c-1;i>=0;i--){\\n            if(board[r][i]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        \\n        for(int i=r+1;i<8;i++){\\n            if(board[i][c]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=r-1;i>=0;i--){\\n            if(board[i][c]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557227,
                "title": "c-solutions",
                "content": "**Version 1**\\nLeant how to explore all the four directions within one loop from https://leetcode.com/problems/available-captures-for-rook/discuss/242932/JavaC%2B%2BPython-Straight-Forward-Solution\\n```\\n    public int NumRookCaptures(char[][] board) {\\n        \\n        int rookI = 0, rookJ = 0, res = 0;\\n        \\n        //find the Rook\\n        for(int i = 0; i < board.Length; i++)\\n        {\\n            for(int j = 0; j < board[0].Length; j++)\\n            {\\n                if(board[i][j] == \\'R\\')\\n                {\\n                    rookI = i;\\n                    rookJ = j;\\n                }\\n            }\\n        }\\n        \\n        int[,] dir = new int[,] { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\\n        for(int d = 0; d < dir.GetLength(0); d++)\\n        {\\n            for(int i = rookI + dir[d, 0], j = rookJ + dir[d, 1]; i >= 0 && i < 8 && j >= 0 && j < 8; i += dir[d, 0], j += dir[d, 1])\\n            {\\n                if(board[i][j] == \\'p\\')\\n                {\\n                    res++;\\n                    break;\\n                }\\n                else if(board[i][j] == \\'B\\')\\n                    break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\n**Version 2**\\n```\\n    public int NumRookCaptures(char[][] board) {\\n        \\n        int m = board.Length, n = board[0].Length, res = 0;\\n        int rookI = 0, rookJ = 0;\\n        \\n        //find the Rook\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(board[i][j] == \\'R\\')\\n                {\\n                    rookI = i;\\n                    rookJ = j;\\n                }\\n            }\\n        }\\n        \\n        //left\\n        for(int j1 = rookJ -1; j1 >= 0; j1--)\\n        {\\n            if(board[rookI][j1] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board [rookI][j1] == \\'B\\')\\n                break;                \\n        }\\n          \\n        //right\\n        for(int j2 = rookJ + 1; j2 < n; j2++)\\n        {\\n            if(board[rookI][j2] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board [rookI][j2] == \\'B\\')\\n                break;                \\n        }\\n        \\n        //up\\n        for(int i1 = rookI - 1; i1 >= 0; i1--)\\n        {\\n            if(board[i1][rookJ] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board[i1][rookJ] == \\'B\\')\\n                break;\\n        }\\n        \\n        //down\\n        for(int i2 = rookI + 1; i2 < m; i2++)\\n        {\\n            if(board[i2][rookJ] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board[i2][rookJ] == \\'B\\')\\n                break;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int NumRookCaptures(char[][] board) {\\n        \\n        int rookI = 0, rookJ = 0, res = 0;\\n        \\n        //find the Rook\\n        for(int i = 0; i < board.Length; i++)\\n        {\\n            for(int j = 0; j < board[0].Length; j++)\\n            {\\n                if(board[i][j] == \\'R\\')\\n                {\\n                    rookI = i;\\n                    rookJ = j;\\n                }\\n            }\\n        }\\n        \\n        int[,] dir = new int[,] { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\\n        for(int d = 0; d < dir.GetLength(0); d++)\\n        {\\n            for(int i = rookI + dir[d, 0], j = rookJ + dir[d, 1]; i >= 0 && i < 8 && j >= 0 && j < 8; i += dir[d, 0], j += dir[d, 1])\\n            {\\n                if(board[i][j] == \\'p\\')\\n                {\\n                    res++;\\n                    break;\\n                }\\n                else if(board[i][j] == \\'B\\')\\n                    break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```\n```\\n    public int NumRookCaptures(char[][] board) {\\n        \\n        int m = board.Length, n = board[0].Length, res = 0;\\n        int rookI = 0, rookJ = 0;\\n        \\n        //find the Rook\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(board[i][j] == \\'R\\')\\n                {\\n                    rookI = i;\\n                    rookJ = j;\\n                }\\n            }\\n        }\\n        \\n        //left\\n        for(int j1 = rookJ -1; j1 >= 0; j1--)\\n        {\\n            if(board[rookI][j1] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board [rookI][j1] == \\'B\\')\\n                break;                \\n        }\\n          \\n        //right\\n        for(int j2 = rookJ + 1; j2 < n; j2++)\\n        {\\n            if(board[rookI][j2] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board [rookI][j2] == \\'B\\')\\n                break;                \\n        }\\n        \\n        //up\\n        for(int i1 = rookI - 1; i1 >= 0; i1--)\\n        {\\n            if(board[i1][rookJ] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board[i1][rookJ] == \\'B\\')\\n                break;\\n        }\\n        \\n        //down\\n        for(int i2 = rookI + 1; i2 < m; i2++)\\n        {\\n            if(board[i2][rookJ] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board[i2][rookJ] == \\'B\\')\\n                break;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 549637,
                "title": "javascript-using-math-random",
                "content": "Just for fun \\uD83D\\uDE04\\n\\n```js\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nfunction numRookCaptures(board) {\\n  const size = 8;\\n  const total = size ** 2;\\n  let n = 0;\\n  while (board[(n / size) | 0][n % size] !== \\'R\\') {\\n    n = (Math.random() * total) | 0;\\n  }\\n  const x = n % size;\\n  const y = (n / size) | 0;\\n  const delta = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n  return delta.reduce((sum, [dx, dy]) => sum + count(x + dx, y + dy, dx, dy), 0);\\n  function count(x, y, dx, dy) {\\n    if (x < 0 || x >= size || y < 0 || y >= size) {\\n      return 0;\\n    }\\n    switch (board[y][x]) {\\n      case \\'B\\':\\n        return 0;\\n      case \\'p\\':\\n        return 1;\\n      default:\\n        return count(x + dx, y + dy, dx, dy);\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nfunction numRookCaptures(board) {\\n  const size = 8;\\n  const total = size ** 2;\\n  let n = 0;\\n  while (board[(n / size) | 0][n % size] !== \\'R\\') {\\n    n = (Math.random() * total) | 0;\\n  }\\n  const x = n % size;\\n  const y = (n / size) | 0;\\n  const delta = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n  return delta.reduce((sum, [dx, dy]) => sum + count(x + dx, y + dy, dx, dy), 0);\\n  function count(x, y, dx, dy) {\\n    if (x < 0 || x >= size || y < 0 || y >= size) {\\n      return 0;\\n    }\\n    switch (board[y][x]) {\\n      case \\'B\\':\\n        return 0;\\n      case \\'p\\':\\n        return 1;\\n      default:\\n        return count(x + dx, y + dy, dx, dy);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515327,
                "title": "c-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int res = 0;\\n        //four directions\\n        for(int i = 0; i < board.size(); ++i)\\n            for(int j = 0; j < board[0].size(); ++j)\\n                if(board[i][j] == \\'R\\') for(int dir = 1; dir <= 4; ++dir) dfs(board,i,j,res,dir);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j, int& res, int dir){\\n        if(i < 0||i >= board.size()||j < 0||j >= board[0].size()||board[i][j]==\\'B\\') return;\\n        if(board[i][j] == \\'p\\') res++;\\n        else dfs(board,i + ((dir % 2) ? dir - 2 : 0),j + (!(dir % 2) ? dir - 3 : 0), res, dir);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int res = 0;\\n        //four directions\\n        for(int i = 0; i < board.size(); ++i)\\n            for(int j = 0; j < board[0].size(); ++j)\\n                if(board[i][j] == \\'R\\') for(int dir = 1; dir <= 4; ++dir) dfs(board,i,j,res,dir);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j, int& res, int dir){\\n        if(i < 0||i >= board.size()||j < 0||j >= board[0].size()||board[i][j]==\\'B\\') return;\\n        if(board[i][j] == \\'p\\') res++;\\n        else dfs(board,i + ((dir % 2) ? dir - 2 : 0),j + (!(dir % 2) ? dir - 3 : 0), res, dir);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500938,
                "title": "python3-not-pretty-but-straight-forward",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'R\\':\\n                    count = 0;\\n                    l, r = j - 1, j + 1\\n                    while l >= 0:\\n                        if board[i][l] in \\'pB\\':\\n                            count += board[i][l] == \\'p\\'\\n                            break\\n                        l -= 1\\n                    while r < len(board[0]):\\n                        if board[i][r] in \\'pB\\':\\n                            count += board[i][r] == \\'p\\'\\n                            break\\n                        r += 1\\n                    u, d = i - 1, i + 1\\n                    while u >= 0:\\n                        if board[u][j] in \\'pB\\':\\n                            count += board[u][j] == \\'p\\'\\n                            break\\n                        u -= 1\\n                    while d < len(board):\\n                        if board[d][j] in \\'pB\\':\\n                            count += board[d][j] == \\'p\\'\\n                            break\\n                        d += 1\\n                    return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'R\\':\\n                    count = 0;\\n                    l, r = j - 1, j + 1\\n                    while l >= 0:\\n                        if board[i][l] in \\'pB\\':\\n                            count += board[i][l] == \\'p\\'\\n                            break\\n                        l -= 1\\n                    while r < len(board[0]):\\n                        if board[i][r] in \\'pB\\':\\n                            count += board[i][r] == \\'p\\'\\n                            break\\n                        r += 1\\n                    u, d = i - 1, i + 1\\n                    while u >= 0:\\n                        if board[u][j] in \\'pB\\':\\n                            count += board[u][j] == \\'p\\'\\n                            break\\n                        u -= 1\\n                    while d < len(board):\\n                        if board[d][j] in \\'pB\\':\\n                            count += board[d][j] == \\'p\\'\\n                            break\\n                        d += 1\\n                    return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474867,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        length = len(board) - 1\\n        count = 0 \\n        position = [0, 0]\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if board[i][j] == \\'R\\':\\n                    position = [i, j]\\n        \\n        up = position[0] - 1\\n        down = position[0] + 1\\n        left = position[1] - 1\\n        right = position[1] + 1\\n        \\n        while up >= 0:\\n            if board[up][position[1]] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[up][position[1]] == \\'B\\':\\n                break\\n            up -= 1\\n        \\n        while left >= 0:\\n            if board[position[0]][left] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[position[0]][left] == \\'B\\':\\n                break\\n            left -= 1\\n            \\n        while down <= length:\\n            if board[down][position[1]] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[down][position[1]] == \\'B\\':\\n                break\\n            down += 1\\n            \\n        while right <= length:\\n            \\n            if board[position[0]][right] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[position[0]][right] == \\'B\\':\\n                break\\n            right += 1\\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        length = len(board) - 1\\n        count = 0 \\n        position = [0, 0]\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if board[i][j] == \\'R\\':\\n                    position = [i, j]\\n        \\n        up = position[0] - 1\\n        down = position[0] + 1\\n        left = position[1] - 1\\n        right = position[1] + 1\\n        \\n        while up >= 0:\\n            if board[up][position[1]] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[up][position[1]] == \\'B\\':\\n                break\\n            up -= 1\\n        \\n        while left >= 0:\\n            if board[position[0]][left] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[position[0]][left] == \\'B\\':\\n                break\\n            left -= 1\\n            \\n        while down <= length:\\n            if board[down][position[1]] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[down][position[1]] == \\'B\\':\\n                break\\n            down += 1\\n            \\n        while right <= length:\\n            \\n            if board[position[0]][right] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[position[0]][right] == \\'B\\':\\n                break\\n            right += 1\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473599,
                "title": "swift-dfs-8ms",
                "content": "```\\nclass Solution {\\n    func rookPosition(_ board: inout [[Character]]) -> (x: Int, y: Int) {\\n        for i in 0..<board.count {\\n            for j in 0..<board[0].count {\\n                if board[i][j] == \"R\" {\\n                    return (i, j)\\n                }\\n            }\\n        }\\n        fatalError()\\n    }\\n    \\n    func numRookCaptures(_ board: [[Character]]) -> Int {\\n        var board = board\\n        let position = rookPosition(&board)\\n        \\n        var answer = 0\\n        func dfs(_ x: Int, _ y: Int, _ dx: Int, _ dy: Int) {\\n            guard x >= 0 && x < board.count && y >= 0 && y < board[0].count else  {\\n                return\\n            }\\n            let current = board[x][y]\\n            \\n            guard current != \"p\" else {\\n                answer += 1\\n                return\\n            }\\n            guard current == \".\" || current == \"R\" else {\\n                return\\n            }\\n            \\n            dfs(x + dx, y + dy, dx, dy)\\n        }\\n        \\n        dfs(position.x, position.y, -1, 0)\\n        dfs(position.x, position.y, 1, 0)\\n        dfs(position.x, position.y, 0, 1)\\n        dfs(position.x, position.y, 0, -1)\\n        \\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func rookPosition(_ board: inout [[Character]]) -> (x: Int, y: Int) {\\n        for i in 0..<board.count {\\n            for j in 0..<board[0].count {\\n                if board[i][j] == \"R\" {\\n                    return (i, j)\\n                }\\n            }\\n        }\\n        fatalError()\\n    }\\n    \\n    func numRookCaptures(_ board: [[Character]]) -> Int {\\n        var board = board\\n        let position = rookPosition(&board)\\n        \\n        var answer = 0\\n        func dfs(_ x: Int, _ y: Int, _ dx: Int, _ dy: Int) {\\n            guard x >= 0 && x < board.count && y >= 0 && y < board[0].count else  {\\n                return\\n            }\\n            let current = board[x][y]\\n            \\n            guard current != \"p\" else {\\n                answer += 1\\n                return\\n            }\\n            guard current == \".\" || current == \"R\" else {\\n                return\\n            }\\n            \\n            dfs(x + dx, y + dy, dx, dy)\\n        }\\n        \\n        dfs(position.x, position.y, -1, 0)\\n        dfs(position.x, position.y, 1, 0)\\n        dfs(position.x, position.y, 0, 1)\\n        dfs(position.x, position.y, 0, -1)\\n        \\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471995,
                "title": "simple-python-solution",
                "content": "100% Space and 75% time Python solution!\\n\\nSteps:\\n1. Locate \\'R\\'(Rook)\\n2. Isolate the row and the column where the Rook is present\\n3. You need to see if there\\'s a pawn with any amount of empty space from the Rook ( So I simply removed all the dots and checked for \\'pR\\' or \\'Rp\\')\\n\\nNote that the maximum answer of this question is 4!\\n\\n```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        Ri,Rj=0,0\\n        for i in board:\\n            for j in i:\\n                if j==\\'R\\':\\n                    Ri = board.index(i)\\n                    Rj = i.index(j)\\n                    Rrow = \\'\\'.join(i).replace(\\'.\\', \\'\\')\\n                    Rcol = \\'\\'.join([x[Rj] for x in board]).replace(\\'.\\', \\'\\')\\n                    break\\n        return Rrow.count(\\'Rp\\')+Rrow.count(\\'pR\\')+Rcol.count(\\'pR\\')+Rcol.count(\\'Rp\\')\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        Ri,Rj=0,0\\n        for i in board:\\n            for j in i:\\n                if j==\\'R\\':\\n                    Ri = board.index(i)\\n                    Rj = i.index(j)\\n                    Rrow = \\'\\'.join(i).replace(\\'.\\', \\'\\')\\n                    Rcol = \\'\\'.join([x[Rj] for x in board]).replace(\\'.\\', \\'\\')\\n                    break\\n        return Rrow.count(\\'Rp\\')+Rrow.count(\\'pR\\')+Rcol.count(\\'pR\\')+Rcol.count(\\'Rp\\')\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 458423,
                "title": "c-extremely-readable-functional-solution",
                "content": "```csharp\\n//Not required, Could work with a char array for less code, but stronger types are nicer\\nenum Square { Rook, Blank, Bishop, Pawn }\\ndelegate (int, int) CoordinateTransform((int x, int y) coord); //function signature required for succinct array generation\\n\\npublic int NumRookCaptures(char[][] board) {\\n\\t//Board is guaranteed to be 8x8\\n\\tbool IsOnBoard((int x, int y) i) => i.x >= 0 && i.x <8 && i.y >= 0 && i.y < 8;\\n\\tSquare FromChar(char c)\\n\\t{\\n\\t\\tswitch(c){\\n\\t\\t\\tcase \\'R\\': return Square.Rook;\\n\\t\\t\\tcase \\'.\\': return Square.Blank;\\n\\t\\t\\tcase \\'B\\': return Square.Bishop;\\n\\t\\t\\tcase \\'p\\': return Square.Pawn;\\n\\t\\t\\tdefault: throw new InvalidOperationException(c.ToString());\\n\\t\\t}\\n\\t}\\n\\tchar GetSquareChar((int x, int y) coord) => board[coord.y][coord.x];\\n\\n\\tSquare GetSquareValue((int x, int y) coord) => FromChar(GetSquareChar(coord));\\n\\tbool Is((int x, int y) coord, Square type) => GetSquareValue(coord) == type;\\n\\n\\t(int x, int y) Up((int x, int y) coord) => (coord.x, coord.y - 1);\\n\\t(int x, int y) Down((int x, int y) coord) => (coord.x, coord.y + 1);\\n\\t(int x, int y) Left((int x, int y) coord) => (coord.x - 1, coord.y);\\n\\t(int x, int y) Right((int x, int y) coord) => (coord.x + 1, coord.y);\\n\\n\\tbool IsBlankSquare((int x, int y) coord) => Is(coord, Square.Blank);\\n\\tbool IsBlank((int x, int y) coord) => IsOnBoard(coord) && IsBlankSquare(coord);\\n\\n\\t(int, int) GetNextNonBlank((int, int) start, CoordinateTransform next)\\n\\t{\\n\\t\\tvar current = next(start);\\n\\t\\twhile(IsBlank(current))\\n\\t\\t{\\n\\t\\t\\tcurrent = next(current);\\n\\t\\t}\\n\\t\\treturn current;\\n\\t}\\n\\n\\tvar locations = from i in Enumerable.Range(0, 8) from j in Enumerable.Range(0, 8) select (i, j);\\n\\n\\tvar rookLocation = locations.First(x => Is(x, Square.Rook));\\n\\n\\t(int, int) GetNextNonBlankFromRook(CoordinateTransform next) => GetNextNonBlank(rookLocation, next);\\n\\n\\tbool IsPawn((int x, int y) coord) => Is(coord, Square.Pawn);\\n\\tvar transforms = new CoordinateTransform[] { Up, Down, Left, Right};\\n\\treturn transforms.Select(GetNextNonBlankFromRook).Where(IsOnBoard).Where(IsPawn).Count();  \\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\n//Not required, Could work with a char array for less code, but stronger types are nicer\\nenum Square { Rook, Blank, Bishop, Pawn }\\ndelegate (int, int) CoordinateTransform((int x, int y) coord); //function signature required for succinct array generation\\n\\npublic int NumRookCaptures(char[][] board) {\\n\\t//Board is guaranteed to be 8x8\\n\\tbool IsOnBoard((int x, int y) i) => i.x >= 0 && i.x <8 && i.y >= 0 && i.y < 8;\\n\\tSquare FromChar(char c)\\n\\t{\\n\\t\\tswitch(c){\\n\\t\\t\\tcase \\'R\\': return Square.Rook;\\n\\t\\t\\tcase \\'.\\': return Square.Blank;\\n\\t\\t\\tcase \\'B\\': return Square.Bishop;\\n\\t\\t\\tcase \\'p\\': return Square.Pawn;\\n\\t\\t\\tdefault: throw new InvalidOperationException(c.ToString());\\n\\t\\t}\\n\\t}\\n\\tchar GetSquareChar((int x, int y) coord) => board[coord.y][coord.x];\\n\\n\\tSquare GetSquareValue((int x, int y) coord) => FromChar(GetSquareChar(coord));\\n\\tbool Is((int x, int y) coord, Square type) => GetSquareValue(coord) == type;\\n\\n\\t(int x, int y) Up((int x, int y) coord) => (coord.x, coord.y - 1);\\n\\t(int x, int y) Down((int x, int y) coord) => (coord.x, coord.y + 1);\\n\\t(int x, int y) Left((int x, int y) coord) => (coord.x - 1, coord.y);\\n\\t(int x, int y) Right((int x, int y) coord) => (coord.x + 1, coord.y);\\n\\n\\tbool IsBlankSquare((int x, int y) coord) => Is(coord, Square.Blank);\\n\\tbool IsBlank((int x, int y) coord) => IsOnBoard(coord) && IsBlankSquare(coord);\\n\\n\\t(int, int) GetNextNonBlank((int, int) start, CoordinateTransform next)\\n\\t{\\n\\t\\tvar current = next(start);\\n\\t\\twhile(IsBlank(current))\\n\\t\\t{\\n\\t\\t\\tcurrent = next(current);\\n\\t\\t}\\n\\t\\treturn current;\\n\\t}\\n\\n\\tvar locations = from i in Enumerable.Range(0, 8) from j in Enumerable.Range(0, 8) select (i, j);\\n\\n\\tvar rookLocation = locations.First(x => Is(x, Square.Rook));\\n\\n\\t(int, int) GetNextNonBlankFromRook(CoordinateTransform next) => GetNextNonBlank(rookLocation, next);\\n\\n\\tbool IsPawn((int x, int y) coord) => Is(coord, Square.Pawn);\\n\\tvar transforms = new CoordinateTransform[] { Up, Down, Left, Right};\\n\\treturn transforms.Select(GetNextNonBlankFromRook).Where(IsOnBoard).Where(IsPawn).Count();  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442578,
                "title": "python3-easy-solution-using-string-manipulation-of-row-and-column",
                "content": "```\\nclass Solution:\\n\\tdef numRookCaptures(self, board: List[List[str]]) -> int:\\n\\t\\trow = \"\"\\n\\t\\tfor i in range(8):\\n\\t\\t\\tif \"R\" in board[i]:\\n\\t\\t\\t\\tk = board[i].index(\"R\")\\n\\t\\t\\t\\trow = \"\".join(board[i])\\n\\t\\t\\t\\tbreak\\n\\t\\tcol = \"\"\\n\\t\\tfor j in range(8):\\n\\t\\t\\tcol += board[j][k]\\n\\n\\t\\trow = row.replace(\".\",\"\")\\n\\t\\tcol = col.replace(\".\",\"\")\\n\\n\\t\\treturn self.checkR(row) + self.checkR(col)\\n\\n\\tdef checkR(self,st) -> int:\\n\\t\\tcount = 0\\n\\t\\tif len(st) >= 2:\\n\\t\\t\\tif st.find(\"R\") == 0:\\n\\t\\t\\t\\tif st[1] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\telif st.find(\"R\") == len(st) - 1:\\n\\t\\t\\t\\tif st[-2] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif st[st.find(\"R\") - 1] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tif st[st.find(\"R\") + 1] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\treturn count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef numRookCaptures(self, board: List[List[str]]) -> int:\\n\\t\\trow = \"\"\\n\\t\\tfor i in range(8):\\n\\t\\t\\tif \"R\" in board[i]:\\n\\t\\t\\t\\tk = board[i].index(\"R\")\\n\\t\\t\\t\\trow = \"\".join(board[i])\\n\\t\\t\\t\\tbreak\\n\\t\\tcol = \"\"\\n\\t\\tfor j in range(8):\\n\\t\\t\\tcol += board[j][k]\\n\\n\\t\\trow = row.replace(\".\",\"\")\\n\\t\\tcol = col.replace(\".\",\"\")\\n\\n\\t\\treturn self.checkR(row) + self.checkR(col)\\n\\n\\tdef checkR(self,st) -> int:\\n\\t\\tcount = 0\\n\\t\\tif len(st) >= 2:\\n\\t\\t\\tif st.find(\"R\") == 0:\\n\\t\\t\\t\\tif st[1] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\telif st.find(\"R\") == len(st) - 1:\\n\\t\\t\\t\\tif st[-2] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif st[st.find(\"R\") - 1] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tif st[st.find(\"R\") + 1] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\treturn count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409550,
                "title": "python-3-concise-solution-95-69",
                "content": "Summary of algo:\\n1) locate the rook;\\n2) move from the rook in four cardinal directions to find pawn if no bishop is in the way.\\n\\nThe solution is very straighforward. This implementation can be imporoved further for efficiency, but fast and concise enough to reflect the underlying idea. \\n```\\nfrom itertools import product\\n\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        #locate the rook (m,n)\\n        for m, n in product(range(8), range(8)):\\n            if board[m][n] == \"R\": break \\n        \\n        def check(di, dj):\\n            \"\"\"Return True if found pawn from (m, n) along given direction\"\"\"\\n            i, j = m, n\\n            while 0 <= i < 8 and 0 <= j < 8:\\n                if board[i][j] not in (\"p\", \"B\"):\\n                    i += di\\n                    j += dj\\n                else: return board[i][j] == \"p\"\\n            return False\\n        \\n        ans = 0\\n        for direction in ((1,0), (0,1), (-1,0), (0,-1)):\\n            ans += check(*direction)\\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        #locate the rook (m,n)\\n        for m, n in product(range(8), range(8)):\\n            if board[m][n] == \"R\": break \\n        \\n        def check(di, dj):\\n            \"\"\"Return True if found pawn from (m, n) along given direction\"\"\"\\n            i, j = m, n\\n            while 0 <= i < 8 and 0 <= j < 8:\\n                if board[i][j] not in (\"p\", \"B\"):\\n                    i += di\\n                    j += dj\\n                else: return board[i][j] == \"p\"\\n            return False\\n        \\n        ans = 0\\n        for direction in ((1,0), (0,1), (-1,0), (0,-1)):\\n            ans += check(*direction)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 400782,
                "title": "java-clean-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int[][] moves = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n    public int numRookCaptures(char[][] board) {\\n        if (board.length==0 || board[0].length==0) return 0;\\n        int rookX=0;\\n        int rookY=0;\\n        for(int i=0; i<board.length; i++) {\\n            for(int j=0; j<board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    rookX = i;\\n                    rookY = j;\\n                }    \\n            }\\n        }\\n        \\n        int count=0;\\n        for (int i=0; i<4; i++) {\\n            int[] move = moves[i];\\n            int x = rookX;\\n            int y = rookY;\\n            while(rookCanMove(board, x + move[0], y + move[1])) {\\n                x += move[0];\\n                y += move[1];\\n                if (board[x][y] == \\'p\\') {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private boolean rookCanMove(char[][] board, int x, int y) {\\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\\n        if (board[x][y] == \\'B\\') return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] moves = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n    public int numRookCaptures(char[][] board) {\\n        if (board.length==0 || board[0].length==0) return 0;\\n        int rookX=0;\\n        int rookY=0;\\n        for(int i=0; i<board.length; i++) {\\n            for(int j=0; j<board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    rookX = i;\\n                    rookY = j;\\n                }    \\n            }\\n        }\\n        \\n        int count=0;\\n        for (int i=0; i<4; i++) {\\n            int[] move = moves[i];\\n            int x = rookX;\\n            int y = rookY;\\n            while(rookCanMove(board, x + move[0], y + move[1])) {\\n                x += move[0];\\n                y += move[1];\\n                if (board[x][y] == \\'p\\') {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private boolean rookCanMove(char[][] board, int x, int y) {\\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\\n        if (board[x][y] == \\'B\\') return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398665,
                "title": "swift",
                "content": "```\\nfunc numRookCaptures(_ board: [[Character]]) -> Int {\\n\\tvar result = 0\\n\\tvar (row, column) = (0, 0)\\n\\tfor i in 0..<board.count {\\n\\t\\tfor j in 0..<board.count {\\n\\t\\t\\tif board[i][j] == \"R\" {\\n\\t\\t\\t\\trow = i\\n\\t\\t\\t\\tcolumn = j\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// on right\\n\\tfor column in stride(from: column + 1, to: board.count, by: 1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\t// on left\\n\\tfor column in stride(from: column - 1, through: 0, by: -1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\t// on bottom\\n\\tfor row in stride(from: row + 1, to: board.count, by: 1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\t// on top\\n\\tfor row in stride(from: row - 1, through: 0, by: -1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc numRookCaptures(_ board: [[Character]]) -> Int {\\n\\tvar result = 0\\n\\tvar (row, column) = (0, 0)\\n\\tfor i in 0..<board.count {\\n\\t\\tfor j in 0..<board.count {\\n\\t\\t\\tif board[i][j] == \"R\" {\\n\\t\\t\\t\\trow = i\\n\\t\\t\\t\\tcolumn = j\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// on right\\n\\tfor column in stride(from: column + 1, to: board.count, by: 1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\t// on left\\n\\tfor column in stride(from: column - 1, through: 0, by: -1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\t// on bottom\\n\\tfor row in stride(from: row + 1, to: board.count, by: 1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\t// on top\\n\\tfor row in stride(from: row - 1, through: 0, by: -1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 379640,
                "title": "simon-s-note-python3",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        res=0\\n        n_row=len(board)\\n        n_col=len(board[0])\\n        dirs=[[0,1],[0,-1],[-1,0],[1,0]]\\n        for i in range(n_row):\\n            for j in range(n_col):\\n                if board[i][j]==\"R\":\\n                    for dir in dirs:\\n                        cur_r=i\\n                        cur_c=j\\n                        while 0<=cur_r<n_row and 0<=cur_c<n_col:\\n                            if board[cur_r][cur_c]==\\'B\\':\\n                                break\\n                            if board[cur_r][cur_c]==\"p\":\\n                                res+=1\\n                                break\\n                            cur_r+=dir[0]\\n                            cur_c+=dir[1]\\n                    return res\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        res=0\\n        n_row=len(board)\\n        n_col=len(board[0])\\n        dirs=[[0,1],[0,-1],[-1,0],[1,0]]\\n        for i in range(n_row):\\n            for j in range(n_col):\\n                if board[i][j]==\"R\":\\n                    for dir in dirs:\\n                        cur_r=i\\n                        cur_c=j\\n                        while 0<=cur_r<n_row and 0<=cur_c<n_col:\\n                            if board[cur_r][cur_c]==\\'B\\':\\n                                break\\n                            if board[cur_r][cur_c]==\"p\":\\n                                res+=1\\n                                break\\n                            cur_r+=dir[0]\\n                            cur_c+=dir[1]\\n                    return res\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374355,
                "title": "javascript-solution-not-pretty-but-works",
                "content": "```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    let rookI = 0;\\n    let rookJ = 0;\\n    let ans = 0;\\n    \\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            if (board[i][j] == \\'R\\') {\\n                rookI = i;\\n                rookJ = j;\\n            }    \\n        }\\n    }\\n    \\n    for(let i = rookI - 1; i >= 0; i--) {\\n        if(board[i][rookJ] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[i][rookJ] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    for(let i = rookI + 1; i < board.length; i++) {\\n        if(board[i][rookJ] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[i][rookJ] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    for(let i = rookJ - 1; i >= 0; i--) {\\n        if(board[rookI][i] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[rookI][i] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    for(let i = rookJ + 1; i < board.length; i++) {\\n        if(board[rookI][i] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[rookI][i] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    return ans;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    let rookI = 0;\\n    let rookJ = 0;\\n    let ans = 0;\\n    \\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            if (board[i][j] == \\'R\\') {\\n                rookI = i;\\n                rookJ = j;\\n            }    \\n        }\\n    }\\n    \\n    for(let i = rookI - 1; i >= 0; i--) {\\n        if(board[i][rookJ] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[i][rookJ] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    for(let i = rookI + 1; i < board.length; i++) {\\n        if(board[i][rookJ] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[i][rookJ] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    for(let i = rookJ - 1; i >= 0; i--) {\\n        if(board[rookI][i] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[rookI][i] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    for(let i = rookJ + 1; i < board.length; i++) {\\n        if(board[rookI][i] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[rookI][i] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    return ans;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 346332,
                "title": "javascript-4-line-solution-with-explanation",
                "content": "```js\\n/**\\n * explanation:\\n * line1: find position of \"R\",  \"i\" == col, \"j\" == row\\n * line2: get the col and the row of \"R\" as t1 and t2\\n * line3: get the part before \"R\" and reverse it, get the part after \"R\", now the 4 cases are same\\n * line4: remove the \".\" and get the first element, if it\\'s \"p\", means this case count\\n */\\nvar numRookCaptures = function (board) {\\n  let j, i = board.findIndex(r => (j = r.findIndex((c, j) => c == \"R\")) != -1);\\n  let t1 = board.map(r => r[j]), t2 = board[i];\\n  let res = [t1.slice(0, i).reverse(), t1.slice(i + 1), t2.slice(0, j).reverse(), t2.slice(j + 1)];\\n  return res.filter(r => r.filter(c => c != \".\")[0] == \"p\").length;\\n};\\n\\n",
                "solutionTags": [],
                "code": "```js\\n/**\\n * explanation:\\n * line1: find position of \"R\",  \"i\" == col, \"j\" == row\\n * line2: get the col and the row of \"R\" as t1 and t2\\n * line3: get the part before \"R\" and reverse it, get the part after \"R\", now the 4 cases are same\\n * line4: remove the \".\" and get the first element, if it\\'s \"p\", means this case count\\n */\\nvar numRookCaptures = function (board) {\\n  let j, i = board.findIndex(r => (j = r.findIndex((c, j) => c == \"R\")) != -1);\\n  let t1 = board.map(r => r[j]), t2 = board[i];\\n  let res = [t1.slice(0, i).reverse(), t1.slice(i + 1), t2.slice(0, j).reverse(), t2.slice(j + 1)];\\n  return res.filter(r => r.filter(c => c != \".\")[0] == \"p\").length;\\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 293042,
                "title": "simple-java-100",
                "content": "```\\nclass Solution {\\n    \\n    public int numRookCaptures(char[][] board) {\\n        int i = 0;\\n        int R_v = -1;\\n        int R_h = -1;\\n        while(i < 64) {\\n            int v = i % 8;\\n            int h = i / 8;\\n            if (board[h][v] == \\'R\\') {\\n                R_v = v;\\n                R_h = h;\\n                break;\\n            }\\n            i++;\\n        }\\n        if (R_v < 0 || R_h < 0) return 0;\\n        return search(board, R_h, R_v, 0, 1) + search(board, R_h, R_v, 1, 0) + search(board, R_h, R_v, 0, -1) + search(board, R_h, R_v, -1, 0);\\n    }\\n    private int search(char[][] board,int h,int v,int step_h,int step_v) {\\n        while (h < 8 && h >= 0 && v < 8 && v >= 0) {\\n            if (board[h][v] == \\'R\\' || board[h][v] == \\'.\\') {\\n                h += step_h;\\n                v += step_v;\\n                continue;\\n            }\\n            if (board[h][v] == \\'B\\') return 0;\\n            if (board[h][v] == \\'p\\') return 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int numRookCaptures(char[][] board) {\\n        int i = 0;\\n        int R_v = -1;\\n        int R_h = -1;\\n        while(i < 64) {\\n            int v = i % 8;\\n            int h = i / 8;\\n            if (board[h][v] == \\'R\\') {\\n                R_v = v;\\n                R_h = h;\\n                break;\\n            }\\n            i++;\\n        }\\n        if (R_v < 0 || R_h < 0) return 0;\\n        return search(board, R_h, R_v, 0, 1) + search(board, R_h, R_v, 1, 0) + search(board, R_h, R_v, 0, -1) + search(board, R_h, R_v, -1, 0);\\n    }\\n    private int search(char[][] board,int h,int v,int step_h,int step_v) {\\n        while (h < 8 && h >= 0 && v < 8 && v >= 0) {\\n            if (board[h][v] == \\'R\\' || board[h][v] == \\'.\\') {\\n                h += step_h;\\n                v += step_v;\\n                continue;\\n            }\\n            if (board[h][v] == \\'B\\') return 0;\\n            if (board[h][v] == \\'p\\') return 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291825,
                "title": "c-simple",
                "content": "\\n\\nint numRookCaptures(char** board, int boardSize, int* boardColSize){\\n    int i, j, flag = 0, rookX, rookY, score = 0;\\n    \\n    for(i = 0; i < 8; i++){\\n        for(j = 0; j < 8; j++){\\n            if(board[i][j] == \\'R\\'){\\n                rookX = i;\\n                rookY = j;\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if(flag == 1)\\n            break;\\n    }\\n    \\n    for(i = rookX; i < 8; i++){\\n        if(board[rookX][i] == \\'B\\')\\n            break;\\n        else if(board[rookX][i] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }  \\n    for(i = rookX; i >= 0; i--){\\n        if(board[rookX][i] == \\'B\\')\\n            break;\\n        else if(board[rookX][i] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }\\n    \\n    for(i = rookY; i < 8; i++){\\n        if(board[i][rookY] == \\'B\\')\\n            break;\\n        else if(board[i][rookY] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }\\n    for(i = rookY; i > 0; i--){\\n        if(board[i][rookY] == \\'B\\')\\n            break;\\n        else if(board[i][rookY] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }\\n    \\n    return score;\\n}",
                "solutionTags": [],
                "code": "\\n\\nint numRookCaptures(char** board, int boardSize, int* boardColSize){\\n    int i, j, flag = 0, rookX, rookY, score = 0;\\n    \\n    for(i = 0; i < 8; i++){\\n        for(j = 0; j < 8; j++){\\n            if(board[i][j] == \\'R\\'){\\n                rookX = i;\\n                rookY = j;\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if(flag == 1)\\n            break;\\n    }\\n    \\n    for(i = rookX; i < 8; i++){\\n        if(board[rookX][i] == \\'B\\')\\n            break;\\n        else if(board[rookX][i] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }  \\n    for(i = rookX; i >= 0; i--){\\n        if(board[rookX][i] == \\'B\\')\\n            break;\\n        else if(board[rookX][i] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }\\n    \\n    for(i = rookY; i < 8; i++){\\n        if(board[i][rookY] == \\'B\\')\\n            break;\\n        else if(board[i][rookY] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }\\n    for(i = rookY; i > 0; i--){\\n        if(board[i][rookY] == \\'B\\')\\n            break;\\n        else if(board[i][rookY] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }\\n    \\n    return score;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 288901,
                "title": "java-solution-100-faster-100-memory-efficient",
                "content": "0ms and ~33 of memory\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ans =0;\\n        int rookI = 0;\\n        int rookJ = 0;\\n        \\n        //find the coordinate of the Rook\\n        for(int i=0; i< board.length; i++){\\n            for(int j=0; j< board[i].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    rookI = i;\\n                    rookJ = j;\\n                } \\n            }\\n        }\\n\\n        int tempR= rookJ;\\n        int tempL = rookJ;\\n        //check Right from position of Rook til end of board(->)\\n        while((tempR < board[rookI].length) && tempR<7){\\n            tempR++;\\n            if(board[rookI][tempR] == \\'B\\'){\\n                break;\\n            }\\n            if(board[rookI][tempR] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n        }\\n        //check Left from position of Rook til end of board(<-)\\n        while(tempL < (board[rookI].length ) && tempL >0){\\n            tempL--;\\n            if(board[rookI][tempL] == \\'B\\')\\n                break;\\n            if(board[rookI][tempL] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n        }\\n        \\n        int tempUp = rookI;\\n        int tempDown = rookI;\\n        //check UP from position of Rook til top of Board\\n        while(tempUp < (board.length) && tempUp>0){\\n            tempUp--;\\n            if(board[tempUp][rookJ] == \\'B\\')\\n                break;\\n            if(board[tempUp][rookJ] == \\'p\\'){\\n                ans++; break;\\n            }\\n        }\\n        //check Down, from position of Rook til bottom of board\\n        while(tempDown < (board.length ) && tempDown <7){\\n            tempDown++;\\n            if(board[tempDown][rookJ] == \\'B\\')\\n                break;\\n            if(board[tempDown][rookJ] == \\'p\\'){\\n                ans++; break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ans =0;\\n        int rookI = 0;\\n        int rookJ = 0;\\n        \\n        //find the coordinate of the Rook\\n        for(int i=0; i< board.length; i++){\\n            for(int j=0; j< board[i].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    rookI = i;\\n                    rookJ = j;\\n                } \\n            }\\n        }\\n\\n        int tempR= rookJ;\\n        int tempL = rookJ;\\n        //check Right from position of Rook til end of board(->)\\n        while((tempR < board[rookI].length) && tempR<7){\\n            tempR++;\\n            if(board[rookI][tempR] == \\'B\\'){\\n                break;\\n            }\\n            if(board[rookI][tempR] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n        }\\n        //check Left from position of Rook til end of board(<-)\\n        while(tempL < (board[rookI].length ) && tempL >0){\\n            tempL--;\\n            if(board[rookI][tempL] == \\'B\\')\\n                break;\\n            if(board[rookI][tempL] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n        }\\n        \\n        int tempUp = rookI;\\n        int tempDown = rookI;\\n        //check UP from position of Rook til top of Board\\n        while(tempUp < (board.length) && tempUp>0){\\n            tempUp--;\\n            if(board[tempUp][rookJ] == \\'B\\')\\n                break;\\n            if(board[tempUp][rookJ] == \\'p\\'){\\n                ans++; break;\\n            }\\n        }\\n        //check Down, from position of Rook til bottom of board\\n        while(tempDown < (board.length ) && tempDown <7){\\n            tempDown++;\\n            if(board[tempDown][rookJ] == \\'B\\')\\n                break;\\n            if(board[tempDown][rookJ] == \\'p\\'){\\n                ans++; break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286158,
                "title": "compact-python-solution",
                "content": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def get_r_index(self, board):\\n        for i, row in enumerate(board):\\n            for j, val in enumerate(row):\\n                if val == \\'R\\':\\n                    return i, j\\n\\n    def check(self, coords, board):\\n        for i, j in coords:\\n            if board[i][j] == \\'p\\':\\n                return 1\\n            if board[i][j] != \\'.\\':\\n                return 0\\n        return 0\\n\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        ri, rj = self.get_r_index(board)\\n        products = [\\n            product([ri], range(rj - 1, -1, -1)),\\n            product([ri], range(rj + 1, len(board))),\\n            product(range(ri - 1, -1, -1), [rj]),\\n            product(range(ri + 1, len(board[0])), [rj])\\n        ]\\n        return sum(self.check(p, board) for p in products)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def get_r_index(self, board):\\n        for i, row in enumerate(board):\\n            for j, val in enumerate(row):\\n                if val == \\'R\\':\\n                    return i, j\\n\\n    def check(self, coords, board):\\n        for i, j in coords:\\n            if board[i][j] == \\'p\\':\\n                return 1\\n            if board[i][j] != \\'.\\':\\n                return 0\\n        return 0\\n\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        ri, rj = self.get_r_index(board)\\n        products = [\\n            product([ri], range(rj - 1, -1, -1)),\\n            product([ri], range(rj + 1, len(board))),\\n            product(range(ri - 1, -1, -1), [rj]),\\n            product(range(ri + 1, len(board[0])), [rj])\\n        ]\\n        return sum(self.check(p, board) for p in products)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283048,
                "title": "java-solution-faster-than-100-and-less-than-100",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n        int[][] oper = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    for (int k = 0; k < 4; k++) {\\n                        int a = i + oper[k][0];\\n                        int b = j + oper[k][1];\\n                        while (0 <= a && a < 8 && 0 <= b && b < 8) {\\n                            if (board[a][b] == \\'B\\') {\\n                                break;\\n                            }\\n                            if (board[a][b] == \\'p\\') {\\n                                count++;\\n                                break;\\n                            }\\n                            a += oper[k][0];\\n                            b += oper[k][1];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n        int[][] oper = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    for (int k = 0; k < 4; k++) {\\n                        int a = i + oper[k][0];\\n                        int b = j + oper[k][1];\\n                        while (0 <= a && a < 8 && 0 <= b && b < 8) {\\n                            if (board[a][b] == \\'B\\') {\\n                                break;\\n                            }\\n                            if (board[a][b] == \\'p\\') {\\n                                count++;\\n                                break;\\n                            }\\n                            a += oper[k][0];\\n                            b += oper[k][1];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266989,
                "title": "javascript-faster-than-97-53-less-memory-than-100",
                "content": "```\\nvar numRookCaptures = function(board) {\\n    \\n    //Find rook\\n    let x = 0, y = 0, pawns = 0;\\n    for (y = 0; y < 8; y++)  {\\n        if(board[y].indexOf(\\'R\\') >= 0) {\\n            x = board[y].indexOf(\\'R\\');\\n            break;\\n        }\\n    }\\n    \\n    //Horizontal moves\\n    [-1, 1].forEach(incr => {\\n        let i = x;\\n        while(board[y][i] && board[y][i] !== \\'B\\') {\\n            if(board[y][i] === \\'p\\') {\\n                pawns++;\\n                break;\\n            }\\n            i += incr;\\n        }\\n    });\\n    \\n    //Vertical moves\\n    [-1, 1].forEach(incr => {\\n        let i = y;\\n        while((board[i] || 0)[x] && (board[i] || 0)[x] !== \\'B\\') {\\n            if(board[i][x] === \\'p\\') {\\n                pawns++;\\n                break;\\n            }\\n            i += incr;\\n        }\\n    });\\n    \\n    return pawns;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numRookCaptures = function(board) {\\n    \\n    //Find rook\\n    let x = 0, y = 0, pawns = 0;\\n    for (y = 0; y < 8; y++)  {\\n        if(board[y].indexOf(\\'R\\') >= 0) {\\n            x = board[y].indexOf(\\'R\\');\\n            break;\\n        }\\n    }\\n    \\n    //Horizontal moves\\n    [-1, 1].forEach(incr => {\\n        let i = x;\\n        while(board[y][i] && board[y][i] !== \\'B\\') {\\n            if(board[y][i] === \\'p\\') {\\n                pawns++;\\n                break;\\n            }\\n            i += incr;\\n        }\\n    });\\n    \\n    //Vertical moves\\n    [-1, 1].forEach(incr => {\\n        let i = y;\\n        while((board[i] || 0)[x] && (board[i] || 0)[x] !== \\'B\\') {\\n            if(board[i][x] === \\'p\\') {\\n                pawns++;\\n                break;\\n            }\\n            i += incr;\\n        }\\n    });\\n    \\n    return pawns;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 263479,
                "title": "simple-java-solution-beats-100",
                "content": "```\\npublic int numRookCaptures(char[][] board) {\\n        int numberOfSteps = 0;\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    numberOfSteps+=goUp(board,i,j)?1:0;\\n                    numberOfSteps+=godown(board,i,j)?1:0;\\n                    numberOfSteps+=goLeft(board,i,j)?1:0;\\n                    numberOfSteps+=goRight(board,i,j)?1:0;\\n                    break;\\n                }\\n            }\\n        }\\n        return numberOfSteps;\\n    }\\n\\n    private boolean goUp(char[][]board, int i,int j){\\n        for(;i>=0;i--){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean godown(char[][]board, int i,int j){\\n        for(;i<board.length;i++){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean goLeft(char[][]board, int i,int j){\\n        for(;j>=0;j--){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean goRight(char[][]board, int i,int j){\\n        for(;j<board[i].length;j++){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numRookCaptures(char[][] board) {\\n        int numberOfSteps = 0;\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    numberOfSteps+=goUp(board,i,j)?1:0;\\n                    numberOfSteps+=godown(board,i,j)?1:0;\\n                    numberOfSteps+=goLeft(board,i,j)?1:0;\\n                    numberOfSteps+=goRight(board,i,j)?1:0;\\n                    break;\\n                }\\n            }\\n        }\\n        return numberOfSteps;\\n    }\\n\\n    private boolean goUp(char[][]board, int i,int j){\\n        for(;i>=0;i--){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean godown(char[][]board, int i,int j){\\n        for(;i<board.length;i++){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean goLeft(char[][]board, int i,int j){\\n        for(;j>=0;j--){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean goRight(char[][]board, int i,int j){\\n        for(;j<board[i].length;j++){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 254026,
                "title": "c-solution-100-faster-in-speed-and-100-less-in-memory",
                "content": "int row = 0;\\n        int col = 0;\\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i < 8 ; i ++){\\n            \\n            for(int j = 0; j < 8;j++){\\n                \\n                if(board[i][j] == \\'R\\'){\\n                    \\n                   \\n                    row = i;\\n                    col = j;\\n                    break;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        for(int i = col; i< 8;i++){\\n            \\n            if(board[row][i] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[row][i] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n         for(int i = col; i>=0;i--){\\n            \\n            if(board[row][i] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[row][i] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n        \\n        \\n        \\n         for(int i = row; i< 8;i++){\\n            \\n            if(board[i][col] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[i][col] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n         for(int i = row; i >= 0;i--){\\n            \\n            if(board[i][col] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[i][col] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n        \\n        \\n        \\n",
                "solutionTags": [],
                "code": "int row = 0;\\n        int col = 0;\\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i < 8 ; i ++){\\n            \\n            for(int j = 0; j < 8;j++){\\n                \\n                if(board[i][j] == \\'R\\'){\\n                    \\n                   \\n                    row = i;\\n                    col = j;\\n                    break;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        for(int i = col; i< 8;i++){\\n            \\n            if(board[row][i] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[row][i] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n         for(int i = col; i>=0;i--){\\n            \\n            if(board[row][i] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[row][i] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n        \\n        \\n        \\n         for(int i = row; i< 8;i++){\\n            \\n            if(board[i][col] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[i][col] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n         for(int i = row; i >= 0;i--){\\n            \\n            if(board[i][col] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[i][col] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n        \\n        \\n        \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 251796,
                "title": "c-faster-than-100-smaller-than-100",
                "content": "For each direction among up, down, left, right, move the current position one step forward each time and see the if it bump into a paw (\\'p\\') or a Bishop \\'(B)\\'.\\ni.e.\\n```\\nfor each direction\\n    initialize current position (x,y) to be (xR, yR)\\n    while (current position (x,y) does not reach the bound)\\n\\t    if (board[x][y]==\\'B\\')\\n\\t\\t    break; /*search on current direction ends.*/\\n\\t    else if (board[x][y]==\\'p\\')\\n\\t\\t\\tbreak; /*search on current direction ends.*/\\n\\t\\t\\t++count;\\n\\t\\tend if\\n\\t\\tupdate (x, y) //move one step forward on the current direction\\n\\tend while\\nend for\\n```\\n use directions[4][2]=[(-1,0), (1,0), (0, 1), (0, -1)]  to represent 4 directions: up, down, left, right.  Since the bound coordinates (when no Bishop or paw is met during the search and we search right to the bound of the board on that direction) varies with the direction:\\n \\n use **int bound_dimension** and **int bound_value** to record the how to measure if we reach the bound.\\n here I used bound_dimension =0 to represent that we measure if we reach the bound by current row coordinate, 1 for column coordinate:\\n ![image](https://assets.leetcode.com/users/lilytennant/image_1552124840.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int Rrow, Rcolumn, answer=0;\\n        for (int row=0; row<8; row++) {\\n            for (int column=0; column<8; column++) {\\n                if (board[row][column]==\\'R\\') {\\n                    Rrow=row;\\n                    Rcolumn=column;\\n                }\\n            }\\n        }\\n        int directions[4][2]={-1,0,1,0,0,-1,0,1};\\n        for (int choice=0; choice<4; choice++) {\\n            int current_coordinates[2]={Rrow, Rcolumn};\\n            int bound_dimension, bound_value;\\n            bound_dimension=(directions[choice][0]==0)?1:0;\\n            bound_value=(directions[choice][bound_dimension]==-1)?-1:8;\\n            while (current_coordinates[bound_dimension]!=bound_value) {\\n                char current_value=board[current_coordinates[0]][current_coordinates[1]];\\n                if (current_value==\\'p\\') {\\n                    ++answer;\\n                    break;\\n                } else if (current_value==\\'B\\') {\\n                    break;\\n                }\\n                current_coordinates[bound_dimension]+=directions[choice][bound_dimension];\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\\nHowever, I think it can be improved if just use enum **directions {up, down, left, right}** to represent these directions, I used 2-dimensional array because I thought I can update the coordinates but add **(directionX, directionY)** on both dimension in the beginning. But turns out there\\'s no need and doing so complicates the logic a little bit, so the solution could have been faster.",
                "solutionTags": [],
                "code": "```\\nfor each direction\\n    initialize current position (x,y) to be (xR, yR)\\n    while (current position (x,y) does not reach the bound)\\n\\t    if (board[x][y]==\\'B\\')\\n\\t\\t    break; /*search on current direction ends.*/\\n\\t    else if (board[x][y]==\\'p\\')\\n\\t\\t\\tbreak; /*search on current direction ends.*/\\n\\t\\t\\t++count;\\n\\t\\tend if\\n\\t\\tupdate (x, y) //move one step forward on the current direction\\n\\tend while\\nend for\\n```\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int Rrow, Rcolumn, answer=0;\\n        for (int row=0; row<8; row++) {\\n            for (int column=0; column<8; column++) {\\n                if (board[row][column]==\\'R\\') {\\n                    Rrow=row;\\n                    Rcolumn=column;\\n                }\\n            }\\n        }\\n        int directions[4][2]={-1,0,1,0,0,-1,0,1};\\n        for (int choice=0; choice<4; choice++) {\\n            int current_coordinates[2]={Rrow, Rcolumn};\\n            int bound_dimension, bound_value;\\n            bound_dimension=(directions[choice][0]==0)?1:0;\\n            bound_value=(directions[choice][bound_dimension]==-1)?-1:8;\\n            while (current_coordinates[bound_dimension]!=bound_value) {\\n                char current_value=board[current_coordinates[0]][current_coordinates[1]];\\n                if (current_value==\\'p\\') {\\n                    ++answer;\\n                    break;\\n                } else if (current_value==\\'B\\') {\\n                    break;\\n                }\\n                current_coordinates[bound_dimension]+=directions[choice][bound_dimension];\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251102,
                "title": "c-solution",
                "content": "```C\\nint numRookCaptures(char **board, int boardRowSize, int boardColSize) {\\n    int result = 0;\\n    for (int i = 0; i < boardRowSize; ++i) {\\n        for (int j = 0; j < boardColSize; ++j) {\\n            if (board[i][j] == \\'R\\') {\\n                for (int left = j; left > 0; --left) {\\n                    if (board[i][left] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[i][left] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n                for (int right = j; right < boardColSize; ++right) {\\n                    if (board[i][right] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[i][right] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n                for (int up = j; up > 0; --up) {\\n                    if (board[up][j] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[up][j] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n                for (int down = j; down < boardRowSize; ++down) {\\n                    if (board[down][j] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[down][j] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n\\n                break;\\n            }\\n        }\\n\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C\\nint numRookCaptures(char **board, int boardRowSize, int boardColSize) {\\n    int result = 0;\\n    for (int i = 0; i < boardRowSize; ++i) {\\n        for (int j = 0; j < boardColSize; ++j) {\\n            if (board[i][j] == \\'R\\') {\\n                for (int left = j; left > 0; --left) {\\n                    if (board[i][left] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[i][left] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n                for (int right = j; right < boardColSize; ++right) {\\n                    if (board[i][right] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[i][right] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n                for (int up = j; up > 0; --up) {\\n                    if (board[up][j] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[up][j] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n                for (int down = j; down < boardRowSize; ++down) {\\n                    if (board[down][j] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[down][j] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n\\n                break;\\n            }\\n        }\\n\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250030,
                "title": "simple-c",
                "content": "```\\nint numRookCaptures(char** board, int boardRowSize, int *boardColSizes) {\\n    \\n    int count = 0;\\n    for (int i = 0; i < boardRowSize; i++) {\\n        for (int j = 0; j < sizeof(boardColSizes); j++) {\\n            if (board[i][j] == \\'R\\') {\\n                if (i+1 < 8) {\\n                    for (int k = i+1; k < 8; k++) {\\n                        if (board[k][j] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[k][j] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (i-1 >= 0) {\\n                    for (int k = i-1; k >= 0; k--) {\\n                        if (board[k][j] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[k][j] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }  \\n                }\\n                \\n                if (j+1 < 8) {\\n                    for (int k = j+1; k < 8; k++) {\\n                        if (board[i][k] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[i][k] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n                if (j-1 >= 0) {\\n                    for (int k = j-1; k >= 0; k--) {\\n                        if (board[i][k] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[i][k] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numRookCaptures(char** board, int boardRowSize, int *boardColSizes) {\\n    \\n    int count = 0;\\n    for (int i = 0; i < boardRowSize; i++) {\\n        for (int j = 0; j < sizeof(boardColSizes); j++) {\\n            if (board[i][j] == \\'R\\') {\\n                if (i+1 < 8) {\\n                    for (int k = i+1; k < 8; k++) {\\n                        if (board[k][j] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[k][j] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (i-1 >= 0) {\\n                    for (int k = i-1; k >= 0; k--) {\\n                        if (board[k][j] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[k][j] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }  \\n                }\\n                \\n                if (j+1 < 8) {\\n                    for (int k = j+1; k < 8; k++) {\\n                        if (board[i][k] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[i][k] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n                if (j-1 >= 0) {\\n                    for (int k = j-1; k >= 0; k--) {\\n                        if (board[i][k] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[i][k] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250004,
                "title": "java-100-with-3ms-easy-solution",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        for (int i=0;i<8;i++){\\n            for (int j=0;j<8;j++){\\n                if( board[i][j] == \\'R\\' ){\\n                    return getKill(i,j,\"white\",board);\\n                }\\n                else if(board[i][j]==\\'r\\'){\\n                    return getKill(i,j,\"black\",board);\\n                }\\n\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int getKill(int row, int col, String color,char[][] brd){\\n        char oppB =\\'B\\';\\n        char oppP = \\'P\\';\\n        int count = 0;\\n        if(color.equals(\"white\")){\\n            oppB = \\'b\\';\\n            oppP = \\'p\\';\\n            System.out.println(\"WHITE\");\\n        }\\n        for (int i = row+1; i<8;i++){\\n            System.out.println(\"row incre \");\\n            if (brd[i][col]==oppB || brd[i][col]==oppP){\\n                count++;\\n                break;\\n            }\\n            else if (brd[i][col]!=\\'.\\'){\\n                break;\\n            }\\n        }\\n        for (int i = row-1; i>=0;i--){\\n            System.out.println(\"row dec \");\\n            if (brd[i][col]==oppB || brd[i][col]==oppP){\\n                count++;\\n                break;\\n            }\\n            else if (brd[i][col]!=\\'.\\'){\\n                break;\\n            }\\n        }\\n        \\n        for (int i = col-1; i>=0;i--){\\n            System.out.println(\"col dec \");\\n            if (brd[row][i]==oppB || brd[row][i]==oppP){\\n                count++;\\n                break;\\n            }\\n            else if (brd[row][i]!=\\'.\\'){\\n                break;\\n            }\\n        }\\n        \\n        for (int i = col+1; i<8;i++){\\n            System.out.println(\"col incre \");\\n            if (brd[row][i]==oppB || brd[row][i]==oppP){\\n                count++;\\n                break;\\n            }\\n            else if (brd[row][i]!=\\'.\\'){\\n                break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numRookCaptures(char[][] board) {\\n        for (int i=0;i<8;i++){\\n            for (int j=0;j<8;j++){\\n                if( board[i][j] == \\'R\\' ){\\n                    return getKill(i,j,\"white\",board);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 248464,
                "title": "python-solution-faster-than-100",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n                \\n        rook_i = 0\\n        rook_j = 0\\n        pawns = 0\\n        \\n        #find the position of rook on the board\\n        for i in range(0, len(board)):\\n            for j in range(0, len(board[i])):\\n                if board[i][j] == \"R\":\\n                    rook_i = i\\n                    rook_j = j\\n        \\n        for x,y in [(1,0), (0,1), (-1,0), (0,-1)]:\\n            pawns += self.boardTraverse(board, rook_i, rook_j, x, y)\\n        \\n        return pawns\\n    \\n    def boardTraverse(self, board, row, col, x, y):\\n        if not 0 <= row < 8 or not 0 <= col < 8 or board[row][col] == \\'B\\':\\n            return 0\\n        elif board[row][col] == \\'p\\':\\n            return 1\\n        else:\\n            return self.boardTraverse(board, row+x, col+y, x, y)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n                \\n        rook_i = 0\\n        rook_j = 0\\n        pawns = 0\\n        \\n        #find the position of rook on the board\\n        for i in range(0, len(board)):\\n            for j in range(0, len(board[i])):\\n                if board[i][j] == \"R\":\\n                    rook_i = i\\n                    rook_j = j\\n        \\n        for x,y in [(1,0), (0,1), (-1,0), (0,-1)]:\\n            pawns += self.boardTraverse(board, rook_i, rook_j, x, y)\\n        \\n        return pawns\\n    \\n    def boardTraverse(self, board, row, col, x, y):\\n        if not 0 <= row < 8 or not 0 <= col < 8 or board[row][col] == \\'B\\':\\n            return 0\\n        elif board[row][col] == \\'p\\':\\n            return 1\\n        else:\\n            return self.boardTraverse(board, row+x, col+y, x, y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244458,
                "title": "js-javascript-w-comments-52ms-100-time-and-space",
                "content": "1. Get the row and column arrays relative to the Rook\\n2. Track the Rook position respective to the row and column arrays \\n3. Search the cardinal directions on each side of the Rook and cache the relevant Pawn and Bishop positions\\n4.  If a bishop is not present east or north of the rook, set its position off the board (rather than breaking the search loops)\\n5.  Count capturable pawns from the cache and return the total\\n\\n```\\nconst numRookCaptures = function(board) {\\n  let results = 0, loc = {leftP: null, leftB: null, rightP: null, rightB: null, upP: null, upB: null, downP: null, downB: null};\\n  const getRookRow = b => b ? b.filter( row => row.indexOf(\\'R\\') !== -1 ).pop() : null;\\n  const getRookColumn = b => b.reduce( (acc, row, i) => { acc.push(row[getRookRow(b).indexOf(\\'R\\')]); return acc; }, []);\\n  \\n  // 1.\\n  const row = getRookRow(board), col = getRookColumn(board);\\n  \\n  // 2.\\n  const rowRPos = row.indexOf(\\'R\\'), colRPos = col.indexOf(\\'R\\');\\n \\n  // 3.\\n  for (let i = 0; i < rowRPos; i++ ) {\\n    if (row[i] === \\'p\\') loc.leftP = i;\\n    if (row[i] === \\'B\\') loc.leftB = i;\\n  }\\n  for (let i = row.length - 1; i > rowRPos; i-- ) {\\n    if (row[i] === \\'p\\') loc.rightP = i;\\n    if (row[i] === \\'B\\') loc.rightB = i;\\n  }\\n  for (let i = 0; i < colRPos; i++ ) {\\n    if (col[i] === \\'p\\') loc.upP = i;\\n    if (col[i] === \\'B\\') loc.upB = i;\\n  }\\n  for (let i = col.length - 1; i > colRPos; i-- ) {\\n    if (col[i] === \\'p\\') loc.downP = i;\\n    if (col[i] === \\'B\\') loc.downB = i;\\n  }\\n  \\n  // 4.\\n  if (!loc.rightB) loc.rightB = row.length + 1;\\n  if (!loc.downB) loc.downB = row.length + 1;\\n \\n // 5.\\n  if (loc.leftP && loc.leftP > loc.leftB) results++;\\n  if (loc.rightP && loc.rightP < loc.rightB) results++;\\n  if (loc.upP && loc.upP > loc.upB) results++;\\n  if (loc.downP && loc.downP < loc.downB) results++;\\n  return results;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst numRookCaptures = function(board) {\\n  let results = 0, loc = {leftP: null, leftB: null, rightP: null, rightB: null, upP: null, upB: null, downP: null, downB: null};\\n  const getRookRow = b => b ? b.filter( row => row.indexOf(\\'R\\') !== -1 ).pop() : null;\\n  const getRookColumn = b => b.reduce( (acc, row, i) => { acc.push(row[getRookRow(b).indexOf(\\'R\\')]); return acc; }, []);\\n  \\n  // 1.\\n  const row = getRookRow(board), col = getRookColumn(board);\\n  \\n  // 2.\\n  const rowRPos = row.indexOf(\\'R\\'), colRPos = col.indexOf(\\'R\\');\\n \\n  // 3.\\n  for (let i = 0; i < rowRPos; i++ ) {\\n    if (row[i] === \\'p\\') loc.leftP = i;\\n    if (row[i] === \\'B\\') loc.leftB = i;\\n  }\\n  for (let i = row.length - 1; i > rowRPos; i-- ) {\\n    if (row[i] === \\'p\\') loc.rightP = i;\\n    if (row[i] === \\'B\\') loc.rightB = i;\\n  }\\n  for (let i = 0; i < colRPos; i++ ) {\\n    if (col[i] === \\'p\\') loc.upP = i;\\n    if (col[i] === \\'B\\') loc.upB = i;\\n  }\\n  for (let i = col.length - 1; i > colRPos; i-- ) {\\n    if (col[i] === \\'p\\') loc.downP = i;\\n    if (col[i] === \\'B\\') loc.downB = i;\\n  }\\n  \\n  // 4.\\n  if (!loc.rightB) loc.rightB = row.length + 1;\\n  if (!loc.downB) loc.downB = row.length + 1;\\n \\n // 5.\\n  if (loc.leftP && loc.leftP > loc.leftB) results++;\\n  if (loc.rightP && loc.rightP < loc.rightB) results++;\\n  if (loc.upP && loc.upP > loc.upB) results++;\\n  if (loc.downP && loc.downP < loc.downB) results++;\\n  return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244293,
                "title": "js-solution",
                "content": "```\\n\\n```/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    let R = null\\n \\n    board.forEach((lst,i)=>(lst.forEach((rook, j)=> {(rook == \\'R\\' ? R = {x: j,y: i} : 0)})));\\n    \\n    let row = board[R.y].toString().replace(/\\\\,|\\\\./g, \"\");\\n    let col = board.map((lst)=>lst[R.x]).toString().replace(/\\\\,|\\\\./g, \"\");\\n    \\n\\n    let r = row.indexOf(\"R\"), c = col.indexOf(\"R\"), count = 0;\\n    \\n    for (let i=r-1; i<=r+1;i++){\\n        if (r != -1 && row[i] == \\'p\\'){\\n            count++;\\n        }\\n    }\\n    \\n    for (let i=c-1; i<=c+1;i++){\\n        if (c != -1 && col[i] == \\'p\\'){\\n            count++;\\n        }\\n    }\\n    \\n    console.log(R, row, col)\\n    \\n    return count\\n    \\n   \\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244133,
                "title": "java-solution-1ms",
                "content": "Pseudocode:\\n```\\nFind Rook\\nSearch left from rooks position:\\n\\tif bishop, break\\n\\tif pawn, counter++ and break\\nDo the same with right, up, and down from rooks position\\nreturn counter\\n```\\nSolution:\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int x = -1, y = -1;\\n        for(int i = 0; i < 8; i++) {\\n            for(int j = 0; j < 8; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    x = i;\\n                    y = j;\\n                    break;\\n                }\\n            }\\n            if(x != -1) break;\\n        }\\n        \\n        // board[x][y] is the rook\\n        // search above, if bishop is hit, break, if pawn is hit, increase counter and break\\n        int counter = 0;\\n        for(int i = x; i >= 0; i--) {\\n            if(board[i][y] == \\'B\\') break;\\n            if(board[i][y] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        //search below\\n        for(int i = x; i < 8; i++) {\\n            if(board[i][y] == \\'B\\') break;\\n            if(board[i][y] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        // search left\\n        for(int i = y; i >= 0; i--) {\\n            if(board[x][i] == \\'B\\') break;\\n            if(board[x][i] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        // search right\\n        for(int i = y; i < 8; i++) {\\n            if(board[x][i] == \\'B\\') break;\\n            if(board[x][i] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nFind Rook\\nSearch left from rooks position:\\n\\tif bishop, break\\n\\tif pawn, counter++ and break\\nDo the same with right, up, and down from rooks position\\nreturn counter\\n```\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int x = -1, y = -1;\\n        for(int i = 0; i < 8; i++) {\\n            for(int j = 0; j < 8; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    x = i;\\n                    y = j;\\n                    break;\\n                }\\n            }\\n            if(x != -1) break;\\n        }\\n        \\n        // board[x][y] is the rook\\n        // search above, if bishop is hit, break, if pawn is hit, increase counter and break\\n        int counter = 0;\\n        for(int i = x; i >= 0; i--) {\\n            if(board[i][y] == \\'B\\') break;\\n            if(board[i][y] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        //search below\\n        for(int i = x; i < 8; i++) {\\n            if(board[i][y] == \\'B\\') break;\\n            if(board[i][y] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        // search left\\n        for(int i = y; i >= 0; i--) {\\n            if(board[x][i] == \\'B\\') break;\\n            if(board[x][i] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        // search right\\n        for(int i = y; i < 8; i++) {\\n            if(board[x][i] == \\'B\\') break;\\n            if(board[x][i] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243636,
                "title": "simple-java-recursive-flood-fill-algorithm-1ms",
                "content": "\\'\\'\\'\\nclass Solution {\\n    \\n    public int numRookCaptures(char[][] board, int row, int col, char direction){\\n        if(row >= 8 || col >= 8 || row < 0 || col < 0) return 0;\\n        \\n        if(board[row][col] != \\'.\\' && board[row][col] != \\'R\\'){\\n            if(board[row][col] == \\'p\\')\\n                return 1;\\n            return 0;\\n        }\\n        \\n        if(direction == \\'u\\'){\\n            return (numRookCaptures(board,row-1,col,direction));\\n        }\\n        else if(direction ==\\'d\\'){\\n            return (numRookCaptures(board,row+1,col,direction));\\n        }\\n        else if(direction == \\'l\\'){\\n            return (numRookCaptures(board,row,col-1,direction));\\n        }\\n        \\n        return (numRookCaptures(board,row,col+1,direction));\\n    }\\n    \\n    public int numRookCaptures(char[][] board) {\\n        \\n        int row = -1,col = -1;\\n        \\n        for(int i = 0; i < 8 ; i++){\\n            for(int j = 0; j < 8 ; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return numRookCaptures(board,row,col,\\'u\\')+numRookCaptures(board,row,col,\\'l\\')+numRookCaptures(board,row,col,\\'r\\')+numRookCaptures(board,row,col,\\'d\\');\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int numRookCaptures(char[][] board, int row, int col, char direction){\\n        if(row >= 8 || col >= 8 || row < 0 || col < 0) return 0;\\n        \\n        if(board[row][col] != \\'.\\' && board[row][col] != \\'R\\'){\\n            if(board[row][col] == \\'p\\')\\n                return 1;\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 243345,
                "title": "simple-ac-python-solution-16-ms-beats-100",
                "content": "Uncomment the commented lines for clarity / understanding testcases\\n\\n```\\n\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        def findWhiteRook(board):\\n            for i in range(len(board)):\\n                for j in range(len(board[0])):\\n                    if board[i][j] == \\'R\\':\\n                        return (i,j)\\n            return -1\\n        rr, rc = findWhiteRook(board)\\n        kills = 0\\n        # print(\"White Rook at \", rr, rc)\\n\\t\\t\\n\\t\\t# west\\n        for ic in range(rc-1,-1,-1):\\n            if board[rr][ic] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(rr,ic))\\n                kills += 1\\n                break\\n            elif board[rr][ic] == \\'B\\' or board[rr][ic] == \\'P\\':\\n                break\\n        \\n\\t\\t# east\\n        for ic in range(rc+1,len(board[0])):\\n            if board[rr][ic] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(rr,ic))\\n                kills += 1\\n                break\\n            elif board[rr][ic] == \\'B\\' or board[rr][ic] == \\'P\\':\\n                break\\n        \\n\\t\\t# south\\n        for ir in range(rr+1,len(board)):\\n            if board[ir][rc] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(ir,rc))\\n                kills += 1\\n                break\\n            elif board[ir][rc] == \\'B\\' or board[ir][rc] == \\'P\\':\\n                break\\n        \\n        # north\\n        for ir in range(rr-1,-1,-1):\\n            if board[ir][rc] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(ir,rc))\\n                kills += 1\\n                break\\n            elif board[ir][rc] == \\'B\\' or board[ir][rc] == \\'P\\':\\n                break\\n        return kills\\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        def findWhiteRook(board):\\n            for i in range(len(board)):\\n                for j in range(len(board[0])):\\n                    if board[i][j] == \\'R\\':\\n                        return (i,j)\\n            return -1\\n        rr, rc = findWhiteRook(board)\\n        kills = 0\\n        # print(\"White Rook at \", rr, rc)\\n\\t\\t\\n\\t\\t# west\\n        for ic in range(rc-1,-1,-1):\\n            if board[rr][ic] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(rr,ic))\\n                kills += 1\\n                break\\n            elif board[rr][ic] == \\'B\\' or board[rr][ic] == \\'P\\':\\n                break\\n        \\n\\t\\t# east\\n        for ic in range(rc+1,len(board[0])):\\n            if board[rr][ic] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(rr,ic))\\n                kills += 1\\n                break\\n            elif board[rr][ic] == \\'B\\' or board[rr][ic] == \\'P\\':\\n                break\\n        \\n\\t\\t# south\\n        for ir in range(rr+1,len(board)):\\n            if board[ir][rc] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(ir,rc))\\n                kills += 1\\n                break\\n            elif board[ir][rc] == \\'B\\' or board[ir][rc] == \\'P\\':\\n                break\\n        \\n        # north\\n        for ir in range(rr-1,-1,-1):\\n            if board[ir][rc] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(ir,rc))\\n                kills += 1\\n                break\\n            elif board[ir][rc] == \\'B\\' or board[ir][rc] == \\'P\\':\\n                break\\n        return kills\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 243184,
                "title": "simple-dfs-python",
                "content": "Basically it\\'s a DFS problem.\\nThere are 3 conditions: \\n1. When meet the bishops, we need to stop and can\\'t go further\\n2.  When meet the pawn, count ++ and then stop;\\n3.  Else we just go straight with the same direction! \\n\\n\\n```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def dfs(row, col, d):\\n            if row < 0 or row >= 8 or col < 0 or col >= 8:\\n                return \\n            if board[row][col] == \"p\":\\n                self.count += 1\\n                return \\n            if board[row][col] == \"B\":\\n                return\\n           \\n            dfs(row + d[0], col + d[1], d)\\n\\n            \\n        self.count = 0\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \"R\":\\n                    dfs(i, j, (1, 0))\\n                    dfs(i, j,  (-1, 0))\\n                    dfs(i, j,  (0, 1))\\n                    dfs(i, j,  (0, -1))\\n        \\n        return self.count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def dfs(row, col, d):\\n            if row < 0 or row >= 8 or col < 0 or col >= 8:\\n                return \\n            if board[row][col] == \"p\":\\n                self.count += 1\\n                return \\n            if board[row][col] == \"B\":\\n                return\\n           \\n            dfs(row + d[0], col + d[1], d)\\n\\n            \\n        self.count = 0\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \"R\":\\n                    dfs(i, j, (1, 0))\\n                    dfs(i, j,  (-1, 0))\\n                    dfs(i, j,  (0, 1))\\n                    dfs(i, j,  (0, -1))\\n        \\n        return self.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242989,
                "title": "python-easy-if-else-solution",
                "content": "```\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n        p1, p2 = -1, -1\\n        count = 0\\n        for i in range(0, 8):\\n            for j in range(0, 8):\\n                if board[i][j] == \\'R\\':\\n                    p1 = i\\n                    p2 = j\\n        # print(p1, p2)\\n        for i in range(p2, 0, -1):\\n            if board[p1][i] == \\'p\\':\\n                count += 1\\n                break\\n            if board[p1][i] == \\'B\\':\\n                break\\n            \\n        for i in range(p2, 8):\\n            if board[p1][i] == \\'p\\':\\n                count += 1\\n                break\\n            if board[p1][i] == \\'B\\':\\n                break\\n        \\n        for j in range(p1, 0, -1):\\n            if board[j][p2] == \\'p\\':\\n                count += 1\\n                break\\n            if board[j][p2] == \\'B\\':\\n                break\\n             \\n        for j in range(p1, 8):\\n            if board[j][p2] == \\'p\\':\\n                count += 1\\n                break\\n            if board[j][p2] == \\'B\\':\\n                break\\n        return count\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n        p1, p2 = -1, -1\\n        count = 0\\n        for i in range(0, 8):\\n            for j in range(0, 8):\\n                if board[i][j] == \\'R\\':\\n                    p1 = i\\n                    p2 = j\\n        # print(p1, p2)\\n        for i in range(p2, 0, -1):\\n            if board[p1][i] == \\'p\\':\\n                count += 1\\n                break\\n            if board[p1][i] == \\'B\\':\\n                break\\n            \\n        for i in range(p2, 8):\\n            if board[p1][i] == \\'p\\':\\n                count += 1\\n                break\\n            if board[p1][i] == \\'B\\':\\n                break\\n        \\n        for j in range(p1, 0, -1):\\n            if board[j][p2] == \\'p\\':\\n                count += 1\\n                break\\n            if board[j][p2] == \\'B\\':\\n                break\\n             \\n        for j in range(p1, 8):\\n            if board[j][p2] == \\'p\\':\\n                count += 1\\n                break\\n            if board[j][p2] == \\'B\\':\\n                break\\n        return count\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 242906,
                "title": "my-straightfoward-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n\\t\\tint x = 0, y = 0, res = 0;\\n\\t\\tfor (int i = 0; i < 8; ++i) {\\n\\t\\t\\tfor (int j = 0; j < 8; ++j) {\\n\\t\\t\\t\\tif (board[i][j] == \\'R\\') {\\n\\t\\t\\t\\t\\tx = i; y = j; break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int j = y; j >= 0; --j) {\\n\\t\\t\\tif (board[x][j] == \\'B\\') break;\\n\\t\\t\\tif (board[x][j] == \\'p\\') {++res; break;} \\n\\t\\t}\\n\\t\\tfor (int j = y; j < 8; ++j) {\\n\\t\\t\\tif (board[x][j] == \\'B\\') break;\\n\\t\\t\\tif (board[x][j] == \\'p\\') {++res; break;}  \\n\\t\\t}\\n\\t\\tfor (int i = x; i >= 0; --i) {\\n\\t\\t\\tif (board[i][y] == \\'B\\') break;\\n\\t\\t\\tif (board[i][y] == \\'p\\') {++res; break;} \\n\\t\\t}\\n\\t\\tfor (int i = x; i < 8; ++i) {\\n\\t\\t\\tif (board[i][y] == \\'B\\') break;\\n\\t\\t\\tif (board[i][y] == \\'p\\') {++res; break;} \\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n\\t\\tint x = 0, y = 0, res = 0;\\n\\t\\tfor (int i = 0; i < 8; ++i) {\\n\\t\\t\\tfor (int j = 0; j < 8; ++j) {\\n\\t\\t\\t\\tif (board[i][j] == \\'R\\') {\\n\\t\\t\\t\\t\\tx = i; y = j; break;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4107493,
                "title": "recursive-solution-beats-90-memory-75-runtime",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind Rook and then go to to every direction until:\\n- Surpased a border of the board\\n- Found a white bishop\\n- Found a black pawn (then sum one to count)\\n\\n# Code\\n```\\nclass Solution:\\n    def dfs(self, board, d, current) -> int:\\n        piece = board[current[0]][current[1]]\\n        if(piece == \\'B\\'):\\n            return 0\\n        elif(piece == \\'p\\'):\\n            return 1\\n\\n        if d == \\'r\\':\\n            if(current[0] + 1 < len(board)):\\n                return self.dfs(board, d, (current[0]+1, current[1]))\\n        if d == \\'l\\':\\n            if(current[0] - 1 >= 0):\\n                return self.dfs(board, d, (current[0]-1, current[1]))\\n        if d == \\'u\\':\\n            if(current[1] - 1 >= 0):\\n                return self.dfs(board, d, (current[0], current[1]-1))\\n        if d == \\'d\\':\\n            if(current[1] + 1 < len(board)):\\n                return self.dfs(board, d, (current[0], current[1]+1))\\n        \\n        return 0\\n\\n\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        # find rook\\n        n = len(board)\\n\\n        rook = ()\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \\'R\\'):\\n                    rook = (i,j)\\n                    break\\n\\n        count = 0\\n\\n        # up\\n        count += self.dfs(board, \\'u\\', rook)\\n        count += self.dfs(board, \\'d\\', rook)\\n        count += self.dfs(board, \\'l\\', rook)\\n        count += self.dfs(board, \\'r\\', rook)\\n\\n        return count\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, board, d, current) -> int:\\n        piece = board[current[0]][current[1]]\\n        if(piece == \\'B\\'):\\n            return 0\\n        elif(piece == \\'p\\'):\\n            return 1\\n\\n        if d == \\'r\\':\\n            if(current[0] + 1 < len(board)):\\n                return self.dfs(board, d, (current[0]+1, current[1]))\\n        if d == \\'l\\':\\n            if(current[0] - 1 >= 0):\\n                return self.dfs(board, d, (current[0]-1, current[1]))\\n        if d == \\'u\\':\\n            if(current[1] - 1 >= 0):\\n                return self.dfs(board, d, (current[0], current[1]-1))\\n        if d == \\'d\\':\\n            if(current[1] + 1 < len(board)):\\n                return self.dfs(board, d, (current[0], current[1]+1))\\n        \\n        return 0\\n\\n\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        # find rook\\n        n = len(board)\\n\\n        rook = ()\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \\'R\\'):\\n                    rook = (i,j)\\n                    break\\n\\n        count = 0\\n\\n        # up\\n        count += self.dfs(board, \\'u\\', rook)\\n        count += self.dfs(board, \\'d\\', rook)\\n        count += self.dfs(board, \\'l\\', rook)\\n        count += self.dfs(board, \\'r\\', rook)\\n\\n        return count\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091387,
                "title": "fast-solution",
                "content": "# Code\\n```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    const getPos = () => {\\n        for(let i = 0; i < 8; i++) {\\n            for(let j = 0; j < 8; j++) {\\n                if(board[i][j] == \\'R\\') return [i, j]\\n            }\\n        }\\n    }\\n\\n    let [row, col] = getPos()\\n    let i = 0\\n    let capture = 0\\n\\n    while(row + i < 8) {\\n        if(board[row + i][col] == \\'B\\') {break}\\n        if(board[row + i][col] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    i = 0\\n    while(row - i >= 0) {\\n        if(board[row - i][col] == \\'B\\') {break}\\n        if(board[row - i][col] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    i = 0\\n    while(col - i >= 0) {\\n        if(board[row][col - i] == \\'B\\') {break}\\n        if(board[row][col - i] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    i = 0\\n    while(col + i < 8) {\\n        if(board[row][col + i] == \\'B\\') {break}\\n        if(board[row][col + i] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    return capture\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    const getPos = () => {\\n        for(let i = 0; i < 8; i++) {\\n            for(let j = 0; j < 8; j++) {\\n                if(board[i][j] == \\'R\\') return [i, j]\\n            }\\n        }\\n    }\\n\\n    let [row, col] = getPos()\\n    let i = 0\\n    let capture = 0\\n\\n    while(row + i < 8) {\\n        if(board[row + i][col] == \\'B\\') {break}\\n        if(board[row + i][col] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    i = 0\\n    while(row - i >= 0) {\\n        if(board[row - i][col] == \\'B\\') {break}\\n        if(board[row - i][col] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    i = 0\\n    while(col - i >= 0) {\\n        if(board[row][col - i] == \\'B\\') {break}\\n        if(board[row][col - i] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    i = 0\\n    while(col + i < 8) {\\n        if(board[row][col + i] == \\'B\\') {break}\\n        if(board[row][col + i] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    return capture\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049402,
                "title": "c-kotlin-easy-to-understand-solution-beats-runtime-100-100-memory-91-57",
                "content": "# C#\\n![image.png](https://assets.leetcode.com/users/images/eb992053-9f8b-4858-a61c-a97f39d90b28_1694813891.915836.png)\\n\\n\\n# Kotlin\\n![image.png](https://assets.leetcode.com/users/images/2d300fc0-a507-49d5-8918-e50b95d13303_1694813888.6574936.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```C# []\\npublic class Solution {\\n    public int NumRookCaptures(char[][] board) {\\n        int i;\\n        int j = 0;\\n        bool foodRook = false;\\n        for (i = 0; i < 8; i++)\\n        {\\n            for (j = 0; j < 8; j++)\\n            {\\n                if (board[i][j] == \\'R\\')\\n                {\\n                    foodRook = true;\\n                    break;\\n                }\\n            }\\n\\n            if (foodRook)\\n            {\\n                break;\\n            }\\n        }\\n\\n        int counter = 0;\\n        int ii = i - 1;\\n        while (ii >= 0)\\n        {\\n            if (board[ii][j] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[ii][j] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            ii--;\\n        }\\n\\n        ii = i + 1;\\n        while (ii < 8)\\n        {\\n            if (board[ii][j] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[ii][j] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            ii++;\\n        }\\n\\n        int jj = j - 1;\\n        while (jj >= 0)\\n        {\\n            if (board[i][jj] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[i][jj] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            jj--;\\n        }\\n\\n        jj = j + 1;\\n        while (jj < 8)\\n        {\\n            if (board[i][jj] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[i][jj] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            jj++;\\n        }\\n\\n\\n        return counter;\\n    }\\n}\\n```\\n```Kotlin []\\nclass Solution {\\n    fun numRookCaptures(board: Array<CharArray>): Int {\\n        var rookRow = 0\\n        var rookColumn = 0\\n        var foundRook = false\\n        for (i in 0..<8) {\\n            for (j in 0..<8) {\\n                if (board[i][j] == \\'R\\') {\\n                    rookColumn = j\\n                    rookRow = i\\n                    foundRook = true\\n                }\\n            }\\n\\n            if (foundRook) {\\n                break\\n            }\\n        }\\n\\n        var counter = 0\\n        var row = rookRow - 1\\n        while (row >= 0) {\\n            if (board[row][rookColumn] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[row][rookColumn] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            row--;\\n        }\\n\\n        row = rookRow + 1\\n        while (row < 8){\\n            if (board[row][rookColumn] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[row][rookColumn] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            row++;\\n        }\\n\\n        var column = rookColumn - 1\\n        while (column >= 0) {\\n            if (board[rookRow][column] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[rookRow][column] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            column--;\\n        }\\n\\n        column = rookColumn + 1\\n        while (column < 8){\\n            if (board[rookRow][column] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[rookRow][column] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            column++;\\n        }\\n\\n        return counter\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Kotlin",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```C# []\\npublic class Solution {\\n    public int NumRookCaptures(char[][] board) {\\n        int i;\\n        int j = 0;\\n        bool foodRook = false;\\n        for (i = 0; i < 8; i++)\\n        {\\n            for (j = 0; j < 8; j++)\\n            {\\n                if (board[i][j] == \\'R\\')\\n                {\\n                    foodRook = true;\\n                    break;\\n                }\\n            }\\n\\n            if (foodRook)\\n            {\\n                break;\\n            }\\n        }\\n\\n        int counter = 0;\\n        int ii = i - 1;\\n        while (ii >= 0)\\n        {\\n            if (board[ii][j] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[ii][j] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            ii--;\\n        }\\n\\n        ii = i + 1;\\n        while (ii < 8)\\n        {\\n            if (board[ii][j] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[ii][j] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            ii++;\\n        }\\n\\n        int jj = j - 1;\\n        while (jj >= 0)\\n        {\\n            if (board[i][jj] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[i][jj] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            jj--;\\n        }\\n\\n        jj = j + 1;\\n        while (jj < 8)\\n        {\\n            if (board[i][jj] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[i][jj] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            jj++;\\n        }\\n\\n\\n        return counter;\\n    }\\n}\\n```\n```Kotlin []\\nclass Solution {\\n    fun numRookCaptures(board: Array<CharArray>): Int {\\n        var rookRow = 0\\n        var rookColumn = 0\\n        var foundRook = false\\n        for (i in 0..<8) {\\n            for (j in 0..<8) {\\n                if (board[i][j] == \\'R\\') {\\n                    rookColumn = j\\n                    rookRow = i\\n                    foundRook = true\\n                }\\n            }\\n\\n            if (foundRook) {\\n                break\\n            }\\n        }\\n\\n        var counter = 0\\n        var row = rookRow - 1\\n        while (row >= 0) {\\n            if (board[row][rookColumn] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[row][rookColumn] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            row--;\\n        }\\n\\n        row = rookRow + 1\\n        while (row < 8){\\n            if (board[row][rookColumn] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[row][rookColumn] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            row++;\\n        }\\n\\n        var column = rookColumn - 1\\n        while (column >= 0) {\\n            if (board[rookRow][column] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[rookRow][column] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            column--;\\n        }\\n\\n        column = rookColumn + 1\\n        while (column < 8){\\n            if (board[rookRow][column] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[rookRow][column] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            column++;\\n        }\\n\\n        return counter\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044925,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int m = board.size(), n = board[0].size();\\n        int rx, ry;\\n        for(int i = 0 ; i < 8 ; i++) {\\n            for(int j = 0 ; j < 8 ; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    rx = i, ry = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int j = ry + 1 ; j < 8 ; j++) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n        for(int j = ry - 1 ; j >= 0 ; j--) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n \\n        for(int i = rx + 1 ; i < 8 ; i++) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n\\n        for(int i = rx - 1 ; i >= 0 ; i--) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n    \\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int m = board.size(), n = board[0].size();\\n        int rx, ry;\\n        for(int i = 0 ; i < 8 ; i++) {\\n            for(int j = 0 ; j < 8 ; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    rx = i, ry = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int j = ry + 1 ; j < 8 ; j++) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n        for(int j = ry - 1 ; j >= 0 ; j--) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n \\n        for(int i = rx + 1 ; i < 8 ; i++) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n\\n        for(int i = rx - 1 ; i >= 0 ; i--) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n    \\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029133,
                "title": "beginner-s-approach-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere in this appraoch we first find the rook.After finding the rook\\nwe move upward,downward,left and right.If find a bishop we break,if we find a pawn we increase the count then break.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int & count,int i,int j,vector<vector<char>> board){\\n        //up\\n        for(int k=i;k>=0;k--){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            //found the bishop break\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //down\\n        for(int k=i;k<board.size();k++){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        //right\\n        for(int k=j;k<board[i].size();k++){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //left\\n        for(int k=j;k>=0;k--){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n    }\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        //counting the number of pawns\\n        int count=0;\\n\\n        //Finding the location of rook\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board.size();j++){\\n                if(board[i][j]==\\'R\\'){\\n                    solve(count,i,j,board);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int & count,int i,int j,vector<vector<char>> board){\\n        //up\\n        for(int k=i;k>=0;k--){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            //found the bishop break\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //down\\n        for(int k=i;k<board.size();k++){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        //right\\n        for(int k=j;k<board[i].size();k++){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //left\\n        for(int k=j;k>=0;k--){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n    }\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        //counting the number of pawns\\n        int count=0;\\n\\n        //Finding the location of rook\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board.size();j++){\\n                if(board[i][j]==\\'R\\'){\\n                    solve(count,i,j,board);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029132,
                "title": "beginner-s-approach-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere in this appraoch we first find the rook.After finding the rook\\nwe move upward,downward,left and right.If find a bishop we break,if we find a pawn we increase the count then break.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int & count,int i,int j,vector<vector<char>> board){\\n        //up\\n        for(int k=i;k>=0;k--){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            //found the bishop break\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //down\\n        for(int k=i;k<board.size();k++){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        //right\\n        for(int k=j;k<board[i].size();k++){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //left\\n        for(int k=j;k>=0;k--){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n    }\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        //counting the number of pawns\\n        int count=0;\\n\\n        //Finding the location of rook\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board.size();j++){\\n                if(board[i][j]==\\'R\\'){\\n                    solve(count,i,j,board);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int & count,int i,int j,vector<vector<char>> board){\\n        //up\\n        for(int k=i;k>=0;k--){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            //found the bishop break\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //down\\n        for(int k=i;k<board.size();k++){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        //right\\n        for(int k=j;k<board[i].size();k++){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //left\\n        for(int k=j;k>=0;k--){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n    }\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        //counting the number of pawns\\n        int count=0;\\n\\n        //Finding the location of rook\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board.size();j++){\\n                if(board[i][j]==\\'R\\'){\\n                    solve(count,i,j,board);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026393,
                "title": "0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int result = 0;\\n        int[] rockIndex = new int[2];\\n        // the rock can have max 4 capture or min zero cap\\n        int nothDis = 9, southDis = 9, eastDis = 9, westDis = 9;\\n        boolean[] dir = new boolean[4];\\n\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    rockIndex[0] = i;\\n                    rockIndex[1] = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        //System.out.println(Arrays.toString(rockIndex));\\n\\n        // first horisontal\\n\\n        // west\\n        for (int i = 0; i < rockIndex[1]; i++) {\\n            if (board[rockIndex[0]][i] == \\'p\\') {\\n                westDis = rockIndex[1] - i;\\n                dir[0] = true;\\n            }\\n            if (board[rockIndex[0]][i] == \\'B\\' && westDis > rockIndex[1] - i) {\\n                dir[0] = false;\\n            }\\n        }\\n\\n        // east\\n        for (int i = 7; i > rockIndex[1]; i--) {\\n            if (board[rockIndex[0]][i] == \\'p\\') {\\n                eastDis = i - rockIndex[1];\\n                dir[1] = true;\\n            }\\n            if (board[rockIndex[0]][i] == \\'B\\' && eastDis > i - rockIndex[1]) {\\n                dir[1] = false;\\n            }\\n        }\\n\\n        // vertical\\n\\n        // north\\n        for (int i = 0; i < rockIndex[0]; i++) {\\n            if (board[i][rockIndex[1]] == \\'p\\') {\\n                nothDis = rockIndex[0] - i;\\n                dir[2] = true;\\n            }\\n            if (board[i][rockIndex[1]] == \\'B\\' && nothDis > rockIndex[0] - i) {\\n                dir[2] = false;\\n            }\\n        }\\n\\n        // south\\n        for (int i = 7; i > rockIndex[0]; i--) {\\n            if (board[i][rockIndex[1]] == \\'p\\') {\\n                southDis = i - rockIndex[0];\\n                dir[3] = true;\\n            }\\n            if (board[i][rockIndex[1]] == \\'B\\' && southDis > i - rockIndex[0]) {\\n                dir[3] = false;\\n            }\\n        }\\n\\n        //System.out.println(Arrays.toString(dir));\\n\\n        for (boolean b : dir) {\\n            if (b) {\\n                result++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int result = 0;\\n        int[] rockIndex = new int[2];\\n        // the rock can have max 4 capture or min zero cap\\n        int nothDis = 9, southDis = 9, eastDis = 9, westDis = 9;\\n        boolean[] dir = new boolean[4];\\n\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    rockIndex[0] = i;\\n                    rockIndex[1] = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        //System.out.println(Arrays.toString(rockIndex));\\n\\n        // first horisontal\\n\\n        // west\\n        for (int i = 0; i < rockIndex[1]; i++) {\\n            if (board[rockIndex[0]][i] == \\'p\\') {\\n                westDis = rockIndex[1] - i;\\n                dir[0] = true;\\n            }\\n            if (board[rockIndex[0]][i] == \\'B\\' && westDis > rockIndex[1] - i) {\\n                dir[0] = false;\\n            }\\n        }\\n\\n        // east\\n        for (int i = 7; i > rockIndex[1]; i--) {\\n            if (board[rockIndex[0]][i] == \\'p\\') {\\n                eastDis = i - rockIndex[1];\\n                dir[1] = true;\\n            }\\n            if (board[rockIndex[0]][i] == \\'B\\' && eastDis > i - rockIndex[1]) {\\n                dir[1] = false;\\n            }\\n        }\\n\\n        // vertical\\n\\n        // north\\n        for (int i = 0; i < rockIndex[0]; i++) {\\n            if (board[i][rockIndex[1]] == \\'p\\') {\\n                nothDis = rockIndex[0] - i;\\n                dir[2] = true;\\n            }\\n            if (board[i][rockIndex[1]] == \\'B\\' && nothDis > rockIndex[0] - i) {\\n                dir[2] = false;\\n            }\\n        }\\n\\n        // south\\n        for (int i = 7; i > rockIndex[0]; i--) {\\n            if (board[i][rockIndex[1]] == \\'p\\') {\\n                southDis = i - rockIndex[0];\\n                dir[3] = true;\\n            }\\n            if (board[i][rockIndex[1]] == \\'B\\' && southDis > i - rockIndex[0]) {\\n                dir[3] = false;\\n            }\\n        }\\n\\n        //System.out.println(Arrays.toString(dir));\\n\\n        for (boolean b : dir) {\\n            if (b) {\\n                result++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024827,
                "title": "easy-to-understand-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public static int numRookCaptures(char[][] board) {\\n\\t\\t int ans = 0;\\n\\t\\t for (int i = 0; i < board.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < board.length; j++) {\\n\\t\\t\\t\\tchar val = board[i][j];\\n\\t\\t\\t\\tif(val==\\'R\\') {\\n\\t\\t\\t\\t\\tans = check(board,i,j);\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;   \\n\\t    }\\n\\n\\tpublic static int check(char[][] arr, int ii, int jj) {\\n\\t\\tint count = 0;\\n\\t\\t// bottom\\n\\t\\tint i1 = ii;\\n\\t\\tint j1 = jj;\\n\\t\\twhile(arr.length-1>i1) {\\n\\t\\t\\tif(arr[i1+1][j1]==\\'P\\' || arr[i1+1][j1]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i1+1][j1]==\\'B\\' || arr[i1+1][j1]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\ti1++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// top\\n\\t\\tint i3 = ii;\\n\\t\\tint j3 = jj;\\n\\t\\twhile(0<i3) {\\n\\t\\t\\tif(arr[i3-1][j3]==\\'P\\' || arr[i3-1][j3]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i3-1][j3]==\\'B\\' || arr[i3-1][j3]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\ti3--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// left\\n\\t\\tint i2 = ii;\\n\\t\\tint j2 = jj;\\n\\t\\twhile(0<j2) {\\n\\t\\t\\tif(arr[i2][j2-1]==\\'P\\' || arr[i2][j2-1]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i2][j2-1]==\\'B\\' || arr[i2][j2-1]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tj2--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// right\\n\\t\\tint i4 = ii;\\n\\t\\tint j4 = jj;\\n\\t\\twhile(arr.length-1>j4) {\\n\\t\\t\\tif(arr[i4][j4+1]==\\'P\\' || arr[i4][j4+1]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i4][j4+1]==\\'B\\' || arr[i4][j4+1]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tj4++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public static int numRookCaptures(char[][] board) {\\n\\t\\t int ans = 0;\\n\\t\\t for (int i = 0; i < board.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < board.length; j++) {\\n\\t\\t\\t\\tchar val = board[i][j];\\n\\t\\t\\t\\tif(val==\\'R\\') {\\n\\t\\t\\t\\t\\tans = check(board,i,j);\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;   \\n\\t    }\\n\\n\\tpublic static int check(char[][] arr, int ii, int jj) {\\n\\t\\tint count = 0;\\n\\t\\t// bottom\\n\\t\\tint i1 = ii;\\n\\t\\tint j1 = jj;\\n\\t\\twhile(arr.length-1>i1) {\\n\\t\\t\\tif(arr[i1+1][j1]==\\'P\\' || arr[i1+1][j1]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i1+1][j1]==\\'B\\' || arr[i1+1][j1]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\ti1++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// top\\n\\t\\tint i3 = ii;\\n\\t\\tint j3 = jj;\\n\\t\\twhile(0<i3) {\\n\\t\\t\\tif(arr[i3-1][j3]==\\'P\\' || arr[i3-1][j3]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i3-1][j3]==\\'B\\' || arr[i3-1][j3]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\ti3--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// left\\n\\t\\tint i2 = ii;\\n\\t\\tint j2 = jj;\\n\\t\\twhile(0<j2) {\\n\\t\\t\\tif(arr[i2][j2-1]==\\'P\\' || arr[i2][j2-1]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i2][j2-1]==\\'B\\' || arr[i2][j2-1]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tj2--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// right\\n\\t\\tint i4 = ii;\\n\\t\\tint j4 = jj;\\n\\t\\twhile(arr.length-1>j4) {\\n\\t\\t\\tif(arr[i4][j4+1]==\\'P\\' || arr[i4][j4+1]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i4][j4+1]==\\'B\\' || arr[i4][j4+1]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tj4++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014788,
                "title": "easy-simple-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        b=[]\\n        for i in board:\\n            if \"R\" in i:\\n                a=i\\n                k=i.index(\\'R\\')\\n        for i in board:\\n            b.append(i[k])\\n        x=a.index(\\'R\\')\\n        y=a.index(\\'R\\')\\n        l=b.index(\\'R\\')\\n        m=b.index(\\'R\\')\\n        c=0\\n        while x<len(a):\\n            if a[x]==\"p\":\\n                c+=1\\n                break\\n            if  a[x]==\"B\":\\n                break\\n            x+=1\\n        while y>=0:\\n            if a[y]==\"p\":\\n                c+=1\\n                break\\n            if  a[y]==\"B\":\\n                break\\n            y-=1\\n        while l<len(b):\\n            if b[l]==\"p\":\\n                c+=1\\n                break\\n            if  b[l]==\"B\":\\n                break\\n            l+=1\\n        while m>=0:\\n            if b[m]==\"p\":\\n                c+=1\\n                break\\n            if  b[m]==\"B\":\\n                break\\n            m-=1\\n        return c\\n        \\n      \\n      \\n        \\n       \\n\\n        \\n\\n       \\n\\n                   \\n        \\n               \\n        \\n         \\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        b=[]\\n        for i in board:\\n            if \"R\" in i:\\n                a=i\\n                k=i.index(\\'R\\')\\n        for i in board:\\n            b.append(i[k])\\n        x=a.index(\\'R\\')\\n        y=a.index(\\'R\\')\\n        l=b.index(\\'R\\')\\n        m=b.index(\\'R\\')\\n        c=0\\n        while x<len(a):\\n            if a[x]==\"p\":\\n                c+=1\\n                break\\n            if  a[x]==\"B\":\\n                break\\n            x+=1\\n        while y>=0:\\n            if a[y]==\"p\":\\n                c+=1\\n                break\\n            if  a[y]==\"B\":\\n                break\\n            y-=1\\n        while l<len(b):\\n            if b[l]==\"p\":\\n                c+=1\\n                break\\n            if  b[l]==\"B\":\\n                break\\n            l+=1\\n        while m>=0:\\n            if b[m]==\"p\":\\n                c+=1\\n                break\\n            if  b[m]==\"B\":\\n                break\\n            m-=1\\n        return c\\n        \\n      \\n      \\n        \\n       \\n\\n        \\n\\n       \\n\\n                   \\n        \\n               \\n        \\n         \\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005696,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    private const char Pawn = \\'p\\';\\n\\n    public int NumRookCaptures(char[][] board)\\n    {\\n        var (x, y) = findRook(board);\\n        var count = 0;\\n\\n        for (var i = x - 1; i >= 0; i--)\\n        {\\n            if (board[i][y] == \\'.\\') continue;\\n\\n            count += board[i][y] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        for (var i = x + 1; i < board.Length; i++)\\n        {\\n            if (board[i][y] == \\'.\\') continue;\\n            \\n            count += board[i][y] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        for (var i = y - 1; i >= 0; i--)\\n        {\\n            if (board[x][i] == \\'.\\') continue;\\n            \\n            count += board[x][i] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        for (var i = y + 1; i < board[0].Length; i++)\\n        {\\n            if (board[x][i] == \\'.\\') continue;\\n            \\n            count += board[x][i] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        return count;\\n    }\\n\\n    private static (int x, int y) findRook(char[][] board)\\n    {\\n        const char rook = \\'R\\';\\n\\n        for (var i = 0; i < board.Length; i++)\\n        {\\n            for (var j = 0; j < board[0].Length; j++)\\n            {\\n                if (board[i][j] == rook)\\n                {\\n                    return (i, j);\\n                }\\n            }\\n        }\\n\\n        return (0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private const char Pawn = \\'p\\';\\n\\n    public int NumRookCaptures(char[][] board)\\n    {\\n        var (x, y) = findRook(board);\\n        var count = 0;\\n\\n        for (var i = x - 1; i >= 0; i--)\\n        {\\n            if (board[i][y] == \\'.\\') continue;\\n\\n            count += board[i][y] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        for (var i = x + 1; i < board.Length; i++)\\n        {\\n            if (board[i][y] == \\'.\\') continue;\\n            \\n            count += board[i][y] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        for (var i = y - 1; i >= 0; i--)\\n        {\\n            if (board[x][i] == \\'.\\') continue;\\n            \\n            count += board[x][i] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        for (var i = y + 1; i < board[0].Length; i++)\\n        {\\n            if (board[x][i] == \\'.\\') continue;\\n            \\n            count += board[x][i] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        return count;\\n    }\\n\\n    private static (int x, int y) findRook(char[][] board)\\n    {\\n        const char rook = \\'R\\';\\n\\n        for (var i = 0; i < board.Length; i++)\\n        {\\n            for (var j = 0; j < board[0].Length; j++)\\n            {\\n                if (board[i][j] == rook)\\n                {\\n                    return (i, j);\\n                }\\n            }\\n        }\\n\\n        return (0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001077,
                "title": "beats-100-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    return ans(board,i,j);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    public int ans(char[][] mat,int r,int c){\\n        int c1=0;\\n        for(int i=r+1;i<mat.length;i++){\\n            if(mat[i][c]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=r-1;i>=0;i--){\\n            if(mat[i][c]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=c+1;i<mat[0].length;i++){\\n            if(mat[r][i]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=c-1;i>=0;i--){\\n            if(mat[r][i]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return c1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    return ans(board,i,j);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    public int ans(char[][] mat,int r,int c){\\n        int c1=0;\\n        for(int i=r+1;i<mat.length;i++){\\n            if(mat[i][c]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=r-1;i>=0;i--){\\n            if(mat[i][c]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=c+1;i<mat[0].length;i++){\\n            if(mat[r][i]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=c-1;i>=0;i--){\\n            if(mat[r][i]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return c1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999771,
                "title": "easy-solution-beating-75-96-in-run-time",
                "content": "\\n\\n# Code\\n```\\n\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n*/\\n\\nvar numRookCaptures = function(board) {\\n\\n    let m = board.length;\\n    let n = board[0].length;\\n    \\n    let capture = 0;\\n\\n    for (let i = 0; i < m; i++){\\n        for (let j = 0; j < n; j++){\\n\\n            // finding the rook\\n            if (board[i][j] === \\'R\\'){\\n\\n                let ri = i;\\n                let rj = j;\\n\\n                // right \\n                for(let j = rj; j < n; j++){\\n                    if (board[ri][j] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[ri][j] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n                \\n                // left \\n                for (let j = rj; j >= 0; j--){\\n                        if (board[ri][j] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[ri][j] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n\\n                // bottom \\n                for (let i = ri; i < m; i++){\\n                    if (board[i][rj] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[i][rj] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n\\n                // up\\n                for (let i = ri; i >= 0; i--){\\n                        if (board[i][rj] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[i][rj] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return capture;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n*/\\n\\nvar numRookCaptures = function(board) {\\n\\n    let m = board.length;\\n    let n = board[0].length;\\n    \\n    let capture = 0;\\n\\n    for (let i = 0; i < m; i++){\\n        for (let j = 0; j < n; j++){\\n\\n            // finding the rook\\n            if (board[i][j] === \\'R\\'){\\n\\n                let ri = i;\\n                let rj = j;\\n\\n                // right \\n                for(let j = rj; j < n; j++){\\n                    if (board[ri][j] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[ri][j] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n                \\n                // left \\n                for (let j = rj; j >= 0; j--){\\n                        if (board[ri][j] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[ri][j] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n\\n                // bottom \\n                for (let i = ri; i < m; i++){\\n                    if (board[i][rj] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[i][rj] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n\\n                // up\\n                for (let i = ri; i >= 0; i--){\\n                        if (board[i][rj] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[i][rj] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return capture;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985107,
                "title": "rust-python-solutions",
                "content": "# Code\\n```python []\\nfrom typing import Literal, Type\\n\\nMOVE: Type[str] = Literal[\\'up\\', \\'down\\', \\'left\\', \\'right\\']\\n\\n\\nclass Solution:\\n    @staticmethod\\n    def move(board: list[list[str]], moves: range, pos: int, to_move: MOVE) -> int:\\n        count = 0\\n        for move in moves:\\n            if to_move == \\'up\\' or to_move == \\'down\\':\\n                value = board[move][pos]\\n            else:\\n                value = board[pos][move]\\n\\n            if value == \\'B\\':\\n                break\\n            if value == \\'p\\':\\n                count += 1\\n                break\\n        return count\\n\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        count = 0\\n\\n        row, col = [\\n            (r, c)\\n            for r, line in enumerate(board)\\n            for c, value in enumerate(line)\\n            if value == \\'R\\'\\n        ][0]\\n\\n        count += Solution().move(board, range(row, -1, -1), col, \\'up\\')\\n        count += Solution().move(board, range(row, 8, 1), col, \\'down\\')\\n        count += Solution().move(board, range(col, -1, -1), row, \\'left\\')\\n        count += Solution().move(board, range(col, 8, 1), row, \\'right\\')\\n\\n        return count\\n```\\n```rust []\\nenum Moves {\\n    UpDown,\\n    LeftRight\\n}\\n\\nimpl Solution {\\n    fn move_up_down(board: &Vec<Vec<char>>, moves: impl Iterator<Item = usize>, pos: usize, to_move: Moves) -> i32 {\\n        for m in moves {\\n            let value = match to_move {\\n                Moves::UpDown => board[m][pos],\\n                Moves::LeftRight => board[pos][m],\\n            };\\n            if value == \\'B\\' {\\n                break;\\n            }\\n            if value == \\'p\\' {\\n                return 1;\\n            }\\n        }\\n        0\\n    }\\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (mut count, mut row, mut col) = (0, 0, 0);\\n        for (r, line) in board.iter().enumerate() {\\n            for (c, value) in line.iter().enumerate() {\\n                if *value == \\'R\\' {\\n                    row = r; \\n                    col = c;\\n                }\\n            }\\n        }\\n        count += Solution::move_up_down(&board, (0..row).rev(), col, Moves::UpDown);\\n        count += Solution::move_up_down(&board, row..8, col, Moves::UpDown);\\n        count += Solution::move_up_down(&board, (0..col).rev(), row, Moves::LeftRight);\\n        count += Solution::move_up_down(&board, col..8, row, Moves::LeftRight);\\n\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nfrom typing import Literal, Type\\n\\nMOVE: Type[str] = Literal[\\'up\\', \\'down\\', \\'left\\', \\'right\\']\\n\\n\\nclass Solution:\\n    @staticmethod\\n    def move(board: list[list[str]], moves: range, pos: int, to_move: MOVE) -> int:\\n        count = 0\\n        for move in moves:\\n            if to_move == \\'up\\' or to_move == \\'down\\':\\n                value = board[move][pos]\\n            else:\\n                value = board[pos][move]\\n\\n            if value == \\'B\\':\\n                break\\n            if value == \\'p\\':\\n                count += 1\\n                break\\n        return count\\n\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        count = 0\\n\\n        row, col = [\\n            (r, c)\\n            for r, line in enumerate(board)\\n            for c, value in enumerate(line)\\n            if value == \\'R\\'\\n        ][0]\\n\\n        count += Solution().move(board, range(row, -1, -1), col, \\'up\\')\\n        count += Solution().move(board, range(row, 8, 1), col, \\'down\\')\\n        count += Solution().move(board, range(col, -1, -1), row, \\'left\\')\\n        count += Solution().move(board, range(col, 8, 1), row, \\'right\\')\\n\\n        return count\\n```\n```rust []\\nenum Moves {\\n    UpDown,\\n    LeftRight\\n}\\n\\nimpl Solution {\\n    fn move_up_down(board: &Vec<Vec<char>>, moves: impl Iterator<Item = usize>, pos: usize, to_move: Moves) -> i32 {\\n        for m in moves {\\n            let value = match to_move {\\n                Moves::UpDown => board[m][pos],\\n                Moves::LeftRight => board[pos][m],\\n            };\\n            if value == \\'B\\' {\\n                break;\\n            }\\n            if value == \\'p\\' {\\n                return 1;\\n            }\\n        }\\n        0\\n    }\\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (mut count, mut row, mut col) = (0, 0, 0);\\n        for (r, line) in board.iter().enumerate() {\\n            for (c, value) in line.iter().enumerate() {\\n                if *value == \\'R\\' {\\n                    row = r; \\n                    col = c;\\n                }\\n            }\\n        }\\n        count += Solution::move_up_down(&board, (0..row).rev(), col, Moves::UpDown);\\n        count += Solution::move_up_down(&board, row..8, col, Moves::UpDown);\\n        count += Solution::move_up_down(&board, (0..col).rev(), row, Moves::LeftRight);\\n        count += Solution::move_up_down(&board, col..8, row, Moves::LeftRight);\\n\\n        count\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565025,
                "content": [
                    {
                        "username": "abkosar",
                        "content": "The last part of the question `Return the number of pawns the rook can capture in one move.` is confusing because in one move you can only capture one pawn. If you want to capture all the three pawns you have to do three moves. So the question should be `Return the number of pawns the rook can capture`. I don\\'t know who assesses these questions but some of these could be written in a much much better way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could not capture those 3 pawns in 3 moves, it'd take 4 moves. But I agree the wording could be better here. Probably something like: `Return the number of pawns the rook is currently attacking` But I believe they have already updated it since your post, it is much clearer now. "
                    },
                    {
                        "username": "ahmed_mostafa14",
                        "content": "actually your correction is confusing , because it means that if a pawn is not on the same horizontal or vertical coordinate as the rook and not completely surrounded by 4 bishops it should be counted in the answer, which is not correct."
                    },
                    {
                        "username": "user4543Nq",
                        "content": "As a chess player who is really bad at coding, this problem was both fun and confusing for me haha"
                    },
                    {
                        "username": "bobjava",
                        "content": "this is definitely more of a medium problem (an easy medium problem)"
                    },
                    {
                        "username": "adis176",
                        "content": "It is just a simple simulation, and the edge cases are somewhat clear. The language isn\\'t clear at all, which can probably confuse a person, make it seem more hard."
                    },
                    {
                        "username": "pangpangdei",
                        "content": "that is lower case \\'p\\' and upper case \\'R\\' and \\'B\\', fml"
                    },
                    {
                        "username": "lenard2626",
                        "content": "The 23rd  test case:\\n\\n `board = [[\"R\",\".\",\"p\",\".\",\"p\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nSeems to be wrong, as it says 2 is the expected answer, however, that requires two turns to capture instead of one. Following rules the right anwer should be 1, as there\\'s a pawn blocking rock. which contradicts the third given example:\\n\\n `board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nwhich expects 3, but have a similar scenario. In order for it to be consistent contrains should establish a pawn is considered to be \"attacked\" even if there\\'s a pawn attacked already\\n\\nEither,test case 23rd should be removed, or, contrains and examples should be updated."
                    }
                ]
            },
            {
                "id": 1735847,
                "content": [
                    {
                        "username": "abkosar",
                        "content": "The last part of the question `Return the number of pawns the rook can capture in one move.` is confusing because in one move you can only capture one pawn. If you want to capture all the three pawns you have to do three moves. So the question should be `Return the number of pawns the rook can capture`. I don\\'t know who assesses these questions but some of these could be written in a much much better way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could not capture those 3 pawns in 3 moves, it'd take 4 moves. But I agree the wording could be better here. Probably something like: `Return the number of pawns the rook is currently attacking` But I believe they have already updated it since your post, it is much clearer now. "
                    },
                    {
                        "username": "ahmed_mostafa14",
                        "content": "actually your correction is confusing , because it means that if a pawn is not on the same horizontal or vertical coordinate as the rook and not completely surrounded by 4 bishops it should be counted in the answer, which is not correct."
                    },
                    {
                        "username": "user4543Nq",
                        "content": "As a chess player who is really bad at coding, this problem was both fun and confusing for me haha"
                    },
                    {
                        "username": "bobjava",
                        "content": "this is definitely more of a medium problem (an easy medium problem)"
                    },
                    {
                        "username": "adis176",
                        "content": "It is just a simple simulation, and the edge cases are somewhat clear. The language isn\\'t clear at all, which can probably confuse a person, make it seem more hard."
                    },
                    {
                        "username": "pangpangdei",
                        "content": "that is lower case \\'p\\' and upper case \\'R\\' and \\'B\\', fml"
                    },
                    {
                        "username": "lenard2626",
                        "content": "The 23rd  test case:\\n\\n `board = [[\"R\",\".\",\"p\",\".\",\"p\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nSeems to be wrong, as it says 2 is the expected answer, however, that requires two turns to capture instead of one. Following rules the right anwer should be 1, as there\\'s a pawn blocking rock. which contradicts the third given example:\\n\\n `board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nwhich expects 3, but have a similar scenario. In order for it to be consistent contrains should establish a pawn is considered to be \"attacked\" even if there\\'s a pawn attacked already\\n\\nEither,test case 23rd should be removed, or, contrains and examples should be updated."
                    }
                ]
            },
            {
                "id": 1764027,
                "content": [
                    {
                        "username": "abkosar",
                        "content": "The last part of the question `Return the number of pawns the rook can capture in one move.` is confusing because in one move you can only capture one pawn. If you want to capture all the three pawns you have to do three moves. So the question should be `Return the number of pawns the rook can capture`. I don\\'t know who assesses these questions but some of these could be written in a much much better way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could not capture those 3 pawns in 3 moves, it'd take 4 moves. But I agree the wording could be better here. Probably something like: `Return the number of pawns the rook is currently attacking` But I believe they have already updated it since your post, it is much clearer now. "
                    },
                    {
                        "username": "ahmed_mostafa14",
                        "content": "actually your correction is confusing , because it means that if a pawn is not on the same horizontal or vertical coordinate as the rook and not completely surrounded by 4 bishops it should be counted in the answer, which is not correct."
                    },
                    {
                        "username": "user4543Nq",
                        "content": "As a chess player who is really bad at coding, this problem was both fun and confusing for me haha"
                    },
                    {
                        "username": "bobjava",
                        "content": "this is definitely more of a medium problem (an easy medium problem)"
                    },
                    {
                        "username": "adis176",
                        "content": "It is just a simple simulation, and the edge cases are somewhat clear. The language isn\\'t clear at all, which can probably confuse a person, make it seem more hard."
                    },
                    {
                        "username": "pangpangdei",
                        "content": "that is lower case \\'p\\' and upper case \\'R\\' and \\'B\\', fml"
                    },
                    {
                        "username": "lenard2626",
                        "content": "The 23rd  test case:\\n\\n `board = [[\"R\",\".\",\"p\",\".\",\"p\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nSeems to be wrong, as it says 2 is the expected answer, however, that requires two turns to capture instead of one. Following rules the right anwer should be 1, as there\\'s a pawn blocking rock. which contradicts the third given example:\\n\\n `board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nwhich expects 3, but have a similar scenario. In order for it to be consistent contrains should establish a pawn is considered to be \"attacked\" even if there\\'s a pawn attacked already\\n\\nEither,test case 23rd should be removed, or, contrains and examples should be updated."
                    }
                ]
            },
            {
                "id": 2076255,
                "content": [
                    {
                        "username": "abkosar",
                        "content": "The last part of the question `Return the number of pawns the rook can capture in one move.` is confusing because in one move you can only capture one pawn. If you want to capture all the three pawns you have to do three moves. So the question should be `Return the number of pawns the rook can capture`. I don\\'t know who assesses these questions but some of these could be written in a much much better way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could not capture those 3 pawns in 3 moves, it'd take 4 moves. But I agree the wording could be better here. Probably something like: `Return the number of pawns the rook is currently attacking` But I believe they have already updated it since your post, it is much clearer now. "
                    },
                    {
                        "username": "ahmed_mostafa14",
                        "content": "actually your correction is confusing , because it means that if a pawn is not on the same horizontal or vertical coordinate as the rook and not completely surrounded by 4 bishops it should be counted in the answer, which is not correct."
                    },
                    {
                        "username": "user4543Nq",
                        "content": "As a chess player who is really bad at coding, this problem was both fun and confusing for me haha"
                    },
                    {
                        "username": "bobjava",
                        "content": "this is definitely more of a medium problem (an easy medium problem)"
                    },
                    {
                        "username": "adis176",
                        "content": "It is just a simple simulation, and the edge cases are somewhat clear. The language isn\\'t clear at all, which can probably confuse a person, make it seem more hard."
                    },
                    {
                        "username": "pangpangdei",
                        "content": "that is lower case \\'p\\' and upper case \\'R\\' and \\'B\\', fml"
                    },
                    {
                        "username": "lenard2626",
                        "content": "The 23rd  test case:\\n\\n `board = [[\"R\",\".\",\"p\",\".\",\"p\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nSeems to be wrong, as it says 2 is the expected answer, however, that requires two turns to capture instead of one. Following rules the right anwer should be 1, as there\\'s a pawn blocking rock. which contradicts the third given example:\\n\\n `board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nwhich expects 3, but have a similar scenario. In order for it to be consistent contrains should establish a pawn is considered to be \"attacked\" even if there\\'s a pawn attacked already\\n\\nEither,test case 23rd should be removed, or, contrains and examples should be updated."
                    }
                ]
            },
            {
                "id": 1945958,
                "content": [
                    {
                        "username": "abkosar",
                        "content": "The last part of the question `Return the number of pawns the rook can capture in one move.` is confusing because in one move you can only capture one pawn. If you want to capture all the three pawns you have to do three moves. So the question should be `Return the number of pawns the rook can capture`. I don\\'t know who assesses these questions but some of these could be written in a much much better way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could not capture those 3 pawns in 3 moves, it'd take 4 moves. But I agree the wording could be better here. Probably something like: `Return the number of pawns the rook is currently attacking` But I believe they have already updated it since your post, it is much clearer now. "
                    },
                    {
                        "username": "ahmed_mostafa14",
                        "content": "actually your correction is confusing , because it means that if a pawn is not on the same horizontal or vertical coordinate as the rook and not completely surrounded by 4 bishops it should be counted in the answer, which is not correct."
                    },
                    {
                        "username": "user4543Nq",
                        "content": "As a chess player who is really bad at coding, this problem was both fun and confusing for me haha"
                    },
                    {
                        "username": "bobjava",
                        "content": "this is definitely more of a medium problem (an easy medium problem)"
                    },
                    {
                        "username": "adis176",
                        "content": "It is just a simple simulation, and the edge cases are somewhat clear. The language isn\\'t clear at all, which can probably confuse a person, make it seem more hard."
                    },
                    {
                        "username": "pangpangdei",
                        "content": "that is lower case \\'p\\' and upper case \\'R\\' and \\'B\\', fml"
                    },
                    {
                        "username": "lenard2626",
                        "content": "The 23rd  test case:\\n\\n `board = [[\"R\",\".\",\"p\",\".\",\"p\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nSeems to be wrong, as it says 2 is the expected answer, however, that requires two turns to capture instead of one. Following rules the right anwer should be 1, as there\\'s a pawn blocking rock. which contradicts the third given example:\\n\\n `board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nwhich expects 3, but have a similar scenario. In order for it to be consistent contrains should establish a pawn is considered to be \"attacked\" even if there\\'s a pawn attacked already\\n\\nEither,test case 23rd should be removed, or, contrains and examples should be updated."
                    }
                ]
            }
        ]
    },
    {
        "title": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "question_content": "<p>Given a <code>sentence</code> that consists of some words separated by a <strong>single space</strong>, and a <code>searchWord</code>, check if <code>searchWord</code> is a prefix of any word in <code>sentence</code>.</p>\n\n<p>Return <em>the index of the word in </em><code>sentence</code><em> (<strong>1-indexed</strong>) where </em><code>searchWord</code><em> is a prefix of this word</em>. If <code>searchWord</code> is a prefix of more than one word, return the index of the first word <strong>(minimum index)</strong>. If there is no such word return <code>-1</code>.</p>\n\n<p>A <strong>prefix</strong> of a string <code>s</code> is any leading contiguous substring of <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentence = &quot;i love eating burger&quot;, searchWord = &quot;burg&quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> &quot;burg&quot; is prefix of &quot;burger&quot; which is the 4th word in the sentence.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentence = &quot;this problem is an easy problem&quot;, searchWord = &quot;pro&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> &quot;pro&quot; is prefix of &quot;problem&quot; which is the 2nd and the 6th word in the sentence, but we return 2 as it&#39;s the minimal index.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentence = &quot;i am tired&quot;, searchWord = &quot;you&quot;\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> &quot;you&quot; is not a prefix of any word in the sentence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= searchWord.length &lt;= 10</code></li>\n\t<li><code>sentence</code> consists of lowercase English letters and spaces.</li>\n\t<li><code>searchWord</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 648610,
                "title": "java-python-3-straight-forward-codes",
                "content": "```java\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for (int i = 1; i <= words.length; ++i) {\\n            if (words[i - 1].startsWith(searchWord)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\n```python\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        for i, w in enumerate(sentence.split(\\' \\'), 1):\\n            if w.startswith(searchWord):\\n                return i\\n        return -1    \\n```",
                "solutionTags": [],
                "code": "```java\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for (int i = 1; i <= words.length; ++i) {\\n            if (words[i - 1].startsWith(searchWord)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```python\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        for i, w in enumerate(sentence.split(\\' \\'), 1):\\n            if w.startswith(searchWord):\\n                return i\\n        return -1    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 648346,
                "title": "c-add-leading-space",
                "content": "To make it simple, we add a leading space to our sentence and word. Then, we can do a string search, and cout the number of spaces before the found word.\\n\\n```cpp\\nint isPrefixOfWord(string sentence, string searchWord) {\\n    auto sent = \" \" + sentence, word = \" \" + searchWord;\\n    auto pos = sent.find(word);\\n    if (pos != string::npos)\\n        return count(begin(sent), begin(sent) + pos + 1, \\' \\');\\n    return -1;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n), where n is the characters in the sentence. \\n\\t\\n\\tWe go through the sentence twice. `string.find` in C++ is KPM, so it\\'s complexity is O(n + m), where m is the characters in the word. But, since our string does not have repeated parts (due to a leading space), the actual complexity is O(n).\\n\\t\\n- Memory: O(m), used internally by `string.find` (KMP).\\n\\n**Optimized KMP-ish Solution**\\nWe can use two pointers to solve this problem in a single pass. We do not need KMP - our word has exactly one space in the beginning, thus no repeating substrings.\\n\\n**Update:** we do need one check from KMP, but just for the first letter (space). Thanks [vitrant](https://leetcode.com/vikrant_pc/) for the find!\\n\\n```cpp\\nint isPrefixOfWord(string sentence, string searchWord) {\\n    auto sent = \" \" + sentence, word = \" \" + searchWord;\\n    int word_cnt = 0, j = 0;\\n    for (auto i = 0; i < sent.size() && j < word.size(); ++i) {\\n        word_cnt += sent[i] == \\' \\';\\n        if (sent[i] == word[j])\\n            ++j;\\n        else\\n            j = sent[i] == word[0] ? 1 : 0;\\n    }\\n    return j == word.size() ? word_cnt : -1;\\n}\\n```\\n**If you do not like adding a space**\\nWell, just check if the previous character is a space. Here, we do not need the KMP check as space will re-start `j` naturally. \\n```cpp\\nint isPrefixOfWord(string sent, string word) {\\n    int word_cnt = 1, j = 0;\\n    for (auto i = 0; i < sent.size() && j < word.size(); ++i) {\\n        word_cnt += sent[i] == \\' \\';\\n        if (sent[i] == word[j])\\n            j = j > 0 ? j + 1 : (i == 0 || sent[i -1] == \\' \\');\\n        else\\n            j = 0;\\n    }\\n    return j == word.size() ? word_cnt : -1;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n), where n is the number of characters in the sentence. We do through the sentence exactly once.\\n- Memory: O(1).",
                "solutionTags": [],
                "code": "```cpp\\nint isPrefixOfWord(string sentence, string searchWord) {\\n    auto sent = \" \" + sentence, word = \" \" + searchWord;\\n    auto pos = sent.find(word);\\n    if (pos != string::npos)\\n        return count(begin(sent), begin(sent) + pos + 1, \\' \\');\\n    return -1;\\n}\\n```\n```cpp\\nint isPrefixOfWord(string sentence, string searchWord) {\\n    auto sent = \" \" + sentence, word = \" \" + searchWord;\\n    int word_cnt = 0, j = 0;\\n    for (auto i = 0; i < sent.size() && j < word.size(); ++i) {\\n        word_cnt += sent[i] == \\' \\';\\n        if (sent[i] == word[j])\\n            ++j;\\n        else\\n            j = sent[i] == word[0] ? 1 : 0;\\n    }\\n    return j == word.size() ? word_cnt : -1;\\n}\\n```\n```cpp\\nint isPrefixOfWord(string sent, string word) {\\n    int word_cnt = 1, j = 0;\\n    for (auto i = 0; i < sent.size() && j < word.size(); ++i) {\\n        word_cnt += sent[i] == \\' \\';\\n        if (sent[i] == word[j])\\n            j = j > 0 ? j + 1 : (i == 0 || sent[i -1] == \\' \\');\\n        else\\n            j = 0;\\n    }\\n    return j == word.size() ? word_cnt : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 648548,
                "title": "c-python-simple-simulation-and-2-lines",
                "content": "Version 1: simple logic \\n```\\nclass Solution {\\npublic:\\n    //int isPrefixOfWord(string& sentence, string& searchWord) { // also ok\\n    int isPrefixOfWord(string sentence, string_view searchWord) {\\n        stringstream ss(sentence);\\n        string word;\\n        int i=1;\\n        while(ss>>word){\\n            if(word.find(searchWord) == 0 ) return i;\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nVersion 2: fewer lines but harder to read\\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string_view searchWord) {\\n        stringstream ss(sentence);\\n        string word;\\n        int i=0;\\n        while(ss>>word) \\n\\t\\t    if(++i && word.find(searchWord) == 0 ) return i;\\n        return -1;\\n    }\\n};\\n```\\n\\nVersion 3: bonus solution. Only for fun\\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {                        \\n        auto it = (\\' \\' + sentence).find(\\' \\' + searchWord);        \\n        return it ==string::npos ? -1: count(begin(sentence), begin(sentence) + it, \\' \\') + 1; \\n    }\\n};\\n```\\n\\nPython: Solution 1\\n```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:        \\n        it = (\\' \\' + sentence).find(\\' \\' + searchWord);        \\n        return -1 if it == -1 else sentence[:it].count(\\' \\') + 1;\\n```\\n\\nPython: Solution 2\\nhttps://stackoverflow.com/questions/3862010/is-there-a-generator-version-of-string-split-in-python\\nWith re.finditer, we cau use minimal memory overhead.\\n```\\nclass Solution:\\n    def split_iter(self, sentence: str):\\n        return (x.group(0) for x in re.finditer(r\"[a-z]+\", sentence))\\n\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:        \\n        for i,w in enumerate(self.split_iter(sentence)):\\n            if w.startswith(searchWord):\\n                return i + 1\\n        return -1\\n```\\nCredit: Thanks for sharing from @zhanghuimeng: \\nhttps://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/discuss/648361/Python3-Split-and-check",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //int isPrefixOfWord(string& sentence, string& searchWord) { // also ok\\n    int isPrefixOfWord(string sentence, string_view searchWord) {\\n        stringstream ss(sentence);\\n        string word;\\n        int i=1;\\n        while(ss>>word){\\n            if(word.find(searchWord) == 0 ) return i;\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string_view searchWord) {\\n        stringstream ss(sentence);\\n        string word;\\n        int i=0;\\n        while(ss>>word) \\n\\t\\t    if(++i && word.find(searchWord) == 0 ) return i;\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {                        \\n        auto it = (\\' \\' + sentence).find(\\' \\' + searchWord);        \\n        return it ==string::npos ? -1: count(begin(sentence), begin(sentence) + it, \\' \\') + 1; \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:        \\n        it = (\\' \\' + sentence).find(\\' \\' + searchWord);        \\n        return -1 if it == -1 else sentence[:it].count(\\' \\') + 1;\\n```\n```\\nclass Solution:\\n    def split_iter(self, sentence: str):\\n        return (x.group(0) for x in re.finditer(r\"[a-z]+\", sentence))\\n\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:        \\n        for i,w in enumerate(self.split_iter(sentence)):\\n            if w.startswith(searchWord):\\n                return i + 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648269,
                "title": "java-o-n-without-using-string-methods-split-or-indexof-or-startswith",
                "content": "O(n) Without using string methods split or indexOf\\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        boolean search = true;\\n        for (int i=0, j =0, wordCount = 1; i<sentence.length(); i++) {\\n            if (search) {\\n                if (searchWord.charAt(j) == sentence.charAt(i)) {\\n                    j++;\\n                    if (j==searchWord.length()) return wordCount;\\n                } else search = false;\\n            }\\n            if (sentence.charAt(i)==\\' \\') {\\n                search = true;\\n                j=0;\\n                wordCount++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nUsing String functions\\n```\\nclass Solution { \\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for (int i=0; i<words.length;i++)\\n            if(words[i].indexOf(searchWord)==0) return i+1; \\n        return -1; \\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        boolean search = true;\\n        for (int i=0, j =0, wordCount = 1; i<sentence.length(); i++) {\\n            if (search) {\\n                if (searchWord.charAt(j) == sentence.charAt(i)) {\\n                    j++;\\n                    if (j==searchWord.length()) return wordCount;\\n                } else search = false;\\n            }\\n            if (sentence.charAt(i)==\\' \\') {\\n                search = true;\\n                j=0;\\n                wordCount++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution { \\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for (int i=0; i<words.length;i++)\\n            if(words[i].indexOf(searchWord)==0) return i+1; \\n        return -1; \\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652789,
                "title": "javascript-easy-to-understand-4-solutions",
                "content": "## SOLUTION 1\\n\\nTraversal the `sentence` char by char to get every word. And check whether the `searchWord` is the prefix.\\nTo add a space at the end of the `sentence` is to handle the last word.\\n\\n```js\\nconst isPrefixOfWord = (sentence, searchWord) => {\\n  sentence += \\' \\';\\n  for (let i = 0, j = 1, word = \\'\\'; i < sentence.length; ++i) {\\n    if (sentence[i] !== \\' \\') { word += sentence[i]; continue; }\\n    if (word.startsWith(searchWord)) return j;\\n    ++j;\\n    word = \\'\\';\\n  }\\n  return -1;\\n};\\n```\\n\\n## SOLUTION 2\\n\\nIt\\'s a improvement for solution 1. Since we traversal the `sentence` char by char, we must have the `searchWord` already before we get the whole word if the `searchWord` is the prefix.\\n\\nAccording to this, we don\\'t need to use the `startsWith` for checking.\\n\\n```js\\nconst isPrefixOfWord = (sentence, searchWord) => {\\n  for (let i = 0, j = 1, word = \\'\\'; i < sentence.length; ++i) {\\n    if (sentence[i] === \\' \\') { ++j; word = \\'\\'; continue; }\\n    word += sentence[i];\\n    if (word === searchWord) return j;\\n  }\\n  return -1;\\n};\\n```\\n\\n## SOLUTION 3\\n\\nWe could use the `String.prototype.split` to split the `sentence` by space. Then, traversal the words and do the checking.\\n\\n```js\\nconst isPrefixOfWord = (sentence, searchWord) => {\\n  const words = sentence.split(\\' \\');\\n  for (let i = 0; i < words.length; ++i) {\\n    if (words[i].startsWith(searchWord)) return i + 1;\\n  }\\n  return -1;\\n};\\n```\\n\\n## SOLUTION 4\\n\\nIt\\'s a 1 line version of solution 2. We just use the `Array.prototype.findIndex` to find the index which we need at the first.\\n\\n```js\\nconst isPrefixOfWord = (sentence, searchWord, idx = sentence.split(\\' \\').findIndex(word => word.startsWith(searchWord))) => idx === -1 ? -1 : idx + 1;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst isPrefixOfWord = (sentence, searchWord) => {\\n  sentence += \\' \\';\\n  for (let i = 0, j = 1, word = \\'\\'; i < sentence.length; ++i) {\\n    if (sentence[i] !== \\' \\') { word += sentence[i]; continue; }\\n    if (word.startsWith(searchWord)) return j;\\n    ++j;\\n    word = \\'\\';\\n  }\\n  return -1;\\n};\\n```\n```js\\nconst isPrefixOfWord = (sentence, searchWord) => {\\n  for (let i = 0, j = 1, word = \\'\\'; i < sentence.length; ++i) {\\n    if (sentence[i] === \\' \\') { ++j; word = \\'\\'; continue; }\\n    word += sentence[i];\\n    if (word === searchWord) return j;\\n  }\\n  return -1;\\n};\\n```\n```js\\nconst isPrefixOfWord = (sentence, searchWord) => {\\n  const words = sentence.split(\\' \\');\\n  for (let i = 0; i < words.length; ++i) {\\n    if (words[i].startsWith(searchWord)) return i + 1;\\n  }\\n  return -1;\\n};\\n```\n```js\\nconst isPrefixOfWord = (sentence, searchWord, idx = sentence.split(\\' \\').findIndex(word => word.startsWith(searchWord))) => idx === -1 ? -1 : idx + 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 776360,
                "title": "python-with-str-split-12ms",
                "content": "\\n\\t\\n\\tdef isPrefixOfWord(self, sentence, searchWord):\\n        sentence = sentence.split(\\' \\')\\n        for index,word in enumerate(sentence):\\n            if searchWord == word[:len(searchWord)]:\\n                return index+1\\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n\\t\\n\\tdef isPrefixOfWord(self, sentence, searchWord):\\n        sentence = sentence.split(\\' \\')\\n        for index,word in enumerate(sentence):\\n            if searchWord == word[:len(searchWord)]:\\n                return index+1\\n        return -1",
                "codeTag": "Python3"
            },
            {
                "id": 1020170,
                "title": "c-super-simple-short-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        stringstream ss(sentence);\\n        string temp;\\n        int i = 1;\\n        \\n        while(ss>>temp) {\\n            if (temp.compare(0, searchWord.size(), searchWord) == 0) \\n                return i;\\n            i++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        stringstream ss(sentence);\\n        string temp;\\n        int i = 1;\\n        \\n        while(ss>>temp) {\\n            if (temp.compare(0, searchWord.size(), searchWord) == 0) \\n                return i;\\n            i++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648335,
                "title": "simple-5-line-java-solution-using-split",
                "content": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] split = sentence.split(\"\\\\\\\\s+\");\\n        for(int i=0;i<split.length;i++){\\n            if(split[i].startsWith(searchWord))\\n                return i+1;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n*Feel free to ask question in comments. Do upvote if you understood the explanation*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] split = sentence.split(\"\\\\\\\\s+\");\\n        for(int i=0;i<split.length;i++){\\n            if(split[i].startsWith(searchWord))\\n                return i+1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763786,
                "title": "simple-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        \\n        int c=1;\\n        int n=sentence.size();\\n        int i=0;\\n        bool b=false;\\n        string t=\"\";\\n        \\n        while(i<n){\\n            \\n            \\n            if(sentence[i]!=\\' \\'){\\n                \\n                t+=sentence[i];\\n                if(t==searchWord){\\n                    b=true;\\n                    break;\\n                }     \\n            }\\n            \\n            else{\\n                \\n                c++;\\n                t=\"\";\\n            } \\n            i++;   \\n        }\\n        \\n        return b==true?c:-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        \\n        int c=1;\\n        int n=sentence.size();\\n        int i=0;\\n        bool b=false;\\n        string t=\"\";\\n        \\n        while(i<n){\\n            \\n            \\n            if(sentence[i]!=\\' \\'){\\n                \\n                t+=sentence[i];\\n                if(t==searchWord){\\n                    b=true;\\n                    break;\\n                }     \\n            }\\n            \\n            else{\\n                \\n                c++;\\n                t=\"\";\\n            } \\n            i++;   \\n        }\\n        \\n        return b==true?c:-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786322,
                "title": "simple-java-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for(int i=0; i<words.length; i++) {\\n        \\tif(words[i].length() >= searchWord.length())\\n        \\t\\tif(words[i].substring(0, searchWord.length()).equals(searchWord)) \\n        \\t\\t\\treturn i + 1;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for(int i=0; i<words.length; i++) {\\n        \\tif(words[i].length() >= searchWord.length())\\n        \\t\\tif(words[i].substring(0, searchWord.length()).equals(searchWord)) \\n        \\t\\t\\treturn i + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 706744,
                "title": "c-0ms-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        \\n        int wordCount = 0;\\n        \\n        for (int i = 0; i < sentence.size(); i++) {\\n                        \\n            // If we are at a new word\\n            if (i == 0 || sentence[i-1] == \\' \\') {\\n                wordCount++;\\n                int j = 0;\\n\\t\\t\\t\\t// Check if full prefix is met\\n                while (sentence[i] == searchWord[j]) {\\n                    if (j == searchWord.size()-1) return wordCount;\\n                    i++;\\n                    j++;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        \\n        int wordCount = 0;\\n        \\n        for (int i = 0; i < sentence.size(); i++) {\\n                        \\n            // If we are at a new word\\n            if (i == 0 || sentence[i-1] == \\' \\') {\\n                wordCount++;\\n                int j = 0;\\n\\t\\t\\t\\t// Check if full prefix is met\\n                while (sentence[i] == searchWord[j]) {\\n                    if (j == searchWord.size()-1) return wordCount;\\n                    i++;\\n                    j++;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648361,
                "title": "python3-split-and-check",
                "content": "# Explanation\\n\\nJust split the sentence into words and check if the search word is the prefix of any word. The time complexity is `O(n)`.\\n\\n# Python3 Solution\\n\\n```cpp\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words = sentence.split(\" \")\\n        for i in range(len(words)):\\n            if words[i].startswith(searchWord):\\n                return i + 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words = sentence.split(\" \")\\n        for i in range(len(words)):\\n            if words[i].startswith(searchWord):\\n                return i + 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277525,
                "title": "c-100-faster-easy-to-understand-fast-clean-and-efficient",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n```\\nclass Solution{\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int l=searchWord.length();\\n        sentence+=\\' \\';\\n        int j=0;\\n        string str;\\n        int c=0;\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            if(sentence[i]==\\' \\')\\n            {\\n                 c++; \\n                 str=sentence.substr(j,i-j);\\n                 if(str.length()>=l)\\n                 {\\n                    if(str.find(searchWord)==0)\\n                    return c;\\n                 }\\n                 j=i+1;\\n                if(i==sentence.length()-1)\\n                 break;   \\n                }\\n             }\\n            return -1;\\n        }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution{\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int l=searchWord.length();\\n        sentence+=\\' \\';\\n        int j=0;\\n        string str;\\n        int c=0;\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            if(sentence[i]==\\' \\')\\n            {\\n                 c++; \\n                 str=sentence.substr(j,i-j);\\n                 if(str.length()>=l)\\n                 {\\n                    if(str.find(searchWord)==0)\\n                    return c;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 1020173,
                "title": "python-4-short-lines-easy-and-simple",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        for i, word in enumerate(sentence.split()):\\n            if word.startswith(searchWord):\\n                return i+1\\n        return -1\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        for i, word in enumerate(sentence.split()):\\n            if word.startswith(searchWord):\\n                return i+1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842028,
                "title": "2-approaches-easy-understanding",
                "content": "```\\n//1.\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        stringstream s(sentence);\\n        string wa;\\n        vector<string> word;\\n        while(s>>wa){\\n            word.push_back(wa);\\n        }\\n        for(int i=0;i<word.size();i++){\\n            if(word[i][0]==searchWord[0]){\\n                size_t found = word[i].find(searchWord); \\n                if (found != string::npos)return i+1;\\n                    \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        stringstream s(sentence);\\n        string wa;\\n        int i=1;\\n        while(s>>wa){\\n            if(wa.find(searchWord) == 0 ) return i;\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//1.\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        stringstream s(sentence);\\n        string wa;\\n        vector<string> word;\\n        while(s>>wa){\\n            word.push_back(wa);\\n        }\\n        for(int i=0;i<word.size();i++){\\n            if(word[i][0]==searchWord[0]){\\n                size_t found = word[i].find(searchWord); \\n                if (found != string::npos)return i+1;\\n                    \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        stringstream s(sentence);\\n        string wa;\\n        int i=1;\\n        while(s>>wa){\\n            if(wa.find(searchWord) == 0 ) return i;\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661966,
                "title": "c-beats-100-space-and-100-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        \\n        stringstream ss(sentence);\\n        \\n        string word;\\n        \\n        int i=1;\\n        \\n        int len = searchWord.length();\\n        \\n        while(ss>>word)\\n        {\\n            string sub = word.substr(0,len);\\n            if(sub==searchWord)\\n                return i;\\n            i++;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        \\n        stringstream ss(sentence);\\n        \\n        string word;\\n        \\n        int i=1;\\n        \\n        int len = searchWord.length();\\n        \\n        while(ss>>word)\\n        {\\n            string sub = word.substr(0,len);\\n            if(sub==searchWord)\\n                return i;\\n            i++;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649050,
                "title": "python-probably-fastest-run-simple-knuth-morris-pratt-implementation",
                "content": "If someone is curious how the KMP algorithm works and how it can be used. This problem is a classic example why KMP is good and fast. It takes only O(N) time to find all substring matches in a string.\\n```\\ndef isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n\\ts = f\"{searchWord.strip()}# {sentence.strip()}\"\\n\\tpi = [0]  # pi-function is a math name chosen in some textbooks for the Prefix Function\\n\\t# Here we calculate and store the prefix-function values\\n\\t# This snippet looks simple but it can break unprepared minds. It took me a lot of iterations over the years to understand it. It might be easy for you btw.\\n\\t# We use our searchWord as the target prefix and the \\'#\\' symbol as a forced border to limit the prefix calculation.\\n\\t# So the whole idea is for each char/position we somewhat recursively count how many chars up to the current char match\\n\\t# the target-prefix which means maximum length substring that ends at the current character and matches\\n\\t# some part of the prefix starting from 0 to maximum \\'#\\'.\\n\\tfor i in range(1, len(s)):\\n\\t\\tj = pi[i-1]\\n\\t\\twhile j > 0 and s[i] != s[j]:\\n\\t\\t\\tj = pi[j-1]\\n\\t\\tif s[i] == s[j]:\\n\\t\\t\\tj += 1\\n\\t\\tpi.append(j)\\n\\n\\tcounter = 0\\n\\tfor i in range(len(searchWord)+1, len(s)):\\n\\t\\tif s[i] == \\' \\':\\n\\t\\t\\tcounter += 1\\n\\t\\t\\tcontinue\\n\\t\\t# our matching substring must be from beginning of a word, not middle of a word\\n\\t\\tif pi[i] == len(searchWord) and s[i-len(searchWord)] == \\' \\':\\n\\t\\t\\treturn counter\\n\\n\\treturn -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n\\ts = f\"{searchWord.strip()}# {sentence.strip()}\"\\n\\tpi = [0]  # pi-function is a math name chosen in some textbooks for the Prefix Function\\n\\t# Here we calculate and store the prefix-function values\\n\\t# This snippet looks simple but it can break unprepared minds. It took me a lot of iterations over the years to understand it. It might be easy for you btw.\\n\\t# We use our searchWord as the target prefix and the \\'#\\' symbol as a forced border to limit the prefix calculation.\\n\\t# So the whole idea is for each char/position we somewhat recursively count how many chars up to the current char match\\n\\t# the target-prefix which means maximum length substring that ends at the current character and matches\\n\\t# some part of the prefix starting from 0 to maximum \\'#\\'.\\n\\tfor i in range(1, len(s)):\\n\\t\\tj = pi[i-1]\\n\\t\\twhile j > 0 and s[i] != s[j]:\\n\\t\\t\\tj = pi[j-1]\\n\\t\\tif s[i] == s[j]:\\n\\t\\t\\tj += 1\\n\\t\\tpi.append(j)\\n\\n\\tcounter = 0\\n\\tfor i in range(len(searchWord)+1, len(s)):\\n\\t\\tif s[i] == \\' \\':\\n\\t\\t\\tcounter += 1\\n\\t\\t\\tcontinue\\n\\t\\t# our matching substring must be from beginning of a word, not middle of a word\\n\\t\\tif pi[i] == len(searchWord) and s[i-len(searchWord)] == \\' \\':\\n\\t\\t\\treturn counter\\n\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3362860,
                "title": "best-c-approach-beats-100-very-simple-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We first check if the search word is a prefix of the sentence. If yes, we return 1.\\n2. We then loop through the sentence and check if the word after a space is the search word. If yes, we return the count of words in the sentence. We add 1 to count because we want to return the word count, not the index.\\n3. If search word is not a prefix of the sentence nor a word in the sentence, we return -1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string search) {\\n        if(sentence.substr(0,search.length())==search)\\n        {\\n            return 1;\\n        }\\n        int count=0;\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            if(sentence[i]==\\' \\')\\n            {\\n                count++;\\n                string str=sentence.substr(i+1,search.length());\\n                if(str==search)\\n                {\\n                    return count+1;\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string search) {\\n        if(sentence.substr(0,search.length())==search)\\n        {\\n            return 1;\\n        }\\n        int count=0;\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            if(sentence[i]==\\' \\')\\n            {\\n                count++;\\n                string str=sentence.substr(i+1,search.length());\\n                if(str==search)\\n                {\\n                    return count+1;\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864100,
                "title": "c-short-code",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t//time: O(len(sentence)), space: O(1)\\n\\t\\tint isPrefixOfWord(string sentence, string searchWord) {\\n\\t\\t\\t// Breaking input into word\\n\\t\\t\\t// using string stream\\n\\t\\t\\tstringstream s(sentence);\\n\\t\\t\\tstring word;\\n\\n\\t\\t\\tint idx = 1;\\n\\t\\t\\twhile(s >> word){\\n\\t\\t\\t\\tif(word.find(searchWord) < 1) //check if searchWord is present or not\\n\\t\\t\\t\\t\\treturn idx;\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t//time: O(len(sentence)), space: O(1)\\n\\t\\tint isPrefixOfWord(string sentence, string searchWord) {\\n\\t\\t\\t// Breaking input into word\\n\\t\\t\\t// using string stream\\n\\t\\t\\tstringstream s(sentence);\\n\\t\\t\\tstring word;\\n\\n\\t\\t\\tint idx = 1;\\n\\t\\t\\twhile(s >> word){\\n\\t\\t\\t\\tif(word.find(searchWord) < 1) //check if searchWord is present or not\\n\\t\\t\\t\\t\\treturn idx;\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2726611,
                "title": "simplest-solution-in-java",
                "content": "```\\nclass Solution {\\n    public static int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for (int i = 1; i <= words.length; ++i) {\\n            if (words[i - 1].startsWith(searchWord)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for (int i = 1; i <= words.length; ++i) {\\n            if (words[i - 1].startsWith(searchWord)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170901,
                "title": "python3-simple-and-readable-solution-with-explanation",
                "content": "Explanation:\\n\\nThis Problem Is Simple. It Just Asks Us To Iterate Through All The Words And Check If Any Word Starts With The Prefix. If No Such Words Appear, Then Return -1 Else Return The Index (1 - based)\\n\\n```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        for i , j in enumerate(sentence.split()):\\n            if(j.startswith(searchWord)):\\n                return i + 1\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        for i , j in enumerate(sentence.split()):\\n            if(j.startswith(searchWord)):\\n                return i + 1\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092690,
                "title": "simple-c-solution",
                "content": "```\\nint isPrefixOfWord(char * sentence, char * searchWord){\\n    int wordIdx = 1;\\n    \\n    char * searchPtr;\\n    \\n    while(*sentence != \\'\\\\0\\'){\\n        searchPtr = searchWord;\\n        \\n        while(*sentence == *searchPtr && *searchPtr != \\'\\\\0\\'){\\n            ++sentence;\\n            ++searchPtr;\\n        }\\n        \\n        if(*searchPtr == \\'\\\\0\\')\\n            return wordIdx;\\n        \\n        while(*sentence != \\'\\\\0\\' && *(sentence++) != \\' \\')\\n            ;\\n        \\n        ++wordIdx;\\n    }\\n    \\n    return -1;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint isPrefixOfWord(char * sentence, char * searchWord){\\n    int wordIdx = 1;\\n    \\n    char * searchPtr;\\n    \\n    while(*sentence != \\'\\\\0\\'){\\n        searchPtr = searchWord;\\n        \\n        while(*sentence == *searchPtr && *searchPtr != \\'\\\\0\\'){\\n            ++sentence;\\n            ++searchPtr;\\n        }\\n        \\n        if(*searchPtr == \\'\\\\0\\')\\n            return wordIdx;\\n        \\n        while(*sentence != \\'\\\\0\\' && *(sentence++) != \\' \\')\\n            ;\\n        \\n        ++wordIdx;\\n    }\\n    \\n    return -1;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 961604,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        l=sentence.split()\\n        for i in range(len(l)):\\n            if l[i].startswith(searchWord):\\n                return i+1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        l=sentence.split()\\n        for i in range(len(l)):\\n            if l[i].startswith(searchWord):\\n                return i+1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820323,
                "title": "c-simple-solution-0-ms-runtime-beats-100-beats-89-in-space-complexity",
                "content": "*C++ Solution\\nProblem:*  **Check If a Word Occurs As a Prefix of Any Word in a Sentence**\\n\\n```\\n\\nclass Solution\\n{\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord)\\n    {\\n        int word_index = 1, i = 0, j = 0;\\n        while (i < sentence.length())\\n        {\\n            while ((j < searchWord.length()) && (sentence[i] == searchWord[j]) && (i >= j) && ((i - j == 0) || (sentence[i - 1 - j] == \\' \\')))\\n            {\\n                j++;\\n                i++;\\n            }\\n            if (j == searchWord.length())\\n                return word_index;\\n            if (sentence[i] == \\' \\')\\n                word_index++;\\n            j = 0;\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord)\\n    {\\n        int word_index = 1, i = 0, j = 0;\\n        while (i < sentence.length())\\n        {\\n            while ((j < searchWord.length()) && (sentence[i] == searchWord[j]) && (i >= j) && ((i - j == 0) || (sentence[i - 1 - j] == \\' \\')))\\n            {\\n                j++;\\n                i++;\\n            }\\n            if (j == searchWord.length())\\n                return word_index;\\n            if (sentence[i] == \\' \\')\\n                word_index++;\\n            j = 0;\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653698,
                "title": "java-100-faster-4-line-solution",
                "content": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n\\t\\n        String[] arr = sentence.split(\" \");\\n        for(int i = 0; i < arr.length; i++)\\n            if(arr[i].indexOf(searchWord)==0) return i+1;\\n        return -1;\\n\\t\\t\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n\\t\\n        String[] arr = sentence.split(\" \");\\n        for(int i = 0; i < arr.length; i++)\\n            if(arr[i].indexOf(searchWord)==0) return i+1;\\n        return -1;\\n\\t\\t\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 649528,
                "title": "crystal-clear-python3-functional-one-liner-beats-100-by-speed-and-memory",
                "content": "Know your libraries! \\n\\n```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        return next((i for i, word in enumerate(sentence.split(), start=1) if word.startswith(searchWord)), -1)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Know your libraries! \\n\\n```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        return next((i for i, word in enumerate(sentence.split(), start=1) if word.startswith(searchWord)), -1)",
                "codeTag": "Java"
            },
            {
                "id": 648542,
                "title": "simple-c-beats-100-using-stringstream",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        if(searchWord.size() >  sentence.size()) \\n        {\\n            return -1;\\n            \\n        }\\n        if(sentence == searchWord)\\n        {\\n            return 0;\\n        }\\n      \\n        \\n        int n = searchWord.size();\\n        istringstream iss(sentence);\\n        vector<string> v;\\n        \\n        string s = \"\";\\n        int i = 0;\\n        while(iss  >>  s)\\n        {\\n            i++;\\n            if(s.substr(0,n) == searchWord)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        if(searchWord.size() >  sentence.size()) \\n        {\\n            return -1;\\n            \\n        }\\n        if(sentence == searchWord)\\n        {\\n            return 0;\\n        }\\n      \\n        \\n        int n = searchWord.size();\\n        istringstream iss(sentence);\\n        vector<string> v;\\n        \\n        string s = \"\";\\n        int i = 0;\\n        while(iss  >>  s)\\n        {\\n            i++;\\n            if(s.substr(0,n) == searchWord)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682381,
                "title": "simple-python-solution-using-startswith",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixOfWord(self, s: str, searchWord: str) -> int:\\n        a = s.split()\\n        for i in range(len(a)):\\n            if a[i].startswith(searchWord):\\n                return i+1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, s: str, searchWord: str) -> int:\\n        a = s.split()\\n        for i in range(len(a)):\\n            if a[i].startswith(searchWord):\\n                return i+1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443690,
                "title": "stringstream-short-c",
                "content": "`Please Upvote If you like the Solution`\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int n = searchWord.size();\\n        stringstream ss(sentence);\\n        string word;\\n        int ans = 1;\\n        bool found = false;\\n        while(ss >> word) {\\n            if(word.substr(0,n) == searchWord) {\\n                found = true;\\n                break;\\n            }\\n            ans++;\\n        }\\n        return ((found) ? ans : -1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int n = searchWord.size();\\n        stringstream ss(sentence);\\n        string word;\\n        int ans = 1;\\n        bool found = false;\\n        while(ss >> word) {\\n            if(word.substr(0,n) == searchWord) {\\n                found = true;\\n                break;\\n            }\\n            ans++;\\n        }\\n        return ((found) ? ans : -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838225,
                "title": "java-3-line-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for (int i = 0; i < words.length; i++) if (words[i].startsWith(searchWord)) return i + 1;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for (int i = 0; i < words.length; i++) if (words[i].startsWith(searchWord)) return i + 1;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542119,
                "title": "c-100-faster-optimal-solution-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence",
                "content": "![image](https://assets.leetcode.com/users/images/1e822ad3-febb-46c2-b0c4-59fdce12b255_1662501565.7421215.png)\\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string s, string pref) {\\n        int n = s.length();\\n        int len = pref.length();\\n        int cnt = 1;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\' \\'){cnt++; continue;}\\n            else{\\n                if(i == 0 || s[i-1] == \\' \\'){\\n                    if(n-i >= len){\\n                        if(s.substr(i,len) == pref){\\n                            return cnt;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string s, string pref) {\\n        int n = s.length();\\n        int len = pref.length();\\n        int cnt = 1;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\' \\'){cnt++; continue;}\\n            else{\\n                if(i == 0 || s[i-1] == \\' \\'){\\n                    if(n-i >= len){\\n                        if(s.substr(i,len) == pref){\\n                            return cnt;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413181,
                "title": "short-javascript-solution-using-the-startswith-method",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n\\n```\\nvar isPrefixOfWord = function (sentence, searchWord) {\\n    let words = sentence.split(\\' \\')\\n\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i].startsWith(searchWord)) return i + 1\\n    }\\n\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPrefixOfWord = function (sentence, searchWord) {\\n    let words = sentence.split(\\' \\')\\n\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i].startsWith(searchWord)) return i + 1\\n    }\\n\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2408073,
                "title": "typescript-javascript-quite-a-short-one-liner",
                "content": "- make an array out of words with `split(\\' \\')`\\n- use `Array.prototype.findIndex()` along with `String.prototype.startsWith()` to find the right word\\n- `findIndex()` returns -1 in case of a failure but we also want to increase the found index by one, so if you add 1 to findIndex result in case of a failure it becomes 0 so ` || -1` will work exactly in that case (`0 || -1 gives -1`).\\n```\\nfunction isPrefixOfWord(sentence: string, searchWord: string): number {\\n  return sentence.split(\\' \\').findIndex(e => e.startsWith(searchWord)) + 1 || -1;\\n}\\n```\\nPlease hit upvote if you find it useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nfunction isPrefixOfWord(sentence: string, searchWord: string): number {\\n  return sentence.split(\\' \\').findIndex(e => e.startsWith(searchWord)) + 1 || -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2255617,
                "title": "java-100-fastser-0-ms-time-complexity-o-n-space-complexity-o-1",
                "content": "Find the index of the search word in the string if it is one thn return 1 other wise search the space + word in the string and count the spaces between 0 to finded Index.\\n```\\npublic int isPrefixOfWord(String sentence, String searchWord) {\\n        if(0==sentence.indexOf(searchWord))\\n            return 1;\\n        int Index = sentence.indexOf(\" \"+searchWord);\\n        if(Index==-1) return -1;\\n        \\n        int count = 0;\\n        for(int i = 0; i < Index+1;i++){\\n            if(sentence.charAt(i)==\\' \\'){\\n                count++;\\n            }\\n        }\\n        return count+1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\npublic int isPrefixOfWord(String sentence, String searchWord) {\\n        if(0==sentence.indexOf(searchWord))\\n            return 1;\\n        int Index = sentence.indexOf(\" \"+searchWord);\\n        if(Index==-1) return -1;\\n        \\n        int count = 0;\\n        for(int i = 0; i < Index+1;i++){\\n            if(sentence.charAt(i)==\\' \\'){\\n                count++;\\n            }\\n        }\\n        return count+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2207801,
                "title": "c-easy-using-substr-function",
                "content": "``  \\n\\n    int isPrefixOfWord(string sentence, string search) {\\n        int count=0;\\n\\t\\t//checking in the first word\\n         if(sentence.substr(0,search.length())==search)\\n             return 1;\\n\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            if(sentence[i]==\\' \\' )\\n            {\\n                count++;\\n                if(sentence.substr(i+1,search.length())==search)\\n                {\\n                    return count+1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n``",
                "solutionTags": [],
                "code": "``  \\n\\n    int isPrefixOfWord(string sentence, string search) {\\n        int count=0;\\n\\t\\t//checking in the first word\\n         if(sentence.substr(0,search.length())==search)\\n             return 1;\\n\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            if(sentence[i]==\\' \\' )\\n            {\\n                count++;\\n                if(sentence.substr(i+1,search.length())==search)\\n                {\\n                    return count+1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 2145896,
                "title": "easy-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string S, string Q) {\\n        int x=Q.length();\\n        vector<string> P;\\n        string N=\"\";\\n        for(int i=0;i<S.length();i++){\\n            if(S[i]==\\' \\'){\\n                P.push_back(N);\\n                N=\"\";\\n            }\\n            else N+=S[i];\\n        }\\n        P.push_back(N);\\n        for(int i=0;i<P.size();i++){\\n            if(P[i].length()>=x && P[i].substr(0,x)==Q) return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string S, string Q) {\\n        int x=Q.length();\\n        vector<string> P;\\n        string N=\"\";\\n        for(int i=0;i<S.length();i++){\\n            if(S[i]==\\' \\'){\\n                P.push_back(N);\\n                N=\"\";\\n            }\\n            else N+=S[i];\\n        }\\n        P.push_back(N);\\n        for(int i=0;i<P.size();i++){\\n            if(P[i].length()>=x && P[i].substr(0,x)==Q) return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678627,
                "title": "simple-solution",
                "content": "class Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int q=searchWord.length();\\n        sentence+=\" \";\\n        string word = \"\";\\n        int m=1;\\n        for (auto x : sentence) \\n        {\\n          if (x == \\' \\')\\n          {\\n             if(word.size()>=q)\\n             {\\n               string t=\"\";\\n               for(int i=0;i<q;i++)\\n               {\\n                  t+=word[i];\\n               }\\n               if(t==searchWord)\\n                  return m;\\n             }\\n             word=\"\";\\n             m++;\\n          }\\n        else {\\n            word = word + x;\\n        }\\n      }\\n        int p=-1;\\n        return p;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int q=searchWord.length();\\n        sentence+=\" \";\\n        string word = \"\";\\n        int m=1;\\n        for (auto x : sentence) \\n        {\\n          if (x == \\' \\')\\n          {\\n             if(word.size()>=q)\\n             {\\n               string t=\"\";\\n               for(int i=0;i<q;i++)\\n               {\\n                  t+=word[i];\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1569159,
                "title": "very-simple-java-solution-100-00",
                "content": "class Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        \\n          String[] split = sentence.split(\" \");\\n          int res = 0;\\n\\n        for (int i = 0; i < split.length; i++) {\\n            if (split[i].indexOf(searchWord) == 0) {\\n                res = i + 1;\\n                break;\\n            }\\n        } \\n        \\n        if (res == 0) {\\n            return -1;\\n        } \\n        else {\\n            return res;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        \\n          String[] split = sentence.split(\" \");\\n          int res = 0;\\n\\n        for (int i = 0; i < split.length; i++) {\\n            if (split[i].indexOf(searchWord) == 0) {\\n                res = i + 1;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1498329,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String arr[] = sentence.split(\" \");\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            if(arr[i].startsWith(searchWord))\\n                return i+1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String arr[] = sentence.split(\" \");\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            if(arr[i].startsWith(searchWord))\\n                return i+1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392655,
                "title": "java-string-matching-0ms-beats-100-in-time-and-memory-t-c-o-n-s-c-o-1",
                "content": "\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        \\n        int len = searchWord.length(), ptr = 0, idx = 1;\\n        boolean flag = true;\\n        \\n        for(char ch : sentence.toCharArray()){\\n            \\n            if(ch == \\' \\'){\\n                idx++;\\n                flag = true;\\n                ptr = 0;\\n            }else if(flag){\\n                flag = (searchWord.charAt(ptr) == ch) ? true : false;\\n                if(flag)\\n                    ptr++;\\n                if(ptr == len)\\n                    return idx;\\n            }\\n        }\\n        \\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        \\n        int len = searchWord.length(), ptr = 0, idx = 1;\\n        boolean flag = true;\\n        \\n        for(char ch : sentence.toCharArray()){\\n            \\n            if(ch == \\' \\'){\\n                idx++;\\n                flag = true;\\n                ptr = 0;\\n            }else if(flag){\\n                flag = (searchWord.charAt(ptr) == ch) ? true : false;\\n                if(flag)\\n                    ptr++;\\n                if(ptr == len)\\n                    return idx;\\n            }\\n        }\\n        \\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1369575,
                "title": "java",
                "content": "\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n\\n\\tString[] words= sentence.split(\" \");\\n\\n\\tint sl= searchWord.length();\\n\\tint i=1;\\n\\n\\tfor(String str:words) {\\n\\t\\tint l = str.length();\\n\\t\\tif(l>=sl) {\\n\\t\\t\\tif(searchWord.equals(str.substring(0,sl))) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ti++;\\n\\t}\\t\\n\\treturn -1;\\n\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n\\n\\tString[] words= sentence.split(\" \");\\n\\n\\tint sl= searchWord.length();\\n\\tint i=1;\\n\\n\\tfor(String str:words) {\\n\\t\\tint l = str.length();\\n\\t\\tif(l>=sl) {\\n\\t\\t\\tif(searchWord.equals(str.substring(0,sl))) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1338434,
                "title": "java-100-faster",
                "content": "```\\n  int len=searchWord.length();\\n\\t\\tString[] s=sentence.split(\" \");\\n\\t\\tint m=0;\\n\\t\\tint n=0;\\n        int index=-1;\\n\\t\\t\\n\\t\\t\\n\\t\\tfor (int i = 0; i < s.length; i++) {\\n\\t\\t\\tif((s[i].length()>=len) && s[i].charAt(m)==searchWord.charAt(n)) {\\n\\t\\t\\t\\tif(searchWord.equals(s[i].subSequence(0, len))) {\\n\\t\\t\\t\\t\\tindex=i+1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn index;\\n```",
                "solutionTags": [],
                "code": "```\\n  int len=searchWord.length();\\n\\t\\tString[] s=sentence.split(\" \");\\n\\t\\tint m=0;\\n\\t\\tint n=0;\\n        int index=-1;\\n\\t\\t\\n\\t\\t\\n\\t\\tfor (int i = 0; i < s.length; i++) {\\n\\t\\t\\tif((s[i].length()>=len) && s[i].charAt(m)==searchWord.charAt(n)) {\\n\\t\\t\\t\\tif(searchWord.equals(s[i].subSequence(0, len))) {\\n\\t\\t\\t\\t\\tindex=i+1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn index;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280213,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        \\n        stringstream ss(sentence);\\n        int i=1;\\n        string s;\\n        \\n        while(ss>>s)\\n        {\\n            if(s.length()>=searchWord.length() && s.substr(0,searchWord.length())==searchWord)\\n             return i;\\n            \\n            i++;\\n        }\\n       return -1; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        \\n        stringstream ss(sentence);\\n        int i=1;\\n        string s;\\n        \\n        while(ss>>s)\\n        {\\n            if(s.length()>=searchWord.length() && s.substr(0,searchWord.length())==searchWord)\\n             return i;\\n            \\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1231917,
                "title": "easy-c-solution-faster-than-100-other-solutions-runtime-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string s, string searchWord) {\\n        s.append(\" \");\\n        int l = s.length();\\n        string word = \"\";\\n        int index = 1;\\n        for(int i = 0; i < l; i++)\\n        {\\n            if(s[i] != \\' \\')\\n                word = word + s[i];\\n            else \\n            {\\n                index++;\\n                word = \"\";\\n            }\\n            if(word == searchWord)\\n                return index;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int isPrefixOfWord(string s, string searchWord) {\\n        s.append(\" \");\\n        int l = s.length();\\n        string word = \"\";\\n        int index = 1;\\n        for(int i = 0; i < l; i++)\\n        {\\n            if(s[i] != \\' \\')\\n                word = word + s[i];\\n            else \\n            {\\n                index++;\\n                word = \"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1223673,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "\\n\\t import java.util.StringTokenizer;\\n     class Solution \\n     {\\n     public int isPrefixOfWord(String sentence, String searchWord) \\n     {\\n        StringTokenizer st = new StringTokenizer(sentence);\\n        int c=1;\\n        while(st.hasMoreTokens())\\n        {\\n            String wd=st.nextToken();\\n            if(wd.startsWith(searchWord))\\n                return c;\\n            c++;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n     {\\n     public int isPrefixOfWord(String sentence, String searchWord) \\n     {\\n        StringTokenizer st = new StringTokenizer(sentence);\\n        int c=1;\\n        while(st.hasMoreTokens())\\n        {\\n            String wd=st.nextToken();\\n            if(wd.startsWith(searchWord))\\n                return c;\\n            c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1215343,
                "title": "python-3-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n\\t\\t\\tlst = sentence.split(\\' \\')\\n\\t\\t\\tfor i in range(len(lst)):\\n\\t\\t\\t\\tif lst[i].find(searchWord) == 0:\\n\\t\\t\\t\\t\\treturn i+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n\\t\\t\\tlst = sentence.split(\\' \\')\\n\\t\\t\\tfor i in range(len(lst)):\\n\\t\\t\\t\\tif lst[i].find(searchWord) == 0:\\n\\t\\t\\t\\t\\treturn i+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1",
                "codeTag": "Java"
            },
            {
                "id": 1139218,
                "title": "c-solution-using-startswith",
                "content": "```\\npublic class Solution {\\n    public int IsPrefixOfWord(string sentence, string searchWord) {\\n        string[] tmp = sentence.Split();\\n        for(int i=0; i<tmp.Length; i++)\\n            if(tmp[i].StartsWith(searchWord))\\n                return i+1;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int IsPrefixOfWord(string sentence, string searchWord) {\\n        string[] tmp = sentence.Split();\\n        for(int i=0; i<tmp.Length; i++)\\n            if(tmp[i].StartsWith(searchWord))\\n                return i+1;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969677,
                "title": "java-very-simple-solution",
                "content": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            if(words[i].indexOf(searchWord) == 0) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return -1;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            if(words[i].indexOf(searchWord) == 0) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return -1;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803482,
                "title": "noob-solution-in-c-for-begineers-only-pro-people-don-t-waste-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        stringstream ss(sentence);\\n        string word;\\n        int n= searchWord.length();\\n        int j=0;\\n        int flag=0;\\n        while(ss>>word){\\n            flag=0;\\n            j++;\\n            for(int i=0;i<n;i++){\\n                if(word[i]!=searchWord[i]){\\n                    flag=1;\\n                    break;\\n                } \\n            }\\n            if(flag==0){\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        stringstream ss(sentence);\\n        string word;\\n        int n= searchWord.length();\\n        int j=0;\\n        int flag=0;\\n        while(ss>>word){\\n            flag=0;\\n            j++;\\n            for(int i=0;i<n;i++){\\n                if(word[i]!=searchWord[i]){\\n                    flag=1;\\n                    break;\\n                } \\n            }\\n            if(flag==0){\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773843,
                "title": "go-without-strings-package",
                "content": "Without the strings.Split() method, you can iterate through the sentence string and search for a \\' \\' and then check if the following characters match the prefix.\\n\\n```go\\nfunc isPrefixOfWord(sentence string, searchWord string) int {\\n\\tif len(sentence) < len(searchWord) {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tif sentence[:len(searchWord)] == searchWord {\\n\\t\\treturn 1\\n\\t}\\n\\n\\tcount := 1\\n\\tfor i := 1; i < len(sentence)-len(searchWord); i++ {\\n\\t\\tif sentence[i] != \\' \\' {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tcount++\\n        i++\\n\\t\\tif sentence[i:i+len(searchWord)] == searchWord {\\n\\t\\t\\treturn count\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc isPrefixOfWord(sentence string, searchWord string) int {\\n\\tif len(sentence) < len(searchWord) {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tif sentence[:len(searchWord)] == searchWord {\\n\\t\\treturn 1\\n\\t}\\n\\n\\tcount := 1\\n\\tfor i := 1; i < len(sentence)-len(searchWord); i++ {\\n\\t\\tif sentence[i] != \\' \\' {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tcount++\\n        i++\\n\\t\\tif sentence[i:i+len(searchWord)] == searchWord {\\n\\t\\t\\treturn count\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762549,
                "title": "c-using-only-vectors-and-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int res = -1;\\n        string word;\\n        vector<string> words; //a vector to store every word\\n        for(int i = 0; i < sentence.size(); i++){\\n            if (sentence[i] != \\' \\'){\\n                word += sentence[i];\\n            }\\n            else{\\n                words.push_back(word);\\n                word = \"\";\\n            }\\n        }\\n        words.push_back(word);//the last word doesnt end with \\' \\', add the last word in\\n        int k = 0;\\n        int n = searchWord.size();\\n        for (int j = 0; j < words.size(); j++){\\n            for (; k < n; k++){\\n                if (searchWord[k] != words[j][k]){\\n                    k=0;\\n                    break;\\n                }\\n                else if (k == (n-1)){\\n                    res = j + 1; // return the 1-indexed, not 0-indexed.\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int res = -1;\\n        string word;\\n        vector<string> words; //a vector to store every word\\n        for(int i = 0; i < sentence.size(); i++){\\n            if (sentence[i] != \\' \\'){\\n                word += sentence[i];\\n            }\\n            else{\\n                words.push_back(word);\\n                word = \"\";\\n            }\\n        }\\n        words.push_back(word);//the last word doesnt end with \\' \\', add the last word in\\n        int k = 0;\\n        int n = searchWord.size();\\n        for (int j = 0; j < words.size(); j++){\\n            for (; k < n; k++){\\n                if (searchWord[k] != words[j][k]){\\n                    k=0;\\n                    break;\\n                }\\n                else if (k == (n-1)){\\n                    res = j + 1; // return the 1-indexed, not 0-indexed.\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744865,
                "title": "golang-beats-100",
                "content": "```\\nfunc isPrefixOfWord(sentence string, searchWord string) int {\\n    arr := strings.Split(sentence, \" \")\\n    for index, word := range arr {\\n        if strings.HasPrefix(word, searchWord) {\\n            return index + 1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isPrefixOfWord(sentence string, searchWord string) int {\\n    arr := strings.Split(sentence, \" \")\\n    for index, word := range arr {\\n        if strings.HasPrefix(word, searchWord) {\\n            return index + 1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 737029,
                "title": "clean-java-solution",
                "content": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] array = sentence.split(\" \");\\n        \\n        for(int i=0;i<array.length;i++){\\n            if(array[i].startsWith(searchWord)){\\n                return i+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] array = sentence.split(\" \");\\n        \\n        for(int i=0;i<array.length;i++){\\n            if(array[i].startsWith(searchWord)){\\n                return i+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721372,
                "title": "python-solution-without-splitting",
                "content": "Using split to split the string into an array is the obvious solution. But I suspect the interviewer won\\'t be satisfied and actually wants a solution where you don\\'t have to traverse the whole string.\\n\\nThe solution below counts character by character and so doesn\\'t require pre-processing the whole string.\\n```\\nclass Solution(object):\\n    def isPrefixOfWord(self, sentence, searchWord):\\n        i = 1\\n        prefix = \\'\\'\\n        for c in sentence:\\n            if c == \\' \\':\\n                i += 1\\n                prefix  = \\'\\'\\n            else:\\n                prefix += c\\n                if searchWord == prefix:\\n                    return i\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isPrefixOfWord(self, sentence, searchWord):\\n        i = 1\\n        prefix = \\'\\'\\n        for c in sentence:\\n            if c == \\' \\':\\n                i += 1\\n                prefix  = \\'\\'\\n            else:\\n                prefix += c\\n                if searchWord == prefix:\\n                    return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659596,
                "title": "java-string-split-and-cnt",
                "content": "```\\nclass Solution {\\n    public int isPrefixOfWord(String ss, String sw) {\\n        String[] ws = ss.split(\"\\\\\\\\s+\");\\n        int res = 0;\\n        for (int i = 0; i < ws.length; i++) {\\n            if (pre(ws[i], sw)) return i + 1;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean pre(String s, String w) {\\n        int m = s.length(), n = w.length();\\n        if (m < n) return false;\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) != w.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String ss, String sw) {\\n        String[] ws = ss.split(\"\\\\\\\\s+\");\\n        int res = 0;\\n        for (int i = 0; i < ws.length; i++) {\\n            if (pre(ws[i], sw)) return i + 1;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean pre(String s, String w) {\\n        int m = s.length(), n = w.length();\\n        if (m < n) return false;\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) != w.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651143,
                "title": "easiest-python-solution-faster-than-94",
                "content": "Tme and space complexity: Linear time and constant space ie O(n) and O(1) resp.\\nSolution:\\n\\t\\t\\t\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        array = sentence.split(\" \")\\n        for word in range(len(array)):\\n            if array[word].startswith(searchWord):\\n                return word + 1 #index + 1 acc to question\\n            else:\\n                continue\\n        return -1\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Tme and space complexity: Linear time and constant space ie O(n) and O(1) resp.\\nSolution:\\n\\t\\t\\t\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        array = sentence.split(\" \")\\n        for word in range(len(array)):\\n            if array[word].startswith(searchWord):\\n                return word + 1 #index + 1 acc to question\\n            else:\\n                continue\\n        return -1\\n",
                "codeTag": "Python3"
            },
            {
                "id": 649705,
                "title": "c-solution-100-00",
                "content": "```\\nint isPrefixOfWord(string sentence, string searchWord) {\\n\\tint index = 1;\\n\\tstringstream ss(sentence);\\n\\twhile (ss) {\\n\\t\\tstring word;\\n\\t\\tss >> word;\\n\\t\\tsize_t pos = word.find(searchWord);\\n\\t\\tif (pos == 0)\\n\\t\\t\\treturn index;\\n\\t\\tindex++;\\n\\t}\\n\\treturn -1;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint isPrefixOfWord(string sentence, string searchWord) {\\n\\tint index = 1;\\n\\tstringstream ss(sentence);\\n\\twhile (ss) {\\n\\t\\tstring word;\\n\\t\\tss >> word;\\n\\t\\tsize_t pos = word.find(searchWord);\\n\\t\\tif (pos == 0)\\n\\t\\t\\treturn index;\\n\\t\\tindex++;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 649584,
                "title": "rust-solution-0ms",
                "content": "\\n```rust\\nimpl Solution {\\n    pub fn is_prefix_of_word(sentence: String, sw: String) -> i32 {\\n        for (i, w) in sentence.split(\\' \\').enumerate(){\\n            if w.starts_with(&sw) {\\n                return i as i32 + 1;\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_prefix_of_word(sentence: String, sw: String) -> i32 {\\n        for (i, w) in sentence.split(\\' \\').enumerate(){\\n            if w.starts_with(&sw) {\\n                return i as i32 + 1;\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 649436,
                "title": "javascript-faster-than-100",
                "content": "```\\n/**\\n * @param {string} sentence\\n * @param {string} searchWord\\n * @return {number}\\n */\\nvar isPrefixOfWord = function(sentence, searchWord) {\\n    const words = sentence.split(\" \");\\n    \\n   for(let i = 0; i < words.length; i++) {\\n       let j = 0;\\n       let k = 0;\\n      \\n       while(j < words[i].length && k < searchWord.length) {\\n           if(searchWord[k] !== words[i][j]) {\\n               break;\\n           }\\n           \\n           j++;\\n           k++;\\n       }\\n       \\n       if (k === searchWord.length) {\\n           return i + 1;\\n       }\\n   }\\n    \\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} sentence\\n * @param {string} searchWord\\n * @return {number}\\n */\\nvar isPrefixOfWord = function(sentence, searchWord) {\\n    const words = sentence.split(\" \");\\n    \\n   for(let i = 0; i < words.length; i++) {\\n       let j = 0;\\n       let k = 0;\\n      \\n       while(j < words[i].length && k < searchWord.length) {\\n           if(searchWord[k] !== words[i][j]) {\\n               break;\\n           }\\n           \\n           j++;\\n           k++;\\n       }\\n       \\n       if (k === searchWord.length) {\\n           return i + 1;\\n       }\\n   }\\n    \\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 648663,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {string} sentence\\n * @param {string} searchWord\\n * @return {number}\\n */\\nvar isPrefixOfWord = function(sentence, searchWord) {\\n    let list = sentence.split(\\' \\')\\n    for(let i=0;i<list.length;i++){\\n        if(list[i].search(searchWord) == 0){\\n            return i+1\\n        }\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sentence\\n * @param {string} searchWord\\n * @return {number}\\n */\\nvar isPrefixOfWord = function(sentence, searchWord) {\\n    let list = sentence.split(\\' \\')\\n    for(let i=0;i<list.length;i++){\\n        if(list[i].search(searchWord) == 0){\\n            return i+1\\n        }\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670761,
                "title": "easy-c-2-pointer-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int ans=1;\\n        int j=0;\\n        int prev=-1;\\n\\n        bool current=true;\\n\\n        for(int i=0;i<sentence.size();i++){\\n            if(sentence[i]==\\' \\') {\\n                ans++;\\n                current=true;\\n                j=0;\\n            }\\n            else if(current && sentence[i]==searchWord[j]){\\n                j++;\\n            }\\n            else{\\n                current=false;\\n                j=0;\\n            }\\n            if(j==searchWord.size()) return ans;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int ans=1;\\n        int j=0;\\n        int prev=-1;\\n\\n        bool current=true;\\n\\n        for(int i=0;i<sentence.size();i++){\\n            if(sentence[i]==\\' \\') {\\n                ans++;\\n                current=true;\\n                j=0;\\n            }\\n            else if(current && sentence[i]==searchWord[j]){\\n                j++;\\n            }\\n            else{\\n                current=false;\\n                j=0;\\n            }\\n            if(j==searchWord.size()) return ans;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591291,
                "title": "rust-simple-3-line-solution-with-iterator-explained-1ms",
                "content": "# Approach\\n* We split the sentence into words using `.split()`.\\n* We try to find the index (using `.position()`) of the word that starts with the given prefix.\\n* Using `.map_or()` if we couldn\\'t find it we return -1, and if we did then we return the index incremented by 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n[Runtime 1 ms Beats 88.24% Memory 2.2 MB Beats 17.65%](https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/submissions/962699825/)\\n\\n```\\nimpl Solution {\\n    pub fn is_prefix_of_word(sentence: String, search_word: String) -> i32 {\\n        sentence.split(\" \")\\n            .position(|word| word.starts_with(&search_word))\\n            .map_or(-1, |i| i as i32 + 1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_prefix_of_word(sentence: String, search_word: String) -> i32 {\\n        sentence.split(\" \")\\n            .position(|word| word.starts_with(&search_word))\\n            .map_or(-1, |i| i as i32 + 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587785,
                "title": "check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int i, j, word=1;\\n        for(i=0 ; i<sentence.length() ; i++)\\n        {\\n            if(sentence[i]==\\' \\')\\n            {\\n                word++;\\n            }\\n            else if(i==0 || sentence[i-1]==\\' \\')\\n            {\\n                for(j=0 ; j<searchWord.length() ; j++)\\n                {\\n                    if(sentence[i+j]!=searchWord[j])\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(j==searchWord.length())\\n                    return word;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/a5012f96-39ec-4d3c-87e4-ea28b28785f2_1685674943.3608043.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int i, j, word=1;\\n        for(i=0 ; i<sentence.length() ; i++)\\n        {\\n            if(sentence[i]==\\' \\')\\n            {\\n                word++;\\n            }\\n            else if(i==0 || sentence[i-1]==\\' \\')\\n            {\\n                for(j=0 ; j<searchWord.length() ; j++)\\n                {\\n                    if(sentence[i+j]!=searchWord[j])\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(j==searchWord.length())\\n                    return word;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451023,
                "title": "100-beginners-friendly-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n            split the sentence into words and store the\\n             words in the form of arrays\\n            if the word starts with searchword then return the index\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] s= sentence.split(\" \");\\n        System.out.println(Arrays.toString(s));\\n        int i=0;\\n        for(String word: s){\\n            i++;\\n            if(word.startsWith(searchWord)) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] s= sentence.split(\" \");\\n        System.out.println(Arrays.toString(s));\\n        int i=0;\\n        for(String word: s){\\n            i++;\\n            if(word.startsWith(searchWord)) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394531,
                "title": "basic-way-to-solve-the-problem-using-string-functions-of-java",
                "content": "# Intuition\\nStore the words in a String Array\\ncheck if word contains searchword &&\\nsearchword is the prefix of the word\\n\\n# Approach\\n\\nSplit the string based on space and store in a String array\\nfind the length of searchword\\ncheck if searchword is present in the word \\n&&\\ncheck if sent[i].substring(0,len) matches with searchword\\n\\nif yes return i+1 position\\nelse return -1\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord)\\n{\\n            String[] sent=null;\\n         \\n        sent=sentence.split(\" \");\\n        for(int i=0;i<sent.length;i++)\\n        {\\n            int len=searchWord.length();\\n            if(sent[i].contains(searchWord) && sent[i].substring(0,len).equals(searchWord)) return i+1;\\n        } \\n        return -1; \\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord)\\n{\\n            String[] sent=null;\\n         \\n        sent=sentence.split(\" \");\\n        for(int i=0;i<sent.length;i++)\\n        {\\n            int len=searchWord.length();\\n            if(sent[i].contains(searchWord) && sent[i].substring(0,len).equals(searchWord)) return i+1;\\n        } \\n        return -1; \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362592,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isPrefixOfWord(self, sentence, searchWord):\\n        \"\"\"\\n        :type sentence: str\\n        :type searchWord: str\\n        :rtype: int\\n        \"\"\"\\n        sentence = sentence.split()\\n        res = 0\\n        for i in range(len(sentence)):\\n            if sentence[i][:len(searchWord)] == searchWord:\\n                res = i + 1\\n                break\\n        return -1 if res == 0 else res\\n\\n\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPrefixOfWord(self, sentence, searchWord):\\n        \"\"\"\\n        :type sentence: str\\n        :type searchWord: str\\n        :rtype: int\\n        \"\"\"\\n        sentence = sentence.split()\\n        res = 0\\n        for i in range(len(sentence)):\\n            if sentence[i][:len(searchWord)] == searchWord:\\n                res = i + 1\\n                break\\n        return -1 if res == 0 else res\\n\\n\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325999,
                "title": "c",
                "content": "\\n# Code\\n```\\npublic class Solution \\n{\\n    public int IsPrefixOfWord(string sentence, string searchWord) \\n    {\\n        var words = sentence.Split(\\' \\');\\n\\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i].StartsWith(searchWord))\\n                return i + 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int IsPrefixOfWord(string sentence, string searchWord) \\n    {\\n        var words = sentence.Split(\\' \\');\\n\\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i].StartsWith(searchWord))\\n                return i + 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296521,
                "title": "easy-solution-c-istringstream-string",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int count = 0 , ans = -1;\\n        istringstream ss(sentence) ;\\n        string w ;\\n        int n = searchWord.size() ;\\n        while(ss>>w){\\n            count++ ;\\n            if(w.substr(0,n)==searchWord){\\n                ans = count ;\\n                break ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int count = 0 , ans = -1;\\n        istringstream ss(sentence) ;\\n        string w ;\\n        int n = searchWord.size() ;\\n        while(ss>>w){\\n            count++ ;\\n            if(w.substr(0,n)==searchWord){\\n                ans = count ;\\n                break ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278379,
                "title": "c-o-n",
                "content": "```\\npublic class Solution {\\n    public int IsPrefixOfWord(string sentence, string searchWord) {\\n        var wordId = -1;\\n        var sId = 0;\\n        var currWordId = 1;\\n        while (sId < sentence.Length)\\n        {\\n            var swId = 0;\\n            var found = true;\\n            while (sId < sentence.Length && !char.IsWhiteSpace(sentence[sId]))\\n            {\\n                if (found && swId < searchWord.Length && sentence[sId] != searchWord[swId]) {\\n                    found = false;\\n                }\\n                swId++;\\n                sId++;\\n            }\\n            if (found && swId >= searchWord.Length) {\\n                wordId = currWordId;\\n                break;\\n            }\\n            sId++;\\n            currWordId++;\\n        }\\n        return wordId;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsPrefixOfWord(string sentence, string searchWord) {\\n        var wordId = -1;\\n        var sId = 0;\\n        var currWordId = 1;\\n        while (sId < sentence.Length)\\n        {\\n            var swId = 0;\\n            var found = true;\\n            while (sId < sentence.Length && !char.IsWhiteSpace(sentence[sId]))\\n            {\\n                if (found && swId < searchWord.Length && sentence[sId] != searchWord[swId]) {\\n                    found = false;\\n                }\\n                swId++;\\n                sId++;\\n            }\\n            if (found && swId >= searchWord.Length) {\\n                wordId = currWordId;\\n                break;\\n            }\\n            sId++;\\n            currWordId++;\\n        }\\n        return wordId;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161274,
                "title": "simple-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string search) {\\n        if(sentence.substr(0,search.length())==search)\\n        {\\n            return 1;\\n        }\\n        int count=0;\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            if(sentence[i]==\\' \\')\\n            {\\n                count++;\\n                string str=sentence.substr(i+1,search.length());\\n                if(str==search)\\n                {\\n                    return count+1;\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string search) {\\n        if(sentence.substr(0,search.length())==search)\\n        {\\n            return 1;\\n        }\\n        int count=0;\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            if(sentence[i]==\\' \\')\\n            {\\n                count++;\\n                string str=sentence.substr(i+1,search.length());\\n                if(str==search)\\n                {\\n                    return count+1;\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147094,
                "title": "fastest-99-85-solution-beginner-friendly-easy-and-simple-python-solution",
                "content": "# Approach\\nJust search for the given searchWord in each of the word of the sentence by checking beginning of the word till the length of the searchWord.. As for loop starts from 0, return the index incremented by 1 in order to get the position of the word in the sentence.\\nSimple............!\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Beats 99.85% of users in runtime: 19ms\\n# Beats 95.54% of users in memory: 13.8mb\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        l = list(sentence.split(\" \"))\\n        # print(l)\\n        for i in range(len(l)):\\n            if l[i][:len(searchWord)]==searchWord:\\n                return i+1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        l = list(sentence.split(\" \"))\\n        # print(l)\\n        for i in range(len(l)):\\n            if l[i][:len(searchWord)]==searchWord:\\n                return i+1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060845,
                "title": "c-simple-solution-faster-than-81",
                "content": "![image.png](https://assets.leetcode.com/users/images/39bc125c-dfce-47e0-932d-47092e63892a_1673902625.4388235.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int IsPrefixOfWord(string sentence, string searchWord) {\\n        var s = sentence.Split(\" \");\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (s[i].Contains(searchWord) && s[i].Substring(0, searchWord.Length) == searchWord)\\n                return i + 1;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsPrefixOfWord(string sentence, string searchWord) {\\n        var s = sentence.Split(\" \");\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (s[i].Contains(searchWord) && s[i].Substring(0, searchWord.Length) == searchWord)\\n                return i + 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972613,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words = sentence.split()\\n        indicies = []\\n        for i, word in enumerate(words):\\n            if word.startswith(searchWord):\\n                return i + 1\\n        return -1\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/bf67bf31-0a03-444a-a7dd-26c6dfa83582_1672425324.7637444.png)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words = sentence.split()\\n        indicies = []\\n        for i, word in enumerate(words):\\n            if word.startswith(searchWord):\\n                return i + 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972605,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words = sentence.split()\\n        indicies = []\\n        for word in words:\\n            if word.startswith(searchWord):\\n                indicies.append(words.index(word))\\n        if len(indicies) > 0:\\n            return min(indicies) + 1\\n        return -1\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/7d94e8f4-3b84-4a43-b031-d1cc2b66450d_1672425138.5607076.png)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words = sentence.split()\\n        indicies = []\\n        for word in words:\\n            if word.startswith(searchWord):\\n                indicies.append(words.index(word))\\n        if len(indicies) > 0:\\n            return min(indicies) + 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903389,
                "title": "c-fast-one-pass-solution-59ms-95",
                "content": "# Approach\\nWalk in sentence word by word and compare in place for prefix - searchWord. \\n\\nThere is two small optimization\\n1) do not check sentence\\'s tail if rest is less than search word length\\n2) if search prefix in place failed then start looking after word space position from the latest search prefix index (continuation).\\n\\n# Complexity\\nTime complexity: $$O(n)$$, Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int IsPrefixOfWord(string sentence, string searchWord) \\n    {\\n        var (idx, wordIdx) = (0, 0);\\n\\n        var sentenceLengthAdjusted = sentence.Length - searchWord.Length;\\n\\n        // each cycle starts with word at index: idx\\n        for(var wordPos = 1; idx <= sentenceLengthAdjusted; idx++, wordPos++)\\n        {\\n            for(wordIdx = 0; wordIdx < searchWord.Length; idx++, wordIdx++)\\n            {\\n                if(sentence[idx] != searchWord[wordIdx]) break;\\n            }\\n\\n            if(wordIdx == searchWord.Length)\\n            {\\n                return wordPos;\\n            }\\n\\n            // move to next space\\n            for(; idx < sentence.Length && sentence[idx] != \\' \\'; idx++) { }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsPrefixOfWord(string sentence, string searchWord) \\n    {\\n        var (idx, wordIdx) = (0, 0);\\n\\n        var sentenceLengthAdjusted = sentence.Length - searchWord.Length;\\n\\n        // each cycle starts with word at index: idx\\n        for(var wordPos = 1; idx <= sentenceLengthAdjusted; idx++, wordPos++)\\n        {\\n            for(wordIdx = 0; wordIdx < searchWord.Length; idx++, wordIdx++)\\n            {\\n                if(sentence[idx] != searchWord[wordIdx]) break;\\n            }\\n\\n            if(wordIdx == searchWord.Length)\\n            {\\n                return wordPos;\\n            }\\n\\n            // move to next space\\n            for(; idx < sentence.Length && sentence[idx] != \\' \\'; idx++) { }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903081,
                "title": "easy-c-solutions-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool fact(string t,string s){\\n     for(int i=0;i<s.size();i++){\\n         if(s[i]!=t[i]){\\n             return 0;\\n         }\\n     }\\n     return 1;\\n}\\n    int isPrefixOfWord(string sentence, string searchWord) {  \\n        stringstream ss(sentence);\\n        string q;\\n         int d=0;\\n         int n=searchWord.size();\\n        while(ss>>q){\\n            d++;\\n            if(q.size()>=n){\\n            if(fact(q,searchWord)) return d;\\n            }\\n        }\\n      return -1;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool fact(string t,string s){\\n     for(int i=0;i<s.size();i++){\\n         if(s[i]!=t[i]){\\n             return 0;\\n         }\\n     }\\n     return 1;\\n}\\n    int isPrefixOfWord(string sentence, string searchWord) {  \\n        stringstream ss(sentence);\\n        string q;\\n         int d=0;\\n         int n=searchWord.size();\\n        while(ss>>q){\\n            d++;\\n            if(q.size()>=n){\\n            if(fact(q,searchWord)) return d;\\n            }\\n        }\\n      return -1;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849873,
                "title": "c-easy-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n       int c=1;\\n       bool f=0;\\n       if(sentence.substr(0,searchWord.size()) == searchWord)\\n       {\\n         return c;\\n       }\\n       for(int i=0;i<sentence.size();i++)\\n       {\\n         if(sentence[i]==\\' \\')\\n         {\\n           c++;\\n           if(sentence.substr(i+1,searchWord.size()) == searchWord)\\n          {\\n            f=1;\\n            break;\\n          }\\n         }\\n       }\\n       if(f==1 && c>0)\\n          return c;\\n        else\\n          return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n       int c=1;\\n       bool f=0;\\n       if(sentence.substr(0,searchWord.size()) == searchWord)\\n       {\\n         return c;\\n       }\\n       for(int i=0;i<sentence.size();i++)\\n       {\\n         if(sentence[i]==\\' \\')\\n         {\\n           c++;\\n           if(sentence.substr(i+1,searchWord.size()) == searchWord)\\n          {\\n            f=1;\\n            break;\\n          }\\n         }\\n       }\\n       if(f==1 && c>0)\\n          return c;\\n        else\\n          return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840928,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n//from arpit410\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string s, string pref) {\\n        int n = s.length();\\n        int len = pref.length();\\n        int cnt = 1;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\' \\'){cnt++; continue;}\\n            else{\\n                if(i == 0 || s[i-1] == \\' \\'){\\n                    if(n-i >= len){\\n                        if(s.substr(i,len) == pref){\\n                            return cnt;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//from arpit410\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string s, string pref) {\\n        int n = s.length();\\n        int len = pref.length();\\n        int cnt = 1;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\' \\'){cnt++; continue;}\\n            else{\\n                if(i == 0 || s[i-1] == \\' \\'){\\n                    if(n-i >= len){\\n                        if(s.substr(i,len) == pref){\\n                            return cnt;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840251,
                "title": "beats-99-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words = sentence.split()\\n        for i in range(0, len(words)):\\n            if searchWord in words[i]:\\n                if words[i][0: len(searchWord)] == searchWord:\\n                           return i + 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words = sentence.split()\\n        for i in range(0, len(words)):\\n            if searchWord in words[i]:\\n                if words[i][0: len(searchWord)] == searchWord:\\n                           return i + 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797808,
                "title": "scala-solution",
                "content": "```scala\\ndef isPrefixOfWord(sentence: String, searchWord: String): Int = {\\n\\tsentence\\n\\t  .split(\" \")\\n\\t  .zipWithIndex\\n\\t  .view\\n\\t  .find(_._1.startsWith(searchWord))\\n\\t  .map(_._2 + 1)\\n\\t  .getOrElse(-1)\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\ndef isPrefixOfWord(sentence: String, searchWord: String): Int = {\\n\\tsentence\\n\\t  .split(\" \")\\n\\t  .zipWithIndex\\n\\t  .view\\n\\t  .find(_._1.startsWith(searchWord))\\n\\t  .map(_._2 + 1)\\n\\t  .getOrElse(-1)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2759451,
                "title": "1455-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence-c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        vector<string>s;\\n        string a;\\n        for(auto& it:sentence){\\n            if(it==\\' \\'){\\n                s.push_back(a);\\n                a.clear();\\n                continue;\\n            }\\n            a.push_back(it);\\n        }\\n        s.push_back(a);\\n        int x=searchWord.length();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i].length()>=x){\\n                string chk=s[i].substr(0,x);\\n                if(chk==searchWord) return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        vector<string>s;\\n        string a;\\n        for(auto& it:sentence){\\n            if(it==\\' \\'){\\n                s.push_back(a);\\n                a.clear();\\n                continue;\\n            }\\n            a.push_back(it);\\n        }\\n        s.push_back(a);\\n        int x=searchWord.length();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i].length()>=x){\\n                string chk=s[i].substr(0,x);\\n                if(chk==searchWord) return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693955,
                "title": "js-very-easy-and-fast-solution",
                "content": "```\\nvar isPrefixOfWord = function(sentence, searchWord) {\\n    sentence = sentence.split(\\' \\');\\n    \\n    for (let i = 0; i < sentence.length; i++) {\\n        if (!sentence[i].indexOf(searchWord)) return i + 1;\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPrefixOfWord = function(sentence, searchWord) {\\n    sentence = sentence.split(\\' \\');\\n    \\n    for (let i = 0; i < sentence.length; i++) {\\n        if (!sentence[i].indexOf(searchWord)) return i + 1;\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2672489,
                "title": "java-startswith-0-ms-easy",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        int idx = Integer.MAX_VALUE;\\n\\n        int i = 0;\\n        for (String s : words) {\\n            i++;\\n            if (s.startsWith(searchWord)) {\\n                idx = Math.min(idx, i);\\n            }\\n        }\\n\\n        return idx == Integer.MAX_VALUE ? -1 : idx;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        int idx = Integer.MAX_VALUE;\\n\\n        int i = 0;\\n        for (String s : words) {\\n            i++;\\n            if (s.startsWith(searchWord)) {\\n                idx = Math.min(idx, i);\\n            }\\n        }\\n\\n        return idx == Integer.MAX_VALUE ? -1 : idx;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650447,
                "title": "simple-0ms-solution",
                "content": "class Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n       int count=-1;\\n            String[] word=sentence.split(\" \");\\n            for(int i=0; i<word.length; i++)\\n            {\\n                if(word[i].startsWith(searchWord)==true){\\n                    count=i+1;\\n                    break;}\\n                }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n       int count=-1;\\n            String[] word=sentence.split(\" \");\\n            for(int i=0; i<word.length; i++)\\n            {\\n                if(word[i].startsWith(searchWord)==true){\\n                    count=i+1;\\n                    break;}",
                "codeTag": "Java"
            },
            {
                "id": 2624409,
                "title": "typescript-javascript-95-faster-two-lines",
                "content": "```\\nfunction isPrefixOfWord(sentence: string, searchWord: string): number {\\n    const index = sentence.split(\\' \\').findIndex(word => word.startsWith(searchWord));\\n    return 0 <= index ? index + 1 : index;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction isPrefixOfWord(sentence: string, searchWord: string): number {\\n    const index = sentence.split(\\' \\').findIndex(word => word.startsWith(searchWord));\\n    return 0 <= index ? index + 1 : index;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2601346,
                "title": "java-easy-solution-faster-than-100",
                "content": "\\n\\n\\n\\t\\tString[] sentences = sentence.split(\" \");\\n        \\n        for (int i = 0; i < sentences.length; i++) {\\n            if (sentences[i].startsWith(searchWord)) {\\n                return (i + 1);\\n            }\\n        }\\n        \\n        return -1;",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\n\\n\\t\\tString[] sentences = sentence.split(\" \");\\n        \\n        for (int i = 0; i < sentences.length; i++) {\\n            if (sentences[i].startsWith(searchWord)) {\\n                return (i + 1);\\n            }\\n        }\\n        \\n        return -1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2580025,
                "title": "java-short-solution-using-string-methods",
                "content": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String s[]=sentence.split(\" \");\\n        for(int i=0;i<s.length;i++)\\n        {\\n            if(s[i].length()>=searchWord.length() && s[i].substring(0,searchWord.length()).equals(searchWord)==true)return (i+1);\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String s[]=sentence.split(\" \");\\n        for(int i=0;i<s.length;i++)\\n        {\\n            if(s[i].length()>=searchWord.length() && s[i].substring(0,searchWord.length()).equals(searchWord)==true)return (i+1);\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497306,
                "title": "easy-solution",
                "content": "```java\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n      var words = sentence.split(\" \");\\n\\n      for (var i = 0; i < words.length; i++) {\\n        if (words[i].startsWith(searchWord))\\n          return i + 1;\\n      }\\n\\n      return -1;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n      var words = sentence.split(\" \");\\n\\n      for (var i = 0; i < words.length; i++) {\\n        if (words[i].startsWith(searchWord))\\n          return i + 1;\\n      }\\n\\n      return -1;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465917,
                "title": "java-string",
                "content": "***Runtime: 0 ms, faster than 100.00% of Java online submissions for Check If a Word Occurs As a Prefix of Any Word in a Sentence.\\nMemory Usage: 42 MB, less than 44.72% of Java online submissions for Check If a Word Occurs As a Prefix of Any Word in a Sentence.***\\n\\n\\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] str =  sentence.split(\" \");\\n        int i = 0;\\n        for(String s : str)\\n        {\\n            i+=1 ;\\n            if(s.startsWith(searchWord))\\n                return i;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] str =  sentence.split(\" \");\\n        int i = 0;\\n        for(String s : str)\\n        {\\n            i+=1 ;\\n            if(s.startsWith(searchWord))\\n                return i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2459168,
                "title": "100-faster-cpp-c-easy-understanding",
                "content": "```\\n int isPrefixOfWord(string sentence, string searchWord) {\\n        int cnt=1;\\n        stringstream str(sentence);\\n        string words;\\n        \\n        while(str>>words){\\n            if(words.find(searchWord)==0)\\n                return cnt;\\n            else\\n                ++cnt;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int isPrefixOfWord(string sentence, string searchWord) {\\n        int cnt=1;\\n        stringstream str(sentence);\\n        string words;\\n        \\n        while(str>>words){\\n            if(words.find(searchWord)==0)\\n                return cnt;\\n            else\\n                ++cnt;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2407253,
                "title": "c-easy-solution-o-n-time-complexity-100-faster-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        sentence+=\" \";\\n        string temp=\"\";\\n        string::iterator it;\\n        int count=0;\\n        for(it=sentence.begin();it!=sentence.end();it++)\\n        {\\n            if(*(it)==\\' \\')//use * before it\\n            {count++;\\n                if(temp.size()>=searchWord.size())\\n                    if(temp.substr(0,searchWord.size())==searchWord)\\n                        return count;\\n             temp=\"\";\\n            }\\n            else\\n                temp+=(*(it));//use * before it\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        sentence+=\" \";\\n        string temp=\"\";\\n        string::iterator it;\\n        int count=0;\\n        for(it=sentence.begin();it!=sentence.end();it++)\\n        {\\n            if(*(it)==\\' \\')//use * before it\\n            {count++;\\n                if(temp.size()>=searchWord.size())\\n                    if(temp.substr(0,searchWord.size())==searchWord)\\n                        return count;\\n             temp=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2399908,
                "title": "c-and-java-runtime-0-ms-faster-than-100-00-easy-understanding",
                "content": "**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int ret=1, i=0, s1 = sentence.size()+1, s2 = searchWord.size();\\n        while(i+s2<s1){\\n            if(string_view(sentence.c_str()+i, s2)==searchWord)\\n                return ret;       \\n            while(sentence[i++]!=32 && i<s1);   \\n            ret++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Java Solution**\\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        int ret=1, ix=0, size = searchWord.length();      \\n        for(String w : words){\\n            if(w.contains(searchWord)){\\n                while(ix<size)\\n                    if(w.charAt(ix)!=searchWord.charAt(ix++)){\\n                        ix=0;\\n                        break;\\n                    }\\n                if(ix == size)\\n                    return ret;\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int ret=1, i=0, s1 = sentence.size()+1, s2 = searchWord.size();\\n        while(i+s2<s1){\\n            if(string_view(sentence.c_str()+i, s2)==searchWord)\\n                return ret;       \\n            while(sentence[i++]!=32 && i<s1);   \\n            ret++;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        int ret=1, ix=0, size = searchWord.length();      \\n        for(String w : words){\\n            if(w.contains(searchWord)){\\n                while(ix<size)\\n                    if(w.charAt(ix)!=searchWord.charAt(ix++)){\\n                        ix=0;\\n                        break;\\n                    }\\n                if(ix == size)\\n                    return ret;\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333067,
                "title": "easy-javacsript-solution",
                "content": "```\\nvar isPrefixOfWord = function(sentence, searchWord) {\\n     \\n    let sen = sentence.split(\\' \\');\\n    for(let i=0;i<sen.length;i++){\\n             \\n       if(sen[i].startsWith(searchWord)){\\n           return i+1;\\n        }\\n    }\\n    return -1;  \\n  \\n};\\n```\\n\\nRuntime: 81 ms, faster than 58.86% of JavaScript online submissions for Check If a Word Occurs As a Prefix of Any Word in a Sentence.\\nMemory Usage: 41.8 MB, less than 68.00% of JavaScript online submissions for Check If a Word Occurs As a Prefix of Any Word in a Sentence.",
                "solutionTags": [],
                "code": "```\\nvar isPrefixOfWord = function(sentence, searchWord) {\\n     \\n    let sen = sentence.split(\\' \\');\\n    for(let i=0;i<sen.length;i++){\\n             \\n       if(sen[i].startsWith(searchWord)){\\n           return i+1;\\n        }\\n    }\\n    return -1;  \\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2316295,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        \\n        stringstream s(sentence);\\n        int count=0;\\n        string words;\\n        while(s>> words)\\n        {\\n            count++;\\n            if(words.find(searchWord)==0)\\n                return count;\\n                \\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        \\n        stringstream s(sentence);\\n        int count=0;\\n        string words;\\n        while(s>> words)\\n        {\\n            count++;\\n            if(words.find(searchWord)==0)\\n                return count;\\n                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2265903,
                "title": "c-3ms-clean-easy-string",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint isPrefixOfWord(string sentence, string searchWord) {\\n\\t\\t\\tstring check=\"\";\\n\\t\\t\\tint c=0;\\n\\t\\t\\tint n=searchWord.size();\\n\\t\\t\\tfor(char i : sentence){\\n\\t\\t\\t\\tif(i==\\' \\'){\\n\\t\\t\\t\\t\\tif(check.size()>=n && check.substr(0,n)==searchWord)\\n\\t\\t\\t\\t\\t\\t\\treturn c+1;\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t\\tcheck=\"\";\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcheck+=i;\\n\\t\\t\\t}\\n\\t\\t\\tif(check.size()>=n && check.substr(0,n)==searchWord)    //for the last word\\n\\t\\t\\t\\t\\t\\t\\treturn c+1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\n\\n\\tTC:O(n)\\n\\tSC:O(1)\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint isPrefixOfWord(string sentence, string searchWord) {\\n\\t\\t\\tstring check=\"\";\\n\\t\\t\\tint c=0;\\n\\t\\t\\tint n=searchWord.size();\\n\\t\\t\\tfor(char i : sentence){\\n\\t\\t\\t\\tif(i==\\' \\'){\\n\\t\\t\\t\\t\\tif(check.size()>=n && check.substr(0,n)==searchWord)\\n\\t\\t\\t\\t\\t\\t\\treturn c+1;\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t\\tcheck=\"\";\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2257782,
                "title": "java-using-3-different-methods",
                "content": "**1. First Method Using startsWith **\\n\\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String str[] = sentence.split(\" \");\\n        for(int i=0;i<str.length;i++){\\n            if(str[i].startsWith(searchWord))\\n                return i+1;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**2.Second Method Using indexOf**\\n\\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String str[] = sentence.split(\" \");\\n        for(int i=0;i<str.length;i++){\\n            if(str[i].indexOf(searchWord)==0)\\n                return i+1;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**3.Using Substring and equals Method**\\n\\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String str[] = sentence.split(\" \");\\n        for(int i=0;i<str.length;i++){\\n            if(str[i].length()>=searchWord.length()){\\n                if (str[i].substring(0,searchWord.length()).equals(searchWord)){\\n                    return i+1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String str[] = sentence.split(\" \");\\n        for(int i=0;i<str.length;i++){\\n            if(str[i].startsWith(searchWord))\\n                return i+1;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String str[] = sentence.split(\" \");\\n        for(int i=0;i<str.length;i++){\\n            if(str[i].indexOf(searchWord)==0)\\n                return i+1;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String str[] = sentence.split(\" \");\\n        for(int i=0;i<str.length;i++){\\n            if(str[i].length()>=searchWord.length()){\\n                if (str[i].substring(0,searchWord.length()).equals(searchWord)){\\n                    return i+1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245600,
                "title": "0ms-faster-than-100-simple-easy-cpp-solution",
                "content": "```\\nint isPrefixOfWord(string sentence, string searchWord) {\\n        string s = \"\";\\n        stringstream ss(sentence);\\n        int index = 1;\\n        while(ss >> s)\\n        {\\n            if(s.find(searchWord) != string::npos && searchWord[0] == s[0] && searchWord[searchWord.length()-1] == s[searchWord.length()-1])\\n                return index;\\n            index++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint isPrefixOfWord(string sentence, string searchWord) {\\n        string s = \"\";\\n        stringstream ss(sentence);\\n        int index = 1;\\n        while(ss >> s)\\n        {\\n            if(s.find(searchWord) != string::npos && searchWord[0] == s[0] && searchWord[searchWord.length()-1] == s[searchWord.length()-1])\\n                return index;\\n            index++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235835,
                "title": "c-easy-solution-easily-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        string word = \"\";\\n        int n = sentence.size();\\n        int space = 0;\\n        for(int i=0;i<n;++i){\\n            if(sentence[i]==\\' \\'){\\n                if(word.size()>=searchWord.size()){\\n                    if(searchWord==word.substr(0,searchWord.size())){\\n                        return space+1;\\n                    } \\n                }\\n                word = \"\";\\n                space++;\\n            }\\n            else{\\n                word.push_back(sentence[i]);\\n            }\\n        }\\n        if(word.size()>=searchWord.size()){\\n            if(searchWord==word.substr(0,searchWord.size())){\\n                return space+1;\\n            } \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        string word = \"\";\\n        int n = sentence.size();\\n        int space = 0;\\n        for(int i=0;i<n;++i){\\n            if(sentence[i]==\\' \\'){\\n                if(word.size()>=searchWord.size()){\\n                    if(searchWord==word.substr(0,searchWord.size())){\\n                        return space+1;\\n                    } \\n                }\\n                word = \"\";\\n                space++;\\n            }\\n            else{\\n                word.push_back(sentence[i]);\\n            }\\n        }\\n        if(word.size()>=searchWord.size()){\\n            if(searchWord==word.substr(0,searchWord.size())){\\n                return space+1;\\n            } \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107018,
                "title": "java-4-liner-solution",
                "content": "```\\npublic int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] str=sentence.split(\" \");\\n        for(int i=0;i<str.length;i++){\\n            if(str[i].startsWith(searchWord)) return i+1;\\n        }\\n        return -1;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] str=sentence.split(\" \");\\n        for(int i=0;i<str.length;i++){\\n            if(str[i].startsWith(searchWord)) return i+1;\\n        }\\n        return -1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1960817,
                "title": "add-leading-spaces-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int isPrefixOfWord(string s, string w) {\\n         s.append(\" \");\\n        string word=\"\";\\n        int index=1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\' \\')\\n            {\\n                word=word+s[i];\\n            }\\n            else\\n            {\\n                index++;\\n                word=\"\";\\n            }\\n            if(word==w)\\n            {\\n              return index;\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1851434,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        ArrayList<String> a = new ArrayList<String>();\\n        int k=0;\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            if(sentence.charAt(i)==\\' \\')\\n            {\\n                a.add(sentence.substring(k,i));\\n                k=i+1;\\n            }      \\n        }\\n        a.add(sentence.substring(k,sentence.length()));\\n        int i=1;\\n        for(String x: a)\\n        {\\n            if(x.indexOf(searchWord)==0)\\n                return i;\\n            i++;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        ArrayList<String> a = new ArrayList<String>();\\n        int k=0;\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            if(sentence.charAt(i)==\\' \\')\\n            {\\n                a.add(sentence.substring(k,i));\\n                k=i+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1609219,
                "title": "rust-fast-100",
                "content": "```\\n\\nstruct Solution{}\\nimpl Solution {\\n    pub fn is_prefix_of_word(sentence: String, search_word: String) -> i32 {\\n        let mut vec:Vec<String> = vec![];\\n        for i in 0..sentence.split_whitespace().count(){\\n            vec.push(sentence.split_whitespace().nth(i).unwrap().to_string())\\n        }\\n        for (i,v) in vec.iter().enumerate(){\\n            if search_word.len() <= v.len(){\\n                if v[0..search_word.len()] == search_word{\\n                    return (i+1) as i32;\\n                }\\n            }\\n        }\\n        -1\\n    }\\n}\\n\\nfn main(){\\n    println!(\"{:?}\",Solution::is_prefix_of_word(\"i love eating burger\".to_string(), \"burg\".to_string()));\\n    \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn basic(){\\n        assert_eq!(Solution::is_prefix_of_word(\"i love eating burger\".to_string(), \"burg\".to_string()),4);\\n        assert_eq!(Solution::is_prefix_of_word(\"this problem is an easy problem\".to_string(), \"pro\".to_string()),2);\\n        assert_eq!(Solution::is_prefix_of_word(\"i am tired\".to_string(), \"you\".to_string()),-1);\\n        assert_eq!(Solution::is_prefix_of_word(\"i use triple pillow\".to_string(), \"pill\".to_string()),4);\\n        assert_eq!(Solution::is_prefix_of_word(\"hello from the other side\".to_string(), \"they\".to_string()),-1);\\n        assert_eq!(Solution::is_prefix_of_word(\"hellohello hellohellohello\".to_string(), \"ell\".to_string()),-1);\\n    }    \\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\nstruct Solution{}\\nimpl Solution {\\n    pub fn is_prefix_of_word(sentence: String, search_word: String) -> i32 {\\n        let mut vec:Vec<String> = vec![];\\n        for i in 0..sentence.split_whitespace().count(){\\n            vec.push(sentence.split_whitespace().nth(i).unwrap().to_string())\\n        }\\n        for (i,v) in vec.iter().enumerate(){\\n            if search_word.len() <= v.len(){\\n                if v[0..search_word.len()] == search_word{\\n                    return (i+1) as i32;\\n                }\\n            }\\n        }\\n        -1\\n    }\\n}\\n\\nfn main(){\\n    println!(\"{:?}\",Solution::is_prefix_of_word(\"i love eating burger\".to_string(), \"burg\".to_string()));\\n    \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn basic(){\\n        assert_eq!(Solution::is_prefix_of_word(\"i love eating burger\".to_string(), \"burg\".to_string()),4);\\n        assert_eq!(Solution::is_prefix_of_word(\"this problem is an easy problem\".to_string(), \"pro\".to_string()),2);\\n        assert_eq!(Solution::is_prefix_of_word(\"i am tired\".to_string(), \"you\".to_string()),-1);\\n        assert_eq!(Solution::is_prefix_of_word(\"i use triple pillow\".to_string(), \"pill\".to_string()),4);\\n        assert_eq!(Solution::is_prefix_of_word(\"hello from the other side\".to_string(), \"they\".to_string()),-1);\\n        assert_eq!(Solution::is_prefix_of_word(\"hellohello hellohellohello\".to_string(), \"ell\".to_string()),-1);\\n    }    \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604182,
                "title": "c-solution-100-time-efficient-92-space-efficient-explained-easy-beginner-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) \\n    {\\n        sentence += \\' \\';    //Adding space at last of sentence because we get a new word when we get a space so to get the last word we add one more space\\n        string w=\"\";  //To store each individual word\\n        int c=0;     //To store the count of which word we are processing\\n        for(int i=0;i<sentence.size();i++)     //Traversing from start to end of string\\n        {\\n            if(sentence[i] != \\' \\')    //We keep on adding character to w until we get a space\\n                w += sentence[i];\\n            else                          //We move to this block when we have got a word\\n            {\\n                c++;                  //Increments c whenever we get a new word\\n                if(w.size() >= searchWord.size() && searchWord == w.substr(0,searchWord.size()))     //This check if searchWord is present at start or not \\n                {                                                           \\n                    return c;    //If it is there we return the count of that word and break the loop\\n                    break;\\n                }\\n                w = \"\";      //It is needed to empty the w as we need to store each word seperately\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) \\n    {\\n        sentence += \\' \\';    //Adding space at last of sentence because we get a new word when we get a space so to get the last word we add one more space\\n        string w=\"\";  //To store each individual word\\n        int c=0;     //To store the count of which word we are processing\\n        for(int i=0;i<sentence.size();i++)     //Traversing from start to end of string\\n        {\\n            if(sentence[i] != \\' \\')    //We keep on adding character to w until we get a space\\n                w += sentence[i];\\n            else                          //We move to this block when we have got a word\\n            {\\n                c++;                  //Increments c whenever we get a new word\\n                if(w.size() >= searchWord.size() && searchWord == w.substr(0,searchWord.size()))     //This check if searchWord is present at start or not \\n                {                                                           \\n                    return c;    //If it is there we return the count of that word and break the loop\\n                    break;\\n                }\\n                w = \"\";      //It is needed to empty the w as we need to store each word seperately\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582243,
                "title": "easy-python-solution",
                "content": "```\\ndef isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        s=sentence.split(\" \")\\n        for i, j in enumerate(s, 1):\\n            if j.startswith(searchWord):\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        s=sentence.split(\" \")\\n        for i, j in enumerate(s, 1):\\n            if j.startswith(searchWord):\\n                return i\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1564693,
                "title": "java-golang-solutions-faster-than-100-java-and-go",
                "content": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] s = sentence.split(\" \");\\n        int searchWordLen = searchWord.length();\\n\\n        for (int i = 0; i < s.length; i++) {\\n            String word = s[i];\\n            if (word.length() > searchWordLen) {\\n                if (word.substring(0, searchWordLen).equals(searchWord)) {\\n                    return i + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\\n\\n```\\nfunc IsPrefixOfWord(sentence string, searchWord string) int {\\n\\tfor i, word := range strings.Split(sentence, \" \") {\\n\\t\\tif len(word) >= len(searchWord) {\\n\\t\\t\\tif word[0: len(searchWord)] == searchWord {\\n\\t\\t\\t\\treturn  i + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] s = sentence.split(\" \");\\n        int searchWordLen = searchWord.length();\\n\\n        for (int i = 0; i < s.length; i++) {\\n            String word = s[i];\\n            if (word.length() > searchWordLen) {\\n                if (word.substring(0, searchWordLen).equals(searchWord)) {\\n                    return i + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\n```\\nfunc IsPrefixOfWord(sentence string, searchWord string) int {\\n\\tfor i, word := range strings.Split(sentence, \" \") {\\n\\t\\tif len(word) >= len(searchWord) {\\n\\t\\t\\tif word[0: len(searchWord)] == searchWord {\\n\\t\\t\\t\\treturn  i + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540373,
                "title": "easy-solution",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        l=list(map(str,sentence.split()))\\n        x=len(searchWord)\\n        for i in range(len(l)):\\n            if(len(l[i])>=x):\\n                if(l[i][:x]==searchWord):\\n                    return(i+1)\\n        return(-1)\\n```\\nIf u liked the code plz upvote...thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        l=list(map(str,sentence.split()))\\n        x=len(searchWord)\\n        for i in range(len(l)):\\n            if(len(l[i])>=x):\\n                if(l[i][:x]==searchWord):\\n                    return(i+1)\\n        return(-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514126,
                "title": "100-fast-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        vector<string> word;\\n        int i=0;\\n        while(i<sentence.size()){\\n            string temp_word;\\n            while(sentence[i]!=\\' \\' && i<sentence.size()){\\n               temp_word  += sentence[i];  \\n                i++;\\n            }\\n            i++;\\n              word.push_back(temp_word);\\n        }\\n           for(int i=0; i<word.size(); i++){\\n               string tmp=word[i];\\n               int j=0;\\n               bool flag=true;\\n               if(tmp.size()<searchWord.size()) continue;\\n               while(j<searchWord.size()){\\n                   if(searchWord[j]!=tmp[j]) {flag=false; break;}\\n                   j++;\\n               }\\n                 if(flag) return i+1;\\n           }\\n            return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        vector<string> word;\\n        int i=0;\\n        while(i<sentence.size()){\\n            string temp_word;\\n            while(sentence[i]!=\\' \\' && i<sentence.size()){\\n               temp_word  += sentence[i];  \\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1490127,
                "title": "java-faster-than-100",
                "content": "**Do vote  up if you like it :)**\\n```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        int sentenceLen = sentence.length();\\n        int searchWordLen = searchWord.length();\\n        int spaceCount = 0;\\n        \\n        for(int i = 0; i < sentenceLen; i++) {\\n            int count = 0;\\n            if(sentence.charAt(i) == \\' \\') spaceCount++;\\n            if((i == 0 && sentence.charAt(i) == searchWord.charAt(0) ||\\n               (i > 0 && sentence.charAt(i - 1) == \\' \\' && sentence.charAt(i) == searchWord.charAt(0)))){\\n                for(int j = i, k = 0; k < searchWordLen; j++, k++) {\\n                    if(sentence.charAt(j) != searchWord.charAt(k)) break;\\n                    else count++;\\n                }\\n                if(count == searchWordLen) return spaceCount + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        int sentenceLen = sentence.length();\\n        int searchWordLen = searchWord.length();\\n        int spaceCount = 0;\\n        \\n        for(int i = 0; i < sentenceLen; i++) {\\n            int count = 0;\\n            if(sentence.charAt(i) == \\' \\') spaceCount++;\\n            if((i == 0 && sentence.charAt(i) == searchWord.charAt(0) ||\\n               (i > 0 && sentence.charAt(i - 1) == \\' \\' && sentence.charAt(i) == searchWord.charAt(0)))){\\n                for(int j = i, k = 0; k < searchWordLen; j++, k++) {\\n                    if(sentence.charAt(j) != searchWord.charAt(k)) break;\\n                    else count++;\\n                }\\n                if(count == searchWordLen) return spaceCount + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489722,
                "title": "c-0ms-100-clean-solution-using-string-find",
                "content": "```cpp\\nclass Solution\\n{\\npublic:\\n  int isPrefixOfWord(string sentence, string searchWord)\\n  {\\n    istringstream iss(sentence);\\n    string word;\\n    int i = 0;\\n    while (iss >> word)\\n    {\\n      ++i;\\n      if (word.find(searchWord) == 0)\\n      {\\n        return i;\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution\\n{\\npublic:\\n  int isPrefixOfWord(string sentence, string searchWord)\\n  {\\n    istringstream iss(sentence);\\n    string word;\\n    int i = 0;\\n    while (iss >> word)\\n    {\\n      ++i;\\n      if (word.find(searchWord) == 0)\\n      {\\n        return i;\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349419,
                "title": "python-solution-seems-to-work-but-the-problem-in-test-cases",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        S_S = sentence.split()\\n        for word in S_S:\\n            if word[:len(searchWord)] == searchWord:\\n                ans =  S_S.index(word) + 1\\n            else:\\n                ans = -1\\n        return ans\\n \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        S_S = sentence.split()\\n        for word in S_S:\\n            if word[:len(searchWord)] == searchWord:\\n                ans =  S_S.index(word) + 1\\n            else:\\n                ans = -1\\n        return ans\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272581,
                "title": "c-baisc-0-ms-faster-than-100-00-easy-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int i=0;\\n        string word;\\n        sentence=sentence+\" \";//adding extra space in the end\\n        //convertinf sentence into string vector\\n        vector<string>words;\\n        for(int i=0;i<sentence.size();i++)\\n        {\\n            if(sentence[i]!=\\' \\')\\n            {\\n                word=word+sentence[i];\\n            }\\n            else\\n            {\\n                words.push_back(word);\\n                word=\"\";\\n                \\n            }\\n                \\n        }\\n        \\n        \\n        for(auto word:words)\\n        {\\n            i++; //counting the words\\n            \\n            //searching the prefix\\n            //if found at pos 0 i.e its prefix\\n            if(word.find(searchWord)==0)\\n            {\\n                    return i;//returning positon\\n            }\\n                \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```# If you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int i=0;\\n        string word;\\n        sentence=sentence+\" \";//adding extra space in the end\\n        //convertinf sentence into string vector\\n        vector<string>words;\\n        for(int i=0;i<sentence.size();i++)\\n        {\\n            if(sentence[i]!=\\' \\')\\n            {\\n                word=word+sentence[i];\\n            }\\n            else\\n            {\\n                words.push_back(word);\\n                word=\"\";\\n                \\n            }\\n                \\n        }\\n        \\n        \\n        for(auto word:words)\\n        {\\n            i++; //counting the words\\n            \\n            //searching the prefix\\n            //if found at pos 0 i.e its prefix\\n            if(word.find(searchWord)==0)\\n            {\\n                    return i;//returning positon\\n            }\\n                \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262226,
                "title": "javascript-solution-for-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence",
                "content": "```\\nvar isPrefixOfWord = function(sentence, searchWord) {\\n // break the sentence to words\\n    let words = sentence.split(\" \");\\n\\t//regular expression for a word starting with the pattern\\n    const regex = \\'^\\'+searchWord+\\'[A-Za-z0-9]*\\';\\n\\t//Iterate through the word array to check if there is a match, if yes return index + 1 as it is zero indexed, else return -1\\n    for (let i = 0; i < words.length; i++) {\\n        if(words[i].toString().match(regex) != null){\\n            return i+1;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isPrefixOfWord = function(sentence, searchWord) {\\n // break the sentence to words\\n    let words = sentence.split(\" \");\\n\\t//regular expression for a word starting with the pattern\\n    const regex = \\'^\\'+searchWord+\\'[A-Za-z0-9]*\\';\\n\\t//Iterate through the word array to check if there is a match, if yes return index + 1 as it is zero indexed, else return -1\\n    for (let i = 0; i < words.length; i++) {\\n        if(words[i].toString().match(regex) != null){\\n            return i+1;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1259289,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        vector<string> v;\\n        stringstream s(sentence);\\n        string word;\\n        while(s >> word)\\n            v.push_back(word);\\n        \\n        int n = searchWord.length();\\n        for(int i = 0; i<v.size(); i++){\\n            if(v[i].length()>=n){\\n                string t = v[i].substr(0,n);\\n                if(t==searchWord) return i+1; \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        vector<string> v;\\n        stringstream s(sentence);\\n        string word;\\n        while(s >> word)\\n            v.push_back(word);\\n        \\n        int n = searchWord.length();\\n        for(int i = 0; i<v.size(); i++){\\n            if(v[i].length()>=n){\\n                string t = v[i].substr(0,n);\\n                if(t==searchWord) return i+1; \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255957,
                "title": "rust-another-solution-with-zip",
                "content": "```\\nimpl Solution {\\n    pub fn is_prefix_of_word(sentence: String, search_word: String) -> i32 {\\n        for (word, num) in sentence.split_whitespace().zip(1i32..) {\\n            if word.starts_with(&search_word) {\\n                return num;\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_prefix_of_word(sentence: String, search_word: String) -> i32 {\\n        for (word, num) in sentence.split_whitespace().zip(1i32..) {\\n            if word.starts_with(&search_word) {\\n                return num;\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248813,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord)\\n    {\\n        stringstream str(sentence);\\n        string s;\\n        int c = 0;\\n        int x = -1;\\n        while(str >> s)\\n            {\\n            c++;\\n             if(s.find(searchWord) == 0)\\n                 {\\n             x = c; \\n                 break;\\n                 }\\n            }\\n        return x;\\n    }\\n};\\n``",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord)\\n    {\\n        stringstream str(sentence);\\n        string s;\\n        int c = 0;\\n        int x = -1;\\n        while(str >> s)\\n            {\\n            c++;\\n             if(s.find(searchWord) == 0)\\n                 {\\n             x = c; \\n                 break;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 1235882,
                "title": "python-solution-94-fast-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        sentence = sentence.split(\" \")\\n        n = len(searchWord)\\n        for i in sentence:\\n            if i[0:n]==searchWord:\\n                return sentence.index(i)+1\\n        return -1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        sentence = sentence.split(\" \")\\n        n = len(searchWord)\\n        for i in sentence:\\n            if i[0:n]==searchWord:\\n                return sentence.index(i)+1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225557,
                "title": "python-super-noob-solution",
                "content": "class Solution:\\n\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        \\n        ls=sentence.split(\" \")\\n        \\n        for i in range(len(ls)):\\n            if searchWord in ls[i][:len(searchWord)]:\\n                return (i+1)\\n        return -1\\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        \\n        ls=sentence.split(\" \")\\n        \\n        for i in range(len(ls)):\\n            if searchWord in ls[i][:len(searchWord)]:\\n                return (i+1)\\n        return -1\\n",
                "codeTag": "Java"
            },
            {
                "id": 1219993,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words=sentence.split(\" \")\\n        n=len(searchWord)\\n        for i in range(len(words)):\\n            if len(words[i])<n:continue\\n            else:\\n                words[i]=words[i][:n]\\n                if searchWord in words[i] :\\n                    return i+1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words=sentence.split(\" \")\\n        n=len(searchWord)\\n        for i in range(len(words)):\\n            if len(words[i])<n:continue\\n            else:\\n                words[i]=words[i][:n]\\n                if searchWord in words[i] :\\n                    return i+1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207476,
                "title": "python-solution-99-faster",
                "content": "```class Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        wordList=sentence.split()\\n        searchWordLen=len(searchWord)\\n        for i in range(len(wordList)):\\n            if searchWord==wordList[i][0:searchWordLen]:\\n                return i+1\\n        return -1",
                "solutionTags": [],
                "code": "```class Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        wordList=sentence.split()\\n        searchWordLen=len(searchWord)\\n        for i in range(len(wordList)):\\n            if searchWord==wordList[i][0:searchWordLen]:\\n                return i+1\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 1193922,
                "title": "c-100-solution-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int j=0;\\n        int wordCount=1;\\n        for(int i=0;i<sentence.length();i++){\\n            if(sentence[i]!=searchWord[0]){\\n                wordCount++;\\n                while(i<sentence.length() && sentence[i]!=\\' \\'){\\n                    i++;\\n                }\\n                \\n            }else{\\n                while(j<searchWord.length() && sentence[i]==searchWord[j]){\\n                    j++;\\n                    i++;\\n                }\\n                if(j==searchWord.length()){\\n                    return wordCount;\\n                }else{\\n                    if(sentence[i]==\\' \\'){\\n                     wordCount++;   \\n                    }\\n                    j=0;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        int j=0;\\n        int wordCount=1;\\n        for(int i=0;i<sentence.length();i++){\\n            if(sentence[i]!=searchWord[0]){\\n                wordCount++;\\n                while(i<sentence.length() && sentence[i]!=\\' \\'){\\n                    i++;\\n                }\\n                \\n            }else{\\n                while(j<searchWord.length() && sentence[i]==searchWord[j]){\\n                    j++;\\n                    i++;\\n                }\\n                if(j==searchWord.length()){\\n                    return wordCount;\\n                }else{\\n                    if(sentence[i]==\\' \\'){\\n                     wordCount++;   \\n                    }\\n                    j=0;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178991,
                "title": "c-stringstream-100-fast-beginner-friendly-code",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sent, string search) {\\n        int i=1;\\n        stringstream stream(sent);\\n        string word=\"\";\\n        \\n        while(stream>>word){\\n            if(word.size()>=search.size() && word.substr(0,search.size())==search)return i;\\n\\t\\t\\telse\\n            i++;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int isPrefixOfWord(string sent, string search) {\\n        int i=1;\\n        stringstream stream(sent);\\n        string word=\"\";\\n        \\n        while(stream>>word){\\n            if(word.size()>=search.size() && word.substr(0,search.size())==search)return i;\\n\\t\\t\\telse\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1174975,
                "title": "java-solution-100-o-n",
                "content": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        int res = 1;\\n        int index = 0;\\n        boolean test = true;\\n        for(int i = 0; i < sentence.length(); i++){\\n            if(sentence.charAt(i) == \\' \\'){\\n                test = true;\\n                res++;\\n                index = 0;\\n            }else if(test == false){\\n                continue;\\n            }else if(sentence.charAt(i) == searchWord.charAt(index)){\\n                index++;\\n                if(index == searchWord.length())\\n                    return res;\\n                continue;\\n            }else if(sentence.charAt(i) != searchWord.charAt(index)){\\n                test = false;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        int res = 1;\\n        int index = 0;\\n        boolean test = true;\\n        for(int i = 0; i < sentence.length(); i++){\\n            if(sentence.charAt(i) == \\' \\'){\\n                test = true;\\n                res++;\\n                index = 0;\\n            }else if(test == false){\\n                continue;\\n            }else if(sentence.charAt(i) == searchWord.charAt(index)){\\n                index++;\\n                if(index == searchWord.length())\\n                    return res;\\n                continue;\\n            }else if(sentence.charAt(i) != searchWord.charAt(index)){\\n                test = false;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154821,
                "title": "c-using-rfind-and-substr-time-o-n-space-o-1",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) \\n    {\\n        int count = 0;\\n        int start = 0, len = 0;\\n        \\n        for ( int i=0; i<sentence.length(); i++ ) {\\n            start = i;\\n            len = i;\\n            while ( sentence[len] != \\' \\' && len<sentence.length() ) {\\n                len++;\\n            }\\n            count++;\\n            if ( sentence.substr(start,len).rfind(searchWord,0) == 0 ) {\\n                return count; \\n            }\\n            start = len;\\n            i = start;\\n            len = 0;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) \\n    {\\n        int count = 0;\\n        int start = 0, len = 0;\\n        \\n        for ( int i=0; i<sentence.length(); i++ ) {\\n            start = i;\\n            len = i;\\n            while ( sentence[len] != \\' \\' && len<sentence.length() ) {\\n                len++;\\n            }\\n            count++;\\n            if ( sentence.substr(start,len).rfind(searchWord,0) == 0 ) {\\n                return count; \\n            }\\n            start = len;\\n            i = start;\\n            len = 0;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149240,
                "title": "76-ms-faster-than-70-50-of-javascript-online-submissions",
                "content": "var isPrefixOfWord = function(sentence, searchWord) {\\n   const arr = sentence.split(\" \");\\n    \\n    for (let i=0; i<arr.length; i++){\\n        if (arr[i].indexOf(searchWord)===0) return i+1;\\n    }\\n    return -1;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var isPrefixOfWord = function(sentence, searchWord) {\\n   const arr = sentence.split(\" \");\\n    \\n    for (let i=0; i<arr.length; i++){\\n        if (arr[i].indexOf(searchWord)===0) return i+1;\\n    }\\n    return -1;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1133960,
                "title": "simple-python-solution",
                "content": "class Solution(object):\\n    def isPrefixOfWord(self, sentence, searchWord):\\n        li=sentence.split()\\n        b=-1\\n        c=len(searchWord)\\n        for i in range(len(li)):\\n            a=li[i]\\n            if searchWord==a[0:c]:\\n                b=i+1\\n                break\\n        return b",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def isPrefixOfWord(self, sentence, searchWord):\\n        li=sentence.split()\\n        b=-1\\n        c=len(searchWord)\\n        for i in range(len(li)):\\n            a=li[i]\\n            if searchWord==a[0:c]:\\n                b=i+1\\n                break\\n        return b",
                "codeTag": "Java"
            },
            {
                "id": 1129090,
                "title": "simple-python-solution-using-startswith-method-faster-than-85",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        l = sentence.split()\\n        for i in range(len(l)):\\n            if l[i].startswith(searchWord):\\n                return (i+1)\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        l = sentence.split()\\n        for i in range(len(l)):\\n            if l[i].startswith(searchWord):\\n                return (i+1)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119536,
                "title": "c-stringstream",
                "content": "```\\nint isPrefixOfWord(string sentence, string searchWord, string cur = \"\") {\\n\\tistringstream iss(sentence);\\n\\tfor (int i = 1; iss >> cur; ++i) if (cur.find(searchWord) == 0) return i;\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint isPrefixOfWord(string sentence, string searchWord, string cur = \"\") {\\n\\tistringstream iss(sentence);\\n\\tfor (int i = 1; iss >> cur; ++i) if (cur.find(searchWord) == 0) return i;\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115266,
                "title": "python-simple-faster-than-90",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        for index, word in enumerate(sentence.split(\\' \\'), 1):\\n            if searchWord == word[:len(searchWord)]:\\n                return index\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        for index, word in enumerate(sentence.split(\\' \\'), 1):\\n            if searchWord == word[:len(searchWord)]:\\n                return index\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110959,
                "title": "python3-easy-100-fast",
                "content": "```class Solution:\\n    def isPrefixOfWord(self, s: str, w: str) -> int:\\n        l = s.split()\\n        for i in l:\\n            if len(i)>= len(w):\\n               \\n                if i[0:len(w)]==w:\\n                    return l.index(i)+1\\n        return -1```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Solution:\\n    def isPrefixOfWord(self, s: str, w: str) -> int:\\n        l = s.split()\\n        for i in l:\\n            if len(i)>= len(w):\\n               \\n                if i[0:len(w)]==w:\\n                    return l.index(i)+1\\n        return -1```",
                "codeTag": "Java"
            },
            {
                "id": 1077822,
                "title": "java-0ms-better-than-99-51-space-wise",
                "content": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n      String[] words = sentence.split(\" \");\\n      for (int i = 0; i < words.length; i++) {\\n        if (words[i].charAt(0) != searchWord.charAt(0)) {\\n          continue;\\n        } else {\\n          int flag = 0;\\n          if (words[i].length() >= searchWord.length()) {\\n            for(int j = 0; j < searchWord.length(); j++) {\\n              if (words[i].charAt(j) != searchWord.charAt(j)) {\\n                flag = 1;\\n                break;\\n              }\\n            }\\n            if (flag != 1) {\\n              return i + 1;\\n            }\\n          }\\n        }\\n      }\\n      return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n      String[] words = sentence.split(\" \");\\n      for (int i = 0; i < words.length; i++) {\\n        if (words[i].charAt(0) != searchWord.charAt(0)) {\\n          continue;\\n        } else {\\n          int flag = 0;\\n          if (words[i].length() >= searchWord.length()) {\\n            for(int j = 0; j < searchWord.length(); j++) {\\n              if (words[i].charAt(j) != searchWord.charAt(j)) {\\n                flag = 1;\\n                break;\\n              }\\n            }\\n            if (flag != 1) {\\n              return i + 1;\\n            }\\n          }\\n        }\\n      }\\n      return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076820,
                "title": "psimple-python-regex-solution-faster-than-80",
                "content": "```\\nimport re\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        count = 0\\n        splat = sentence.split(\\' \\')\\n        for i in splat:\\n            if re.search(f\\'^{searchWord}\\', i):\\n                return splat.index(i) + 1\\n                count += 1\\n                break\\n\\n        if count == 0:\\n            return -1\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        count = 0\\n        splat = sentence.split(\\' \\')\\n        for i in splat:\\n            if re.search(f\\'^{searchWord}\\', i):\\n                return splat.index(i) + 1\\n                count += 1\\n                break\\n\\n        if count == 0:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056474,
                "title": "python-self-explained-straightforward-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words=sentence.split(\\' \\')\\n        index=0\\n        for word in words:\\n            index+=1\\n            if word.find(searchWord)==0:\\n                return index        \\n        return -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words=sentence.split(\\' \\')\\n        index=0\\n        for word in words:\\n            index+=1\\n            if word.find(searchWord)==0:\\n                return index        \\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 1046460,
                "title": "java-clean-and-simple-solution",
                "content": "```\\nclass Solution {\\n    public int isPrefixOfWord(String s, String sw) {\\n        String arr[]=s.split(\" \");\\n        for(int i=0;i<arr.length;i++){\\n            String x=arr[i];\\n            String temp=\"\";\\n            for(int j=0;j<sw.length();j++){\\n                if(j<x.length()){\\n                if(sw.charAt(j)==x.charAt(j)){\\n                 temp=temp+sw.charAt(j);   \\n                }\\n                }\\n            }\\n            if(temp.equals(sw)){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int isPrefixOfWord(String s, String sw) {\\n        String arr[]=s.split(\" \");\\n        for(int i=0;i<arr.length;i++){\\n            String x=arr[i];\\n            String temp=\"\";\\n            for(int j=0;j<sw.length();j++){\\n                if(j<x.length()){\\n                if(sw.charAt(j)==x.charAt(j)){\\n                 temp=temp+sw.charAt(j);   \\n                }\\n                }\\n            }\\n            if(temp.equals(sw)){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011192,
                "title": "java-simple-soultion",
                "content": "public int isPrefixOfWord(String sentence, String searchWord) {\\n    \\n     String[] strs = sentence.split(\" \");\\n      \\n     for(int i = 0; i < strs.length; i++){\\n       String str = strs[i];\\n         if(str.startsWith(searchWord))\\n          return i+1;\\n      }\\n      return -1;\\n    }",
                "solutionTags": [],
                "code": "public int isPrefixOfWord(String sentence, String searchWord) {\\n    \\n     String[] strs = sentence.split(\" \");\\n      \\n     for(int i = 0; i < strs.length; i++){\\n       String str = strs[i];\\n         if(str.startsWith(searchWord))\\n          return i+1;\\n      }\\n      return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1010570,
                "title": "python-simple-solution",
                "content": "```\\ndef isprefix(word,searchWord):\\n    if word[:len(searchWord)]==searchWord:\\n        return True\\n    else:\\n        return False\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        sentence_list=sentence.split(\\' \\')\\n        prefix_exists=-1\\n        for i,word in enumerate(sentence_list):\\n            if isprefix(word,searchWord):\\n                return i+1\\n        return prefix_exists\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef isprefix(word,searchWord):\\n    if word[:len(searchWord)]==searchWord:\\n        return True\\n    else:\\n        return False\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        sentence_list=sentence.split(\\' \\')\\n        prefix_exists=-1\\n        for i,word in enumerate(sentence_list):\\n            if isprefix(word,searchWord):\\n                return i+1\\n        return prefix_exists\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979355,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        \\n        sentence = sentence.split()\\n        \\n        for word in sentence:\\n            \\n            if searchWord == word[0:len(searchWord)]:\\n                \\n                return sentence.index(word)+1\\n        \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        \\n        sentence = sentence.split()\\n        \\n        for word in sentence:\\n            \\n            if searchWord == word[0:len(searchWord)]:\\n                \\n                return sentence.index(word)+1\\n        \\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 952032,
                "title": "c-simple-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        stringstream s(sentence);\\n        string word;\\n        int count = 1;\\n        while(s >> word){\\n            if (word.substr(0,searchWord.size()) == searchWord){\\n                return count;\\n            }\\n            count+= 1;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        stringstream s(sentence);\\n        string word;\\n        int count = 1;\\n        while(s >> word){\\n            if (word.substr(0,searchWord.size()) == searchWord){\\n                return count;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 944789,
                "title": "no-split-no-list-no-builtin-function-o-n-time-o-1-space-interview-answer",
                "content": "```python\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        i, count = 0, 1\\n        while i < len(sentence):\\n            #if fist letter of the word is not match \\n            if sentence[i] != searchWord[0]:\\n                \\n                #loop until there is a white space and increase index\\n                while  i<len(sentence) and sentence[i] != \" \":\\n                    i += 1\\n                count += 1  #count white space, (index of the word)\\n                \\n            #if first letter match\\n            if  i<len(sentence) and sentence[i] == searchWord[0]:\\n                \\n                #compare the rest of the searchWord\\n                if sentence[i+1:i+1+len(searchWord)-1] == searchWord[1:]:\\n                    return count #index of the word\\n            i += 1\\n        else:\\n            return -1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        i, count = 0, 1\\n        while i < len(sentence):\\n            #if fist letter of the word is not match \\n            if sentence[i] != searchWord[0]:\\n                \\n                #loop until there is a white space and increase index\\n                while  i<len(sentence) and sentence[i] != \" \":\\n                    i += 1\\n                count += 1  #count white space, (index of the word)\\n                \\n            #if first letter match\\n            if  i<len(sentence) and sentence[i] == searchWord[0]:\\n                \\n                #compare the rest of the searchWord\\n                if sentence[i+1:i+1+len(searchWord)-1] == searchWord[1:]:\\n                    return count #index of the word\\n            i += 1\\n        else:\\n            return -1",
                "codeTag": "Java"
            },
            {
                "id": 932213,
                "title": "javascript",
                "content": "```\\nlet isPrefixOfWord = (sentence, searchWord) => {\\n    let el = sentence\\n        .split(\" \")\\n        .map((w, i) => [w, i])\\n        .find(a => a[0].startsWith(searchWord));\\n    \\n    return el ? el[1] + 1 : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet isPrefixOfWord = (sentence, searchWord) => {\\n    let el = sentence\\n        .split(\" \")\\n        .map((w, i) => [w, i])\\n        .find(a => a[0].startsWith(searchWord));\\n    \\n    return el ? el[1] + 1 : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906118,
                "title": "easy-python-solution-using-startswith-method",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        for i in sentence.split():\\n            if i.startswith(searchWord):\\n                return sentence.split().index(i) + 1\\n        return -1\\n```\\nFor more such questions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        for i in sentence.split():\\n            if i.startswith(searchWord):\\n                return sentence.split().index(i) + 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902012,
                "title": "simple-java-with-comments-beats-100-solutions",
                "content": "```\\npublic int isPrefixOfWord(String sentence, String searchWord) {\\n\\t// split the string into array of words\\n        String[] wordArray = sentence.split(\" \");\\n        int searchWordLength = searchWord.length();\\n        for (int i = 0; i < wordArray.length; i++) {\\n\\t\\t// check if the length of the word is >= length of search word and \\n\\t\\t// the first char matches with search word(helps in optimization)\\n            if (wordArray[i].length() >= searchWordLength &&\\n                    wordArray[i].charAt(0) == searchWord.charAt(0)) {\\n\\t\\t\\t\\t\\t// check if it is a prefix\\n                if (wordArray[i].substring(0, searchWordLength).equals(searchWord)) {\\n                    return i + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int isPrefixOfWord(String sentence, String searchWord) {\\n\\t// split the string into array of words\\n        String[] wordArray = sentence.split(\" \");\\n        int searchWordLength = searchWord.length();\\n        for (int i = 0; i < wordArray.length; i++) {\\n\\t\\t// check if the length of the word is >= length of search word and \\n\\t\\t// the first char matches with search word(helps in optimization)\\n            if (wordArray[i].length() >= searchWordLength &&\\n                    wordArray[i].charAt(0) == searchWord.charAt(0)) {\\n\\t\\t\\t\\t\\t// check if it is a prefix\\n                if (wordArray[i].substring(0, searchWordLength).equals(searchWord)) {\\n                    return i + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 883308,
                "title": "100-faster-than-other-c-solutions",
                "content": "int isPrefixOfWord(string sentence, string searchWord) {\\n        int count=1,flag=0;\\n        for(int i=0,j=0;i<sentence.length()&&j<searchWord.length();i++)\\n        {\\n            if(sentence[i]==searchWord[j]&&j==0)\\n            {\\n                if(i==0)\\n                {\\n                    if(j==searchWord.length()-1)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                else\\n                {\\n                    if(sentence[i-1]==\\' \\')\\n                    {\\n                        if(j==searchWord.length()-1)\\n                        {\\n                            flag=1;\\n                            break;\\n                        }\\n                        j++;\\n                    }\\n                }\\n            }\\n            else if(sentence[i]==searchWord[j]&&j!=0)\\n            {\\n                if(j==searchWord.length()-1)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n                j++;\\n            }\\n            else if(sentence[i]!=searchWord[j]&&j!=0&&sentence[i]!=\\' \\')\\n                j=0;\\n            else if(sentence[i]==\\' \\'&&j!=0)\\n            {\\n                count++;\\n                j=0;\\n            }\\n            else if(sentence[i]==\\' \\')\\n                count++;\\n        }\\n        if(flag==0)\\n            return -1;\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "int isPrefixOfWord(string sentence, string searchWord) {\\n        int count=1,flag=0;\\n        for(int i=0,j=0;i<sentence.length()&&j<searchWord.length();i++)\\n        {\\n            if(sentence[i]==searchWord[j]&&j==0)\\n            {\\n                if(i==0)\\n                {\\n                    if(j==searchWord.length()-1)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                else\\n                {\\n                    if(sentence[i-1]==\\' \\')\\n                    {\\n                        if(j==searchWord.length()-1)\\n                        {\\n                            flag=1;\\n                            break;\\n                        }\\n                        j++;\\n                    }\\n                }\\n            }\\n            else if(sentence[i]==searchWord[j]&&j!=0)\\n            {\\n                if(j==searchWord.length()-1)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n                j++;\\n            }\\n            else if(sentence[i]!=searchWord[j]&&j!=0&&sentence[i]!=\\' \\')\\n                j=0;\\n            else if(sentence[i]==\\' \\'&&j!=0)\\n            {\\n                count++;\\n                j=0;\\n            }\\n            else if(sentence[i]==\\' \\')\\n                count++;\\n        }\\n        if(flag==0)\\n            return -1;\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 838421,
                "title": "java-simple-solution-100-faster",
                "content": "```\\n public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for(int i=0; i<words.length; i++){\\n            if(words[i].length() < searchWord.length()) continue;\\n            if(words[i].substring(0,searchWord.length()).equals(searchWord)) return i+1;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for(int i=0; i<words.length; i++){\\n            if(words[i].length() < searchWord.length()) continue;\\n            if(words[i].substring(0,searchWord.length()).equals(searchWord)) return i+1;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 824454,
                "title": "c-solution-with-runtime-0-ms",
                "content": "```\\nint isPrefixOfWord(char * sentence, char * searchWord){\\n    \\n    /* Extract each word from sentence and check if search Word is the prefix or not*/\\n    char *s;\\n    int idx = 0;\\n    \\n    s = strtok(sentence, \" \");\\n    \\n    while(s != NULL){\\n        idx++;\\n        if (strstr(s, searchWord) == s) return idx;\\n        s = strtok(NULL, \" \");\\n    }\\n\\n    return -1;\\n}",
                "solutionTags": [],
                "code": "```\\nint isPrefixOfWord(char * sentence, char * searchWord){\\n    \\n    /* Extract each word from sentence and check if search Word is the prefix or not*/\\n    char *s;\\n    int idx = 0;\\n    \\n    s = strtok(sentence, \" \");\\n    \\n    while(s != NULL){\\n        idx++;\\n        if (strstr(s, searchWord) == s) return idx;\\n        s = strtok(NULL, \" \");\\n    }\\n\\n    return -1;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 820763,
                "title": "another-boring-python-solution",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        \\n        for i, w in enumerate(sentence.split()):\\n            if w.startswith(searchWord):\\n                return i + 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        \\n        for i, w in enumerate(sentence.split()):\\n            if w.startswith(searchWord):\\n                return i + 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796458,
                "title": "javascript-easy-to-understand-using-regular-expression-for-fun",
                "content": "```\\nvar isPrefixOfWord = function(sentence, searchWord) {\\n    let regex = new RegExp(\"^\" + searchWord,\"gi\")\\n    let res = sentence.split(\\' \\').findIndex(word => regex.test(word))\\n    return res===-1?-1: res+1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPrefixOfWord = function(sentence, searchWord) {\\n    let regex = new RegExp(\"^\" + searchWord,\"gi\")\\n    let res = sentence.split(\\' \\').findIndex(word => regex.test(word))\\n    return res===-1?-1: res+1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747318,
                "title": "swift-1-line-solution",
                "content": "```\\nclass Solution {\\n    func isPrefixOfWord(_ sentence: String, _ searchWord: String) -> Int {\\n        return (sentence.split(separator: \" \").firstIndex { $0.hasPrefix(searchWord) } ?? -2) + 1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func isPrefixOfWord(_ sentence: String, _ searchWord: String) -> Int {\\n        return (sentence.split(separator: \" \").firstIndex { $0.hasPrefix(searchWord) } ?? -2) + 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719663,
                "title": "very-simple-solution-with-indexof",
                "content": "\\n\\tpublic int isPrefixOfWord(String sentence, String searchWord) {\\n        int searchIndex = -1;\\n        String[] sentences = sentence.split(\" \");\\n        \\n        for (int i = 0; i < sentences.length; i++) {\\n            if (sentences[i].indexOf(searchWord) == 0) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return searchIndex;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\tpublic int isPrefixOfWord(String sentence, String searchWord) {\\n        int searchIndex = -1;\\n        String[] sentences = sentence.split(\" \");\\n        \\n        for (int i = 0; i < sentences.length; i++) {\\n            if (sentences[i].indexOf(searchWord) == 0) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return searchIndex;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 694462,
                "title": "c-istringstream-easy-understanding",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        \\n        string word = \"\";\\n        istringstream ss(sentence);\\n        int index = 1;\\n        \\n        while(ss >> word)\\n        {\\n            if(word.length() < searchWord.length())\\n            {\\n                index++;\\n                continue;\\n            }\\n            \\n            if(word.substr(0, searchWord.length()) == searchWord)\\n            {\\n                return index;\\n            }\\n            \\n            index++;\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int isPrefixOfWord(string sentence, string searchWord) {\\n        \\n        string word = \"\";\\n        istringstream ss(sentence);\\n        int index = 1;\\n        \\n        while(ss >> word)\\n        {\\n            if(word.length() < searchWord.length())\\n            {\\n                index++;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 685770,
                "title": "python-one-liner-just-for-fun",
                "content": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        return min([i + 1 for i, v in enumerate(sentence.split()) if re.match(searchWord, v)]) if [i + 1 for i, v in enumerate(sentence.split()) if re.match(searchWord, v)] else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        return min([i + 1 for i, v in enumerate(sentence.split()) if re.match(searchWord, v)]) if [i + 1 for i, v in enumerate(sentence.split()) if re.match(searchWord, v)] else -1\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1707649,
                "content": [
                    {
                        "username": "arrowmaster1252",
                        "content": "I am offended that it is 1-indexed"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var isPrefixOfWord = function(sentence, searchWord) {\\n    const words = sentence.split(\" \");\\n   return  words.indexOf(words.find(word=>word.indexOf(searchWord)===0))+1 || -1\\n};"
                    },
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-1455-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence-b1736d42e23c"
                    },
                    {
                        "username": "lovell3232",
                        "content": "Wrong Answer\\n34 / 40 testcases passed\\nEditorial\\n\\nInput\\nsentence =\\n\"hellohello hellohellohello\"\\n\\nsearchWord =\\n\"ell\"\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n-1\\n\\n\\nSo, \\'ell\\' is exists in two words, but the expected output is -1"
                    },
                    {
                        "username": "lovell3232",
                        "content": "broken testcase"
                    }
                ]
            },
            {
                "id": 1575127,
                "content": [
                    {
                        "username": "arrowmaster1252",
                        "content": "I am offended that it is 1-indexed"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var isPrefixOfWord = function(sentence, searchWord) {\\n    const words = sentence.split(\" \");\\n   return  words.indexOf(words.find(word=>word.indexOf(searchWord)===0))+1 || -1\\n};"
                    },
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-1455-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence-b1736d42e23c"
                    },
                    {
                        "username": "lovell3232",
                        "content": "Wrong Answer\\n34 / 40 testcases passed\\nEditorial\\n\\nInput\\nsentence =\\n\"hellohello hellohellohello\"\\n\\nsearchWord =\\n\"ell\"\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n-1\\n\\n\\nSo, \\'ell\\' is exists in two words, but the expected output is -1"
                    },
                    {
                        "username": "lovell3232",
                        "content": "broken testcase"
                    }
                ]
            },
            {
                "id": 1573837,
                "content": [
                    {
                        "username": "arrowmaster1252",
                        "content": "I am offended that it is 1-indexed"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var isPrefixOfWord = function(sentence, searchWord) {\\n    const words = sentence.split(\" \");\\n   return  words.indexOf(words.find(word=>word.indexOf(searchWord)===0))+1 || -1\\n};"
                    },
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-1455-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence-b1736d42e23c"
                    },
                    {
                        "username": "lovell3232",
                        "content": "Wrong Answer\\n34 / 40 testcases passed\\nEditorial\\n\\nInput\\nsentence =\\n\"hellohello hellohellohello\"\\n\\nsearchWord =\\n\"ell\"\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n-1\\n\\n\\nSo, \\'ell\\' is exists in two words, but the expected output is -1"
                    },
                    {
                        "username": "lovell3232",
                        "content": "broken testcase"
                    }
                ]
            },
            {
                "id": 2071694,
                "content": [
                    {
                        "username": "arrowmaster1252",
                        "content": "I am offended that it is 1-indexed"
                    },
                    {
                        "username": "masha-nv",
                        "content": "var isPrefixOfWord = function(sentence, searchWord) {\\n    const words = sentence.split(\" \");\\n   return  words.indexOf(words.find(word=>word.indexOf(searchWord)===0))+1 || -1\\n};"
                    },
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-1455-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence-b1736d42e23c"
                    },
                    {
                        "username": "lovell3232",
                        "content": "Wrong Answer\\n34 / 40 testcases passed\\nEditorial\\n\\nInput\\nsentence =\\n\"hellohello hellohellohello\"\\n\\nsearchWord =\\n\"ell\"\\n\\nUse Testcase\\nOutput\\n1\\nExpected\\n-1\\n\\n\\nSo, \\'ell\\' is exists in two words, but the expected output is -1"
                    },
                    {
                        "username": "lovell3232",
                        "content": "broken testcase"
                    }
                ]
            }
        ]
    }
]