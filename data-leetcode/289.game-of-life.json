[
    {
        "title": "Gray Code",
        "question_content": "An n-bit gray code sequence is a sequence of 2n integers where:\n\n\tEvery integer is in the inclusive range [0, 2n - 1],\n\tThe first integer is 0,\n\tAn integer appears no more than once in the sequence,\n\tThe binary representation of every pair of adjacent integers differs by exactly one bit, and\n\tThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.\n&nbsp;\nExample 1:\n\nInput: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit\n\nExample 2:\n\nInput: n = 1\nOutput: [0,1]\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 16",
        "solutions": [
            {
                "id": 29891,
                "title": "share-my-solution",
                "content": "My idea is to generate the sequence iteratively. For example, when n=3, we can get the result based on n=2. \\n00,01,11,10 -> (000,001,011,010 ) (110,111,101,100). The middle two numbers only differ at their highest bit, while the rest numbers of part two are exactly symmetric of part one. It is easy to see its correctness.\\nCode is simple:\\n\\n----------\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> rs=new ArrayList<Integer>();\\n        rs.add(0);\\n        for(int i=0;i<n;i++){\\n            int size=rs.size();\\n            for(int k=size-1;k>=0;k--)\\n                rs.add(rs.get(k) | 1<<i);\\n        }\\n        return rs;\\n    }",
                "solutionTags": [],
                "code": "My idea is to generate the sequence iteratively. For example, when n=3, we can get the result based on n=2. \\n00,01,11,10 -> (000,001,011,010 ) (110,111,101,100). The middle two numbers only differ at their highest bit, while the rest numbers of part two are exactly symmetric of part one. It is easy to see its correctness.\\nCode is simple:\\n\\n----------\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> rs=new ArrayList<Integer>();\\n        rs.add(0);\\n        for(int i=0;i<n;i++){\\n            int size=rs.size();\\n            for(int k=size-1;k>=0;k--)\\n                rs.add(rs.get(k) | 1<<i);\\n        }\\n        return rs;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29881,
                "title": "an-accepted-three-line-solution-in-java",
                "content": "    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new LinkedList<>();\\n        for (int i = 0; i < 1<<n; i++) result.add(i ^ i>>1);\\n        return result;\\n    }\\n\\nThe idea is simple. G(i) = i^ (i/2).",
                "solutionTags": [],
                "code": "    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new LinkedList<>();\\n        for (int i = 0; i < 1<<n; i++) result.add(i ^ i>>1);\\n        return result;\\n    }\\n\\nThe idea is simple. G(i) = i^ (i/2).",
                "codeTag": "Unknown"
            },
            {
                "id": 29893,
                "title": "one-liner-python-solution-with-demo-in-comments",
                "content": "All you need is a bit of careful thought.\\n\\nBtw, it's extremely useful to write down your thought/demo in comments before you actually start to write the code, especially during interview. \\n\\nEven if you do not solve the problem finally, the interviewer at least get to know what you're thinking. \\n\\nAnd if you don't get the problem right, he/she will have a chance to correct you.\\n\\n    class Solution:\\n        # @return a list of integers\\n        '''\\n        from up to down, then left to right\\n        \\n        0   1   11  110\\n                10  111\\n                    101\\n                    100\\n                    \\n        start:      [0]\\n        i = 0:      [0, 1]\\n        i = 1:      [0, 1, 3, 2]\\n        i = 2:      [0, 1, 3, 2, 6, 7, 5, 4]\\n        '''\\n        def grayCode(self, n):\\n            results = [0]\\n            for i in range(n):\\n                results += [x + pow(2, i) for x in reversed(results)]\\n            return results",
                "solutionTags": [],
                "code": "All you need is a bit of careful thought.\\n\\nBtw, it's extremely useful to write down your thought/demo in comments before you actually start to write the code, especially during interview. \\n\\nEven if you do not solve the problem finally, the interviewer at least get to know what you're thinking. \\n\\nAnd if you don't get the problem right, he/she will have a chance to correct you.\\n\\n    class Solution:\\n        # @return a list of integers\\n        '''\\n        from up to down, then left to right\\n        \\n        0   1   11  110\\n                10  111\\n                    101\\n                    100\\n                    \\n        start:      [0]\\n        i = 0:      [0, 1]\\n        i = 1:      [0, 1, 3, 2]\\n        i = 2:      [0, 1, 3, 2, 6, 7, 5, 4]\\n        '''\\n        def grayCode(self, n):\\n            results = [0]\\n            for i in range(n):\\n                results += [x + pow(2, i) for x in reversed(results)]\\n            return results",
                "codeTag": "Java"
            },
            {
                "id": 29880,
                "title": "backtracking-c-solution",
                "content": "    class Solution {\\n        void utils(bitset<32>& bits, vector<int>& result, int k){\\n            if (k==0) {\\n                result.push_back(bits.to_ulong());\\n            }\\n            else {\\n                utils(bits, result, k-1);\\n                bits.flip(k-1);\\n                utils(bits, result, k-1);\\n            }\\n        }\\n    public:\\n        vector<int> grayCode(int n) {\\n            bitset<32> bits;\\n            vector<int> result;\\n            utils(bits, result, n);\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        void utils(bitset<32>& bits, vector<int>& result, int k){\\n            if (k==0) {\\n                result.push_back(bits.to_ulong());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30028,
                "title": "4-lines-c-code",
                "content": "You can also view more solution on [Github](https://github.com/flexwang/CodeTest)\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> ans(1<<n);\\n            for (int i=0; i<(1<<n); i++) \\n                ans[i] = i^(i>>1);\\n            return ans;\\n        }\\n    };\\n\\nI try to give a simple proof here. Let's denote i^(i>>1) as f(i). To proof f(i) is the ith gray code, we only need to prove the following statements:\\n\\n 1. f(0) = 0\\n 2. (i) and f(i+1) only differs in one digit\\n 3. f(i) is bijective, e.g. f(i) = f(j) if and only if i = j.\\n\\nThe first one is obvious. \\n\\nFor the second , f(i) ^ f(i+1) = i^(i>>1)^(i+1)^((i+1)>>1) = (i^(i+1)) ^ ((i^(i+1)) >> 1). Let's denote g(i) = i^(i+1), g(i) has the form of 0000111...111. So f(i) ^ f(i+1) = g(i) ^ g(i)>>1 = 00001000...000.\\n\\nThe third part can be proved alike.",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> ans(1<<n);\\n            for (int i=0; i<(1<<n); i++) \\n                ans[i] = i^(i>>1);\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 29884,
                "title": "what-is-the-best-solution-for-gray-code-problem-no-extra-space-used-and-no-recursion",
                "content": "  I have a solution here which takes O(1) on space and no recursion used. Is this the best possible solution?  (I combined the base cases in the loop as mike3 does. Thanks mike3!)\\n\\n    vector<int> grayCode(int n) \\n    {         \\n        vector<int> result(1, 0);        \\n        for (int i = 0; i < n; i++) {\\n            int curCount = result.size();\\n            // push back all element in result in reverse order\\n            while (curCount) {\\n                curCount--;\\n                int curNum = result[curCount];\\n                curNum += (1<<i);\\n                result.push_back(curNum);\\n            } \\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "  I have a solution here which takes O(1) on space and no recursion used. Is this the best possible solution?  (I combined the base cases in the loop as mike3 does. Thanks mike3!)\\n\\n    vector<int> grayCode(int n) \\n    {         \\n        vector<int> result(1, 0);        \\n        for (int i = 0; i < n; i++) {\\n            int curCount = result.size();\\n            // push back all element in result in reverse order\\n            while (curCount) {\\n                curCount--;\\n                int curNum = result[curCount];\\n                curNum += (1<<i);\\n                result.push_back(curNum);\\n            } \\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1308570,
                "title": "python-short-recursive-solution-explained",
                "content": "The idea is to use recursion, if we have gray code for `n-1`, than we can construct gray code for `n` easily. Imagine, that `n = 4` and we have code `[0,1,3,2,6,7,5,4]`. Then we need to add numbers in `[8, 15]`. Let us add `8` to each number, so we have `[8, 9, 11, 10, 14, 15, 13, 12]` which is also code with property that every two adjacent number differ by one bit. All we need to do is to concatenate these two lists, but first we need to invert one of them to get `[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]`.\\n\\n#### Complexity\\nTime complexity is `O(2^n)`, space as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def grayCode(self, n):\\n        if n == 0: return [0]\\n        t = self.grayCode(n-1)\\n        return t + [i+(1<<(n-1)) for i in t][::-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def grayCode(self, n):\\n        if n == 0: return [0]\\n        t = self.grayCode(n-1)\\n        return t + [i+(1<<(n-1)) for i in t][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245076,
                "title": "4-lines-elegant-fast-and-easy-understand-python-solution",
                "content": "Fisrt, we can explore the data and try to figure out the pattern. \\nFor example, when n=3, **results** start from 000, we can **XOR** last number in results with **X** .\\n`result[i+1] = X[i] ^ result[i]`\\nBelow we can figure out the pattern of **X**:\\n```\\nresult          X                  Y\\n0 0 0         0 0 1           0 0 1 (1)\\n0 0 1         0 1 0           0 1 0 (2)\\n0 1 1         0 0 1           0 1 1 (3)\\n0 1 0         1 0 0           1 0 0 (4)\\n1 1 0         0 0 1           1 0 1 (5)\\n1 1 1         0 1 0           1 1 0 (6)\\n1 0 1         0 0 1           1 1 1 (7)\\n1 0 0\\n```\\nSo the keypoint is to generate **X** sequence. Here is the trick, actually **X** is **lowest one-bit** of **Y** (natural number set).\\nAccording to bit-manipulation, we can get lowest one-bit of number by\\n`X = Y & -Y`\\nFinally, we can get this elegant and easy-understand solution:\\n```\\ndef grayCode(self, n: int) -> \\'List[int]\\':\\n\\tres = [0]\\n\\tfor i in range(1, 2**n):\\n\\t\\tres.append(res[-1] ^ (i & -i))\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nresult          X                  Y\\n0 0 0         0 0 1           0 0 1 (1)\\n0 0 1         0 1 0           0 1 0 (2)\\n0 1 1         0 0 1           0 1 1 (3)\\n0 1 0         1 0 0           1 0 0 (4)\\n1 1 0         0 0 1           1 0 1 (5)\\n1 1 1         0 1 0           1 1 0 (6)\\n1 0 1         0 0 1           1 1 1 (7)\\n1 0 0\\n```\n```\\ndef grayCode(self, n: int) -> \\'List[int]\\':\\n\\tres = [0]\\n\\tfor i in range(1, 2**n):\\n\\t\\tres.append(res[-1] ^ (i & -i))\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1308562,
                "title": "gray-code-c-python-iterative-solution-explained",
                "content": "The main idea is to use previously calculated values\\nLook the examples in bit representation =>>\\nn=0  =>   [0]\\nn=1  =>  [0, 1] \\nn=2 => [00, 01, 11, 10]   => [00, 01] + [11, 01]  => ( 0 + [result(n-1)] ) +  ( 1 + [result(n-1)] )\\nn=3 => [000, 001, 011, 010, 110, 111, 101, 100] => ( 0 + [result(n-1) ) + ( 1+ [result(n-1)] )\\nso on ...\\nNow we can implement the above pattern easily\\nWe can make it more simple, if we observe that, Every time we just twiced the values in the prev result ans new values are just made on the folling pattern =>\\nn=0 =>  [0000]\\nn=1 => [0000, 0001]  // observe the we had just set (n-1)th bit to 1, iterating from right in the prev result ;\\nn=2 => [0000, 0001, 0011, 0010]\\nn=3 => [0000, 0001, 0011, 0010, 0110, 0111, 0101, 0100]\\nso on ...\\nmask containes (n-1)th bit as 1,   \\nif result for n=2, 0001 =>  **mask = 0010** hence newRes = (**res | mask**) = 0011; \\nHope it helped you to understand the logic.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> result;\\n        result.push_back(0);\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int prevLength = result.size();\\n            int mask = 1 << (i - 1);\\n            for (int j = prevLength - 1; j >= 0; j--) {\\n                result.push_back(mask + result[j]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Python =>**\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        arr = []\\n        arr.append(0)\\n        for i in range(1,n+1):\\n            prevLength = len(arr)\\n            mask = 1 << (i-1)\\n            for j in range(prevLength, 0, -1):\\n                arr.append(mask + arr[j-1])\\n        return arr\\n```\\n**If you find it helpful, plz upvote**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> result;\\n        result.push_back(0);\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int prevLength = result.size();\\n            int mask = 1 << (i - 1);\\n            for (int j = prevLength - 1; j >= 0; j--) {\\n                result.push_back(mask + result[j]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        arr = []\\n        arr.append(0)\\n        for i in range(1,n+1):\\n            prevLength = len(arr)\\n            mask = 1 << (i-1)\\n            for j in range(prevLength, 0, -1):\\n                arr.append(mask + arr[j-1])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30045,
                "title": "share-my-simple-way-of-this-problem",
                "content": "    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int N(1 << n), tmp;\\n            vector<int> result;\\n            for(int i(0); i < N; i++)\\n            {\\n                tmp = i << 1;\\n                result.push_back((tmp^i) >> 1);\\n            }\\n            return result;\\n        }\\n    };\\n\\nAs we known:\\n\\n    Gi = Bi+1 xor Bi\\n\\nFor example, trans binay '001' to gray code:\\n\\n    tmp = 001 << 1\\n\\nthen,\\n\\n    bin 0 0 0 1\\n    tmp 0 0 1 0\\n    -xor------------\\n        0 0 1 1\\nand the gray code is:\\n\\n    0 0 1 1 >> 1 (ignore last bit) => 0 0 1",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int N(1 << n), tmp;\\n            vector<int> result;\\n            for(int i(0); i < N; i++)\\n            {\\n                tmp = i << 1;\\n                result.push_back((tmp^i) >> 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3440293,
                "title": "easy-to-understand-concise-c",
                "content": "`Idea`:\\nGray code for a number n is n^(n/2), and we push the same for every number in range [0, pow(2,x)).\\n\\n`Explanation`\\nFor the explanation part, we copy the MSB from binary as it is in the code and xor the remaining bits i.e. g[i] = b[i] ^ b[i-1].\\n\\n`Lets take 13`: 1101\\n`Gray code will b`e:\\n1 + 1^1 + 0^1 + 1^0\\n\\nIf you see carefully, the xored number is actually \\'0110\\' which is equal to n/2.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int p=(1<<n);\\n        for(int i=0; i<p; i++){\\n            v.push_back(i^(i/2));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int p=(1<<n);\\n        for(int i=0; i<p; i++){\\n            v.push_back(i^(i/2));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30007,
                "title": "python-easy-bit-manipulation-solution",
                "content": "For n=1: 0 1\\n\\nFor n=2: 00 01 11 10\\n\\nNotice that the second half (11 and 10) are mirror of the first half (0 1) with additional 1 before it (10 11).\\nNow we have (00 01 11 10), in order to do n=3 we need to do the same. The 4 elements of n=2 will be our first half, to do the second half we mirror them to get (10 11 01 00) and add additional 1 before it (110 111 101 100). We get:\\n\\nFor n=3: 000 001 011 010 110 111 101 100\\n\\n\\n    def grayCode(n):\\n        if not n:\\n            return [0]\\n        res = [0,1]\\n        for i in range(2,n+1):\\n            for j in range(len(res)-1,-1,-1):\\n                res.append(res[j] | 1<<i-1)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "For n=1: 0 1\\n\\nFor n=2: 00 01 11 10\\n\\nNotice that the second half (11 and 10) are mirror of the first half (0 1) with additional 1 before it (10 11).\\nNow we have (00 01 11 10), in order to do n=3 we need to do the same. The 4 elements of n=2 will be our first half, to do the second half we mirror them to get (10 11 01 00) and add additional 1 before it (110 111 101 100). We get:\\n\\nFor n=3: 000 001 011 010 110 111 101 100\\n\\n\\n    def grayCode(n):\\n        if not n:\\n            return [0]\\n        res = [0,1]\\n        for i in range(2,n+1):\\n            for j in range(len(res)-1,-1,-1):\\n                res.append(res[j] | 1<<i-1)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 29953,
                "title": "java-easy-version-to-understand",
                "content": "    public static List<Integer> grayCode(int n) {\\n\\t\\tif (n < 0)\\n\\t\\t\\treturn new ArrayList<Integer>();\\n\\t\\tif (n == 0) {\\n\\t\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\t\\tlist.add(0);\\n\\t\\t\\treturn list;\\n\\t\\t}\\n\\t\\tList<Integer> tmp = grayCode(n - 1);\\n\\t\\tList<Integer> result = new ArrayList<Integer>(tmp);\\n\\t\\tint addNumber = 1 << (n - 1);\\n\\t\\tfor (int i = tmp.size() - 1; i >= 0; i--) {\\n\\t\\t\\tresult.add(addNumber + tmp.get(i));\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    public static List<Integer> grayCode(int n) {\\n\\t\\tif (n < 0)\\n\\t\\t\\treturn new ArrayList<Integer>();\\n\\t\\tif (n == 0) {\\n\\t\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\t\\tlist.add(0);\\n\\t\\t\\treturn list;\\n\\t\\t}\\n\\t\\tList<Integer> tmp = grayCode(n - 1);\\n\\t\\tList<Integer> result = new ArrayList<Integer>(tmp);\\n\\t\\tint addNumber = 1 << (n - 1);\\n\\t\\tfor (int i = tmp.size() - 1; i >= 0; i--) {\\n\\t\\t\\tresult.add(addNumber + tmp.get(i));\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 30084,
                "title": "4ms-simple-iterative-solution",
                "content": "    vector<int> grayCode(int n) {\\n        vector<int> result = { 0 };\\n        int t = 1;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = result.size() - 1; j >= 0; j--)\\n                result.push_back(result[j]^t);\\n            t <<= 1;\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> grayCode(int n) {\\n        vector<int> result = { 0 };\\n        int t = 1;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = result.size() - 1; j >= 0; j--)\\n                result.push_back(result[j]^t);\\n            t <<= 1;\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30092,
                "title": "one-line-python-solution-with-comments",
                "content": "These characteristics suggest a simple and fast method of translating a binary value into the corresponding Gray code. Each bit is inverted if the next higher bit of the input value is set to one. This can be performed in parallel by a bit-shift and exclusive-or operation if they are available: g(b) = x(b) XOR x(b+1)\\n\\n    class Solution:\\n    # @param {integer} n\\n    # @return {integer[]}\\n    def grayCode(self, n):\\n        return [(i>>1)^i for i in xrange(2**n)]",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 1308685,
                "title": "c-python-easy-to-understand-100-fast",
                "content": "**Idea:** \\nGray code for a number **```n```** is **```n^(n/2)```**, and we push the same for every number in range ```[0, pow(2,x))```.\\n\\n**Explanation**\\nFor the explanation part, we copy the MSB from binary as it is in the code and xor the remaining bits **i.e. ```g[i] = b[i] ^ b[i-1]```.**\\n\\nLets take 13: 1101\\nGray code will be:\\n```1 + 1^1 + 0^1 + 1^0```\\nIf you see carefully, the xored number is actually \\'0110\\' which is equal to n/2.\\n\\n**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int p=(1<<n);\\n        for(int i=0; i<p; i++){\\n            v.push_back(i^(i/2));\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n**Python Solution**\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i^(i//2) for i in range(1<<n)]\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```n```\n```n^(n/2)```\n```[0, pow(2,x))```\n```g[i] = b[i] ^ b[i-1]```\n```1 + 1^1 + 0^1 + 1^0```\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int p=(1<<n);\\n        for(int i=0; i<p; i++){\\n            v.push_back(i^(i/2));\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i^(i//2) for i in range(1<<n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400651,
                "title": "java-solutions-with-detailed-comments-and-explanations-backtracking-prepending",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/gray-code/) <span class=\"gray\">EPI 15.11</span>\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> The gray code is a binary numeral system where two successive values **differ in only one bit**.\\n\\nGiven a non-negative integer `n` representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with `0`.\\n\\n**Example:** \\n\\n```java\\nInput: 2\\nOutput: [0,1,3,2]\\nExplanation:\\n00 - 0\\n01 - 1\\n11 - 3\\n10 - 2\\n\\nFor a given n, a gray code sequence may not be uniquely defined.\\nFor example, [0,2,3,1] is also a valid gray code sequence.\\n\\n00 - 0\\n10 - 2\\n11 - 3\\n01 - 1\\n\\nInput: 0\\nOutput: [0]\\n\\nInput: 1\\nOutput: [0, 1]\\n```\\n\\n\\n## Analysis\\n\\n### Backtracking\\n\\nInstead of enumerating all possible permutations, which takes `O(2^{n * 2^n})`, we construct the gray code by a step-by-step approach.\\n\\nFirst, we design a function that checks if two numbers `n1` and `n2` differ only in one bit.\\n\\n- `n1 == n2`: `xor == 0`, returns false.\\n- Differ in more than one bit: `(xor & (xor - 1)) != 0`, returns false.\\n- Differ in one bit: `(xor & (xor - 1)) == 0`, returns true.\\n\\n**Note:** `num & (num - 1)` can remove the rightmost one-bit of `num`.\\n\\n```java\\nprivate boolean isValid(int n1, int n2) {\\n  int xor = n1 ^ n2;\\n  return xor != 0 && (xor & (xor - 1)) == 0;\\n}\\n```\\n\\nConsider we have a number `0110`. How many differ-in-one numbers can we have for `0110`? The answer is `[1110, 0010, 0100, 0111]`. We can write it out right away because we just need to do XOR operation for each bit. In other words, we XOR `0110` with `[1000, 0100, 0010, 0001]`.\\n\\nBased on this idea, we can take the latest generated number in the result list, and try out all differ-in-one possibilities. In order to know if the new candidate is qualified, we use a hash set to store all previously constructed numbers.\\n\\nIf the candidate is not in the hash set, we add it to the hash set and also append it to the result list. Then we construct the next number based on the number we\\'ve just added.\\n\\nAt last, when we have `2^n` numbers in the result list, we need to check if the first and the last elements are compatible via `isValid(n1, n2)`. If yes, everything is done; if no, backtrack and construct a new possible number, and try again.\\n\\n**Note:** `2^i` can be computed by `1 << i`.\\n\\n\\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  Set<Integer> history = new HashSet<>();\\n  generateGrayCode(n, history, result);\\n  return result;\\n}\\n\\nprivate boolean generateGrayCode(int n, Set<Integer> history, List<Integer> result) {\\n  // base case\\n  if (result.size() == (1 << n)) {\\n    // check the first element and the last element\\n    return isValid(result.get(0), result.get(result.size() - 1));\\n  }\\n  for (int i = 0; i < n; ++i) {\\n    int prevCode = result.get(result.size() - 1);\\n    int candCode = prevCode ^ (1 << i);\\n    if (!history.contains(candCode)) {\\n      history.add(candCode);\\n      result.add(candCode);\\n      boolean found = generateGrayCode(n, history, result);\\n      if (found) return true;\\n      history.remove(candCode);\\n      result.remove(result.size() - 1);\\n    }\\n  }\\n  return false;\\n}\\n```\\n\\n**Time:** `O(2^N)` <span class=\"purple\">I don\\'t know how to get it~</span>\\n**Space:** `O(2^N)`\\n\\n\\n\\n### Prepending 0 and 1\\n\\nThe idea is simple. Based on the `result` in `n = k`, we add $0$ before each element to get the first half; we add $1$ before each element of `result` and **reverse** the list to get the second half. Then concatenate them to get the result for `n = k + 1`. **See the example below to understand it!**.\\n\\nConsider how we generate gray codes from `n = 0` to `n = 3`.\\n\\n```java\\nn = 0, we have [0].\\n\\nn = 1, we previously have [0] and then construct [0, 1].\\n\\nJust add 1 (actually add 1, which is 1 << n = 1)\\n\\nn = 2, we previously have [0, 1] and construct [00, 01, 11, 10].\\n\\nBy adding 0 before each element, we get [00, 01] (actually do nothing in the code)\\nBy adding 1 before each element, we get [10, 11] (actually add 10, which is 1 << n = 10)\\nReverse [10, 11] to get [11, 10]\\nCombine [00, 01] and [11, 10], we have [00, 01, 11, 10].\\n\\nn = 3, we previously have [00, 01, 11, 10].\\n\\nAdd 0:   [000, 001, 011, 010]\\nAdd 1:   [110, 111, 101, 100] (reversed) (actually add 100, which is 1 << n = 1 << 3 = 100)\\nCombine: [000, 001, 011, 010, 110, 111, 101, 100]\\n```\\n\\n**Note:** Consider the corner cases when `n = 0` and `n = 1`, and then decide `i` should start from $0$.\\n\\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  for (int i = 0; i < n; ++i) {\\n    List<Integer> res1 = result;\\n    List<Integer> res2 = new ArrayList<>(res1);\\n    Collections.reverse(res2);\\n    // prepend \"1\"\\n    int prependVal = (1 << i);\\n    for (int j = 0; j < res2.size(); ++j) {\\n      res2.set(j, res2.get(j) + prependVal);\\n    }\\n    res1.addAll(res2);\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(2^N)`\\n- `n = 0` (`[0]`), prepending \"1\" takes `1` operation (**allocating extra space takes `1` operation and reversing takes $1$ operation, but they are proportional to number of prepending operations**).\\n- `n = 1` (`[0, 1]`), prepending \"1\" takes `2` operations.\\n- `n = 2` (`[00, 01, 11, 10]`), prepending \"1\" takes `4` operations.\\n- `n = 3` (`[000, 001, 011, 010, 110, 111, 101, 100]`), prepending \"1\" takes `8` operations.\\n- `n = k`, prepending \"1\" takes `2^k` operations.\\n- In total, `T(N) = 1 + 2 + 4 + 8 + ... + 2^N = 2^N`.\\n\\n**Space:** `O(2^N)`\\n\\n**Without allocating extra space (In-Place):**\\n\\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  for (int i = 0; i < n; ++i) {\\n    int prependVal = (1 << i);\\n    int oldSize = result.size();\\n    for (int j = oldSize - 1; j >= 0; --j) {\\n      result.add(result.get(j) + prependVal);\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\nSame complexity.\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nInput: 2\\nOutput: [0,1,3,2]\\nExplanation:\\n00 - 0\\n01 - 1\\n11 - 3\\n10 - 2\\n\\nFor a given n, a gray code sequence may not be uniquely defined.\\nFor example, [0,2,3,1] is also a valid gray code sequence.\\n\\n00 - 0\\n10 - 2\\n11 - 3\\n01 - 1\\n\\nInput: 0\\nOutput: [0]\\n\\nInput: 1\\nOutput: [0, 1]\\n```\n```java\\nprivate boolean isValid(int n1, int n2) {\\n  int xor = n1 ^ n2;\\n  return xor != 0 && (xor & (xor - 1)) == 0;\\n}\\n```\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  Set<Integer> history = new HashSet<>();\\n  generateGrayCode(n, history, result);\\n  return result;\\n}\\n\\nprivate boolean generateGrayCode(int n, Set<Integer> history, List<Integer> result) {\\n  // base case\\n  if (result.size() == (1 << n)) {\\n    // check the first element and the last element\\n    return isValid(result.get(0), result.get(result.size() - 1));\\n  }\\n  for (int i = 0; i < n; ++i) {\\n    int prevCode = result.get(result.size() - 1);\\n    int candCode = prevCode ^ (1 << i);\\n    if (!history.contains(candCode)) {\\n      history.add(candCode);\\n      result.add(candCode);\\n      boolean found = generateGrayCode(n, history, result);\\n      if (found) return true;\\n      history.remove(candCode);\\n      result.remove(result.size() - 1);\\n    }\\n  }\\n  return false;\\n}\\n```\n```java\\nn = 0, we have [0].\\n\\nn = 1, we previously have [0] and then construct [0, 1].\\n\\nJust add 1 (actually add 1, which is 1 << n = 1)\\n\\nn = 2, we previously have [0, 1] and construct [00, 01, 11, 10].\\n\\nBy adding 0 before each element, we get [00, 01] (actually do nothing in the code)\\nBy adding 1 before each element, we get [10, 11] (actually add 10, which is 1 << n = 10)\\nReverse [10, 11] to get [11, 10]\\nCombine [00, 01] and [11, 10], we have [00, 01, 11, 10].\\n\\nn = 3, we previously have [00, 01, 11, 10].\\n\\nAdd 0:   [000, 001, 011, 010]\\nAdd 1:   [110, 111, 101, 100] (reversed) (actually add 100, which is 1 << n = 1 << 3 = 100)\\nCombine: [000, 001, 011, 010, 110, 111, 101, 100]\\n```\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  for (int i = 0; i < n; ++i) {\\n    List<Integer> res1 = result;\\n    List<Integer> res2 = new ArrayList<>(res1);\\n    Collections.reverse(res2);\\n    // prepend \"1\"\\n    int prependVal = (1 << i);\\n    for (int j = 0; j < res2.size(); ++j) {\\n      res2.set(j, res2.get(j) + prependVal);\\n    }\\n    res1.addAll(res2);\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  for (int i = 0; i < n; ++i) {\\n    int prependVal = (1 << i);\\n    int oldSize = result.size();\\n    for (int j = oldSize - 1; j >= 0; --j) {\\n      result.add(result.get(j) + prependVal);\\n    }\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1451928,
                "title": "c-bit-manipulation-easy-to-understand-explained-beginner",
                "content": "# ***Appraoch***\\n```\\nWe are required to find n-bit gray codes and return them in a vector\\n\\nThis is a pretty good bit-manipulation + backtracking problem\\nI would say backtracking part is really easy but bit-manipulation logic is really good for this particular problem\\n\\nLogic is very simple\\n\\nsuppose we are given n = 1 [means we are required all 1-bit gray codes]\\ngray codes : differ only by 1 bit in their binary representation!!!\\n    \\nfor n = 1 => codes [0 , 1]\\nfor n = 2 => codes [00 , 01 , 11 , 10]\\nfor n = 3 => codes [000 , 001 , 011 , 010 , 110 , 111 , 101 , 100]\\n\\nObservation : for n , we have (2 ^ n ) codes\\n\\nalso for finding we can find all n-bit gray codes if we already know (n-1) bit codes\\n\\nlet\\'s find out how?\\n    \\n    suppose we are given all codes for n = 2 , [00 , 01 , 11 , 10]\\n    and required to find for n = 3\\n        \\n        means n = 3,\\n\\t\\tfor n = 3 , we have 2 ^ 3 = 8 codes [4 created by putting 0 in front of 2-bit codes + 4 created by putting 1 in front of 2-bit codes in reverse fashion]\\n\\t\\t\\n        find n-bit codes with the help of (n-1) bit codes\\n        actually 3-bit codes can be build using 2-bit codes by first placing 0 in front of all codes and then 1 bit codes in reverse fashion\\n        \\n        Put 0 in front of all 2-bit codes\\n        00  => 000\\n        01  => 001\\n        11  => 011\\n        10  => 010\\n            \\n        half of 3-bit codes are ready!!\\n            \\n        Other half can be build putting 1 in front of all 2-bit codes in reverse fashion[because if we put in forward order we get 2 changed bits in one pair]\\n        \\n        Put 1 in front of all 2-bit codes in reverse fashion\\n\\n        10  => 110\\n        11  => 111\\n        01  => 101\\n        00  => 100\\n\\n        so 3-bit codes are = [000 , 001 , 011 , 010 , 110 , 111 , 101 , 100]\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> codes;\\n        \\n        for(string s : get_n_bit_gray_code(n))\\n            codes.push_back(stoi(s , 0 , 2)); // converting string-binary-num to int : \"100\" = 4\\n        return codes;\\n    }\\n    \\n    vector<string> get_n_bit_gray_code(int n)\\n    {\\n        if(n == 1) // base case\\n            return {\"0\" , \"1\"};\\n        \\n        vector<string> v = get_n_bit_gray_code(n - 1);\\n        \\n        vector<string> codes;\\n        \\n        for(int i = 0 ; i < v.size() ; ++i) // forward-fashion traversal to add 0 to front\\n            codes.push_back(\"0\" + v[i]);\\n        \\n        for(int i = v.size() - 1 ; i >= 0 ; --i) // reverse-fashion traversal to add 1 to front\\n            codes.push_back(\"1\" + v[i]);\\n        \\n        return codes;\\n    }\\n};\\n```\\n# ***If you liked the solution , please Upvote!!!***",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nWe are required to find n-bit gray codes and return them in a vector\\n\\nThis is a pretty good bit-manipulation + backtracking problem\\nI would say backtracking part is really easy but bit-manipulation logic is really good for this particular problem\\n\\nLogic is very simple\\n\\nsuppose we are given n = 1 [means we are required all 1-bit gray codes]\\ngray codes : differ only by 1 bit in their binary representation!!!\\n    \\nfor n = 1 => codes [0 , 1]\\nfor n = 2 => codes [00 , 01 , 11 , 10]\\nfor n = 3 => codes [000 , 001 , 011 , 010 , 110 , 111 , 101 , 100]\\n\\nObservation : for n , we have (2 ^ n ) codes\\n\\nalso for finding we can find all n-bit gray codes if we already know (n-1) bit codes\\n\\nlet\\'s find out how?\\n    \\n    suppose we are given all codes for n = 2 , [00 , 01 , 11 , 10]\\n    and required to find for n = 3\\n        \\n        means n = 3,\\n\\t\\tfor n = 3 , we have 2 ^ 3 = 8 codes [4 created by putting 0 in front of 2-bit codes + 4 created by putting 1 in front of 2-bit codes in reverse fashion]\\n\\t\\t\\n        find n-bit codes with the help of (n-1) bit codes\\n        actually 3-bit codes can be build using 2-bit codes by first placing 0 in front of all codes and then 1 bit codes in reverse fashion\\n        \\n        Put 0 in front of all 2-bit codes\\n        00  => 000\\n        01  => 001\\n        11  => 011\\n        10  => 010\\n            \\n        half of 3-bit codes are ready!!\\n            \\n        Other half can be build putting 1 in front of all 2-bit codes in reverse fashion[because if we put in forward order we get 2 changed bits in one pair]\\n        \\n        Put 1 in front of all 2-bit codes in reverse fashion\\n\\n        10  => 110\\n        11  => 111\\n        01  => 101\\n        00  => 100\\n\\n        so 3-bit codes are = [000 , 001 , 011 , 010 , 110 , 111 , 101 , 100]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> codes;\\n        \\n        for(string s : get_n_bit_gray_code(n))\\n            codes.push_back(stoi(s , 0 , 2)); // converting string-binary-num to int : \"100\" = 4\\n        return codes;\\n    }\\n    \\n    vector<string> get_n_bit_gray_code(int n)\\n    {\\n        if(n == 1) // base case\\n            return {\"0\" , \"1\"};\\n        \\n        vector<string> v = get_n_bit_gray_code(n - 1);\\n        \\n        vector<string> codes;\\n        \\n        for(int i = 0 ; i < v.size() ; ++i) // forward-fashion traversal to add 0 to front\\n            codes.push_back(\"0\" + v[i]);\\n        \\n        for(int i = v.size() - 1 ; i >= 0 ; --i) // reverse-fashion traversal to add 1 to front\\n            codes.push_back(\"1\" + v[i]);\\n        \\n        return codes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393673,
                "title": "python-recursive-implementation",
                "content": "This uses property of gray codes, that you can mirror and add prefix to get these codes. This is shown in the following image. \\n\\n\\n![image](https://assets.leetcode.com/users/msminhas93/image_1569797075.png)\\n\\nThe code uses basic recursion to add the appropirate prefixes to the original codes and the mirrored codes [obtained by reversing the list of original codes.].\\n\\n```\\n    def grayCode(self, n: int) -> List[int]:\\n        if n==0:\\n            return [0]\\n        if n==1:\\n            return [0,1]\\n        if n==2:\\n            return [0,1,3,2]\\n        else:\\n            return self.grayCode(n-1) + [x + (2**(n-1)) for x in self.grayCode(n-1)[::-1]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def grayCode(self, n: int) -> List[int]:\\n        if n==0:\\n            return [0]\\n        if n==1:\\n            return [0,1]\\n        if n==2:\\n            return [0,1,3,2]\\n        else:\\n            return self.grayCode(n-1) + [x + (2**(n-1)) for x in self.grayCode(n-1)[::-1]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 30006,
                "title": "6-line-java-solution-very-concise",
                "content": "All we need to do is to add an '1' to the top digit of the binary string and reversely added the new number to the list.\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        \\n        for(int i = 0; i < n ; i++)\\n            for(int j = ans.size()-1; j>=0; j--)\\n                ans.add(ans.get(j)+(1<<i));\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "All we need to do is to add an '1' to the top digit of the binary string and reversely added the new number to the list.\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        \\n        for(int i = 0; i < n ; i++)\\n            for(int j = ans.size()-1; j>=0; j--)\\n                ans.add(ans.get(j)+(1<<i));\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 741620,
                "title": "intuitive-solution-using-inputs-cpp-hard-till-you-understand-logic-xd",
                "content": "n==0 {0}  //base case\\nn==1 {0,1} //base case\\nn==2 {00,01,11,10} //traversing from left to right through for n==1 add 0 to the front and traversing from right to left add 1 at the front. \\nn==3 {000,001,011,010,110,111,101,100} // similar as above\\nn==4 {0000,0001,0011,0010,0110,0111,0101,0100,1100,1101,1111,1110,1010,1011,1001,1000} \\nNow write for n==5 yourself. \\nNow code ---> \\n```\\nclass Solution {\\npublic:\\n    int bin(string c)\\n    {\\n        int ans = 0;\\n        for(auto x:c)\\n        {\\n            ans = ans*2  + (x-\\'0\\');\\n        }\\n        return ans;\\n    }\\n    vector<int> grayCode(int n) {\\n        if(n==0)return {0};\\n        if(n==1)return {0,1};\\n        vector<string>vect;\\n        vector<string>ans;\\n        ans.push_back(\"0\");\\n        ans.push_back(\"1\");\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<string>temp;\\n            for(auto c: ans)\\n            {\\n                c.insert(c.begin(),\\'0\\');\\n                temp.push_back(c);\\n            }\\n            for(int k=ans.size()-1;k>=0;k--)\\n            {\\n                ans[k].insert(ans[k].begin(),\\'1\\');\\n                temp.push_back(ans[k]);\\n            }\\n           ans = temp;\\n        }\\n        vector<int>ans1;\\n        for(auto c: ans)\\n        {\\n            ans1.push_back(bin(c));\\n        }\\n        return ans1;\\n    }\\n};\\n```\\nPS:Thumbs up if you like it, It will encourage me. Have a nice day :).\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bin(string c)\\n    {\\n        int ans = 0;\\n        for(auto x:c)\\n        {\\n            ans = ans*2  + (x-\\'0\\');\\n        }\\n        return ans;\\n    }\\n    vector<int> grayCode(int n) {\\n        if(n==0)return {0};\\n        if(n==1)return {0,1};\\n        vector<string>vect;\\n        vector<string>ans;\\n        ans.push_back(\"0\");\\n        ans.push_back(\"1\");\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<string>temp;\\n            for(auto c: ans)\\n            {\\n                c.insert(c.begin(),\\'0\\');\\n                temp.push_back(c);\\n            }\\n            for(int k=ans.size()-1;k>=0;k--)\\n            {\\n                ans[k].insert(ans[k].begin(),\\'1\\');\\n                temp.push_back(ans[k]);\\n            }\\n           ans = temp;\\n        }\\n        vector<int>ans1;\\n        for(auto c: ans)\\n        {\\n            ans1.push_back(bin(c));\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29938,
                "title": "simplest-fastest-easiest-solution",
                "content": "    public List<Integer> grayCode(int n) {\\n        int count = (int)Math.pow(2,n);\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i < count; i++){\\n            res.add((i) ^ (i >> 1));\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public List<Integer> grayCode(int n) {\\n        int count = (int)Math.pow(2,n);\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i < count; i++){\\n            res.add((i) ^ (i >> 1));\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30106,
                "title": "recursive-solution-c-6-ms-with-explaination",
                "content": "    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> result;\\n            if (n > 0) {\\n                grayCodeHelper(n, result);\\n            } else {\\n                result.push_back(0);\\n            }\\n            return result;\\n        }\\n        \\n        void grayCodeHelper(int n, vector<int>& res) {\\n            if (n == 1) {\\n                res.push_back(0);\\n                res.push_back(1);\\n                return;\\n            }\\n            \\n            grayCodeHelper(n-1, res);\\n            int size = res.size()-1;\\n            // n elements in res are already a part of\\n            // current gray code as they start with 0 as the MSB\\n            // we need to traverse the res in reverse order, or it \\n            // with 1 to get the next numbers.\\n            // If dont understand, then try making gray code seq\\n            // with 1 and then see how to get graycode(2) from 1.\\n            \\n            for (int i = size; i >= 0; --i) {\\n                int num = res[i] | (1<<(n-1));\\n                res.push_back(num);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> result;\\n            if (n > 0) {\\n                grayCodeHelper(n, result);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 681993,
                "title": "java-solution-without-using-any-bitwise-operation-1ms-runtime-complexity",
                "content": "Ping in comment if anybody does not understand the login behind the answer.\\n```\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList();\\n        res.add(0);\\n        for(int i=1;i<=n;i++){\\n            int count = res.size()-1;\\n            int add = (int)Math.pow(2,i-1);\\n            while(count>=0)\\n                   res.add(add+res.get(count--));\\n            }\\n     return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList();\\n        res.add(0);\\n        for(int i=1;i<=n;i++){\\n            int count = res.size()-1;\\n            int add = (int)Math.pow(2,i-1);\\n            while(count>=0)\\n                   res.add(add+res.get(count--));\\n            }\\n     return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 29954,
                "title": "dp-python-solution",
                "content": "dp is a good way to solve this problem. Every time when you increase the n by 1, you add 1 more digit in the front, which means you add 2**(n-1) to dp[n-1][-1] for you  second half number list\\n\\nn = 1: [0,1]\\nn = 2: [0,1]+ [2+0, 2+1][::-1] = [0,1,3,2]\\nn = 3: [0,1,3,2] + [4 + 0, 4 +1, 4 +3, 4 + 2][::-1] = [0,1,3,2,6,7,5,4]\\n\\n```\\n    def grayCode(self, n):\\n        dp = [[0]]\\n        for i in range(1,n+1):\\n            dp.append(dp[i-1] + [2**(i-1) + j for j in dp[i-1]][::-1])\\n        return dp[n]\\n```",
                "solutionTags": [],
                "code": "```\\n    def grayCode(self, n):\\n        dp = [[0]]\\n        for i in range(1,n+1):\\n            dp.append(dp[i-1] + [2**(i-1) + j for j in dp[i-1]][::-1])\\n        return dp[n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1921930,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func grayCode(_ n: Int) -> [Int] {\\n        var arr: [Int] = [0]\\n        var e = -1\\n        \\n        func povv(_ n: Int, _ e: Int) -> Int { return Int(pow(Double(n), Double(e))) }\\n        \\n        for i in 1..<povv(2, n) {\\n            if i == povv(2, e + 1) { e += 1 }\\n            \\n            let index = povv(2, e + 1) - i - 1\\n            let num = povv(2, e) + arr[index]\\n            arr.append(num)\\n        }\\n        \\n        return arr\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func grayCode(_ n: Int) -> [Int] {\\n        var arr: [Int] = [0]\\n        var e = -1\\n        \\n        func povv(_ n: Int, _ e: Int) -> Int { return Int(pow(Double(n), Double(e))) }\\n        \\n        for i in 1..<povv(2, n) {\\n            if i == povv(2, e + 1) { e += 1 }\\n            \\n            let index = povv(2, e + 1) - i - 1\\n            let num = povv(2, e) + arr[index]\\n            arr.append(num)\\n        }\\n        \\n        return arr\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309424,
                "title": "python3-1-line-solution-list-comprehension",
                "content": "Using List Comprehension, we can easily solve this problem statement in 1 line.\\n```\\n#   Gray Code Formula:\\n#   n <= 16\\n#   Gray_Code(n) = n XOR (n / 2)\\n\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = [i ^ (i // 2) for i in range(pow(2, n))]\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#   Gray Code Formula:\\n#   n <= 16\\n#   Gray_Code(n) = n XOR (n / 2)\\n\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = [i ^ (i // 2) for i in range(pow(2, n))]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110683,
                "title": "python-js-c-go-o-2-n-by-toggle-bitmask-w-example",
                "content": "Python O(2^n) by toggle bitmask\\n\\n---\\n\\nExample with n = 2:\\n\\n1st iteration\\n\\u3000\\u3000 0 0\\n\\u2295\\u3000  0 0\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\n\\u3000\\u30000 0 \\n  \\n  We get 0\\'b 00 = **0**\\n\\n---\\n\\n2nd iteration\\n\\u3000\\u3000 0 1\\n\\u2295\\u3000  0 0\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\n\\u3000\\u30000 1 \\n  \\n  We get 0\\'b 01 = **1**\\n\\n---\\n\\n3rd iteration\\n\\u3000\\u3000 1 0\\n\\u2295\\u3000  0 1\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\n\\u3000\\u30001 1 \\n  \\n  We get 0\\'b 11 = **3**\\n\\n---\\n\\n4th iteration\\n\\u3000\\u3000 1 1\\n\\u2295\\u3000  0 1\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\n\\u3000\\u30001 0 \\n  \\n  We get 0\\'b 10 = **2**\\n  \\n---\\n\\nFinally, we have gray codes with n=2: \\n[**0**, **1**, **3**, **2**]\\n\\n---\\n\\n**Implementation** in Python:\\n\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        \\n        # total 2^n codes for bit length n\\n        code_count = 1 << n\\n        \\n        # generate gray code from 0, and toggle 1 bit on each iteration\\n        # toggle mask: ( i >> 1 )\\n        \\n        gray_codes =[ i ^ ( i >> 1 ) for i in range(code_count) ]\\n        \\n        return gray_codes\\n```\\n\\n---\\n\\nin **Javascript**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\n```\\n\\nvar grayCode = function(n) {\\n\\n    // toal 2^n codes for bit length n\\n    const codeCount = 1 << n;\\n    \\n    let result = [];\\n    \\n    // generate gray code from 0, and toggle 1 bit on each iteration\\n    // toggle mask: ( i >> 1 )\\n    \\n    for(let i = 0 ; i < codeCount ; i++){\\n        \\n        code = i ^ ( i >> 1);\\n        result.push( code );\\n    }\\n    \\n    return result\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nin **C++**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        \\n        // toal 2^n codes for bit length n\\n        const int codeCount = 1 << n;\\n        \\n        vector<int> result;\\n\\n        // generate gray code from 0, and toggle 1 bit on each iteration\\n        // toggle mask: ( i >> 1 )\\n        \\n        for( int i = 0 ; i < codeCount ; i++ ){\\n            \\n            int mask = i >> 1;\\n            result.push_back( i ^ mask );\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nin **Go**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\n\\n```\\nfunc grayCode(n int) []int {\\n    \\n    // total 2^n codes for bit length n\\n    code_count := 1 << n\\n    \\n    // slice to store gray codes\\n    gray_codes := make([]int, code_count)\\n    \\n    for i:=0 ; i < code_count ; i+=1 {\\n        \\n        toggle_mask := ( i >> 1 )\\n        \\n        gray_codes[ i ] = i ^ toggle_mask\\n    }\\n    \\n    return gray_codes\\n}\\n```\\n\\n</details>\\n\\n---\\nReference:\\n\\n[1] [Wiki: Gray code](https://en.wikipedia.org/wiki/Gray_code)\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        \\n        # total 2^n codes for bit length n\\n        code_count = 1 << n\\n        \\n        # generate gray code from 0, and toggle 1 bit on each iteration\\n        # toggle mask: ( i >> 1 )\\n        \\n        gray_codes =[ i ^ ( i >> 1 ) for i in range(code_count) ]\\n        \\n        return gray_codes\\n```\n```\\n\\nvar grayCode = function(n) {\\n\\n    // toal 2^n codes for bit length n\\n    const codeCount = 1 << n;\\n    \\n    let result = [];\\n    \\n    // generate gray code from 0, and toggle 1 bit on each iteration\\n    // toggle mask: ( i >> 1 )\\n    \\n    for(let i = 0 ; i < codeCount ; i++){\\n        \\n        code = i ^ ( i >> 1);\\n        result.push( code );\\n    }\\n    \\n    return result\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        \\n        // toal 2^n codes for bit length n\\n        const int codeCount = 1 << n;\\n        \\n        vector<int> result;\\n\\n        // generate gray code from 0, and toggle 1 bit on each iteration\\n        // toggle mask: ( i >> 1 )\\n        \\n        for( int i = 0 ; i < codeCount ; i++ ){\\n            \\n            int mask = i >> 1;\\n            result.push_back( i ^ mask );\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\nfunc grayCode(n int) []int {\\n    \\n    // total 2^n codes for bit length n\\n    code_count := 1 << n\\n    \\n    // slice to store gray codes\\n    gray_codes := make([]int, code_count)\\n    \\n    for i:=0 ; i < code_count ; i+=1 {\\n        \\n        toggle_mask := ( i >> 1 )\\n        \\n        gray_codes[ i ] = i ^ toggle_mask\\n    }\\n    \\n    return gray_codes\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280958,
                "title": "1-line-python-recursion",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return (lambda r: r + [x | 1<<n-1 for x in r[::-1]])(self.grayCode(n-1)) if n else [0]\\n```\\nReferences to [@girikuncoro\\'s solution](https://leetcode.com/problems/gray-code/discuss/30007/Python-Easy-Bit-Manipulation-Solution)\\n\\nOr, you can just use the method of \\'Gray Code\\'\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i ^ i >> 1  for i in range(1 << n)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return (lambda r: r + [x | 1<<n-1 for x in r[::-1]])(self.grayCode(n-1)) if n else [0]\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i ^ i >> 1  for i in range(1 << n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216001,
                "title": "python-solution",
                "content": "Recursion. `grayCode(n)` can be obtained by first constructing `grayCode(n-1)` and append `grayCode(n-1)[::-1]` with a bit `1` added in front of every binary number in `grayCode(n-1)[::-1]`. The base case: `grayCode(0) = [0]`.\\n\\nConsider the example `n = 3`. With `n = 2`, we have `grayCode(2) = [00, 01, 11, 10] = [0, 1, 3, 2]`. For `n = 3`, the 4 binary numbers in `grayCode(2)` still show up, i.e., it will contain `[000, 001, 011, 010] = [0, 1, 3, 2]`. To obtain the other 4 binary numbers, we simply flip the first binary digit to `1`, i.e., `[100, 101, 111, 110] = [4, 5, 7, 6]`. Finally, we append `[6, 7, 5, 4]` to `[0, 1, 3, 2]` to obtain the output for `grayCode(3) = [0, 1, 3, 2, 6, 7, 5, 4]`. Note that we have to reverse the second list because `6 (110)` can be obtained from `2 (010)` by flipping one bit, whereas `4 (100)` cannot.\\n\\nTime complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution:\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 0:\\n            return [0]\\n        if n == 1:\\n            return [0, 1]\\n        res = self.grayCode(n-1)\\n        num = 2**(n-1)\\n        res += res[::-1]\\n        for i in range(num,len(res)):\\n            res[i] ^= num\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 0:\\n            return [0]\\n        if n == 1:\\n            return [0, 1]\\n        res = self.grayCode(n-1)\\n        num = 2**(n-1)\\n        res += res[::-1]\\n        for i in range(num,len(res)):\\n            res[i] ^= num\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29979,
                "title": "typical-backtracking-solution-without-using-bit-manipulation",
                "content": "This problem is very similar with permutation pronblem. so we can use DFS and backtracking to solve this problem.But the gray code is binary numeral system where two successive values differ in only one bit, so we need to reverse the array which store 0 and 1,  when we add 1 to list which store the binary numbers. When the list's size equal n , convert binary to deciamal and add deciamal to result.\\n\\n`\\n\\n    public class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> result = new ArrayList<>();\\n            List<Integer> grayCode = new ArrayList<>();\\n            // if (n == 0) {\\n            //     return result;\\n            // }\\n            int[] a = {0, 1};\\n            solver(result, grayCode, a, n);\\n            return result;\\n        }\\n        public void solver (List<Integer> result, List<Integer> grayCode, int[] a, int n) {\\n            if (grayCode.size() == n) {\\n                double sum = 0;\\n                for (int i = 0 ; i < grayCode.size(); i++) {\\n                    if (grayCode.get(i) == 1) {\\n                        sum += Math.pow(2, grayCode.size() - 1 - i);\\n                    }\\n                }\\n                result.add((int)sum);\\n                return;\\n            }\\n            for (int i = 0 ; i < 2; i++) {\\n                grayCode.add(a[i]);\\n                if (a[i] == 0) {\\n                    solver(result, grayCode, a, n);\\n                } else {\\n                    swap(a);\\n                    solver(result, grayCode, a, n);\\n                    swap(a);\\n                }\\n                grayCode.remove(grayCode.size() - 1);\\n            }\\n        }\\n        public void swap (int[] a) {\\n            int temp = a[0];\\n            a[0] = a[1];\\n            a[1] = temp;\\n        }\\n    }`",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> result = new ArrayList<>();\\n            List<Integer> grayCode = new ArrayList<>();\\n            // if (n == 0) {\\n            //     return result;\\n            // }",
                "codeTag": "Java"
            },
            {
                "id": 2212006,
                "title": "c-3-approaches-recursion-iteration-gray-code-property-4-lines",
                "content": "The idea is simple. if we have gray code for n-1, then we can construct gray code for n easily. Imagine, that n = 4 and we have code for n-1 i.e, n=3 [0,1,3,2,6,7,5,4]. \\nThen we need to add numbers in [8, 15].\\nLet us add 8 to each number, so we have [8, 9, 11, 10, 14, 15, 13, 12] which is also code with property that every two adjacent number differ by one bit. All we need to do is to concatenate these two lists, but first we need to invert one of them to get [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8].\\n\\n**Iterative Code in C++**\\n```\\n\\tvector<int> grayCode(int n) {\\n        vector<int> ans={0};\\n        int value;\\n        for(int i=0;i<n;i++){\\n           vector<int> curr;\\n            for(auto it=ans.rbegin();it!=ans.rend();it++){\\n                curr.push_back((1<<i) | (*it) );\\n            }\\n            ans.insert(ans.end(),curr.begin(),curr.end());\\n        }\\n        return ans;\\n    }\\n```\\n**Recursive Code in C++**\\n```\\n\\tvector<int> grayCode(int n) {\\n        if(n==0) return {0};\\n        vector<int> curr;\\n        vector<int> prev=grayCode(n-1);\\n        for(int i=prev.size()-1;i>=0;i--){\\n            int value =(1<<(n-1)|prev[i]);\\n            curr.push_back(value);\\n        }\\n        curr.insert(curr.begin(),prev.begin(),prev.end());\\n        return curr;\\n    }\\n```\\n\\nThe third approach needs the property of gray code.\\n*G ( i ) = i ^ ( i / 2 )*\\nUsing the above property, we can easily generate gray code for any integer.\\n```\\n\\tvector<int> grayCode(int n) {\\n        vector<int> ans;\\n        int value;\\n        for(int i=0;i<(1<<n);i++){\\n            value = i^(i>>1); // G(i) = i ^ (i/2)\\n            ans.push_back(value);\\n        }\\n        return ans;\\n    }\\n```\\n**Please support me. If you like my effort !!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\tvector<int> grayCode(int n) {\\n        vector<int> ans={0};\\n        int value;\\n        for(int i=0;i<n;i++){\\n           vector<int> curr;\\n            for(auto it=ans.rbegin();it!=ans.rend();it++){\\n                curr.push_back((1<<i) | (*it) );\\n            }\\n            ans.insert(ans.end(),curr.begin(),curr.end());\\n        }\\n        return ans;\\n    }\\n```\n```\\n\\tvector<int> grayCode(int n) {\\n        if(n==0) return {0};\\n        vector<int> curr;\\n        vector<int> prev=grayCode(n-1);\\n        for(int i=prev.size()-1;i>=0;i--){\\n            int value =(1<<(n-1)|prev[i]);\\n            curr.push_back(value);\\n        }\\n        curr.insert(curr.begin(),prev.begin(),prev.end());\\n        return curr;\\n    }\\n```\n```\\n\\tvector<int> grayCode(int n) {\\n        vector<int> ans;\\n        int value;\\n        for(int i=0;i<(1<<n);i++){\\n            value = i^(i>>1); // G(i) = i ^ (i/2)\\n            ans.push_back(value);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310706,
                "title": "c-solution-95-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>ans;\\n        ans.push_back(0);\\n        if(n == 0) return ans;\\n        ans.push_back(1);\\n        \\n        int curr = 1;\\n        for(int i = 2; i <= n; i++){\\n          curr*=2;\\n            for(int j = ans.size()-1; j >= 0; j--) \\n                ans.push_back(curr+ans[j]);\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>ans;\\n        ans.push_back(0);\\n        if(n == 0) return ans;\\n        ans.push_back(1);\\n        \\n        int curr = 1;\\n        for(int i = 2; i <= n; i++){\\n          curr*=2;\\n            for(int j = ans.size()-1; j >= 0; j--) \\n                ans.push_back(curr+ans[j]);\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039828,
                "title": "java-simple-backtracking-just-like-permutation-detailed-explanation",
                "content": "Since this problem is tagged with backtracking and I also admit that it\\'s hard for me to come up with a smart algorithm to generate the gray code directly, here I share a pretty standard backtracking solution can be used in other backtracking problems.\\n\\nBit manipulations you need to know:\\n1. `1 << n = 2 ^ n`, in this problem, there\\'s `n` bits in code, so the total number is `2^n` (i.e. 0,1,...,2^n -1). Also, `1 << n` means left shift `1` by `n` bit, the mask in the example below is obtained by `1 << 1`.\\n2. `XOR(^)` operation can toggle/flip a bit, e.g. \\n```\\n    1 1 0  (original)\\n^   0 1 0  (mask)\\n----------\\n    1 0 0  (result)\\n\\t\\nThe middle bit of original is flipped, so that original and result only differ by 1 bit.\\n```\\n\\nThe problem is basically permutation of `2^n` numbers so that 2 successive numbers in the permutation differ in only one bit. The input size is can be `n = 16`, though `n` is small, generating all permutation of `2^16` numbers and check the validity would definitely lead to TLE. So we need to prune while we do the permutation. \\n\\nTo meet the 2 number differ in 1 bit constraint, we found that `XOR` operation is useful to generate the next valid number. Also, we only need ANY ONE of the valid permutaion, so when we find one, just return it, avoid further search. Like in the [permutations](https://leetcode.com/problems/permutations/) problem, we need to track the number is used or not since we can use different number only once.\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> curr = new ArrayList<>();\\n        curr.add(0);\\n        boolean[] used = new boolean[1 << n];\\n        used[0] = true;\\n        backtrack(n, curr, used);\\n        return curr;\\n    }\\n    \\n    private boolean backtrack(int n, List<Integer> curr, boolean[] used) {\\n        if (curr.size() == 1 << n) {\\n            return true;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int nex = (1 << i) ^ curr.get(curr.size() - 1); // (1 << i) is the mask in example, nex is next valid number\\n            if (used[nex]) continue;\\n            used[nex] = true;\\n            curr.add(nex);\\n            if (backtrack(n, curr, used)) return true;\\n            used[nex] = false;\\n            curr.remove(curr.size() - 1);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nTime Complexity: `O(2^n)`, a very loose bound\\nSapce: `O(2^n)`",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n    1 1 0  (original)\\n^   0 1 0  (mask)\\n----------\\n    1 0 0  (result)\\n\\t\\nThe middle bit of original is flipped, so that original and result only differ by 1 bit.\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> curr = new ArrayList<>();\\n        curr.add(0);\\n        boolean[] used = new boolean[1 << n];\\n        used[0] = true;\\n        backtrack(n, curr, used);\\n        return curr;\\n    }\\n    \\n    private boolean backtrack(int n, List<Integer> curr, boolean[] used) {\\n        if (curr.size() == 1 << n) {\\n            return true;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int nex = (1 << i) ^ curr.get(curr.size() - 1); // (1 << i) is the mask in example, nex is next valid number\\n            if (used[nex]) continue;\\n            used[nex] = true;\\n            curr.add(nex);\\n            if (backtrack(n, curr, used)) return true;\\n            used[nex] = false;\\n            curr.remove(curr.size() - 1);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30069,
                "title": "short-and-clear-iterative-c-solution",
                "content": "Very easy to understand, just generate the results using already generated values. Used a few intermediate variables for clarity.\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            \\n            vector<int> out = {0};\\n            for (int i = 0; i < n ; ++i)\\n            {\\n                int p = 1<<i;\\n                int s = out.size();\\n                while (s)\\n                {\\n                    int v = p | out[--s];\\n                    out.push_back(v);\\n                }\\n            }\\n    \\n            return out;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            \\n            vector<int> out = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2340177,
                "title": "simple-java-solution",
                "content": "Total no bits =1<<n,\\n   ![image](https://assets.leetcode.com/users/images/98335758-385b-4a2d-9ba4-9b3cd077c2c8_1658910773.2479193.png)\\n for n=3 total no bits=8.\\ni=0,   j=i>>1 = 0    i ^ j=0\\ni=1,    j=i>>1 = 0    i ^ j=1\\ni=2    j=i>>1 = 1     i ^ j=3          \\ni=3    j=i>>1 = 1     i ^ j=2        \\ni=4    j=i>>1 = 2     i ^ j=6\\ni=5    j=i>>1 = 2     i ^ j=7\\ni=6    j=i>>1 = 3     i ^ j=5\\ni=7    j=i>>1=3        i^j=4\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n      ArrayList list=new ArrayList();\\n       for(int i=0;i<(1<<n);i++){\\n         list.add(i^(i>>1));\\n       }\\n         return list;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public List<Integer> grayCode(int n) {\\n      ArrayList list=new ArrayList();\\n       for(int i=0;i<(1<<n);i++){\\n         list.add(i^(i>>1));\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 852558,
                "title": "detailed-explanation-with-example-100-faster",
                "content": "This is very basic problem of generating the first n numbers in `GRAY CODE` representation.\\nDefinition of GRAY Code is already described in the description of the problem statement. So I\\'m skipping that here. And if it\\'s not cleared from there then probably by going through what I\\'ve described below it will make it more clearer.\\n\\nSo first lets take a look how BINARY and GRAY codes are different from one another.\\n\\n| Binary \\t| Gray \\t|\\n|--------\\t|------\\t|\\n| 0000   \\t| 0000 \\t|\\n| 0001   \\t| 0001 \\t|\\n| 0010   \\t| 0011 \\t|\\n| 0011   \\t| 0010 \\t|\\n| 0100   \\t| 0110 \\t|\\n| 0101   \\t| 0111 \\t|\\n| 0110   \\t| 0101 \\t|\\n| 0111   \\t| 0100 \\t|\\n| 1000   \\t| 1100 \\t|\\n| 1001   \\t| 1101 \\t|\\n| 1010   \\t| 1111 \\t|\\n| 1011   \\t| 1110 \\t|\\n| 1100   \\t| 1010 \\t|\\n| 1101   \\t| 1011 \\t|\\n| 1110   \\t| 1001 \\t|\\n| 1111   \\t| 1000 \\t|\\n\\nNow try to see some pattern how the numbers are generated. At every 2<sup>x</sup> where x = [0,n) element you put mirror of `x` index and copy the same number of elements in reverse order as you see them in mirror and add 2<sup>x</sup> to it.\\n\\nLet me explain it with an example\\n\\nInitial element that will be present in the list = [0]\\n\\nlist = [0]\\n\\nNow put mirror of length x = 0 at 2<sup>0</sup>=1 index \\n```\\n0\\n-\\n```\\n\\nNow  copy the same number of elements and add 2<sup>0</sup> to it\\n```\\n0\\n-\\n0 + 1 = 1\\n```\\n\\nthis was for n = 1, now for n=2 lets do the same thing, put mirror of length x = 1 at 2<sup>1</sup>=2 index and add 2<sup>1</sup> to it.\\n\\n```\\n0 = 00\\n1 = 01\\n-\\n1(binary) + 10 (binary)  = 11\\n0(binary) + 10 (binary) = 10\\n```\\n\\nNow for 2 bit, the gray number in decimal format looks like\\n```\\n0\\n1\\n3\\n2\\n```\\n\\nNow for 3 bit, lets do the same thing, put mirror at length x = 2 at 2<sup>2</sup> index and add 2<sup>2</sup> to all of them\\n\\n```\\n00 = 000\\n01 = 001\\n11 = 011\\n10 = 010\\n--\\n10 (binary) + 100 (binary) = 110\\n11 (binary) + 100 (binary) = 111\\n01 (binary) + 100 (binary) = 101\\n00 (binary) + 100 (binary) = 100\\n```\\n\\nand so on. \\n\\nIf it is still not clear please comment below I\\'ll try to make it more clearer by adding more examples\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n\\t\\t\\n\\t\\t// Handling negative n\\n        if (n < 0) {\\n            return list;\\n        }\\n\\t\\t// Initial value\\n        list.add(0);\\n\\t\\t\\n        int mirror = 0;\\n        while (mirror < n) {\\n            int count = list.size();\\n            for (int i = count-1; i >= 0; i--) {\\n                list.add((1 << mirror) | list.get(i)); // this will get the value from list and add 2^mirror to the number as we discussed above\\n            }\\n            mirror++;\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\nPlease do upvote if the explaination helped you in understanding the solution.",
                "solutionTags": [],
                "code": "```\\n0\\n-\\n```\n```\\n0\\n-\\n0 + 1 = 1\\n```\n```\\n0 = 00\\n1 = 01\\n-\\n1(binary) + 10 (binary)  = 11\\n0(binary) + 10 (binary) = 10\\n```\n```\\n0\\n1\\n3\\n2\\n```\n```\\n00 = 000\\n01 = 001\\n11 = 011\\n10 = 010\\n--\\n10 (binary) + 100 (binary) = 110\\n11 (binary) + 100 (binary) = 111\\n01 (binary) + 100 (binary) = 101\\n00 (binary) + 100 (binary) = 100\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n\\t\\t\\n\\t\\t// Handling negative n\\n        if (n < 0) {\\n            return list;\\n        }\\n\\t\\t// Initial value\\n        list.add(0);\\n\\t\\t\\n        int mirror = 0;\\n        while (mirror < n) {\\n            int count = list.size();\\n            for (int i = count-1; i >= 0; i--) {\\n                list.add((1 << mirror) | list.get(i)); // this will get the value from list and add 2^mirror to the number as we discussed above\\n            }\\n            mirror++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29978,
                "title": "java-short-code-with-explanation",
                "content": "how to go from  i = 1 [0,1] to i=2?\\n\\n1.copy list of i=1 in reverse order\\n\\n0, 1 || 1, 0\\n\\n\\n2 append \"1\" in front all numbers of the copy\\n\\n0, 1 || 11, 10\\n \\n\\n\\n\\n       public class Solution {\\n            public List<Integer> grayCode(int n) {\\n                List<Integer> list = new ArrayList<>();\\n                list.add(0);\\n                int mask = 1;\\n                for (int i = 1; i <= n; i++) {\\n                    // change from len i-1 to i\\n                    for (int j = list.size() - 1; j >= 0; j--) {\\n                        list.add(list.get(j) | mask);\\n                    }\\n                    mask <<= 1;\\n                }\\n                return list;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public List<Integer> grayCode(int n) {\\n                List<Integer> list = new ArrayList<>();\\n                list.add(0);\\n                int mask = 1;\\n                for (int i = 1; i <= n; i++) {\\n                    // change from len i-1 to i\\n                    for (int j = list.size() - 1; j >= 0; j--) {\\n                        list.add(list.get(j) | mask);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 30108,
                "title": "java-solution-use-a-stack-easy-to-figure-out-simple-and-interesting",
                "content": "    0\\t\\t0\\n    1\\t\\t1\\n    \\n    00  \\t\\t0\\n    01\\t\\t1\\t\\t+1\\n    11\\t\\t3\\t\\t--------\\n    10\\t\\t2\\t\\t-1\\n    \\n    000\\t\\t0\\n    001\\t\\t1\\t\\t+1\\n    011\\t\\t3\\t\\t+2\\n    010\\t\\t2\\t\\t-1\\t\\n    110\\t\\t6\\t\\t-----------\\n    111\\t\\t7\\t\\t+1\\t\\t\\t\\n    101\\t\\t5\\t\\t-2\\n    100\\t\\t4\\t\\t-1\\n    \\n    \\n    0000\\t\\t0\\n    0001\\t\\t1\\t\\t+1\\n    0011\\t\\t3\\t\\t+2\\n    0010\\t\\t2\\t\\t-1\\n    0110\\t\\t6\\t\\t+4\\n    0111\\t\\t7\\t\\t+1\\n    0101\\t\\t5\\t\\t-2\\n    0100\\t\\t4\\t\\t-1\\n    1100\\t\\t12\\t\\t-----------\\n    1101\\t\\t13\\t\\t+1\\n    1111\\t\\t15\\t\\t+2\\t\\n    1110\\t\\t14\\t\\t-1\\n    1010\\t\\t10\\t\\t-4\\n    1011\\t\\t11\\t\\t+1\\n    1001\\t\\t9\\t\\t-2\\n    1000\\t\\t8\\t\\t-1\\n\\n\\nFrom the above example, I believe you will find out that why use a stack here, all the post half is the pre half plus the Math.pow(2, i) in the symmetric form!!!\\n\\n\\n    public class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> list = new LinkedList<Integer>();\\n            Stack<Integer> stack = new Stack<Integer>();\\n            list.add(0);\\n            int i = 0;\\n            while(i < n) {\\n                int len = list.size();\\n                int inc = (int)(Math.pow(2, i));\\n                for(int j=0; j<len; j++) {\\n                    stack.push(list.get(j));\\n                }\\n                while(!stack.isEmpty()) {\\n                    list.add(stack.pop() + inc);\\n                }\\n                i++;\\n            }\\n            return list;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> list = new LinkedList<Integer>();\\n            Stack<Integer> stack = new Stack<Integer>();\\n            list.add(0);\\n            int i = 0;\\n            while(i < n) {\\n                int len = list.size();\\n                int inc = (int)(Math.pow(2, i));\\n                for(int j=0; j<len; j++) {\\n                    stack.push(list.get(j));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2697032,
                "title": "c-java-go-3-line-code-easy-to-understand",
                "content": "***Explain:***\\nGray code is a binary numeral system where two successive values differ in only one bit.\\nFor example, the sequence of Gray codes for 3-bit numbers is: 000, 001, 011, 010, 110, 111, 101, 100.\\nFor more details read this blog ([Gray Code](https://cp-algorithms.com/algebra/gray-code.html))\\n\\n**C++ Solution:** \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>v;\\n        for(int i=0; i<1<<n; i++) {\\n            v.push_back(i^i>>1);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n\\n\\n**JAVA Solution:**\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n       List<Integer> v = new ArrayList<Integer>();\\n        for(int i=0; i<1<<n; i++) {\\n            v.add(i^(i>>1));\\n        }\\n        return v;\\n    }\\n}\\n```\\n\\n\\n**GO Solution:**\\n\\n```\\nfunc grayCode(n int) []int {\\n    var v []int\\n    for i:=0; i<1<<n; i++ {\\n        v =append(v, i^(i>>1));\\n    }\\n    return v;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>v;\\n        for(int i=0; i<1<<n; i++) {\\n            v.push_back(i^i>>1);\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n       List<Integer> v = new ArrayList<Integer>();\\n        for(int i=0; i<1<<n; i++) {\\n            v.add(i^(i>>1));\\n        }\\n        return v;\\n    }\\n}\\n```\n```\\nfunc grayCode(n int) []int {\\n    var v []int\\n    for i:=0; i<1<<n; i++ {\\n        v =append(v, i^(i>>1));\\n    }\\n    return v;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308829,
                "title": "gray-code-bitmanip-c",
                "content": "### What\\'s the Problem?\\nIn this problem, we have to frame a list of numbers from 0 to 2^n, such that the adjacent numbers and the first and last numbers should have only 1 bit difference.\\n\\n### What to Do?\\nFor any number, if we divide it by 2, it gets 1 bit shifted. \\nEg: 2 = 00**10**\\n2/2 = 1 = 00**01**\\n\\nif the values are XORed, it gives the number with 1 bit difference of the previous number.\\nEg. \\n0 ^ (0/2) = 0 = 00**00**\\n1 ^ (1/2) = 1 ^ 0 = 1 = 00**01**\\n2 ^ (2/2) = 2 ^ 1 = 3 = 00**11**\\n3 ^ (3/2) = 3 ^ 1 = 2 = 00**10**\\n\\nThis idea can be used to solve the problem.\\n\\nHope that Helps!\\n\\n### My C++ Code:\\n```\\nvector<int> grayCode(int n) {\\n        int x = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < (1 << n); ++i) {\\n            x = (i/2) ^ i;\\n            ans.push_back(x);\\n        } return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nvector<int> grayCode(int n) {\\n        int x = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < (1 << n); ++i) {\\n            x = (i/2) ^ i;\\n            ans.push_back(x);\\n        } return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 971284,
                "title": "bits-backtracking-explanation-visual-python",
                "content": "## Use Traditional Backtrack Template\\n\\nTL;DR using a traditional backtracking template \\n\\n```python\\n  def grayCode(self, n: int) -> List[int]:\\n\\t\\tresult = [0]  \\n\\t\\t# 2^n possible gray codes \\n\\t\\tself.backtrack(result, n, 0, pow(2, n))\\n\\t\\treturn result\\n\\t\\t\\n  def backtrack(self, result, n, curr, size):\\n\\t\\t# all gray codes same length \\n        if len(result) == size: return \\n        for i in range(n):\\n            mask = 1 << i \\n\\t\\t\\t#generate candidate by flipping left most bit\\n            candidate = curr ^ mask\\n\\t\\t\\t# avoid duplicates \\n            if candidate not in result:\\n                result.append(int(candidate))\\n                self.backtrack(result, n, candidate, size\\n\\t\\t\\t\\t# reduce number of recursive calls made\\n                if len(result) == size: return \\n```\\n\\n### Walkthrough\\n\\n![image](https://assets.leetcode.com/users/images/0b9fd653-8a79-4918-bac7-354f33a9f9a1_1607888555.8872228.png)\\n\\n### Explanation\\n\\nGray Code: to get to next code in seqeunce, flip exactly 1 bit.\\nour return values should be the value the gray code represents in binary. \\n\\n```      \\nGray Code -> Return Value \\n00 ->  0\\n01 ->  1\\n11 ->  3\\n10 ->  2\\n```\\n##### Number of Possible Gray Codes\\nGiven ```N``` bits, there are ```2^N``` possible gray codes. All adjacent gray codes in the sequence differ by ```1``` bit. for every bit we make a choice to turn this bit on or off. our decision is ***binary*** and this is done for all ```N``` bits. Our result will contain ```2^N``` gray codes. \\n\\n#### Algorithm\\n1. To generate the next candidate in the sequence, a single bit must be flipped. we flip the left most bit (excluding leading zeros). \\n\\n2. To flip the left most bit we use a mask, the last known candidate, and the XOR operation. \\n3. If we ever generate a candidate that has aready been seen, it is not added to the result and no recursive call is made. instead generate a new candidate, by generating a larger mask. \\n\\t* Becuase we only make recursive call when a valid candidate is found and then immedaitely return, there is no need for the traditional undoing found in most backtracking problems. all that must be done is to ignore duplicate codes generated. \\n\\nThis problem isnt as ```backtracking like``` as i initially thought. \\n\\n\\n***Note:***\\nthe recursion tree ends up always resulting in a linked list regardless of N, because we keep going as deep as possible until we have all possible gray codes.\\n\\n\\n[code courtesy of fabrizio3](https://leetcode.com/problems/gray-code/discuss/30087/Backtracking-Solution)\\n\\n\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```python\\n  def grayCode(self, n: int) -> List[int]:\\n\\t\\tresult = [0]  \\n\\t\\t# 2^n possible gray codes \\n\\t\\tself.backtrack(result, n, 0, pow(2, n))\\n\\t\\treturn result\\n\\t\\t\\n  def backtrack(self, result, n, curr, size):\\n\\t\\t# all gray codes same length \\n        if len(result) == size: return \\n        for i in range(n):\\n            mask = 1 << i \\n\\t\\t\\t#generate candidate by flipping left most bit\\n            candidate = curr ^ mask\\n\\t\\t\\t# avoid duplicates \\n            if candidate not in result:\\n                result.append(int(candidate))\\n                self.backtrack(result, n, candidate, size\\n\\t\\t\\t\\t# reduce number of recursive calls made\\n                if len(result) == size: return \\n```\n```      \\nGray Code -> Return Value \\n00 ->  0\\n01 ->  1\\n11 ->  3\\n10 ->  2\\n```\n```N```\n```2^N```\n```1```\n```N```\n```2^N```\n```backtracking like```",
                "codeTag": "Python3"
            },
            {
                "id": 534055,
                "title": "python-5-line-solution-without-prior-knowledge-of-gray-code",
                "content": "If we already have the array R<sub>n</sub> consisting of 2<sup>n</sup> numbers of n bits in the gray code order, then the next 2<sup>n</sup> numbers is just the reversed R<sub>n</sub> with additional value 2<sup>n</sup> on every number.\\n```\\ndef grayCode(self, n: int) -> List[int]:\\n    b, r = 1, [0]\\n    for _ in range(n):\\n        r += [i|b for i in reversed(r)]\\n        b <<= 1\\n    return r\\n```\\nVote up if find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef grayCode(self, n: int) -> List[int]:\\n    b, r = 1, [0]\\n    for _ in range(n):\\n        r += [i|b for i in reversed(r)]\\n        b <<= 1\\n    return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 29909,
                "title": "javascript-recursive-solution-using-reflected-gray-code",
                "content": "```\\nvar grayCode = function(n) {\\n    if (n === 0) return [0];\\n    const res = grayCode(n - 1);\\n    const mask = 1 << n - 1;\\n    for (let i = res.length - 1; i >= 0; i--) {\\n        res.push(res[i] | mask);\\n    }\\n    return res;\\n};\\n```\\nThe strategy is described [here](https://en.wikipedia.org/wiki/Gray_code#Constructing_an_n-bit_Gray_code) and can also be done iteratively.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar grayCode = function(n) {\\n    if (n === 0) return [0];\\n    const res = grayCode(n - 1);\\n    const mask = 1 << n - 1;\\n    for (let i = res.length - 1; i >= 0; i--) {\\n        res.push(res[i] | mask);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30027,
                "title": "1ms-java-solution-with-explaination",
                "content": "    public class Solution {\\n    //analyze the pattern\\n    //n=0  -> 0\\n    //n=1  -> 0, 1\\n    //n=2  -> (00,  01),  (10,  11)\\n    //n=3  -> (000, 001, 010, 011), (111, 110, 101, 100)\\n    \\n    //so the pattern is when n=n  -> add 0 in front of all the result of (n-1)'s binary value (This is just same as all the result of (n-1)\\n    //                               and add 1 in front of all the result of(n-1)'s binary value (This need to calculate.)\\n    \\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new ArrayList();\\n        result.add(0);\\n        \\n        for(int i=1; i<=n; i++){\\n            int front=1;\\n            //Create the correct value for binary format (10...0) which the value has i digi\\n            //so shift 1 to right (i-1) times\\n            for(int j=1; j<i; j++){\\n                front = front<<1;\\n            }\\n            \\n            //add the new generated value to the result list\\n            //the new generated value is the last result add front value\\n            int size=result.size();\\n            //we want to loop through the (n-1) result from end to start. This is just because want to make the test case match the Leetcode answer. You can use other way loop through the (n-1) result.\\n            for(int k=size-1; k>=0; k--){\\n                result.add(result.get(k)+front);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    //analyze the pattern\\n    //n=0  -> 0\\n    //n=1  -> 0, 1\\n    //n=2  -> (00,  01),  (10,  11)\\n    //n=3  -> (000, 001, 010, 011), (111, 110, 101, 100)\\n    \\n    //so the pattern is when n=n  -> add 0 in front of all the result of (n-1)'s binary value (This is just same as all the result of (n-1)\\n    //                               and add 1 in front of all the result of(n-1)'s binary value (This need to calculate.)\\n    \\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new ArrayList();\\n        result.add(0);\\n        \\n        for(int i=1; i<=n; i++){\\n            int front=1;\\n            //Create the correct value for binary format (10...0) which the value has i digi\\n            //so shift 1 to right (i-1) times\\n            for(int j=1; j<i; j++){\\n                front = front<<1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30109,
                "title": "backtracking-solution",
                "content": "    public class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            List<Integer> list = new ArrayList<Integer>();\\n            list.add(0);\\n            helper(result,list,n);\\n            return result;\\n        }\\n        public void helper(List<Integer> result,List<Integer> list,int n){\\n            \\n            if(list.size() == Math.pow(2,n)){\\n                result.addAll(list);\\n                return;\\n            }\\n            int last = list.get(list.size() - 1);\\n            \\n            for(int i = 0; i < n; i++){\\n                int off = 1 << i;\\n                int cur = last ^ off;\\n                \\n                if(list.contains(cur)) continue;\\n                \\n                list.add(cur);\\n                helper(result,list,n);\\n                \\n                if(result.size() > 0) return;\\n                list.remove(list.size() - 1);\\n            }\\n            \\n        } \\n    }\\n    }\\n\\nUsing backtracking without knowing gray code knowledge. Find one solution and return.",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            List<Integer> list = new ArrayList<Integer>();\\n            list.add(0);\\n            helper(result,list,n);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3433391,
                "title": "c-java-remember-this-formula",
                "content": "## Explanation\\nIt is not very intuitive to come up with a solution for this problem in an interview if you haven\\'t solved this already. But there is a simple formula/ technique to remember to solve this one without much hassle !!\\n\\nIf n = 0 => {0}\\nIf n = 1 => {0,1} `{0 , 0 + pow(2,0)}`\\nIf n = 2 => {0,1,3,2} `{0 , 1 , 1 + pow(2,1) , 0 + pow(2,1)}`\\nIf n = 3 => {0,1,3,2,6,7,5,4} `{0 , 1 , 3 , 2 , 2 + pow(2,2) , 3 + pow(2,2) , 1 + pow(2,2) , 0 + pow(2,2)}`\\n\\nHere you can observe a pattern !!\\n\\nAt each step where we\\'re supposed to calculate the gray code of `i` , **Reverse the gray code list of i-1 and add the value pow(2,i-1) to all the elements of the reversed list. Append the modified and reversed list to the (i-1) list.**\\n\\n## Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res{0};\\n        for(int i = 1; i <= n; i++) {\\n            vector<int> rev = res;\\n            reverse(begin(rev), end(rev));\\n            int val = pow(2,i-1);\\n            for(int v : rev) res.push_back(v+val);\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n\\n        for(int i = 1; i <= n; i++){\\n            List<Integer> rev = new ArrayList<>(list);\\n            Collections.reverse(rev);\\n            int val = (int)Math.pow(2,i-1);\\n            for(int v : rev) list.add(v+val);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\n\\n## Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res{0};\\n        for(int i = 1; i <= n; i++) {\\n            vector<int> rev = res;\\n            reverse(begin(rev), end(rev));\\n            int val = pow(2,i-1);\\n            for(int v : rev) res.push_back(v+val);\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n\\n        for(int i = 1; i <= n; i++){\\n            List<Integer> rev = new ArrayList<>(list);\\n            Collections.reverse(rev);\\n            int val = (int)Math.pow(2,i-1);\\n            for(int v : rev) list.add(v+val);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630427,
                "title": "2-lines-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>current;\\n\\t\\t/*\\n\\t\\t0 1 2 3 4 5 6 7 -- in range(0,2^n-1) \\n\\t\\t0 1 3 2 6 7 5 4 - required answer order(now observe difference with xor\\n\\t\\t--------------------------------------------------\\n\\t\\t0 0 1 1 2 2 3 3  - for getting these values i >> 1\\n\\t\\t*/\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            current.push_back(i ^ i>>1);\\n        }\\n        return current;\\n        \\n    }\\n};\\n```\\n**Find helpful Upvote it**\\n**For Detailed DSA Applications refer to respective README files**\\nhttps://github.com/teja963/Advanced-DSA",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>current;\\n\\t\\t/*\\n\\t\\t0 1 2 3 4 5 6 7 -- in range(0,2^n-1) \\n\\t\\t0 1 3 2 6 7 5 4 - required answer order(now observe difference with xor\\n\\t\\t--------------------------------------------------\\n\\t\\t0 0 1 1 2 2 3 3  - for getting these values i >> 1\\n\\t\\t*/\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            current.push_back(i ^ i>>1);\\n        }\\n        return current;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334453,
                "title": "java-simple-and-easy-iterative-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        \\n        List<Integer> codes = new ArrayList((1 << n));\\n        codes.add(0);\\n        \\n        for(int i = 0; i < n; i++){\\n            int size = codes.size();\\n            \\n            //most significant bit\\n            int msb = 1 << i;\\n            \\n            for(int j = size - 1; j >= 0; j--){\\n                //append msb\\n                int num = codes.get(j) | msb;\\n                \\n                codes.add(num);\\n            }\\n        }\\n        \\n        return codes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        \\n        List<Integer> codes = new ArrayList((1 << n));\\n        codes.add(0);\\n        \\n        for(int i = 0; i < n; i++){\\n            int size = codes.size();\\n            \\n            //most significant bit\\n            int msb = 1 << i;\\n            \\n            for(int j = size - 1; j >= 0; j--){\\n                //append msb\\n                int num = codes.get(j) | msb;\\n                \\n                codes.add(num);\\n            }\\n        }\\n        \\n        return codes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319275,
                "title": "python-easy-to-understand-3-line-recursive-solution",
                "content": "We see the pattern:\\n```\\n1: [0,1]\\n2: [00,01,11,10]\\n3: [000,001,011,010,110,111,101,100]\\n```\\nNotice the following recursive relation:\\n```\\ngrayCode(n) = [grayCode(n-1), new_part]\\n```\\n`new_part` consists of `1` added to the left of each item in reversed sequence of `grayCode(n-1)`.\\n\\nThis leads us to the following code:\\n```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n==1: return [0,1]\\n        prev = self.grayCode(n-1)\\n        return prev + [2**(n-1)+i for i in prev[::-1]]\\n```\\nTime complexity: `O(n)`.",
                "solutionTags": [],
                "code": "```\\n1: [0,1]\\n2: [00,01,11,10]\\n3: [000,001,011,010,110,111,101,100]\\n```\n```\\ngrayCode(n) = [grayCode(n-1), new_part]\\n```\n```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n==1: return [0,1]\\n        prev = self.grayCode(n-1)\\n        return prev + [2**(n-1)+i for i in prev[::-1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309277,
                "title": "easy-to-understand-solution",
                "content": "The idea is that we can leverage the fact that the last bits reverse when we move from n-1 to n and we have to concat the bit `1` as the prefix.\\n\\nEg:\\nFor `n=2`: Gray-code sequence is\\n```\\n00\\n01\\n11\\n10\\n```\\n\\nNow for `n=3` we copy the above sequence in reverse order and add prefix `0` to existing codes and `1` to newly generated codes\\n```\\n0 | 00\\n0 | 01\\n0 | 11\\n0 | 10\\n-------\\n1 | 10\\n1 | 11\\n1 | 01\\n1 | 00\\n```\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        String[] grayCodes = binaryGrayCodes(n);\\n        List<Integer> result = new ArrayList<>();\\n        for(String grayCode: grayCodes){\\n            result.add(Integer.parseInt(grayCode,2));\\n        }\\n        return result;\\n    }\\n    \\n    private String[] binaryGrayCodes(int n) {\\n        int total = (int) Math.pow(2,n);\\n        String[] grayCode = new String[total];\\n        grayCode[0]=\"0\";\\n        grayCode[1]=\"1\";\\n        \\n        for(int i=2;i<=n;i++){\\n            int start = (int) Math.pow(2,i-1);\\n            for(int j=0;j<start;j++){\\n                if(grayCode[start-j-1].length()<i-1){\\n                    grayCode[start-j-1] = \"0\".concat(grayCode[start-j-1]);\\n                }\\n                grayCode[start+j]=\"1\".concat(grayCode[start-j-1]);\\n            }\\n        }\\n        \\n        return grayCode;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n00\\n01\\n11\\n10\\n```\n```\\n0 | 00\\n0 | 01\\n0 | 11\\n0 | 10\\n-------\\n1 | 10\\n1 | 11\\n1 | 01\\n1 | 00\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        String[] grayCodes = binaryGrayCodes(n);\\n        List<Integer> result = new ArrayList<>();\\n        for(String grayCode: grayCodes){\\n            result.add(Integer.parseInt(grayCode,2));\\n        }\\n        return result;\\n    }\\n    \\n    private String[] binaryGrayCodes(int n) {\\n        int total = (int) Math.pow(2,n);\\n        String[] grayCode = new String[total];\\n        grayCode[0]=\"0\";\\n        grayCode[1]=\"1\";\\n        \\n        for(int i=2;i<=n;i++){\\n            int start = (int) Math.pow(2,i-1);\\n            for(int j=0;j<start;j++){\\n                if(grayCode[start-j-1].length()<i-1){\\n                    grayCode[start-j-1] = \"0\".concat(grayCode[start-j-1]);\\n                }\\n                grayCode[start+j]=\"1\".concat(grayCode[start-j-1]);\\n            }\\n        }\\n        \\n        return grayCode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30009,
                "title": "11-lines-c-solution-4ms",
                "content": "    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int  len = 1 << n;\\n            vector<int> res(len,0);\\n            for(int i = 0;i != len;++i){\\n                res[i] =i ^ (i >> 1); \\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int  len = 1 << n;\\n            vector<int> res(len,0);\\n            for(int i = 0;i != len;++i){\\n                res[i] =i ^ (i >> 1); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30046,
                "title": "ac-python-44ms-solution",
                "content": "    def grayCode(self, n):\\n        ans = [0]\\n        for i in xrange(n):\\n            for j in xrange(len(ans) - 1, -1, -1):\\n                ans.append(1 << i | ans[j])\\n        return ans\\n\\n\\n    # 12 / 12 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 92.86%\\n\\n\\nAppend a bit of 1 in front of on every number to generate next batch.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def grayCode(self, n):\\n        ans = [0]\\n        for i in xrange(n):\\n            for j in xrange(len(ans) - 1, -1, -1):\\n                ans.append(1 << i | ans[j])\\n        return ans\\n\\n\\n    # 12 / 12 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 92.86%\\n\\n\\nAppend a bit of 1 in front of on every number to generate next batch.",
                "codeTag": "Python3"
            },
            {
                "id": 30079,
                "title": "this-is-the-standard-backtracking-method",
                "content": "Well, I write a method using standard backtracking way. \\n\\n    class Solution {\\n    public:\\n        int Bit2Int(bitset<32> &c, int n)\\n        {\\n            int sum = 0;\\n            for(int i = 0; i < n; i++)\\n            {\\n                sum <<= 1;\\n                sum += c[i];\\n            }\\n            return sum;\\n        }\\n    \\n        void backtrack(bitset<32> &c, int k, int n, vector<int> &result)\\n        {\\n            if(++k == n)\\n                result.push_back(Bit2Int(c, n));\\n            else\\n            {\\n                backtrack(c, k, n, result);\\n                c.flip(k);\\n                backtrack(c, k, n, result);\\n            }\\n        }\\n    \\n        vector<int> grayCode(int n) {\\n            if(!n)\\n                return vector<int>{0};\\n            else if(n == 1)\\n                return vector<int>{0, 1};\\n            vector<int> result;\\n            bitset<32> c;\\n            backtrack(c, -1, n, result);\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        int Bit2Int(bitset<32> &c, int n)\\n        {\\n            int sum = 0;\\n            for(int i = 0; i < n; i++)\\n            {\\n                sum <<= 1;\\n                sum += c[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3065429,
                "title": "simple-solution-in-c-with-explanation",
                "content": "# Intuition\\nThis was a pattern I noticed on writing out some examples:\\nn=1 -> 0,1\\nn=2 -> **0,1**,3,2\\nn=3 -> **0,1,3,2**,6,7,5,4\\nn=4 -> **0,1,3,2,6,7,5,4**,12,13,15,14,10,11,9,8\\n\\nNoticed for all cases above n>1, it took the first part from the previous case for n-1 and for the remaining half, the values were formed by going through the list in reverse order and adding a factor(pow(2,n-1)) to each number.\\n\\nFor n=3,\\nthe first bold half is taken from n=2 -> 0,1,3,2 and we added 4 (pow(2,2)) to each number from the reverse order. i.e we appended 2+4=**6**, 3+4=**7**, 1+4=**5**, 0+4=**4** in that specific order.\\n\\n# Approach\\nWe used the logic derived at the intution to implement the code below:\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        \\n        int iteration = 1;\\n        int fac = 1;\\n        vector<int> result{0, 1};\\n\\n        for( ; iteration < n ; iteration++ ){\\n            fac = fac*2;\\n            int l = result.size()-1;\\n            for( ; l>=0 ; l-- ){\\n                int val = result[l] + fac;\\n                result.push_back(val);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        \\n        int iteration = 1;\\n        int fac = 1;\\n        vector<int> result{0, 1};\\n\\n        for( ; iteration < n ; iteration++ ){\\n            fac = fac*2;\\n            int l = result.size()-1;\\n            for( ; l>=0 ; l-- ){\\n                int val = result[l] + fac;\\n                result.push_back(val);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769433,
                "title": "java-solutionjs-easy",
                "content": "```\\nclass Solution \\n{\\n\\tpublic List<Integer> grayCode(int n) \\n\\t{\\n\\t\\t// 0: [0]\\n\\t\\t// 1: [0,1]\\n\\t\\t// 2: [0,1,3,2]\\n\\t\\t// 3: [0,1,3,2,6,7,5,4]\\n\\t\\t// 4: [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\\n\\n\\t\\tint edge = 1 << n; // (1 << n) == 2 ** n\\n\\t\\tInteger[] ans = new Integer[edge];\\n\\t\\tans[0] = 0;\\n\\t\\tint lngth = 1; // is the length of the previous block\\n\\t\\tint i, j = 1;\\n\\n\\t\\twhile (j != edge)\\n\\t\\t{\\n\\t\\t\\tlngth = j;\\n\\n\\t\\t\\tfor(i = lngth - 1; i >= 0; i--)\\n\\t\\t\\t\\tans[j++] = ans[i] | lngth; // ans[i] | lngth  == ans[i] + lngth \\n\\t\\t}\\n\\n\\t\\treturn Arrays.asList(ans);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n\\tpublic List<Integer> grayCode(int n) \\n\\t{\\n\\t\\t// 0: [0]\\n\\t\\t// 1: [0,1]\\n\\t\\t// 2: [0,1,3,2]\\n\\t\\t// 3: [0,1,3,2,6,7,5,4]\\n\\t\\t// 4: [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\\n\\n\\t\\tint edge = 1 << n; // (1 << n) == 2 ** n\\n\\t\\tInteger[] ans = new Integer[edge];\\n\\t\\tans[0] = 0;\\n\\t\\tint lngth = 1; // is the length of the previous block\\n\\t\\tint i, j = 1;\\n\\n\\t\\twhile (j != edge)\\n\\t\\t{\\n\\t\\t\\tlngth = j;\\n\\n\\t\\t\\tfor(i = lngth - 1; i >= 0; i--)\\n\\t\\t\\t\\tans[j++] = ans[i] | lngth; // ans[i] | lngth  == ans[i] + lngth \\n\\t\\t}\\n\\n\\t\\treturn Arrays.asList(ans);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104825,
                "title": "c-short-recursive-approach-without-bit-manipulation",
                "content": "To calculate Graycode(n), we basically need to prefix 0 to each number GrayCode(n-1), prefix 1 to each number in reversed GrayCode(n-1), and add them up. \\n\\nPrefixing 1 can be done by adding 2^(n-1).\\n\\nExample GrayCode(2) to GrayCode(3) :\\n0 00\\n0 01\\n0 11\\n0 10\\n1 10\\n1 11\\n1 01\\n1 00\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1){\\n            return {0,1};\\n        }\\n        vector<int> ans = grayCode(n-1);\\n        int ans_size = ans.size();\\n        int a = pow(2,n-1);\\n        for(int i=ans_size-1;i>=0; i--){\\n            ans.push_back(ans[i]+a);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nI hope this helps :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1){\\n            return {0,1};\\n        }\\n        vector<int> ans = grayCode(n-1);\\n        int ans_size = ans.size();\\n        int a = pow(2,n-1);\\n        for(int i=ans_size-1;i>=0; i--){\\n            ans.push_back(ans[i]+a);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492687,
                "title": "java-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        \\n        if(n == 1)\\n        {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(0);list.add(1);\\n            return list;\\n        }\\n        \\n        List<Integer> pres = grayCode(n-1);\\n        List<Integer> mres = new ArrayList<>();\\n        \\n        for(int i=0;i<pres.size();i++)\\n            mres.add(0+2*pres.get(i));\\n        \\n        for(int i=pres.size()-1;i>=0;i--)\\n            mres.add(1+2*pres.get(i));\\n        \\n        return mres;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        \\n        if(n == 1)\\n        {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(0);list.add(1);\\n            return list;\\n        }\\n        \\n        List<Integer> pres = grayCode(n-1);\\n        List<Integer> mres = new ArrayList<>();\\n        \\n        for(int i=0;i<pres.size();i++)\\n            mres.add(0+2*pres.get(i));\\n        \\n        for(int i=pres.size()-1;i>=0;i--)\\n            mres.add(1+2*pres.get(i));\\n        \\n        return mres;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309954,
                "title": "c-mirroring-previous-result-solution-explained-100-time-95-space",
                "content": "The tricky part of this problem is to spot a pattern.\\n\\nLet\\'s assume we have a given 2<sup>n</sup> elements that correctly match the requirements, like:\\n\\n```cpp\\n0, 1, 3, 2\\n```\\n\\nYou can find the next expected 2<sup>n</sup> of them (thus going up to 2<sup>n + 1</sup>) by mirroring those numbers and adding 2<sup>n</sup> to all of them, thus obtaining:\\n\\n```cpp\\n0, 1, 3, 2, 6, 7, 5, 4\\n// ie: 0, 1, 3, 2, 2 + 4, 3 + 4, 1 + 4, 0 + 4\\n```\\n\\nNow, we that in mind, we can start working on what we know we need to do, creating a variable `res` already of the correct size (2<sup>n - 1</sup> or rather `2 << --n`), to avoid reallocations.\\n\\nWe will then loop `n + 1` times, with `a` and `b` (the latter initially set to `0`) and:\\n* set `a` to be `b + 1` -  both the starting index and the added value of our sequence;\\n* right shift `b` by `1` position;\\n* add `1` to `b` as its least significant bit;\\n* loop `a` times with `j` and having `k` initially set to `b`, increasing `j` and decreasing `k` at each iteration and:\\n\\t* set `res[k]` to be `res[j] + a` (with `j` and `k` pointing at mirrored cells in the same subsequence).\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        // support variables\\n        vector<int> res(2 << --n);\\n        for (int i = 0, a, b = 0; i <= n; i++) {\\n            // updating variables\\n            a = b + 1;\\n            b <<= 1;\\n            ++b;\\n            // building the next a elements as a mirror of the previous a, plus a\\n            for (int j = 0, k = b; j < a; j++, k--) res[k] = res[j] + a;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n0, 1, 3, 2\\n```\n```cpp\\n0, 1, 3, 2, 6, 7, 5, 4\\n// ie: 0, 1, 3, 2, 2 + 4, 3 + 4, 1 + 4, 0 + 4\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        // support variables\\n        vector<int> res(2 << --n);\\n        for (int i = 0, a, b = 0; i <= n; i++) {\\n            // updating variables\\n            a = b + 1;\\n            b <<= 1;\\n            ++b;\\n            // building the next a elements as a mirror of the previous a, plus a\\n            for (int j = 0, k = b; j < a; j++, k--) res[k] = res[j] + a;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308565,
                "title": "c-simple-and-short-solution-no-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res = {0};\\n        int size;\\n        \\n        for (int i = 0; i < n; i++) {\\n            size = res.size();\\n            for (int j = size - 1; j >= 0; j--) {\\n                res.push_back(res[j] | 1 << i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res = {0};\\n        int size;\\n        \\n        for (int i = 0; i < n; i++) {\\n            size = res.size();\\n            for (int j = size - 1; j >= 0; j--) {\\n                res.push_back(res[j] | 1 << i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504836,
                "title": "javascript-solution",
                "content": "### The idea\\n*Based on top voted discussion*\\nSimulation:\\n| n=0 | n=1 | n=2 | n=3 |\\n|----:|----:|----:|----:|\\n| 000 | 000 | 000 | 000 |\\n|     | 001 | 001 | 001 |\\n|     |     | 011 | 011 |\\n|     |     | 010 | 010 |\\n|     |     |     | **110** |\\n|     |     |     | **111** |\\n|     |     |     | **101** |\\n|     |     |     | **100** |\\n1. From observation, we can see that at every level, we keep the previous results as the first part. The second part is just adding `1` at the begining in reverse order.\\n\\n``` javascript\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar grayCode = function(n) {\\n    let arr = [0];\\n    for (let i=0;i<n;i++) {\\n        for (let j=arr.length-1;j>=0;j--) {\\n            arr.push(arr[j] | 1<<i);\\n        }\\n    }\\n    return arr;\\n};\\n```\\n**Shorter Ver.**\\n```\\nvar grayCode = function(n) {\\n    let arr = [0];\\n    for (let i=0;i<n;i++) {\\n        arr.push(...arr.map((v)=>v|1<<i).reverse());\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar grayCode = function(n) {\\n    let arr = [0];\\n    for (let i=0;i<n;i++) {\\n        for (let j=arr.length-1;j>=0;j--) {\\n            arr.push(arr[j] | 1<<i);\\n        }\\n    }\\n    return arr;\\n};\\n```\n```\\nvar grayCode = function(n) {\\n    let arr = [0];\\n    for (let i=0;i<n;i++) {\\n        arr.push(...arr.map((v)=>v|1<<i).reverse());\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485439,
                "title": "java-solution-with-explanation-7-lines-code",
                "content": "This problem is not complicated, we just need to find the regularity.\\nn = 1: (0, 1)-> (0,1);\\nn = 2: (00, 01, 11, 10)->(0, 1, 3, 2);\\nn = 3: (000, 001, 011, 010, 110, 111, 101, 100) -> (0, 1, 3, 2, 6, 7, 5, 4);\\n\\nAt first we compare n = 1 and n = 2. we find that :\\n0 appends (0,1) = (00, 01);  0 + 0 = 0, 0 + 1 = 1; \\nrevese (0,1) -> (1, 0)\\n1 appends (1,0) = (11, 10);  2 + 1= 3,  2 + 0 = 2; \\n\\nThen we compare n = 2 and n =3. we find that:\\n0 appends (00, 01, 11, 10) = (000, 001, 011, 010); 0 + 0 = 0, 0 + 1 = 1, 0 + 3 = 3, 0 + 2 = 2;\\nrevese (00, 01, 11, 10) -> (10, 11, 01, 00)\\n1 appends (10, 11, 01, 00) = (110, 111, 101, 100); 4 + 2 = 6, 4 + 3 = 7, 4 + 1 = 5, 4 + 0 = 4;\\nThe regularity is very obvious.\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        for(int i = 0; i < n; i++){\\n            for(int j = ans.size() - 1; j >= 0; j--){\\n                ans.add(ans.get(j) + (int)Math.pow(2, i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        for(int i = 0; i < n; i++){\\n            for(int j = ans.size() - 1; j >= 0; j--){\\n                ans.add(ans.get(j) + (int)Math.pow(2, i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393991,
                "title": "java-beats-100-with-explaination",
                "content": "```\\n/**\\n * n=0, \\u987A\\u5E8F:0\\n * n=1, \\u987A\\u5E8F:0,1\\n * n=2, \\u987A\\u5E8F:00,01,11,10\\n * n=3, \\u53EF\\u4EE5\\u8FD9\\u4E48\\u6784\\u6210,\\u7B2C\\u4E00\\u4E2A\\u6570\\u662F110(100 + 10),\\u5373\\u7B2Cn\\u4F4D\\u7F6E1,\\u52A0\\u4E0An=2\\u7684\\u6700\\u540E\\u4E00\\u4E2A\\u6570;\\u7B2C\\u4E8C\\u4E2A\\u6570\\u5C31\\u662F111(100+11),\\u5982\\u6B64\\u9006\\u5E8F\\u904D\\u5386\\u5B8Cn=2\\u7684\\u6240\\u6709\\u60C5\\u51B5\\u5373\\u53EF.\\n * n=4, \\u540Cn=3\\u7684\\u89C4\\u5F8B.\\n*/\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>(1<<n);\\n        res.add(0);\\n        if (n == 0) {\\n            return res;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            int lastIdx = res.size() - 1;\\n            int add = 1 << (i - 1);\\n            for (int j = lastIdx; j >= 0; j--) {\\n                res.add(add + res.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * n=0, \\u987A\\u5E8F:0\\n * n=1, \\u987A\\u5E8F:0,1\\n * n=2, \\u987A\\u5E8F:00,01,11,10\\n * n=3, \\u53EF\\u4EE5\\u8FD9\\u4E48\\u6784\\u6210,\\u7B2C\\u4E00\\u4E2A\\u6570\\u662F110(100 + 10),\\u5373\\u7B2Cn\\u4F4D\\u7F6E1,\\u52A0\\u4E0An=2\\u7684\\u6700\\u540E\\u4E00\\u4E2A\\u6570;\\u7B2C\\u4E8C\\u4E2A\\u6570\\u5C31\\u662F111(100+11),\\u5982\\u6B64\\u9006\\u5E8F\\u904D\\u5386\\u5B8Cn=2\\u7684\\u6240\\u6709\\u60C5\\u51B5\\u5373\\u53EF.\\n * n=4, \\u540Cn=3\\u7684\\u89C4\\u5F8B.\\n*/\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>(1<<n);\\n        res.add(0);\\n        if (n == 0) {\\n            return res;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            int lastIdx = res.size() - 1;\\n            int add = 1 << (i - 1);\\n            for (int j = lastIdx; j >= 0; j--) {\\n                res.add(add + res.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 280620,
                "title": "java-beats-100-and-100-memoryemory",
                "content": "reference \\uFF1Ahttps://en.wikipedia.org/wiki/Gray_code\\nBinary to Gray Code\\uFF1A    \\n![image](https://assets.leetcode.com/users/u2647/image_1557797884.png)\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        int len = (int) Math.pow(2, n);\\n        List<Integer> ans = new ArrayList<>(len);\\n        for (int i = 0; i < len; i++) {\\n            ans.add(i ^ (i >> 1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        int len = (int) Math.pow(2, n);\\n        List<Integer> ans = new ArrayList<>(len);\\n        for (int i = 0; i < len; i++) {\\n            ans.add(i ^ (i >> 1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279206,
                "title": "very-intuitive-o-n-c-solution-11-lines-explained-with-examples",
                "content": "Okay so this question is actually pretty simple once you figure out the pattern:\\n\\nfor 2:\\n00\\n01\\n11\\n10\\n\\nfor 3: (pay attention to how the right part is same as 2 until 5th line)\\n(0)-00\\n(0)-01\\n(0)-11\\n(0)-10 (you can see it is just reversed after this point)\\n(1)-10\\n(1)-11\\n(1)-01\\n(1)-00\\n\\nLikewise, for each step, you only have to go backwards in your vector and then add the newdigit which will be powers of 2 since it is binary count.\\n\\nExample:\\nif my current vector is {0,1,3,2} for n = 2, \\nthen for n = 3 --> {0,1,3,2, (2+4), (3+4), (1+4), (0+4)} --> {0,1,3,2,6,7,5,4}\\n\\n``` \\n    vector<int> grayCode(int n) {\\n        vector<int> gray;\\n        gray.push_back(0);\\n        int newdigit = 1;\\n        while(n>0){\\n            for(int i = gray.size() - 1; i >= 0; i--){\\n                gray.push_back(gray[i]+newdigit);\\n            }\\n            newdigit *= 2;\\n            n--;\\n        }\\n        return gray;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\n    vector<int> grayCode(int n) {\\n        vector<int> gray;\\n        gray.push_back(0);\\n        int newdigit = 1;\\n        while(n>0){\\n            for(int i = gray.size() - 1; i >= 0; i--){\\n                gray.push_back(gray[i]+newdigit);\\n            }\\n            newdigit *= 2;\\n            n--;\\n        }\\n        return gray;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261362,
                "title": "java-beats-100-in-time-and-100-in-space",
                "content": "```\\n    public List<Integer> grayCode(int n) {\\n        list.add(0);\\n        for(int i=0;i<n;i++){\\n            recur(i);\\n        }\\n        return list;\\n    }\\n    \\n    public void recur(int j){\\n        int diff = (int)Math.pow(2,j);\\n        int size = list.size();\\n        for(int i=size-1;i>=0;i--){\\n            int x = list.get(i);\\n            list.add(x+diff);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> grayCode(int n) {\\n        list.add(0);\\n        for(int i=0;i<n;i++){\\n            recur(i);\\n        }\\n        return list;\\n    }\\n    \\n    public void recur(int j){\\n        int diff = (int)Math.pow(2,j);\\n        int size = list.size();\\n        for(int i=size-1;i>=0;i--){\\n            int x = list.get(i);\\n            list.add(x+diff);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 210895,
                "title": "c-with-picture",
                "content": "For each new bit, we are reusing the existing gray code sequence. We are combining the new bit with the reflection of the existing sequence, so that newly added numbers comply with the 1-bit difference rule.\\n![image](https://assets.leetcode.com/users/votrubac/image_1546070487.png)\\n```\\nvector<int> grayCode(int n) {\\n  vector<int> res = { 0 };\\n  for (auto f = 1; n > 0; f <<= 1, --n)\\n    for (int j = f - 1; j >= 0; --j) \\n        res.push_back(res[j] + f);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> grayCode(int n) {\\n  vector<int> res = { 0 };\\n  for (auto f = 1; n > 0; f <<= 1, --n)\\n    for (int j = f - 1; j >= 0; --j) \\n        res.push_back(res[j] + f);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29933,
                "title": "o-2-n-time-complexity-o-1-space-with-my-explanation",
                "content": "The obvious way when I first saw this question is using backtracking/brute-force. By Grey Code definition, \\n1. from 0, I try to modify each bits from very right to left. \\n2. after modify this bits, If there is no such num in my hashSet, put it into hashSet and also result list, if there is such num in my hashSet, move to higher bits and repeat step 2, until get 2^n numbers\\n\\nI assume n bits must have a way to transfer 0-2^n-1 to gray code. The following is proof. \\nI use induction to proof this. So we proof If k bits can get 2^k gray code, then k+1 bits can get 2^(k+1) gray code. For the k + 1 bits gray codes, the first 2^k gray codes' highest bit is \"0\", with the same order of k bits's gray code. the second 2^k gray codes' highest bit is \"1\" with the symmetrical order of k bits' gray code. Such, we get the 2^(k+1) gray code.\\nFor this solution, time complexity is n*2^n, 2^n numbers and to get each numbers, at most n bits to modify.\\n\\nIt is far away from optimization. So I try another way. \\n```\\npublic class Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0; i < (1 << n); i++) {\\n            res.add(i ^ (i >> 1));\\n        }\\n        return res;\\n    }\\n}\\n```\\ni ^ (i >> 1) means for i-th gray code, we can get it by the following way:\\n1. invert bits if higher bit is \"1\"\\n2. keep the original bit if higher bit is \"0\"\\n\\nWhy? Generally because we get our gray code by \"recursive symmetry with 2^k\". \\nLet we take 6-th gray code as example. 6 is \"110\", The first bits \"1\" means 6-th gray code is on the second half part, in this part, second bit \"1\" shows 6-th gray code is on the second half part of second half part, third bit \"0\" shows the gray code is one the first half of the second half of the second part. By inverting, we can get symmetric position of 6-th, which is \"001\". Considering the 6-th is in the second part, also add 1 to the highest bit of \"001\", which leads to our 6-th gray code \"101\"",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0; i < (1 << n); i++) {\\n            res.add(i ^ (i >> 1));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29976,
                "title": "quite-simple-solution-accepted-as-best-in-c-well-explained",
                "content": "\\nIt's quite a math problem and the formula to convert **n** to its **gray code** is as follows:\\n\\n> grayCode = n^(n>>1)\\n\\nIf you never heard of this, please read [wiki][1] first and if you are still eager to understand this equation, you may check this [post][2] for reasoning details. \\n\\n- space cost O(2^n)\\n- time cost O(2^n)\\n\\n----------\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) \\n        {\\n            vector<int> v;\\n            for(int i = 0, a = 1<<n; i < a; ++i) v.push_back(i^(i>>1));\\n            return v;\\n        }\\n    };\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Gray_code\\n  [2]: https://www.quora.com/I-came-across-this-code-which-generates-the-nth-gray-code-number-G-n-n-n-1-How-can-we-proof-that-it-is-correct\\n  [3]: https://en.wikipedia.org/w/index.php?title=Gray_code&oldid=631353193#Converting_to_and_from_Gray_code",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) \\n        {\\n            vector<int> v;\\n            for(int i = 0, a = 1<<n; i < a; ++i) v.push_back(i^(i>>1));\\n            return v;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 30018,
                "title": "few-lines-of-java-code-1ms-no-recursion",
                "content": "    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        result.add(0);\\n\\t\\t\\n\\t\\tfor(int i=1; i<=n; i++){\\n        \\tint size = result.size()-1;\\n        \\tfor(int j=size; j>=0; j--){\\n        \\t\\tresult.add(result.get(j) | 1<<i-1);\\n        \\t}\\n        }\\n\\t\\treturn result;\\n    }",
                "solutionTags": [],
                "code": "    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        result.add(0);\\n\\t\\t\\n\\t\\tfor(int i=1; i<=n; i++){\\n        \\tint size = result.size()-1;\\n        \\tfor(int j=size; j>=0; j--){\\n        \\t\\tresult.add(result.get(j) | 1<<i-1);\\n        \\t}\\n        }\\n\\t\\treturn result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30035,
                "title": "simple-2ms-java-solution",
                "content": "    public class Solution {\\n        public List<Integer> grayCode(int n) {\\n            if(n == 0) return Arrays.asList(0);\\n            List<Integer> prev = grayCode(n-1);\\n            List<Integer> next = new ArrayList<Integer>(prev);\\n            int pow = 1 << (n-1);\\n            for(int i=prev.size()-1; i >= 0; i--){\\n                next.add(prev.get(i) | pow);\\n            }\\n            return next;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n) {\\n            if(n == 0) return Arrays.asList(0);\\n            List<Integer> prev = grayCode(n-1);\\n            List<Integer> next = new ArrayList<Integer>(prev);\\n            int pow = 1 << (n-1);\\n            for(int i=prev.size()-1; i >= 0; i--){\\n                next.add(prev.get(i) | pow);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30039,
                "title": "python-recursive-solution-easy-understanding",
                "content": "    class Solution(object):\\n\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n\\n        \"\"\"\\n        if n<1:\\n            return [0]\\n        if (n==1):\\n            return [0,1]\\n        res = self.grayCode( n-1)\\n        x=pow(2,n-1)\\n        for i in range(x-1,-1,-1):\\n            res.append(res[i]+x)\\n        return res",
                "solutionTags": [],
                "code": "    class Solution(object):\\n\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n\\n        \"\"\"\\n        if n<1:\\n            return [0]\\n        if (n==1):\\n            return [0,1]\\n        res = self.grayCode( n-1)\\n        x=pow(2,n-1)\\n        for i in range(x-1,-1,-1):\\n            res.append(res[i]+x)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 30087,
                "title": "backtracking-solution",
                "content": "        public static List<Integer> grayCode(int n) {\\n    \\t\\tList<Integer> code = new ArrayList<Integer>();\\n    \\t\\tcode.add(0);\\n    \\t\\tgenCodes(code,n,0,1<<n);\\n    \\t\\treturn code;\\n    \\t}\\n    \\tpublic static void genCodes(List<Integer> code, int n, int curr, int size) {\\n    \\t\\tif(code.size()==size) return;\\n    \\t\\tfor(int i=0;i<n;i++) {\\n    \\t\\t\\tint mask = 1<<i;\\n    \\t\\t\\tint el = (curr^mask);\\n    \\t\\t\\tif(!code.contains(el)) {\\n    \\t\\t\\t\\tcode.add(el);\\n    \\t\\t\\t\\tgenCodes(code,n,el,size);\\n    \\t\\t\\t\\tif(code.size()==size) return;\\n    \\t\\t\\t\\tcode.remove(new Integer(el));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "        public static List<Integer> grayCode(int n) {\\n    \\t\\tList<Integer> code = new ArrayList<Integer>();\\n    \\t\\tcode.add(0);\\n    \\t\\tgenCodes(code,n,0,1<<n);\\n    \\t\\treturn code;\\n    \\t}\\n    \\tpublic static void genCodes(List<Integer> code, int n, int curr, int size) {\\n    \\t\\tif(code.size()==size) return;\\n    \\t\\tfor(int i=0;i<n;i++) {\\n    \\t\\t\\tint mask = 1<<i;\\n    \\t\\t\\tint el = (curr^mask);\\n    \\t\\t\\tif(!code.contains(el)) {\\n    \\t\\t\\t\\tcode.add(el);\\n    \\t\\t\\t\\tgenCodes(code,n,el,size);\\n    \\t\\t\\t\\tif(code.size()==size) return;\\n    \\t\\t\\t\\tcode.remove(new Integer(el));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3362071,
                "title": "easy-java-solution-using-xor",
                "content": "# Intuition\\n* The problem requires us to generate a sequence of n-bit gray codes that satisfy the given conditions.\\n * The gray code sequence has the property that the binary representation of every adjacent integer differs by only one bit.\\n * The first integer is 0 and the last integer differs from the first integer by only one bit.\\n * We can generate the gray code sequence using the following approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe start with a list that contains only 0 as the first element.\\nThen, we iterate from 0 to (2^n - 1) and perform the following steps:\\n 1. We compute the XOR of the current index i with (i & -i).\\n     This operation flips the least significant bit that is set in i.\\n     For example, if i = 3 (011), then (i & -i) = 1 (001).\\n     So, num = num ^ (i & -i) will set the least significant bit of num to 1 if it is 0, and vice versa.\\n  2. We add the computed num to the answer list.\\n  3. Repeat steps 1 and 2 for all indices from 0 to (2^n - 1).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(2^n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        int num = 0;\\n        for (int i = 0; i < (1 << n); i++) {\\n            // Compute the XOR of the current index i with (i & -i) to generate the next gray code.\\n            num ^= i & (-i);\\n            // Add the generated gray code to the answer list.\\n            ans.add(num);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        int num = 0;\\n        for (int i = 0; i < (1 << n); i++) {\\n            // Compute the XOR of the current index i with (i & -i) to generate the next gray code.\\n            num ^= i & (-i);\\n            // Add the generated gray code to the answer list.\\n            ans.add(num);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196995,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        int cnt=1;\\n        vector<int>v;\\n        v.push_back(0);\\n        v.push_back(1);\\n        for(int i=1; i<n; i++){\\n            cnt*=2;\\n            int l=v.size();\\n            for(int j=l-1; j>=0; j--){\\n                v.push_back(v[j]+cnt);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        int cnt=1;\\n        vector<int>v;\\n        v.push_back(0);\\n        v.push_back(1);\\n        for(int i=1; i<n; i++){\\n            cnt*=2;\\n            int l=v.size();\\n            for(int j=l-1; j>=0; j--){\\n                v.push_back(v[j]+cnt);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185748,
                "title": "gray-code-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an initial list with 0\\n2. For each bit in n, starting from the 0th bit:\\n   1. Traverse the current list in reverse and add the current bit to each number by doing bitwise OR with (1 << i)\\n   2. This step is repeated until we have processed all the bits in n\\n3. Return the final list as the result\\n\\nExample: n = 2\\n\\n- Initial list: [0]\\n- 1st iteration: i = 0, [0, 1 | (1 << 0) = 1] = [0, 1]\\n- 2nd iteration: i = 1, [0, 1, 3 | (1 << 1) = 3, 2 | (1 << 1) = 2] = [0, 1, 3, 2]\\n- Result: [0, 1, 3, 2]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = [0]\\n        for i in range(n):\\n            for j in range(len(res) - 1, -1, -1):\\n                res.append(res[j] | (1 << i))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = [0]\\n        for i in range(n):\\n            for j in range(len(res) - 1, -1, -1):\\n                res.append(res[j] | (1 << i))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722095,
                "title": "c-simple-recursive-solution-backtracking",
                "content": "//for video explaination u can watch  pepcoding video on youtube\\n\\n           *    vector<string> solve(int n){\\n                   if(n==1){\\n                     return {\"0\",\"1\"};\\n                    }\\n        \\n             vector<string>ans=solve(n-1);\\n        \\n            vector<string> mainAns;\\n        \\n           for(int i=0;i<ans.size();i++){\\n            string s=ans[i];\\n              mainAns.push_back(\"0\"+s);\\n          }\\n          for(int i=ans.size()-1;i>=0;i--){\\n              string s=ans[i];\\n              mainAns.push_back(\"1\"+s);\\n          }\\n         return mainAns;\\n         }\\n        vector<int> grayCode(int n) {\\n            vector<string> strRes = solve(n);\\n           vector<int> result;\\n\\t\\t   // converting string to int \\n            for(int i=0;i<strRes.size();i++)\\n               {\\n              int val = stoi(strRes[i], 0, 2);\\n                 result.push_back(val);\\n             }\\n            return result;\\n            }\\n// in our problem we have binary-number-strings, we want them to convert to integers of base 10\\n\\nSTOI[string to integer] , stoi(string_to_be_converted , position[optional] , base of string : in our case its binary so we used 2)\\nFor more info, you can follow official documentation or the link given at the top..\\n       \\n      \\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "//for video explaination u can watch  pepcoding video on youtube\\n\\n           *    vector<string> solve(int n){\\n                   if(n==1){\\n                     return {\"0\",\"1\"};\\n                    }\\n        \\n             vector<string>ans=solve(n-1);\\n        \\n            vector<string> mainAns;\\n        \\n           for(int i=0;i<ans.size();i++){\\n            string s=ans[i];\\n              mainAns.push_back(\"0\"+s);\\n          }\\n          for(int i=ans.size()-1;i>=0;i--){\\n              string s=ans[i];\\n              mainAns.push_back(\"1\"+s);\\n          }\\n         return mainAns;\\n         }\\n        vector<int> grayCode(int n) {\\n            vector<string> strRes = solve(n);\\n           vector<int> result;\\n\\t\\t   // converting string to int \\n            for(int i=0;i<strRes.size();i++)\\n               {\\n              int val = stoi(strRes[i], 0, 2);\\n                 result.push_back(val);\\n             }\\n            return result;\\n            }\\n// in our problem we have binary-number-strings, we want them to convert to integers of base 10\\n\\nSTOI[string to integer] , stoi(string_to_be_converted , position[optional] , base of string : in our case its binary so we used 2)\\nFor more info, you can follow official documentation or the link given at the top..\\n       \\n      \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1407039,
                "title": "python-very-easy-solution-using-or-operator",
                "content": "Example where n=2:\\n==> Output = [0,1,3,2]\\n\\nStep 1: write the binary of the output.\\n              00 = 0\\n\\t\\t\\t  01 = 1\\n\\t\\t\\t  11 = 3\\n\\t\\t\\t  10 = 2\\nStep 2: If you can see the pattern i.e. it is just OR operation of its n-1 output array\\n\\t\\t\\twhich has been reversed with 2**n (n is the power of 2) \\n               like : for n=2:\\n\\t\\t\\t   n-1 output will be [0,1]\\n\\t\\t\\t   so we OR it with reverse array output i.e. [1,0]\\n\\t\\t\\t        01 OR 10 = 11 = 3\\n\\t\\t\\t\\t\\t00 OR 10 = 10 = 2\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        \\n        k = 2**n-1\\n        lt = [0]\\n        x=0\\n        while(x<n):\\n            p = len(lt)\\n            two = 2**x\\n            for i in range(p-1, -1, -1): #Reverse the output array of n-1\\n                lt.append(two | lt[i])\\n            x+=1\\n        return lt\\n```\\n\\n**Please Upvote this solution if you like......**",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        \\n        k = 2**n-1\\n        lt = [0]\\n        x=0\\n        while(x<n):\\n            p = len(lt)\\n            two = 2**x\\n            for i in range(p-1, -1, -1): #Reverse the output array of n-1\\n                lt.append(two | lt[i])\\n            x+=1\\n        return lt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309394,
                "title": "c-2-approaches-clear-explanation-with-code",
                "content": "```\\n//Approach-1 (Using Simple Recursion)\\n/*\\n    Example : n = 2\\n    helper(n-1) calls-> helper(1)\\n    \\n    Now, helper(1) returns {\"0\", \"1\"}; Which is correct gray code sequence for n = 1 (# elements = 2^1)\\n    \\n    Now, juts append \"0\" to each element , you will get {\"00\", \"01\"} which is Gray code as well\\n    because each element differ in only 1 bit  ----> Result1\\n    \\n    Now, juts append \"1\" to each element , you will get {\"10\", \"11\"} which is Gray code as well\\n    because each element differ in only 1 bit  ----> Result2\\n    \\n    So, after combining Result1 and Result2 (for n = 2),  {\"00\", \"01\", \"10\", \"11\"}\\n    BUT, you notice that if we combine them, the 1st and 2nd string differ in 2 bits i.e. \"01\", \"10\"\\n    SO, \\n    instead of combining them face to face, reverse the Result2 and then combine it with Result1.\\n    \\n    That\\'s why my 2nd for loop below starts from i = temp.size()-1 and goes till i >=0 .\\n    \\n*/\\nclass Solution {\\npublic:\\n    vector<string> helper(int n) {\\n        if(n == 1) {\\n            return {\"0\", \"1\"};\\n        }\\n        \\n        vector<string> temp = helper(n-1); //To get the result of n, we fetch result from (n-1)\\n        \\n        vector<string> padded;\\n        \\n        for(int i = 0; i<temp.size(); i++) {\\n            padded.push_back(\"0\" + temp[i]); //Just add \"0\" in the beginning\\n        }\\n        \\n        for(int i = temp.size()-1; i >= 0; i--) {\\n            padded.push_back(\"1\" + temp[i]); //Just add \"1\" in the beginning\\n        }\\n        \\n        return padded;\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        vector<string> result = helper(n);\\n        \\n        vector<int> finalR;\\n        \\n        //Just convert them to integer and you got your answer\\n        for(string &s : result) {\\n            bitset<32> bt(s);\\n            finalR.push_back(bt.to_ulong());\\n        }\\n        return finalR;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2\\nclass Solution {\\npublic:\\n    vector<int> result;\\n    void helper(bitset<32>& bt, int n) {\\n        if(n == 0) {\\n            //It means we have generate all n elements\\n            result.push_back(bt.to_ulong());\\n            return;\\n        }\\n        \\n        //Generate the remaining (n-1) numbers from bt\\n        helper(bt, n-1);\\n        \\n        //flip the (n-1)th bit (to create a difference of just one bit)\\n        bt.flip(n-1);\\n        \\n        //Generate the remaining (n-1) numbers from bt but this time (n-1)th bit flipped (to create a difference of just one bit)\\n        helper(bt, n-1);\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        bitset<32> bt; //by default all bits are 0 i.e. {0000000.....000}\\n        \\n        result.clear();\\n        \\n        helper(bt, n);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Using Simple Recursion)\\n/*\\n    Example : n = 2\\n    helper(n-1) calls-> helper(1)\\n    \\n    Now, helper(1) returns {\"0\", \"1\"}; Which is correct gray code sequence for n = 1 (# elements = 2^1)\\n    \\n    Now, juts append \"0\" to each element , you will get {\"00\", \"01\"} which is Gray code as well\\n    because each element differ in only 1 bit  ----> Result1\\n    \\n    Now, juts append \"1\" to each element , you will get {\"10\", \"11\"} which is Gray code as well\\n    because each element differ in only 1 bit  ----> Result2\\n    \\n    So, after combining Result1 and Result2 (for n = 2),  {\"00\", \"01\", \"10\", \"11\"}\\n    BUT, you notice that if we combine them, the 1st and 2nd string differ in 2 bits i.e. \"01\", \"10\"\\n    SO, \\n    instead of combining them face to face, reverse the Result2 and then combine it with Result1.\\n    \\n    That\\'s why my 2nd for loop below starts from i = temp.size()-1 and goes till i >=0 .\\n    \\n*/\\nclass Solution {\\npublic:\\n    vector<string> helper(int n) {\\n        if(n == 1) {\\n            return {\"0\", \"1\"};\\n        }\\n        \\n        vector<string> temp = helper(n-1); //To get the result of n, we fetch result from (n-1)\\n        \\n        vector<string> padded;\\n        \\n        for(int i = 0; i<temp.size(); i++) {\\n            padded.push_back(\"0\" + temp[i]); //Just add \"0\" in the beginning\\n        }\\n        \\n        for(int i = temp.size()-1; i >= 0; i--) {\\n            padded.push_back(\"1\" + temp[i]); //Just add \"1\" in the beginning\\n        }\\n        \\n        return padded;\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        vector<string> result = helper(n);\\n        \\n        vector<int> finalR;\\n        \\n        //Just convert them to integer and you got your answer\\n        for(string &s : result) {\\n            bitset<32> bt(s);\\n            finalR.push_back(bt.to_ulong());\\n        }\\n        return finalR;\\n    }\\n};\\n```\n```\\n//Approach-2\\nclass Solution {\\npublic:\\n    vector<int> result;\\n    void helper(bitset<32>& bt, int n) {\\n        if(n == 0) {\\n            //It means we have generate all n elements\\n            result.push_back(bt.to_ulong());\\n            return;\\n        }\\n        \\n        //Generate the remaining (n-1) numbers from bt\\n        helper(bt, n-1);\\n        \\n        //flip the (n-1)th bit (to create a difference of just one bit)\\n        bt.flip(n-1);\\n        \\n        //Generate the remaining (n-1) numbers from bt but this time (n-1)th bit flipped (to create a difference of just one bit)\\n        helper(bt, n-1);\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        bitset<32> bt; //by default all bits are 0 i.e. {0000000.....000}\\n        \\n        result.clear();\\n        \\n        helper(bt, n);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308590,
                "title": "c-recursive-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n == 1) return vector<int>{0,1};\\n        vector<int>prev = grayCode(n-1);\\n        \\n        for(int i=prev.size()-1;i>=0;i--)\\n            prev.push_back(prev[i]+pow(2,n-1));\\n        \\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n == 1) return vector<int>{0,1};\\n        vector<int>prev = grayCode(n-1);\\n        \\n        for(int i=prev.size()-1;i>=0;i--)\\n            prev.push_back(prev[i]+pow(2,n-1));\\n        \\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773096,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> ans;\\n        for(int i=0;i<(1<<n);i++){\\n            ans.push_back(i^(i>>1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> ans;\\n        for(int i=0;i<(1<<n);i++){\\n            ans.push_back(i^(i>>1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736419,
                "title": "fastest-solution-c",
                "content": "vector<int> grayCode(int n) {\\n        int c=pow(2,n);\\n        vector<int> ans(c);\\n        for(int i=0;i<c;i++)\\n            ans[i]=i^(i>>1);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "vector<int> grayCode(int n) {\\n        int c=pow(2,n);\\n        vector<int> ans(c);\\n        for(int i=0;i<c;i++)\\n            ans[i]=i^(i>>1);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 702123,
                "title": "java-0ms-three-simple-approaches",
                "content": "# Approach 1: Dynamic Programming\\n`grayCode(n) = (1 << n - 1) | each code in grayCode(n - 1))`\\n``` java\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n        code.add(0);\\n\\n        for (int mask = 0; mask < n; mask++) {\\n            for (int prev = code.size() - 1; prev >= 0; prev--) {\\n                code.add((1 << mask) | code.get(prev));\\n            }\\n        }\\n\\n        return code;\\n    }\\n}\\n```\\n**Complexity Analysis**\\nTime complexity: O(2^n).\\nSpace complexity: O(1) excluding the output list.\\n# Approach 2: Iterative\\n```\\nwhile (count < (1 << n))\\n    1st first change the rightmost bit\\n    or\\n    2st second change the left bit of the rightmost 1 bit\\n```\\n</br>\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n\\n        int prev = 0;\\n        for (int i = 0; i < 1 << n; i++) {\\n            prev ^= (i & 1) == 1 ? 1 : (prev & -prev) << 1;\\n            code.add(prev);\\n        }\\n\\n        return code;\\n    }\\n}\\n```\\n**Complexity Analysis**\\nTime complexity: O(2^n)\\nSpace complexity: O(1)\\n# Approach 3: Formula\\nRefer to [wiki/gray code](https://en.wikipedia.org/wiki/Gray_code).\\n```\\nBINARYTOGRAY(num)\\n    return num ^ (num >> 1)\\n```\\n</br>\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n\\n        // i-th code sequence of the graycode\\n        for (int i = 0; i < 1 << n; i++) {\\n            code.add(i ^ (i >> 1));\\n        }\\n\\n        return code;\\n    }\\n}\\n```\\n**Complexity Analysis**\\nTime complexity: O(2^n)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n        code.add(0);\\n\\n        for (int mask = 0; mask < n; mask++) {\\n            for (int prev = code.size() - 1; prev >= 0; prev--) {\\n                code.add((1 << mask) | code.get(prev));\\n            }\\n        }\\n\\n        return code;\\n    }\\n}\\n```\n```\\nwhile (count < (1 << n))\\n    1st first change the rightmost bit\\n    or\\n    2st second change the left bit of the rightmost 1 bit\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n\\n        int prev = 0;\\n        for (int i = 0; i < 1 << n; i++) {\\n            prev ^= (i & 1) == 1 ? 1 : (prev & -prev) << 1;\\n            code.add(prev);\\n        }\\n\\n        return code;\\n    }\\n}\\n```\n```\\nBINARYTOGRAY(num)\\n    return num ^ (num >> 1)\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n\\n        // i-th code sequence of the graycode\\n        for (int i = 0; i < 1 << n; i++) {\\n            code.add(i ^ (i >> 1));\\n        }\\n\\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651316,
                "title": "python3-easy-to-understand-beats-99-41-solutions",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 0:\\n            return [0]\\n\\n        result = [0,1]\\n        iterations = 1\\n\\t\\t# calculate till row-1, reverse result and add 2^(iteration -1)\\n        # [0,1] + [1+2,0+2] => [0,1,3,2]\\n        # [0,1,3,2] + [2 + 4, 3 + 4, 1 + 4, 0 + 4] => [0,1,3,2,6,7,5,4]\\n        while iterations < n:\\n            iterations += 1\\n            temp = result\\n            increment_val = 2 ** (iterations-1)\\n            new_array = []\\n            for i in range(len(temp)-1, -1, -1):\\n                result.append(temp[i] + increment_val)\\n        \\n        return result\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 0:\\n            return [0]\\n\\n        result = [0,1]\\n        iterations = 1\\n\\t\\t# calculate till row-1, reverse result and add 2^(iteration -1)\\n        # [0,1] + [1+2,0+2] => [0,1,3,2]\\n        # [0,1,3,2] + [2 + 4, 3 + 4, 1 + 4, 0 + 4] => [0,1,3,2,6,7,5,4]\\n        while iterations < n:\\n            iterations += 1\\n            temp = result\\n            increment_val = 2 ** (iterations-1)\\n            new_array = []\\n            for i in range(len(temp)-1, -1, -1):\\n                result.append(temp[i] + increment_val)\\n        \\n        return result\\n",
                "codeTag": "Java"
            },
            {
                "id": 475200,
                "title": "python-a-very-very-easy-understanding-solution",
                "content": "# I think this python version is more easy to understand\\n\\n## explain\\nAt first glance, we find that for a gray code sequence  with n = 1 `0, 1`, its reversed sequence `1, 0` is also a gray code sequence too. \\n\\nWe can add `1` to the front of every element,  and this new sequence `10, 11` is also a gray code sequence.  It is also valid if we add `0`s to the sequence. `00, 01`.\\n\\nSince the first element of sequence is as same as the last one of its reverse, we can find that we can get a gray code sequence with n = 2 by add zeros to the sequence of n=1\\nand ones to its reverse. That are `00, 01` and `11, 10`.  Then we concatenate them to get the result -- `00, 01, 11, 10`.\\n\\nThe general scheme is   \\n\\n`seq(n) =  concatenate(  padding seq(n-1) with zeros,   padding  seq(n-1)\\'s reverse with ones )`\\n\\n## example\\n\\n1.   `01, 10`  -- reverse --> `10,  01`\\n2.   `01, 10`  --padding with zeros--> `001, 010`\\n       `10,  01` --padding with ones--> `110, 101`\\n3.    `001, 010` + `110, 101`  --concatenate--> `001, 010, 110, 101`\\n\\n## tip:\\nA number padded with zero is still itself, and is equal to plus `pow(2, n)` if it is padded with one at `n th` bit.  \\n\\n## code:\\n```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = [0]\\n        bit = 1\\n        while n > 0:\\n            layer = res[::-1]\\n            for i in layer:\\n                res.append(i+bit)\\n            bit += bit\\n            n -= 1\\n        return res      \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = [0]\\n        bit = 1\\n        while n > 0:\\n            layer = res[::-1]\\n            for i in layer:\\n                res.append(i+bit)\\n            bit += bit\\n            n -= 1\\n        return res      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 441028,
                "title": "c-0ms-beats-100-on-time-and-space-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n\\t    // Total number of combinations.\\n        int totalCombos = (int)pow(2, n);\\n        vector<int> ourVec;\\n        v.reserve(totalCombos);\\n        for (int i{}; i < totalCombos; ++i) {\\n\\t\\t\\tourVec.push_back(i^(i>>1));\\n\\t\\t}\\n        return ourVec;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n\\t    // Total number of combinations.\\n        int totalCombos = (int)pow(2, n);\\n        vector<int> ourVec;\\n        v.reserve(totalCombos);\\n        for (int i{}",
                "codeTag": "Java"
            },
            {
                "id": 354466,
                "title": "simple-python-solution-dfs",
                "content": "Not every path leads to the complete combination. eg.\\n(n = 3) 000 -> 001 -> 011 -> 111 -> 110 -> 100 -> 101 -> X\\n\\nThe goal is to find a path which reaches the level == 2^n\\nRevert bit one at a time (always from the right most one) and append to the ans list if it is not already.\\nIf the len(ans) == target, stop.\\n\\n\\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        targetLevel = 2**n\\n        ans = []\\n        \\n        self.DFS(n, ans, 0, 1, targetLevel)   # Start with number = 0 (000), level = 1\\n        \\n        return ans\\n    \\n    \\n    def DFS(self, n, ans, num, level, targetLevel):\\n        if num in ans:\\n            return\\n        \\n        ans.append(num)\\n        \\n        if level == targetLevel:\\n            return\\n        \\n        for i in range(0, n):\\n            self.DFS(n, ans, num ^ (1 << i), level+1, targetLevel)  # num ^ (1 << i): revert a bit at a time\\n            \\n            if len(ans) == targetLevel: return  # result found. Stop.\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        targetLevel = 2**n\\n        ans = []\\n        \\n        self.DFS(n, ans, 0, 1, targetLevel)   # Start with number = 0 (000), level = 1\\n        \\n        return ans\\n    \\n    \\n    def DFS(self, n, ans, num, level, targetLevel):\\n        if num in ans:\\n            return\\n        \\n        ans.append(num)\\n        \\n        if level == targetLevel:\\n            return\\n        \\n        for i in range(0, n):\\n            self.DFS(n, ans, num ^ (1 << i), level+1, targetLevel)  # num ^ (1 << i): revert a bit at a time\\n            \\n            if len(ans) == targetLevel: return  # result found. Stop.\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 322062,
                "title": "beats-100-c-n-n-1-one-line",
                "content": "**if u like hit vote**\\n```\\nvector<int> grayCode(int n) {\\n        vector<int> ans;\\n       for(int i=0;i<(1<<n);i++)\\n        ans.push_back(i^(i>>1));\\n       return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> grayCode(int n) {\\n        vector<int> ans;\\n       for(int i=0;i<(1<<n);i++)\\n        ans.push_back(i^(i>>1));\\n       return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30053,
                "title": "simple-python-method-52-ms",
                "content": "\\tclass Solution(object):\\n        ```\\n\\t\\tdef grayCode(self, n): \\n\\t\\t\\t\\t\\tif n==0: return [0]\\n\\t\\t\\t\\t\\treturn self.back(n) \\n            \\n        def back(self, n):\\n            if n==1:\\n                return [0,1] \\n            cur = [] \\n            pre= self.back(n-1)\\n            for x in xrange(len(pre)-1,-1,-1):\\n                cur.append(2**(n-1)+pre[x])  \\n            return pre+cur\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\n\\t\\tdef grayCode(self, n): \\n\\t\\t\\t\\t\\tif n==0: return [0]\\n\\t\\t\\t\\t\\treturn self.back(n) \\n            \\n        def back(self, n):\\n            if n==1:\\n                return [0,1] \\n            cur = [] \\n            pre= self.back(n-1)\\n            for x in xrange(len(pre)-1,-1,-1):\\n                cur.append(2**(n-1)+pre[x])  \\n            return pre+cur\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 30105,
                "title": "iterative-5-lines-in-java",
                "content": "Hi guys!\\n\\nThe idea is standard: we have n iterations and at each iteration \"i\" we run through our list (which is a gray code for \"i-1\") in reverse adding 1 to the front of bit-wise representation of a current number.\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>(Arrays.asList(0));\\n        for (int i = 1; i < (1 << n); i <<= 1)\\n            for (int j = res.size()-1; j >= 0; j--)\\n                res.add(i | res.get(j));\\n        return res;\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nThe idea is standard: we have n iterations and at each iteration \"i\" we run through our list (which is a gray code for \"i-1\") in reverse adding 1 to the front of bit-wise representation of a current number.\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>(Arrays.asList(0));\\n        for (int i = 1; i < (1 << n); i <<= 1)\\n            for (int j = res.size()-1; j >= 0; j--)\\n                res.add(i | res.get(j));\\n        return res;\\n    }\\n\\nHope it helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 3125514,
                "title": "very-easy-way-gray-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>v;\\n        int m=pow(2,n);\\n        for(int i=0; i<m; i++){\\n            int x=i^(i>>1);\\n           \\n            v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>v;\\n        int m=pow(2,n);\\n        for(int i=0; i<m; i++){\\n            int x=i^(i>>1);\\n           \\n            v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970359,
                "title": "world-simplest-way-to-solve-this-question",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        n = pow(2, n)-1;\\n        for(int i=0; i<=n; ++i)\\n            v.push_back(i^(i>>1));\\n        return v;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        n = pow(2, n)-1;\\n        for(int i=0; i<=n; ++i)\\n            v.push_back(i^(i>>1));\\n        return v;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741505,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N+2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        oldArr = [0,1]\\n        i = 1\\n        while i< n:\\n            Arr = list(oldArr)\\n            for j in range(len(oldArr)-1,-1,-1):\\n                Arr.append((2**i)+oldArr[j])\\n            oldArr = Arr\\n            i+=1\\n        return oldArr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        oldArr = [0,1]\\n        i = 1\\n        while i< n:\\n            Arr = list(oldArr)\\n            for j in range(len(oldArr)-1,-1,-1):\\n                Arr.append((2**i)+oldArr[j])\\n            oldArr = Arr\\n            i+=1\\n        return oldArr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570947,
                "title": "gray-codes-explained-c-easy-solution",
                "content": "__Algorithm__\\n```                                                         upvote if helpful```\\n- Gray code => a sequence of numbers where binary representation of any 2 consecutive numbers differ by exactly one bit\\n- For exaple for n = 1 => [ 0 , 1 ]\\n                          n = 2 => [00 , 01 , 11 , 10]\\n- To solve this we can understand to find gray code of n bits we need the gray code of n-1 bits and then add 0 and 1 at the front of those numbers\\n- for n = 2 we first find gray code for n = 1 which is [0 , 1] now we add 0 and 1 at the front of all elements in vectro 00 , 01 , 10 , 11 but here there is a discontinuity in 01 and 10 as to bits change\\n- so to resolve this we will add 0 to all integers in the order in which elements are there is vector and for adding 1 we will go in reverse order and push them accordingly . Like -> after adding o in front array will be 00 , 01 after adding 1 array will be 00 , 01 ,11 , 10 as for adding 1 in front the last element ie 1 is used and we go in reverse order\\n- During implementation we don\\'t add 0 as the binary representation already consists of 0 for adding 1 we use bitmask ie 1<<(n-1) as for n = 2 we need to add 1 to 2nd place ie shift 1 by 1 place \\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n == 1){\\n            vector<int> vec = {0,1};\\n            return vec;\\n        }\\n        vector<int> ans(grayCode(n-1));\\n        for(int i = ans.size()-1 ; i>= 0 ;i--){\\n            ans.push_back((ans[i] | 1<<(n-1)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```                                                         upvote if helpful```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n == 1){\\n            vector<int> vec = {0,1};\\n            return vec;\\n        }\\n        vector<int> ans(grayCode(n-1));\\n        for(int i = ans.size()-1 ; i>= 0 ;i--){\\n            ans.push_back((ans[i] | 1<<(n-1)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316165,
                "title": "c-easy-to-understand-simple-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        ans.push_back(1);\\n        for(int i=1;i<n;i++)\\n        {\\n            int sz=ans.size();\\n            int add=pow(2,i);\\n            for(int j=sz-1;j>=0;j--){\\n                ans.push_back(ans[j]+add);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        ans.push_back(1);\\n        for(int i=1;i<n;i++)\\n        {\\n            int sz=ans.size();\\n            int add=pow(2,i);\\n            for(int j=sz-1;j>=0;j--){\\n                ans.push_back(ans[j]+add);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130452,
                "title": "c-almost-in-one-line",
                "content": "```\\nGray[i] = i ^ (i >> 1); // That is all you need to know\\n```\\n\\nSo, the solution is:\\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<int> grayCode(int n)\\n\\t{\\n\\t\\tvector<int> res;\\n\\t\\tfor (int i = 0; i < (1 << n); ++i) res.push_back(i ^ (i >> 1));\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nGray[i] = i ^ (i >> 1); // That is all you need to know\\n```\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<int> grayCode(int n)\\n\\t{\\n\\t\\tvector<int> res;\\n\\t\\tfor (int i = 0; i < (1 << n); ++i) res.push_back(i ^ (i >> 1));\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999295,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 1:\\n            return [0, 1]\\n        \\n        code = self.grayCode(n - 1)\\n        k = 2 ** (n-1)\\n        return code + [k + i for i in reversed(code)]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 1:\\n            return [0, 1]\\n        \\n        code = self.grayCode(n - 1)\\n        k = 2 ** (n-1)\\n        return code + [k + i for i in reversed(code)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942255,
                "title": "easy-100-mathematical",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    \\n    vector<int> grayCode(int n) {\\n        \\n        vector<int>ans;\\n        for(int i=0;i<=(pow(2,n)-1);i++)\\n        {\\n            ans.push_back(i ^ (i>>1));\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    \\n    vector<int> grayCode(int n) {\\n        \\n        vector<int>ans;\\n        for(int i=0;i<=(pow(2,n)-1);i++)\\n        {\\n            ans.push_back(i ^ (i>>1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1721825,
                "title": "java-o-2-n-with-clear-explanation",
                "content": "First, let\\'s analyse these kind of results:\\n\\nn = 1:\\n```\\nGray code = [0,1]\\n```\\nn = 2:\\n```\\nGray code = [0,1,3,2]\\n```\\nn = 3:\\n```\\nGray code = [0,1,3,2,6,7,5,4]\\n```\\nn = 4\\n```\\nGray code = [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\\n```\\nWhat are the patterns here?\\n```\\nThe last number of gray code of n is 2^(n-1). For example for gray code of n = 4, the last number is 2^3 = 8\\n```\\nand\\n```\\nThe first half of gray code of n is the gray code of n - 1\\n```\\nand\\n```\\nThe second half of gray code of n can be constructed from the first half as in the example below:\\n```\\nFor example: With the pattern above, n = 3, assume that we somehow already have gray code of n = 2 How can we calculate the second half?\\n```\\n[0,1,3,2,A,B,C,4]\\n```\\nTurns out:\\n```\\nA = 2 + 4 = 6 (element of gray code 2 at position [3] plus the last element of gray cod 3)\\nB = 3 + 4 = 7 (element of gray code 2 at position [2] plus the last element of gray cod 3)\\nC = 1 + 4 = 5 (element of gray code 2 at position [1] plus the last element of gray cod 3)\\n```\\n\\nSo we implement like this:\\n* Declare an array with 2^n elements.\\n* Init it with the last number of all gray code from 1 to n\\n* Then calculate the right half for each gray code of n (from 1 to n)\\n\\nLike this (with n = 4)\\n```\\n_____________________________________ (array with 2^4 elements)\\n0_1___2_______4_____________________8 (last number of all gray code from 1 to 4)\\n0,1,3,2_______4_____________________8 (calculate the right half of gray code 2)\\n0,1,3,2,6,7,5,4_____________________8 (calculate the right half of gray code 3)\\n0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8 (calculate the right half of gray code 4)\\n```\\n\\nCode:\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        int s = 1 << n;\\n        int[] result = new int[s];\\n\\n\\t\\t/* Init it with the last number of all gray code from 1 to n */\\n        int val = s >> 1;\\n        while (s > 0) {\\n            result[s - 1] = val;\\n            val >>= 1;\\n            s >>= 1;\\n        }\\n\\n\\t\\t/* Construct the right half for each n from 1 to n */\\n        for(int i = 4; i <= result.length; i <<= 1) {\\n            addMoreValues(result, i);\\n        }\\n\\n        return arrayToList(result);\\n    }\\n\\n    private List<Integer> arrayToList(int[] array) {\\n        List<Integer> result = new ArrayList<>();\\n        for(int i = 0; i < array.length; ++i) {\\n            result.add(array[i]);\\n        }\\n\\n        return result;\\n    }\\n\\n    private void addMoreValues(int[] result, int m) {\\n        int mid = m >> 1;\\n        int addValue = result[m - 1];\\n        for(int i = 0; mid + i < m - 1; ++i) {\\n            result[mid + i] = result[mid - i - 1] + addValue;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nGray code = [0,1]\\n```\n```\\nGray code = [0,1,3,2]\\n```\n```\\nGray code = [0,1,3,2,6,7,5,4]\\n```\n```\\nGray code = [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\\n```\n```\\nThe last number of gray code of n is 2^(n-1). For example for gray code of n = 4, the last number is 2^3 = 8\\n```\n```\\nThe first half of gray code of n is the gray code of n - 1\\n```\n```\\nThe second half of gray code of n can be constructed from the first half as in the example below:\\n```\n```\\n[0,1,3,2,A,B,C,4]\\n```\n```\\nA = 2 + 4 = 6 (element of gray code 2 at position [3] plus the last element of gray cod 3)\\nB = 3 + 4 = 7 (element of gray code 2 at position [2] plus the last element of gray cod 3)\\nC = 1 + 4 = 5 (element of gray code 2 at position [1] plus the last element of gray cod 3)\\n```\n```\\n_____________________________________ (array with 2^4 elements)\\n0_1___2_______4_____________________8 (last number of all gray code from 1 to 4)\\n0,1,3,2_______4_____________________8 (calculate the right half of gray code 2)\\n0,1,3,2,6,7,5,4_____________________8 (calculate the right half of gray code 3)\\n0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8 (calculate the right half of gray code 4)\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        int s = 1 << n;\\n        int[] result = new int[s];\\n\\n\\t\\t/* Init it with the last number of all gray code from 1 to n */\\n        int val = s >> 1;\\n        while (s > 0) {\\n            result[s - 1] = val;\\n            val >>= 1;\\n            s >>= 1;\\n        }\\n\\n\\t\\t/* Construct the right half for each n from 1 to n */\\n        for(int i = 4; i <= result.length; i <<= 1) {\\n            addMoreValues(result, i);\\n        }\\n\\n        return arrayToList(result);\\n    }\\n\\n    private List<Integer> arrayToList(int[] array) {\\n        List<Integer> result = new ArrayList<>();\\n        for(int i = 0; i < array.length; ++i) {\\n            result.add(array[i]);\\n        }\\n\\n        return result;\\n    }\\n\\n    private void addMoreValues(int[] result, int m) {\\n        int mid = m >> 1;\\n        int addValue = result[m - 1];\\n        for(int i = 0; mid + i < m - 1; ++i) {\\n            result[mid + i] = result[mid - i - 1] + addValue;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579716,
                "title": "my-python-one-liner-using-logic-gates",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [(num ^ (num<<1))>>1 for num in range(1<<n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [(num ^ (num<<1))>>1 for num in range(1<<n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568408,
                "title": "c-recursive-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1) return {0,1}; //base case\\n        vector<int> prevRes = grayCode(n-1); //dfs call\\n        vector<int> curRes;\\n        for(int i=0; i<prevRes.size(); ++i){\\n            curRes.push_back(prevRes[i]);\\n        }\\n        for(int i=prevRes.size()-1; i>=0; --i){\\n            curRes.push_back((1<<n-1) + prevRes[i]);\\n        }\\n        return curRes;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1) return {0,1}; //base case\\n        vector<int> prevRes = grayCode(n-1); //dfs call\\n        vector<int> curRes;\\n        for(int i=0; i<prevRes.size(); ++i){\\n            curRes.push_back(prevRes[i]);\\n        }\\n        for(int i=prevRes.size()-1; i>=0; --i){\\n            curRes.push_back((1<<n-1) + prevRes[i]);\\n        }\\n        return curRes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422842,
                "title": "how-to-approach-initial-approach-brute-force-backtracking-javascript",
                "content": "1. Initialize result array with 0 repeated n times (n bits)\\n2. toggle each bit and check if the conditions for it being the next in the sequence match, if nothing matches, the current position of this needs to be changed => backtracking.\\n3. The first element will always be 0 and the last element will always be yth power of 2.\\n \\n PS: This is only to understand the initial approach after which we can move on to using bitwise manipulations and undertsanding other more optimised way of solving the problem\\n```\\nvar grayCode = function(n) {\\n// build the first binary string. No. of bits == n;\\n\\tlet binary = \\'0\\'.repeat(n);\\n\\tlet resultBinary = [binary];\\n\\tlet set = new Set();\\n\\tset.add(binary);\\n\\tbacktrack(binary, n, set,  resultBinary);\\n\\tresult = resultBinary.map(binary => convertBinary(binary));\\n\\treturn result;\\n}\\n\\nvar backtrack = function(binary, n, set,  result) {\\n\\tif(result.length === 2 ** n) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlet called = false, found;\\n\\tfor(let i=binary.length-1; i>=0; i--) {\\n\\t\\tlet binArray = binary.split(\\'\\');\\n\\t\\tbinArray[i] = binArray[i] === \\'0\\'  ?  \\'1\\' : \\'0\\';\\n\\t\\tlet newBinary = binArray.join(\\'\\');\\n\\t\\tif(newBinary === 10 ** (n - 1) + \\'\\' && result.length !== (2 ** n - 1)) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif(!set.has(newBinary)) {\\n\\t\\t\\tresult.push(newBinary);\\n\\t\\t\\tset.add(newBinary);\\n\\t\\t\\tcalled = true;\\n\\t\\t\\tfound = backtrack(newBinary, n, set, result);\\n\\t\\t}\\n\\t\\tif(found === false) {\\n\\t\\t\\tresult.pop();\\n\\t\\t\\tset.delete(newBinary);\\n\\t\\t\\tcalled = false;\\n\\t\\t}\\n\\t}\\n\\tif(!called) {\\n\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nvar convertBinary = function(binary) {\\n\\tlet decimal = 0, exp = 0;\\n\\tfor(let i=binary.length-1; i>=0; i--) {\\n\\t\\tdecimal += parseInt(binary[i]) * Math.pow(2, exp++);\\n\\t}\\n\\treturn decimal;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar grayCode = function(n) {\\n// build the first binary string. No. of bits == n;\\n\\tlet binary = \\'0\\'.repeat(n);\\n\\tlet resultBinary = [binary];\\n\\tlet set = new Set();\\n\\tset.add(binary);\\n\\tbacktrack(binary, n, set,  resultBinary);\\n\\tresult = resultBinary.map(binary => convertBinary(binary));\\n\\treturn result;\\n}\\n\\nvar backtrack = function(binary, n, set,  result) {\\n\\tif(result.length === 2 ** n) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlet called = false, found;\\n\\tfor(let i=binary.length-1; i>=0; i--) {\\n\\t\\tlet binArray = binary.split(\\'\\');\\n\\t\\tbinArray[i] = binArray[i] === \\'0\\'  ?  \\'1\\' : \\'0\\';\\n\\t\\tlet newBinary = binArray.join(\\'\\');\\n\\t\\tif(newBinary === 10 ** (n - 1) + \\'\\' && result.length !== (2 ** n - 1)) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif(!set.has(newBinary)) {\\n\\t\\t\\tresult.push(newBinary);\\n\\t\\t\\tset.add(newBinary);\\n\\t\\t\\tcalled = true;\\n\\t\\t\\tfound = backtrack(newBinary, n, set, result);\\n\\t\\t}\\n\\t\\tif(found === false) {\\n\\t\\t\\tresult.pop();\\n\\t\\t\\tset.delete(newBinary);\\n\\t\\t\\tcalled = false;\\n\\t\\t}\\n\\t}\\n\\tif(!called) {\\n\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nvar convertBinary = function(binary) {\\n\\tlet decimal = 0, exp = 0;\\n\\tfor(let i=binary.length-1; i>=0; i--) {\\n\\t\\tdecimal += parseInt(binary[i]) * Math.pow(2, exp++);\\n\\t}\\n\\treturn decimal;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1416588,
                "title": "c-easy-5-lines-solution-with-explanation",
                "content": "The idea is simple; for example, consider `n = 2`, we have `{00, 01, 11, 10}` in binary.\\nNotice that the first half of the array starts with `0` and the second half starts with `1`. If we remove all the first bit, the array we have is **symmetric**, in which the first half is `{0, 1}` - the solution to `n = 1`\\n\\nConsider `n = 3`, we have the array `{0, 1, 3, 2, 6, 7, 5, 4}`, or `{000, 001, 011, 010, 110, 111, 101, 100}` in binary. You can notice the same pattern: if we remove all the first bit, the first half of the remaining array is `{00, 01, 11, 10}` - the solution to `n = 2`.\\n\\nSo we can build the array as follow: start with `{0}`, for each additional bit (`ith` bit) you copy each element `a[j]` in the array *backward*, and add a bit `1` in front of it - equivalent to `a[j] | (1 << i)` \\n-\\n*Note: the `1<<i` part is `100...0` with `i` bits `0`, when you use the operator `| - OR`, it will put the bit `1` in front of an `i` bit number - `a[j]` in this case*\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> a = {0};\\n        for (int i = 0; i < n; i++) \\n            for (int size = a.size(), j = size-1; j >= 0; --j)\\n                a.push_back(a[j] | (1 << i));\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> a = {0};\\n        for (int i = 0; i < n; i++) \\n            for (int size = a.size(), j = size-1; j >= 0; --j)\\n                a.push_back(a[j] | (1 << i));\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346758,
                "title": "c-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;       \\n        for(int i=0;i<(1<<n);i++){\\n            v.push_back(i^(i>>1));\\n            \\n            // 00 ^ (00)\\n            // 01 ^ (00)\\n            // 10 ^ (01)\\n            // 11 ^ (01)\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;       \\n        for(int i=0;i<(1<<n);i++){\\n            v.push_back(i^(i>>1));\\n            \\n            // 00 ^ (00)\\n            // 01 ^ (00)\\n            // 10 ^ (01)\\n            // 11 ^ (01)\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316592,
                "title": "c-easy-and-short",
                "content": "```\\n        std::vector<int> grayCode(int n)\\n        {\\n            int limit = (int)std::pow(2, n);\\n            std::vector<int> code{};\\n\\n            code.push_back(0);\\n\\n            // i xor i >> 1 will give you the gray code for i.\\n            for (int i = 1; i < limit; i++) {\\n                code.push_back(i ^ (i >> 1));\\n            }\\n\\n            return code;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        std::vector<int> grayCode(int n)\\n        {\\n            int limit = (int)std::pow(2, n);\\n            std::vector<int> code{};\\n\\n            code.push_back(0);\\n\\n            // i xor i >> 1 will give you the gray code for i.\\n            for (int i = 1; i < limit; i++) {\\n                code.push_back(i ^ (i >> 1));\\n            }\\n\\n            return code;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310242,
                "title": "simplest-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n)\\n    {\\n        vector<int>ans;\\n        long itr = pow(2,n); //pow function for computing the base no. raised to the power of exponent\\n        \\n        for(int i=0;i<itr;i++)\\n        {\\n            ans.push_back(i^(i/2));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n)\\n    {\\n        vector<int>ans;\\n        long itr = pow(2,n); //pow function for computing the base no. raised to the power of exponent\\n        \\n        for(int i=0;i<itr;i++)\\n        {\\n            ans.push_back(i^(i/2));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310225,
                "title": "c-dfs-backtracking",
                "content": "\\n**Explanation:**\\n**Neighbours of curr node are all nodes with one bit difference with curr**\\n1. Assume 0 as the source and neighbours {powers of 2 - 1,2,4,8,16.....}\\n2. Recursively follow the below steps on each neighbour:\\n\\t* \\tMark neighbour as visited, push in vector and proceed ahead with next neighbours\\n\\t* \\tIf you reach a dead end ,backtrack - (mark visited false and pop from vector and proceed with another neighbour)\\n\\t* \\tIf you reach the answer, you will have all values in vector, just return\\n\\nYou can also draw edges between neighbours for better visualization.\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int curr, vector<bool> &visited, vector<int> &v, int n){\\n        v.push_back(curr);\\n        visited[curr] = true;\\n        if(v.size()==(1<<n)){\\n            return true;\\n        }\\n            \\n        for(int i = 0; i < n; i++){\\n            int next = curr ^ (1<<i);\\n            if(!visited[next] && dfs(next,visited,v,n))\\n                return true;\\n        }\\n        \\n        v.pop_back();\\n        visited[curr] = false;\\n        return false;\\n    }\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int curr = 0;\\n        vector<bool> visited(1<<n,false);\\n        dfs(curr,visited,v,n);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int curr, vector<bool> &visited, vector<int> &v, int n){\\n        v.push_back(curr);\\n        visited[curr] = true;\\n        if(v.size()==(1<<n)){\\n            return true;\\n        }\\n            \\n        for(int i = 0; i < n; i++){\\n            int next = curr ^ (1<<i);\\n            if(!visited[next] && dfs(next,visited,v,n))\\n                return true;\\n        }\\n        \\n        v.pop_back();\\n        visited[curr] = false;\\n        return false;\\n    }\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int curr = 0;\\n        vector<bool> visited(1<<n,false);\\n        dfs(curr,visited,v,n);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309869,
                "title": "java-simple-iterative-clean",
                "content": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans= new ArrayList<>();   \\n        for(int i=0;i<(1<<n);i++)\\n            ans.add(i^(i>>1));\\n        return ans;\\n    }\\n}\\n```\\n\\nMain Points to be taken care of,\\n1) There will be exactly 2^n number of gray codes for n bit,\\n2) We need to think of the fact that, can we obtain the gray code using current number,\\n\\nFor eg:\\nif current number = 0\\nthe gray code will be = 0\\n\\nif current number = 1\\nthe gray code will be = 1\\n\\nif current number = 2\\nthe gray code will be = 3\\n\\nIf we carefully observe for every number \"num\",\\nthe gray code will be = num ^ (num>>1),\\nwhy?\\nbecause it is making sure that there will be difference of 1 bit between the number and gray code to be formed,\\nLet us take the eg of num=2\\nin Binary = 10\\n(10>>1) = 01\\n10 ^ (10>>1) = 11 (3 in decimal)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans= new ArrayList<>();   \\n        for(int i=0;i<(1<<n);i++)\\n            ans.add(i^(i>>1));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309431,
                "title": "scala-1-line-solution",
                "content": "```\\ndef grayCode(n: Int) = List.tabulate(1 << n)(i => i ^ i >> 1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef grayCode(n: Int) = List.tabulate(1 << n)(i => i ^ i >> 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1309419,
                "title": "c-two-easy-solutions-recursion-and-without-recursion",
                "content": "```\\n//With Recursion\\nvector<int> grayCode(int n) \\n    {\\n       if(n == 1) \\n            return {0, 1};\\n        vector<int>prev = grayCode(n - 1);\\n        \\n        for(int i = prev.size() - 1; i >= 0; i--)\\n            prev.push_back(prev[i] + pow(2, n - 1));\\n        \\n        return prev;  \\n}\\n\\n//Without recursion\\nvector<int> grayCode(int n) \\n    {\\n        vector<int> v;\\n        long long int p = pow(2, n);   //1<<n;\\n        for(int i = 0; i < p; i++)\\n          v.push_back(i ^ (i / 2));    //i>>1\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//With Recursion\\nvector<int> grayCode(int n) \\n    {\\n       if(n == 1) \\n            return {0, 1};\\n        vector<int>prev = grayCode(n - 1);\\n        \\n        for(int i = prev.size() - 1; i >= 0; i--)\\n            prev.push_back(prev[i] + pow(2, n - 1));\\n        \\n        return prev;  \\n}\\n\\n//Without recursion\\nvector<int> grayCode(int n) \\n    {\\n        vector<int> v;\\n        long long int p = pow(2, n);   //1<<n;\\n        for(int i = 0; i < p; i++)\\n          v.push_back(i ^ (i / 2));    //i>>1\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309155,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n        if(n==0){return list;}\\n        list.add(1);\\n        int prev_Bit = 1;\\n        for(int i = 2;i<=n;i++){\\n            prev_Bit *=2;\\n            for(int j = list.size()-1;j>=0;j--){\\n                list.add(prev_Bit+list.get(j));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n        if(n==0){return list;}\\n        list.add(1);\\n        int prev_Bit = 1;\\n        for(int i = 2;i<=n;i++){\\n            prev_Bit *=2;\\n            for(int j = list.size()-1;j>=0;j--){\\n                list.add(prev_Bit+list.get(j));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006682,
                "title": "python-solution-with-xor-explained",
                "content": "Here is the list for n=2, as provided in the example\\n```\\ngray_code = [0,1,3,2]\\n```\\nLets XOR the values with their own indexes, which would mean,\\n```\\ngray_code[i]^i\\n```\\nDoing the above operation on the example given yields,\\n```\\n[0,0,1,1]\\n```\\nThat list looks a lot like every element is just floor(i/2). Lets hold onto that for a while.\\n\\nXOR has the interesting property: ```if A^B = C, then B^C = A```.\\nWhich implies, \\n```\\nif gray_code[i]^i = x, then x^i = gray_code[i], where x is floor(i/2)\\n```\\nOne last thing: floor(i/2) is same as i >> 1, and 2^n is same as 1<<n (n!=0), where n is the number of bits.\\n```\\ndef grayCode(self, n):\\n       lim = 1 << n\\n       return [(i>>1)^i for i in range(0, lim)]\\n```",
                "solutionTags": [],
                "code": "```\\ngray_code = [0,1,3,2]\\n```\n```\\ngray_code[i]^i\\n```\n```\\n[0,0,1,1]\\n```\n```if A^B = C, then B^C = A```\n```\\nif gray_code[i]^i = x, then x^i = gray_code[i], where x is floor(i/2)\\n```\n```\\ndef grayCode(self, n):\\n       lim = 1 << n\\n       return [(i>>1)^i for i in range(0, lim)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 881932,
                "title": "simple-c-solution-0ms-faster-than-100-6-7mb",
                "content": "```\\nvector<int> grayCode(int n) {\\n        vector<int> res;\\n        for(int i=0;i<(1<<n);i++)\\n            res.push_back(i^(i>>1));\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> grayCode(int n) {\\n        vector<int> res;\\n        for(int i=0;i<(1<<n);i++)\\n            res.push_back(i^(i>>1));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 825353,
                "title": "c-simple-technique-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        n = (1<<n);\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            int x = ((i)^(i>>1));\\n            v.push_back(x);\\n                     \\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        n = (1<<n);\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            int x = ((i)^(i>>1));\\n            v.push_back(x);\\n                     \\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808416,
                "title": "python-one-line",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [(i >> 1) ^ i for i in range(2**n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [(i >> 1) ^ i for i in range(2**n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749462,
                "title": "fastest-c-solution-0ms-with-only-4-5-lines-of-code",
                "content": "class Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        int c = pow(2,n);\\n        for(int i=0;i<c;i++){\\n            res.push_back(i^i>>1);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        int c = pow(2,n);\\n        for(int i=0;i<c;i++){\\n            res.push_back(i^i>>1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 514818,
                "title": "python-bitwise-100",
                "content": "```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = []\\n        for i in range(1 << n):\\n            res.append(i ^ (i >> 1))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = []\\n        for i in range(1 << n):\\n            res.append(i ^ (i >> 1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434639,
                "title": "python-bit-manipulation-easy-to-understand-with-explanation",
                "content": "This solution uses bit manipulation. It is much easier to see the pattern if you change n=2 to n=3\\nIf I make a loop count from 0 to 2^n then take the difference of what the output and the input should be to find a mask to use the XOR operator with. See the table be low.\\n_________________________  \\n\\t0 = 000 --->0 = 000          difference = 000\\n\\t1 = 001 --->1 = 001          difference = 000\\n\\t2 = 010 --->3 =011           difference = 001\\n\\t3 =011 --->2 = 010           difference = 001\\n\\t4 =100 --->6 =110            difference = 010\\n\\t5 =101 --->7 =111            difference = 010\\n\\t6 =110 --->5 =101            difference = 011\\n\\t7 =111 --->4 =100            difference = 011\\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        if n ==0:\\n            return [0]\\n        \\n        out = [0,1]\\n        mask =0\\n        for j in range(2,2**n):\\n            if j%2 ==0:\\n                mask +=1\\n            out.append(j^mask)\\n        return out\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        if n ==0:\\n            return [0]\\n        \\n        out = [0,1]\\n        mask =0\\n        for j in range(2,2**n):\\n            if j%2 ==0:\\n                mask +=1\\n            out.append(j^mask)\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423263,
                "title": "two-python-solutions-with-video-explanations",
                "content": "**Solution 1**\\n```\\ndef grayCode(self, n):\\n\\tres = []\\n\\tfor i in range(1 << n):\\n\\t\\tres.append(i ^ (i >> 1))\\n\\treturn res\\n```\\n\\n**Solution 2**\\n```\\ndef grayCode(self, n):\\n\\tdef helper(n):\\n\\t\\tif n == 0:\\n\\t\\t\\treturn [\\'0\\']\\n\\t\\tif n == 1:\\n\\t\\t\\treturn [\\'0\\', \\'1\\']\\n\\t\\tres = helper(n - 1)\\n\\t\\treturn [\\'0\\' + s for s in res] + [\\'1\\' + s for s in res[::-1]]\\n\\n\\treturn [int(s, 2) for s in helper(n)]\\n```\\n\\n**Video explanation for Gray Code**\\nhttps://www.youtube.com/watch?v=oVMOTNqVYns\\n\\n**Video explanation for both solutions**\\nhttps://www.youtube.com/watch?v=CHr3V8JDa1w\\n",
                "solutionTags": [],
                "code": "```\\ndef grayCode(self, n):\\n\\tres = []\\n\\tfor i in range(1 << n):\\n\\t\\tres.append(i ^ (i >> 1))\\n\\treturn res\\n```\n```\\ndef grayCode(self, n):\\n\\tdef helper(n):\\n\\t\\tif n == 0:\\n\\t\\t\\treturn [\\'0\\']\\n\\t\\tif n == 1:\\n\\t\\t\\treturn [\\'0\\', \\'1\\']\\n\\t\\tres = helper(n - 1)\\n\\t\\treturn [\\'0\\' + s for s in res] + [\\'1\\' + s for s in res[::-1]]\\n\\n\\treturn [int(s, 2) for s in helper(n)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 259921,
                "title": "python-20ms-2-methods",
                "content": "Method 1 : according to the Gray Code generation principle (you can check it on the Internet)\\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        for i in range(1<<n):\\n            res.append(i^(i>>1))      \\n        return res\\n```\\n\\nMethod 2 :  iteration and mirror\\n\\nSuch as n = 1 , the gray code is [0,1] ;\\nand when n = 2 ,  the gray code is [0,1,3,2] , equal to [0,1] + [1,0](each element plus 2**(n-1))\\nso when n = 3 , the gray code is [0,1,3,2] + [2,3,1,0](each element plus 2**2) , just [0,1,3,2,6,7,5,4]\\n\\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 0:\\n            return [0]\\n        temp = self.grayCode(n-1)\\n        temp1 = [i+2**(n-1) for i in temp[::-1]]\\n        res = temp + temp1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        for i in range(1<<n):\\n            res.append(i^(i>>1))      \\n        return res\\n```\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 0:\\n            return [0]\\n        temp = self.grayCode(n-1)\\n        temp1 = [i+2**(n-1) for i in temp[::-1]]\\n        res = temp + temp1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204179,
                "title": "simple-java-solution",
                "content": "Recursion and the mirror image property of gray codes+ add pow(2,n-1) can be used.\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        if(n==0){\\n            List<Integer> result = new ArrayList<Integer>();\\n            result.add(0);\\n            return result;\\n        }\\n        \\n        List<Integer> result= grayCode(n-1);\\n        int numToAdd= 1<<(n-1);\\n        for(int i=result.size()-1;i>=0;i--) {\\n            result.add(numToAdd+result.get(i));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        if(n==0){\\n            List<Integer> result = new ArrayList<Integer>();\\n            result.add(0);\\n            return result;\\n        }\\n        \\n        List<Integer> result= grayCode(n-1);\\n        int numToAdd= 1<<(n-1);\\n        for(int i=result.size()-1;i>=0;i--) {\\n            result.add(numToAdd+result.get(i));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156204,
                "title": "simple-java-solution-with-comments",
                "content": "```\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> arr=new ArrayList<>();\\n        \\n        if(n==0)\\n        {\\n            arr.add(0);\\n            return arr;\\n        }\\n        arr.add(0);\\n        arr.add(1);\\n        int ptr=1;\\n\\n        while(ptr<n){\\n            for(int i=arr.size()-1;i>=0;i--){\\n                arr.add((1<<ptr)+arr.get(i));\\n            }\\n            ptr++;\\n        }\\n        // initially \\n        // 0\\n        // 1\\n        // arr = [0, 1]\\n        // now - for ptr=1, following is added\\n        // 11\\n        // 10\\n        // arr = [0, 1, 3, 2]\\n        // now for ptr=2, following is added\\n        // 101\\n        // 111\\n        // 101\\n        // 100\\n        // arr = [0, 1, 3, 2, 6, 7, 5, 4]\\n        // for each new ptr we add 1<<ptr to the reverse order of previous ptr values.\\n        // eg  6=(1<<2)+2\\n        // eg  7=(1<<2)+3\\n        // eg  5=(1<<2)+1\\n        // eg  4=(1<<2)+0\\n        // and [2, 3, 1, 0] are reverse of previous ptr arr values\\n        \\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> arr=new ArrayList<>();\\n        \\n        if(n==0)\\n        {\\n            arr.add(0);\\n            return arr;\\n        }\\n        arr.add(0);\\n        arr.add(1);\\n        int ptr=1;\\n\\n        while(ptr<n){\\n            for(int i=arr.size()-1;i>=0;i--){\\n                arr.add((1<<ptr)+arr.get(i));\\n            }\\n            ptr++;\\n        }\\n        // initially \\n        // 0\\n        // 1\\n        // arr = [0, 1]\\n        // now - for ptr=1, following is added\\n        // 11\\n        // 10\\n        // arr = [0, 1, 3, 2]\\n        // now for ptr=2, following is added\\n        // 101\\n        // 111\\n        // 101\\n        // 100\\n        // arr = [0, 1, 3, 2, 6, 7, 5, 4]\\n        // for each new ptr we add 1<<ptr to the reverse order of previous ptr values.\\n        // eg  6=(1<<2)+2\\n        // eg  7=(1<<2)+3\\n        // eg  5=(1<<2)+1\\n        // eg  4=(1<<2)+0\\n        // and [2, 3, 1, 0] are reverse of previous ptr arr values\\n        \\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123663,
                "title": "just-share-some-more-about-gray-code-tower-of-hanoi",
                "content": "First I definitely agree with other commentors that this is not a great interview question since it doesn\\'t really reveal much about candidates\\'s competency. I just want to share more about what I read recently about gray code. Knuth devoted a lot of pages to gray code in his The Art of Programming Volume 4A starting at page 281.  The idea is to have a variable i iterate over 0 to 1 << N. And for each i, find the first bit set, and flip that bit on the previous value. NO credit belongs to me here. Here is my code:\\n\\n```\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> r;\\n        int m = 0;\\n        r.push_back(m);\\n        for (int i = 1; i < (1 << n); ++i) {\\n            for (int j = 0; j < 32; ++j) {\\n                if ((1<<j) & i) {\\n                    m = m ^ (1<<j);\\n                    r.push_back(m); // Of course we can use built in functions in C/C++ like ffs\\n                    break;\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\n\\nIf you read more of Knuth\\'s book, it also says it\\'s related to ancient Chinese puzzle \\u4E5D\\u8FDE\\u73AF. If you buy one from Amazon and play with it, you would find graycode truly amazing. It\\'s also related to iterative solution of tower of hanoi.",
                "solutionTags": [],
                "code": "```\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> r;\\n        int m = 0;\\n        r.push_back(m);\\n        for (int i = 1; i < (1 << n); ++i) {\\n            for (int j = 0; j < 32; ++j) {\\n                if ((1<<j) & i) {\\n                    m = m ^ (1<<j);\\n                    r.push_back(m); // Of course we can use built in functions in C/C++ like ffs\\n                    break;\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29885,
                "title": "python-1-liner",
                "content": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        return [(num ^ (num >> 1)) for num in range(2 ** n)]\\n```\\n\\n*By Yangshun*",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        return [(num ^ (num >> 1)) for num in range(2 ** n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29999,
                "title": "6-lines-4ms-easy-c-solution",
                "content": "    vector<int> grayCode(int n) {\\n        vector<int>res;\\n        for(int i=0;i<(1<<n);i++){\\n            res.push_back(i^(i>>1));\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> grayCode(int n) {\\n        vector<int>res;\\n        for(int i=0;i<(1<<n);i++){\\n            res.push_back(i^(i>>1));\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30010,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "After seeing the top voted post, I find their idea is really elegant. We just need to double expand the previous layer element by adding 1 to all the element of the previous layer.\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> result(1, 0);\\n            /** level-by-level expand the result **/\\n            /** add 1 to prefix of each int the previous layer ***/\\n            for(int i=0; i<n; i++){\\n                int cur=result.size();\\n                while(cur){\\n                    cur--;\\n                    int temp=result[cur];\\n                    temp+=(1<<i);\\n                    result.push_back(temp);\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> result(1, 0);\\n            /** level-by-level expand the result **/\\n            /** add 1 to prefix of each int the previous layer ***/\\n            for(int i=0; i<n; i++){\\n                int cur=result.size();\\n                while(cur){\\n                    cur--;\\n                    int temp=result[cur];\\n                    temp+=(1<<i);\\n                    result.push_back(temp);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 30022,
                "title": "multiple-approaches-topdown-bottom-up-recursive",
                "content": "\\n**Build up, DP table** \\n\\n    vector<int> grayCode_dp(int n) {\\n        if( n == 0) return {0};\\n        vector<int> prev={0};\\n        \\n        for( int cur=1; cur<=n; cur++)\\n            for( int j=prev.size()-1; j>=0; j--)\\n                    prev.push_back( (1<<(cur-1))|prev[j]);    \\n        return prev;\\n    }\\n\\n**top down, Just recursive**\\n\\n\\n    vector<int> grayCode_rec(int n) {\\n        \\n        if( n == 0) return {0};\\n        if( n == 1) return {0,1};\\n        \\n        vector<int> cur;\\n        vector<int> prev=grayCode(n-1);\\n        for( auto val : prev )\\n        {\\n            cur.push_back( (0<<n)|val);    \\n        }\\n        for( int j=prev.size()-1;j>=0;j--)\\n        {\\n            cur.push_back( (1<<(n-1))|prev[j]);    \\n        }\\n        return cur;\\n    }\\n};\\n\\n\\n**Truncated BFS with O(1 shft by n) space**\\n\\n        vector<int> res;\\n    void gc(int n, int cur, vector<bool> &exists )\\n    {\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int temp= cur^ (1<<i);\\n            \\n            if(exists[temp] == false)\\n            {\\n                exists[temp]=true;\\n                res.push_back(temp);\\n                gc(n, temp, exists);\\n                break;\\n            }\\n        }\\n        \\n    }\\n    vector<int> grayCode(int n , int cur=0) {\\n        \\n        \\n        vector<bool> exists(1<<n,false);\\n        exists[0]=true;\\n        res.push_back(0);\\n        gc(n,0, exists);\\n        \\n        return res;\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "\\n**Build up, DP table** \\n\\n    vector<int> grayCode_dp(int n) {\\n        if( n == 0) return {0};\\n        vector<int> prev={0};\\n        \\n        for( int cur=1; cur<=n; cur++)\\n            for( int j=prev.size()-1; j>=0; j--)\\n                    prev.push_back( (1<<(cur-1))|prev[j]);    \\n        return prev;\\n    }\\n\\n**top down, Just recursive**\\n\\n\\n    vector<int> grayCode_rec(int n) {\\n        \\n        if( n == 0) return {0};\\n        if( n == 1) return {0,1};\\n        \\n        vector<int> cur;\\n        vector<int> prev=grayCode(n-1);\\n        for( auto val : prev )\\n        {\\n            cur.push_back( (0<<n)|val);    \\n        }\\n        for( int j=prev.size()-1;j>=0;j--)\\n        {\\n            cur.push_back( (1<<(n-1))|prev[j]);    \\n        }\\n        return cur;\\n    }\\n};\\n\\n\\n**Truncated BFS with O(1 shft by n) space**\\n\\n        vector<int> res;\\n    void gc(int n, int cur, vector<bool> &exists )\\n    {\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int temp= cur^ (1<<i);\\n            \\n            if(exists[temp] == false)\\n            {\\n                exists[temp]=true;\\n                res.push_back(temp);\\n                gc(n, temp, exists);\\n                break;\\n            }\\n        }\\n        \\n    }\\n    vector<int> grayCode(int n , int cur=0) {\\n        \\n        \\n        vector<bool> exists(1<<n,false);\\n        exists[0]=true;\\n        res.push_back(0);\\n        gc(n,0, exists);\\n        \\n        return res;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30066,
                "title": "my-java-solution-6-lines-easy-to-understand",
                "content": "    public List<Integer> grayCode(int n) {\\n    \\tList<Integer> output = new ArrayList<Integer>();\\t\\n    \\toutput.add(0);\\n    \\tfor (int i = 1; i <= n; i++)\\n    \\t\\tfor (int j = output.size() - 1; j >= 0; j--)\\n    \\t\\t\\toutput.add(output.get(j) + (int)Math.pow(2, i - 1));   \\t\\n    \\treturn output;\\n    }",
                "solutionTags": [],
                "code": "    public List<Integer> grayCode(int n) {\\n    \\tList<Integer> output = new ArrayList<Integer>();\\t\\n    \\toutput.add(0);\\n    \\tfor (int i = 1; i <= n; i++)\\n    \\t\\tfor (int j = output.size() - 1; j >= 0; j--)\\n    \\t\\t\\toutput.add(output.get(j) + (int)Math.pow(2, i - 1));   \\t\\n    \\treturn output;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30068,
                "title": "share-my-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> seq = {0};\\n            if (n == 0) {\\n                return seq;\\n            }\\n            \\n            seq = grayCode(n-1);\\n            int len = seq.size();\\n            int mask = 1 << (n-1);\\n            for (int i = len-1; i >= 0; i--) {\\n                seq.push_back(seq[i] | mask);\\n            }\\n            return seq;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> seq = {0}",
                "codeTag": "Java"
            },
            {
                "id": 30070,
                "title": "java-solution-with-explanation",
                "content": "\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        res.add(0);\\n        if (n == 0) return res;\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> temp = new ArrayList<>();\\n            temp.addAll(res);\\n            for (int j = temp.size() - 1; j >= 0; j--) {\\n                res.add((1<<i) + temp.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n\\n - 000\\n - 001\\n - 011\\n - 010\\n - ---------\\n - 110\\n - 111\\n - 101\\n - 100\\n\\n\\n----------\\nThink about how to get gray code when n is 3: the first 4 gray codes is the same with when n equals to 2, and the last gray codes is adding 1 in front of the gray codes when n is 2. The first 4 is symmetric to the last 4.",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        res.add(0);\\n        if (n == 0) return res;\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> temp = new ArrayList<>();\\n            temp.addAll(res);\\n            for (int j = temp.size() - 1; j >= 0; j--) {\\n                res.add((1<<i) + temp.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n\\n - 000\\n - 001\\n - 011\\n - 010\\n - ---------\\n - 110\\n - 111\\n - 101\\n - 100\\n\\n\\n----------\\nThink about how to get gray code when n is 3: the first 4 gray codes is the same with when n equals to 2, and the last gray codes is adding 1 in front of the gray codes when n is 2. The first 4 is symmetric to the last 4.",
                "codeTag": "Unknown"
            },
            {
                "id": 30078,
                "title": "python-5-lines-no-recursive-just-generate-the-result",
                "content": "    def grayCode(self, n):\\n            ret = [0]\\n            for k in range(0, n):\\n                for i in range(len(ret)-1, -1, -1):\\n                    ret.append(ret[i]+(2**k))\\n            return ret\\n\\nThe idea as below.\\n\\nf(n=1) :\\n\\n    0\\n    1\\n\\nf(n=2) :  \\nafter got result of f(n = 1), add 1 to every elements's binary value, add result to the f(n = 1) reversed order.\\n\\n          00 \\n          01 \\n    1 --> 11\\n    0 --> 10\\n\\nf(n=3) :  do as above.\\n\\n           000 \\n           001 \\n           011\\n           010\\n    10 --> 110\\n    11 --> 111\\n    01 --> 101\\n    00 --> 100\\n\\nn = 4, 5, 6... as above.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def grayCode(self, n):\\n            ret = [0]\\n            for k in range(0, n):\\n                for i in range(len(ret)-1, -1, -1):\\n                    ret.append(ret[i]+(2**k))\\n            return ret\\n\\nThe idea as below.\\n\\nf(n=1) :\\n\\n    0\\n    1\\n\\nf(n=2) :  \\nafter got result of f(n = 1), add 1 to every elements's binary value, add result to the f(n = 1) reversed order.\\n\\n          00 \\n          01 \\n    1 --> 11\\n    0 --> 10\\n\\nf(n=3) :  do as above.\\n\\n           000 \\n           001 \\n           011\\n           010\\n    10 --> 110\\n    11 --> 111\\n    01 --> 101\\n    00 --> 100\\n\\nn = 4, 5, 6... as above.",
                "codeTag": "Python3"
            },
            {
                "id": 30061,
                "title": "solution-using-binary-tree",
                "content": "We can represent binary numbers as paths of binary tree.  \\nLeft node value is parent value times 2. \\nRight node value is parent value times 2 plus 1.\\nWe can only change a single part of a path at a time.\\nWe will look for a pattern to accomplish this.\\n\\n         /*\\n    \\t *                                  _____0_____                     000                      0000\\n    \\t *                                 /           \\\\                    001                      0001\\n    \\t *                              __0_           _1__                 011                      0011\\n    \\t *                             /    \\\\         /    \\\\                010                      0010\\n    \\t *                            0      1       2      3               110                      0110 \\n    \\t *                           / \\\\    / \\\\     / \\\\    / \\\\              111                      0111\\n    \\t *                          0   1  2   3   4   5  6   7             101                      0101 \\n    \\t *                                                                  100                      0100\\n    \\t *              n=0                                  0                                       1100\\n    \\t *              n=1                    0                            1                        1101 \\n    \\t *              n=2             0            1              3                2               1111 \\n    \\t *              n=3         0      1     3       2       6     7         5       4           1110   \\n    \\t *              n=4        0,1    3,2   6,7     5,4    12,13 15,14      10,11   9,8          1010    \\n    \\t *                                                                                           1011 \\n    \\t *                                                                                           1001\\n    \\t *                                                                                           1000\\n    \\t */\\n    public class Solution {\\n        public List<Integer> grayCode(int n){\\n    \\t\\tList<Integer> result = new ArrayList<Integer>();\\n    \\t\\tresult.add(0);\\n    \\t\\t\\n    \\t\\tfor (int i=0;i<n;i++){\\n    \\t\\t\\tboolean smallerFirst=true;\\n    \\t\\t\\tList<Integer> temp = new ArrayList<Integer>();\\n    \\t\\t\\tfor (int val:result){\\n    \\t\\t\\t\\tif (smallerFirst){\\n    \\t\\t\\t\\t\\ttemp.add(val*2);\\n    \\t\\t\\t\\t\\ttemp.add(val*2+1);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\ttemp.add(val*2+1);\\n    \\t\\t\\t\\t\\ttemp.add(val*2);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tsmallerFirst=!smallerFirst;\\n    \\t\\t\\t}\\n    \\t\\t\\tresult = temp;\\n    \\t\\t}\\n    \\t\\treturn result;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n){\\n    \\t\\tList<Integer> result = new ArrayList<Integer>();\\n    \\t\\tresult.add(0);\\n    \\t\\t\\n    \\t\\tfor (int i=0;i<n;i++){\\n    \\t\\t\\tboolean smallerFirst=true;\\n    \\t\\t\\tList<Integer> temp = new ArrayList<Integer>();\\n    \\t\\t\\tfor (int val:result){\\n    \\t\\t\\t\\tif (smallerFirst){\\n    \\t\\t\\t\\t\\ttemp.add(val*2);\\n    \\t\\t\\t\\t\\ttemp.add(val*2+1);\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 30088,
                "title": "accepted-4ms-c-recursive-solution-only-6-lines-easy-understand",
                "content": "If n = 2, the result will be:\\n\\n    00\\n    01\\n    11\\n    10\\n\\nIf n = 3, the result will be:\\n\\n    0  00\\n    0  01\\n    0  11\\n    0  10\\n    -----\\n    1  10\\n    1  11\\n    1  01\\n    1  00\\n\\nEasy to get the accepted solution:\\n\\n    class Solution {\\n    public:\\n        std::vector<int> grayCode(int n) {\\n    \\t\\tif (!n) \\n    \\t\\t\\treturn std::vector<int>(1);\\n            std::vector<int> res = grayCode(n - 1);\\n    \\t\\tfor (int i = res.size() - 1; i >= 0; --i)\\n    \\t\\t\\tres.push_back(res[i] + (1 << (n - 1))); // or res.push_back(res[i] | (1 << (n - 1)));\\n    \\t\\treturn res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        std::vector<int> grayCode(int n) {\\n    \\t\\tif (!n) \\n    \\t\\t\\treturn std::vector<int>(1);\\n            std::vector<int> res = grayCode(n - 1);\\n    \\t\\tfor (int i = res.size() - 1; i >= 0; --i)\\n    \\t\\t\\tres.push_back(res[i] + (1 << (n - 1))); // or res.push_back(res[i] | (1 << (n - 1)));\\n    \\t\\treturn res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 30097,
                "title": "my-c-solution-7ms-17lines",
                "content": "The basic idea is following:\\nif n = 3<br>\\n000<br>\\n001<br>\\n011<br>\\n010<br>\\n100<br>\\n101<br>\\n111<br>\\n110<br>\\nLook the columns, it is a repeat of {0, 1, 1, 0}. The first column (from the right) is 0110, the send column is 00111100, every element repeat twice, the third column is 0000111111110000, every element repeat four times.\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int num = 1 << n;\\n            int sum = 0;\\n            vector<int> res;\\n            int t[] = {0, 1, 1, 0};\\n            for (int i = 0; i < num; ++i) {\\n                sum = 0;\\n                for (int j = 0; j < n; ++j) {\\n                    sum += t[i/(1 << j) % 4] * (1 << j);\\n                }\\n                res.push_back(sum);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int num = 1 << n;\\n            int sum = 0;\\n            vector<int> res;\\n            int t[] = {0, 1, 1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 3831538,
                "title": "c-very-easy-solution-beats-100-users-with-0ms-runtime",
                "content": "# Intuition\\nFor each adjacent pair to be differing by a bit the difference between them should be a 2 power.\\n\\n# Approach\\nBy observation we can get to a conclusion that for every increment of n, adding 1<<n to previous elements in the vector all the way till beginning starting from end and adding them into the vector simultaneously gives the differenec between each adjacent elements in the vector a power of 2 i.e., 1, 2, 4, 8, ....\\n\\n# Complexity\\n- Time complexity : $$O(1<<n)$$\\n\\n- Space complexity : $$O(1<<n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> p = {0, 1};\\n        n--;\\n\\n        int prod = 1;\\n        while(n>0){\\n            prod = prod*2;\\n            for(int i=p.size()-1; i>-1; i--) p.emplace_back(p[i]+prod);\\n            n--;\\n        }\\n\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> p = {0, 1};\\n        n--;\\n\\n        int prod = 1;\\n        while(n>0){\\n            prod = prod*2;\\n            for(int i=p.size()-1; i>-1; i--) p.emplace_back(p[i]+prod);\\n            n--;\\n        }\\n\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737460,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151508,
                "title": "gray-code-rust-fast-and-easy-solution-beats-100-in-both-time-and-space-complexity",
                "content": "# Intuition\\nI knew there was some technique to calculate gray code from the binary number. I had learnt that in the first semester in the subject Digital Logic class. So wanted to convert that technique to bitwise operations.\\n\\n# Approach\\nEssentially, what you need to do is, you have to XOR the first bit with the next bit, and do it sequencially till the end. The very first bit is copied as it is, and all the subsequent bits is computed from the XOR operation between adjacent bits, till the end.\\n\\nLet us understand from the example below:\\n101110011:\\n```\\n1   0   1   1   1   0   0   1   1\\n|\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\n| \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ |\\n|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|\\n1   1   1   0   0   1   0   1   0\\n```\\nSo, all you need to do is iterate from 0 to 2^n and convert all the numbers into gray code.\\n\\nNow, 2^n can be done very cheaply using ` 1 << n`, and the operation shown above can be achieved by the bitwise operation `n ^ (n >> 1)`.\\n\\nWe can see that from following:\\n```\\nRemember, second binary number is the first binary number right shifted once.\\n 1  0  1  1  1  0  0  1  1\\n^0  1  0  1  1  1  0  0  1\\n-|--|--|--|--|--|--|--|--|-\\n 1  1  1  0  0  1  0  1  0\\n```\\n\\nFrom that, we can just use the iterator, map each element to it\\'s equivalent gray code, and collect it to a vector.\\n\\n# Complexity\\n- Time complexity:\\nTime complexity would be $$O(2^n)$$, since we have to create 2^n elements in output, which is created one by one.\\n\\n- Space complexity:\\nSpace complexity would also be $$O(2^n)$$, for the same reason as time complexity (we have to create vector list containint 2^n elements.)\\n\\n# Code\\nThe code is as simple as it looks:\\nIt iterates from 0 to 2^n, converts each one to equivalent gray code, and collects it to a vector.\\n```\\nimpl Solution {\\n    pub fn gray_code(n: i32) -> Vec<i32> {\\n        (0..(1<<n)).map(into_gray).collect()\\n    }\\n}\\n#[inline]\\nfn into_gray(n : i32) -> i32 {\\n    n ^ (n >> 1)\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n1   0   1   1   1   0   0   1   1\\n|\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\n| \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ |\\n|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|\\n1   1   1   0   0   1   0   1   0\\n```\n```\\nRemember, second binary number is the first binary number right shifted once.\\n 1  0  1  1  1  0  0  1  1\\n^0  1  0  1  1  1  0  0  1\\n-|--|--|--|--|--|--|--|--|-\\n 1  1  1  0  0  1  0  1  0\\n```\n```\\nimpl Solution {\\n    pub fn gray_code(n: i32) -> Vec<i32> {\\n        (0..(1<<n)).map(into_gray).collect()\\n    }\\n}\\n#[inline]\\nfn into_gray(n : i32) -> i32 {\\n    n ^ (n >> 1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2695237,
                "title": "easy-to-understand-python-solution-faster-than-95",
                "content": "```\\n# logic is:\\n# for 1- [0,1]\\n# for 2 - [0,1,3,2] - not that first half of array is same as for n=1 addition for i=2 is (2**1)+1 => 3, (2**1)+0 => 2\\n# that is [0,1,1,0] => first half of array + concatenate reverse part of array and add powers of 2 to it  \\noldArr = [0,1]\\ni = 1\\nwhile i< n:\\n\\t# add old array\\n\\tnewArr = list(oldArr)\\n\\t# now add bit value to old reversed values\\n\\tfor j in range(len(oldArr)-1,-1,-1):\\n\\t\\tnewArr.append((2**i)+oldArr[j])\\n\\toldArr = newArr\\n\\ti+=1\\nreturn oldArr",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# logic is:\\n# for 1- [0,1]\\n# for 2 - [0,1,3,2] - not that first half of array is same as for n=1 addition for i=2 is (2**1)+1 => 3, (2**1)+0 => 2\\n# that is [0,1,1,0] => first half of array + concatenate reverse part of array and add powers of 2 to it  \\noldArr = [0,1]\\ni = 1\\nwhile i< n:\\n\\t# add old array\\n\\tnewArr = list(oldArr)\\n\\t# now add bit value to old reversed values\\n\\tfor j in range(len(oldArr)-1,-1,-1):\\n\\t\\tnewArr.append((2**i)+oldArr[j])\\n\\toldArr = newArr\\n\\ti+=1\\nreturn oldArr",
                "codeTag": "Unknown"
            },
            {
                "id": 2501346,
                "title": "easy-simple-small-in-o-n-n-2-time-complexity",
                "content": "```\\nimport math\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        n2=2**n\\n        ans=[]\\n        for j in range(n2):\\n            st=0\\n            for i in range(n):\\n                if(((1<<i)&j>0 and (1<<(i+1))&j==0) or ((1<<i)&j==0 and (1<<(i+1))&j>0)):\\n                    st+=2**i\\n            ans.append(st)\\n        return(ans)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        n2=2**n\\n        ans=[]\\n        for j in range(n2):\\n            st=0\\n            for i in range(n):\\n                if(((1<<i)&j>0 and (1<<(i+1))&j==0) or ((1<<i)&j==0 and (1<<(i+1))&j>0)):\\n                    st+=2**i\\n            ans.append(st)\\n        return(ans)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472189,
                "title": "direct-solution-faster-than-99-53-submissions",
                "content": "```\\n\\t\\tvector<int> out;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            out.push_back(i ^(i>>1));\\n        }\\n        return out;\\n```\\n\\nSo, gray code works as follows :  Instead of 3 i.e 110 : It is 101\\nHow?? Each bit position stays the same if the next bit is 0, else flips. \\nIn place of 0b\\'abcd : we get a1_b1_c1_d1. d1==d, if c1 is 0. else flips\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tc1=c, if b1=0. else flips\\nThus the output current bit depends on the input next bit.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\t\\tvector<int> out;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            out.push_back(i ^(i>>1));\\n        }\\n        return out;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406111,
                "title": "clean-code",
                "content": "```\\nint gray(int n) {\\n        return n ^ (n >> 1);\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        n=1<<n;\\n        vector<int> ans(n); // specifying size of vector is important, otherwise Runtime Error\\n        for(int i=0; i<n; i++){\\n            ans[i]= gray(i);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint gray(int n) {\\n        return n ^ (n >> 1);\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        n=1<<n;\\n        vector<int> ans(n); // specifying size of vector is important, otherwise Runtime Error\\n        for(int i=0; i<n; i++){\\n            ans[i]= gray(i);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171923,
                "title": "one-liner-python-solution-using-xor-and-right-shift",
                "content": "**Algorithm:**\\n1) Traverse from 0 to 2**n\\n2) In each iteration, right shift the number once and xor it with the original number to obtain the gray code.\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        ans = []\\n        for i in range(2**n):\\n            ans.append(i ^ (i>>1))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        ans = []\\n        for i in range(2**n):\\n            ans.append(i ^ (i>>1))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105684,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = [0]\\n        visited = set()\\n        visited.add(0)\\n        self.grayCodeHelper(n, visited, result)\\n        return result\\n    \\n    def grayCodeHelper(self, n, visited, result):\\n        \\n        if len(result) == 1 << n:\\n            return True\\n        \\n        \\n        last_number = result[-1]\\n        \\n        for i in range(0,n):\\n            new_number = last_number ^ (1 << i)\\n                \\n            if new_number not in visited:\\n                visited.add(new_number)\\n                result.append(new_number)\\n                if self.grayCodeHelper(n, visited, result):\\n                    return True\\n                result.pop(-1)\\n                visited.remove(new_number)\\n        return False\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = [0]\\n        visited = set()\\n        visited.add(0)\\n        self.grayCodeHelper(n, visited, result)\\n        return result\\n    \\n    def grayCodeHelper(self, n, visited, result):\\n        \\n        if len(result) == 1 << n:\\n            return True\\n        \\n        \\n        last_number = result[-1]\\n        \\n        for i in range(0,n):\\n            new_number = last_number ^ (1 << i)\\n                \\n            if new_number not in visited:\\n                visited.add(new_number)\\n                result.append(new_number)\\n                if self.grayCodeHelper(n, visited, result):\\n                    return True\\n                result.pop(-1)\\n                visited.remove(new_number)\\n        return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 2046672,
                "title": "observation-easy-c-solution-bit-manipulation",
                "content": "// Just observe the pattern how there is difference between bits in the input and accordingly perform the bits //operation\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>answer;               // create a vector to store the answer\\n        for(int i=0;i<=pow(2,n)-1;i++){      // traverse till 2^n-1 and push (i^(i>>1)) in the answer\\n            answer.push_back(i^(i>>1));\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE IF YOU FIND IT HELPFUL:)\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>answer;               // create a vector to store the answer\\n        for(int i=0;i<=pow(2,n)-1;i++){      // traverse till 2^n-1 and push (i^(i>>1)) in the answer\\n            answer.push_back(i^(i>>1));\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770100,
                "title": "gray-code-solution-java",
                "content": "class Solution {\\n  public List<Integer> grayCode(int n) {\\n    List<Integer> ans = new ArrayList<>();\\n    ans.add(0);\\n\\n    for (int i = 0; i < n; ++i)\\n      for (int j = ans.size() - 1; j >= 0; --j)\\n        ans.add(ans.get(j) | 1 << i);\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n  public List<Integer> grayCode(int n) {\\n    List<Integer> ans = new ArrayList<>();\\n    ans.add(0);\\n\\n    for (int i = 0; i < n; ++i)\\n      for (int j = ans.size() - 1; j >= 0; --j)\\n        ans.add(ans.get(j) | 1 << i);\\n\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1749052,
                "title": "several-ways-to-solve-it-cpp-can-t-be-more-simpler",
                "content": "**Way 1 : **\\n\\n![image](https://assets.leetcode.com/users/images/df66a229-1c9b-49d8-b2c8-6b4dcca8a620_1644127722.321113.png)\\n\\nIf you observe carefully gray(n) = gray(n-1) above the lines + gray(n-1) in reverse bellow the lines with extra 1!!\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1) return {0,1};\\n        \\n        vector<int> p= grayCode(n-1);\\n        vector<int> q=p;reverse(q.begin(),q.end());\\n        int inc= 1<<(n-1);\\n        for(auto &i : q) i+=inc;\\n        p.insert(p.end(),q.begin(),q.end());\\n        \\n        return p;\\n    }\\n};\\n\\n```\\n\\n\\n**Way 2 **\\n\\n```\\nvector<int> grayCode(int n) {\\n      vector<int>ans;\\n        ans.push_back(0);\\n        if(n == 0) return ans;\\n        ans.push_back(1);\\n        \\n        int curr = 1;\\n        for(int i = 2; i <= n; i++){\\n          curr*=2;\\n            for(int j = ans.size()-1; j >= 0; j--) \\n                ans.push_back(curr+ans[j]);\\n        }    \\n        return ans;\\n    }: \\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1) return {0,1};\\n        \\n        vector<int> p= grayCode(n-1);\\n        vector<int> q=p;reverse(q.begin(),q.end());\\n        int inc= 1<<(n-1);\\n        for(auto &i : q) i+=inc;\\n        p.insert(p.end(),q.begin(),q.end());\\n        \\n        return p;\\n    }\\n};\\n\\n```\n```\\nvector<int> grayCode(int n) {\\n      vector<int>ans;\\n        ans.push_back(0);\\n        if(n == 0) return ans;\\n        ans.push_back(1);\\n        \\n        int curr = 1;\\n        for(int i = 2; i <= n; i++){\\n          curr*=2;\\n            for(int j = ans.size()-1; j >= 0; j--) \\n                ans.push_back(curr+ans[j]);\\n        }    \\n        return ans;\\n    }: \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714940,
                "title": "c-97-faster-nth-gray-code",
                "content": "For a given number `n`, the n-bit gray code can be found as `n^(n/2)`\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> grayCode(int n) \\n    {\\n        vector<int> ans;\\n        int t = pow(2,n);\\n        int i=0;\\n        while(i<t)\\n        {\\n            ans.push_back(i^(i/2));\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> grayCode(int n) \\n    {\\n        vector<int> ans;\\n        int t = pow(2,n);\\n        int i=0;\\n        while(i<t)\\n        {\\n            ans.push_back(i^(i/2));\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663568,
                "title": "light-weight-python-solution",
                "content": "My solution:\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 0:\\n            return [0]\\n        rest = self.grayCode(n - 1)\\n        # everytime it builds one set, reverse the front part\\n        return [ r << 1 for r in rest] + [ (r << 1) + 1 for r in rest[::-1]]\\n```\\n\\nThat was evolved from my first submission which is this:\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = set()\\n        def backtrack(i):\\n            if i == 0:\\n                return [[]]\\n            rest = backtrack(i - 1)\\n            result = []\\n            for r in rest:\\n                result.append(r + [\\'0\\'])\\n            for r in rest[::-1]:\\n                result.append(r + [\\'1\\'])\\n            return result\\n        \\n        return [ int(\"\".join(ar), 2) for ar in backtrack(n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 0:\\n            return [0]\\n        rest = self.grayCode(n - 1)\\n        # everytime it builds one set, reverse the front part\\n        return [ r << 1 for r in rest] + [ (r << 1) + 1 for r in rest[::-1]]\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = set()\\n        def backtrack(i):\\n            if i == 0:\\n                return [[]]\\n            rest = backtrack(i - 1)\\n            result = []\\n            for r in rest:\\n                result.append(r + [\\'0\\'])\\n            for r in rest[::-1]:\\n                result.append(r + [\\'1\\'])\\n            return result\\n        \\n        return [ int(\"\".join(ar), 2) for ar in backtrack(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519011,
                "title": "python-one-liner-short-explanation",
                "content": "Picture a cube. 2x2.\\n\\nYou start at the top-left-front corner, labeled `000`. Move back along an edge to the top-left-back corner to get `001`. Looks like just increasing by 1 each time, but if we go to 2 (corner `010`) we change two bits. Hop to the right to 3 instead, which is at corner `011`. Then, we can go to 2 `010`.\\n\\nSo, when we switch to the right side of the cube (i.e. when we switch the second digit to `1`) we go the opposite direction, starting from the top (3) and decreasing (to 2), in effect inverting the third digit.\\n\\nAs we continue this reversing onto the bottom side of the cube (go for a tesseract if you\\'re feeling particularly marvelous), a bitwise pattern emerges. Take the binary representations of the counting numbers (the boringest way to say `000`, `001`, `010`, `011`, `100`, etc.) and whenever there is a `1` (the equivalent of being on the \"backwards\" side of the cube), invert the next bit. In a truth table, with the current bit on the side and previous bit on the top, you get\\n\\n```\\n    0  1\\n    ----\\n0 | 0  1\\n1 | 1  0\\n```\\n\\nOh neat! That looks like `XOR`! So we just want to `XOR` each number with itself, but pushed over one to the right. Bit of golf to iterate through the numbers from 0 to 2^n, right shift it over once, and then save the `XOR` result in a list.\\n\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i^(i>>1) for i in range(1<<n)]\\n```\\n\\nAlso, this provides a O(1) function to retrieve the value in the sequence at *any* index. Which is neat.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    0  1\\n    ----\\n0 | 0  1\\n1 | 1  0\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i^(i>>1) for i in range(1<<n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498963,
                "title": "gray-code-solution-in-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        if(n==1){\\n            List<Integer> list = new ArrayList<Integer>();\\n            list.add(0);\\n            list.add(1);\\n            return list;\\n        }\\n        \\n        List<Integer> pres = grayCode(n-1);\\n        List<Integer> mres = new ArrayList<Integer>();\\n        for(int i=0;i<pres.size();i++){\\n            mres.add(0+2*pres.get(i));\\n        }\\n        for(int i=pres.size()-1 ; i>=0;i--){\\n            mres.add(1+2*pres.get(i));\\n        }\\n        \\n        return mres;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        if(n==1){\\n            List<Integer> list = new ArrayList<Integer>();\\n            list.add(0);\\n            list.add(1);\\n            return list;\\n        }\\n        \\n        List<Integer> pres = grayCode(n-1);\\n        List<Integer> mres = new ArrayList<Integer>();\\n        for(int i=0;i<pres.size();i++){\\n            mres.add(0+2*pres.get(i));\\n        }\\n        for(int i=pres.size()-1 ; i>=0;i--){\\n            mres.add(1+2*pres.get(i));\\n        }\\n        \\n        return mres;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564717,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1565251,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1566741,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1568912,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1766371,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1571197,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1786326,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1785411,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1573702,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 2006483,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1564717,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1565251,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1566741,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1568912,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1766371,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1571197,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1786326,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1785411,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1573702,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 2006483,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1568911,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1996171,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1571198,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1573155,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 2059245,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 2022337,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 2016675,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1990286,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1960932,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1906517,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            }
        ]
    },
    {
        "title": "Rotate Array",
        "question_content": "<p>Given an integer array <code>nums</code>, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5,6,7], k = 3\n<strong>Output:</strong> [5,6,7,1,2,3,4]\n<strong>Explanation:</strong>\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-100,3,99], k = 2\n<strong>Output:</strong> [3,99,-1,-100]\n<strong>Explanation:</strong> \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Try to come up with as many solutions as you can. There are at least <strong>three</strong> different ways to solve this problem.</li>\n\t<li>Could you do it in-place with <code>O(1)</code> extra space?</li>\n</ul>\n",
        "solutions": [
            {
                "id": 54250,
                "title": "easy-to-read-java-solution",
                "content": "I really don't like those _*something little*_ line solutions as they are incredibly hard to read. Below is my solution.\\n\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        reverse(nums, 0, nums.length - 1);\\n        reverse(nums, 0, k - 1);\\n        reverse(nums, k, nums.length - 1);\\n    }\\n    \\n    public void reverse(int[] nums, int start, int end) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I really don't like those _*something little*_ line solutions as they are incredibly hard to read. Below is my solution.\\n\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        reverse(nums, 0, nums.length - 1);\\n        reverse(nums, 0, k - 1);\\n        reverse(nums, k, nums.length - 1);\\n    }\\n    \\n    public void reverse(int[] nums, int start, int end) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54277,
                "title": "summary-of-c-solutions",
                "content": "#1. Make an extra copy and then rotate. \\nTime complexity: O(n). Space complexity: O(n).\\n    \\n        class Solution \\n        {\\n        public:\\n            void rotate(int nums[], int n, int k) \\n            {\\n                if ((n == 0) || (k <= 0))\\n                {\\n                    return;\\n                }\\n                \\n                // Make a copy of nums\\n                vector<int> numsCopy(n);\\n                for (int i = 0; i < n; i++)\\n                {\\n                    numsCopy[i] = nums[i];\\n                }\\n                \\n                // Rotate the elements.\\n                for (int i = 0; i < n; i++)\\n                {\\n                    nums[(i + k)%n] = numsCopy[i];\\n                }\\n            }\\n        };\\n\\n#2. Start from one element and keep rotating until we have rotated n different elements.\\nTime complexity: O(n). Space complexity: O(1).\\n    \\n        class Solution \\n        {\\n        public:\\n            void rotate(int nums[], int n, int k) \\n            {\\n                if ((n == 0) || (k <= 0))\\n                {\\n                    return;\\n                }\\n                \\n                int cntRotated = 0;\\n                int start = 0;\\n                int curr = 0;\\n                int numToBeRotated = nums[0];\\n                int tmp = 0;\\n                // Keep rotating the elements until we have rotated n \\n                // different elements.\\n                while (cntRotated < n)\\n                {\\n                    do\\n                    {\\n                        tmp = nums[(curr + k)%n];\\n                        nums[(curr+k)%n] = numToBeRotated;\\n                        numToBeRotated = tmp;\\n                        curr = (curr + k)%n;\\n                        cntRotated++;\\n                    } while (curr != start);\\n                    // Stop rotating the elements when we finish one cycle, \\n                    // i.e., we return to start.\\n                    \\n                    // Move to next element to start a new cycle.\\n                    start++;\\n                    curr = start;\\n                    numToBeRotated = nums[curr];\\n                }\\n            }\\n        };\\n    \\n#3. Reverse the first n - k elements, the last k elements, and then all the n elements.\\nTime complexity: O(n). Space complexity: O(1).\\n        \\n        class Solution \\n        {\\n        public:\\n            void rotate(int nums[], int n, int k) \\n            {\\n                k = k%n;\\n        \\n                // Reverse the first n - k numbers.\\n                // Index i (0 <= i < n - k) becomes n - k - i.\\n                reverse(nums, nums + n - k);\\n                \\n                // Reverse tha last k numbers.\\n                // Index n - k + i (0 <= i < k) becomes n - i.\\n                reverse(nums + n - k, nums + n);\\n                \\n                // Reverse all the numbers.\\n                // Index i (0 <= i < n - k) becomes n - (n - k - i) = i + k.\\n                // Index n - k + i (0 <= i < k) becomes n - (n - i) = i.\\n                reverse(nums, nums + n);\\n            }\\n        };\\n\\n#4. Swap the last k elements with the first k elements.\\nTime complexity: O(n). Space complexity: O(1).\\n\\n    class Solution \\n    {\\n    public:\\n        void rotate(int nums[], int n, int k) \\n        {\\n            for (; k = k%n; n -= k, nums += k)\\n            {\\n                // Swap the last k elements with the first k elements. \\n                // The last k elements will be in the correct positions\\n                // but we need to rotate the remaining (n - k) elements \\n                // to the right by k steps.\\n                for (int i = 0; i < k; i++)\\n                {\\n                    swap(nums[i], nums[n - k + i]);\\n                }\\n            }\\n        }\\n    };\\n\\n#5. Keep swapping two subarrays.\\nTime complexity: O(n). Space complexity: O(1).\\n    \\n    class Solution \\n    {\\n    public:\\n        void rotate(int nums[], int n, int k) \\n        {\\n            if ((n == 0) || (k <= 0) || (k%n == 0))\\n            {\\n                return;\\n            }\\n            \\n            k = k%n;\\n            // Rotation to the right by k steps is equivalent to swapping \\n            // the two subarrays nums[0,...,n - k - 1] and nums[n - k,...,n - 1].\\n            int start = 0;\\n            int tmp = 0;\\n            while (k > 0)\\n            {\\n                if (n - k >= k)\\n                {\\n                    // The left subarray with size n - k is longer than \\n                    // the right subarray with size k. Exchange \\n                    // nums[n - 2*k,...,n - k - 1] with nums[n - k,...,n - 1].\\n                    for (int i = 0; i < k; i++)\\n                    {\\n                        tmp = nums[start + n - 2*k + i];\\n                        nums[start + n - 2*k + i] = nums[start + n - k + i];\\n                        nums[start + n - k + i] = tmp;\\n                    }\\n                    \\n                    // nums[n - 2*k,...,n - k - 1] are in their correct positions now.\\n                    // Need to rotate the elements of nums[0,...,n - k - 1] to the right \\n                    // by k%n steps.\\n                    n = n - k;\\n                    k = k%n;\\n                }\\n                else\\n                {\\n                    // The left subarray with size n - k is shorter than \\n                    // the right subarray with size k. Exchange \\n                    // nums[0,...,n - k - 1] with nums[n - k,...,2*(n - k) - 1].\\n                    for (int i = 0; i < n - k; i++)\\n                    {\\n                        tmp = nums[start + i];\\n                        nums[start + i] = nums[start + n - k + i];\\n                        nums[start + n - k + i] = tmp;\\n                    }\\n                    \\n                    // nums[n - k,...,2*(n - k) - 1] are in their correct positions now.\\n                    // Need to rotate the elements of nums[n - k,...,n - 1] to the right \\n                    // by k - (n - k) steps.\\n                    tmp = n - k;\\n                    n = k;\\n                    k -= tmp;\\n                    start += tmp;\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution \\n        {\\n        public:\\n            void rotate(int nums[], int n, int k) \\n            {\\n                if ((n == 0) || (k <= 0))\\n                {\\n                    return;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1730142,
                "title": "java-c-python-a-very-very-well-detailed-explanation",
                "content": "```\\nWell, to be honest with you all. This is really not a hard problem! It\\'s an easy one\\n```\\n\\nAlright, what the question is saying that we have **given an array & we have to rotate the array to the right by k steps, where k is non-negative.**\\n```\\nOkay so, we have one thing that k will always be > 0.\\nBut, I will teach you, one bonus point as well what if k < 0 i.e. k is -ve then how can you rotate the array.\\n```\\nLet\\'s undertsand this problem using an example,\\n**Input:** nums = [1,2,3,4,5,6,7], k = 3\\n**Output:** [5,6,7,1,2,3,4]\\n\\n```\\n\"K all possible rotation\"\\n\\n[7,1,2,3,4,5,6], k = 1\\n[6,7,1,2,3,4,5], k = 2\\n[5,6,7,1,2,3,4], k = 3\\n[4,5,6,7,1,2,3], k = 4\\n[3,4,5,6,7,1,2], k = 5\\n[2,3,4,5,6,7,1], k = 6\\n[1,2,3,4,5,6,7], k = 7\\n```\\n\\nWe have **k is 3**, so it means we have to take **3 values from the back** and **put in the front** of the array values.\\n\\nSo, for that what we will do is, we will break Array into 2 parts. **Part1[P1] & Part2[P2]**\\n* `[P1] is defined as` the array part just before the last 3 values. What I mean is something like [1,2,3,4]\\n* `[P2] is defined as` the array part just after remaining values which we have to rotate [5,6,7]\\n\\n![image](https://assets.leetcode.com/users/images/bafbf0fc-198b-4fe2-b4e9-974330840daf_1643513368.0827003.png)\\n\\nSo, in order to rotate this Array **k times** what we will do is, we will reverse the **P1 first which become [4,3,2,1]** & then we **reverse P2 which becomes [7,6,5]**\\nNow finally what we have to do is we gonna **reverse the complete array** by doing that what will happen is our array become **[5,6,7,1,2,3,4]** and that\\'s what we want in our **Output**\\n\\n![image](https://assets.leetcode.com/users/images/b303db4f-a485-41ef-9b0a-1e5141c634d3_1643514374.4636352.png)\\n\\nBut, what if we have **k = 101**, then we will **not rotate it** 101 times. It simply means **till 100 times it will be [1,2,3,4,5,6,7]** & we have to **rotate only 1 time i.e. [7,1,2,3,4,5,6]**. So, now your question is how can we handle this, we simply do the **modulo of \"k\"** with length of array\\n```\\nOkay Bonus point what if we have k = -1, then how can we rotate the array. If k is -1 then we have to rotate the value backward not in the front.\\nEg - \\nInput : [1,2,3,4,5,6,7], k = -1\\nOutput : [2,3,4,5,6,7,1]\\n\\nNow how did we figure out this, if you carefully look that k = -1 is equals to k = 6.\\nJust look at the table which I have made for every possible k values\\n\\nSo, what It represent is that add the -ve value to the length of array. And you will get your answer!\\n```\\n\\n*I hope Approach is crystal clear now!* **Let\\'s do some dirty work**, `\"code it up\"`\\n\\n*code each line explained :* `Similar for C++, Java, Python` **{Only Syntax Difference}** approach same\\n* Step - 1\\n```\\n// reversing the array values\\n    public static void reverse(int nums[], int i, int j){\\n        int li = i; // left index;\\n        int ri = j; // right index\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }\\n    }\\n```\\n* Step - 2\\n```\\npublic void rotate(int[] nums, int k) {\\n        k = k % nums.length; // if we have let\\'s say 101 to rotate, then we only rotate it 1 time not 101 times\\n        if(k < 0){ // if we get -ve value, then -ve is just equals to it\\'s -ve + array.length\\n            k += nums.length;\\n        }\\n        // part 1 reverse\\n        reverse(nums, 0, nums.length - k - 1);\\n        // part 2 reverse\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        // complete reverse\\n        reverse(nums, 0, nums.length - 1);\\n    }\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n\\t public static void reverse(int nums[], int i, int j){\\n        int li = i;\\n        int ri = j;\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length; \\n        if(k < 0){ \\n            k += nums.length;\\n        }\\n        reverse(nums, 0, nums.length - k - 1);\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        reverse(nums, 0, nums.length - 1);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\n    public :\\n    void reverse(vector<int>& nums, int i, int j){\\n        int li = i; // left;\\n        int ri = j;\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        if(k < 0){ \\n            k += nums.size();\\n        }\\n        reverse(nums, 0, nums.size() - k - 1);\\n        reverse(nums, nums.size() - k, nums.size() - 1);\\n        reverse(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def reverse (self, nums, i, j) : \\n        li = i\\n        ri = j\\n        \\n        while li < ri:\\n            temp = nums[li]\\n            nums[li] = nums[ri]\\n            nums[ri] = temp\\n            \\n            li += 1\\n            ri -= 1\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = k % len(nums)\\n        if k < 0 : \\n            k += len(nums)\\n        \\n        self.reverse(nums, 0, len(nums) - k - 1);\\n        self.reverse(nums, len(nums) - k, len(nums) - 1);\\n        self.reverse(nums, 0, len(nums) - 1);\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(1)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nWell, to be honest with you all. This is really not a hard problem! It\\'s an easy one\\n```\n```\\nOkay so, we have one thing that k will always be > 0.\\nBut, I will teach you, one bonus point as well what if k < 0 i.e. k is -ve then how can you rotate the array.\\n```\n```\\n\"K all possible rotation\"\\n\\n[7,1,2,3,4,5,6], k = 1\\n[6,7,1,2,3,4,5], k = 2\\n[5,6,7,1,2,3,4], k = 3\\n[4,5,6,7,1,2,3], k = 4\\n[3,4,5,6,7,1,2], k = 5\\n[2,3,4,5,6,7,1], k = 6\\n[1,2,3,4,5,6,7], k = 7\\n```\n```\\nOkay Bonus point what if we have k = -1, then how can we rotate the array. If k is -1 then we have to rotate the value backward not in the front.\\nEg - \\nInput : [1,2,3,4,5,6,7], k = -1\\nOutput : [2,3,4,5,6,7,1]\\n\\nNow how did we figure out this, if you carefully look that k = -1 is equals to k = 6.\\nJust look at the table which I have made for every possible k values\\n\\nSo, what It represent is that add the -ve value to the length of array. And you will get your answer!\\n```\n```\\n// reversing the array values\\n    public static void reverse(int nums[], int i, int j){\\n        int li = i; // left index;\\n        int ri = j; // right index\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }\\n    }\\n```\n```\\npublic void rotate(int[] nums, int k) {\\n        k = k % nums.length; // if we have let\\'s say 101 to rotate, then we only rotate it 1 time not 101 times\\n        if(k < 0){ // if we get -ve value, then -ve is just equals to it\\'s -ve + array.length\\n            k += nums.length;\\n        }\\n        // part 1 reverse\\n        reverse(nums, 0, nums.length - k - 1);\\n        // part 2 reverse\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        // complete reverse\\n        reverse(nums, 0, nums.length - 1);\\n    }\\n```\n```\\nclass Solution {\\n\\t public static void reverse(int nums[], int i, int j){\\n        int li = i;\\n        int ri = j;\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length; \\n        if(k < 0){ \\n            k += nums.length;\\n        }\\n        reverse(nums, 0, nums.length - k - 1);\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        reverse(nums, 0, nums.length - 1);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public :\\n    void reverse(vector<int>& nums, int i, int j){\\n        int li = i; // left;\\n        int ri = j;\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        if(k < 0){ \\n            k += nums.size();\\n        }\\n        reverse(nums, 0, nums.size() - k - 1);\\n        reverse(nums, nums.size() - k, nums.size() - 1);\\n        reverse(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reverse (self, nums, i, j) : \\n        li = i\\n        ri = j\\n        \\n        while li < ri:\\n            temp = nums[li]\\n            nums[li] = nums[ri]\\n            nums[ri] = temp\\n            \\n            li += 1\\n            ri -= 1\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = k % len(nums)\\n        if k < 0 : \\n            k += len(nums)\\n        \\n        self.reverse(nums, 0, len(nums) - k - 1);\\n        self.reverse(nums, len(nums) - k, len(nums) - 1);\\n        self.reverse(nums, 0, len(nums) - 1);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54252,
                "title": "java-o-1-space-solution-of-rotate-array",
                "content": "The basic idea is that, for example, nums = [1,2,3,4,5,6,7] and k = 3, first we reverse [1,2,3,4], it becomes[4,3,2,1]; then we reverse[5,6,7], it becomes[7,6,5], finally we reverse the array as a whole, it becomes[4,3,2,1,7,6,5] ---> [5,6,7,1,2,3,4].\\n\\nReverse is done by using two pointers, one point at the head and the other point at the tail, after switch these two, these two pointers move one position towards the middle. \\n\\n\\npublic class Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n\\n        if(nums == null || nums.length < 2){\\n            return;\\n        }\\n        \\n        k = k % nums.length;\\n        reverse(nums, 0, nums.length - k - 1);\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        reverse(nums, 0, nums.length - 1);\\n        \\n    }\\n    \\n    private void reverse(int[] nums, int i, int j){\\n        int tmp = 0;       \\n        while(i < j){\\n            tmp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = tmp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n\\n        if(nums == null || nums.length < 2){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54294,
                "title": "my-solution-by-using-python",
                "content": "    class Solution:\\n        # @param nums, a list of integer\\n        # @param k, num of steps\\n        # @return nothing, please modify the nums list in-place.\\n        def rotate(self, nums, k):\\n            n = len(nums)\\n            k = k % n\\n            nums[:] = nums[n-k:] + nums[:n-k]\\n        \\n\\nA little important thing to be cautious:  \\n\\n    nums[:] = nums[n-k:] + nums[:n-k] \\ncan't be written as:\\n\\n    nums = nums[n-k:] + nums[:n-k]\\n\\non the OJ. \\n    \\nThe previous one can truly change the value of **old** *nums*, but the following one just changes its reference to a **new** *nums* not the value of **old** *nums*.",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param nums, a list of integer\\n        # @param k, num of steps\\n        # @return nothing, please modify the nums list in-place.\\n        def rotate(self, nums, k):\\n            n = len(nums)\\n            k = k % n\\n            nums[:] = nums[n-k:] + nums[:n-k]\\n        \\n\\nA little important thing to be cautious:  \\n\\n    nums[:] = nums[n-k:] + nums[:n-k] \\ncan't be written as:\\n\\n    nums = nums[n-k:] + nums[:n-k]\\n\\non the OJ. \\n    \\nThe previous one can truly change the value of **old** *nums*, but the following one just changes its reference to a **new** *nums* not the value of **old** *nums*.",
                "codeTag": "Java"
            },
            {
                "id": 3506340,
                "title": "beats-100-3-line-solution-fully-most-optimised-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExample:-1234567 ,k=3\\n1.first reverse the numbers form index 0 to n-k;\\n->4321 567\\n2.reverse the k elements from the last \\n->4321 765\\n3.now reverse the whole nums;\\n->5671234 Done Answer is here !!!!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        // vector<int>temp;\\n        // int len=nums.size();\\n        // int j=0;\\n        // k=k%len;\\n        // for(int i=0;i<abs(len-k);i++)\\n        // {\\n        //     //1,2,3,4\\n        //     cout<<nums[i]<<\" \";\\n        //     temp.push_back(nums[i]);\\n        // }\\n        // cout<<endl;\\n        // for(int i=abs(len-k);i<len;i++)\\n        // {\\n        //     //5,6,7\\n\\n        //     cout<<nums[i]<<endl;\\n        //     nums[abs(i-abs(len-k))]=nums[i];\\n        // }\\n        // for(int i=k;i<len;i++)\\n        // {\\n        //     nums[i]=temp[j];\\n        //     j++;\\n        // }\\n        \\n        k=k%nums.size();\\n        reverse(nums.begin(),nums.begin()+(nums.size()-k));\\n\\n        reverse(nums.begin()+(nums.size()-k),nums.end());\\n    \\n        reverse(nums.begin(),nums.end());\\n            \\n\\n        \\n        \\n\\n        \\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/be16a9b6-6d5f-433f-89e8-90f18384d6f9_1683670956.5248532.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        // vector<int>temp;\\n        // int len=nums.size();\\n        // int j=0;\\n        // k=k%len;\\n        // for(int i=0;i<abs(len-k);i++)\\n        // {\\n        //     //1,2,3,4\\n        //     cout<<nums[i]<<\" \";\\n        //     temp.push_back(nums[i]);\\n        // }\\n        // cout<<endl;\\n        // for(int i=abs(len-k);i<len;i++)\\n        // {\\n        //     //5,6,7\\n\\n        //     cout<<nums[i]<<endl;\\n        //     nums[abs(i-abs(len-k))]=nums[i];\\n        // }\\n        // for(int i=k;i<len;i++)\\n        // {\\n        //     nums[i]=temp[j];\\n        //     j++;\\n        // }\\n        \\n        k=k%nums.size();\\n        reverse(nums.begin(),nums.begin()+(nums.size()-k));\\n\\n        reverse(nums.begin()+(nums.size()-k),nums.end());\\n    \\n        reverse(nums.begin(),nums.end());\\n            \\n\\n        \\n        \\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 269948,
                "title": "4-solutions-in-python-from-easy-to-hard",
                "content": "A good start ito think a wayt out is brute force \\n\\n1. Approach #1 \\n\\n   varaible `previous` to store the number being replaced.\\n\\n   ```python\\n   class Solution1:\\n       def rotate(self, nums, k):\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           for _ in range(k):\\n               previous = nums[-1] #initiate a first previous \\n               for i in range(len(nums)):\\n                   temp = nums[i] #hodl nums[i]\\n                   nums[i] = previous #overwrite the current index \\n                   previous = temp #swap the value \\n           logging.debug(f\"nums: {nums}\")\\n   ```\\n\\n   **Complexity Analysis**\\n\\n   - Time complexity : O( *n*\\u2217*k*). All the numbers are shifted by one step(O (n)*O*(*n*)) k times(O (k)*O* ( *k* ) ).\\n   - Space complexity : O(1). No extra space is used.\\n\\n2. Approch #2 Using Extra Array\\n\\n   We use an extra array in which we place every element of the array at its correct position i.e. the number at index i*i* in the original array is placed at the index (i+k)%(length of array)(*i*+*k*). Then, we copy the new array to the original one.\\n\\n   ```python\\n   class Solution2:\\n       def rotate(self, nums, k):\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           a = [0] * len(nums)\\n           for i in range(len(nums)):\\n               a[(i+k)%len(nums)] = nums[i] #recycle\\n   \\n           for i in range(len(nums)):\\n               nums[i] = a[i]\\n   ```\\n\\n   **Complexity Analysis**\\n\\n   - Time complexity : O(n). One pass is used to put the numbers in the new array. And another pass to copy the new array to the original one.\\n   - Space complexity :O*(*n). Another array of the same size is used.\\n\\n\\n\\n3. Approach #3 Using Cyclic Replacements\\n\\n   ![solution 3](https://leetcode.com/media/original_images/189_Rotate_Array.png)\\n\\n   ```python\\n   class Solution3:\\n       def rotate(self, nums, k):\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           k = k % len(nums)\\n           count = 0\\n           start = 0\\n           while count < len(nums):\\n               current = start \\n               prev = nums[start] #store the value in the position\\n               \\n               while True:\\n                   next = (current + k) % len(nums) #\\n                   temp = nums[next] #store it temporaly \\n                   nums[next] = prev #overide the next \\n                   prev = temp #reset prev\\n                   current = next #reset current\\n                   count += 1\\n   \\n                   if start == current:\\n                       break \\n               \\n               start += 1\\n   ```\\n\\n   **Complexity Analysis**\\n\\n   - Time complexity : O(n). Only one pass is used.\\n   - Space complexity : O(1). Constant extra space is used.\\n\\n\\n\\n\\n\\n4. #### Approach #4 Using Reverse \\n\\n   **Algorithm**\\n\\n   This approach is based on the fact that when we rotate the array k times, k%n*k* elements from the back end of the array come to the front and the rest of the elements from the front shift backwards.\\n\\n   In this approach, we firstly reverse all the elements of the array. Then, reversing the first k elements followed by reversing the rest n-k*n*\\u2212*k*elements gives us the required result.\\n\\n   Let n=7*n*=7 and k=3*k*=3.\\n\\n   ```python\\n   Original List                   : 1 2 3 4 5 6 7\\n   After reversing all numbers     : 7 6 5 4 3 2 1\\n   After reversing first k numbers : 5 6 7 4 3 2 1\\n   After revering last n-k numbers : 5 6 7 1 2 3 4 --> Result\\n   ```\\n\\n   ```python\\n   class Solution4:\\n       def rotate(self, nums, k) -> None:\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           k %= len(nums)\\n           self.reverse(nums,0,len(nums)-1)\\n           self.reverse(nums,0, k-1)\\n           self.reverse(nums,k, len(nums)-1)\\n   \\n       def reverse(self, nums, start, end) -> None:\\n           \"\"\"\\n           :type nums: List[int]\\n           :type start: int\\n           :type end: int\\n           :rtype: None\\n           \"\"\"\\n           while start < end: #\\n               temp = nums[start]\\n               nums[start] = nums[end]\\n               nums[end] = temp \\n               start += 1\\n               end -= 1\\n   ```\\n\\n   \\n\\n   **Complexity Analysis**\\n\\n   - Time complexity : O(n) .n*n*elements are reversed a total of three times.\\n   - Space complexity : O(1). No extra space is used.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n   class Solution1:\\n       def rotate(self, nums, k):\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           for _ in range(k):\\n               previous = nums[-1] #initiate a first previous \\n               for i in range(len(nums)):\\n                   temp = nums[i] #hodl nums[i]\\n                   nums[i] = previous #overwrite the current index \\n                   previous = temp #swap the value \\n           logging.debug(f\"nums: {nums}\")\\n   ```\n```python\\n   class Solution2:\\n       def rotate(self, nums, k):\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           a = [0] * len(nums)\\n           for i in range(len(nums)):\\n               a[(i+k)%len(nums)] = nums[i] #recycle\\n   \\n           for i in range(len(nums)):\\n               nums[i] = a[i]\\n   ```\n```python\\n   class Solution3:\\n       def rotate(self, nums, k):\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           k = k % len(nums)\\n           count = 0\\n           start = 0\\n           while count < len(nums):\\n               current = start \\n               prev = nums[start] #store the value in the position\\n               \\n               while True:\\n                   next = (current + k) % len(nums) #\\n                   temp = nums[next] #store it temporaly \\n                   nums[next] = prev #overide the next \\n                   prev = temp #reset prev\\n                   current = next #reset current\\n                   count += 1\\n   \\n                   if start == current:\\n                       break \\n               \\n               start += 1\\n   ```\n```python\\n   Original List                   : 1 2 3 4 5 6 7\\n   After reversing all numbers     : 7 6 5 4 3 2 1\\n   After reversing first k numbers : 5 6 7 4 3 2 1\\n   After revering last n-k numbers : 5 6 7 1 2 3 4 --> Result\\n   ```\n```python\\n   class Solution4:\\n       def rotate(self, nums, k) -> None:\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           k %= len(nums)\\n           self.reverse(nums,0,len(nums)-1)\\n           self.reverse(nums,0, k-1)\\n           self.reverse(nums,k, len(nums)-1)\\n   \\n       def reverse(self, nums, start, end) -> None:\\n           \"\"\"\\n           :type nums: List[int]\\n           :type start: int\\n           :type end: int\\n           :rtype: None\\n           \"\"\"\\n           while start < end: #\\n               temp = nums[start]\\n               nums[start] = nums[end]\\n               nums[end] = temp \\n               start += 1\\n               end -= 1\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 3351511,
                "title": "java-100-faster-soluion-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/2dbd188f-23fb-4f11-a067-e48f48a3a491_1680007896.3123865.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static void reverse(int nums[], int start, int end){\\n    // While start index is less than end index\\n    while(start < end){\\n        // Swap elements at start and end indices\\n        int temp = nums[start];\\n        nums[start] = nums[end];\\n        nums[end] = temp;\\n        // Increment start index and decrement end index\\n        start++;\\n        end--;\\n    }\\n}\\n\\n    public void rotate(int[] nums, int k) {\\n        // Ensure k is within array bounds\\n        k %= nums.length;\\n        // Reverse entire array\\n        reverse(nums, 0, nums.length - 1);\\n        // Reverse first k elements\\n        reverse(nums, 0, k - 1);\\n        // Reverse remaining elements\\n        reverse(nums, k, nums.length - 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static void reverse(int nums[], int start, int end){\\n    // While start index is less than end index\\n    while(start < end){\\n        // Swap elements at start and end indices\\n        int temp = nums[start];\\n        nums[start] = nums[end];\\n        nums[end] = temp;\\n        // Increment start index and decrement end index\\n        start++;\\n        end--;\\n    }\\n}\\n\\n    public void rotate(int[] nums, int k) {\\n        // Ensure k is within array bounds\\n        k %= nums.length;\\n        // Reverse entire array\\n        reverse(nums, 0, nums.length - 1);\\n        // Reverse first k elements\\n        reverse(nums, 0, k - 1);\\n        // Reverse remaining elements\\n        reverse(nums, k, nums.length - 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730030,
                "title": "c-brute-force-o-n-o-1-solutions-optimized-w-explanation",
                "content": "**APPROACH 1 : Brute Force**\\n\\n* If ```k>=n``` do ```k = k%n```\\n* Create a ```temp``` array of size ```k```.\\n* Store the last ```k``` elements in a temp array.\\n* Shift the rest of the elements each by 1 position to the right.\\n* Store the last ```k``` elements in the first ```k``` indices.\\n\\n**Time Complexity :** O(n)\\n\\n**Space Complexity :** O(k)\\n\\n**APPROACH 2 : Rotate k times**\\n\\n* Rotate all the elements by 1 position ```k``` times.\\n\\n**Time Complexity :** O()\\n\\n**Space Complexity :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n\\tvoid rotateByOne(vector<int> &nums){\\n\\t\\tint n = nums.size(), temp = nums[n-1];\\n\\t\\tfor(int i=n-1; i>0; i--){\\n\\t\\t\\tnums[i] = nums[i-1];\\n\\t\\t\\tnums[0] = temp;\\n\\t\\t}\\n\\t}\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0; i<k; i++) rotateByOne(nums);\\n    }\\n};\\n```\\n\\n**APPROACH 3 : Reversal of array**\\n\\n* Reverse the whole array.\\n* Then reverse the first k elements.\\n* Finally reverse the remaining elements.\\n(Do a dry run, it\\'s very easy to understand)\\n\\n**Time Complexity :** O(n)\\n\\n**Space Complexity :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k%nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n    }\\n};\\n```\\n\\n**Do upvote if you like my solutions & explanation :)**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```k>=n```\n```k = k%n```\n```temp```\n```k```\n```k```\n```k```\n```k```\n```k```\n```\\nclass Solution {\\npublic:\\n\\tvoid rotateByOne(vector<int> &nums){\\n\\t\\tint n = nums.size(), temp = nums[n-1];\\n\\t\\tfor(int i=n-1; i>0; i--){\\n\\t\\t\\tnums[i] = nums[i-1];\\n\\t\\t\\tnums[0] = temp;\\n\\t\\t}\\n\\t}\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0; i<k; i++) rotateByOne(nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k%nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54249,
                "title": "3-line-using-reverse",
                "content": "    void rotate(int nums[], int n, int k) {\\n        reverse(nums,nums+n);\\n        reverse(nums,nums+k%n);\\n        reverse(nums+k%n,nums+n);\\n    }",
                "solutionTags": [],
                "code": "    void rotate(int nums[], int n, int k) {\\n        reverse(nums,nums+n);\\n        reverse(nums,nums+k%n);\\n        reverse(nums+k%n,nums+n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54426,
                "title": "summary-of-solutions-in-python",
                "content": "## **Classical 3-step array rotation:**\\n> \\n> 1. reverse the first n - k elements\\n> \\n> 2. reverse the rest of them\\n> \\n> 3. reverse the entire array\\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            if k is None or k <= 0:\\n                return\\n            k, end = k % len(nums), len(nums) - 1\\n            self.reverse(nums, 0, end - k)\\n            self.reverse(nums, end - k + 1, end)\\n            self.reverse(nums, 0, end)\\n            \\n        def reverse(self, nums, start, end):\\n            while start < end:\\n                nums[start], nums[end] = nums[end], nums[start]\\n                start, end = start + 1, end - 1\\n\\n**O(n) in time, O(1) in space**\\n\\n\\n## **Rotate `k` times**:\\n\\nEach rotation, we move the `n - 1` to the back of the array one by one and we do rotation `k` times.\\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            k = k % len(nums)\\n            for i in xrange(0, k):\\n                tmp = nums[-1]\\n                for j in xrange(0, len(nums) - 1):\\n                    nums[len(nums) - 1 - j] = nums[len(nums) - 2 - j]\\n                nums[0] = tmp\\n\\n**O(n^2) in  time, O(1) in space**\\n\\n**It can't pass the OJ due to TLE.**\\n\\n## **Recursive solution** \\n\\nput the shorter part in the correct position then do the rest of them iteratively. This is not necessarily to be a recursive solution. \\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            self.helper(0, len(nums) - 1 - (k % len(nums)), len(nums) - 1, nums) # mid belongs to left part\\n    \\n        def helper(self, start, mid, end, nums):\\n            left, right = mid - start, end - mid - 1\\n            if left < 0 or right < 0:\\n                return\\n            if left > right:\\n                for j in xrange(mid + 1, end + 1):\\n                    nums[j], nums[start] = nums[start], nums[j]\\n                    start += 1\\n                self.helper(start, mid, end, nums)\\n            elif right >= left:\\n                i = mid\\n                while i >= start:\\n                    nums[i], nums[end] = nums[end], nums[i]\\n                    i, end = i - 1, end - 1\\n                if left != right:\\n                    self.helper(start, mid, end, nums)\\n\\n**O(n) in time, O(n) in space**\\n\\n## **Iterative and improved solution:** \\n\\nput the last `k` elements in correct position (ahead) and do the remaining `n - k`. Once finish swap, the `n` and k decrease.\\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type k: int\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            n, k, j = len(nums), k % len(nums), 0\\n            while n > 0 and k % n != 0:\\n                for i in xrange(0, k):\\n                    nums[j + i], nums[len(nums) - k + i] = nums[len(nums) - k + i], nums[j + i] # swap\\n                n, j = n - k, j + k\\n                k = k % n\\n\\n**O(n) in time, O(1) in space**",
                "solutionTags": [],
                "code": "## **Classical 3-step array rotation:**\\n> \\n> 1. reverse the first n - k elements\\n> \\n> 2. reverse the rest of them\\n> \\n> 3. reverse the entire array\\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            if k is None or k <= 0:\\n                return\\n            k, end = k % len(nums), len(nums) - 1\\n            self.reverse(nums, 0, end - k)\\n            self.reverse(nums, end - k + 1, end)\\n            self.reverse(nums, 0, end)\\n            \\n        def reverse(self, nums, start, end):\\n            while start < end:\\n                nums[start], nums[end] = nums[end], nums[start]\\n                start, end = start + 1, end - 1\\n\\n**O(n) in time, O(1) in space**\\n\\n\\n## **Rotate `k` times**:\\n\\nEach rotation, we move the `n - 1` to the back of the array one by one and we do rotation `k` times.\\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            k = k % len(nums)\\n            for i in xrange(0, k):\\n                tmp = nums[-1]\\n                for j in xrange(0, len(nums) - 1):\\n                    nums[len(nums) - 1 - j] = nums[len(nums) - 2 - j]\\n                nums[0] = tmp\\n\\n**O(n^2) in  time, O(1) in space**\\n\\n**It can't pass the OJ due to TLE.**\\n\\n## **Recursive solution** \\n\\nput the shorter part in the correct position then do the rest of them iteratively. This is not necessarily to be a recursive solution. \\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            self.helper(0, len(nums) - 1 - (k % len(nums)), len(nums) - 1, nums) # mid belongs to left part\\n    \\n        def helper(self, start, mid, end, nums):\\n            left, right = mid - start, end - mid - 1\\n            if left < 0 or right < 0:\\n                return\\n            if left > right:\\n                for j in xrange(mid + 1, end + 1):\\n                    nums[j], nums[start] = nums[start], nums[j]\\n                    start += 1\\n                self.helper(start, mid, end, nums)\\n            elif right >= left:\\n                i = mid\\n                while i >= start:\\n                    nums[i], nums[end] = nums[end], nums[i]\\n                    i, end = i - 1, end - 1\\n                if left != right:\\n                    self.helper(start, mid, end, nums)\\n\\n**O(n) in time, O(n) in space**\\n\\n## **Iterative and improved solution:** \\n\\nput the last `k` elements in correct position (ahead) and do the remaining `n - k`. Once finish swap, the `n` and k decrease.\\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type k: int\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            n, k, j = len(nums), k % len(nums), 0\\n            while n > 0 and k % n != 0:\\n                for i in xrange(0, k):\\n                    nums[j + i], nums[len(nums) - k + i] = nums[len(nums) - k + i], nums[j + i] # swap\\n                n, j = n - k, j + k\\n                k = k % n\\n\\n**O(n) in time, O(1) in space**",
                "codeTag": "Java"
            },
            {
                "id": 54289,
                "title": "my-three-way-to-solve-this-problem-the-first-way-is-interesting-java",
                "content": "Method 1: ( Interesting way, O(n) time cost, O(1) space cost)\\n\\n    public class Solution {\\n        public void rotate(int[] nums, int k) {\\n            if(nums.length <= 1){\\n                return;\\n            }\\n            //step each time to move\\n            int step = k % nums.length;\\n            //find GCD between nums length and step\\n            int gcd = findGcd(nums.length, step);\\n            int position, count;\\n            \\n            //gcd path to finish movie\\n            for(int i = 0; i < gcd; i++){\\n                //beginning position of each path\\n                position = i;\\n                //count is the number we need swap each path\\n                count = nums.length / gcd - 1;\\n                for(int j = 0; j < count; j++){\\n                    position = (position + step) % nums.length;\\n                    //swap index value in index i and position\\n                    nums[i] ^= nums[position];\\n                    nums[position] ^= nums[i];\\n                    nums[i] ^= nums[position];\\n                }\\n            }\\n        }\\n        \\n        public int findGcd(int a, int b){\\n            return (a == 0 || b == 0) ? a + b : findGcd(b, a % b);\\n        }\\n        \\n    }\\n\\nMethod 2:( 3 reverse thinking, O(n) time cost, O(1) space cost)\\n\\n    public class Solution {\\n        public void rotate(int[] nums, int k) {\\n            if(nums.length <= 1){\\n                return;\\n            }\\n            //step each time to move\\n            int step = k % nums.length;\\n            reverse(nums,0,nums.length - 1);\\n            reverse(nums,0,step - 1);\\n            reverse(nums,step,nums.length - 1);\\n        }\\n        \\n        //reverse int array from n to m\\n        public void reverse(int[] nums, int n, int m){\\n            while(n < m){\\n                nums[n] ^= nums[m];\\n                nums[m] ^= nums[n];\\n                nums[n] ^= nums[m];\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n\\nMethod 3:( Normal way, O(n) time cost, O(k % nums.length) space cost)\\n\\n    public class Solution {\\n        public void rotate(int[] nums, int k) {\\n            if(nums.length <= 1){\\n                return;\\n            }\\n            //step each time to move\\n            int step = k % nums.length;\\n            int[] tmp = new int[step];\\n            for(int i = 0; i < step; i++){\\n                tmp[i] = nums[nums.length - step + i];\\n            }\\n            for(int i = nums.length - step - 1; i >= 0; i--){\\n                nums[i + step] = nums[i];\\n            }\\n            for(int i = 0; i < step; i++){\\n                nums[i] = tmp[i];\\n            }\\n            \\n        }\\n        \\n    }\\n\\t\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void rotate(int[] nums, int k) {\\n            if(nums.length <= 1){\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2747423,
                "title": "complete-python-explanation-5-methods",
                "content": "Let\\'s start with one of the simplest ways of solving this problem \\u2013\\u2013 rotating ```nums``` by 1 step, a total of ```k``` times. From this solution, we can work towards better methods of solving the problem.\\n\\n**Method 1: Rotate 1 Step at a Time; Time: O(n\\u2022k), Space: O(1) --> TLE**\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums) # store length of nums\\n\\tfor _ in range(k):\\n\\t\\tprev = nums[-1] # previous element starts as the end\\n\\t\\tfor i in range(n):\\n\\t\\t\\tnums[i], prev = prev, nums[i] # this element becomes the previous one, store this element in prev\\n```\\nIn this solution, the inner part of our outer ```for``` loop rotates ```nums``` by one spot. We perform this operation ```k``` times to rotate by a total of ```k``` steps!\\n\\nThis solution takes ```O(n\\u2022k)``` time where ```n == Ien(nums)``` since we need to look at every number in ```nums``` once to rotate by one step, and we do this ```k``` times. Unfortunately, this results in a time limit exception :( so instead of rotating one step at a time, let\\'s try to rotate ```k``` steps at a time using a second array for extra storage!\\n\\nTo come up with this solution, we need to think more about how rotation actually works. First, let\\'s think about what happens if ```nums``` has length ```5``` and we rotate ```5``` times. By the time we\\'ve made our fifth rotation, ```nums``` will be back in its original orientation! Similarly, if we rotate ```6``` times, then the first ```5``` rotations won\\'t do anything so it\\'s the same as rotating just once! Essentially, rotating ```k``` times is the same as rotating ```k % n``` times! \\n\\nSecondly, if we are rotating ```3``` times, then the last three elements in ```nums``` are going to end up going to the beginning of the array! This means that we need to be careful that we don\\'t accidentally try to insert any elements into indices beyond the end of ```nums```.\\n\\nWith this knowledge we can realize that an element at index ```i``` will need to be at index ```(i + k) % n``` after our rotation! So we can use our second array to simply set every element in ```nums``` to be their new value.\\n\\n**Method 2: Copy Array; Time: O(n), Space; O(n)**\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tcopy = [num for num in nums] # copy the nums array\\n\\tn = len(nums)\\n\\tfor i, num in enumerate(copy): # for every element in the copy\\n\\t\\tnums[(i + k) % n] = copy[i] # set corresponding location in nums\\n```\\n(P.S. ```for i, num in enumerate(copy)``` is the same as using ```for i in range(n)``` and then saying ```num = copy[i]```)\\n\\nSince we made a copy of our original array, the space complexity is ```O(n)```. The time this solution takes scales directly with the number of elements, so it is ```O(n)```. This is a great solution and gets accepted, but we can still improve! \\n\\nEarlier we went over what happens if we rotate ```3``` times in an array of length ```5``` \\u2013 the last ```3``` elements get rotated to the front. This means that ```nums``` will become ```[last three elements] + [first two elements]```. In python syntax, this is ```nums[-3:] + nums[-3:]``` (the negative index is the same as using ```n-3```). Therefore, we want ```nums = nums[-k:] + nums[:-k]```! However, there are two important things to note. \\n\\nFirst, we need to remember that ```k``` can be bigger than ```n```! To avoid trying to index the ```-10```th element of an array of length ```5``` (in a hypothetical case where ```n = 5``` and ```k = 10```), we can use our mod operator from before \\u2013\\u2013 we really want ```nums = nums[-k%n:] + nums[:-k%n]```. To fix this we can just add ```k %= n``` at the beginning of our answer (this is the same as ```k = k % n```).\\n\\nSecond, if we set ```nums = nums[-k:] + nums[:-k]```, then we will actually be creating a new pointer for ```nums``` in memory. Since we want to actually set ```nums``` to this result, we need to set ```nums[:] = nums[-k:] + nums[:-k]```, which will overwrite ```nums``` element by element.\\n\\n**Method 3: Pythonic; Time: O(n), Space: O(n)**\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums) # store length\\n\\tk %= n # avoid unnecessary rotations\\n\\tnums[:] = nums[-k:] + nums[:-k] # set nums to answer\\n```\\nThis can also be turned into a one-liner:\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tnums[:] = nums[-k%len(nums):] + nums[:-k%len(nums)]\\n```\\nThis solution also takes ```O(n)``` time and space since we still look at every element once and we also need extra space temporarily for ```nums[-k:]``` and ```nums[:-k]```. This is a very pythonic solution, but since we know the order that the elements in ```nums``` will end up, we can optimize our space storage from ```O(n)``` to ```O(k)``` by just storing the last ```k``` elements of ```nums``` and shifting the first ```n-k``` manually.\\n\\n**Method 4: Store last k elements; Time: O(n), Space: O(k)**\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums)\\n\\tk %= n\\n\\tif k != 0: # we only want to rotate the array if we need to\\n\\t\\tend = nums[-k:] # store the end of the array (which will become the front)\\n\\t\\tfor i in range(n-k-1, -1, -1): # go backwards through the first n-k elements of the array\\n\\t\\t\\tnums[i+k] = nums[i] # shift everything forward k spots\\n\\t\\tnums[:k] = end # put the old end to the front\\n```\\nThe key to this solution is that we have to iterate backwards through ```nums``` with our ```for i in range(n-k-1, -1, -1)``` loop since otherwise, we may overwrite future values that we need!\\n\\nThis solution still takes ```O(n)``` time but now takes just ```O(k)``` space! We can actually optimize this depending on whether or not the end or beginning of our array is smaller:\\n\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums)\\n\\tk %= n\\n\\tif k != 0: # we only want to rotate the array if we need to\\n\\t\\tif k < n//2: # if the end is less than half the size of the array\\n\\t\\t\\tend = nums[-k:] # store the end of the array (which will become the front)\\n\\t\\t\\tfor i in range(n-k-1, -1, -1): # go backwards through the first n-k elements of the array\\n\\t\\t\\t\\tnums[i+k] = nums[i] # shift everything forward k spots\\n\\t\\t\\tnums[:k] = end # put the old end to the front\\n\\t\\telse: # the end is bigger than the beginning so store the beginning\\n\\t\\t\\tbeg = nums[:-k] # store the beginning!\\n\\t\\t\\tfor i in range(n-k, n): # go forwards through the last k elements\\n\\t\\t\\t\\tnums[(i+k)%n] = nums[i] # shift them forwards k spots (to the front of the list)\\n\\t\\t\\tnums[k:] = beg # set the end to the beginning\\n```\\nThis makes the space complexity ```O(min(k, n-k))```.\\n\\nThis is a great solution but crazily there is one way to reduce the space complexity further! To do this, we need a special insight about how to rotate the array. We want the last ```k``` elements to become the first ```k``` elements of our array, so how about we begin by reversing the whole list. After that, the first ```k``` elements will be last ```k``` elements of our original list, but they will be in reverse order. Similarly, the new end of our list will be the old beginning, only in reverse order. So how do we remedy this? Well, we can reverse the first ```k``` elements of our new array and the last ```n-k``` elements! After that, the array will be fully rotated!\\n\\n**Method 5: Reverse; Time: O(n), Space: O(1)**\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tdef reverse(start, end): # helper method to reverse from start to end\\n\\t\\twhile start < end: # while there is stuff to reverse\\n\\t\\t\\tnums[start], nums[end] = nums[end], nums[start] # swap the elements at the ends\\n\\t\\t\\tstart, end = start + 1, end - 1 # move pointers closer to each other\\n\\t\\t\\t\\n\\tn = len(nums)\\n\\tk %= n\\n\\treverse(0,n-1) # reverse full list\\n\\treverse(0,k-1) # reverse first k elements (previously the last k elements)\\n\\treverse(k,n-1) # reverse the rest of the list\\n```\\n\\nIf you are still confused about how this works, I\\'ll show what ```nums``` looks like after each step with the example problems:\\n\\n***Example 1***\\n```\\noriginal nums: [1, 2, 3, 4, 5, 6, 7]\\nnums after fully reversing: [7, 6, 5, 4, 3, 2, 1]\\nnums after reversing the first k elements: [5, 6, 7, 4, 3, 2, 1]\\nnums after reversing the remaining elements: [5, 6, 7, 1, 2, 3, 4]\\n```\\n\\n***Example 2***\\n```\\noriginal nums: [-1, -100, 3, 99]\\nnums after fully reversing: [99, 3, -100, -1]\\nnums after reversing the first k elements: [3, 99, -100, -1]\\nnums after reversing the remaining elements: [3, 99, -1, -100]\\n```\\n\\n**Thanks for Reading!**\\nPlease consider upvoting the post if it helped you! If you have any questions, comments, or concerns, please leave them below and I will get to them as soon as possible.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```nums```\n```k```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums) # store length of nums\\n\\tfor _ in range(k):\\n\\t\\tprev = nums[-1] # previous element starts as the end\\n\\t\\tfor i in range(n):\\n\\t\\t\\tnums[i], prev = prev, nums[i] # this element becomes the previous one, store this element in prev\\n```\n```for```\n```nums```\n```k```\n```k```\n```O(n\\u2022k)```\n```n == Ien(nums)```\n```nums```\n```k```\n```k```\n```nums```\n```5```\n```5```\n```nums```\n```6```\n```5```\n```k```\n```k % n```\n```3```\n```nums```\n```nums```\n```i```\n```(i + k) % n```\n```nums```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tcopy = [num for num in nums] # copy the nums array\\n\\tn = len(nums)\\n\\tfor i, num in enumerate(copy): # for every element in the copy\\n\\t\\tnums[(i + k) % n] = copy[i] # set corresponding location in nums\\n```\n```for i, num in enumerate(copy)```\n```for i in range(n)```\n```num = copy[i]```\n```O(n)```\n```O(n)```\n```3```\n```5```\n```3```\n```nums```\n```[last three elements] + [first two elements]```\n```nums[-3:] + nums[-3:]```\n```n-3```\n```nums = nums[-k:] + nums[:-k]```\n```k```\n```n```\n```-10```\n```5```\n```n = 5```\n```k = 10```\n```nums = nums[-k%n:] + nums[:-k%n]```\n```k %= n```\n```k = k % n```\n```nums = nums[-k:] + nums[:-k]```\n```nums```\n```nums```\n```nums[:] = nums[-k:] + nums[:-k]```\n```nums```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums) # store length\\n\\tk %= n # avoid unnecessary rotations\\n\\tnums[:] = nums[-k:] + nums[:-k] # set nums to answer\\n```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tnums[:] = nums[-k%len(nums):] + nums[:-k%len(nums)]\\n```\n```O(n)```\n```nums[-k:]```\n```nums[:-k]```\n```nums```\n```O(n)```\n```O(k)```\n```k```\n```nums```\n```n-k```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums)\\n\\tk %= n\\n\\tif k != 0: # we only want to rotate the array if we need to\\n\\t\\tend = nums[-k:] # store the end of the array (which will become the front)\\n\\t\\tfor i in range(n-k-1, -1, -1): # go backwards through the first n-k elements of the array\\n\\t\\t\\tnums[i+k] = nums[i] # shift everything forward k spots\\n\\t\\tnums[:k] = end # put the old end to the front\\n```\n```nums```\n```for i in range(n-k-1, -1, -1)```\n```O(n)```\n```O(k)```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums)\\n\\tk %= n\\n\\tif k != 0: # we only want to rotate the array if we need to\\n\\t\\tif k < n//2: # if the end is less than half the size of the array\\n\\t\\t\\tend = nums[-k:] # store the end of the array (which will become the front)\\n\\t\\t\\tfor i in range(n-k-1, -1, -1): # go backwards through the first n-k elements of the array\\n\\t\\t\\t\\tnums[i+k] = nums[i] # shift everything forward k spots\\n\\t\\t\\tnums[:k] = end # put the old end to the front\\n\\t\\telse: # the end is bigger than the beginning so store the beginning\\n\\t\\t\\tbeg = nums[:-k] # store the beginning!\\n\\t\\t\\tfor i in range(n-k, n): # go forwards through the last k elements\\n\\t\\t\\t\\tnums[(i+k)%n] = nums[i] # shift them forwards k spots (to the front of the list)\\n\\t\\t\\tnums[k:] = beg # set the end to the beginning\\n```\n```O(min(k, n-k))```\n```k```\n```k```\n```k```\n```k```\n```k```\n```n-k```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tdef reverse(start, end): # helper method to reverse from start to end\\n\\t\\twhile start < end: # while there is stuff to reverse\\n\\t\\t\\tnums[start], nums[end] = nums[end], nums[start] # swap the elements at the ends\\n\\t\\t\\tstart, end = start + 1, end - 1 # move pointers closer to each other\\n\\t\\t\\t\\n\\tn = len(nums)\\n\\tk %= n\\n\\treverse(0,n-1) # reverse full list\\n\\treverse(0,k-1) # reverse first k elements (previously the last k elements)\\n\\treverse(k,n-1) # reverse the rest of the list\\n```\n```nums```\n```\\noriginal nums: [1, 2, 3, 4, 5, 6, 7]\\nnums after fully reversing: [7, 6, 5, 4, 3, 2, 1]\\nnums after reversing the first k elements: [5, 6, 7, 4, 3, 2, 1]\\nnums after reversing the remaining elements: [5, 6, 7, 1, 2, 3, 4]\\n```\n```\\noriginal nums: [-1, -100, 3, 99]\\nnums after fully reversing: [99, 3, -100, -1]\\nnums after reversing the first k elements: [3, 99, -100, -1]\\nnums after reversing the remaining elements: [3, 99, -1, -100]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 558971,
                "title": "faster-than-99-56-javascript",
                "content": "```\\nvar rotate = function(nums, k) {\\n   k %= nums.length // if k is greater than nums.length then one cycle is completed that means it will remain the same and we have to remainder shifts\\n    \\n   let reverse = function(i, j){\\n    while(i < j){\\n        let temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        i++\\n        j--\\n    }\\n   } // suppose  ----->---> \\n\\treverse(0, nums.length-1); // reverse   <--<------\\n\\t reverse(0, k-1) // reverse first part ---><----\\n   reverse(k, nums.length-1)// reverse second part --->----->\\n    \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function(nums, k) {\\n   k %= nums.length // if k is greater than nums.length then one cycle is completed that means it will remain the same and we have to remainder shifts\\n    \\n   let reverse = function(i, j){\\n    while(i < j){\\n        let temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        i++\\n        j--\\n    }\\n   } // suppose  ----->---> \\n\\treverse(0, nums.length-1); // reverse   <--<------\\n\\t reverse(0, k-1) // reverse first part ---><----\\n   reverse(k, nums.length-1)// reverse second part --->----->\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 54263,
                "title": "3-lines-of-c-in-one-pass-using-swap",
                "content": "Every swap will put one number into its correct position, so the running time is O(n)\\n\\nFor example,\\n\\nat first, `nums[]` is `[1,2,3,4,5,6,7]`, n is 7, k is 3\\n\\nafter first outer loop, `nums[]` is `[4,1,2,3]`, n is 4, k is 3\\n\\nafter second outer loop, `nums[]` is `[4]`, n is 1, k is 0\\n\\nloop ends.\\n\\n    void rotate(int nums[], int n, int k) {\\n        for (; k %= n; n -= k)\\n            for (int i = 0; i < k; i++)\\n                swap(*nums++, nums[n - k]);\\n    }",
                "solutionTags": [],
                "code": "Every swap will put one number into its correct position, so the running time is O(n)\\n\\nFor example,\\n\\nat first, `nums[]` is `[1,2,3,4,5,6,7]`, n is 7, k is 3\\n\\nafter first outer loop, `nums[]` is `[4,1,2,3]`, n is 4, k is 3\\n\\nafter second outer loop, `nums[]` is `[4]`, n is 1, k is 0\\n\\nloop ends.\\n\\n    void rotate(int nums[], int n, int k) {\\n        for (; k %= n; n -= k)\\n            for (int i = 0; i < k; i++)\\n                swap(*nums++, nums[n - k]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1729973,
                "title": "python3-in-place-exaplained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe idea is to reverse the given list, and then reverse elements in the range `0..k` and in the range `k..L`. For example `nums = [1,2,3,4,5,6,7]`, `k = 3`:\\n\\n1. Reverse: `nums` = [**7,6,5,4,3,2,1**] \\n2. Reverse in the range `0..k`:  `nums` = [**5,6,7**,4,3,2,1]\\n3. Reverse in the range `k..L`:  `nums` = [5,6,7,**1,2,3,4**]\\n\\nNotice that `k` can be greater than `L` (length of the `nums`) because `k` is number of rotattion steps. If `k` is equal to `L`, elements do full rotation and `nums` is not changed. So for this case we can recalculate `k` as `k%L`.\\n\\nTime: **O(n)** - for reverse and swaps\\nSpace: **O(1)** - in-place\\n\\nRuntime: 220 ms, faster than **81.00%** of Python3 online submissions for Rotate Array.\\nMemory Usage: 25.4 MB, less than **96.40%** of Python3 online submissions for Rotate Array.\\n\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tL = len(nums)\\n\\tif L == k: return\\n\\n\\tk = k%L # the case when k > L\\n\\tnums.reverse()\\n\\n\\tfor i in range(k//2):\\n\\t\\tnums[i], nums[k-1-i] = nums[k-1-i], nums[i]\\n\\n\\tfor i in range(k, (L+k)//2):\\n\\t\\tnums[i], nums[L-1-i+k] = nums[L-1-i+k], nums[i]\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tL = len(nums)\\n\\tif L == k: return\\n\\n\\tk = k%L # the case when k > L\\n\\tnums.reverse()\\n\\n\\tfor i in range(k//2):\\n\\t\\tnums[i], nums[k-1-i] = nums[k-1-i], nums[i]\\n\\n\\tfor i in range(k, (L+k)//2):\\n\\t\\tnums[i], nums[L-1-i+k] = nums[L-1-i+k], nums[i]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3014158,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& v, int k) {\\n        int a =k%v.size();\\n        reverse(v.begin(),v.end());\\n        reverse(v.begin(),v.begin()+a);\\n        reverse(v.begin()+a,v.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& v, int k) {\\n        int a =k%v.size();\\n        reverse(v.begin(),v.end());\\n        reverse(v.begin(),v.begin()+a);\\n        reverse(v.begin()+a,v.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426703,
                "title": "easy-approach-c",
                "content": "# Approach\\nhere i is of loop which starts form (0,1,2...) k is the value how many times you want to rotate and n is the size of first vector ,and after that new indexes will be generated in our temp vector and we have to put values of nums vector at new indexes . . . \\nlike for first  arr[1,2,3,4,5,6,7]  and k=3     so ,\\ntemp[0 + 3 % 7]=nums[i]\\ntemp[3 % 7]=nums[i]\\ntemp[3] = nums[i]\\n[_ , _ , _ , 1 , _ ,_ , _ ]\\nfor next ,\\ntemp[1 + 3 % 7]=nums[i]\\ntemp[4 % 7]=nums[i]\\ntemp[4] = nums[i]\\n[_ , _ , _ , 1 , 2 ,_ , _ ]   and so on \\ni hope you understand ..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<n;i++){\\n            temp[(i+k)%n]=nums[i];\\n        }\\n        nums=temp;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/565d5fa5-1370-44d9-a6b6-0cf06d575aae_1681731352.2608747.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<n;i++){\\n            temp[(i+k)%n]=nums[i];\\n        }\\n        nums=temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187339,
                "title": "easy-es6-javascript-js-solution-without-unshift-splice",
                "content": "Scroll down if you want to have an explanation.\\n\\n```\\nvar rotate = function (nums, k) {\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    nums[i + k] = nums[i];\\n  }\\n\\n  for (let j = k - 1; j >= 0; j--) {\\n    nums[j] = nums.pop();\\n  }\\n\\n  // Time comlexity = O(a + b)\\n};\\n```\\n.\\n.\\n.\\n.\\n.\\n.\\nExplanation down below\\n\\n\\n```\\nvar rotate = function (nums, k) {\\n  // i.e. nums = [1, 2, 3, 4, 5, 6, 7],  k = 3\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    nums[i + k] = nums[i];\\n    // i = 6,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[6 + 3] = nums[6]\\n    // nums[9] = 7              nums = [1, 2, 3, 4, 5, 6, 7, , , 7]\\n\\n    // i = 5,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[5 + 3] = nums[5]\\n    // nums[8] = 6              nums = [1, 2, 3, 4, 5, 6, 7, , 6, 7]\\n\\n    // i = 4,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[4 + 3] = nums[4]\\n    // nums[7] = 5              nums = [1, 2, 3, 4, 5, 6, 7, 5, 6, 7]\\n\\n    // i = 3,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[3 + 3] = nums[3]\\n    // nums[6] = 4              nums = [1, 2, 3, 4, 5, 6, 4, 5, 6, 7]\\n\\n    // i = 2,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[2 + 3] = nums[2]\\n    // nums[5] = 3              nums = [1, 2, 3, 4, 5, 3, 4, 5, 6, 7]\\n\\n    // i = 1,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[1 + 3] = nums[1]\\n    // nums[4] = 2              nums = [1, 2, 3, 4, 2, 3, 4, 5, 6, 7]\\n\\n    // i = 0,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[0 + 3] = nums[0]\\n    // nums[3] = 1              nums = [1, 2, 3, 1, 2, 3, 4, 5, 6, 7]\\n  }\\n\\n  for (let j = k - 1; j >= 0; j--) {\\n    // nums = [1, 2, 3, 1, 2, 3, 4, 5, 6, 7]\\n    nums[j] = nums.pop();\\n\\n    // j = 2\\n    // nums[j] = nums.pop()\\n    // nums[2] = 7               nums = [1, 2, 7, 1, 2, 3, 4, 5, 6]\\n\\n    // j = 1\\n    // nums[j] = nums.pop()\\n    // nums[1] = 6               nums = [1, 6, 7, 1, 2, 3, 4, 5]\\n\\n    // j = 0\\n    // nums[j] = nums.pop()\\n    // nums[0] = 5               nums = [5, 6, 7, 1, 2, 3, 4]\\n  }\\n\\n  // nums = [5, 6, 7, 1, 2, 3, 4]\\n\\n  // Time comlexity = O(a + b)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function (nums, k) {\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    nums[i + k] = nums[i];\\n  }\\n\\n  for (let j = k - 1; j >= 0; j--) {\\n    nums[j] = nums.pop();\\n  }\\n\\n  // Time comlexity = O(a + b)\\n};\\n```\n```\\nvar rotate = function (nums, k) {\\n  // i.e. nums = [1, 2, 3, 4, 5, 6, 7],  k = 3\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    nums[i + k] = nums[i];\\n    // i = 6,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[6 + 3] = nums[6]\\n    // nums[9] = 7              nums = [1, 2, 3, 4, 5, 6, 7, , , 7]\\n\\n    // i = 5,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[5 + 3] = nums[5]\\n    // nums[8] = 6              nums = [1, 2, 3, 4, 5, 6, 7, , 6, 7]\\n\\n    // i = 4,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[4 + 3] = nums[4]\\n    // nums[7] = 5              nums = [1, 2, 3, 4, 5, 6, 7, 5, 6, 7]\\n\\n    // i = 3,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[3 + 3] = nums[3]\\n    // nums[6] = 4              nums = [1, 2, 3, 4, 5, 6, 4, 5, 6, 7]\\n\\n    // i = 2,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[2 + 3] = nums[2]\\n    // nums[5] = 3              nums = [1, 2, 3, 4, 5, 3, 4, 5, 6, 7]\\n\\n    // i = 1,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[1 + 3] = nums[1]\\n    // nums[4] = 2              nums = [1, 2, 3, 4, 2, 3, 4, 5, 6, 7]\\n\\n    // i = 0,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[0 + 3] = nums[0]\\n    // nums[3] = 1              nums = [1, 2, 3, 1, 2, 3, 4, 5, 6, 7]\\n  }\\n\\n  for (let j = k - 1; j >= 0; j--) {\\n    // nums = [1, 2, 3, 1, 2, 3, 4, 5, 6, 7]\\n    nums[j] = nums.pop();\\n\\n    // j = 2\\n    // nums[j] = nums.pop()\\n    // nums[2] = 7               nums = [1, 2, 7, 1, 2, 3, 4, 5, 6]\\n\\n    // j = 1\\n    // nums[j] = nums.pop()\\n    // nums[1] = 6               nums = [1, 6, 7, 1, 2, 3, 4, 5]\\n\\n    // j = 0\\n    // nums[j] = nums.pop()\\n    // nums[0] = 5               nums = [5, 6, 7, 1, 2, 3, 4]\\n  }\\n\\n  // nums = [5, 6, 7, 1, 2, 3, 4]\\n\\n  // Time comlexity = O(a + b)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419527,
                "title": "python-two-pointers-solution",
                "content": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        def twopt(arr, i, j):\\n            while (i < j):\\n                arr[i], arr[j] = arr[j], arr[i]\\n                i += 1\\n                j -= 1\\n            return arr\\n        \\n        if k > len(nums):\\n            k %= len(nums)\\n            \\n        if (k > 0):\\n            twopt(nums, 0, len(nums) - 1)  # rotate entire array\\n            twopt(nums, 0, k - 1)          # rotate array upto k elements\\n            twopt(nums, k, len(nums) - 1)  # rotate array from k to end of array",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        def twopt(arr, i, j):\\n            while (i < j):\\n                arr[i], arr[j] = arr[j], arr[i]\\n                i += 1\\n                j -= 1\\n            return arr\\n        \\n        if k > len(nums):\\n            k %= len(nums)\\n            \\n        if (k > 0):\\n            twopt(nums, 0, len(nums) - 1)  # rotate entire array\\n            twopt(nums, 0, k - 1)          # rotate array upto k elements\\n            twopt(nums, k, len(nums) - 1)  # rotate array from k to end of array",
                "codeTag": "Java"
            },
            {
                "id": 54282,
                "title": "my-interpretation-proof-of-the-cyclic-replacements-method-in-editorial-solution",
                "content": "**Caveat at 2018-06-01 16:23:20**: it was recently pointed out that my orriginal formulation is appealing yet not really sufficient for the proof of the method. I revised the post so that I provide a revised version of the proof. Yet, I want to retain the original version, which is not strictly correct. The three sections below corresponds to:\\n* The introduction\\n* The first attempt of proof which is not rigidly correct.\\n* The second attemp of proof which is more comprehensive.\\n---\\n## Introduction\\nI find the **Cyclic Replacements** method in the editorial solution quite clever and spent some time learning it. On the other hand, I am not quite satisfied with the explanation and proof provided there. Thus I am elaborating on my way of relating to this algorithm here.\\n\\nFirst, I am putting the code directly copied from the editorial solution here for reference:\\n```java\\npublic class Solution {\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        int count = 0;\\n        for (int start = 0; count < nums.length; start++) {\\n            int current = start;\\n            int prev = nums[start];\\n            do {\\n                int next = (current + k) % nums.length;\\n                int temp = nums[next];\\n                nums[next] = prev;\\n                prev = temp;\\n                current = next;\\n                count++;\\n            } while (start != current);\\n        }\\n    }\\n}\\n```\\nThe main idea is to put each entry(denoted by its index) to its correct position after `k` shifts. \\nFirst consider how you would do this in a naive way. (assuming `k = k % n` is already done).\\n```java\\nfor (int i = 0; i < nums.length; i++) {\\n    put nums[i] to position[(i + k) % n] //cyclic shift\\n}\\n```\\nBut this naive way has a problem, when you reach `i + k`, this entry is already gone: overriden by the iteration of `i`.\\nTo avoid this problem, we could buffer `nums[i + k]` before we shift `nums[i]`, but such a modification, albeit feasible for the problem, would fail the O(1) space requirement: you need O(n - k) space to buffer the entries.\\n\\nThis **Cyclic Replacements** solution, on the other hand, overcomes this problem: only one buffer variable `prev` is shared for all shifts of all `n` elements(although the code declares new `current, prev, etc.` in each iteration, JVM optimization can handle that, or you can always just make these variables global to the loop block anyway).\\n## Proof Attempt 1: intuitive but not really complete\\n**Lemma1**: This algorithm visits each entry/index of `nums` exactly once. During the visit, the algorithm shifts the entry to the correct position. \\n**Proof**: \\n### Case 1: `n % k != 0`\\n**Caveat**: the proof for this case is incorrect, or at least incomplete. If you are not curious how it is incorrect, you can skip this part. The key error I made is I only proved that **no duplicate index is visited during one inner-loop**, but I did not prove **only one inner-loop will be executed**.\\n\\nif `n % k != 0`, the outer loop will only execute one iteration(`start == 0`) before the algorithm finisheds.\\nIf `n % k != 0`, the inner do-while loop will only terminate when `count == n`. Consider what this inner loop does: for example, in the case of `[1,2,3,4,5,6,7]` and `k = 2`, it essentially does something like moving values (not indexes) in this way: `1 -> 3, 3 -> 5, 5 -> 7, 7 -> 2, 2 -> 4, 4 -> 6, 6 -> 1`, and then`start == current` and `count == n == 7`. We will then have to try to get to the second iteration of the outer loop, which fails due to `count == n`. Thus the outer loop only executes one iteration.\\nNow let\\'s abstract: when `n % k != 0`, we start from `[0]` and in this one iteration, we can shift all `n` elements (to its perspectively correct position). This is because each `current` in the do-while loop will all be distinct indices (other than the last one that reaches `start` and ends the loop). \\n\\n**Lemma2**: No duplicate indexes will be visited (other than `start`) in each inner-loop. \\n**Proof**: This is proven by contradiction. Now, for convenience, let\\'s consider the chain of *index* movements rather than the chain of *value* movements. For the instance of `n=7, k=3`, we have:\\n```\\n0 -> 3 -> 6 -> 2 -> 5 -> 1 -> 4 -> 0\\n```\\nThis is a chain of length 7 (in terms of number of distinct indexes in the chain).\\nWe start from `start`, then move `current` from there, till `current` reaches `start` again. What we want to prove is, during this process, `current` never duplicates itself before it reach the final `start`. Suppose for the sake of contradiction that it did, then we have a chain like:\\n```\\nstart -> ... -> a -> ... -> a -> ... -> start\\nA               B           C           D\\n```\\nWhere the index `a` is picked twice by the pointer `current`, also `a \\u2260 start` (otherwise the inner-loop would have terminated at the first `a`). No `a` or `start` is included in any of the three `...` segment WLOG.\\nA trivial way to prove this is that, by the above assumptions, the BC segment has no `start`, which means, you start from `a`, you will reach `a` before reaching a `start`. But looking at the CD segment, you will have another conclusion: starting from `a`, you will reach `start` before reaching `a`, where `a \\u2260 start`. This is a contradiction.\\n**End of proof for Lemma2**\\nThus concludes my attempt for this case. Note that this case\\'s proof is incomplete in that I proved that no duplicate indexes shall be reached in one inner-loop. But I did not prove that *only* one inner-loop will execute in this case: in fact, that is a false claim. As pointed out by @ibici.\\nI could add on more augments to this proof but @ibici \\'s advice made me rethink about my classification of the two cases here and I eventually see how it is not a good choice. In **attempt 2**, I will try to provide the proof in a better way.\\n\\n### Case 2: `n % k == 0`\\nFor each `start` value of the outer loop, it is obvious to see that the inner loop does `n / k` iterations, visiting one distinct indice in each iteration.\\nThat is, each `start` visits `n / k` distinct indices.\\nThen we increment `start`. How many values of `start` can we have (or what is the number iterations of the outer loop)? It has to be `k`, because in each outer loop, `count` get incremented `n / k` no matter what (even if there are duplicates across different outer loop iterations/`start` values, which we shall debunk later). So the domain of `start` is `0..k-1`. **marker here**\\n\\nWe are now sure that the entire algorithm will visit `n / k * k = n` indices, but are they guaranteed to be distinct?\\nYes, and this is proven by contradiction. Suppose there exists two indices `idx1` and `idx2`, each corresponding to `start == s1` and `start == s2` in the outer loop. Then we have:\\n```\\nidx1 = idx2\\n(s1 + a * k) % n = (s2 + b * k) % n\\n```\\nfor some `a` and `b`. We also know that `s1 != s2` (otherwise there is nothing to prove because **lemma 2** will guarantee no duplicate within a single inner-loop). \\nWe can deduce that\\n```\\n(s1 - s2) % n = (b - a) * k % n\\ns1 - s2 = (b - a) * k + t * n               //for some t\\n|s1 - s2| \\u2265 k\\n```\\nBecause \\n* if `t != 0`, then `|s1 - s2| \\u2265 n > k`; \\n* if `t == 0`, then `s1 - s2 = (b - a) * k`, and we know `s1 - s2 \\u2260 0`, so `b \\u2260 a`, thus we also have `|s1 - s2| \\u2265 k`.\\n\\nThis is a contradiction with the previous conclusion of `start`\\'s domain being `0..k-1`.\\n\\nThus the `n` indices visited in the algorithm will also be distinct.\\n**End of Proof for Lemma1**\\n\\nI think this **lemma 1** is enough for understanding the correctness of this algorithm. There is also a [nice solution](https://discuss.leetcode.com/topic/11349/my-three-way-to-solve-this-problem-the-first-way-is-interesting-java) here using a similar idea. I would learn that one as well if I were you.\\n\\nHere is a trace to help your understanding:\\n<img src=\"http://i66.tinypic.com/vhb37m.png\" width=\"350\">\\n\\n## Proof Attempt 2: complete and general\\nLet\\'s just see what\\'s happening with a concrete example where `n,k = 7,3`. Note that from now on all chains/movements are described in terms of indexes rather than values.\\n<img src=\"https://www.dropbox.com/s/qe5z20o4xn0d1x2/Screenshot%202018-06-01%2018.23.05.png?raw=1\" width=\"600\">\\n\\nAs the length of the chain grows, think carefully when would we actually stop? Yes, we would stop when we reached a length `L` such that `L` is a multiple of both `n` and `k`. To be more accurate, we stop when `L` is the LCM of `n` and `k`. \\nIf the chain started from somewhere like `1` rather than `0`, the end result is actually similar, `L` will always be an LCM and thus a multiple of `n`.\\n\\nIn the example above where `n,k=7,3`, we have\\n```\\nL = (7) * 3 = (3) * 7\\n```\\nThe parens are used to mark the `n` and `k` variables we care about.\\n\\nFrom the **lemma2** proved in **attempt 1**, we already know that within one chain, which corresponds to one inner-loop (in that the chain terminates when the first duplciate is reached, which is `start`), there is no other duplicate index than `start`. But how long can this chain be? Of course, it can\\'t exceed `n`: you only have `n` distinct indexes. In the example above, the first chain (corresponds to `start=0`) has length `chain_len=n=7`, which triggers `count=n` to terminate the outer-loop immediately.\\nAnother example: `n,k=10,4`:\\n```\\n0 -> 4 -> 8 -> 2 -> 6 -> 0\\n```\\nThis chain is only of length 5, and we have `n=10`, so in the end we need two separate chains, corresponding to two inner-loop executions, to traverse all `n` indexes. We have:\\n```\\nL   = (10) * 2 = ((2) * 5) * 2\\n    = (4) * 5  = ((2) * 2) * 5\\n```\\nNote how the GCD is also marked with parens.\\n\\nNow, compare the two cases, you should see how LCM and GCD plays a part in this algorithm. We first find the GCD of `n` and `k`. Then we can calculate `L`, which is the LCM, then we can divide it by `k`, then we have the length of this chain.\\nAt this moment, given the sole input of `n` and `k`, we can tell:\\n* how many disjoint chains we have?\\n    * why are they disjoint, as in why would there be no duplicates across chains? See the proof for **case 2** in **attempt 1**.\\n* how long each of the chain would be?\\n\\nThese information are not explicitly utilied in the code, but is helpful for understanding the correctness of the algorithm overall. The beauty of this cyclic replacement code as compared to [this solution](https://discuss.leetcode.com/topic/11349/my-three-way-to-solve-this-problem-the-first-way-is-interesting-java) where GCD calculations are done explicitly is that everything just, happens, and it\\'s correct.\\n\\nNow, look back at the code, you should see that the code is actually doing:\\n```\\nfor each CHAIN:\\n    for each INDEX in this CHAIN:\\n        move elements\\n```\\n**Lemma 3**: each index will be traversed exactly once during the entire outer-loop.\\n**Proof**:\\nFirst, each index will belong to exactly one of the disjoint chains. This derives naturally from how we proved the chains to be disjoint in the first place.\\nSecondly, from **lemma 1**, we know that each index will be touched no more than once within each inner-loop (chain).\\n\\nNow, what conclusion do we have by now: each index will be touched *no more than once* in the entire outer-loop.\\nThis is not enough, we want *exactly* touched once.\\n\\nThe outer loop will only terminate when `count=n` which means we visited all `n` indexes, which are guaranteed to be distinct from above discussion. Does this statement suffice? \\nWell, in the case of `n \\u2265 10`, what if we had three inner-loops each contributing 4, 4, 4 to `count`? In this case, `chain_len=4` and in the end we will have `count=12>n` to terminate the outer-loop.\\nThis case is not possible because the length of each chain is deterministically calculated as shown above: `chain_len = L / k`:\\n```\\nL   = (10) * 2 = ((2) * 5) * 2\\n    = (4) * 5  = ((2) * 2) * 5\\n```\\nThe `chain_len` is actually `n / GCD`, somebody else help me prove this please.\\nAssume this is right, then it is clear that `chain_len` can divide into `n`, and the case of `n,chain_len=10,4` is impossible. Ruling out that possibility, the outer-loop\\'s termination iff *exactly `n` distinct indexes visited* is enough to justify the lemma and the algorithm: `n` is a multiple of `chain_len`, we will have exactly `n=count` in the end. All distinct, so each index touched exactly once.\\n**End of proof for lemma3**.\\nThe termination of the algorithm also trivially follows from **lemma 3**.",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        int count = 0;\\n        for (int start = 0; count < nums.length; start++) {\\n            int current = start;\\n            int prev = nums[start];\\n            do {\\n                int next = (current + k) % nums.length;\\n                int temp = nums[next];\\n                nums[next] = prev;\\n                prev = temp;\\n                current = next;\\n                count++;\\n            } while (start != current);\\n        }\\n    }\\n}\\n```\n```java\\nfor (int i = 0; i < nums.length; i++) {\\n    put nums[i] to position[(i + k) % n] //cyclic shift\\n}\\n```\n```\\n0 -> 3 -> 6 -> 2 -> 5 -> 1 -> 4 -> 0\\n```\n```\\nstart -> ... -> a -> ... -> a -> ... -> start\\nA               B           C           D\\n```\n```\\nidx1 = idx2\\n(s1 + a * k) % n = (s2 + b * k) % n\\n```\n```\\n(s1 - s2) % n = (b - a) * k % n\\ns1 - s2 = (b - a) * k + t * n               //for some t\\n|s1 - s2| \\u2265 k\\n```\n```\\nL = (7) * 3 = (3) * 7\\n```\n```\\n0 -> 4 -> 8 -> 2 -> 6 -> 0\\n```\n```\\nL   = (10) * 2 = ((2) * 5) * 2\\n    = (4) * 5  = ((2) * 2) * 5\\n```\n```\\nfor each CHAIN:\\n    for each INDEX in this CHAIN:\\n        move elements\\n```\n```\\nL   = (10) * 2 = ((2) * 5) * 2\\n    = (4) * 5  = ((2) * 2) * 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730564,
                "title": "python-1-line-detailed-explanation-clean-and-easy-to-understand",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n\\n\\n\\n```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        nums[:] = nums[-(k % len(nums)):] + nums[:-(k % len(nums))]\\n```\\n![image](https://assets.leetcode.com/users/images/4cc8eab5-1c11-4042-a60b-3d824cae2113_1643522511.6529794.png)\\n\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        nums[:] = nums[-(k % len(nums)):] + nums[:-(k % len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080798,
                "title": "c-o-n-time-o-1-space-0-ms-faster-than-100-00-4-lines-amazing-cool-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin() + k);\\n        reverse(nums.begin() + k, nums.end());\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin() + k);\\n        reverse(nums.begin() + k, nums.end());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 54458,
                "title": "java-o-n-in-place-solution",
                "content": "    \\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        reverse(nums, 0, nums.length-1);  // reverse the whole array\\n        reverse(nums, 0, k-1);  // reverse the first part\\n        reverse(nums, k, nums.length-1);  // reverse the second part\\n    }\\n    \\n    public void reverse(int[] nums, int l, int r) {\\n        while (l < r) {\\n            int tmp = nums[l];\\n            nums[l++] = nums[r];\\n            nums[r--] = tmp;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    \\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        reverse(nums, 0, nums.length-1);  // reverse the whole array\\n        reverse(nums, 0, k-1);  // reverse the first part\\n        reverse(nums, k, nums.length-1);  // reverse the second part\\n    }\\n    \\n    public void reverse(int[] nums, int l, int r) {\\n        while (l < r) {\\n            int tmp = nums[l];\\n            nums[l++] = nums[r];\\n            nums[r--] = tmp;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4006719,
                "title": "simple-beats-100",
                "content": "\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        int n = nums.length;\\n        reverseNum(nums,0,n-1);\\n        reverseNum(nums,0,k-1);\\n        reverseNum(nums,k,n-1);\\n    }\\n    public void reverseNum(int[] nums, int start, int end) {\\n        while(start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n![1271c6fe-345b-4f3d-959e-d13e791111d7_1677726484.8832572.jpeg](https://assets.leetcode.com/users/images/b5d72c1f-750f-4f09-a85a-b14f1ac49274_1693936505.706019.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        int n = nums.length;\\n        reverseNum(nums,0,n-1);\\n        reverseNum(nums,0,k-1);\\n        reverseNum(nums,k,n-1);\\n    }\\n    public void reverseNum(int[] nums, int start, int end) {\\n        while(start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895412,
                "title": "python-o-n-inplace-solution-explained",
                "content": "Very nice and interesting problem if we are asked to do it in place in linear time. \\nImagine, that we have number `[1,2,3,4,5,6,7,8]` and we have `k = 3`, then what is expected from us is `[6,7,8,1,2,3,4,5]`. Let us note, that a lot of structure in our list kept the same. Let us reverse list and try to find some patterns:\\n`[6,7,8,1,2,3,4,5]`\\n`[8,7,6,5,4,3,2,1]`\\nYou see it? What we need to do know is reverse first `3` elements and to reverst last `5` elements and this is all! It seems very easy, but in fact if you never used similar trick, it is very difficult to think, why we need to inverse arrays in the first place.\\n\\n**Complexity**: time complexity is `O(n)`, because in whole we change elements `2n` times. Space complexity is `O(1)`, because we do it in place.\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        def inverse(i, j):\\n            while i < j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i, j = i + 1, j - 1\\n        \\n        n = len(nums)\\n        k = k % n\\n        inverse(0, n-1)\\n        inverse(0, k-1)\\n        inverse(k, n-1)\\n        return nums\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        def inverse(i, j):\\n            while i < j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i, j = i + 1, j - 1\\n        \\n        n = len(nums)\\n        k = k % n\\n        inverse(0, n-1)\\n        inverse(0, k-1)\\n        inverse(k, n-1)\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259418,
                "title": "clear-cyclic-replacement-java-solution-with-proof-o-n-in-time-o-1-in-space",
                "content": "# Clear cyclic replacement solution with proof\\n## Intuition\\nAssume `k = k % n`.\\n\\nImagine we have an array `A = [0, 1, 2, 3, 4, 5, 6]` (n = 7) and need to shift it right by `k = 3` by HAND.\\n\\nWhat I would do is start from index 0, **hold** `A[0]=0` in hand, go to next index `(0 + k) % n = (0 + 3) % 7 = 3`, and swap `A[3]` with what I hold in hand, repeat this step until all elements are moved. The indexes of elements traversed form a closed chain `0 -> 3 -> 6 -> 2 -> 5 -> 1 -> 4 -> 0`, which has 7 elements, equal to array length.\\n\\nHowever, if `n` and `k` are not mutually prime, we may return to start position before moving all elements, forming a closed chain with elements fewer than `n`, e.g. `n = 6, k = 4 => 0 -> 4 -> 2 -> 0`, this chain only has `L1 = 3` elements. To move all elements, we need to start from index 1 and traverse another chain `1 -> 5 -> 3 -> 1`, which contains `L2 = 3` different elements. In total we moved `L1 + L2 = 3 + 3 = 6 == n` elements, and each element moved only once. \\n\\nThe general procedures are:\\n1. start from index `start = 0` (actually can be any other index)\\n2. cyclically shift element at index `(start + m * k)` right by `k` until reaching start again, forming a closed chain\\n3. shift `start` by 1, repeat step 1 and 2 until all elements moved.\\n\\n## Solution\\n```\\nclass Solution {\\n    // Cyclic replacement\\n    public void rotate(int[] nums, int k) {\\n        if (nums == null || nums.length <= 1 || k <= 0) {\\n            return;\\n        }\\n        \\n        int n = nums.length;\\n        int step = k % n;\\n        int count = 0; // count of elements moved to target position\\n        for (int start = 0; start < n; start++) {\\n            // Cyclically move each element until returning to start position and forms \\n            // a closed chain\\n            int hold = nums[start];\\n            int p = start;\\n            do {\\n                p = (p + step) % n;\\n                // swap hold and nums[p]\\n                int tmp = hold;\\n                hold = nums[p];\\n                nums[p] = tmp;\\n                count++;\\n            } while (p != start);\\n            \\n            if (count == n) {\\n                break;\\n            }\\n        }   \\n    }\\n}\\n```\\n\\n## Proof\\n### Lemme 1: Each closed chain has same length `L = n / gcd(n, k)`\\n**Proof**:\\n`lcm`: least common multiple\\n`gcd`: greatest common divisor\\n\\nAccording to the chain definition, a chain with index `start -> (start + k) % n -> (start + 2k) % n -> ... -> (start + Lk) % n` closes when chain ends at start index, i.e. `(start + Lk) % n == start`, i.e. when `Lk == tn`, where `t` is a positive integer as small as possible. In other words:\\n\\n`Lk == lcm(n, k)` => `L = lcm(n, k) / k`\\n\\nAccording to the [relation between lcm and gcd: `gcd(a,b) * lcm(a, b) = a * b`](https://math.stackexchange.com/questions/470807/prove-that-gcdm-n-times-mboxlcmm-n-m-times-n), we have:\\n\\n`L = lcm(n, k) / k = (n * k / gcd(n, k)) / k = n / gcd(n, k)`\\n\\nFor example:\\n* `n = 7, k = 3` => `L = 7 / gcd(7, 3) = 7 / 1 = 7`\\n* `n = 6, k = 4` => `L = 6 / gcd(6, 4) = 6 / 2 = 3`\\n\\nLemme 1 indicates each inner loop ends after `L = n / gcd(n, k)` steps.\\n\\n### Lemme 2: For any index `0 <= i < j < gcd(n, k)`, chains starting from `i` and `j` are mutually exclusive.\\n**Intuitive Proof**:\\nThanks to @kafa321:\\nIf two chains intercept, after intersection point, since both chains advance by `k` every step, esentially they are the same chain.\\n\\n**Strict mathmatical proof by contradiction**\\nAssume two chains does intercept at index `p` after `x` steps from `i` and `y` steps from `j`, i.e.\\n`p = (i + x * k) % n == (j + y * k) % n`\\n=> `(j - i + (y - x) * k) % n == 0`\\n=> `(j - i) - (x - y) * k = tn`\\n=> `j - i = (x - y) * k + tn`\\n=> `j - i = (x - y) * gcd(n, k) * (k / gcd(n, k)) + t * gcd(n, k) * (n / gcd(n, k))`\\n=> `j - i = gcd(n, k) * ((x - y) * (k / gcd(n, k)) + t * (n / gcd(n, k)))`\\n=> `j - i = M * gcd(n, k), M is an integer`\\n\\nHowever, `0 < j - i < gcd(n, k)`, so there exists no valid `M`, assumption is invalid.\\n\\n### Conclusion\\nBased on Lemma 1 and 2, we have proven that the cyclic replacement algorithem has following properties:\\n* Each inner loop moves `L = n / gcd(n, k)` unique indexes (according to chain definition, no duplicate indexes other than start position is allowed in a closed chain).\\n* Outer loop iterates start position from `0` to `gcd(n, k) - 1`, execute inner loop `gcd(n, k)` times\\n* All indexes moved in those `gcd(n, k)` inner loops are mutually exclusive, in total `n / gcd(n,k) * gcd(n, k) = n` unique indexes have been moved. \\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Cyclic replacement\\n    public void rotate(int[] nums, int k) {\\n        if (nums == null || nums.length <= 1 || k <= 0) {\\n            return;\\n        }\\n        \\n        int n = nums.length;\\n        int step = k % n;\\n        int count = 0; // count of elements moved to target position\\n        for (int start = 0; start < n; start++) {\\n            // Cyclically move each element until returning to start position and forms \\n            // a closed chain\\n            int hold = nums[start];\\n            int p = start;\\n            do {\\n                p = (p + step) % n;\\n                // swap hold and nums[p]\\n                int tmp = hold;\\n                hold = nums[p];\\n                nums[p] = tmp;\\n                count++;\\n            } while (p != start);\\n            \\n            if (count == n) {\\n                break;\\n            }\\n        }   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54702,
                "title": "java-solution-in-one-pass-o-1-space-o-n-time",
                "content": "I got the idea from this C++ solution: [3 lines of C++ in one pass using swap][1]\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/26501/3-lines-of-c-in-one-pass-using-swap\\n\\n\\nBut since Java doesn't have all those nice trick of swap() and pointer operations, I modified it to store the processed section at the end, and then handle the rest at the beginning of the array.\\n\\nThe idea is: for a given K, I can put (n - k) elements to their final locations at the end of the array in a single pass; after that, the problem is reduced to a sub-problem of processing the remaining elements.\\n\\nFor example, [1,2,3,4,5,6,7] k = 3, in the first iteration in the while loop, put n-k=4 elements to the final places at the end. Will have to start from the last element, so that the other elements will be bubbled down correctly. It will look like this after the first iteration: [7, 5, 6, 1, 2, 3, 4]\\n\\nThe 2nd iteration will handle the remaining 3 elements: [7, 5, 6]; to determine the new k, we first observe that the # of out-of-order elements being put to the beginning of the array are (range % k), and in this example, only one element (7) is out of order. then to move the out-of-order elements back in order, we just need to rotate the remaining 3 elements to the right by k' = n - (range % k) = 2.\\n\\ntherefore, after 2nd iteration in while loop, we will get [6, 5, 7], then n <- 2, k <- 1;\\n\\nthe 3rd iteration starts with sub array [6,5], k =1, and we will get [5,6] after it,  and then n <- 1.\\n\\n\\n        if (nums.length == 0) return;\\n        int n = nums.length;\\n        while ((k %= n) > 0 && n > 1) {\\n            int range = n - k;\\n            for (int i = 1; i <= range; i++) {\\n                int val = nums[n - i];\\n                nums[n - i] = nums[n - i - k];\\n                nums[n - i - k] = val;\\n            }\\n            n = k;\\n            k = n - (range % k);\\n        }\\n\\nHope this helps.",
                "solutionTags": [
                    "Java"
                ],
                "code": "I got the idea from this C++ solution: [3 lines of C++ in one pass using swap][1]\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/26501/3-lines-of-c-in-one-pass-using-swap\\n\\n\\nBut since Java doesn't have all those nice trick of swap() and pointer operations, I modified it to store the processed section at the end, and then handle the rest at the beginning of the array.\\n\\nThe idea is: for a given K, I can put (n - k) elements to their final locations at the end of the array in a single pass; after that, the problem is reduced to a sub-problem of processing the remaining elements.\\n\\nFor example, [1,2,3,4,5,6,7] k = 3, in the first iteration in the while loop, put n-k=4 elements to the final places at the end. Will have to start from the last element, so that the other elements will be bubbled down correctly. It will look like this after the first iteration: [7, 5, 6, 1, 2, 3, 4]\\n\\nThe 2nd iteration will handle the remaining 3 elements: [7, 5, 6]; to determine the new k, we first observe that the # of out-of-order elements being put to the beginning of the array are (range % k), and in this example, only one element (7) is out of order. then to move the out-of-order elements back in order, we just need to rotate the remaining 3 elements to the right by k' = n - (range % k) = 2.\\n\\ntherefore, after 2nd iteration in while loop, we will get [6, 5, 7], then n <- 2, k <- 1;\\n\\nthe 3rd iteration starts with sub array [6,5], k =1, and we will get [5,6] after it,  and then n <- 1.\\n\\n\\n        if (nums.length == 0) return;\\n        int n = nums.length;\\n        while ((k %= n) > 0 && n > 1) {\\n            int range = n - k;\\n            for (int i = 1; i <= range; i++) {\\n                int val = nums[n - i];\\n                nums[n - i] = nums[n - i - k];\\n                nums[n - i - k] = val;\\n            }\\n            n = k;\\n            k = n - (range % k);\\n        }\\n\\nHope this helps.",
                "codeTag": "Unknown"
            },
            {
                "id": 723103,
                "title": "c-easy-to-understand-multiple-approaches",
                "content": "***Runtime: 16 ms, faster than 21.15% of C++ online submissions for Rotate Array.\\nMemory Usage: 10 MB, less than 54.57% of C++ online submissions for Rotate Array.***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %= nums.size();\\n        vector<int> result(nums.end()-k,nums.end());\\n        result.insert(result.end(),nums.begin(),nums.end()-k);\\n        nums = result;\\n    }\\n};\\n```\\n***Time Limit Exceeded***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %= nums.size();\\n        while(k--){\\n            int temp = nums[nums.size()-1];\\n            for(int i = nums.size()-2; i>= 0 ;i--){\\n                nums[i+1] = nums[i];\\n            }\\n            nums[0] = temp;\\n        }   \\n    }\\n};\\n```\\n***Runtime: 28 ms, faster than 11.54% of C++ online submissions for Rotate Array.\\nMemory Usage: 10 MB, less than 50.27% of C++ online submissions for Rotate Array.***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int orig_size = nums.size();\\n        k %= orig_size;\\n        nums.insert(nums.end(),nums.end()-k,nums.end());\\n        int i=orig_size - k - 1, j = orig_size - 1;\\n        while(j >= 0){\\n            nums[j--] = nums[i--];\\n            if(i == -1){\\n                i = nums.size()-1;\\n            }\\n        }\\n        nums.resize(orig_size, 0);\\n    }\\n};\\n```\\n***Runtime: 8 ms, faster than 83.90% of C++ online submissions for Rotate Array.\\nMemory Usage: 10.1 MB, less than 21.86% of C++ online submissions for Rotate Array.***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int sz = nums.size();\\n        vector<int> result(sz,0);\\n        for(int i=0;i<sz;i++){\\n            result[(i + k)%sz] = nums[i];\\n        }\\n        nums = result;\\n    }\\n};\\n```\\n***Runtime: 12 ms, faster than 37.86% of C++ online submissions for Rotate Array.\\nMemory Usage: 10 MB, less than 47.04% of C++ online submissions for Rotate Array.***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %= nums.size();\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```\\n***Runtime: 8 ms, faster than 84.24% of C++ online submissions for Rotate Array.\\nMemory Usage: 10.1 MB, less than 32.86% of C++ online submissions for Rotate Array.***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k %= n;\\n        for(int i=0;i<gcd(n,k);i++){\\n            int prev = i, next = (prev+k)%n;\\n            int temp = nums[i];\\n            while(next != i){\\n                int temp2 = nums[next];\\n                nums[next] = temp;\\n                temp = temp2;\\n                prev = next;\\n                next = (prev+k)%n;\\n            }\\n            nums[next] = temp;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %= nums.size();\\n        vector<int> result(nums.end()-k,nums.end());\\n        result.insert(result.end(),nums.begin(),nums.end()-k);\\n        nums = result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %= nums.size();\\n        while(k--){\\n            int temp = nums[nums.size()-1];\\n            for(int i = nums.size()-2; i>= 0 ;i--){\\n                nums[i+1] = nums[i];\\n            }\\n            nums[0] = temp;\\n        }   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int orig_size = nums.size();\\n        k %= orig_size;\\n        nums.insert(nums.end(),nums.end()-k,nums.end());\\n        int i=orig_size - k - 1, j = orig_size - 1;\\n        while(j >= 0){\\n            nums[j--] = nums[i--];\\n            if(i == -1){\\n                i = nums.size()-1;\\n            }\\n        }\\n        nums.resize(orig_size, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int sz = nums.size();\\n        vector<int> result(sz,0);\\n        for(int i=0;i<sz;i++){\\n            result[(i + k)%sz] = nums[i];\\n        }\\n        nums = result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %= nums.size();\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k %= n;\\n        for(int i=0;i<gcd(n,k);i++){\\n            int prev = i, next = (prev+k)%n;\\n            int temp = nums[i];\\n            while(next != i){\\n                int temp2 = nums[next];\\n                nums[next] = temp;\\n                temp = temp2;\\n                prev = next;\\n                next = (prev+k)%n;\\n            }\\n            nums[next] = temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194483,
                "title": "go-solution-time-o-n-space-o-1",
                "content": "```\\nfunc rotate(nums []int, k int) {\\n    n := len(nums)\\n    k %= n\\n    reverse(nums, 0, n - 1)\\n    reverse(nums, 0, k - 1)\\n    reverse(nums, k, n - 1)\\n}\\n\\nfunc reverse(nums []int, start int, end int) {\\n    for start < end {\\n        nums[start], nums[end] = nums[end], nums[start]\\n        start++\\n        end--\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rotate(nums []int, k int) {\\n    n := len(nums)\\n    k %= n\\n    reverse(nums, 0, n - 1)\\n    reverse(nums, 0, k - 1)\\n    reverse(nums, k, n - 1)\\n}\\n\\nfunc reverse(nums []int, start int, end int) {\\n    for start < end {\\n        nums[start], nums[end] = nums[end], nums[start]\\n        start++\\n        end--\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54438,
                "title": "my-c-solution-o-n-time-o-1-space",
                "content": "    class Solution {\\n    public:\\n        void rotate(int nums[], int n, int k) {\\n            int nowIndex = 0, nextIndex;\\n    \\t\\tint tmp1, tmp2 = nums[0];\\n    \\t\\tfor(int j=0,i=0; j<n; j++){\\n    \\t\\t\\ttmp1 = tmp2;\\n    \\t\\t\\tnowIndex = (k + nowIndex) % (n);\\n    \\t\\t\\ttmp2 = nums[nowIndex];\\n    \\t\\t\\tnums[nowIndex] = tmp1;\\n    \\t\\t\\tif(nowIndex == i) {\\n    \\t\\t\\t\\tnowIndex = ++i;\\n    \\t\\t\\t\\ttmp2 = nums[nowIndex];\\n    \\t\\t\\t}\\n    \\t\\t}\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void rotate(int nums[], int n, int k) {\\n            int nowIndex = 0, nextIndex;\\n    \\t\\tint tmp1, tmp2 = nums[0];\\n    \\t\\tfor(int j=0,i=0; j<n; j++){\\n    \\t\\t\\ttmp1 = tmp2;\\n    \\t\\t\\tnowIndex = (k + nowIndex) % (n);\\n    \\t\\t\\ttmp2 = nums[nowIndex];\\n    \\t\\t\\tnums[nowIndex] = tmp1;\\n    \\t\\t\\tif(nowIndex == i) {\\n    \\t\\t\\t\\tnowIndex = ++i;\\n    \\t\\t\\t\\ttmp2 = nums[nowIndex];\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3413782,
                "title": "js-ts-easy-explained-solution-two-pointers-o-n-o-1",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n Do not return anything, modify nums in-place instead.\\n */\\nfunction rotate(nums: number[], k: number): void {\\n  k = k % nums.length;\\n  let l = 0;\\n  let r = nums.length - 1;\\n  // reverse full given array\\n  // from [1,2,3,4,5,6,7] to [7,6,5,4,3,2,1]\\n  nums = reverseArr(nums, l, r);\\n\\n  // reverse part from 0 to k - 1;\\n  // from [7,6,5,4,3,2,1] to [5,6,7,4,3,2,1]\\n  l = 0;\\n  r = k - 1;\\n  nums = reverseArr(nums, l, r);\\n\\n  // reverse part from k to the end;\\n  // from [5,6,7,4,3,2,1] to [5,6,7,1,2,3,4]\\n  l = k;\\n  r = nums.length - 1;\\n  nums = reverseArr(nums, l, r);\\n};\\n\\nfunction reverseArr(nums: number[], l: number, r: number): number[] {\\n    while(l < r) {\\n    let temp = nums[l];\\n    nums[l] = nums[r];\\n    nums[r] = temp;\\n    l++;\\n    r--;\\n  }\\n\\n  return nums;\\n}\\n\\n```\\nPlease do not forget to upvote the solution in case it is helpfull for you \\uD83D\\uDD25",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n Do not return anything, modify nums in-place instead.\\n */\\nfunction rotate(nums: number[], k: number): void {\\n  k = k % nums.length;\\n  let l = 0;\\n  let r = nums.length - 1;\\n  // reverse full given array\\n  // from [1,2,3,4,5,6,7] to [7,6,5,4,3,2,1]\\n  nums = reverseArr(nums, l, r);\\n\\n  // reverse part from 0 to k - 1;\\n  // from [7,6,5,4,3,2,1] to [5,6,7,4,3,2,1]\\n  l = 0;\\n  r = k - 1;\\n  nums = reverseArr(nums, l, r);\\n\\n  // reverse part from k to the end;\\n  // from [5,6,7,4,3,2,1] to [5,6,7,1,2,3,4]\\n  l = k;\\n  r = nums.length - 1;\\n  nums = reverseArr(nums, l, r);\\n};\\n\\nfunction reverseArr(nums: number[], l: number, r: number): number[] {\\n    while(l < r) {\\n    let temp = nums[l];\\n    nums[l] = nums[r];\\n    nums[r] = temp;\\n    l++;\\n    r--;\\n  }\\n\\n  return nums;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3009665,
                "title": "java-detailed-explanation-very-easy-sol-with-step-by-step-guide-and-intuition",
                "content": "<p> <img align=\"right\" alt=\"Coding\" width=\"100\" src=\"https://assets.leetcode.com/users/images/14aea68c-f5c2-41d3-b2d2-3c8556d0d9bc_1673600276.9231472.gif\"/> </p\\n\\n![Screenshot_20230106_091731.png](https://assets.leetcode.com/users/images/19c36e8a-0203-4d3d-8ed7-694b54b5b5b7_1673020110.2665236.png)\\n\\nBefore i Start see how a bracket () can take your 2 hour.....\\uD83E\\uDEE3\\uD83D\\uDE4C\\n\\nBTW the song is of abdul hannan.....if you are curious...\\n\\n    Now let\\'s begin....\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is a famous idiom in hindi which describe this problem very acurately.....  \" UlTE KA ULTA = SIDHA \" for the non-hindi folks it goes somewhat like -> reverse of reverse is straight .\\n\\nsee we need to reverse the array but only k times and for that we can do one thing in bruteforce appraoch -\\n     we store the left part of the k i.e from k+1 to arr.length-1 in an array and from 0 to k in  other array and then just append those two array\\n  \\n    obviously the interviewer will not be \\uD83D\\uDE00 with it and will ask you\\n    to opimize it ... then you will show your skills \\uD83E\\uDEE1\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso for optimized approach we will perform 3 step ->\\n1. In first step - you will reverse the array from  0 to len-k\\n2. In second step - you will reverse the array from len-k+1 to len\\n3. And at last you will reverse the whole array.\\n   \\n# Boom you got the answer \\uD83C\\uDF93\\n\\n     well wait! there is a \\uD83E\\uDEB2 very dangerous \\n\\nwhat if we get k > then len then we will get abnormility here we will use our main weapon  -> % ( yup looks tiny but very usefull \\uD83E\\uDD26\\u200D\\u2642\\uFE0F )\\n\\nsee when we rotate len time a array we get the array back again and thus [ k%len ] give us the exact time we have to rotate after a full rotation and for k less then len we will get k back again .\\n\\n     fun fact -> the hindi idiom is self made ...just like you coder \\uD83D\\uDC96\\n\\nHope you under stood it.  For any correction pls let me know...\\n\\n    PLEASE UP-VOTE IF IT HELPED YOU \\uD83D\\uDE4C  \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Additionals\\n-  connect with me - https://linktr.ee/_soumya\\n# Code\\n```\\nclass Solution {\\n     public int[] rotate(int[] arr, int k) {\\n        int len = arr.length-1;\\n        k=k%(len+1);\\n        arr = rev(arr,0,len-k);\\n        arr=rev(arr,len-k+1,len);\\n        arr=rev(arr,0,len);\\n        return arr;\\n    }\\n\\n   public int[] rev(int[] arr,int low,int hi)\\n    {\\n        while(low<hi)\\n        {\\n           int temp=arr[low];\\n           arr[low]=arr[hi];\\n           arr[hi]=temp;\\n           hi--;\\n           low++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n     public int[] rotate(int[] arr, int k) {\\n        int len = arr.length-1;\\n        k=k%(len+1);\\n        arr = rev(arr,0,len-k);\\n        arr=rev(arr,len-k+1,len);\\n        arr=rev(arr,0,len);\\n        return arr;\\n    }\\n\\n   public int[] rev(int[] arr,int low,int hi)\\n    {\\n        while(low<hi)\\n        {\\n           int temp=arr[low];\\n           arr[low]=arr[hi];\\n           arr[hi]=temp;\\n           hi--;\\n           low++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54437,
                "title": "my-perfect-java-code-o-1-1ms-use-reverse",
                "content": "    public class Solution {\\n        public void reverse(int[] nums, int l, int r) {\\n    \\t\\twhile (l < r) {\\n    \\t\\t\\tint temp = nums[l];\\n    \\t\\t\\tnums[l++] = nums[--r];\\n    \\t\\t\\tnums[r] = temp;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\tpublic void rotate(int[] nums, int k) {\\n    \\t\\tint n = nums.length;\\n    \\t\\tk = (n == 0 ? 0 : k % n);\\n    \\t\\treverse(nums, 0    , n - k);\\n    \\t\\treverse(nums, n - k, n    );\\n    \\t\\treverse(nums, 0    , n    );\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void reverse(int[] nums, int l, int r) {\\n    \\t\\twhile (l < r) {\\n    \\t\\t\\tint temp = nums[l];\\n    \\t\\t\\tnums[l++] = nums[--r];\\n    \\t\\t\\tnums[r] = temp;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 895980,
                "title": "2-liner-python-solution-beats-99-8-time",
                "content": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        k=k%len(nums)\\n        nums[:]=nums[-k:]+nums[:-k]\\n```\\nHowever, its considered O(n) space since nums[:] is equivalent to creating a new array",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        k=k%len(nums)\\n        nums[:]=nums[-k:]+nums[:-k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487529,
                "title": "py3-js-5-different-simple-solutions",
                "content": "## Brute Force\\n- Repeat `pop` and `insert at front` k times.\\n- Time complexity: **O(NK)**\\n- Space complexity: **O(1)**\\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        while k:\\n            nums.insert(0, nums.pop())\\n            k -= 1\\n```\\n\\n- Time complexity: **O(NK)**\\n- Space complexity: **O(1)**\\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void}\\n */\\nconst rotate = (nums, k) => {\\n    while(k--) {\\n        nums.unshift(nums.pop());\\n    }\\n};\\n```\\n## `prepend` of Deque\\n- add element in front of deque takes constant time.  \\n- Time complexity: **O(K)**\\n- Space complexity: **O(N)**\\n```Python\\nfrom collections import deque\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        d = deque(nums)\\n        for _ in range(k):\\n            d.appendleft(d.pop())\\n        nums[:] = list(d)\\n```\\n\\n## Stack\\n- Time complexity: **O(N)**\\n- Space complexity: **O(N)**\\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void}\\n */\\nconst rotate = (nums, k) => {\\n    const stack = [];\\n    k %= nums.length;\\n    while(k--) {\\n        stack.push(nums.pop());\\n    }\\n    nums.unshift(...stack.reverse());\\n};\\n```\\n\\n## Reduce `k`: Using Cyclic Replacements\\n_1. Remove redundant loop:_\\n  If `k` is bigger than length of `nums`. Bruteforce algorithm gonna looping `nums` over and over.\\n  To prevent the redunant work only move remainder of ` k / length of nums` steps.\\n- Time complexity: **O(NK)**\\n- Space complexity: **O(1)**\\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        while k:\\n            nums.insert(0, nums.pop())\\n            k -= 1\\n```\\n_2. Insert(0,x) takes O(N), swap elements takes O(1):_\\n  Python list is a dynamic array. inserting an element in front of array takes O(N).\\n   swaping element in array takes O(1). \\n- Time complexity: **O(N)**\\n- Space complexity: **O(1)**\\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)\\n        count, start = 0, 0\\n        while count < len(nums):\\n            current = start\\n            prev = nums[start]\\n            while 1:\\n                current = (current + k) % len(nums)\\n                temp, nums[current] = nums[current], prev\\n                prev = temp\\n                count += 1\\n                if start == current:\\n                    break\\n            start += 1\\n```\\n- Time complexity: **O(N)**\\n- Space complexity: **O(1)**\\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar rotate = (nums, k) => {\\n    let [start, count] = [0, 0];\\n    while (count < nums.length) {\\n        let [current, prev] = [start, nums[start]];\\n        do {\\n            current = (current + k) % nums.length;\\n            [nums[current], prev] = [prev, nums[current]];\\n            count++;\\n        } while (current !== start)\\n        start++\\n    }\\n};\\n```\\n\\n##  Reduce `k` & Use Slicing\\n- Time complexity: **O(N)**\\n- Space complexity: **O(N)**\\n- Python slice create new array\\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        if k == 0: return\\n        nums[:-k], nums[-k:] = nums[-k:], nums[:-k]\\n```\\n- Time complexity: **O(N)**\\n- Space complexity: **O(N)**\\n- JavaScript splice create new array\\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void}\\n */\\nconst rotate = (nums, k) => {\\n    nums.unshift(...nums.splice(nums.length - k%nums.length));\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        while k:\\n            nums.insert(0, nums.pop())\\n            k -= 1\\n```\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void}\\n */\\nconst rotate = (nums, k) => {\\n    while(k--) {\\n        nums.unshift(nums.pop());\\n    }\\n};\\n```\n```Python\\nfrom collections import deque\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        d = deque(nums)\\n        for _ in range(k):\\n            d.appendleft(d.pop())\\n        nums[:] = list(d)\\n```\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void}\\n */\\nconst rotate = (nums, k) => {\\n    const stack = [];\\n    k %= nums.length;\\n    while(k--) {\\n        stack.push(nums.pop());\\n    }\\n    nums.unshift(...stack.reverse());\\n};\\n```\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        while k:\\n            nums.insert(0, nums.pop())\\n            k -= 1\\n```\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)\\n        count, start = 0, 0\\n        while count < len(nums):\\n            current = start\\n            prev = nums[start]\\n            while 1:\\n                current = (current + k) % len(nums)\\n                temp, nums[current] = nums[current], prev\\n                prev = temp\\n                count += 1\\n                if start == current:\\n                    break\\n            start += 1\\n```\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar rotate = (nums, k) => {\\n    let [start, count] = [0, 0];\\n    while (count < nums.length) {\\n        let [current, prev] = [start, nums[start]];\\n        do {\\n            current = (current + k) % nums.length;\\n            [nums[current], prev] = [prev, nums[current]];\\n            count++;\\n        } while (current !== start)\\n        start++\\n    }\\n};\\n```\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        if k == 0: return\\n        nums[:-k], nums[-k:] = nums[-k:], nums[:-k]\\n```\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void}\\n */\\nconst rotate = (nums, k) => {\\n    nums.unshift(...nums.splice(nums.length - k%nums.length));\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202250,
                "title": "4-python-solutions",
                "content": "Delete k elements from the end and insert them at the begining\\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        for i in range(k % len(nums)):\\n            nums.insert(0, nums.pop())\\n```\\n\\nIteratively move each element to it\\'s correct position\\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        k = k % len(nums)\\n        n = len(nums)\\n        i = 0\\n        count = 0\\n        while count < n:\\n            pos = (i + k) % len(nums)\\n            curr = nums[pos]\\n            nums[pos] = nums[i]\\n            count += 1\\n            j = pos\\n            while j != i and count < n:\\n                pos = (j + k) % len(nums)\\n                nums[pos], curr = curr, nums[pos]\\n                j = pos\\n                count += 1\\n            i += 1\\n```\\n\\nUse an additional array to copy the elements into rotated positions and copy them back to original array\\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        k = k % len(nums)\\n        dupnums = [0] * len(nums)\\n        for i in range(len(nums)):\\n            dupnums[(i + k) % len(nums)] = nums[i]\\n\\n        nums[:] = dupnums # copy dupnums to nums\\n```\\n\\nSame as the first one. But, by taking advantage of python\\'s list indexing.\\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        for i in range(k % len(nums)):\\n            nums.insert(0, nums.pop())\\n```\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        k = k % len(nums)\\n        n = len(nums)\\n        i = 0\\n        count = 0\\n        while count < n:\\n            pos = (i + k) % len(nums)\\n            curr = nums[pos]\\n            nums[pos] = nums[i]\\n            count += 1\\n            j = pos\\n            while j != i and count < n:\\n                pos = (j + k) % len(nums)\\n                nums[pos], curr = curr, nums[pos]\\n                j = pos\\n                count += 1\\n            i += 1\\n```\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        k = k % len(nums)\\n        dupnums = [0] * len(nums)\\n        for i in range(len(nums)):\\n            dupnums[(i + k) % len(nums)] = nums[i]\\n\\n        nums[:] = dupnums # copy dupnums to nums\\n```\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54419,
                "title": "a-7-line-time-o-n-in-place-solution-no-reversing",
                "content": "The concise 7-line version.\\n\\n    Sample [1,2,3,4,5,6,7,8,9] 3    \\n    The replacing process is as follow:\\n    1) 1->4->7->1\\n    2) 2->5->8->2\\n    3) 3->6->9->3\\n    public void Rotate(int[] nums, int k) {\\n        if(nums.Length == 0 || k % nums.Length == 0) return;\\n        int start = 0, i = start, curNum = nums[i], count = 0;\\n        while(count++ < nums.Length){\\n            int tmp = nums[i = (i + k) % nums.Length];\\n            nums[i] = curNum;\\n            curNum = i == start ? nums[i = ++start] : tmp;\\n        }\\n    }\\n\\n\\nBelow is the elaborated version easier to understand\\n\\n    public void Rotate(int[] nums, int k) {\\n        if(nums.Length == 0 || k % nums.Length == 0) return;\\n        int start = 0, i = start, curNum = nums[i], count = 0;\\n        while(count < nums.Length){\\n            i = (i + k) % nums.Length;\\n            int tmp = nums[i];\\n            nums[i] = curNum;\\n            if(i == start){\\n                start++;\\n                i = start;\\n                curNum = nums[i];\\n            }\\n            else curNum = tmp;\\n            count++;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The concise 7-line version.\\n\\n    Sample [1,2,3,4,5,6,7,8,9] 3    \\n    The replacing process is as follow:\\n    1) 1->4->7->1\\n    2) 2->5->8->2\\n    3) 3->6->9->3\\n    public void Rotate(int[] nums, int k) {\\n        if(nums.Length == 0 || k % nums.Length == 0) return;\\n        int start = 0, i = start, curNum = nums[i], count = 0;\\n        while(count++ < nums.Length){\\n            int tmp = nums[i = (i + k) % nums.Length];\\n            nums[i] = curNum;\\n            curNum = i == start ? nums[i = ++start] : tmp;\\n        }\\n    }\\n\\n\\nBelow is the elaborated version easier to understand\\n\\n    public void Rotate(int[] nums, int k) {\\n        if(nums.Length == 0 || k % nums.Length == 0) return;\\n        int start = 0, i = start, curNum = nums[i], count = 0;\\n        while(count < nums.Length){\\n            i = (i + k) % nums.Length;\\n            int tmp = nums[i];\\n            nums[i] = curNum;\\n            if(i == start){\\n                start++;\\n                i = start;\\n                curNum = nums[i];\\n            }\\n            else curNum = tmp;\\n            count++;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54606,
                "title": "c-3-lines-easy-to-understand",
                "content": "    /*****\\n    ****author: cxq\\n    ****weibo: http://weibo.com/chenxq1992\\n    ****/\\n    class Solution {\\n    public:\\n        void rotate(int nums[], int n, int k) {\\n            k = k % n;\\n            reverse(nums, nums + n);\\n            reverse(nums, nums + k);\\n            reverse(nums + k, nums + n);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void rotate(int nums[], int n, int k) {\\n            k = k % n;\\n            reverse(nums, nums + n);\\n            reverse(nums, nums + k);\\n            reverse(nums + k, nums + n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3218810,
                "title": "189-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The first step is to calculate the number of steps we actually need to take. Since rotating the array by its length has no effect, we can use the modulo operator to reduce the number of steps to be less than the length of the array.\\n2. The second step is to reverse the entire array. This has the effect of moving the last k elements to the beginning of the array.\\n3. The third step is to reverse the first k elements. This moves them to the end of the array, while leaving the remaining elements in place.\\n4. The fourth and final step is to reverse the remaining elements. This moves them to the beginning of the array, completing the rotation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        # Calculate the number of steps we actually need to take\\n        k = k % len(nums)\\n    \\n        # Reverse the entire array\\n        nums.reverse()\\n    \\n        # Reverse the first k elements\\n        nums[:k] = reversed(nums[:k])\\n    \\n        # Reverse the remaining elements\\n        nums[k:] = reversed(nums[k:])\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        # Calculate the number of steps we actually need to take\\n        k = k % len(nums)\\n    \\n        # Reverse the entire array\\n        nums.reverse()\\n    \\n        # Reverse the first k elements\\n        nums[:k] = reversed(nums[:k])\\n    \\n        # Reverse the remaining elements\\n        nums[k:] = reversed(nums[k:])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832647,
                "title": "two-js-solutions",
                "content": "```\\nvar rotate = function(nums, k) {\\n    for (let i = 0; i < k; i++) {\\n        nums.unshift(nums.pop());\\n    }\\n};\\n```\\n\\n```\\nvar rotate = function(nums, k) {\\n    if (nums === null || nums.length === 0) {\\n        return;\\n    }\\n    k = k % nums.length;\\n    if (k === 0) {\\n        return;\\n    }\\n    nums.reverse();\\n    reverse(nums, 0, k-1);\\n    reverse(nums, k, nums.length - 1);\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n\\nconst reverse = (arr, start, end) => {\\n    while (start < end) {\\n        let temp = arr[start];\\n        arr[start] = arr[end];\\n        arr[end] = temp;\\n        start++, end--;\\n    }\\n}\\n\\n/*\\nSolution:\\n1. Reverse the entire array.\\n2. Reverse the first k elements.\\n3. Reverse the rest.\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function(nums, k) {\\n    for (let i = 0; i < k; i++) {\\n        nums.unshift(nums.pop());\\n    }\\n};\\n```\n```\\nvar rotate = function(nums, k) {\\n    if (nums === null || nums.length === 0) {\\n        return;\\n    }\\n    k = k % nums.length;\\n    if (k === 0) {\\n        return;\\n    }\\n    nums.reverse();\\n    reverse(nums, 0, k-1);\\n    reverse(nums, k, nums.length - 1);\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n\\nconst reverse = (arr, start, end) => {\\n    while (start < end) {\\n        let temp = arr[start];\\n        arr[start] = arr[end];\\n        arr[end] = temp;\\n        start++, end--;\\n    }\\n}\\n\\n/*\\nSolution:\\n1. Reverse the entire array.\\n2. Reverse the first k elements.\\n3. Reverse the rest.\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3125740,
                "title": "easy-solution-with-explanation-without-using-extra-space",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is here to use circular rotation i.e, here in \\n##### Example 1:\\nInput: nums = [1,2], k = 3\\n Output: [2,1]\\n\\nif the value of k is greater than the size of the array, then our array can go out of bounds, to solve that and rotate the array under given condition we are using circular rotation. i.e, **k= k% nums.length**\\n\\nHere in E:g the k=3, now if k%n = 3%2 ==> 1, so the value of rotation becomes 1.\\n\\n### To Arrange the elements in place\\n\\n1) First we have to reverse the whole array using two pointers technique.\\n2) Now after the array is reversed, now we have to reverse the elements before the occurence of k, i.e, **(0,k-1)**\\n\\n**Note:** [Here we have  here we subtracted 1 from k **(0,k-1)**, because we are using 0-indexed array].\\n\\n3) Now we have to reverse the elements after the occurence of k(rotation), i.e, \\n**(k,nums.length-1)**\\n\\nNow, the array is arranged without using extra space\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        rotate(nums,0,nums.length-1);\\n        rotate(nums,0,k-1);\\n        rotate(nums,k,nums.length-1);\\n    }\\n    private void rotate(int[] nums, int low, int high){\\n        while(low<high){\\n            int temp = nums[low];\\n            nums[low] = nums[high];\\n            nums[high] = temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```\\n## Upvote me if you like the approach and explanation. This helps me to bring you more solutions like that............",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        rotate(nums,0,nums.length-1);\\n        rotate(nums,0,k-1);\\n        rotate(nums,k,nums.length-1);\\n    }\\n    private void rotate(int[] nums, int low, int high){\\n        while(low<high){\\n            int temp = nums[low];\\n            nums[low] = nums[high];\\n            nums[high] = temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258789,
                "title": "python-2-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Using Extra Space**\\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        n = len(nums)\\n        k %= n\\n        ans = [0] * n\\n        \\n        for i in range(n):\\n            ans[(i+k)%n] = nums[i]\\n            \\n        for i in range(n):\\n            nums[i] = ans[i]\\n```\\nComplexity:\\n- Time: `O(N)`, where `N` is length of `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Reverse array**\\n- Example Input: [1, 2, 3, 4, 5, 6], k = 2\\n- Expect Output: [5, 6, 1, 2, 3, 4]\\n- The idea is that we do 3 reverse\\n- Reverse the whole array, it becomes: [6, 5, 4, 3, 2, 1]\\n- Reverse first `k` elements, it becomes: [5, 6, 4, 3, 2, 1]\\n- Reverse the last `n-k` elements, it becomes: [5, 6, 1, 2, 3, 4]\\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        def reverse(arr, left, right):\\n            while left < right:\\n                arr[left], arr[right] = arr[right], arr[left]\\n                left += 1\\n                right -= 1\\n                \\n        n = len(nums)\\n        k %= n\\n        reverse(nums, 0, n - 1)\\n        reverse(nums, 0, k-1)\\n        reverse(nums, k, n-1)\\n```\\nComplexity:\\n- Time: `O(N)`, where `N` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        n = len(nums)\\n        k %= n\\n        ans = [0] * n\\n        \\n        for i in range(n):\\n            ans[(i+k)%n] = nums[i]\\n            \\n        for i in range(n):\\n            nums[i] = ans[i]\\n```\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        def reverse(arr, left, right):\\n            while left < right:\\n                arr[left], arr[right] = arr[right], arr[left]\\n                left += 1\\n                right -= 1\\n                \\n        n = len(nums)\\n        k %= n\\n        reverse(nums, 0, n - 1)\\n        reverse(nums, 0, k-1)\\n        reverse(nums, k, n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668133,
                "title": "simplest-way-using-insert-and-pop",
                "content": "# Intuition\\nTo rotate the array nums to the right by k steps, we can follow these steps:\\n\\n1. If k is greater than the length of nums, reduce k by taking its modulo with the length of nums. This ensures that k falls within the range of valid rotations.\\n2. Perform the rotation in-place by repeatedly popping the last element of the array and inserting it at the beginning for k times.\\n# Approach\\n\\n1.\\tCheck if k is greater than the length of nums. If so, reduce k by taking its modulo with the length of nums.\\n2.\\tPerform the rotation by iterating k times using a for loop:\\n\\u2022\\tRemove the last element of nums using pop() and store it in a variable a.\\n\\u2022\\tInsert the value a at the beginning of nums using insert().\\n\\n# Complexity\\n- Time complexity: O(n^2)\\nThe time complexity is proportional to the value of k since we need to rotate the array k times.\\n\\n- Space complexity: O(1)\\nThe space complexity is constant as we are modifying the input array in-place and not using any additional data structures.\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        for i in range(k):\\n            a=nums.pop()\\n            nums.insert(0,a)\\n```\\n\\n##### reach me to discuss any problems - https://www.linkedin.com/in/naveen-kumar-g-500469210/\\n![image.png](https://assets.leetcode.com/users/images/8d8328c3-f05f-4acb-9e6d-87c7a1abd695_1687413526.140085.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        for i in range(k):\\n            a=nums.pop()\\n            nums.insert(0,a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168393,
                "title": "one-liner-in-python3",
                "content": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545232,
                "title": "c-java-python-javascript-2-approaches-brute-and-optimized-space-complexity-o-1",
                "content": "# 1. Brute Force: Time complexity: O(n), Space complexity: O(k)\\n### Intuition\\nThe intuition behind the approach is to divide the rotation process into two steps: first, storing the last k elements in a temporary array, and then rearranging the remaining elements in nums to their new positions. By using this two-step process, the function achieves the desired rotation effect.\\n\\n### Approach\\n1. Initialize the variable `n` with the size of the `nums` vector.\\n\\n2. The value of `k` is updated to be the remainder when divided by `n`. This step ensures that `k` is within the valid range of indices.\\n\\n3. If `k` is greater than `n`, the function returns early without performing any rotations. This is because rotating by `k` positions would result in the same configuration as rotating by `k % n` positions.\\n\\n4. Next, the function checks for some special cases where rotation is not necessary: when `n` or `k` is 0, or when `n` is equal to `k`. In such cases, the function returns early without any further computations.\\n\\n5. If none of the early return conditions are met, an array `temp` of size `k` is created to store the last `k` elements of `nums` temporarily.\\n\\n6. A loop runs `k` times, copying the last `k` elements of `nums` to the `temp` array in reverse order.\\n\\n7. Another loop runs from `n-1` to 0. For each iteration, if the index `i` is less than `k`, the corresponding element in `nums` is updated with the element from `temp` at the reversed index `k-i-1`. This step places the rotated elements at the beginning of `nums`.\\n\\n8. If the index `i` is greater than or equal to `k`, the corresponding element in `nums` is updated with the element at index `i-k`, effectively shifting the remaining elements to their new positions.\\n\\n9. After the loops complete, the function has successfully rotated the elements in `nums` by `k` positions.\\n\\n### Complexity\\n- Time complexity: O(n), where n is the size of the input vector `nums`. This is because the code performs two loops, one with `k` iterations and the other with `n` iterations, where `k` and `n` are at most equal to the size of `nums`. All other operations are constant time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k), as it uses an auxiliary array `temp` of size `k` to temporarily store the elements to be rotated.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\t   k = k % n;\\n\\t   cout<<k<<endl;\\n\\t   if (k > n){\\n        return;\\n\\t   }\\n        if(n==0 || k==0 || n==k){\\n\\t       return;\\n\\t   }\\n\\t   int temp[k];\\n\\t   for(int i=0;i<k;i++){\\n\\t       temp[i]=nums[n-i-1];\\n\\t   }\\n\\t   for(int i=n-1;i>=0;i--){\\n\\t\\t\\t if(i<k){\\n\\t\\t\\t\\t nums[i]=temp[k-i-1];\\n\\t\\t\\t }\\n\\t\\t\\t else{\\n\\t\\t\\t\\t nums[i]=nums[i-k];\\n\\t\\t\\t }\\n\\t   }\\n    }\\n};\\n```\\n\\n---\\n\\n\\n# 2. Optimized Approach : Time complexity: O(n), Space complexity: O(1)\\n\\n# Intuition:\\nThe problem requires rotating the elements of a vector to the right by a given number of positions. To optimize the code to achieve O(1) space complexity, we can perform the rotation in-place without using any additional arrays.\\n\\n# Approach:\\n1. First, we initialize the variables `n` and `k`, where `n` is the size of the input vector `nums`, and `k` is the number of positions to rotate.\\n2. We update `k` to be the remainder when divided by `n` to ensure it is within the valid range of indices.\\n3. We handle some special cases: if `k` is 0, `n` is 0, or `n` is equal to `k`, we return early as no rotation is needed.\\n4. We initialize the variables `count`, `start`, `current`, and `prev`. The `count` keeps track of the number of elements moved, `start` represents the starting index for each rotation cycle, `current` is the current index being processed, and `prev` stores the value that will be moved to the next position.\\n5. We enter a loop that continues until all elements have been moved to their correct positions. Inside the loop:\\n   - We calculate the new index `current` by adding `k` to the current index and taking the modulus of `n` to handle wraparound.\\n   - We swap the value at the current index `current` with the value in `prev`.\\n   - We update `prev` to the value that was previously at the current index.\\n   - We increment the `count`.\\n   - If the `current` index becomes equal to the `start` index, it means that we have completed a rotation cycle. We increment `start`, update `current` and `prev` to the new values, and continue the rotation process until all elements have been moved.\\n6. Once the loop completes, the vector `nums` will contain the rotated elements.\\n\\n# Complexity:\\n- The time complexity of the optimized code is O(n), where n is the size of the input vector `nums`. This is because the code needs to visit each element in the vector to perform the rotations.\\n\\n- The space complexity of the optimized code is O(1) since it does not require any additional space proportional to the input size. It only uses a few extra variables to keep track of indices and temporarily store values during swapping.\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k = k % n;\\n        if (k == 0 || n == 0 || n == k) {\\n            return;\\n        }\\n        \\n        int count = 0;\\n        int start = 0;\\n        int current = start;\\n        int prev = nums[start];\\n        \\n        while (count < n) {\\n            current = (current + k) % n;\\n            int temp = nums[current];\\n            nums[current] = prev;\\n            prev = temp;\\n            count++;\\n            \\n            if (current == start) {\\n                start++;\\n                current = start;\\n                prev = nums[start];\\n            }\\n        }\\n    }\\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        k = k % n;\\n        if (k == 0 || n == 0 || n == k) {\\n            return;\\n        }\\n        \\n        int count = 0;\\n        int start = 0;\\n        int current = start;\\n        int prev = nums[start];\\n        \\n        while (count < n) {\\n            current = (current + k) % n;\\n            int temp = nums[current];\\n            nums[current] = prev;\\n            prev = temp;\\n            count++;\\n            \\n            if (current == start) {\\n                start++;\\n                current = start;\\n                prev = nums[start];\\n            }\\n        }\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        n = len(nums)\\n        k = k % n\\n        if k == 0 or n == 0 or n == k:\\n            return\\n        \\n        count = 0\\n        start = 0\\n        current = start\\n        prev = nums[start]\\n        \\n        while count < n:\\n            current = (current + k) % n\\n            nums[current], prev = prev, nums[current]\\n            count += 1\\n            \\n            if current == start:\\n                start += 1\\n                current = start\\n                prev = nums[start]\\n\\n```\\n# JavaScript\\n```\\nvar rotate = function(nums, k) {\\n    var n = nums.length;\\n    k = k % n;\\n    if (k === 0 || n === 0 || n === k) {\\n        return;\\n    }\\n    \\n    var count = 0;\\n    var start = 0;\\n    var current = start;\\n    var prev = nums[start];\\n    \\n    while (count < n) {\\n        current = (current + k) % n;\\n        var temp = nums[current];\\n        nums[current] = prev;\\n        prev = temp;\\n        count++;\\n        \\n        if (current === start) {\\n            start++;\\n            current = start;\\n            prev = nums[start];\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\t   k = k % n;\\n\\t   cout<<k<<endl;\\n\\t   if (k > n){\\n        return;\\n\\t   }\\n        if(n==0 || k==0 || n==k){\\n\\t       return;\\n\\t   }\\n\\t   int temp[k];\\n\\t   for(int i=0;i<k;i++){\\n\\t       temp[i]=nums[n-i-1];\\n\\t   }\\n\\t   for(int i=n-1;i>=0;i--){\\n\\t\\t\\t if(i<k){\\n\\t\\t\\t\\t nums[i]=temp[k-i-1];\\n\\t\\t\\t }\\n\\t\\t\\t else{\\n\\t\\t\\t\\t nums[i]=nums[i-k];\\n\\t\\t\\t }\\n\\t   }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k = k % n;\\n        if (k == 0 || n == 0 || n == k) {\\n            return;\\n        }\\n        \\n        int count = 0;\\n        int start = 0;\\n        int current = start;\\n        int prev = nums[start];\\n        \\n        while (count < n) {\\n            current = (current + k) % n;\\n            int temp = nums[current];\\n            nums[current] = prev;\\n            prev = temp;\\n            count++;\\n            \\n            if (current == start) {\\n                start++;\\n                current = start;\\n                prev = nums[start];\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        k = k % n;\\n        if (k == 0 || n == 0 || n == k) {\\n            return;\\n        }\\n        \\n        int count = 0;\\n        int start = 0;\\n        int current = start;\\n        int prev = nums[start];\\n        \\n        while (count < n) {\\n            current = (current + k) % n;\\n            int temp = nums[current];\\n            nums[current] = prev;\\n            prev = temp;\\n            count++;\\n            \\n            if (current == start) {\\n                start++;\\n                current = start;\\n                prev = nums[start];\\n            }\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        n = len(nums)\\n        k = k % n\\n        if k == 0 or n == 0 or n == k:\\n            return\\n        \\n        count = 0\\n        start = 0\\n        current = start\\n        prev = nums[start]\\n        \\n        while count < n:\\n            current = (current + k) % n\\n            nums[current], prev = prev, nums[current]\\n            count += 1\\n            \\n            if current == start:\\n                start += 1\\n                current = start\\n                prev = nums[start]\\n\\n```\n```\\nvar rotate = function(nums, k) {\\n    var n = nums.length;\\n    k = k % n;\\n    if (k === 0 || n === 0 || n === k) {\\n        return;\\n    }\\n    \\n    var count = 0;\\n    var start = 0;\\n    var current = start;\\n    var prev = nums[start];\\n    \\n    while (count < n) {\\n        current = (current + k) % n;\\n        var temp = nums[current];\\n        nums[current] = prev;\\n        prev = temp;\\n        count++;\\n        \\n        if (current === start) {\\n            start++;\\n            current = start;\\n            prev = nums[start];\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2396053,
                "title": "c-3-methods-fast-explained",
                "content": "**This took a lot of effort to document. Please upvote if helpful**\\n\\n**Method-1**\\nMost elementary method is by creating a  copy of given array and exploiting defn of rotation: *nums[(i+k)%n] = old_nums[i]*.\\nTC: O(n)\\nSC: O(n)\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> cpy(nums.cbegin(), nums.cend());\\n        \\n        for (int i = 0; i < n; i++) {\\n            nums[(i+k)%n] = cpy[i];\\n        }\\n    }\\n};\\n```\\n\\n**Method-2**\\nHere, we reduce the space complexity from O(n) to O(1). Note that the rotated array consists of two parts of the main array- one from [k..n-1], and otehr from [0..k-1]. Note that the part from [0..k-1] follows [k..n-1]. So, we reverse the main array, and re-reverse it in two parts- [0..k-1] and [k..n-1].\\nTC: O(n)\\nSC: O(1)\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k %= n;\\n        \\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n        \\n        return;\\n    }\\n};\\n```\\n\\n**Method-3**\\nThis is fairly mathematically involved, and some interest in number theory is expected. Although it too used O(n) space, but instead of storing *n integers*, we store *n booleans*; also this is mainly for mathematic interests. For *n*, and *k*, we have two cases-\\nCase i: *gcd(n,k) = 1*\\nS = {(i+k)%n | i=0 or i \\\\in S} = {i | 0<=i and i<n}\\nCase ii: *gcd(n,k) = d != 1*\\nSt = {(i+k)%n | i=t or i \\\\in S}; union of whom for t=0 to t=d-1, will equal {i | 0<=i and i<n}.\\nTC: O(n)\\nSC: O(n)\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k %= n;\\n        vector<bool> visited(n, false);\\n\\n        int curr_idx = 0, curr_val = nums[0], next_idx = k;\\n        for (int i = 0; i < n;i++) {\\n            if (!visited[i]) {\\n                curr_idx = i;\\n                next_idx = (i + k) % n;\\n                curr_val = nums[i];\\n                while (!visited[next_idx]) {\\n                    visited[next_idx] = true;\\n                    swap(curr_val, nums[next_idx]);\\n                    curr_idx = next_idx;\\n                    next_idx = (curr_idx + k) % n;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Please upvote, if helpful; as this took a lot of effort**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> cpy(nums.cbegin(), nums.cend());\\n        \\n        for (int i = 0; i < n; i++) {\\n            nums[(i+k)%n] = cpy[i];\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k %= n;\\n        \\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n        \\n        return;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k %= n;\\n        vector<bool> visited(n, false);\\n\\n        int curr_idx = 0, curr_val = nums[0], next_idx = k;\\n        for (int i = 0; i < n;i++) {\\n            if (!visited[i]) {\\n                curr_idx = i;\\n                next_idx = (i + k) % n;\\n                curr_val = nums[i];\\n                while (!visited[next_idx]) {\\n                    visited[next_idx] = true;\\n                    swap(curr_val, nums[next_idx]);\\n                    curr_idx = next_idx;\\n                    next_idx = (curr_idx + k) % n;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591978,
                "title": "python-solution-super-simple-easy-to-understand-common-mistakes-explained",
                "content": "**1. Solution**\\n\\n```\\n    def rotate(self, nums, k):\\n        k = k % len(nums)                 #take care of the case where k >= len(nums)  \\n        nums[:] = nums[-k:] + nums[:-k] \\n```\\n\\n\\n\\n**2. Remarks**\\n\\n* We use  `k % len(nums)` to take care of the case where the input `k` is larger than the length of `nums` list.\\n* There\\'s no return value since we modified the list in-place using  `nums[:] = ...` .\\n\\n\\n**3. Common confusion** \\n* ***Why ` return nums[-k:] + nums[:-k] ` doesn\\'t work?***\\n\\n     Well, it should work when you run it locally (not on Leetcode). Because there\\'s an extra constraint added in the follow-up questions which requires in-place list modification. And this is clearly not an in-place modification, so it won\\'t pass the Leetcode tests.\\n\\t \\n\\t \\n****Please upvote if you find it useful, and welcome to any further discussion!***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def rotate(self, nums, k):\\n        k = k % len(nums)                 #take care of the case where k >= len(nums)  \\n        nums[:] = nums[-k:] + nums[:-k] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2836561,
                "title": "o-1-java-simple-solution-0ms-100-faster",
                "content": "1. for eg: arr = [1,2,3,4,5] k=2, Now reverse the array. It becomes [5,4,3,2,1]\\n2. Now split into two parts based on k value. like [5,4,] and [3,2,1]\\n3. Now reverse the both parts.\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        // step1: reverse the array\\n        // step2: split the array into two.\\n        // step3: reverse both the two parts.\\n        \\n        //taking k modulo for edge cases\\n        k = k%nums.length;\\n        swap(nums, 0, nums.length-1);\\n        swap(nums, 0, k-1);\\n        swap(nums, k, nums.length-1);\\n    }\\n    public void swap(int[] arr, int start, int end){\\n        while(start<end){\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        // step1: reverse the array\\n        // step2: split the array into two.\\n        // step3: reverse both the two parts.\\n        \\n        //taking k modulo for edge cases\\n        k = k%nums.length;\\n        swap(nums, 0, nums.length-1);\\n        swap(nums, 0, k-1);\\n        swap(nums, k, nums.length-1);\\n    }\\n    public void swap(int[] arr, int start, int end){\\n        while(start<end){\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390391,
                "title": "4-methods-in-python-index-assign-list-slicing-reversed",
                "content": "```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        # Method 1 : list slicing\\n        k = k % len(nums)\\n        if len(nums) > 1 and k > 0:\\n            nums[:] = nums[-k:] + nums[:-k]\\n        \\n        # Method 2 : list replacing\\n        k = k % len(nums)\\n        if len(nums) > 1 and  k > 0:\\n            nums[:k], nums[k:] = nums[-k:], nums[:-k]\\n            \\n        # Method 3 : index assigning\\n        k = k % len(nums)\\n        tmp = nums[-k:]\\n        for index in range(len(nums)-1, k-1, -1):\\n            nums[index] = nums[index-k]\\n        for index, value in enumerate(tmp):\\n            nums[index] = value\\n\\n        # Method 4 : reversed method\\n        k = k % len(nums)\\n        if len(nums) > 1 and  k > 0:\\n            nums[:] = reversed(nums)\\n            nums[:k], nums[k:] = reversed(nums[:k]), reversed(nums[k:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        # Method 1 : list slicing\\n        k = k % len(nums)\\n        if len(nums) > 1 and k > 0:\\n            nums[:] = nums[-k:] + nums[:-k]\\n        \\n        # Method 2 : list replacing\\n        k = k % len(nums)\\n        if len(nums) > 1 and  k > 0:\\n            nums[:k], nums[k:] = nums[-k:], nums[:-k]\\n            \\n        # Method 3 : index assigning\\n        k = k % len(nums)\\n        tmp = nums[-k:]\\n        for index in range(len(nums)-1, k-1, -1):\\n            nums[index] = nums[index-k]\\n        for index, value in enumerate(tmp):\\n            nums[index] = value\\n\\n        # Method 4 : reversed method\\n        k = k % len(nums)\\n        if len(nums) > 1 and  k > 0:\\n            nums[:] = reversed(nums)\\n            nums[:k], nums[k:] = reversed(nums[:k]), reversed(nums[k:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54331,
                "title": "three-simple-solutions-using-c",
                "content": "    void rotate(int nums[], int n, int k) {\\n        while(k>0) {\\n        int tmp = nums[n-1];\\n            for(int i=n-1; i>0; i--) {\\n                nums[i] = nums[i-1];\\n            }\\n            nums[0] = tmp;\\n            k--;\\n        }\\n    }\\n    \\n    void rotate(int nums[], int n, int k) {\\n        if (k<=0) {\\n            return;\\n        }\\n        int tmp = nums[n-1];\\n        for(int i=n-1; i>0; i--) {\\n            nums[i] = nums[i-1];\\n        }\\n        nums[0] = tmp;\\n        rotate(nums, n, k-1);\\n    }\\n    \\n    void strReverse(int nums[], int bgn, int end) {\\n        int lst = end-1;\\n        while(bgn<lst) {\\n            int tmp = nums[bgn];\\n            nums[bgn] = nums[lst];\\n            nums[lst] = tmp;\\n            bgn++;\\n            lst--;\\n        }\\n    }\\n    \\n    void rotate(int nums[], int n, int k) {\\n        if (k<=0) {\\n            return;\\n        }\\n        k = k%n;\\n        strReverse(nums, 0, n-k);\\n        strReverse(nums, n-k, n);\\n        strReverse(nums, 0, n);\\n    }",
                "solutionTags": [],
                "code": "    void rotate(int nums[], int n, int k) {\\n        while(k>0) {\\n        int tmp = nums[n-1];\\n            for(int i=n-1; i>0; i--) {\\n                nums[i] = nums[i-1];\\n            }\\n            nums[0] = tmp;\\n            k--;\\n        }\\n    }\\n    \\n    void rotate(int nums[], int n, int k) {\\n        if (k<=0) {\\n            return;\\n        }\\n        int tmp = nums[n-1];\\n        for(int i=n-1; i>0; i--) {\\n            nums[i] = nums[i-1];\\n        }\\n        nums[0] = tmp;\\n        rotate(nums, n, k-1);\\n    }\\n    \\n    void strReverse(int nums[], int bgn, int end) {\\n        int lst = end-1;\\n        while(bgn<lst) {\\n            int tmp = nums[bgn];\\n            nums[bgn] = nums[lst];\\n            nums[lst] = tmp;\\n            bgn++;\\n            lst--;\\n        }\\n    }\\n    \\n    void rotate(int nums[], int n, int k) {\\n        if (k<=0) {\\n            return;\\n        }\\n        k = k%n;\\n        strReverse(nums, 0, n-k);\\n        strReverse(nums, n-k, n);\\n        strReverse(nums, 0, n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4045516,
                "title": "most-optimized-solution-c-o-n-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n<div class=\"Note:\">\\n  <p><strong># Note:</strong> k might be greater than or equal to nums.size(). Therefore set k equal to k % nums.size() .</p>\\n</div>\\n\\n<pre>\\nk = k % nums.size();\\n</pre>\\n\\n\\n##### Example:- 1 2 3 4 5 6 7; k = 4; n = 7\\n1. Reverse the k elements from the last:\\n<pre>reverse(nums.end() - k, nums.end());      // 1 2 3 7 6 5 4</pre>\\n2. Then reverse the elements form index 0 to n-k-1:\\n<pre>reverse(nums.begin(), nums.end() - k);    // 3 2 1 7 6 5 4</pre>\\n3. Now reverse the whole nums;\\n<pre>reverse(nums.begin(), nums.end());        // 4 5 6 7 1 2 3</pre> \\n\\n\\n<!-- <div class=\"Note:\">\\n  <p><strong># Note:</strong> k might be greater than or equal to nums.size(). Therefore set k equal to k % nums.size() .</p>\\n</div> -->\\n# Complexity\\n\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        // int nums_size = nums.size();\\n        k = k % nums.size();\\n        if(k!=0)\\n        {\\n            reverse(nums.end() - k, nums.end());\\n            reverse(nums.begin(), nums.end() - k);\\n            reverse(nums.begin(), nums.end());\\n        }\\n    }\\n};\\n```\\n\\n### Please upvote!!!\\n\\n<!-- <p><img src=\"https://assets.leetcode.com/users/images/be16a9b6-6d5f-433f-89e8-90f18384d6f9_1683670956.5248532.jpeg\" alt=\"7abc56.jpg\"></p> -->",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        // int nums_size = nums.size();\\n        k = k % nums.size();\\n        if(k!=0)\\n        {\\n            reverse(nums.end() - k, nums.end());\\n            reverse(nums.begin(), nums.end() - k);\\n            reverse(nums.begin(), nums.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244055,
                "title": "rotation-array-clockwise-rotation-rotation-game-time-complexity-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this question you just need to know: \\n**How to reverse the array?**\\nEg:\\nA0  A1  A2  A3  A4  A5  A6  A7  A8  A9  A10 A11\\n\\nfor K = 5\\nthe last 5 elements comes at the front (**observation 1**)\\n\\nAfter rotation of K times, exactly from back will come to front.\\n\\n\\nA7  A8  A9  A10 A11   A0  A1  A2  A3  A4  A5  A6\\n\\\\-------------------\\\\ \\\\--------------------------\\\\\\n______  k __________   ___________N-K _____________\\n\\nrotation(arr, k){\\n// 1. reverse the complete array\\n reverse(0, n-1);\\n// 2. reverse the first k elements\\n reverse(0, k-1);\\n// 3. reverse the remaining elements\\n reverse(k, n-1);\\n}\\n\\n\\n**Extension of Problem:**\\n**What if K > N??**\\nfor this you just have to have 1 condition:\\nif(k > n){\\nk = K %  n; // do rotations for k > n, you will figure why i did this.\\n}\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolution contains three steps:-\\n1. Reverse the complete array.\\n2. Reverse first K elements.\\n3. Reverse remaining elements.\\n\\n# Complexity\\n- Time complexity: N/2 + K/2 + (n-k)/2 => N/2 +  K/2 + N/2 - K/2 => O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public void reverse(int []arr, int low, int high){\\n        while(low < high){\\n            int temp = arr[low];\\n            arr[low] = arr[high];\\n            arr[high] = temp;\\n\\n            low++;\\n            high--;\\n        }\\n    }\\n    \\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        int start = 0;\\n        int end = n-1;\\n        if(k > n){\\n            k = k%n;\\n        }\\n        //1. reversing the whole array\\n        reverse(nums, start, end);\\n \\n\\n        //2. reversing the k part\\n        reverse(nums, start, k-1);\\n\\n        //3. reverse the remaining part\\n        reverse(nums, k, end);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public void reverse(int []arr, int low, int high){\\n        while(low < high){\\n            int temp = arr[low];\\n            arr[low] = arr[high];\\n            arr[high] = temp;\\n\\n            low++;\\n            high--;\\n        }\\n    }\\n    \\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        int start = 0;\\n        int end = n-1;\\n        if(k > n){\\n            k = k%n;\\n        }\\n        //1. reversing the whole array\\n        reverse(nums, start, end);\\n \\n\\n        //2. reversing the k part\\n        reverse(nums, start, k-1);\\n\\n        //3. reverse the remaining part\\n        reverse(nums, k, end);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664082,
                "title": "o-1-space-solution-with-explaination-and-code-with-comments-in-c",
                "content": "So the idea here is first we will reverse the entire array for example if the array was :[1,2,3,4,5,6,7] k=3\\nnow after we reverse it entirely we it will become :[7,6,5,4,3,2,1]\\nnow what we can do is reverse the subarray containing first k elements so now it will become :\\n[5,6,7,4,3,2,1]\\nnow u can notice that the elements which should have been in front after k rotations aree now in their right place and now finally to get our answer simply we reverse the rest of the elements then we will get :\\n[5,6,7,1,2,3,4]  this is our answer \\n\\nthis would be the code for this approach i hope guys will like it also it requires kinda 3 loops if any one has a solution to solve it in single iteration please do suggest Thankyou for viewing this below  I will be sharing the code for this with comments also please share any suggestions if you guys have any\\n\\n```\\nclass Solution {\\npublic:\\n    void rev(vector <int> &nums,int k){\\n        int s=0,e=k-1;\\n        while(s<=e){\\n            swap(nums[e],nums[s]);\\n            s++;e--;\\n        }\\n    }\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k=k%nums.size();//Calculating the appropriate size of k so as to prevent any index out of bounds\\n        \\n        reverse(nums.begin(),nums.end());// reversing the entire array\\n        \\n        rev(nums,k);// reversing first k elements of the array\\n        \\n        reverse(nums.begin()+k,nums.end());//reversing reset of the (nums.size()-k) elements of the array\\n    }\\n};\\n```\\nTime Complexity : O(n)\\nSpace Complexity : O(1)\\n\\nThankyou !",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rev(vector <int> &nums,int k){\\n        int s=0,e=k-1;\\n        while(s<=e){\\n            swap(nums[e],nums[s]);\\n            s++;e--;\\n        }\\n    }\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k=k%nums.size();//Calculating the appropriate size of k so as to prevent any index out of bounds\\n        \\n        reverse(nums.begin(),nums.end());// reversing the entire array\\n        \\n        rev(nums,k);// reversing first k elements of the array\\n        \\n        reverse(nums.begin()+k,nums.end());//reversing reset of the (nums.size()-k) elements of the array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54538,
                "title": "o-n-time-and-o-1-space-solution",
                "content": "The idea is to rotate using reversal.\\n1. divide the array into two parts.\\n2. reverse first part\\n3. reverse second part\\n4. reverse whole array\\n\\n    /**\\n     * rotate right an array\\n     * nums      : pointer to array to be rotated\\n     * numsSize  : length of array\\n     * k         : distance of rotation\\n     */ \\n    void rotate(int* nums, int numsSize, int k) {\\n        k = k % numsSize;\\n        if (k == 0) return;\\n        if (numsSize <= 1) return;\\n        \\n        //divide the array into 2 part\\n        int lengthFirstPart = numsSize - k;\\n        //reverse first part\\n        reverse(nums, lengthFirstPart);\\n        //reverse second part\\n        reverse(&nums[lengthFirstPart], numsSize - lengthFirstPart);\\n        //reverse everything\\n        reverse(nums, numsSize);\\n    }\\n    \\n    /**\\n     * reverse array\\n     * nums      : pointer to array to be reversed\\n     * numsSize  : length of array\\n     */ \\n    void reverse(int* nums, int numsSize){\\n        int mid = numsSize / 2;\\n        int temp;\\n        for(int i = 0; i < mid; i++){\\n            temp = nums[i];\\n            nums[i] = nums[numsSize - 1 - i];\\n            nums[numsSize - 1 - i] = temp;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The idea is to rotate using reversal.\\n1. divide the array into two parts.\\n2. reverse first part\\n3. reverse second part\\n4. reverse whole array\\n\\n    /**\\n     * rotate right an array\\n     * nums      : pointer to array to be rotated\\n     * numsSize  : length of array\\n     * k         : distance of rotation\\n     */ \\n    void rotate(int* nums, int numsSize, int k) {\\n        k = k % numsSize;\\n        if (k == 0) return;\\n        if (numsSize <= 1) return;\\n        \\n        //divide the array into 2 part\\n        int lengthFirstPart = numsSize - k;\\n        //reverse first part\\n        reverse(nums, lengthFirstPart);\\n        //reverse second part\\n        reverse(&nums[lengthFirstPart], numsSize - lengthFirstPart);\\n        //reverse everything\\n        reverse(nums, numsSize);\\n    }\\n    \\n    /**\\n     * reverse array\\n     * nums      : pointer to array to be reversed\\n     * numsSize  : length of array\\n     */ \\n    void reverse(int* nums, int numsSize){\\n        int mid = numsSize / 2;\\n        int temp;\\n        for(int i = 0; i < mid; i++){\\n            temp = nums[i];\\n            nums[i] = nums[numsSize - 1 - i];\\n            nums[numsSize - 1 - i] = temp;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54427,
                "title": "my-simple-python-code",
                "content": "    class Solution:\\n        def rotate(self, nums, k):\\n            while k > 0:\\n                nums.insert(0, nums.pop())\\n                k -= 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        def rotate(self, nums, k):\\n            while k > 0:\\n                nums.insert(0, nums.pop())\\n                k -= 1",
                "codeTag": "Java"
            },
            {
                "id": 1459896,
                "title": "java-o-n-time-o-1-space-with-examples",
                "content": "**Example:**\\n\\n```\\ninput = {1, 2, 3, 4, 5, 6, 7}\\nk = 3\\n\\n// Expected output\\noutput = {5, 6, 7, 1, 2, 3, 4}\\n\\n// Step 1: Reverse the entire array\\n{7, 6, 5, 4, 3, 2, 1}\\n// Step 2: Reverse 0 to k-1 elements\\n{5, 6, 7, 4, 3, 2, 1}\\n \\\\____/\\n// Step 3: Reverse from k to n-1 elements\\n{5, 6, 7, 1, 2, 3, 4}\\n           \\\\______/\\n```\\n\\n**Code:**\\n```java\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        if (k == 0) return; // Rotated array will be same as original array\\n        reverse(0, nums.length-1, nums);\\n        reverse(0, k-1, nums);\\n        reverse(k, nums.length-1, nums);\\n    }\\n    \\n    private void reverse(int start, int end, int[] nums){        \\n        while(start < end){\\n            int temp = nums[start];\\n            nums[start++] = nums[end];\\n            nums[end--] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ninput = {1, 2, 3, 4, 5, 6, 7}\\nk = 3\\n\\n// Expected output\\noutput = {5, 6, 7, 1, 2, 3, 4}\\n\\n// Step 1: Reverse the entire array\\n{7, 6, 5, 4, 3, 2, 1}\\n// Step 2: Reverse 0 to k-1 elements\\n{5, 6, 7, 4, 3, 2, 1}\\n \\\\____/\\n// Step 3: Reverse from k to n-1 elements\\n{5, 6, 7, 1, 2, 3, 4}\\n           \\\\______/\\n```\n```java\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        if (k == 0) return; // Rotated array will be same as original array\\n        reverse(0, nums.length-1, nums);\\n        reverse(0, k-1, nums);\\n        reverse(k, nums.length-1, nums);\\n    }\\n    \\n    private void reverse(int start, int end, int[] nums){        \\n        while(start < end){\\n            int temp = nums[start];\\n            nums[start++] = nums[end];\\n            nums[end--] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54353,
                "title": "straight-forward-python-code-use-slice",
                "content": "    class Solution:\\n    # @param nums, a list of integer\\n    # @param k, num of steps\\n    # @return nothing, please modify the nums list in-place.\\n    def rotate(self, nums, k):\\n        k %= len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param nums, a list of integer\\n    # @param k, num of steps\\n    # @return nothing, please modify the nums list in-place.\\n    def rotate(self, nums, k):\\n        k %= len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]",
                "codeTag": "Java"
            },
            {
                "id": 1729862,
                "title": "c-java-simple-and-clean-very-efficient-solutions",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    void reverse_range(vector<int>& nums, int i, int j) {\\n        while (i < j)\\n            swap(nums[i++], nums[j--]);\\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        if (nums.size() <= 1) return;\\n        \\n        reverse_range(nums, 0, nums.size()-1);\\n        reverse_range(nums, k, nums.size()-1);\\n        reverse_range(nums, 0, k-1);\\n    }\\n};\\n```\\n****\\n**Java:**\\n```\\nclass Solution {\\n    void reverse_range(int[] nums, int i, int j) {\\n        while (i < j) {\\n            int temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        if (nums.length <= 1) return;\\n        \\n        reverse_range(nums, 0, nums.length-1);\\n        reverse_range(nums, k, nums.length-1);\\n        reverse_range(nums, 0, k-1);\\n    }\\n}\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverse_range(vector<int>& nums, int i, int j) {\\n        while (i < j)\\n            swap(nums[i++], nums[j--]);\\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        if (nums.size() <= 1) return;\\n        \\n        reverse_range(nums, 0, nums.size()-1);\\n        reverse_range(nums, k, nums.size()-1);\\n        reverse_range(nums, 0, k-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void reverse_range(int[] nums, int i, int j) {\\n        while (i < j) {\\n            int temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        if (nums.length <= 1) return;\\n        \\n        reverse_range(nums, 0, nums.length-1);\\n        reverse_range(nums, k, nums.length-1);\\n        reverse_range(nums, 0, k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631131,
                "title": "javascript-simple-solution-3-lines",
                "content": "```\\nvar rotate = function (nums, k) {\\n  k %= nums.length;\\n  nums.unshift(...nums.splice(nums.length - k));\\n  return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function (nums, k) {\\n  k %= nums.length;\\n  nums.unshift(...nums.splice(nums.length - k));\\n  return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 895335,
                "title": "c-o-1-space-simple-and-easy-to-understand-o-n-time",
                "content": "Please ask in comments if you face any problem in undestanding.\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        reverse(nums.end()-k,nums.end()); //reverse nums[n-k] to nums[n-1]\\n        reverse(nums.begin(),nums.end()-k); //reverse nums[0] to nums[n-k-1]\\n        reverse(nums.begin(),nums.end());  //reverse complete array\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        reverse(nums.end()-k,nums.end()); //reverse nums[n-k] to nums[n-1]\\n        reverse(nums.begin(),nums.end()-k); //reverse nums[0] to nums[n-k-1]\\n        reverse(nums.begin(),nums.end());  //reverse complete array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54650,
                "title": "simple-c-solution-with-detail-explain-and-o-1-extra-space",
                "content": "     /**\\n     * this solution is so-called three times rotate method\\n     * because (X^TY^T)^T = YX, so we can perform rotate operation three times to get the result\\n     * obviously, the algorithm consumes O(1) space and O(n) time\\n     **/\\n    class Solution {\\n    public:\\n        void rotate(int nums[], int n, int k) {\\n            k %= n; // if k > n then the final result is the same as k%n\\n            reverseArray(nums, n-k, n-1);\\n            reverseArray(nums, 0, n-k-1);\\n            reverseArray(nums, 0, n-1);\\n            \\n        }\\n        /**\\n         * rotate the array nums from start to end\\n        **/\\n        void reverseArray(int nums[],int start, int end){\\n            while(start < end){\\n                int temp = nums[start];\\n                nums[start++] = nums[end];\\n                nums[end--] = temp;\\n                // or you can simply code as \"std::swap(nums[start++], nums[end--])\" to replace above three lines\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void rotate(int nums[], int n, int k) {\\n            k %= n; // if k > n then the final result is the same as k%n\\n            reverseArray(nums, n-k, n-1);\\n            reverseArray(nums, 0, n-k-1);\\n            reverseArray(nums, 0, n-1);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54520,
                "title": "java-solution-with-o-1-space",
                "content": "    public class Solution {\\n        public void rotate(int[] nums, int k) {\\n            if (nums == null || nums.length == 0) {\\n                return;\\n            }\\n            k = k % nums.length;\\n            reverse(nums, 0, nums.length-k-1);\\n            reverse(nums, nums.length-k, nums.length-1);\\n            reverse(nums, 0, nums.length-1);\\n        }\\n        private void reverse(int[] num, int left, int right) {\\n            while (left < right) {\\n                int t = num[left];\\n                num[left] = num[right];\\n                num[right] = t;\\n                left++;\\n                right--;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void rotate(int[] nums, int k) {\\n            if (nums == null || nums.length == 0) {\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3754681,
                "title": "c-o-n-swapping",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void reverse(vector<int> &a, int i, int j){\\n        while(i<j){\\n            swap(a[i],a[j]);\\n            i++, j--;\\n        }\\n    }\\n    \\n    void rotate(vector<int> &a, int k) {\\n        int n=a.size();   \\n        \\n        k%=n;\\n        if(k<0) k += n;\\n        \\n        reverse(a,0,n-1);\\n        reverse(a,0,k-1);\\n        reverse(a,k,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void reverse(vector<int> &a, int i, int j){\\n        while(i<j){\\n            swap(a[i],a[j]);\\n            i++, j--;\\n        }\\n    }\\n    \\n    void rotate(vector<int> &a, int k) {\\n        int n=a.size();   \\n        \\n        k%=n;\\n        if(k<0) k += n;\\n        \\n        reverse(a,0,n-1);\\n        reverse(a,0,k-1);\\n        reverse(a,k,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728190,
                "title": "brute-optimized-logic-explained-time-complexity-o-n",
                "content": "# Intuition\\nSuppose the question was to rotate right by one place,\\neg: [1,2,3,4,5]  k=1\\n    then we would have:\\n   1. stored the last element in some temporary variable .\\n   2. shifted all the elements to the right-->nums[i]=nums[i-1].\\n   3. finally,put the temporary variable in the first index -->nums[0]=temp.\\n\\nwe will the same logic to solve this problem\\n\\n# Approach\\n- observe carefully and try to compare the problem with the above one\\n- store the last \\'k\\' elements in some temporary array\\n- now start shifting the \\'n-k\\' elements to the end\\n- finally place the temporary array to the beginning \\'k\\' positions.\\n- it might be confusing at first but trying doing it in pen and paper \\n\\n           \\n\\n\\n# Complexity\\n- Time complexity:\\n  This solution takes linear time complexity ->O(n)\\n\\n- Space complexity:\\n  We are using an extra temp array , hence \\n  space complexity ->O(n) , where n is the size of the array\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n         int n=nums.size();\\n         k=k%n;\\n\\n        vector<int>temp(k);\\n   \\n        int i=0;\\n        for(int j=n-k;j<n;j++){  \\n            temp[i]=nums[j];  \\n            i++;\\n        }\\n\\n        i=n-1;  \\n        for(int j=n-k-1;j>=0;j--){\\n            nums[i]=nums[j];\\n            i--; \\n        }\\n        \\n       for(int j=0;j<=i;j++){    \\n           nums[j]=temp[j];      \\n                                  \\n        }\\n\\n    }\\n};\\n\\n<!-- DRY RUN\\n\\neg: [1,2,3,4,5,6,7]  ; k=3\\nj=4 (n-k) \\n\\ntemp=[5,6,7]\\n\\ni=6;\\n\\n[1,2,3,4,5,6,7]  \\n\\nnums[6]=nums[3]---->[1,2,3,4,5,6,4]\\nnums[5]=nums[2]---->[1,2,3,4,5,3,4]\\nnums[4]=nums[1]---->[1,2,3,4,2,3,4]\\nnums[3]=nums[0]---->[1,2,3,1,2,3,4]\\n\\n\\ni=2;   \\n\\nnums[0]=temp[0]---->[5,2,3,1,2,3,4]  \\nnums[1]=temp[1]---->[5,6,3,1,2,3,4] \\nnums[2]=temp[2]---->[5,6,7,1,2,3,4] \\n\\n\\n```\\n\\n# Without using extra space \\n- It is purely based on observation and if asked in any interview first tell the above solution. \\n- Reverse the complete array\\n- Then , reverse the first k elements.\\n- Finally , reverse the last n-k elements\\n- eg:  [1,2,3,4,5,6,7] k=3\\nI.   [7,6,5,4,3,2,1]\\nII.  [5,6,7,4,3,2,1]\\nIII. [5,6,7,1,2,3,4]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int l=nums.size();\\n        k%=l;\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());      \\n    }\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n         int n=nums.size();\\n         k=k%n;\\n\\n        vector<int>temp(k);\\n   \\n        int i=0;\\n        for(int j=n-k;j<n;j++){  \\n            temp[i]=nums[j];  \\n            i++;\\n        }\\n\\n        i=n-1;  \\n        for(int j=n-k-1;j>=0;j--){\\n            nums[i]=nums[j];\\n            i--; \\n        }\\n        \\n       for(int j=0;j<=i;j++){    \\n           nums[j]=temp[j];      \\n                                  \\n        }\\n\\n    }\\n};\\n\\n<!-- DRY RUN\\n\\neg: [1,2,3,4,5,6,7]  ; k=3\\nj=4 (n-k) \\n\\ntemp=[5,6,7]\\n\\ni=6;\\n\\n[1,2,3,4,5,6,7]  \\n\\nnums[6]=nums[3]---->[1,2,3,4,5,6,4]\\nnums[5]=nums[2]---->[1,2,3,4,5,3,4]\\nnums[4]=nums[1]---->[1,2,3,4,2,3,4]\\nnums[3]=nums[0]---->[1,2,3,1,2,3,4]\\n\\n\\ni=2;   \\n\\nnums[0]=temp[0]---->[5,2,3,1,2,3,4]  \\nnums[1]=temp[1]---->[5,6,3,1,2,3,4] \\nnums[2]=temp[2]---->[5,6,7,1,2,3,4] \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452201,
                "title": "95-solution-with-easiest-explanation",
                "content": "the first solution which usually come to our mind is remove the last item, then add it at first. like this: \\n\\n```\\nvar rotate = function(nums, k) {\\n\\tfor(let i = 0; i<k; i++){\\n\\t\\t nums.unshift(nums.pop());\\n\\t}\\n   \\n};\\n```\\nBut, it has some time issue.\\n\\nThe alternative solution is using remainder. if k is less then the length of nums array, then it will remove k elements from the end, and add those at first. but, if k is greater than the length of nums array, then only the remainder of k % nums.length will be removed from the last and those will be added at the first. As a example ; if k is 2 and nums.length is 3, then 2 element will be removed from the end and those will be add at the first. this will be same as if we rotate 2 times. \\n\\nbut, if length is 2 but k is 3, and if we then rotate the array 3 times in pen and paper, we will see that after final rotation the scene will be like - only 1 element removed from the end and added at first. here 1 is the remainder of k % nums.length. This will be the case everytime whenever k is greater than nums.length. So the final solution will be- \\n\\n\\n\\n```\\nvar rotate = function(nums, k) {\\n    return nums.unshift(...nums.splice(-k % nums.length));\\n};\\n```\\n\\nhere, by using splice we remove the element from the last, splice gives us an array output. thats why we using spread operator while we wanna unshift all element which we spliced from the end.",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function(nums, k) {\\n\\tfor(let i = 0; i<k; i++){\\n\\t\\t nums.unshift(nums.pop());\\n\\t}\\n   \\n};\\n```\n```\\nvar rotate = function(nums, k) {\\n    return nums.unshift(...nums.splice(-k % nums.length));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906033,
                "title": "using-simple-swapping-with-explanation-0ms-100-faster",
                "content": "Click UP ARROW if you like the solution.\\nCheck profile if you wanna connect on Twitter\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        fum(nums, 0, nums.length-1);     //rotating array in [7,6,5,4,3,2,1].\\n        fum(nums, 0, k-1);                   //rotating array in [5,6,7,4,3,2,1].\\n        fum(nums,k,nums.length-1);     //rotating array in [5,6,7,1,2,3,4].\\n    }\\n    private void fum(int[] nums, int left , int right){\\n        while(left< right){                              // while loop for checking the indexes.\\n            int temp = nums[left];                          \\n            nums[left] = nums[right];             // simple swapping between array elements.\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        fum(nums, 0, nums.length-1);     //rotating array in [7,6,5,4,3,2,1].\\n        fum(nums, 0, k-1);                   //rotating array in [5,6,7,4,3,2,1].\\n        fum(nums,k,nums.length-1);     //rotating array in [5,6,7,1,2,3,4].\\n    }\\n    private void fum(int[] nums, int left , int right){\\n        while(left< right){                              // while loop for checking the indexes.\\n            int temp = nums[left];                          \\n            nums[left] = nums[right];             // simple swapping between array elements.\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557491,
                "title": "c-solutions",
                "content": "**Approach 1: Reverse (preferred)**\\n**Intuition**\\nMove the last ```k``` numbers to the front, and first ```n-k``` numbers to the end. But relative order of the two parts won\\'t change.\\n\\n\\n![image](https://assets.leetcode.com/users/images/ca3ec7f3-6bfe-4c05-bf9a-aeeab79049ae_1631468229.9639452.png)\\n\\n**Complexity**\\n- time: O(n). Each number will be moved twice, O(2n) = O(n).\\n- space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public void Rotate(int[] nums, int k) {\\n        if(nums == null || nums.Length < 2)\\n            return;\\n        \\n        k %= nums.Length;        \\n        Reverse(nums, 0, nums.Length - 1);\\n        Reverse(nums, 0, k - 1);\\n        Reverse(nums, k, nums.Length - 1); \\n    }\\n    \\n    public void Reverse(int[] nums, int left, int right)\\n    {\\n        while(left < right)\\n        {\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\\n\\n</br></br></br>\\n**Approach 2: Extra Space**\\n**Intuition**\\nUse additional space to move ```nums[i]``` to ```arr[(i+k)%n]```\\n\\n**Complexity**\\n* Time: O(n)\\n* Space: O(n)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public void Rotate(int[] nums, int k) {\\n        \\n        if(nums == null || nums.Length == 0 || k == 0)\\n            return;\\n        \\n        int n = nums.Length;\\n        int[] tmp = new int[n];\\n        for(int i = 0; i < n; i++)\\n            tmp[(i + k) % n] = nums[i];\\n        \\n         for(int i = 0; i < n; i++)\\n             nums[i] = tmp[i];\\n        \\n        // nums = (int[])tmp.Clone(); fail\\n        // Array.Copy(tmp, 0, nums, 0, n); success\\n        // Array.Copy(tmp, nums, n);       success\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```k```\n```n-k```\n```\\npublic class Solution {\\n    public void Rotate(int[] nums, int k) {\\n        if(nums == null || nums.Length < 2)\\n            return;\\n        \\n        k %= nums.Length;        \\n        Reverse(nums, 0, nums.Length - 1);\\n        Reverse(nums, 0, k - 1);\\n        Reverse(nums, k, nums.Length - 1); \\n    }\\n    \\n    public void Reverse(int[] nums, int left, int right)\\n    {\\n        while(left < right)\\n        {\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\n```nums[i]```\n```arr[(i+k)%n]```\n```\\npublic class Solution {\\n    public void Rotate(int[] nums, int k) {\\n        \\n        if(nums == null || nums.Length == 0 || k == 0)\\n            return;\\n        \\n        int n = nums.Length;\\n        int[] tmp = new int[n];\\n        for(int i = 0; i < n; i++)\\n            tmp[(i + k) % n] = nums[i];\\n        \\n         for(int i = 0; i < n; i++)\\n             nums[i] = tmp[i];\\n        \\n        // nums = (int[])tmp.Clone(); fail\\n        // Array.Copy(tmp, 0, nums, 0, n); success\\n        // Array.Copy(tmp, nums, n);       success\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54659,
                "title": "one-concise-solution-with-constant-space-o-n-time-java",
                "content": "    public class Solution {\\n        public void rotate(int[] nums, int k) {\\n            int n = nums.length;\\n            k %= n;\\n            reverse(nums, 0, n);\\n            reverse(nums, 0, k);\\n            reverse(nums, k, n);\\n        }\\n        \\n        private void reverse(int[] nums, int s, int e) {\\n            while (s < --e) {\\n                int temp = nums[s];\\n                nums[s] = nums[e];\\n                nums[e] = temp;\\n                ++s;\\n            }\\n        }\\n    }\\n\\nAny suggestions? Thanks.",
                "solutionTags": [],
                "code": "class Solution {\\n        public void rotate(int[] nums, int k) {\\n            int n = nums.length;\\n            k %= n;\\n            reverse(nums, 0, n);\\n            reverse(nums, 0, k);\\n            reverse(nums, k, n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3184255,
                "title": "the-use-of-simple-swapping-with-an-explanation-0ms-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDivide the array into two parts, one ranging from 0 to n-k-1 and the other ranging from n-k to n-1. Afterward, reverse the first and second parts of the array and finally reverse the entire array to obtain the result\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        flip(nums,0,n-k-1);\\n        flip(nums,n-k,n-1);\\n        flip(nums,0,n-1);\\n        \\n    }\\n    public void flip(int[] arr,int s,int e)\\n    {\\n        while(s<e)\\n        {\\n            int temp=arr[s];\\n            arr[s]=arr[e];\\n            arr[e]=temp;\\n            s++;\\n            e--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        flip(nums,0,n-k-1);\\n        flip(nums,n-k,n-1);\\n        flip(nums,0,n-1);\\n        \\n    }\\n    public void flip(int[] arr,int s,int e)\\n    {\\n        while(s<e)\\n        {\\n            int temp=arr[s];\\n            arr[s]=arr[e];\\n            arr[e]=temp;\\n            s++;\\n            e--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064276,
                "title": "c-o-n-easy-solution-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n ## Swaping number in array basically. please voteup \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\t \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. some people might be thinking why i am using k=k%n when k>n because there are only two possibility first is when k is divisible by \\'n\\' than no need to change-.. if it\\'s not divisible than k%n time we have to run the loop.\\n2. first you make a vector to copy the given array because if we changing  in array will affect the value of given array.That why we have to make a copy of given array.\\n3. second start changing in array nums[i]value to last \"num[n-k+i]--> which is 5 when i=0,6 -->i=1,...\".run it only  k time.for shifting of array last to first\\n4. Third loop will change remain position of array nuumber.basically for shifting of array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int>v;// making vector for copy the array in vector.\\n        int n=nums.size();\\n        if(k>nums.size()){\\n           k=k%n;// check k>n and than check it is divisible by n or not.\\n       }\\n        for(int i=0;i<n;i++){\\n           v.push_back(nums[i]);// puting nums value to vector..\\n        }\\n       for(int i=0;i<k;i++){\\n           nums[i]=v[n-k+i];// puting value of vector into nums..i explained it above..\\n        }\\n        for(int i=0;i<n-k;i++){ \\n            nums[k+i]=v[i];// here we will changing  all value (n-k time)of nums array after runing k time. for shifting of array.\\n        }\\n      return ;\\n    }\\n};// ;)plzz like bro..................................>>>>>>>>>>>>>>\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int>v;// making vector for copy the array in vector.\\n        int n=nums.size();\\n        if(k>nums.size()){\\n           k=k%n;// check k>n and than check it is divisible by n or not.\\n       }\\n        for(int i=0;i<n;i++){\\n           v.push_back(nums[i]);// puting nums value to vector..\\n        }\\n       for(int i=0;i<k;i++){\\n           nums[i]=v[n-k+i];// puting value of vector into nums..i explained it above..\\n        }\\n        for(int i=0;i<n-k;i++){ \\n            nums[k+i]=v[i];// here we will changing  all value (n-k time)of nums array after runing k time. for shifting of array.\\n        }\\n      return ;\\n    }\\n};// ;)plzz like bro..................................>>>>>>>>>>>>>>\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937407,
                "title": "typescript-one-line-solution",
                "content": "```typescript\\nfunction rotate(nums: number[], k: number): void {\\n  nums.unshift(...nums.splice(-(k % nums.length)));\\n};\\n```\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction rotate(nums: number[], k: number): void {\\n  nums.unshift(...nums.splice(-(k % nums.length)));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729976,
                "title": "c-o-n-gcd",
                "content": "# 1. Observation of how gcd(n,k) cases related to array rotation.\\nFrom the following observation ,  we know that rorate can seperate into gcd(n,k) cases.\\nJust let me say that we can process in different rows. \\n```\\n    //[0,1,2,3,4,5,6] steps 3\\u3000gcd(7,3) = 1\\n    //0,3,6,2,5,1,4,\\n    \\n    //[0,1,2,3,4,5,6,7] steps 4  gcd(8,4)=4\\n    //0,4,\\n    //1,5,\\n    //2,6,\\n    //3,7,\\n    \\n    //[0,1,2,3,4,5,6,7] steps 2  gcd(8,2) = 2\\n    //0,2,4,6,\\n    //1,3,5,7,\\n    \\n    //[0,1,2,3,4,5,6,7,8,9,10,11] step 3   gcd(12,3) = 3\\n    //0,3,6,9,\\n    //1,4,7,10,\\n    //2,5,8,11,\\n```\\n\\nFor each row, we can process its rorated move. \\nFor example\\n```\\n    [0,1,2,3,4,5,6,7,8,9,10,11] step 3   gcd(12,3) = 3\\n    //0,3,6,9,  -> 9,0,3,6  \\\\\\n    //1,4,7,10  ->10,1 4,7   -=> [9,10,11,0,1,2,3,4,5,6,7,8]\\t\\n    //2,5,8,11 -> 11,2,5,8  / \\n```\\n\\n# 2. rotate array by two temp variable.\\nAnother tool is the way to make rorate move. \\nMy idea of rorated move is by using two temp values. \\nFor example of rorated move from  A={2,5,8,11} to A={11,2,5,8}. \\nI the following explantation, I use notation A\\'[0] to mean original A[0]. \\nSo whatever A have been changed, It\\'s still that A\\'[0] =2, A\\'[1]=5. A\\'[2]=8. A\\'[3]=11\\nThe following is showing how two temp variable can make help rorated move. \\n```  \\nprev_temp=NA\\ntemp=2\\nA is {2,5, 8,11}\\n```\\n```\\nprev_temp=2 //(A\\'[0])\\ntemp=5  //(A\\'[1])\\nA[1] = 2 ->  A is {2,2,8,11}\\n```\\n```\\nprev_temp=5 //(A\\'[1])\\ntemp=8  //(A\\'[2])      \\nA[2] = 5 ->  A is {2,2,5,11}\\n```\\n```\\nprev_temp=8 //(A\\'[2])      \\ntemp=11 //(A\\'[3])      \\nA[3] = 8 ->  A is {2,2,5,8}\\n```\\n```\\nprev_temp=11 //(A\\'[3])      \\ntemp=2 //(A\\'[0])      \\nA[0] = 11 ->  A is {11,2,5,8}\\n```\\n\\n\\n# 3. outcome of solution\\nFrom the observation to seperate row and the idea of rorated move by two temp variable, \\nwe can implment the following solution.\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int rows = gcd(n, k);\\n        for(int i = 0; i < rows; i++) {\\n\\t\\t\\t//seperate into gcd(n,k) rows cases\\n            int temp = nums[i];\\n            int curr_idx = i;                \\n            for(int j = 0 ; j < n / rows; j++) {\\n\\t\\t\\t\\t//Make a rorated move for each row by two temp\\n                int next_idx = (curr_idx + k) % n;\\n                int prev_temp = temp;\\n                temp = nums[next_idx];\\n                nums[next_idx] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        }   \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    //[0,1,2,3,4,5,6] steps 3\\u3000gcd(7,3) = 1\\n    //0,3,6,2,5,1,4,\\n    \\n    //[0,1,2,3,4,5,6,7] steps 4  gcd(8,4)=4\\n    //0,4,\\n    //1,5,\\n    //2,6,\\n    //3,7,\\n    \\n    //[0,1,2,3,4,5,6,7] steps 2  gcd(8,2) = 2\\n    //0,2,4,6,\\n    //1,3,5,7,\\n    \\n    //[0,1,2,3,4,5,6,7,8,9,10,11] step 3   gcd(12,3) = 3\\n    //0,3,6,9,\\n    //1,4,7,10,\\n    //2,5,8,11,\\n```\n```\\n    [0,1,2,3,4,5,6,7,8,9,10,11] step 3   gcd(12,3) = 3\\n    //0,3,6,9,  -> 9,0,3,6  \\\\\\n    //1,4,7,10  ->10,1 4,7   -=> [9,10,11,0,1,2,3,4,5,6,7,8]\\t\\n    //2,5,8,11 -> 11,2,5,8  / \\n```\n```  \\nprev_temp=NA\\ntemp=2\\nA is {2,5, 8,11}\\n```\n```\\nprev_temp=2 //(A\\'[0])\\ntemp=5  //(A\\'[1])\\nA[1] = 2 ->  A is {2,2,8,11}\\n```\n```\\nprev_temp=5 //(A\\'[1])\\ntemp=8  //(A\\'[2])      \\nA[2] = 5 ->  A is {2,2,5,11}\\n```\n```\\nprev_temp=8 //(A\\'[2])      \\ntemp=11 //(A\\'[3])      \\nA[3] = 8 ->  A is {2,2,5,8}\\n```\n```\\nprev_temp=11 //(A\\'[3])      \\ntemp=2 //(A\\'[0])      \\nA[0] = 11 ->  A is {11,2,5,8}\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int rows = gcd(n, k);\\n        for(int i = 0; i < rows; i++) {\\n\\t\\t\\t//seperate into gcd(n,k) rows cases\\n            int temp = nums[i];\\n            int curr_idx = i;                \\n            for(int j = 0 ; j < n / rows; j++) {\\n\\t\\t\\t\\t//Make a rorated move for each row by two temp\\n                int next_idx = (curr_idx + k) % n;\\n                int prev_temp = temp;\\n                temp = nums[next_idx];\\n                nums[next_idx] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        }   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54564,
                "title": "python-easy-to-understand-solutions",
                "content": "        \\n    def rotate1(self, nums, k):\\n        k %= len(nums)\\n        self.reverse(nums, 0, len(nums)-1)\\n        self.reverse(nums, 0, k-1)\\n        self.reverse(nums, k, len(nums)-1)\\n        \\n    def reverse(self, nums, l, r):\\n        while l < r:\\n            nums[l], nums[r] = nums[r], nums[l]\\n            l += 1\\n            r -= 1\\n            \\n    def rotate2(self, nums, k):\\n        k %= len(nums)\\n        for _ in xrange(k):\\n            nums.insert(0, nums.pop())\\n     \\n    # O(n) space       \\n    def rotate(self, nums, k):\\n        deque = collections.deque(nums)\\n        k %= len(nums)\\n        for _ in xrange(k):\\n            deque.appendleft(deque.pop())\\n        nums[:] = list(deque)",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def rotate1(self, nums, k):\\n        k %= len(nums)\\n        self.reverse(nums, 0, len(nums)-1)\\n        self.reverse(nums, 0, k-1)\\n        self.reverse(nums, k, len(nums)-1)\\n        \\n    def reverse(self, nums, l, r):\\n        while l < r:\\n            nums[l], nums[r] = nums[r], nums[l]\\n            l += 1\\n            r -= 1\\n            \\n    def rotate2(self, nums, k):\\n        k %= len(nums)\\n        for _ in xrange(k):\\n            nums.insert(0, nums.pop())\\n     \\n    # O(n) space       \\n    def rotate(self, nums, k):\\n        deque = collections.deque(nums)\\n        k %= len(nums)\\n        for _ in xrange(k):\\n            deque.appendleft(deque.pop())\\n        nums[:] = list(deque)",
                "codeTag": "Python3"
            },
            {
                "id": 54602,
                "title": "accepted-java-solution-with-o-1-space-and-o-n-time",
                "content": "  \\n\\n    public void rotate(int[] nums, int k) {\\n         \\n        if (k >nums.length){\\n            k = k%nums.length;\\n         }\\n        int end = nums.length;\\n        \\n        nums = reverse(nums,0,end-k-1);\\n        nums = reverse(nums,end-k,end-1);\\n        nums = reverse(nums,0,end-1);\\n     }\\n        \\n        private int[] reverse(int[] nums, int start, int end){\\n           \\n           while(start<end){\\n           int temp = nums[start];\\n           nums[start] = nums[end];\\n           nums[end] = temp;\\n           start++; end--;\\n           }\\n           return nums;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "  \\n\\n    public void rotate(int[] nums, int k) {\\n         \\n        if (k >nums.length){\\n            k = k%nums.length;\\n         }\\n        int end = nums.length;\\n        \\n        nums = reverse(nums,0,end-k-1);\\n        nums = reverse(nums,end-k,end-1);\\n        nums = reverse(nums,0,end-1);\\n     }\\n        \\n        private int[] reverse(int[] nums, int start, int end){\\n           \\n           while(start<end){\\n           int temp = nums[start];\\n           nums[start] = nums[end];\\n           nums[end] = temp;\\n           start++; end--;\\n           }\\n           return nums;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3826786,
                "title": "1-line-in-c-optimized-solution-using-inbuilt-function",
                "content": "# Intuition\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    k= k%nums.size();\\n    std::rotate(nums.begin(), nums.begin()+nums.size()-k, nums.end());  \\n    }\\n};\\n```\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![upvote1.gif](https://assets.leetcode.com/users/images/73a3f1a5-c0ba-4c88-9276-144642d7fc29_1690519094.3517249.gif)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    k= k%nums.size();\\n    std::rotate(nums.begin(), nums.begin()+nums.size()-k, nums.end());  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758175,
                "title": "java-0ms-100-faster-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n       k %= nums.length;\\n       reverse(nums, 0, nums.length - 1); // Reverse the entire array\\n       reverse(nums, 0, k - 1); // Reverse the first k elements\\n       reverse(nums, k, nums.length - 1); // Reverse the rest of the elements\\n    }\\n    public static void reverse(int[] nums, int start, int end) {\\n        while(start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start ++;\\n            end --;\\n        }\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n       k %= nums.length;\\n       reverse(nums, 0, nums.length - 1); // Reverse the entire array\\n       reverse(nums, 0, k - 1); // Reverse the first k elements\\n       reverse(nums, k, nums.length - 1); // Reverse the rest of the elements\\n    }\\n    public static void reverse(int[] nums, int start, int end) {\\n        while(start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start ++;\\n            end --;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186609,
                "title": "python-clean-simple-o-n-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Here we are reversing array 3 times. \\n1. from the start to the n - k - 1 index \\n2. from n - k to end of the array\\n3. Reversing whole array\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, arr: List[int], k: int) -> None:\\n        n = len(arr)\\n        k = k % n                 \\n# Here reminder is taken because if we had 10 rotation but our array is of size 9 then only 1 rotation is effective to produce ans.\\n\\n        arr[n - k:] = arr[n - k:][::-1] # Reverse n - k to end of the array \\n        arr[:n - k] = arr[:n - k][::-1] # Reverse 0 to n - k  \\n        arr[:] = arr[::-1]              # Reverse whole array\\n\\n```\\nWe can do above 3 steps in 1 step using python list slicing\\n\\n```\\narr[:] = arr[n - k:] + arr[:n - k]\\n```\\n\\nCan\\'t be written as \\n\\n```\\narr = arr[n - k:] + arr[:n - k]\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, arr: List[int], k: int) -> None:\\n        n = len(arr)\\n        k = k % n                 \\n# Here reminder is taken because if we had 10 rotation but our array is of size 9 then only 1 rotation is effective to produce ans.\\n\\n        arr[n - k:] = arr[n - k:][::-1] # Reverse n - k to end of the array \\n        arr[:n - k] = arr[:n - k][::-1] # Reverse 0 to n - k  \\n        arr[:] = arr[::-1]              # Reverse whole array\\n\\n```\n```\\narr[:] = arr[n - k:] + arr[:n - k]\\n```\n```\\narr = arr[n - k:] + arr[:n - k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668087,
                "title": "c-4-different-solutions-highly-commented-and-explained",
                "content": "```\\n/*\\n* o(n)\\n* This solution is simply reversing the array and the reversing array from 0 to k-1 and then from k to n-1. \\n* Do a dry run by taking an example on copy and you will usndersand it. \\n*/\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k%nums.size());\\n        reverse(nums.begin()+k%nums.size(),nums.begin()+nums.size());\\n    }\\n};\\n\\n// o(n) Same as above but without using inbuilt function.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        reverse(nums.begin(),nums.end());\\n        int i=0,j=k-1;\\n        while(i<j) swap(nums[i++],nums[j--]);\\n        i=k,j=nums.size()-1;\\n        while(i<j) swap(nums[i++],nums[j--]);\\n    }\\n};\\n\\n/*\\n* o(n) \\n* Using extra space approach we simply store the last k elemets in same order from n-k to n-1 in a temp vector and \\n* we then pushback the reaining elements in the temp vector from index 0 to n-k-1; \\n*/\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        vector<int> temp;\\n        int n = nums.size() - k;\\n        for(int i=n ; i<nums.size();i++)temp.push_back(nums[i]);\\n        for(int i=0;i<n;i++) temp.push_back(nums[i]);\\n        nums = temp;\\n\\n    }\\n};\\n\\n// o(n*k) we roatate elements of the vector one by one for k times and achieve k roatations.\\n// TLE\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k){\\n        int i, j, tmp,n = nums.size();\\n        k%=n;\\n        if (n==k) return;\\n        for(i=n-1; i>=n-k; i--) {\\n            tmp = nums[n-1];\\n            for (j=n-1;j>0;j--)nums[j] = nums[j-1];\\n            nums[0] = tmp;\\n        }   \\n    }\\n};\\n```\\n\\n***Do upvote if you like my solutions & explanation :)***\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n/*\\n* o(n)\\n* This solution is simply reversing the array and the reversing array from 0 to k-1 and then from k to n-1. \\n* Do a dry run by taking an example on copy and you will usndersand it. \\n*/\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k%nums.size());\\n        reverse(nums.begin()+k%nums.size(),nums.begin()+nums.size());\\n    }\\n};\\n\\n// o(n) Same as above but without using inbuilt function.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        reverse(nums.begin(),nums.end());\\n        int i=0,j=k-1;\\n        while(i<j) swap(nums[i++],nums[j--]);\\n        i=k,j=nums.size()-1;\\n        while(i<j) swap(nums[i++],nums[j--]);\\n    }\\n};\\n\\n/*\\n* o(n) \\n* Using extra space approach we simply store the last k elemets in same order from n-k to n-1 in a temp vector and \\n* we then pushback the reaining elements in the temp vector from index 0 to n-k-1; \\n*/\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        vector<int> temp;\\n        int n = nums.size() - k;\\n        for(int i=n ; i<nums.size();i++)temp.push_back(nums[i]);\\n        for(int i=0;i<n;i++) temp.push_back(nums[i]);\\n        nums = temp;\\n\\n    }\\n};\\n\\n// o(n*k) we roatate elements of the vector one by one for k times and achieve k roatations.\\n// TLE\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k){\\n        int i, j, tmp,n = nums.size();\\n        k%=n;\\n        if (n==k) return;\\n        for(i=n-1; i>=n-k; i--) {\\n            tmp = nums[n-1];\\n            for (j=n-1;j>0;j--)nums[j] = nums[j-1];\\n            nums[0] = tmp;\\n        }   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917709,
                "title": "c-o-1-space-o-n-time",
                "content": "Step 1: reverse the whole array.\\nStep 2: reverse the elements from starting of the array till the kth element.\\nStep 3: reverse the elements from the kth element till the end of the array.\\n\\nFor example:\\nlet the array be arr = [1,2,3,4,5] and k = 2\\ntherefore the result  array should be arr = [4,5,1,2,3]\\n\\nStep 1: reverse the whole array\\narr = [5,4,3,2,1]\\nStep 2: reverse from 0 to k\\narr = [4,5,3,2,1]\\nStep 3: reverse from k to n\\narr = [4,5,1,2,3]\\n\\n```class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        \\n\\t\\t//remove redundant k values  and shorten k\\n        k = k % nums.size();\\n        \\n\\t\\t//reverse the array from starting to end\\n        reverse(nums.begin(), nums.end());\\n\\t\\t\\n\\t\\t//reverse from starting till kth element\\n        reverse(nums.begin(), nums.begin()+k);\\n\\t\\t\\n\\t\\t//reverse from kth till last element\\n        reverse(nums.begin()+k, nums.end());\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        \\n\\t\\t//remove redundant k values  and shorten k\\n        k = k % nums.size();\\n        \\n\\t\\t//reverse the array from starting to end\\n        reverse(nums.begin(), nums.end());\\n\\t\\t\\n\\t\\t//reverse from starting till kth element\\n        reverse(nums.begin(), nums.begin()+k);\\n\\t\\t\\n\\t\\t//reverse from kth till last element\\n        reverse(nums.begin()+k, nums.end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817326,
                "title": "java-explained-time-o-n-space-o-1-runtime-0-ms-100-faster",
                "content": "# **Please upvote if you like the solution**\\n\\n```\\nclass Solution {\\n    \\n  /***\\n     * To do the in place rotation i.e. with O(1) space complexity we need to follow the below steps\\n     *\\n     * Step-1 : Divide the Array into two part and the division should be from right side / end.\\n     *          like for arr = [1, 2, 3, 4, 5]  and k = 2 we need to divide the array into two part\\n     *          arr = [1, 2, 3   ##   4, 5]   (k position from right)\\n     *          i.e. Part-1 : [1, 2. 3]  part-2 : [4, 5]\\n     *\\n     *  Step-2 : Reverse the above part individually, so post reversal it should be something like below\\n     *           arr = [3, 2, 1   ##   5, 4]\\n     *\\n     *  Step-3 : Now reverse the whole array, so post reversal it should be something like below\\n     *           arr = [4, 5, 1, 2, 3]  which is the intended output\\n     */\\n    public void rotate(int[] nums, int k) {\\n\\n        /**\\n         *\\n         * For a given array of length N if we will rotate it N times the initial and final array will be same\\n         * like for arr = [1, 2, 3, 4, 5]\\n         * Rotate-1 :  [5, 1, 2, 3, 4]  -> Rotate-2 :  [4, 5, 1, 2, 3]   ...   Rotate-5 :  [1, 2, 3, 4, 5]\\n         *\\n         * So, If k is greater than length of the array, then we can say (k % nums.length) value time rotation state will\\n         * be the final state of the array.\\n         */\\n        if (k > nums.length) {\\n            k = k % nums.length;\\n        }\\n\\n        /**\\n         *   As per the problem statement below check is not required as value of k is 0 <= k <= 105\\n         *\\n         *   Constraints:\\n         *      1 <= nums.length <= 105\\n         *      -231 <= nums[i] <= 231 - 1\\n         *      0 <= k <= 105\\n         */\\n\\n\\n        /***\\n         * If value of k is negative and for all -ve value it should rotate left wise\\n         * Like arr = [1, 2, 3, 4, 5]  and k = -1 the final array should be arr : [2, 3, 4, 5, 1]\\n         *\\n         * Now to handle this kind of -ve cases, lets analyze the rotation\\n         *          arr = [1, 2, 3, 4, 5]\\n         *\\n         *  Rotation  -2 :  [3, 4, 5, 1, 2]   ###\\n         *  Rotation  -1 :  [2, 3, 4, 5, 1]      ****\\n         *  Rotation  0  :  [1, 2, 3, 4, 5]\\n         *  Rotation  1  :  [5, 1, 2, 3, 4]\\n         *  Rotation  2  :  [4, 5, 1, 2, 3]\\n         *  Rotation  3  :  [3, 4, 5, 1, 2]   ###\\n         *  Rotation  4  :  [2, 3, 4, 5, 1]     ****\\n         *  Rotation  5  :  [1, 2, 3, 4, 5]\\n         *\\n         *  Now if we will see Rotation for -1 and 4 is same or -2 and 3 is also same.\\n         *  So, we can say -k rotation is equivalent to -k + array length position\\n         */\\n//        if (k < 0) {\\n//            k = k + nums.length;\\n//        }\\n\\n\\n        // Step-1 : Divide the Array into two part\\n        int numsLength = nums.length - 1;\\n        int dividePosition = numsLength - k;\\n\\n        //Step-2 : Reverse the above part individually\\n        reverse(0, dividePosition, nums);\\n        reverse(dividePosition + 1, numsLength, nums);\\n\\n        //Step-3 : Now reverse the whole array\\n        reverse(0, numsLength, nums);\\n    }\\n\\n    private void reverse(int start, int end, int[] nums) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n  /***\\n     * To do the in place rotation i.e. with O(1) space complexity we need to follow the below steps\\n     *\\n     * Step-1 : Divide the Array into two part and the division should be from right side / end.\\n     *          like for arr = [1, 2, 3, 4, 5]  and k = 2 we need to divide the array into two part\\n     *          arr = [1, 2, 3   ##   4, 5]   (k position from right)\\n     *          i.e. Part-1 : [1, 2. 3]  part-2 : [4, 5]\\n     *\\n     *  Step-2 : Reverse the above part individually, so post reversal it should be something like below\\n     *           arr = [3, 2, 1   ##   5, 4]\\n     *\\n     *  Step-3 : Now reverse the whole array, so post reversal it should be something like below\\n     *           arr = [4, 5, 1, 2, 3]  which is the intended output\\n     */\\n    public void rotate(int[] nums, int k) {\\n\\n        /**\\n         *\\n         * For a given array of length N if we will rotate it N times the initial and final array will be same\\n         * like for arr = [1, 2, 3, 4, 5]\\n         * Rotate-1 :  [5, 1, 2, 3, 4]  -> Rotate-2 :  [4, 5, 1, 2, 3]   ...   Rotate-5 :  [1, 2, 3, 4, 5]\\n         *\\n         * So, If k is greater than length of the array, then we can say (k % nums.length) value time rotation state will\\n         * be the final state of the array.\\n         */\\n        if (k > nums.length) {\\n            k = k % nums.length;\\n        }\\n\\n        /**\\n         *   As per the problem statement below check is not required as value of k is 0 <= k <= 105\\n         *\\n         *   Constraints:\\n         *      1 <= nums.length <= 105\\n         *      -231 <= nums[i] <= 231 - 1\\n         *      0 <= k <= 105\\n         */\\n\\n\\n        /***\\n         * If value of k is negative and for all -ve value it should rotate left wise\\n         * Like arr = [1, 2, 3, 4, 5]  and k = -1 the final array should be arr : [2, 3, 4, 5, 1]\\n         *\\n         * Now to handle this kind of -ve cases, lets analyze the rotation\\n         *          arr = [1, 2, 3, 4, 5]\\n         *\\n         *  Rotation  -2 :  [3, 4, 5, 1, 2]   ###\\n         *  Rotation  -1 :  [2, 3, 4, 5, 1]      ****\\n         *  Rotation  0  :  [1, 2, 3, 4, 5]\\n         *  Rotation  1  :  [5, 1, 2, 3, 4]\\n         *  Rotation  2  :  [4, 5, 1, 2, 3]\\n         *  Rotation  3  :  [3, 4, 5, 1, 2]   ###\\n         *  Rotation  4  :  [2, 3, 4, 5, 1]     ****\\n         *  Rotation  5  :  [1, 2, 3, 4, 5]\\n         *\\n         *  Now if we will see Rotation for -1 and 4 is same or -2 and 3 is also same.\\n         *  So, we can say -k rotation is equivalent to -k + array length position\\n         */\\n//        if (k < 0) {\\n//            k = k + nums.length;\\n//        }\\n\\n\\n        // Step-1 : Divide the Array into two part\\n        int numsLength = nums.length - 1;\\n        int dividePosition = numsLength - k;\\n\\n        //Step-2 : Reverse the above part individually\\n        reverse(0, dividePosition, nums);\\n        reverse(dividePosition + 1, numsLength, nums);\\n\\n        //Step-3 : Now reverse the whole array\\n        reverse(0, numsLength, nums);\\n    }\\n\\n    private void reverse(int start, int end, int[] nums) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683382,
                "title": "c-o-1-space-and-o-n-time-3-step-solution",
                "content": "Let n = size of array\\n\\n3 step solution:\\n- Reverse 1st half of array i.e 0 to n-k-1\\n- Reverse 2nd half of array i.e n-k to n-1\\n- Then reverse full array i.e 0 to n-k\\n\\nAfter 3rd step we\\'ll get our rotated array\\n\\n![image](https://assets.leetcode.com/users/images/36bc86e5-10a3-411c-afd5-495cc80caebb_1641922898.1235006.png)\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k - (k/nums.size())*nums.size();\\n        reverse(nums, 0,nums.size()-k-1);\\n        reverse(nums, nums.size()-k ,nums.size()-1);\\n        reverse(nums,0,nums.size()-1);\\n    }\\n    void reverse(vector<int>& nums, int low, int high)\\n    {\\n        while(low<high)\\n        {\\n            swap(nums[low],nums[high]);\\n            low++;\\n            high--;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k - (k/nums.size())*nums.size();\\n        reverse(nums, 0,nums.size()-k-1);\\n        reverse(nums, nums.size()-k ,nums.size()-1);\\n        reverse(nums,0,nums.size()-1);\\n    }\\n    void reverse(vector<int>& nums, int low, int high)\\n    {\\n        while(low<high)\\n        {\\n            swap(nums[low],nums[high]);\\n            low++;\\n            high--;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1468248,
                "title": "python-simple-but-optimal-solution-o-n-time-and-o-1-space",
                "content": "The idea is to first reverse the whole array, then reverse the first `k` elements and then reverse the last `n-k` elements. You end up with the rotated array. As reversing an array in-place is easily possible in linear time and constant space, the overall solution also just uses O(n) time and O(1) space. Here is the code:\\n\\n```\\ndef reverse_inplace(nums, lo, hi):\\n    while lo < hi:\\n        nums[lo], nums[hi] = nums[hi], nums[lo]\\n        lo += 1\\n        hi -= 1\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)\\n        reverse_inplace(nums, 0, len(nums) - 1)\\n        reverse_inplace(nums, 0, k - 1)\\n        reverse_inplace(nums, k, len(nums) - 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef reverse_inplace(nums, lo, hi):\\n    while lo < hi:\\n        nums[lo], nums[hi] = nums[hi], nums[lo]\\n        lo += 1\\n        hi -= 1\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)\\n        reverse_inplace(nums, 0, len(nums) - 1)\\n        reverse_inplace(nums, 0, k - 1)\\n        reverse_inplace(nums, k, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377847,
                "title": "python-multiple-solutions",
                "content": "# List slicing\\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```\\n\\n# Temp list of size k\\n\\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        tmp = nums[-k:]\\n        for idx in reversed(range(k, len(nums))):\\n            nums[idx] = nums[idx-k]\\n            \\n        for idx, num in enumerate(tmp):\\n            nums[idx] = num\\n```\\n\\n# Cyclic Replacement\\n\\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        count = 0\\n        start = 0\\n        while count < len(nums):\\n            current = start\\n            prev = nums[start]\\n            while True:\\n                next = (current + k) % len(nums)\\n                temp = nums[next]\\n                nums[next] = prev\\n                prev = temp\\n                current = next\\n                count += 1\\n                if current == start:\\n                    break\\n            start += 1\\n```\\n\\n# List reversal\\n\\n```python\\nclass Solution:\\n    \\n    def reverse(self, nums, start, end):\\n        while (start < end):\\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n            \\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        self.reverse(nums, 0, len(nums) - 1)\\n        self.reverse(nums, 0, k - 1)\\n        self.reverse(nums, k, len(nums) - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        tmp = nums[-k:]\\n        for idx in reversed(range(k, len(nums))):\\n            nums[idx] = nums[idx-k]\\n            \\n        for idx, num in enumerate(tmp):\\n            nums[idx] = num\\n```\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        count = 0\\n        start = 0\\n        while count < len(nums):\\n            current = start\\n            prev = nums[start]\\n            while True:\\n                next = (current + k) % len(nums)\\n                temp = nums[next]\\n                nums[next] = prev\\n                prev = temp\\n                current = next\\n                count += 1\\n                if current == start:\\n                    break\\n            start += 1\\n```\n```python\\nclass Solution:\\n    \\n    def reverse(self, nums, start, end):\\n        while (start < end):\\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n            \\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        self.reverse(nums, 0, len(nums) - 1)\\n        self.reverse(nums, 0, k - 1)\\n        self.reverse(nums, k, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253052,
                "title": "c-solution",
                "content": "Runtime: 256 ms, faster than 93.03% of C# online submissions for Rotate Array.\\nMemory Usage: 30.6 MB, less than 10.00% of C# online submissions for Rotate Array.\\n\\n```\\npublic class Solution {\\n    public void Rotate(int[] nums, int k) {       \\n        // Solution 1 -- Time: O(n), Space: O(n)\\n        int[] output = new int[nums.Length];\\n        int length = nums.Length;\\n        for(int i=0; i<nums.Length; i++) {\\n            output[(i+k) % length] = nums[i];\\n        }\\n        for(int i=0; i<nums.Length; i++) {\\n            nums[i] = output[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public void Rotate(int[] nums, int k) {       \\n        // Solution 1 -- Time: O(n), Space: O(n)\\n        int[] output = new int[nums.Length];\\n        int length = nums.Length;\\n        for(int i=0; i<nums.Length; i++) {\\n            output[(i+k) % length] = nums[i];\\n        }\\n        for(int i=0; i<nums.Length; i++) {\\n            nums[i] = output[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54529,
                "title": "5-lines-c-using-reverse",
                "content": "        \\n    \\n       void rotate(vector<int>& nums, int k) {\\n            k%=nums.size();\\n            if(k==0 || nums.size()==0) return;\\n            reverse(nums.begin(), nums.end());\\n            reverse(nums.begin(), nums.begin()+k);\\n            reverse(nums.begin()+k, nums.end());\\n        }",
                "solutionTags": [],
                "code": "        \\n    \\n       void rotate(vector<int>& nums, int k) {\\n            k%=nums.size();\\n            if(k==0 || nums.size()==0) return;\\n            reverse(nums.begin(), nums.end());\\n            reverse(nums.begin(), nums.begin()+k);\\n            reverse(nums.begin()+k, nums.end());\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3529657,
                "title": "a-different-way-of-thinking-c-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf an array consisting of `n` elements if to right-rotated by `k` positions, we can reverse the array from the beginning till the `(n-k)`th index, then again from the `(n-k)`th index to the end and finally, from the beginning to the end. This will yield the same result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAssign to `k` the mod of itself with the size of the array.\\n\\nThis is done to ensure the number of operations is minimum as right-rotating an array of size 5 eight times will yield the same result as right-rotating it 8%5 = three times.\\n\\nFirst, reverse the array from the beginning till the `(n-k)`th index. Now, reverse it from the `(n-k)`th index to the end. Finally, reverse the array from the beginning to the end.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        k%=n;\\n        reverse(nums.begin(), nums.begin()+(n-k));\\n        reverse(nums.begin()+(n-k), nums.end());\\n        reverse(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        k%=n;\\n        reverse(nums.begin(), nums.begin()+(n-k));\\n        reverse(nums.begin()+(n-k), nums.end());\\n        reverse(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360421,
                "title": "three-possible-java-solution-to-rotate-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- ## ***- Time complexity:***\\n\\n---\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// public class Solution {\\n//     public void rotate(int[] nums, int k) {\\n//         if (nums == null || nums.length == 0) {\\n//             return;\\n//         }\\n\\n//         int[] a = new int[nums.length];\\n//         for (int i = 0; i < nums.length; i++) {\\n//             a[(i + k) % nums.length] = nums[i];\\n//         }\\n//         for (int i = 0; i < nums.length; i++) {\\n//             nums[i] = a[i];\\n//         }\\n//     }\\n// }\\n// class Solution {\\n//     public void rotate(int[] nums, int k) {\\n//         if (nums == null || nums.length == 0) {\\n//             return;\\n//         }\\n\\n//         int offset = k % nums.length;\\n//         reverse(nums, 0, nums.length - 1);\\n//         reverse(nums, 0, offset - 1);\\n//         reverse(nums, offset, nums.length - 1);\\n//     }\\n\\n//     public void reverse(int[] nums, int start, int end) {\\n//         while (start < end) {\\n//             int temp = nums[start];\\n//             nums[start] = nums[end];\\n//             nums[end] = temp;\\n//             start++;\\n//             end--;\\n//         }\\n//     }\\n// }$$$$O(n)$$$$\\nclass Solution{\\n    public void rotate(int[] nums,int k)\\n    {\\n        k=k%nums.length;\\n    reverse(nums,0,nums.length-1);\\n    reverse(nums,0,(k-1));\\n    reverse(nums,k,nums.length-1);\\n\\n\\n\\n    }\\n    public void reverse(int[] nums,int start,int end)\\n    {\\n        while(start<end)\\n        {\\n            int temp=nums[start];\\n            nums[start]=nums[end];\\n            nums[end]=temp;\\n            start++;\\n            end--;\\n                    \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// public class Solution {\\n//     public void rotate(int[] nums, int k) {\\n//         if (nums == null || nums.length == 0) {\\n//             return;\\n//         }\\n\\n//         int[] a = new int[nums.length];\\n//         for (int i = 0; i < nums.length; i++) {\\n//             a[(i + k) % nums.length] = nums[i];\\n//         }\\n//         for (int i = 0; i < nums.length; i++) {\\n//             nums[i] = a[i];\\n//         }\\n//     }\\n// }\\n// class Solution {\\n//     public void rotate(int[] nums, int k) {\\n//         if (nums == null || nums.length == 0) {\\n//             return;\\n//         }\\n\\n//         int offset = k % nums.length;\\n//         reverse(nums, 0, nums.length - 1);\\n//         reverse(nums, 0, offset - 1);\\n//         reverse(nums, offset, nums.length - 1);\\n//     }\\n\\n//     public void reverse(int[] nums, int start, int end) {\\n//         while (start < end) {\\n//             int temp = nums[start];\\n//             nums[start] = nums[end];\\n//             nums[end] = temp;\\n//             start++;\\n//             end--;\\n//         }\\n//     }\\n// }$$$$O(n)$$$$\\nclass Solution{\\n    public void rotate(int[] nums,int k)\\n    {\\n        k=k%nums.length;\\n    reverse(nums,0,nums.length-1);\\n    reverse(nums,0,(k-1));\\n    reverse(nums,k,nums.length-1);\\n\\n\\n\\n    }\\n    public void reverse(int[] nums,int start,int end)\\n    {\\n        while(start<end)\\n        {\\n            int temp=nums[start];\\n            nums[start]=nums[end];\\n            nums[end]=temp;\\n            start++;\\n            end--;\\n                    \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925114,
                "title": "3-solutions-easy-medium-hard-explained",
                "content": "There are 3 methods to solve this question:\\n1) Brute-Force Method : \\ni. Purely Brute-force, no optimization\\nii. a little optimized (but still brute-force)\\n( In either of the cases above Time Limit will exceed )\\n\\nIn the i. part we will simply rotate for k times (which is given). It is the most basic approach which will come to everyone\\'s mind at first thought. \\n\\nCode for the Above :-\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n\\n        for(int i = 1; i <= k; i++){\\n            //code for simple rotation\\n            int temp = nums[0];\\n            for(int idx = 1; idx < nums.size(); idx++){\\n                int temp1 = nums[idx];\\n                nums[idx] = temp;\\n                temp = temp1;\\n            }\\n            nums[0] = temp;\\n        }\\n    //Note: Time Limit will Exceed\\n    }\\n};\\n```\\nNow Let\\'s think, do we really need to rotate K times? If we check carefully after rotating for a total of n times (where n is equal to length of the array) we will reach at the initial state of our array. **How?** Let\\'s take a look at the below example:\\n```\\nfor eg, array is = [1, 2, 3]\\n Let\\'s say we have to rotate the above array for 3 times\\n which is equal to the length of the array (say length is n).\\n Let\\'s rotate,\\n    First Rotation: [3, 1, 2]\\n    Second Rotation: [2, 3, 1]\\n    Third Rotation: [1, 2, 3]\\n \\n Isn\\'t the array we got after n rotations equal to our initial \\n array? So actually we did waste 3 iteration for the same task\\n which could have been done in 0 iteration, right?\\n```\\nWhich leads us to our Brute-Force ii. method:\\n```\\nHere we will only rotate for k % size of array times.\\nwhere k is the number of times given to rotate.\\n\\nLet\\'s Rotate the same array of our previous example: [1, 2, 3],\\nfor a total of 7 times, i.e, k = 7.\\n\\nFirst, Let\\'s do the same with the help of Brute-Force i. method:\\n[using r as abbreviation for rotation]\\n1st r: [3, 1, 2]\\n2nd r: [2, 3, 1]\\n3rd r: [1, 2, 3] -> see how we returned to initial state\\n4th r: [3, 1, 2]\\n5th r: [2, 3, 1]\\n6th r: [1, 2, 3] -> notice we once again reached initial state\\n7th r: [3, 1, 2]\\n\\nLet\\'s try rotating with our Brute-Force ii. method:\\ntimesToRotate = k % size => 7 % 3 = 1\\nRotating timesToRotate times now, i.e, 1 time:\\noriginal array: [1, 2, 3]\\nafter 1st r: [3, 1, 2]\\n\\nDidn\\'t we get the same array we got by using our first approach?\\nAlso we didn\\'t have to waste so many iterations with the help of a\\nsimple mod operation.\\n```\\nLet\\'s see the Code for the Above Approach:\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int timesToRotate = k % nums.size();\\n\\n        for(int i = 1; i <= timesToRotate; i++){\\n            int temp = nums[0];\\n            for(int idx = 1; idx < nums.size(); idx++){\\n                int temp1 = nums[idx];\\n                nums[idx] = temp;\\n                temp = temp1;\\n            }\\n            nums[0] = temp;\\n        }\\n        //Note: Time Limit will still exceed\\n    }\\n};\\n```\\nOkay, very Well, we now know our first approach, but come to think of it, why is the time limit still exceeding? it\\'s because we are shifting the elements in the array one-by-one for a total of k times or k % size times with the help of our 1st Approach, which ultimately is a time consuming task even if we optimized it.\\nCan we do the same task in O(n) time, i.e, in a single traversal? to do so we have to understand our 2nd Approach:\\n2) We now know that we only need to rotate for t times now, lets say t = k % size by our first approach. Now what if we create a second array and directly store the corresponding elements of our main array at the proper location they should be after rotation and then copy it back to our main array. Note: The Time complexity will surely be reduced but we will have to use extra space for another array in this case.\\n\\nLet\\'s understand the above in a little more depth:\\n```\\nLet\\'s Say we have the same array: [1, 2, 3]\\nWe also create a temporary array: [0, 0, 0] <- 0 denoting no values\\n(which has the same size as the main array but is currently NULL)\\n\\nLet\\'s say k = 7,\\ntherefore t = k % size => 7 % 3 = 1\\n\\nNow, what if we store each element of first array at \\n(current index + t) % (size of array) index in our secondary \\narray.\\n\\nFor example:\\nin our main array: 1 is at index -> 0\\n                   2 is at index -> 1\\n                   3 is at index -> 2\\n\\nSo in our secondary array we should store 1 at:\\n    (index of 1 in main array + t) % size => (0 + 1) % 3 = 1\\nSo our secondary array becomes: [0, 1, 0]\\n\\nDoing the same element 2 of main array:\\n    (2s index in main array + t) % size => (1 + 1) % 3 = 2\\nSecondary array becomes: [0, 1, 2]\\n\\nDoing the same with element 3 of main array:\\n    (3s index in main array + t) % size => (2 + 1) % 3 = 0\\nSecondary array becomes: [3, 1, 2]\\nNow simply copy it to our main array.\\n\\nWhy did we have to mod the position to provide in array2 \\nby the size? it could have been done without it? Well, \\nwe did it to save ourselves from handling the edge cases when\\nindex becomes greater than size - 1 of array, which if is not\\nhandled will give us ArrayOutOfBounds kind of error.\\n\\nHere we only traversed the main array once hence Time Complexity \\nwill be = O(n),\\nand O(n) time will also be taken for copying, making the\\nTotal Complexity = O(n) + O(n) = O(n) (in general)\\n```\\nLet\\'s see the Implementation of the above code,\\n (This time it won\\'t exceed the time limit):\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int timesToRotate = k % nums.size();\\n\\n        vector<int> temp(nums.size());\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n            temp[(i + timesToRotate) % nums.size()] = nums[i];\\n        \\n        //copying the array\\n        for(int i = 0; i < nums.size(); i++)\\n            nums[i] = temp[i];\\n    }\\n};\\n```\\nNow, we have done the task in O(n) time, so why do we need more approaches? The reason being we took extra space in our last approach, Can we do the same task in O(n) time without using extra space? the answer is Yes we can, which brings us our 3rd Approach:\\n\\n3) Now this approach TBH is tricky and you won\\'t understand it unless you dry run it, and for your curiousity neither was I able to understand it without implementing.\\nIn this approach we will :\\n    First: Reverse the whole array.\\n    Second: Reverse from starting till t - 1 index (where t = k % length/size of array).\\n    Third: Reverse from index t till the last index of the array.\\n\\nDidn\\'t understand any of the above? Worry not, let\\'s understand in a little depth:\\n```\\nLet\\'s take our favourite array: [1, 2, 3]\\nand our favourite k, which is: 7 times\\nour t becomes: k % size of array => 7 % 3 = 1\\n\\nStep 1: Reverse the whole array:\\n    [3, 2, 1]\\nStep 2: Reverse from start (which is 0th index) till t-1 index:\\n    t = 1\\n    t - 1 = 0\\n    Reverse from 0 to 0th index, which is basically doing nothing\\n    [3, 2, 1]\\nStep 3: Reverse from index t to end of array:\\n    t = 1\\n    last index = size - 1 => 3 - 1 = 2\\n    reversing from index 1 to 2:\\n    [3, 1, 2] <- Isn\\'t this the very array we were asked to fetch?\\n\\nSo here we solved the question without using any extra space like\\nour 2nd approach.\\n```\\nNow, I have written the code in cpp which has a function which takes the parameter of both the start point of the reverse and the end point of the reverse (where the end point is not included). If you use some other language you might have to create a function to reverse which accepts both starting and ending points seperately (which is pretty easy to do) or pass your parameters of indexes a little differently than me. However, the logic remains the same as above.\\n\\nMy Cpp code for the same:\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int timesToRotate = k % nums.size();\\n\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin() + timesToRotate);\\n        reverse(nums.begin() + timesToRotate, nums.end());\\n\\n    }\\n};\\n```\\n> **If you read till here and found it helpful then don\\'t forget to UP VOTE**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n\\n        for(int i = 1; i <= k; i++){\\n            //code for simple rotation\\n            int temp = nums[0];\\n            for(int idx = 1; idx < nums.size(); idx++){\\n                int temp1 = nums[idx];\\n                nums[idx] = temp;\\n                temp = temp1;\\n            }\\n            nums[0] = temp;\\n        }\\n    //Note: Time Limit will Exceed\\n    }\\n};\\n```\n```\\nfor eg, array is = [1, 2, 3]\\n Let\\'s say we have to rotate the above array for 3 times\\n which is equal to the length of the array (say length is n).\\n Let\\'s rotate,\\n    First Rotation: [3, 1, 2]\\n    Second Rotation: [2, 3, 1]\\n    Third Rotation: [1, 2, 3]\\n \\n Isn\\'t the array we got after n rotations equal to our initial \\n array? So actually we did waste 3 iteration for the same task\\n which could have been done in 0 iteration, right?\\n```\n```\\nHere we will only rotate for k % size of array times.\\nwhere k is the number of times given to rotate.\\n\\nLet\\'s Rotate the same array of our previous example: [1, 2, 3],\\nfor a total of 7 times, i.e, k = 7.\\n\\nFirst, Let\\'s do the same with the help of Brute-Force i. method:\\n[using r as abbreviation for rotation]\\n1st r: [3, 1, 2]\\n2nd r: [2, 3, 1]\\n3rd r: [1, 2, 3] -> see how we returned to initial state\\n4th r: [3, 1, 2]\\n5th r: [2, 3, 1]\\n6th r: [1, 2, 3] -> notice we once again reached initial state\\n7th r: [3, 1, 2]\\n\\nLet\\'s try rotating with our Brute-Force ii. method:\\ntimesToRotate = k % size => 7 % 3 = 1\\nRotating timesToRotate times now, i.e, 1 time:\\noriginal array: [1, 2, 3]\\nafter 1st r: [3, 1, 2]\\n\\nDidn\\'t we get the same array we got by using our first approach?\\nAlso we didn\\'t have to waste so many iterations with the help of a\\nsimple mod operation.\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int timesToRotate = k % nums.size();\\n\\n        for(int i = 1; i <= timesToRotate; i++){\\n            int temp = nums[0];\\n            for(int idx = 1; idx < nums.size(); idx++){\\n                int temp1 = nums[idx];\\n                nums[idx] = temp;\\n                temp = temp1;\\n            }\\n            nums[0] = temp;\\n        }\\n        //Note: Time Limit will still exceed\\n    }\\n};\\n```\n```\\nLet\\'s Say we have the same array: [1, 2, 3]\\nWe also create a temporary array: [0, 0, 0] <- 0 denoting no values\\n(which has the same size as the main array but is currently NULL)\\n\\nLet\\'s say k = 7,\\ntherefore t = k % size => 7 % 3 = 1\\n\\nNow, what if we store each element of first array at \\n(current index + t) % (size of array) index in our secondary \\narray.\\n\\nFor example:\\nin our main array: 1 is at index -> 0\\n                   2 is at index -> 1\\n                   3 is at index -> 2\\n\\nSo in our secondary array we should store 1 at:\\n    (index of 1 in main array + t) % size => (0 + 1) % 3 = 1\\nSo our secondary array becomes: [0, 1, 0]\\n\\nDoing the same element 2 of main array:\\n    (2s index in main array + t) % size => (1 + 1) % 3 = 2\\nSecondary array becomes: [0, 1, 2]\\n\\nDoing the same with element 3 of main array:\\n    (3s index in main array + t) % size => (2 + 1) % 3 = 0\\nSecondary array becomes: [3, 1, 2]\\nNow simply copy it to our main array.\\n\\nWhy did we have to mod the position to provide in array2 \\nby the size? it could have been done without it? Well, \\nwe did it to save ourselves from handling the edge cases when\\nindex becomes greater than size - 1 of array, which if is not\\nhandled will give us ArrayOutOfBounds kind of error.\\n\\nHere we only traversed the main array once hence Time Complexity \\nwill be = O(n),\\nand O(n) time will also be taken for copying, making the\\nTotal Complexity = O(n) + O(n) = O(n) (in general)\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int timesToRotate = k % nums.size();\\n\\n        vector<int> temp(nums.size());\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n            temp[(i + timesToRotate) % nums.size()] = nums[i];\\n        \\n        //copying the array\\n        for(int i = 0; i < nums.size(); i++)\\n            nums[i] = temp[i];\\n    }\\n};\\n```\n```\\nLet\\'s take our favourite array: [1, 2, 3]\\nand our favourite k, which is: 7 times\\nour t becomes: k % size of array => 7 % 3 = 1\\n\\nStep 1: Reverse the whole array:\\n    [3, 2, 1]\\nStep 2: Reverse from start (which is 0th index) till t-1 index:\\n    t = 1\\n    t - 1 = 0\\n    Reverse from 0 to 0th index, which is basically doing nothing\\n    [3, 2, 1]\\nStep 3: Reverse from index t to end of array:\\n    t = 1\\n    last index = size - 1 => 3 - 1 = 2\\n    reversing from index 1 to 2:\\n    [3, 1, 2] <- Isn\\'t this the very array we were asked to fetch?\\n\\nSo here we solved the question without using any extra space like\\nour 2nd approach.\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int timesToRotate = k % nums.size();\\n\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin() + timesToRotate);\\n        reverse(nums.begin() + timesToRotate, nums.end());\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673140,
                "title": "python3-easy-3-lines-99-8-faster",
                "content": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = k%len(nums)\\n        n= len(nums)-k\\n        nums[:] = nums[n:]+nums[:n]\\n            \\n```\\npls upvote if you like the solution :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = k%len(nums)\\n        n= len(nums)-k\\n        nums[:] = nums[n:]+nums[:n]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373418,
                "title": "fast-c-easy-logic",
                "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n       vector<int> ans(n);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          //i-th index wali value (i+k)%n wale index par hogi\\n            ans[(i+k)%n]=nums[i];\\n        \\n        \\n        }\\n        nums=ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n       vector<int> ans(n);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          //i-th index wali value (i+k)%n wale index par hogi\\n            ans[(i+k)%n]=nums[i];\\n        \\n        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2082183,
                "title": "o-n-time-complexity-o-1-extra-space",
                "content": "In this , you have to make the flow diagram and debug it again and again to understand this better.\\nSuppose,\\n1 2 3 4 5 6 7 is the array and the number of rotations is 3.\\nWe have taken iterations as 0.\\nAfter 1st iteration, \\n4 2 3 1 5 6 7 and we have the index of 4 as well because we are always moving 3 steps ahead which our index variable is taking care of.\\nAfter 2nd iteration,\\n7 2 3 1 5 6 4\\nAfter 3rd iteration,\\n3 2 7 1 5 6 4\\nAfter 4th iteration,\\n6 2 7 1 5 3 4 \\nAfter 5th iteration,\\n2 6 7 1 5 3 4\\nAfter 6th iteration,\\n5 6 7 1 2 3 4 which is our answer and now as iterations == array.length so loop will not further move.\\n\\nSimilarly, for -1 , 100, 3, 99\\nAfter 1st iteration,\\n3,100,-1,99\\nAfter 2nd iteration,\\n3 100 -1 99   i==1\\nAfter 3rd iteration,\\n3 99 -1 100\\nNow iterations == array.length so this will not further move. \\n\\n**Important**\\nIt is very important that you do not move more than the length of the array as it will ruin the indices that you corrected while rotating.\\n\\n```\\n public void rotate(int[] nums, int k) {\\n//        Marks the correct index of a number\\n        int index = 0;\\n//        Marks the index of the array.\\n        int i = 0;\\n//        Marks the number of iterations in the array.\\n        int iterations = 0;\\n        while(iterations < nums.length){\\n           if((index+k)% nums.length == i){\\n               i++;\\n               index = i;\\n               iterations++;\\n           }else{\\n               swap(nums,i,(index+k)%nums.length);\\n               index = (index+k)%nums.length;\\n               iterations++;\\n           }\\n        }\\n    }\\n\\n    void swap(int [] nums , int i , int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n```\\n\\nIf you liked the solution or found it different , do upvote :)\\nThank you",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n public void rotate(int[] nums, int k) {\\n//        Marks the correct index of a number\\n        int index = 0;\\n//        Marks the index of the array.\\n        int i = 0;\\n//        Marks the number of iterations in the array.\\n        int iterations = 0;\\n        while(iterations < nums.length){\\n           if((index+k)% nums.length == i){\\n               i++;\\n               index = i;\\n               iterations++;\\n           }else{\\n               swap(nums,i,(index+k)%nums.length);\\n               index = (index+k)%nums.length;\\n               iterations++;\\n           }\\n        }\\n    }\\n\\n    void swap(int [] nums , int i , int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1873375,
                "title": "c-easy-solution-98-o-n-o-1",
                "content": "```\\nvoid reverse(int* arr, int start, int end) {\\n    for (; start < end; start++, end--) {\\n        int tmp = arr[start];\\n        arr[start] = arr[end];\\n        arr[end] = tmp;\\n    }\\n}\\nvoid rotate(int* nums, int numsSize, int k)\\n{\\n    if (numsSize == 1)\\n        return;\\n    k %= numsSize;\\n\\n    reverse(nums, 0, numsSize - 1);\\n    reverse(nums, 0, k - 1);\\n    reverse(nums, k, numsSize - 1);\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid reverse(int* arr, int start, int end) {\\n    for (; start < end; start++, end--) {\\n        int tmp = arr[start];\\n        arr[start] = arr[end];\\n        arr[end] = tmp;\\n    }\\n}\\nvoid rotate(int* nums, int numsSize, int k)\\n{\\n    if (numsSize == 1)\\n        return;\\n    k %= numsSize;\\n\\n    reverse(nums, 0, numsSize - 1);\\n    reverse(nums, 0, k - 1);\\n    reverse(nums, k, numsSize - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1769426,
                "title": "javascript-solution",
                "content": "```\\nvar rotate = function (nums, k) {\\n    const len = nums.length\\n    k = (k % len)\\n    \\n    let end = nums.splice(len - k)\\n\\n    nums.splice(0,0,...end)\\n};\\n```\\n\\nRuntime: 104 ms, faster than 87.37% of JavaScript online submissions for Rotate Array.\\nMemory Usage: 50.7 MB, less than 43.86% of JavaScript online submissions for Rotate Array.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function (nums, k) {\\n    const len = nums.length\\n    k = (k % len)\\n    \\n    let end = nums.splice(len - k)\\n\\n    nums.splice(0,0,...end)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314695,
                "title": "javascript-0-n-solution",
                "content": "```\\nvar rotate = function(nums, k) {\\n    let j = nums.length - k % nums.length;\\n    let arr = [...nums];\\n    for(let i=0; i<nums.length; i++) {\\n        if(j === nums.length) {\\n            j = 0;\\n        }\\n        nums[i] = arr[j];\\n        j++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function(nums, k) {\\n    let j = nums.length - k % nums.length;\\n    let arr = [...nums];\\n    for(let i=0; i<nums.length; i++) {\\n        if(j === nums.length) {\\n            j = 0;\\n        }\\n        nums[i] = arr[j];\\n        j++;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 225810,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Brute Force Approach**\\n\\n**Intuition:**\\n- The simplest approach is to rotate all the elements of the array in `K` .\\n\\n**Algorithm:**\\n1. Shift all the array elements right by `1` step.\\n1. Do this `K` times.\\n\\n**Time complexity:** `O(N * K)`, All the numbers are shifted by one step right and it will take `O(N)`. For `K` times, it will take `O(N * K)`\\n**Space complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public void rotate(int[] A, int K) {\\n        K = K % A.length;\\n\\n        int prev;\\n        int current;\\n\\n        for (int i = 0; i < K; i++) {\\n            prev = A[A.length - 1];\\n\\n            for (int j = 0; j < A.length; j++) {\\n                current = A[j];\\n                A[j] = prev;\\n                prev = current;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Solution 2: Using Extra Array**\\n\\n**Algorithm:**\\n1. We use an extra array in which we place every element of the array at its correct position i.e. the number at index `i` in the original array is placed at the index `(i + K) % length` of array. \\n1. Then, we copy the new array to the original one.\\n\\n**Time complexity:** `O(N)`\\n**Space complexity:** `O(N)`, Another array of the same size is used.\\n\\n```\\nclass Solution {\\n    public void rotate(int[] A, int K) {\\n        int[] B = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            int index = (i + K) % A.length;\\n            B[index] = A[i];\\n        }\\n\\n        for (int i = 0; i < A.length; i++) {\\n            A[i] = B[i];\\n        }\\n    }\\n}\\n```\\n\\n**Solution 3: Using Reverse**\\n\\n**Intuition:**\\n- Let given array `A = [1, 2, 3, 4, a, b]`, and `K = 2`. Then in the rotated array `A`, there are two sub-arrays, `[1, 2, 3, 4]` and `[a, b]` that keep their original orders.\\n- Therefore, rotation can be seen as the exchanges of the two sub-arrays of `A` and these exchanges can be performed in `O(N)` time. Also we can use an in-place array-reverse method to perform these exchanges in `O(1)` space.\\n\\n**Algorithm:**\\n1. First reverse the entire array `A` and so `[1, 2, 3, 4, a, b]` becomes `[b, a, 4, 3, 2, 1].`\\n2. Then reverse first `K` elements from index `0` to `K` and so `[b, a, 4, 3, 2, 1]` becomes `[a, b, 4, 3, 2, 1]`.\\n3. Lastly, reverse the remaining `N - K` elements from index `N` to `N - 1` and so `[a, b, 4, 3, 2, 1]` becomes `[a, b, 1, 2, 3, 4]` which yields the rotated array.\\n\\n**Time complexity:** `O(N)`\\n**Space complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public void rotate(int[] A, int K) {\\n        K = K % A.length;\\n\\n        reverse(A, 0, A.length - 1);    // [1, 2, 3, 4, a, b] --> [b, a, 4, 3, 2, 1]  Reverse entire array\\n        reverse(A, 0, K - 1);           // [b, a, 4, 3, 2, 1] --> [a, b, 4, 3, 2, 1]  Reverse first \\'K\\' elements\\n        reverse(A, K, A.length - 1);    // [a, b, 4, 3, 2, 1] --> [a, b, 1, 2, 3, 4]  Reverse remaining \\'N - K\\' elements\\n    }\\n\\n    private void reverse(int[] A, int start, int end) {\\n        while (start < end) {\\n            int temp = A[start];\\n            A[start++] = A[end];\\n            A[end--] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] A, int K) {\\n        K = K % A.length;\\n\\n        int prev;\\n        int current;\\n\\n        for (int i = 0; i < K; i++) {\\n            prev = A[A.length - 1];\\n\\n            for (int j = 0; j < A.length; j++) {\\n                current = A[j];\\n                A[j] = prev;\\n                prev = current;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void rotate(int[] A, int K) {\\n        int[] B = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            int index = (i + K) % A.length;\\n            B[index] = A[i];\\n        }\\n\\n        for (int i = 0; i < A.length; i++) {\\n            A[i] = B[i];\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void rotate(int[] A, int K) {\\n        K = K % A.length;\\n\\n        reverse(A, 0, A.length - 1);    // [1, 2, 3, 4, a, b] --> [b, a, 4, 3, 2, 1]  Reverse entire array\\n        reverse(A, 0, K - 1);           // [b, a, 4, 3, 2, 1] --> [a, b, 4, 3, 2, 1]  Reverse first \\'K\\' elements\\n        reverse(A, K, A.length - 1);    // [a, b, 4, 3, 2, 1] --> [a, b, 1, 2, 3, 4]  Reverse remaining \\'N - K\\' elements\\n    }\\n\\n    private void reverse(int[] A, int start, int end) {\\n        while (start < end) {\\n            int temp = A[start];\\n            A[start++] = A[end];\\n            A[end--] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169152,
                "title": "my-detailed-explained-5-javascript-solutions-with-one-liner-that-beats-98-5-of-all-submissions",
                "content": "Here are my five different JavaScript solutions for Rotate Array problem (four are analogs to Solutions and one is JavaScript-specific, requiring ES6 syntax). The most interesting JS-specific ES6 one-line super-fast solution with detailed description is at the very end.\\n\\nFirst is the same as solution **#4 cycling replacements**. I figured out this method by myself by trying to solve this task on a piece of paper, so my solution is somewhat different from the one stated in LeetCode solution. My solution uses only a single `do while` cycle, and I handle special case where I need to update starting point via `if` statement.\\n\\n```\\nlet rotate = function(nums, k) {\\n    function getNext(start, shift = k) {\\n        return (start + shift) % nums.length;\\n    }\\n\\n    k = getNext(k, 0); // force k < nums.length\\n    if (nums.length === 1 || k === 0) return;\\n\\n    let start = 0, i = start + k, prev = start, temp = nums[start], swaps = 0;\\n    do {\\n        let buffer = nums[i];\\n        nums[i] = temp;\\n        temp = buffer;\\n        if (i === start) {\\n            start++;\\n            i = start;\\n            temp = nums[i];\\n        }\\n        prev = i;\\n        i = getNext(i);\\n        swaps++;\\n    } while (swaps < nums.length);\\n};\\n```\\n\\nMy initial solution was identical to **#2 - Using Extra Array**. I use a temp array to create a copy of the input array and insert original elements into new indexes, and then simply update original array. This solution has O(n) time complexity, O(n) space complexity:\\n\\n```\\nlet rotate = function(nums, k) {\\n    while (k >= nums.length) {\\n        k -= nums.length;\\n    }\\n    if (nums.length === 1 || k === 0) return;\\n    let temp = [];\\n    for (let left = 0, right = k; left < nums.length; left++, right++) {\\n        if (right >= nums.length) {\\n            right -= nums.length;\\n        }\\n        temp[right] = nums[left];\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        nums[i] = temp[i];\\n    }\\n};\\n```\\n\\nI really loved the original idea of solution **#4 - Using Reverse**, or simply rotating array and two parts (before and after the shift). So I took the idea and made a JavaScript implementation:\\n\\n```\\nlet rotate = function(nums, k) {\\n    k = k % nums.length;\\n    if (k === 0 || nums.length === 1) return;\\n\\n    function reverse(start, finish) {\\n        for (let i = start, j = finish - 1; i < Math.floor((start + finish) / 2); i++, j--) {\\n            let temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n        }\\n    }\\n\\n    reverse(0, nums.length);\\n    reverse(0, k);\\n    reverse(k, nums.length);\\n};\\n```\\n\\n**One-line brute-force** approach.\\nUsing JavaScript built-in methods we can shrink brute force to one line:\\nFirst, `pop` the last element of the array, then `unshift` it (add it at the start). Repeat `k` times to reach desired result. Very easy to code in JS but not very fast, beats around 50% of submissions:\\n```\\nlet rotate = function(nums, k) {\\n    for(let i = 0; i < k % nums.length; i++) nums.unshift(nums.pop());\\n};\\n```\\n\\nAnd here\\'s my favorite JS-specific one-line solution, which just happens to be very efficient - it **beats 98.5% of all submissions (and looks awesome!)**:\\n```\\nlet rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length-k));\\n};\\n```\\nThis does exactly what is required: cuts off nums.length elements at the end and reinserts them at the start. All while using built-in JavaScript functions. As a bonus, it has same execution speed as the faster methods above. The only **downside** - it cannot be recreated in other languages unless they have `unshift` and `splice` analogs. `...` (spread) is required for quick and painless `unshift`ing.\\n\\nHow it works:\\n`splice` removes a certain number of elements starting at provided index and modifies array length. Removed elements are returned. [Array.prototype.splice() @ MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)\\n`unshift` adds elements at the start of the array and moves the rest of elements forward. [Array.prototype.unshift() @ MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)\\n`...` is called [Spread syntax @ MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax). It is used to break down arrays (or strings) into separate elements. In this case it allows us to `unshif` elements we `splice`d from the array without concatenating arrays and iterating over `nums` to update it in place.",
                "solutionTags": [],
                "code": "```\\nlet rotate = function(nums, k) {\\n    function getNext(start, shift = k) {\\n        return (start + shift) % nums.length;\\n    }\\n\\n    k = getNext(k, 0); // force k < nums.length\\n    if (nums.length === 1 || k === 0) return;\\n\\n    let start = 0, i = start + k, prev = start, temp = nums[start], swaps = 0;\\n    do {\\n        let buffer = nums[i];\\n        nums[i] = temp;\\n        temp = buffer;\\n        if (i === start) {\\n            start++;\\n            i = start;\\n            temp = nums[i];\\n        }\\n        prev = i;\\n        i = getNext(i);\\n        swaps++;\\n    } while (swaps < nums.length);\\n};\\n```\n```\\nlet rotate = function(nums, k) {\\n    while (k >= nums.length) {\\n        k -= nums.length;\\n    }\\n    if (nums.length === 1 || k === 0) return;\\n    let temp = [];\\n    for (let left = 0, right = k; left < nums.length; left++, right++) {\\n        if (right >= nums.length) {\\n            right -= nums.length;\\n        }\\n        temp[right] = nums[left];\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        nums[i] = temp[i];\\n    }\\n};\\n```\n```\\nlet rotate = function(nums, k) {\\n    k = k % nums.length;\\n    if (k === 0 || nums.length === 1) return;\\n\\n    function reverse(start, finish) {\\n        for (let i = start, j = finish - 1; i < Math.floor((start + finish) / 2); i++, j--) {\\n            let temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n        }\\n    }\\n\\n    reverse(0, nums.length);\\n    reverse(0, k);\\n    reverse(k, nums.length);\\n};\\n```\n```\\nlet rotate = function(nums, k) {\\n    for(let i = 0; i < k % nums.length; i++) nums.unshift(nums.pop());\\n};\\n```\n```\\nlet rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length-k));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851537,
                "title": "beats-100-o-n-time-o-1-space-java-striver-explanation",
                "content": "# Intuition\\nTo rotate the array to the right by k steps, we can use a three-step approach. Firstly, we reverse the first n-k elements of the array. Then, we reverse the remaining k elements. Finally, we reverse the entire array. This approach allows us to achieve the rotation in-place without using any additional space.\\n\\n# Approach\\n1. Reverse the first n-k elements of the array. We can do this by swapping elements from the start and end of the subarray until we reach the middle.\\n2. Reverse the remaining k elements of the array. We can do this by swapping elements from the start and end of the subarray until we reach the middle.\\n3. Reverse the entire array. This is similar to step 1 but done on the whole array.\\n\\n# Complexity\\n- Time complexity: O(n) where n is the number of elements in the array. The three reverse operations take linear time, and since all three operations are done separately, the overall time complexity remains linear.\\n- Space complexity: O(1) since we are modifying the input array in-place and not using any additional space that depends on the size of the input.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        k %= n; // In case k is larger than the length of the array, take the modulo.\\n\\n        // Reverse the first n-k elements.\\n        reverseArray(nums, 0, n - k - 1);\\n\\n        // Reverse the rest elements.\\n        reverseArray(nums, n - k, n - 1);\\n\\n        // Reverse the entire array.\\n        reverseArray(nums, 0, n - 1);\\n    }\\n    private static void reverseArray(int[] nums, int start, int end) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        k %= n; // In case k is larger than the length of the array, take the modulo.\\n\\n        // Reverse the first n-k elements.\\n        reverseArray(nums, 0, n - k - 1);\\n\\n        // Reverse the rest elements.\\n        reverseArray(nums, n - k, n - 1);\\n\\n        // Reverse the entire array.\\n        reverseArray(nums, 0, n - 1);\\n    }\\n    private static void reverseArray(int[] nums, int start, int end) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726746,
                "title": "python-reversal-algorithm-beginners-solution-easy",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        def reverse(nums,l,h):\\n            while l<=h:\\n                nums[l],nums[h] = nums[h],nums[l]\\n                l+=1\\n                h-=1\\n        \\n        n = len(nums)\\n        k = k%n\\n        reverse(nums,0,n-k-1)\\n        reverse(nums,n-k,n-1)\\n        reverse(nums,0,n-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        def reverse(nums,l,h):\\n            while l<=h:\\n                nums[l],nums[h] = nums[h],nums[l]\\n                l+=1\\n                h-=1\\n        \\n        n = len(nums)\\n        k = k%n\\n        reverse(nums,0,n-k-1)\\n        reverse(nums,n-k,n-1)\\n        reverse(nums,0,n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720648,
                "title": "easy-java-solution-3ms",
                "content": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623153,
                "title": "c-solution-o-n-time-complexity-o-1-space-complexity-99-faster",
                "content": "Lets take an Example:- \\nnums = [-1,-100,3,99], k = 2\\n**Algo**\\nStep 1- Reverse first size-k element\\nnums=[**-100,-1**,3,99]\\nStep 2- Reverse last k element\\nnums=[-100,-1,**99,3**]\\nStep 3- At last, reverse whole array\\nnums[**3,99,-1,-100**]\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) \\n    {\\n        int len=nums.size();\\n        k%=len;\\n        if(k==0)\\n            return;\\n\\t\\t// reversing first size-k element\\n        reverse(nums.begin(),nums.end()-k);\\n\\t\\t\\n\\t\\t// reversing last k element\\n        reverse(nums.end()-k,nums.end());\\n\\t\\t\\n\\t\\t//reversing the whole array\\n        reverse(nums.begin(),nums.end());\\n    }\\n};\\n```\\n\\n\\nPlz upvote if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) \\n    {\\n        int len=nums.size();\\n        k%=len;\\n        if(k==0)\\n            return;\\n\\t\\t// reversing first size-k element\\n        reverse(nums.begin(),nums.end()-k);\\n\\t\\t\\n\\t\\t// reversing last k element\\n        reverse(nums.end()-k,nums.end());\\n\\t\\t\\n\\t\\t//reversing the whole array\\n        reverse(nums.begin(),nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884774,
                "title": "98-faster-reverse-c",
                "content": "***Please Upvote to keep me motivated*** \\u270C\\n\\n**Explanation :-**\\n\\neg. [1,2,3,4,5,6,7] , k = 3\\nOutput = [5,6,7,1,2,3,4]\\n\\n\\u2714 Reverse the whole array => [7,6,5,4,3,2,1]\\n\\u2714 Reverse the parts now as => [5,6,7,1,2,3,4]\\nWe are doing k = k % n because if size of array is 7 (n = 7) and k = 21, then we need not to rotate the array as we will get the same array after rotations.\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k = k % n;\\n        reverse(nums.begin() , nums.end());\\n        reverse(nums.begin() , nums.begin() + k);\\n        reverse(nums.begin() + k , nums.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k = k % n;\\n        reverse(nums.begin() , nums.end());\\n        reverse(nums.begin() , nums.begin() + k);\\n        reverse(nums.begin() + k , nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776484,
                "title": "c-o-1-space-follow-up-reverse-approach-3-solution",
                "content": "This solution can be done in the following approaches:\\n1. Creating an array and add last k elements firast then add 1 to n-k elements in the array.\\n2. We can store last element of array in a variable and will rotate array by 1. Repeat this k times.\\n3.  Reversing the array multiple times. (Code is below)\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        \\n        int n=k%nums.size(); //if k is greater then size\\n        \\n        reverse(nums.begin(),nums.end()); //reverse full array\\n        \\n        reverse(nums.begin(),nums.begin()+n);   //reverse first k elements\\n        \\n        reverse(nums.begin()+n,nums.end());     // reverse remaining elements\\n        \\n    }\\n};\\n```\\nPlease **UpVote** if you liked my solution.\\nDon\\'t forget to check my other solution: https://github.com/tarunsahnan/LeetCode-Solutions",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        \\n        int n=k%nums.size(); //if k is greater then size\\n        \\n        reverse(nums.begin(),nums.end()); //reverse full array\\n        \\n        reverse(nums.begin(),nums.begin()+n);   //reverse first k elements\\n        \\n        reverse(nums.begin()+n,nums.end());     // reverse remaining elements\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719123,
                "title": "o-n-time-and-o-1-space-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverse(vector<int>& nums, int i, int j){\\n        while(i<j){\\n            swap(nums[i],nums[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k>n){\\n            k=k%n;\\n        }\\n        reverse(nums,0,n-k-1);\\n        reverse(nums,n-k,n-1);\\n        reverse(nums,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverse(vector<int>& nums, int i, int j){\\n        while(i<j){\\n            swap(nums[i],nums[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k>n){\\n            k=k%n;\\n        }\\n        reverse(nums,0,n-k-1);\\n        reverse(nums,n-k,n-1);\\n        reverse(nums,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494187,
                "title": "c-easy-2-methods-with-and-without-using-extra-space",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Space complexity O(N)**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n       int i=1,l=nums.size();\\n        while(true)\\n        {\\n            if(i*l-k>0)\\n            {\\n            k=i*l-k;\\n            break;\\n            }\\n            i++;\\n        }\\n        vector<int> ans;\\n        for(int j=k;j<l;j++)\\n        {\\n            ans.push_back(nums[j]);\\n        }\\n        for(int j=0;j<k;j++)\\n        {\\n            ans.push_back(nums[j]);\\n        }\\n        nums=ans;\\n    }\\n};\\n```\\n**Space complexity O(1)**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+k);\\n    reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n       int i=1,l=nums.size();\\n        while(true)\\n        {\\n            if(i*l-k>0)\\n            {\\n            k=i*l-k;\\n            break;\\n            }\\n            i++;\\n        }\\n        vector<int> ans;\\n        for(int j=k;j<l;j++)\\n        {\\n            ans.push_back(nums[j]);\\n        }\\n        for(int j=0;j<k;j++)\\n        {\\n            ans.push_back(nums[j]);\\n        }\\n        nums=ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+k);\\n    reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853405,
                "title": "clean-python",
                "content": "**Clean Python**\\n\\nOfficial Solution N\\xBA 4, with clean variables and a small check to prevent redundant work.\\n\\n```\\nclass Solution:\\n    def reverse(self,A,i,j):\\n        while i<j:\\n            A[i],A[j] = A[j],A[i]\\n            i += 1\\n            j -= 1\\n    def rotate(self, A, k):\\n        L  = len(A)\\n        k %= L\\n        if k:\\n            self.reverse( A , 0 , L-1 )\\n            self.reverse( A , 0 , k-1 )\\n            self.reverse( A , k , L-1 )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverse(self,A,i,j):\\n        while i<j:\\n            A[i],A[j] = A[j],A[i]\\n            i += 1\\n            j -= 1\\n    def rotate(self, A, k):\\n        L  = len(A)\\n        k %= L\\n        if k:\\n            self.reverse( A , 0 , L-1 )\\n            self.reverse( A , 0 , k-1 )\\n            self.reverse( A , k , L-1 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278393,
                "title": "swift",
                "content": "```\\n    func rotate(_ nums: inout [Int], _ k: Int) {\\n        if k < 1 || nums.count == 0{\\n            return\\n        }\\n        var k = k % nums.count\\n        nums = Array(nums[nums.count - k..<nums.count] + nums[0..<nums.count-k])\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func rotate(_ nums: inout [Int], _ k: Int) {\\n        if k < 1 || nums.count == 0{\\n            return\\n        }\\n        var k = k % nums.count\\n        nums = Array(nums[nums.count - k..<nums.count] + nums[0..<nums.count-k])\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54563,
                "title": "my-o-n-solution-using-c",
                "content": "    void reverse( int *nums,int begin,int end ){\\n        int tmp = 0;\\n        while( begin < end ){\\n            tmp = nums[begin];\\n            nums[begin++] = nums[end];\\n            nums[end--] = tmp;\\n        }\\n    }\\n    void three_reverse( int *nums,int numsSize,int n ){\\n        reverse(nums,0,n-1);\\n        reverse(nums,n,numsSize-1);\\n        reverse(nums,0,numsSize-1);\\n    }\\n    void rotate(int* nums, int numsSize, int k) {\\n        k %= numsSize;\\n        three_reverse(nums,numsSize,numsSize-k);\\n    }",
                "solutionTags": [],
                "code": "    void reverse( int *nums,int begin,int end ){\\n        int tmp = 0;\\n        while( begin < end ){\\n            tmp = nums[begin];\\n            nums[begin++] = nums[end];\\n            nums[end--] = tmp;\\n        }\\n    }\\n    void three_reverse( int *nums,int numsSize,int n ){\\n        reverse(nums,0,n-1);\\n        reverse(nums,n,numsSize-1);\\n        reverse(nums,0,numsSize-1);\\n    }\\n    void rotate(int* nums, int numsSize, int k) {\\n        k %= numsSize;\\n        three_reverse(nums,numsSize,numsSize-k);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54557,
                "title": "my-accepted-java-solution-o-n-time-and-o-1-space",
                "content": "    public class Solution {\\n        public void rotate(int[] nums, int k) {\\n           int end = nums.length;\\n            k=k%end;// to check for outofbounds when k >= nums.length\\n            rotate(nums,0,end-k-1);//reverse one half of the array\\n            rotate(nums,end-k,end-1);//reverse other half of the array\\n            rotate(nums,0,end-1);//reverse whole array  \\n        }\\n        public void swap(int[] nums,int a,int b){\\n            int temp = nums[a];\\n            nums[a] = nums[b];\\n            nums[b] = temp;\\n        }\\n        \\n        public void rotate(int[] nums,int start,int end){\\n            for(int i = start;i<=(start+end)/2;i++){\\n                swap(nums,i,(start+end)-i);\\n            }\\n        }\\n        \\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void rotate(int[] nums, int k) {\\n           int end = nums.length;\\n            k=k%end;// to check for outofbounds when k >= nums.length\\n            rotate(nums,0,end-k-1);//reverse one half of the array\\n            rotate(nums,end-k,end-1);//reverse other half of the array\\n            rotate(nums,0,end-1);//reverse whole array  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54567,
                "title": "a-simple-c-solution-o-1-space",
                "content": "  \\n    void swap(int &x,int &y)\\n    {\\n        int tmp = x;\\n        x = y;\\n        y = tmp;\\n    }\\n    \\n    void swap_arr(vector<int>& nums, int s, int e)\\n    {\\n        int mid = (s+e)>>1;\\n        for(int i = s; i < mid; ++i)\\n        {\\n            swap(nums[i],nums[s+e-1-i]);\\n        }\\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(n<=1)return;\\n        if(k==0)return;\\n        if(k>n)k = k%n;\\n        k = n-k;\\n        swap_arr(nums,0,k);\\n        swap_arr(nums,k,n);\\n        swap_arr(nums,0,n);\\n        \\n    }",
                "solutionTags": [],
                "code": "  \\n    void swap(int &x,int &y)\\n    {\\n        int tmp = x;\\n        x = y;\\n        y = tmp;\\n    }\\n    \\n    void swap_arr(vector<int>& nums, int s, int e)\\n    {\\n        int mid = (s+e)>>1;\\n        for(int i = s; i < mid; ++i)\\n        {\\n            swap(nums[i],nums[s+e-1-i]);\\n        }\\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(n<=1)return;\\n        if(k==0)return;\\n        if(k>n)k = k%n;\\n        k = n-k;\\n        swap_arr(nums,0,k);\\n        swap_arr(nums,k,n);\\n        swap_arr(nums,0,n);\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54633,
                "title": "share-c-code-sub-array-rotate",
                "content": "    void R(int *a, int n){\\n        for(int i=0;i<n/2;i++){\\n            int temp = a[i];\\n            a[i] = a[n-i-1];\\n            a[n-i-1] = temp;\\n        }\\n    }\\n    void rotate(int nums[], int n, int k) {\\n        k = k%n;\\n        R(nums,n-k);\\n        R(nums+n-k,k);\\n        R(nums,n);\\n    }",
                "solutionTags": [],
                "code": "    void R(int *a, int n){\\n        for(int i=0;i<n/2;i++){\\n            int temp = a[i];\\n            a[i] = a[n-i-1];\\n            a[n-i-1] = temp;\\n        }\\n    }\\n    void rotate(int nums[], int n, int k) {\\n        k = k%n;\\n        R(nums,n-k);\\n        R(nums+n-k,k);\\n        R(nums,n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54481,
                "title": "my-accepted-python-solution-in-o-1-space-and-o-n-time",
                "content": "    class Solution:\\n    # @param nums, a list of integer\\n    # @param k, num of steps\\n    # @return nothing, please modify the nums list in-place.\\n    def rotate(self, nums, k):\\n\\t\\tk %= len(nums)\\n\\t\\tdef transpose(nums, lo, hi):\\n\\t\\t\\tif lo >= hi:\\n\\t\\t\\t\\treturn\\n\\t\\t\\twhile lo < hi:\\n\\t\\t\\t\\tnums[lo], nums[hi - 1] = (nums[hi - 1], nums[lo])\\n\\t\\t\\t\\tlo += 1\\n\\t\\t\\t\\thi -= 1\\n\\t\\tlength = len(nums)\\n\\t\\tk %= length\\n\\t\\ttranspose(nums, 0, length - k)\\n\\t\\ttranspose(nums, length - k, length)\\n\\t\\ttranspose(nums, 0, length)\\n\\n\\nThe rationale is ***Matrix Transposition***: ((a^tr)(b^tr))^tr = ba\\n\\n\\n***ab*** is the source list, ***ba*** is the target. So we just transpose ***a***, then transpose ***b***, finally transpose ***(a^tr)(b^tr)***, as a result, we get the result ***ba***.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param nums, a list of integer\\n    # @param k, num of steps\\n    # @return nothing, please modify the nums list in-place.\\n    def rotate(self, nums, k):\\n\\t\\tk %= len(nums)\\n\\t\\tdef transpose(nums, lo, hi):\\n\\t\\t\\tif lo >= hi:\\n\\t\\t\\t\\treturn\\n\\t\\t\\twhile lo < hi:\\n\\t\\t\\t\\tnums[lo], nums[hi - 1] = (nums[hi - 1], nums[lo])\\n\\t\\t\\t\\tlo += 1\\n\\t\\t\\t\\thi -= 1\\n\\t\\tlength = len(nums)\\n\\t\\tk %= length\\n\\t\\ttranspose(nums, 0, length - k)\\n\\t\\ttranspose(nums, length - k, length)\\n\\t\\ttranspose(nums, 0, length)\\n\\n\\nThe rationale is ***Matrix Transposition***: ((a^tr)(b^tr))^tr = ba\\n\\n\\n***ab*** is the source list, ***ba*** is the target. So we just transpose ***a***, then transpose ***b***, finally transpose ***(a^tr)(b^tr)***, as a result, we get the result ***ba***.",
                "codeTag": "Java"
            },
            {
                "id": 3196739,
                "title": "tc-o-n-sc-o-1-efficient-rotation-of-an-array-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo rotate an array by k steps, we can $$reverse$$ the $$entire$$ array first, then $$reverse$$ the $$first$$ $$k$$ elements, and finally reverse the remaining i.e $$(k-1)$$ to $$len(array)$$ elements to obtain the required $$rotated$$ array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Make $$k$$ = $$k$$ % $$len(nums)$$ because whatever $$k$$ value is that is greater than length of the array we only need to rotate $$k$$ % $$len(array)$$ and also to avoid list index out range errors.\\n2. For example let\\'s say array = [1,2,3] and $$k$$ = $$4$$ after rotating $$4$$ times resulting array = [2,3,1] which is same as $$k$$%$$3$$ $$(len(array))$$ i.e $$1$$ rotation.\\n2. Define a helper function called $$reverse$$ which takes a $$left$$ index, $$right$$ index, and $$array$$ as arguments. The function reverses the array $$in$$ $$place$$ for the $$specified$$ range.\\n3. Reverse the $$entire$$ array by calling $$reverse$$ function with $$left$$ index as $$0$$ and $$right$$ index as $$len(nums)-1$$.\\n4. Reverse the $$first$$ $$k$$ elements of the array by calling $$reverse$$ function with $$left$$ index as $$0$$ and $$right$$ index as $$k-1$$.\\n5. Reverse the remaining elements of the $$array$$ by calling $$reverse$$ function with $$left$$ index as $$k$$ and $$right$$ index as $$len(nums)-1$$.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nThe time complexity of the algorithm is O(n) because we are \\nreversing the array three times which takes linear time.\\n```\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nThe space complexity of the algorithm is O(1) because we are not\\nusing any extra space except for some variables.\\n```\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)   #calculate k such that it is less than length of the array\\n        def reverse(left,right,nums):\\n            while left <= right:\\n                nums[left], nums[right] = nums[right], nums[left]\\n                left, right = left+1, right-1\\n        reverse(0, len(nums)-1, nums)   #reverse the entire array\\n        reverse(0, k-1, nums)   #reverse the first k elements\\n        reverse(k, len(nums)-1, nums)   #reverse the remaining elements\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nThe time complexity of the algorithm is O(n) because we are \\nreversing the array three times which takes linear time.\\n```\n```\\nThe space complexity of the algorithm is O(1) because we are not\\nusing any extra space except for some variables.\\n```\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)   #calculate k such that it is less than length of the array\\n        def reverse(left,right,nums):\\n            while left <= right:\\n                nums[left], nums[right] = nums[right], nums[left]\\n                left, right = left+1, right-1\\n        reverse(0, len(nums)-1, nums)   #reverse the entire array\\n        reverse(0, k-1, nums)   #reverse the first k elements\\n        reverse(k, len(nums)-1, nums)   #reverse the remaining elements\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172485,
                "title": "3-approaches-easy-solution-c-4-lines-of-code",
                "content": "# Multiple Methods\\n\\n### TTime Complexity O(N), Space O(N)\\n\\n# Code\\n```\\n void rotate(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        if(k>=n){\\n            k = k%n;\\n        }\\n        \\n        \\n        vector<int> newarr(n,0);\\n     int c = 0;\\n       for(int i=n-k;i<n;i++){\\n           newarr[c++] = nums[i];\\n       }\\n        \\n        for(int i=0;i<n-k;i++){\\n            newarr[c++] = nums[i];\\n        }\\n    \\n        for(int i =0 ;i<n;i++){\\n            nums[i] = newarr[i];\\n        }\\n     return;\\n```\\n\\n### Time Complexity O(N), Space O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rev(vector<int>& arr, int start, int end){\\n        while(start<=end){\\n            swap(arr[start++],arr[end--]);\\n        }\\n    }\\n    void rotate(vector<int>& arr, int k) {\\n        int n = size(arr);\\n        k = k%n;\\n        rev(arr,n-k,n-1);\\n        rev(arr,0,n-k-1);\\n        rev(arr,0,n-1);\\n        return;\\n\\t} \\n};\\n```\\n### Using In-built Reverse Function\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %=nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n    }\\n};\\n```\\n#### Please UPVOTE if you liked the solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n void rotate(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        if(k>=n){\\n            k = k%n;\\n        }\\n        \\n        \\n        vector<int> newarr(n,0);\\n     int c = 0;\\n       for(int i=n-k;i<n;i++){\\n           newarr[c++] = nums[i];\\n       }\\n        \\n        for(int i=0;i<n-k;i++){\\n            newarr[c++] = nums[i];\\n        }\\n    \\n        for(int i =0 ;i<n;i++){\\n            nums[i] = newarr[i];\\n        }\\n     return;\\n```\n```\\nclass Solution {\\npublic:\\n    void rev(vector<int>& arr, int start, int end){\\n        while(start<=end){\\n            swap(arr[start++],arr[end--]);\\n        }\\n    }\\n    void rotate(vector<int>& arr, int k) {\\n        int n = size(arr);\\n        k = k%n;\\n        rev(arr,n-k,n-1);\\n        rev(arr,0,n-k-1);\\n        rev(arr,0,n-1);\\n        return;\\n\\t} \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %=nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984833,
                "title": "python-solution-explained-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe first compute rotation since k could be greater than the length of the array, we can find the modulo of k to length (` k % len(nums)`) of array. this gives us the rotation without rotating it more than once.\\n\\nFinaly we can splice the two halves and `swap` them. \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if k == 0:\\n            return nums\\n        \\n        # compute rotation\\n        k = k % len(nums)\\n        lenght = len(nums)\\n        \\n        #swap positions\\n        nums[lenght-k:], nums[:lenght-k] = nums[:lenght-k],nums[lenght-k:]\\n        # return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if k == 0:\\n            return nums\\n        \\n        # compute rotation\\n        k = k % len(nums)\\n        lenght = len(nums)\\n        \\n        #swap positions\\n        nums[lenght-k:], nums[:lenght-k] = nums[:lenght-k],nums[lenght-k:]\\n        # return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875064,
                "title": "easiest-faang-method-ever",
                "content": "\\n\\n# \\uD83D\\uDCA8Complexity :-\\n- Time complexity: O(n) + O(n) + O(n) = O(3n) ~ O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# ***Please Upvote if it Helps :)***\\n\\n# \\uD83D\\uDCA8Code :-\\n# **\\u26A1Method 1 => TC: O(n) SC:O(1)**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```\\n# **\\u26A1Method-2 => TC: O(n) SC:O(k)**\\nThis method throws TLE error for 1 case !\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int count=0;\\n        k=k%nums.size();\\n        for(int i=nums.size()-1;count<k;){\\n            nums.emplace(nums.begin(),nums[i]);\\n            nums.pop_back();\\n            count++;\\n        }\\n    }\\n};\\n```\\n# ***Please Upvote if it Helps :)***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int count=0;\\n        k=k%nums.size();\\n        for(int i=nums.size()-1;count<k;){\\n            nums.emplace(nums.begin(),nums[i]);\\n            nums.pop_back();\\n            count++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566915,
                "title": "c-too-easy-cool-soln",
                "content": "void rotate(vector<int>& nums, int k) {\\n        \\n        vector<int> temp(nums.size());\\n        \\n        for(int i = 0;i < nums.size(); i++) {\\n            \\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }\\n\\tPlz upvote if you find it helpful !!! warna koi na, chill scene. \\n\\tpls share better approach if you have any...",
                "solutionTags": [
                    "C"
                ],
                "code": "void rotate(vector<int>& nums, int k) {\\n        \\n        vector<int> temp(nums.size());\\n        \\n        for(int i = 0;i < nums.size(); i++) {\\n            \\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }\\n\\tPlz upvote if you find it helpful !!! warna koi na, chill scene. \\n\\tpls share better approach if you have any...",
                "codeTag": "Unknown"
            },
            {
                "id": 2460257,
                "title": "o-1-space-complexity-solution",
                "content": "**Plzz Upvote if you find it helpful**\\n```\\nclass Solution {\\n    public void rotate(int[] arr, int d) {\\n    \\n         /*\\n        Reversal algorithm For ArrayRotation\\n        1. Reverse the first part\\n        2. Reverse last part\\n        3. Reverse the whole array.\\n        */\\n        int n = arr.length;\\n        d= d%n;\\n        reverse(arr,0,n-d);\\n        reverse(arr,n-d,n);\\n        reverse(arr,0,n);\\n    \\n    }   \\n  \\n     void reverse(int []arr,int start, int end){\\n        int j = end-1;\\n        for(int i= start;i<j;i++){\\n            int temp = arr[i];\\n            arr[i]= arr[j];\\n            arr[j]= temp;\\n            j--;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] arr, int d) {\\n    \\n         /*\\n        Reversal algorithm For ArrayRotation\\n        1. Reverse the first part\\n        2. Reverse last part\\n        3. Reverse the whole array.\\n        */\\n        int n = arr.length;\\n        d= d%n;\\n        reverse(arr,0,n-d);\\n        reverse(arr,n-d,n);\\n        reverse(arr,0,n);\\n    \\n    }   \\n  \\n     void reverse(int []arr,int start, int end){\\n        int j = end-1;\\n        for(int i= start;i<j;i++){\\n            int temp = arr[i];\\n            arr[i]= arr[j];\\n            arr[j]= temp;\\n            j--;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364200,
                "title": "fast-c-c-python-javascript-java-solution",
                "content": "Fast C++ || C || Python || Javascript || Java Solution\\nhttps://www.nileshblog.tech/2022/04/leet-code-rotate-array-c-python-javascript-java-solution/",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2348333,
                "title": "fast-java-javascript-c-python-solution",
                "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/leet-code-rotate-array-c-python-javascript-java-solution/",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2257586,
                "title": "3-ways-to-solve-this-problem-simple-easy-understand-c-o-n-time-and-o-1-space",
                "content": "okay first we need to insure that* k* shoud not be greater than n if *k >n* then we simply take module of this k\\n \\n`k=k%n;`\\n*let solve this question *\\n\\n**first method is O(k*n) time and O(1) space**\\n![image](https://assets.leetcode.com/users/images/99b471eb-4789-46f3-b8f6-4aea3aa38def_1657349607.591481.png)\\n\\n we will create a function which rotate a array by one.\\n and we call this function by k times in our main function\\n```\\n    void rotatebyone(vector<int>&nums){\\n        int n=nums.size();\\n        int temp=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            nums[i+1]=nums[i];\\n        nums[0]=temp;\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        // first we need to insure that k<n\\n        k=k%n;\\n        for(int i=0;i<k;i++){\\n            rotatebyone(nums);\\n        }\\n   }\\n```\\n**now lets talk about O(n) time and O(n) space**\\n```\\n void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;// insuring that k<n\\n        vector<int>ans(n);// create ans array/vector\\n        int j=0;\\n\\t\\t//copy elements from n-k to n in our ans vector\\n        for(int i=n-k;i<n;i++){\\n            ans[j++]=nums[i];\\n        }\\n\\t\\t// copy elements form 0 to n-k\\n        for(int i=0;i<n-k;i++){\\n            ans[j++]=nums[i];\\n        }\\n       nums=ans;\\n    }\\n```\\n**third solution is O(n) time and O(1) space**\\nthe idea is simple first we reverse 0 to n-k element \\nafter that we reverse n-k to n and in the last we reverse whole array\\nand we get our ans\\n![image](https://assets.leetcode.com/users/images/b7cd48c5-dfdb-46fd-99f2-b85d34372b22_1657351951.3675656.png)\\n\\n```\\n    void reverseArray(vector<int>&nums,int i,int j){\\n        while(i<j){\\n            swap(nums[i++],nums[j--]);\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        reverseArray(nums,0,n-k-1);\\n        reverseArray(nums,n-k,n-1);\\n        reverseArray(nums,0,n-1);\\n    }\\n```\\nthnaks!\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n    void rotatebyone(vector<int>&nums){\\n        int n=nums.size();\\n        int temp=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            nums[i+1]=nums[i];\\n        nums[0]=temp;\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        // first we need to insure that k<n\\n        k=k%n;\\n        for(int i=0;i<k;i++){\\n            rotatebyone(nums);\\n        }\\n   }\\n```\n```\\n void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;// insuring that k<n\\n        vector<int>ans(n);// create ans array/vector\\n        int j=0;\\n\\t\\t//copy elements from n-k to n in our ans vector\\n        for(int i=n-k;i<n;i++){\\n            ans[j++]=nums[i];\\n        }\\n\\t\\t// copy elements form 0 to n-k\\n        for(int i=0;i<n-k;i++){\\n            ans[j++]=nums[i];\\n        }\\n       nums=ans;\\n    }\\n```\n```\\n    void reverseArray(vector<int>&nums,int i,int j){\\n        while(i<j){\\n            swap(nums[i++],nums[j--]);\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        reverseArray(nums,0,n-k-1);\\n        reverseArray(nums,n-k,n-1);\\n        reverseArray(nums,0,n-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730768,
                "title": "rotate-array-beginner-friendly-and-easy-to-understand",
                "content": "In this question we have been given an array and an integer .We to rotate k elements of the array.\\nIn this approach a reverse function is created in which array , starting index and ending index is passed.Then using swapping technique we are reversing the array.\\n\\n**Steps followed**\\n\\n1 ). In the main function first we are reversing the whole array.\\n2 ). Then starting from 0th index till k-1 th index we will reverse the array.\\n3 ). In the last step starting from kth index till end index we are reversing the array.\\n\\nHence we will reach out to the output.\\n\\n![image](https://assets.leetcode.com/users/images/588e3a64-320b-4311-9455-5685922ab470_1643525385.3704638.jpeg)\\n\\nHere is the code\\n\\n```\\nclass Solution {\\npublic:\\n    void reverse(vector<int>& nums,int start,int end){\\n        //creating a variable to stor one data\\n        int temp;\\n        while(start<end){   // traversing through the array\\n            \\n            //swappig first index with the last index\\n            temp = nums[start];\\n            nums[start]=nums[end];\\n            nums[end]=temp;\\n            \\n            //increasing starting index and decreasing ending index\\n            \\n            start++;\\n            end--;\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        //if k is greater than size then making it in the range of size\\n        k=k%n;\\n        \\n        //if k is 0 or only one element in array no need to rotate\\n        if(k==0 || n==1)\\n        return;\\n        \\n        reverse(nums,0,n-1);    // reversing the whole array\\n        reverse(nums,0,k-1);    //reversing first half of array\\n        reverse(nums,k,n-1);    //reversing second half of array\\n        \\n    } \\n};\\n```\\n\\nThis is a beginner friendly approach and easy to understand.\\n\\nPlease upvote if understand it \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverse(vector<int>& nums,int start,int end){\\n        //creating a variable to stor one data\\n        int temp;\\n        while(start<end){   // traversing through the array\\n            \\n            //swappig first index with the last index\\n            temp = nums[start];\\n            nums[start]=nums[end];\\n            nums[end]=temp;\\n            \\n            //increasing starting index and decreasing ending index\\n            \\n            start++;\\n            end--;\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        //if k is greater than size then making it in the range of size\\n        k=k%n;\\n        \\n        //if k is 0 or only one element in array no need to rotate\\n        if(k==0 || n==1)\\n        return;\\n        \\n        reverse(nums,0,n-1);    // reversing the whole array\\n        reverse(nums,0,k-1);    //reversing first half of array\\n        reverse(nums,k,n-1);    //reversing second half of array\\n        \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730029,
                "title": "java-0-ms-explained",
                "content": "**Method 1:**\\n>**T/S:** O(n)/O(n), where n = size(nums)\\n```\\npublic void rotateExtraSpace(int[] nums, int k) {\\n\\tvar rotated = nums.clone();\\n\\tvar n = nums.length;\\n\\tk %= n;\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tnums[(i + k) % n] = rotated[i];\\n}\\n```\\n**Method 2:** When an array is rotated k times to the right, k items from the end move to the front of the array and n - k items move to the end\\n```\\nSource: [1, 2, 3, 4, 5, 6, 7] | Target: [5, 6, 7, 1, 2, 3, 4], rotate k = 3 times\\n\\nStep 1: Reverse [0, n). This brings the last k items to the front and n - k items from the front to the end, but they\\'re all in reverse\\n0     k           n\\n[7, 6, 5, 4, 3, 2, 1]\\n\\nStep 2: Reverse [0, k)\\n 0     k           n\\n[5, 6, 7, 4, 3, 2, 1]\\n\\nStep 3: Reverse [k, n)\\n 0     k           n\\n[5, 6, 7, 1, 2, 3, 4]\\n\\n```\\n>**T/S:** O(n)/O(1)\\n```\\npublic void rotate(int[] nums, int k) {\\n\\tvar length = nums.length;\\n\\tk %= length--;\\n\\treverse(nums, 0, length);\\n\\treverse(nums, 0, k - 1);\\n\\treverse(nums, k, length);\\n}\\n\\nprivate void reverse(int[] nums, int start, int end) {\\n\\twhile (start < end) {\\n\\t\\tvar temp = nums[start];\\n\\t\\tnums[start++] = nums[end];\\n\\t\\tnums[end--] = temp;\\n\\t}\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void rotateExtraSpace(int[] nums, int k) {\\n\\tvar rotated = nums.clone();\\n\\tvar n = nums.length;\\n\\tk %= n;\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tnums[(i + k) % n] = rotated[i];\\n}\\n```\n```\\nSource: [1, 2, 3, 4, 5, 6, 7] | Target: [5, 6, 7, 1, 2, 3, 4], rotate k = 3 times\\n\\nStep 1: Reverse [0, n). This brings the last k items to the front and n - k items from the front to the end, but they\\'re all in reverse\\n0     k           n\\n[7, 6, 5, 4, 3, 2, 1]\\n\\nStep 2: Reverse [0, k)\\n 0     k           n\\n[5, 6, 7, 4, 3, 2, 1]\\n\\nStep 3: Reverse [k, n)\\n 0     k           n\\n[5, 6, 7, 1, 2, 3, 4]\\n\\n```\n```\\npublic void rotate(int[] nums, int k) {\\n\\tvar length = nums.length;\\n\\tk %= length--;\\n\\treverse(nums, 0, length);\\n\\treverse(nums, 0, k - 1);\\n\\treverse(nums, k, length);\\n}\\n\\nprivate void reverse(int[] nums, int start, int end) {\\n\\twhile (start < end) {\\n\\t\\tvar temp = nums[start];\\n\\t\\tnums[start++] = nums[end];\\n\\t\\tnums[end--] = temp;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668690,
                "title": "c-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp[(i+k)%nums.size()]=nums[i];\\n        }\\n                                           \\n          nums=temp;                               \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp[(i+k)%nums.size()]=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1467132,
                "title": "easy-c-solution-using-reversal-algorithm-o-n",
                "content": "class Solution {\\npublic:\\n    \\n    void reverse(vector<int>&nums,int low,int high)\\n    {\\n        while(low<high){\\n            swap(nums[low],nums[high]);\\n            low++;\\n            high--;\\n        }    \\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        long long int n = nums.size();\\n        reverse(nums,0,n-k-1);\\n        reverse(nums,n-k,n-1);\\n        reverse(nums,0,n-1);    \\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void reverse(vector<int>&nums,int low,int high)\\n    {\\n        while(low<high){\\n            swap(nums[low],nums[high]);\\n            low++;\\n            high--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1461106,
                "title": "c-easy-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        if(k==0) return;\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        if(k==0) return;\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426336,
                "title": "java-o-n-time-o-1-space-in-depth-explanation",
                "content": "The concept of this problem is very simple, but the catch here is to try and do it in linear time and constant space. \\n\\n**Naive Solution**\\nWe can start of with the simple naive approach by actually rotating the array ```k``` times.\\n\\n```\\nclass Solutions{\\n    public void rotate(int[] nums, int k){\\n\\t    for(int i = 0; i < k; i++){\\n\\t\\t    rotation(nums);\\n\\t\\t}\\n\\t}\\n    public void rotation(int[] nums){\\n\\t    int temp = nums[nums.length - 1];\\n\\t\\tfor(int i = nums.length - 1; i > 0; i--){\\n\\t\\t    nums[i] = nums[i-1];\\n\\t    }\\n\\t\\tnums[0] = temp;\\n\\t}\\n}\\n```\\nThis solution does the trick, but is very slow with an ```O(kn)``` run time. In cases where the array is very large and ```k``` is very large, the solution takes too long, so this solution would not be accepted.\\n\\n**Slight Improvement**\\nThere is still one thing we can do to this solution to speed it up. Notice how after the array is rotated ```nums.length ``` times, it reverts to the original array. This means instead of doing ```k``` rotations, we do ```k % nums.length``` rotations. Since this bounds the number of rotations to the interval ```[0, n-1]```, this solution now has a run time of ```O(n^2)``` in the worst case. \\n\\nEven after doing this, the inputs can still be large enough to a point where ```O(n^2)``` is still too slow. So we need to do better.\\n\\n\\n**Optimal Solution**\\nFor the sake of simplicty, let ```k = k % nums.length```\\n\\nIn order to do this problem in ```O(n)``` time, we can make a few observations about how the rotated array differs from the original. Let\\'s use the example given in the problem ```[1, 2, 3, 4, 5, 6, 7]``` and ```k = 3```. After rotating, the array becomes ```[5, 6, 7, 1, 2, 3, 4]```. \\n\\nNotice how essentially, the original array is broken up into 2 blocks, a block of size ```k``` consisting of the last ```k``` elements, and a block of size ```nums.length - k``` elments. These two blocks are switched in the rotated array. So how can we swap these two blocks with constant space?\\n\\nNotice that the element in the ```nums.length - k``` index is now at the front, and the elements following the ```nums.length - k```th element also follow it at the front of the array. We can move this entire block of elements by reversing the subarray from ```[nums.length - k, nums.length - 1]```, then reverse the entire array. Using the array in the example, after these 2 reversals, it becomes :\\n\\n```[5, 6, 7, 4, 3, 2, 1]```. \\n\\nNow notice that the only thing different from this and the rotated array is that the elements from the ```k```th index to the end are reversed. So after reversing those elements, the array becomes ```[5, 6, 7, 1, 2, 3, 4]```, which is the array we were looking for. \\n\\nSince the reverse functions runs in ```O(n)``` time and is done in-place, and is called exactly 3 times, the whole algorithm runs in ```O(n)``` time with ```O(1)``` extra space. \\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        reverse(nums, 0, nums.length - 1);\\n        reverse(nums, k, nums.length - 1);\\n    }\\n    \\n    public void reverse(int[] nums, int start, int end){\\n        while(start <= end){\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n\\nHope this helps!!",
                "solutionTags": [],
                "code": "```k```\n```\\nclass Solutions{\\n    public void rotate(int[] nums, int k){\\n\\t    for(int i = 0; i < k; i++){\\n\\t\\t    rotation(nums);\\n\\t\\t}\\n\\t}\\n    public void rotation(int[] nums){\\n\\t    int temp = nums[nums.length - 1];\\n\\t\\tfor(int i = nums.length - 1; i > 0; i--){\\n\\t\\t    nums[i] = nums[i-1];\\n\\t    }\\n\\t\\tnums[0] = temp;\\n\\t}\\n}\\n```\n```O(kn)```\n```k```\n```nums.length ```\n```k```\n```k % nums.length```\n```[0, n-1]```\n```O(n^2)```\n```O(n^2)```\n```k = k % nums.length```\n```O(n)```\n```[1, 2, 3, 4, 5, 6, 7]```\n```k = 3```\n```[5, 6, 7, 1, 2, 3, 4]```\n```k```\n```k```\n```nums.length - k```\n```nums.length - k```\n```nums.length - k```\n```[nums.length - k, nums.length - 1]```\n```[5, 6, 7, 4, 3, 2, 1]```\n```k```\n```[5, 6, 7, 1, 2, 3, 4]```\n```O(n)```\n```O(n)```\n```O(1)```\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        reverse(nums, 0, nums.length - 1);\\n        reverse(nums, k, nums.length - 1);\\n    }\\n    \\n    public void reverse(int[] nums, int start, int end){\\n        while(start <= end){\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346844,
                "title": "c-easy-4-lines-solution",
                "content": "this is my c++ solution  , hope you find it helpful , if you do  , upvote!\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\nk=k%nums.size();\\nreverse(nums.begin() , nums.end());\\nreverse(nums.begin() , nums.begin()+k);\\nreverse(nums.begin()+k , nums.end());\\n }\\n};\\n```\\ndont forget to upvote if it helps you in any way , im trying to get through collage :/",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\nk=k%nums.size();\\nreverse(nums.begin() , nums.end());\\nreverse(nums.begin() , nums.begin()+k);\\nreverse(nums.begin()+k , nums.end());\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770606,
                "title": "c-solution",
                "content": "```\\nvoid rotate(int* nums, int numsSize, int k)\\n{\\n\\tsize_t tmp;\\n\\tsize_t i;\\n\\tfor(i = 0; i < numsSize / 2; i++)\\n\\t{\\n\\t\\t// reverse array\\n\\t\\ttmp = nums[i];\\n\\t\\tnums[i] = nums[numsSize - i - 1];\\n\\t\\tnums[numsSize - i - 1] = tmp;\\n\\t}\\t    \\n\\t \\n\\tk %= numsSize;\\n    \\n\\tfor(i = 0; i < k / 2; i++)\\n\\t{\\n\\t\\t// reverse first k elements\\n\\t\\ttmp = nums[i];\\n\\t\\tnums[i] = nums[k - i - 1];\\n\\t\\tnums[k - i - 1] = tmp;\\n\\t\\t\\n\\t}\\n\\n\\n\\tfor(i = k; i < (numsSize - k) / 2 + k ; i++)\\n\\t{\\n\\t\\t// reverse last (numsSize - k) elements\\n\\t\\ttmp = nums[i];\\n\\t\\tnums[i] = nums[numsSize - i + k - 1];\\n\\t\\tnums[numsSize - i + k - 1] = tmp;\\n\\t}\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid rotate(int* nums, int numsSize, int k)\\n{\\n\\tsize_t tmp;\\n\\tsize_t i;\\n\\tfor(i = 0; i < numsSize / 2; i++)\\n\\t{\\n\\t\\t// reverse array\\n\\t\\ttmp = nums[i];\\n\\t\\tnums[i] = nums[numsSize - i - 1];\\n\\t\\tnums[numsSize - i - 1] = tmp;\\n\\t}\\t    \\n\\t \\n\\tk %= numsSize;\\n    \\n\\tfor(i = 0; i < k / 2; i++)\\n\\t{\\n\\t\\t// reverse first k elements\\n\\t\\ttmp = nums[i];\\n\\t\\tnums[i] = nums[k - i - 1];\\n\\t\\tnums[k - i - 1] = tmp;\\n\\t\\t\\n\\t}\\n\\n\\n\\tfor(i = k; i < (numsSize - k) / 2 + k ; i++)\\n\\t{\\n\\t\\t// reverse last (numsSize - k) elements\\n\\t\\ttmp = nums[i];\\n\\t\\tnums[i] = nums[numsSize - i + k - 1];\\n\\t\\tnums[numsSize - i + k - 1] = tmp;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 291388,
                "title": "javascript-o-n-space-o-1-space-special-trick",
                "content": "if you reverse the entire array to start, and then reverse the k portion at the beginning and reverse the remaining, you will achieve the k rotation.\\n\\n```\\nfunction rotate(nums, k) {\\n  if (!nums.length) return [];\\n\\n  if (k > 0) {\\n    k = k % nums.length;\\n    reverse(nums, 0, nums.length - 1);\\n    reverse(nums, 0, k - 1);\\n    reverse(nums, k, nums.length - 1);\\n  }\\n\\n  return nums;\\n};\\n\\nfunction reverse(arr, start, end) {\\n  if (!arr || !arr.length || start >= end) return;\\n\\n  while (start < end) {\\n    let temp = arr[start];\\n    arr[start] = arr[end];\\n    arr[end] = temp;\\n    start++, end--;\\n  }\\n\\n  return arr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction rotate(nums, k) {\\n  if (!nums.length) return [];\\n\\n  if (k > 0) {\\n    k = k % nums.length;\\n    reverse(nums, 0, nums.length - 1);\\n    reverse(nums, 0, k - 1);\\n    reverse(nums, k, nums.length - 1);\\n  }\\n\\n  return nums;\\n};\\n\\nfunction reverse(arr, start, end) {\\n  if (!arr || !arr.length || start >= end) return;\\n\\n  while (start < end) {\\n    let temp = arr[start];\\n    arr[start] = arr[end];\\n    arr[end] = temp;\\n    start++, end--;\\n  }\\n\\n  return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 146061,
                "title": "clean-python",
                "content": "\\n```\\nclass Solution:\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        while k>0:\\n            nums.insert(0,nums.pop())\\n            k-=1\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        while k>0:\\n            nums.insert(0,nums.pop())\\n            k-=1\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 54490,
                "title": "java-o-1-space-o-n-time-with-detailed-explanations",
                "content": "If you have difficulty understanding the following code, check [this link][1] for detailed explanation.\\n\\n    public void rotate(int[] nums, int k) {\\n    \\tint L=nums.length, counter=0, currentLoc=0, starti=0, prevVal=nums[currentLoc];\\n    \\tk = k%L;\\n    \\twhile(counter++<L) {\\n    \\t\\tif(currentLoc>=L && currentLoc%L==starti) { // this handles the case when currentLoc moves back to where started.\\n    \\t\\t    currentLoc = ++starti; \\n    \\t\\t    prevVal=nums[currentLoc];\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tint nextLoc = (currentLoc+k)%L; // get index of next location\\n    \\t\\tint nextVal = nums[nextLoc]; // get value at next location\\n    \\t\\tnums[nextLoc] = prevVal; // update value at next location\\n    \\t\\tprevVal = nextVal; // update previous value\\n\\n    \\t\\tcurrentLoc += k; // move current to next location\\n    \\t}\\n    }\\n\\n\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java/commit/520f505ccc3f9e5512d8ae2d6824ec9833b71b5c",
                "solutionTags": [
                    "Java"
                ],
                "code": "If you have difficulty understanding the following code, check [this link][1] for detailed explanation.\\n\\n    public void rotate(int[] nums, int k) {\\n    \\tint L=nums.length, counter=0, currentLoc=0, starti=0, prevVal=nums[currentLoc];\\n    \\tk = k%L;\\n    \\twhile(counter++<L) {\\n    \\t\\tif(currentLoc>=L && currentLoc%L==starti) { // this handles the case when currentLoc moves back to where started.\\n    \\t\\t    currentLoc = ++starti; \\n    \\t\\t    prevVal=nums[currentLoc];\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tint nextLoc = (currentLoc+k)%L; // get index of next location\\n    \\t\\tint nextVal = nums[nextLoc]; // get value at next location\\n    \\t\\tnums[nextLoc] = prevVal; // update value at next location\\n    \\t\\tprevVal = nextVal; // update previous value\\n\\n    \\t\\tcurrentLoc += k; // move current to next location\\n    \\t}\\n    }\\n\\n\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java/commit/520f505ccc3f9e5512d8ae2d6824ec9833b71b5c",
                "codeTag": "Unknown"
            },
            {
                "id": 54587,
                "title": "my-two-o-n-solutions-with-o-1-extra-memory-i-don-t-know-the-third-one-yet-any-idea",
                "content": "    void rotate(int nums[], int n, int k) {\\n        if (n == 0)\\n            return;\\n\\n        k %= n;\\n        if (k == 0)\\n            return;\\n\\n        // Method 1, \\n        // reverse(nums, 0, n-k-1);\\n        // reverse(nums, n-k, n-1);\\n        // reverse(nums, 0, n-1);\\n\\n        // Method 2. Swap int to its position directly, \\n        // and store the next one that need be swapped. \\n        // One tricky thing is to to avoid swapping the same int.\\n        int idx = 0;\\n        int distance = 0;\\n        int cur = nums[idx];\\n        for (int i = 0; i < n; ++i) {\\n            int next = (idx+k)%n;\\n            int temp = nums[next];\\n            nums[next] = cur;\\n            idx = next;\\n            cur = temp;\\n\\n            // If distance is back. Move it one step forward.\\n            distance = (distance+k)%n;\\n            if (distance == 0) {\\n                idx = (idx+1)%n;\\n                cur = nums[idx];\\n            }\\n        }\\n    }\\n\\n    void reverse(int nums[], int begin, int end) {\\n        while (begin < end) {\\n            swap (nums[begin++], nums[end--]);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    void rotate(int nums[], int n, int k) {\\n        if (n == 0)\\n            return;\\n\\n        k %= n;\\n        if (k == 0)\\n            return;\\n\\n        // Method 1, \\n        // reverse(nums, 0, n-k-1);\\n        // reverse(nums, n-k, n-1);\\n        // reverse(nums, 0, n-1);\\n\\n        // Method 2. Swap int to its position directly, \\n        // and store the next one that need be swapped. \\n        // One tricky thing is to to avoid swapping the same int.\\n        int idx = 0;\\n        int distance = 0;\\n        int cur = nums[idx];\\n        for (int i = 0; i < n; ++i) {\\n            int next = (idx+k)%n;\\n            int temp = nums[next];\\n            nums[next] = cur;\\n            idx = next;\\n            cur = temp;\\n\\n            // If distance is back. Move it one step forward.\\n            distance = (distance+k)%n;\\n            if (distance == 0) {\\n                idx = (idx+1)%n;\\n                cur = nums[idx];\\n            }\\n        }\\n    }\\n\\n    void reverse(int nums[], int begin, int end) {\\n        while (begin < end) {\\n            swap (nums[begin++], nums[end--]);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4036034,
                "title": "accepted-java-code-beats-100",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java\\n -- | Details | --\\n--- | --- | ---:\\n**Runtime** | **0** *ms* | *Beats* **100%**\\n**Memory** | **56** *MB* | *Beats* **50%**\\n```\\nclass Solution {\\n    public void rev(int[] nums,int l,int r){\\n        while(l<r){\\n            // swap\\n            nums[l]=nums[l]+nums[r]-(nums[r]=nums[l]);\\n            l++;r--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        k%=nums.length;\\n        rev(nums,0,nums.length-1);\\n        rev(nums,0,k-1);\\n        rev(nums,k,nums.length-1);\\n\\n    }\\n}\\n```\\n## UPVOTE : |\\n![waiting-tom-and-jerry.gif](https://assets.leetcode.com/users/images/4f0cc754-71e1-4cfc-816b-36a94c20b17f_1678366238.9546802.gif)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void rev(int[] nums,int l,int r){\\n        while(l<r){\\n            // swap\\n            nums[l]=nums[l]+nums[r]-(nums[r]=nums[l]);\\n            l++;r--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        k%=nums.length;\\n        rev(nums,0,nums.length-1);\\n        rev(nums,0,k-1);\\n        rev(nums,k,nums.length-1);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573071,
                "title": "python-beats-99-98",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code first creates an empty list `temp` to hold the rotated elements. It then calculates the effective rotation steps `k` by taking the modulus of `k` with the length of `nums` to handle cases where `k` is larger than the length of `nums`.\\n\\nNext, it assigns the last `k` elements of `nums` to `temp` using slicing `nums[-k:]`. This captures the elements that will be moved to the front of the list after rotation.\\n\\nThen, it updates the `nums` list by assigning the elements from index `k` onwards (`nums[k:]`) to the elements from index 0 to `k-1` in `nums` (`nums[:-k]`). This shifts the remaining elements to the right, making space for the rotated elements.\\n\\nFinally, it assigns the elements in `temp` to the first `k` positions in `nums` (`nums[:k]`). This places the rotated elements at the front of the list.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. O(n) -->\\n\\n- Space complexity: `O(k)`\\n<!-- Add your space complexity here, e.g. O(n) -->\\n\\n# Code\\nFollowing code beats 94%\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        `temp` = []\\n        k = k % len(nums)\\n        `temp` = nums[-k:]\\n        nums[k:] = nums[:-k]\\n        nums[:k] = `temp`\\n```\\n\\n# Optimization proposed by @drjasonharrison\\nWe need to compute the remainder only if `k` >= `n`, because when `k` is less than `n`, `k % n` is still equal to `k`.\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        `temp` = []\\n        if `k` >= len(nums):\\n            k = k % len(nums)\\n        `temp` = nums[-k:]\\n        nums[k:] = nums[:-k]\\n        nums[:k] = `temp`\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        `temp` = []\\n        k = k % len(nums)\\n        `temp` = nums[-k:]\\n        nums[k:] = nums[:-k]\\n        nums[:k] = `temp`\\n```\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        `temp` = []\\n        if `k` >= len(nums):\\n            k = k % len(nums)\\n        `temp` = nums[-k:]\\n        nums[k:] = nums[:-k]\\n        nums[:k] = `temp`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484143,
                "title": "easy-solution-solved-in-o-1-space-beginner-friendly-approach",
                "content": "## Read intuition and approach, and try to code it own, at last see code\\n# Intuition\\nWe have to rotate right, so we rotate from last...\\n\\n# Approach\\n1. reverse last k numbers in array.\\n2. reverse araay from 0 to n-k numbers.\\n3. reverse whole array from 0 to end..\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin()+n-k, nums.end()); // reverse last k numbers\\n        reverse(nums.begin(), nums.begin()+n-k); //reverse first n-k numbers\\n        reverse(nums.begin(), nums.end()); // reverse whole array for required answer\\n    }\\n};\\n```\\nif you like solution, then plz \\uD83D\\uDE4F upvote this solution..",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin()+n-k, nums.end()); // reverse last k numbers\\n        reverse(nums.begin(), nums.begin()+n-k); //reverse first n-k numbers\\n        reverse(nums.begin(), nums.end()); // reverse whole array for required answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230089,
                "title": "one-line-very-easy-solution-python",
                "content": "\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866425,
                "title": "java-optimize-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\noptimize Soluation with time complexity O(N) & Space complexity O(1)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this question just you have to first reverse the whole array and then  you have to rotate array with index 0 to k-1 and we have to rotate array from k to arr.length\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[] arr, int k) {\\n\\n        k = k%arr.length;\\n        reverseArray(0 ,  arr.length-1 ,  arr);\\n\\t    reverseArray(0 ,  k-1 ,  arr);\\n\\t    reverseArray(k,  arr.length-1 ,  arr);\\n\\n        System.out.println(arr);\\n\\n\\n        \\n    }\\n\\n    public static void  reverseArray(int i , int j , int[] arr){\\n\\n\\t    while(i<j){\\n\\t            \\n\\t            \\n\\t        int temp = arr[i];\\n\\t        arr[i] = arr[j];\\n\\t        arr[j]= temp;\\n\\t            \\n\\t        i++;\\n\\t        j--;\\n\\t            \\n\\t    }\\n\\t        \\n\\t        \\n\\t        \\n\\t        \\n\\t}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] arr, int k) {\\n\\n        k = k%arr.length;\\n        reverseArray(0 ,  arr.length-1 ,  arr);\\n\\t    reverseArray(0 ,  k-1 ,  arr);\\n\\t    reverseArray(k,  arr.length-1 ,  arr);\\n\\n        System.out.println(arr);\\n\\n\\n        \\n    }\\n\\n    public static void  reverseArray(int i , int j , int[] arr){\\n\\n\\t    while(i<j){\\n\\t            \\n\\t            \\n\\t        int temp = arr[i];\\n\\t        arr[i] = arr[j];\\n\\t        arr[j]= temp;\\n\\t            \\n\\t        i++;\\n\\t        j--;\\n\\t            \\n\\t    }\\n\\t        \\n\\t        \\n\\t        \\n\\t        \\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271395,
                "title": "very-easy-with-intutuion-c",
                "content": "**Please Upvote if understood**\\n\\n```\\n// suppose nums: 1 2 3 4 5 6 7, k = 3\\n        int n = nums.size();\\n                \\n        k = k%n;\\n        \\n```\\n        reverse(nums.begin(),nums.end());\\n        // 7 6 5 4 3 2 1 \\n        // we need to reverse from start to k and k to end.\\n        reverse(nums.begin(),nums.begin() + k);\\n        // 5 6 7 4 3 2 1\\n        reverse(nums.begin() + k,nums.end());\\n        // 5 6 7 1 2 3 4",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// suppose nums: 1 2 3 4 5 6 7, k = 3\\n        int n = nums.size();\\n                \\n        k = k%n;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2078308,
                "title": "python-two-solutions-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        #Approach 1\\n        for _ in range(k):\\n            nums.insert(0, nums.pop())\\n        \\n        #Approach 2\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        #Approach 1\\n        for _ in range(k):\\n            nums.insert(0, nums.pop())\\n        \\n        #Approach 2\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830990,
                "title": "rotate-array-time-o-n-space-o-1-with-proper-explanation",
                "content": "class Solution {\\n    \\n    //This solution is solved using reversal algorithm.\\n    \\n    //function for reversing the array element in the specified range\\n    public void reverse(int arr[],int low,int high){\\n        while(low<high){\\n            int temp = arr[low];\\n            arr[low] = arr[high];\\n            arr[high] = temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n==1){\\n            return;\\n        }\\n        //if(k>n) this will handle the cases\\n        k = k%n;\\n        \\n         reverse(nums,0,(n-k)-1);\\n         reverse(nums,n-k,n-1);\\n         reverse(nums,0,n-1);\\n        \\n    }\\n}\\n\\n**********************************************************************************************************************\\nIf you did not understood the concept. You can read the concept below.\\n\\nThe main idea of the reversal algorithm is :\\nWe divide the given array into two parts. Lets say A = arr[0,.....k-1]  and B = arr[k,.....n-1].\\n\\nAlgorithm:\\n\\n1. Reverse A.\\n2. Reverse B\\n3. Reverse the whole array to get the desired result;\\n\\n\\nLets understand this with an example. For rotating the array k places towards left(anticlockwise)----->for clockwise(right rotattion) the solution is mentioned above. You can try coding for anticlockwise rotation using the concept described here.\\n\\narray = [1,2,3,4,5,6,7]   k=2\\n\\nA = [1,2] and B = [3,4,5,6,7]\\n\\nstep1: reverse A :  [2,1,3,4,5,6,7]\\nstep2.reverse B: [2,1,7,6,5,4,3]\\nstep3: reverse the whole array. \\n\\nResultant array = [3,4,5,6,7,1,2]\\n\\n\\n********************************************************************************************************\\nIf it helped you kindly please upvote. Thank You Happy coding\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    \\n    //This solution is solved using reversal algorithm.\\n    \\n    //function for reversing the array element in the specified range\\n    public void reverse(int arr[],int low,int high){\\n        while(low<high){\\n            int temp = arr[low];\\n            arr[low] = arr[high];\\n            arr[high] = temp;\\n            low++;\\n            high--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1717742,
                "title": "c-2-approaches-easy-understanding",
                "content": "**APPROACH-1:**\\n\\n Takes extra space\\n\\n\\n\\t  \\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> res(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            res[(i+k)%n]=nums[i];\\n        }\\n        \\n        nums=res;  \\n    }\\n};\\n```\\n\\n**APPROACH-2:**\\n\\nEfficient approach , doesn\\'t take any extra space.\\n\\n```\\nclass Solution {\\npublic:\\n    void reverse(vector<int> &num,int low,int high)\\n    {\\n        while(low<high)\\n        {\\n            swap(num[low],num[high]);\\n            low++;\\n            high--;\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        reverse(nums,0,n-k-1);\\n        reverse(nums,n-k,n-1);\\n        reverse(nums,0,n-1);\\n    }\\n};\\n```\\n\\nDo upvote this...: )",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> res(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            res[(i+k)%n]=nums[i];\\n        }\\n        \\n        nums=res;  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverse(vector<int> &num,int low,int high)\\n    {\\n        while(low<high)\\n        {\\n            swap(num[low],num[high]);\\n            low++;\\n            high--;\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        reverse(nums,0,n-k-1);\\n        reverse(nums,n-k,n-1);\\n        reverse(nums,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709227,
                "title": "easy-c-solution-using-reverse-with-explaination",
                "content": "```\\n k=k%nums.size();\\n        // divide the array in two parts 0 to (length-k-1) AND length-k to length\\n\\t\\t// Eg. 1 2 3 4 5 6 7 if k=3 ans should be 5 6 7 1 2 3 4\\n        reverse(nums.begin(), nums.end()-k);// reverse the first half  4 3 2 1 , full array now- 4 3 2 1 5 6 7\\n        reverse(nums.end()-k,nums.end()); // reverse the second half 7 6 5  , full array now-  4 3 2 1 7 6 5\\n        reverse(nums.begin(), nums.end()); // reverse the whole array , full array now- 5 6 7 1 2 3 4\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n k=k%nums.size();\\n        // divide the array in two parts 0 to (length-k-1) AND length-k to length\\n\\t\\t// Eg. 1 2 3 4 5 6 7 if k=3 ans should be 5 6 7 1 2 3 4\\n        reverse(nums.begin(), nums.end()-k);// reverse the first half  4 3 2 1 , full array now- 4 3 2 1 5 6 7\\n        reverse(nums.end()-k,nums.end()); // reverse the second half 7 6 5  , full array now-  4 3 2 1 7 6 5\\n        reverse(nums.begin(), nums.end()); // reverse the whole array , full array now- 5 6 7 1 2 3 4\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676538,
                "title": "python-simple-reverse-solution",
                "content": "**Python :**\\n\\n```\\nclass Solution:\\n    def reverse(self, nums, start, end) -> None:\\n        while start < end: \\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n            \\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)\\n        self.reverse(nums,0, len(nums) - 1)\\n        self.reverse(nums, 0, k - 1)\\n        self.reverse(nums, k, len(nums) - 1)\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverse(self, nums, start, end) -> None:\\n        while start < end: \\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n            \\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)\\n        self.reverse(nums,0, len(nums) - 1)\\n        self.reverse(nums, 0, k - 1)\\n        self.reverse(nums, k, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663260,
                "title": "python-solution",
                "content": "Python solution: \\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        nums.reverse()\\n        for i in range(k):\\n            nums.append(nums[i])\\n        nums[:] = nums[k:]\\n        nums.reverse()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        nums.reverse()\\n        for i in range(k):\\n            nums.append(nums[i])\\n        nums[:] = nums[k:]\\n        nums.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642621,
                "title": "faster-than-100-javascript-atleast-on-first-run",
                "content": "```\\nvar rotate = function(nums, k) {\\n    if(k === 0) return nums\\n    let rotations = k % nums.length\\n    let tempArr = nums.splice(nums.length - rotations, rotations)\\n    return nums.unshift(...tempArr)\\n};\\n```\\n\\nGet remainder of k % nums.length, to get rid of all full-rotations you would have to do for bigger values.\\n\\nTake out the amount of rotations you have remaining from the back of the nums array.\\nStore in temporary array with original order intact thanks to splice().\\n\\nInsert it all back into the front of the original array with the temporary array.\\n\\nNot sure if there are other test-cases I should\\'ve tested for, but pretty pumped I figured this out!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function(nums, k) {\\n    if(k === 0) return nums\\n    let rotations = k % nums.length\\n    let tempArr = nums.splice(nums.length - rotations, rotations)\\n    return nums.unshift(...tempArr)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563149,
                "title": "c-o-n-solution-faster-than-99-67",
                "content": "```\\nvoid rotate(vector<int>& nums, int k) {\\n        k=nums.size()-k%nums.size();\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n        reverse(nums.begin(),nums.end());\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid rotate(vector<int>& nums, int k) {\\n        k=nums.size()-k%nums.size();\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n        reverse(nums.begin(),nums.end());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1558449,
                "title": "java-100-faster-solution-easy-and-explained",
                "content": "# JAVA SOLUTION @DeepakKumar\\n# In Case of Any Doubt Feel Free to ASK ....\\n\\n ```\\n/*\\n        Array Rotation Using Reversal Algorithm\\n        Step 1: reverse the Array from indices 0 to length-1\\n        Step 2: reverse the Array from indices 0 to k-1\\n        Step 3: reverse the Array from indices 0 to length-1\\n\\n        Example:\\n           let  arr is --> [ 1, 2, 3, 4, 5 ]      k = 2\\n\\n           index -->     0   k-1  k  3  length-1\\n                       [ 1,  2,  3,  4,  5 ]\\n\\n            Reversing from 0 to length -1\\n                      We get     [5,4,3,2,1]\\n            Reversing from 0 to k-1\\n                      We get     [4, 5, 3, 2, 1]\\n            Reversing from k to length-1\\n                      We get     [4, 5, 1, 2, 3]   --> RESULTANT Rotated Array\\n         */\\n```\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        reverse(nums, 0, nums.length-1);\\n        reverse(nums, 0, k-1);\\n        reverse(nums, k, nums.length-1);\\n    }\\n\\n    static void reverse(int [] nums, int start, int end){\\n        // reversing the Array Using two pointer Method\\n        while(start < end){\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n        Array Rotation Using Reversal Algorithm\\n        Step 1: reverse the Array from indices 0 to length-1\\n        Step 2: reverse the Array from indices 0 to k-1\\n        Step 3: reverse the Array from indices 0 to length-1\\n\\n        Example:\\n           let  arr is --> [ 1, 2, 3, 4, 5 ]      k = 2\\n\\n           index -->     0   k-1  k  3  length-1\\n                       [ 1,  2,  3,  4,  5 ]\\n\\n            Reversing from 0 to length -1\\n                      We get     [5,4,3,2,1]\\n            Reversing from 0 to k-1\\n                      We get     [4, 5, 3, 2, 1]\\n            Reversing from k to length-1\\n                      We get     [4, 5, 1, 2, 3]   --> RESULTANT Rotated Array\\n         */\\n```\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        reverse(nums, 0, nums.length-1);\\n        reverse(nums, 0, k-1);\\n        reverse(nums, k, nums.length-1);\\n    }\\n\\n    static void reverse(int [] nums, int start, int end){\\n        // reversing the Array Using two pointer Method\\n        while(start < end){\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529297,
                "title": "easyyyyyy-cpp-solution-with-picture-illustration",
                "content": "UPVOTE PLEASE \\uD83D\\uDE0A \\n\\n![image](https://assets.leetcode.com/users/images/64b42ea9-f49e-4978-bf98-dc799576a450_1634626183.3344586.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // a function to reverse from position lo to hi\\n    \\n    void reverse(vector<int>& n, int lo, int hi) {\\n        \\n        while(lo<=hi) {\\n            int t = n[lo];\\n            n[lo] = n[hi];\\n            n[hi] = t;\\n            lo++; hi--;\\n        }\\n        \\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// what if k is greater than n? \\n        k = k%n;\\n        \\n        // reverse the whole array\\n        reverse(nums,0,n-1);\\n        \\n        // reverse the first k elements\\n        reverse(nums,0,k-1);\\n        \\n        // reverse rest of the (n-k) elenebts\\n        reverse(nums,k,n-1);\\n        \\n        \\n        // there u go!\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // a function to reverse from position lo to hi\\n    \\n    void reverse(vector<int>& n, int lo, int hi) {\\n        \\n        while(lo<=hi) {\\n            int t = n[lo];\\n            n[lo] = n[hi];\\n            n[hi] = t;\\n            lo++; hi--;\\n        }\\n        \\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// what if k is greater than n? \\n        k = k%n;\\n        \\n        // reverse the whole array\\n        reverse(nums,0,n-1);\\n        \\n        // reverse the first k elements\\n        reverse(nums,0,k-1);\\n        \\n        // reverse rest of the (n-k) elenebts\\n        reverse(nums,k,n-1);\\n        \\n        \\n        // there u go!\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515960,
                "title": "java-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public int[] rotate(int[] nums, int k) {\\n        k = k % nums.length; //every number divisible by nums.length meaning it will go back to initial position, will only need to rotate  by the modulo\\n        reverse(nums, 0, nums.length - 1);  //reverse the whole array\\n        reverse(nums, 0, k -1); //reverse back the first k numbers to original order\\n        reverse(nums, k, nums.length  - 1); //reverse the remaining numbers  to original  order\\n        return nums;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end){\\n        while (start < end ){\\n            int  temp  = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] rotate(int[] nums, int k) {\\n        k = k % nums.length; //every number divisible by nums.length meaning it will go back to initial position, will only need to rotate  by the modulo\\n        reverse(nums, 0, nums.length - 1);  //reverse the whole array\\n        reverse(nums, 0, k -1); //reverse back the first k numbers to original order\\n        reverse(nums, k, nums.length  - 1); //reverse the remaining numbers  to original  order\\n        return nums;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end){\\n        while (start < end ){\\n            int  temp  = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1737179,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1564818,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1576312,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1566763,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1566543,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1569644,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1567132,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1565517,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1567394,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1565169,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1737179,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1564818,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1576312,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1566763,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1566543,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1569644,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1567132,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1565517,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1567394,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1565169,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1749563,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1567774,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1568187,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1567911,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1783664,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1566273,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1710887,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1688955,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1576581,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1567910,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1566408,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1565946,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1568788,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1570644,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1574819,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1990408,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1569717,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1573089,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1572666,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1571855,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1569005,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1955277,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1782449,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1704032,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1576984,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1576950,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1576934,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1574489,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1573724,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1573176,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1572523,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1572431,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1572350,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1571398,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1571400,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1571399,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1576672,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1575642,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1574089,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1571397,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 2072457,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2064220,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2060082,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2059111,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2057847,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2056136,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2049672,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2046527,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2044804,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2043830,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2043037,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2041259,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2037594,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2036097,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2035298,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2029994,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2027648,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2027478,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2026895,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2025598,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2024602,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 2015754,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 2009311,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 2008045,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 2002384,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 1999297,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 1998505,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 1997302,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 1995442,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 1994744,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 1990421,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1989384,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1985169,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1984556,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1984279,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1981254,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1981008,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1980793,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1980177,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1978922,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1978792,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1978060,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1973220,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1971281,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1971252,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1965079,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1964577,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1962944,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1958740,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1954006,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1952038,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k  5  10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1950970,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k  5  10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1950923,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k  5  10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1950137,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k  5  10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1949957,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k  5  10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1949544,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k  5  10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1949134,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k  5  10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1949075,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k  5  10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1942822,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k  5  10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1941674,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k  5  10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1937356,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1931736,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1930182,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1930174,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1928875,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1928101,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1926218,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1924877,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1924275,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1923155,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1921703,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? \\_()_/"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1918924,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? \\_()_/"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1916464,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? \\_()_/"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1914328,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? \\_()_/"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1901175,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? \\_()_/"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1900704,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? \\_()_/"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1900152,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? \\_()_/"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1899139,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? \\_()_/"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1884733,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? \\_()_/"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1881492,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? \\_()_/"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1876237,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1874740,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1874638,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1872906,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1869856,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1859385,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1859261,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1854508,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1849246,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1842088,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1838597,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1834705,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1833950,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1828039,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1827935,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1826189,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1823892,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1812603,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1807561,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1805792,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1805186,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1801954,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1801209,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1801165,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1800614,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1800606,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1800299,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1799625,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1796362,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1795501,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1793199,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1791639,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1791556,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1786047,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1781793,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1780304,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1777153,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1776951,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1776446,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1775035,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1773348,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1769395,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1769382,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1767529,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1759287,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1756392,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1754579,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1754571,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1753927,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1753042,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1751638,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1748130,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1747675,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1746753,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1739439,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1738265,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1737568,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1735160,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1735104,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1735042,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1730559,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1727491,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1724223,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1722409,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1721908,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1721770,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1721628,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1721364,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1721363,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1721143,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1715159,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1714225,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1707192,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1704724,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1704313,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1701179,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1697952,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1692642,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1691298,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1686108,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Game of Life",
        "question_content": "<p>According to&nbsp;<a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\" target=\"_blank\">Wikipedia&#39;s article</a>: &quot;The <b>Game of Life</b>, also known simply as <b>Life</b>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&quot;</p>\n\n<p>The board is made up of an <code>m x n</code> grid of cells, where each cell has an initial state: <b>live</b> (represented by a <code>1</code>) or <b>dead</b> (represented by a <code>0</code>). Each cell interacts with its <a href=\"https://en.wikipedia.org/wiki/Moore_neighborhood\" target=\"_blank\">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>\n\n<ol>\n\t<li>Any live cell with fewer than two live neighbors dies as if caused by under-population.</li>\n\t<li>Any live cell with two or three live neighbors lives on to the next generation.</li>\n\t<li>Any live cell with more than three live neighbors dies, as if by over-population.</li>\n\t<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>\n</ol>\n\n<p><span>The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the <code>m x n</code> grid <code>board</code>, return <em>the next state</em>.</span></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg\" style=\"width: 562px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n<strong>Output:</strong> [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg\" style=\"width: 402px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> board = [[1,1],[1,0]]\n<strong>Output:</strong> [[1,1],[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 25</code></li>\n\t<li><code>board[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.</li>\n\t<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?</li>\n</ul>\n",
        "solutions": [
            {
                "id": 73223,
                "title": "easiest-java-solution-with-explanation",
                "content": "To solve it in place, we use 2 bits to store 2 states:\\n\\n    [2nd bit, 1st bit] = [next state, current state]\\n\\n    - 00  dead (next) <- dead (current)\\n    - 01  dead (next) <- live (current)  \\n    - 10  live (next) <- dead (current)  \\n    - 11  live (next) <- live (current) \\n\\n- In the beginning, every cell is either `00` or `01`.\\n- Notice that `1st` state is independent of `2nd` state.\\n- Imagine all cells are instantly changing from the `1st` to the `2nd` state, at the same time.\\n- Let's count # of neighbors from `1st` state and set `2nd` state bit.\\n- Since every `2nd` state is by default dead, no need to consider transition `01 -> 00`.\\n- In the end, delete every cell's `1st` state by doing `>> 1`.\\n\\nFor each cell's `1st` bit, check the 8 pixels around itself, and set the cell's `2nd` bit.\\n\\n- Transition `01 -> 11`: when `board == 1` and `lives >= 2 && lives <= 3`.\\n- Transition `00 -> 10`: when `board == 0`  and  `lives == 3`.\\n\\n\\nTo get the current state, simply do\\n\\n    board[i][j] & 1\\n\\nTo get the next state, simply do\\n\\n    board[i][j] >> 1\\n\\nHope this helps!\\n\\n    public void gameOfLife(int[][] board) {\\n        if (board == null || board.length == 0) return;\\n        int m = board.length, n = board[0].length;\\n    \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int lives = liveNeighbors(board, m, n, i, j);\\n    \\n                // In the beginning, every 2nd bit is 0;\\n                // So we only need to care about when will the 2nd bit become 1.\\n                if (board[i][j] == 1 && lives >= 2 && lives <= 3) {  \\n                    board[i][j] = 3; // Make the 2nd bit 1: 01 ---> 11\\n                }\\n                if (board[i][j] == 0 && lives == 3) {\\n                    board[i][j] = 2; // Make the 2nd bit 1: 00 ---> 10\\n                }\\n            }\\n        }\\n    \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] >>= 1;  // Get the 2nd state.\\n            }\\n        }\\n    }\\n    \\n    public int liveNeighbors(int[][] board, int m, int n, int i, int j) {\\n        int lives = 0;\\n        for (int x = Math.max(i - 1, 0); x <= Math.min(i + 1, m - 1); x++) {\\n            for (int y = Math.max(j - 1, 0); y <= Math.min(j + 1, n - 1); y++) {\\n                lives += board[x][y] & 1;\\n            }\\n        }\\n        lives -= board[i][j] & 1;\\n        return lives;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "To solve it in place, we use 2 bits to store 2 states:\\n\\n    [2nd bit, 1st bit] = [next state, current state]\\n\\n    - 00  dead (next) <- dead (current)\\n    - 01  dead (next) <- live (current)  \\n    - 10  live (next) <- dead (current)  \\n    - 11  live (next) <- live (current) \\n\\n- In the beginning, every cell is either `00` or `01`.\\n- Notice that `1st` state is independent of `2nd` state.\\n- Imagine all cells are instantly changing from the `1st` to the `2nd` state, at the same time.\\n- Let's count # of neighbors from `1st` state and set `2nd` state bit.\\n- Since every `2nd` state is by default dead, no need to consider transition `01 -> 00`.\\n- In the end, delete every cell's `1st` state by doing `>> 1`.\\n\\nFor each cell's `1st` bit, check the 8 pixels around itself, and set the cell's `2nd` bit.\\n\\n- Transition `01 -> 11`: when `board == 1` and `lives >= 2 && lives <= 3`.\\n- Transition `00 -> 10`: when `board == 0`  and  `lives == 3`.\\n\\n\\nTo get the current state, simply do\\n\\n    board[i][j] & 1\\n\\nTo get the next state, simply do\\n\\n    board[i][j] >> 1\\n\\nHope this helps!\\n\\n    public void gameOfLife(int[][] board) {\\n        if (board == null || board.length == 0) return;\\n        int m = board.length, n = board[0].length;\\n    \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int lives = liveNeighbors(board, m, n, i, j);\\n    \\n                // In the beginning, every 2nd bit is 0;\\n                // So we only need to care about when will the 2nd bit become 1.\\n                if (board[i][j] == 1 && lives >= 2 && lives <= 3) {  \\n                    board[i][j] = 3; // Make the 2nd bit 1: 01 ---> 11\\n                }\\n                if (board[i][j] == 0 && lives == 3) {\\n                    board[i][j] = 2; // Make the 2nd bit 1: 00 ---> 10\\n                }\\n            }\\n        }\\n    \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] >>= 1;  // Get the 2nd state.\\n            }\\n        }\\n    }\\n    \\n    public int liveNeighbors(int[][] board, int m, int n, int i, int j) {\\n        int lives = 0;\\n        for (int x = Math.max(i - 1, 0); x <= Math.min(i + 1, m - 1); x++) {\\n            for (int y = Math.max(j - 1, 0); y <= Math.min(j + 1, n - 1); y++) {\\n                lives += board[x][y] & 1;\\n            }\\n        }\\n        lives -= board[i][j] & 1;\\n        return lives;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73230,
                "title": "c-o-1-space-o-mn-time",
                "content": "Since the board has ints but only the 1-bit is used, I use the 2-bit to store the new state. At the end, replace the old state with the new state by shifting all values one bit to the right.\\n\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int m = board.size(), n = m ? board[0].size() : 0;\\n        for (int i=0; i<m; ++i) {\\n            for (int j=0; j<n; ++j) {\\n                int count = 0;\\n                for (int I=max(i-1, 0); I<min(i+2, m); ++I)\\n                    for (int J=max(j-1, 0); J<min(j+2, n); ++J)\\n                        count += board[I][J] & 1;\\n                if (count == 3 || count - board[i][j] == 3)\\n                    board[i][j] |= 2;\\n            }\\n        }\\n        for (int i=0; i<m; ++i)\\n            for (int j=0; j<n; ++j)\\n                board[i][j] >>= 1;\\n    }\\n\\nNote that the above `count` counts the live ones among a cell's neighbors and the cell itself. Starting with `int count = -board[i][j]` counts only the live neighbors and allows the neat\\n\\n    if ((count | board[i][j]) == 3)\\n\\ntest. Thanks to aileenbai for showing that one in the comments.",
                "solutionTags": [
                    "C++"
                ],
                "code": "Since the board has ints but only the 1-bit is used, I use the 2-bit to store the new state. At the end, replace the old state with the new state by shifting all values one bit to the right.\\n\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int m = board.size(), n = m ? board[0].size() : 0;\\n        for (int i=0; i<m; ++i) {\\n            for (int j=0; j<n; ++j) {\\n                int count = 0;\\n                for (int I=max(i-1, 0); I<min(i+2, m); ++I)\\n                    for (int J=max(j-1, 0); J<min(j+2, n); ++J)\\n                        count += board[I][J] & 1;\\n                if (count == 3 || count - board[i][j] == 3)\\n                    board[i][j] |= 2;\\n            }\\n        }\\n        for (int i=0; i<m; ++i)\\n            for (int j=0; j<n; ++j)\\n                board[i][j] >>= 1;\\n    }\\n\\nNote that the above `count` counts the live ones among a cell's neighbors and the cell itself. Starting with `int count = -board[i][j]` counts only the live neighbors and allows the neat\\n\\n    if ((count | board[i][j]) == 3)\\n\\ntest. Thanks to aileenbai for showing that one in the comments.",
                "codeTag": "Unknown"
            },
            {
                "id": 73217,
                "title": "infinite-board-solution",
                "content": "For the second follow-up question, here's a solution for an infinite board. Instead of a two-dimensional array of ones and zeros, I represent the board as a set of live cell coordinates.\\n\\n    def gameOfLifeInfinite(self, live):\\n        ctr = collections.Counter((I, J)\\n                                  for i, j in live\\n                                  for I in range(i-1, i+2)\\n                                  for J in range(j-1, j+2)\\n                                  if I != i or J != j)\\n        return {ij\\n                for ij in ctr\\n                if ctr[ij] == 3 or ctr[ij] == 2 and ij in live}\\n\\nAnd here's a wrapper that uses the above infinite board solution to solve the problem we have here at the OJ (submitted together, this gets accepted):\\n\\n    def gameOfLife(self, board):\\n        live = {(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live}\\n        live = self.gameOfLifeInfinite(live)\\n        for i, row in enumerate(board):\\n            for j in range(len(row)):\\n                row[j] = int((i, j) in live)",
                "solutionTags": [
                    "Python"
                ],
                "code": "For the second follow-up question, here's a solution for an infinite board. Instead of a two-dimensional array of ones and zeros, I represent the board as a set of live cell coordinates.\\n\\n    def gameOfLifeInfinite(self, live):\\n        ctr = collections.Counter((I, J)\\n                                  for i, j in live\\n                                  for I in range(i-1, i+2)\\n                                  for J in range(j-1, j+2)\\n                                  if I != i or J != j)\\n        return {ij\\n                for ij in ctr\\n                if ctr[ij] == 3 or ctr[ij] == 2 and ij in live}\\n\\nAnd here's a wrapper that uses the above infinite board solution to solve the problem we have here at the OJ (submitted together, this gets accepted):\\n\\n    def gameOfLife(self, board):\\n        live = {(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live}\\n        live = self.gameOfLifeInfinite(live)\\n        for i, row in enumerate(board):\\n            for j in range(len(row)):\\n                row[j] = int((i, j) in live)",
                "codeTag": "Python3"
            },
            {
                "id": 1225591,
                "title": "c-two-approaches-with-intuition-faster-than-100",
                "content": "<hr><br>\\n\\n## Basic Idea\\nConway\\'s Game of Life is a simulation game wherein the following rules are applied **simultaneously** to the entire board:\\n1. If a live cell has less than two live neighbours, it dies (underpopulation).\\n2. If a live cell has more than three live neighbours, it dies (overpopulation).\\n3. If a live cell has exactly 2 or 3 live neighbours, it lives on.\\n4. If a dead cell has exactly 3 live neighbours, it becomes alive again (reproduction).\\n\\nThe keyword in this question is **simultaneously**, meaning that the effect of any cell dying or becoming alive again does cannot affect any other cells until the next state (or next iteration of the game).\\n\\nNow as referenced in the question itself, the actual game is supposed to be played on an infinite plane, but we don\\'t have an infinite plane. So we assume another border of dead cells around the original border. This way each cell in the actual playing area has exactly 8 neighbours, and thus has an equal chance at the game. But I don\\'t actually allocate space to accomodate this, I just use bound checks to make sure we just count those neighbours as dead.\\n<hr><br>\\n\\n## Approach 1: Remember the board (extra space)\\nOne way to not let any changes we make affect the choices for other cells, is to:\\n1. Either do the modifications on a new board, and use the old board for checking the neighbours.\\n2. Or make a copy of the old board, and use that for checking, while making modifications on the original board.\\n\\nI will go for the second approach on this, but we can implement either of those with similar complexity.\\n\\n```\\nint getLiveNeighbours(vector<vector<int>>& curr, int i, int j, int m, int n) {\\n\\tint liveNeighbours = 0;\\n\\tif(i>0) {\\n\\t\\t//check the upper neighbour\\n\\t\\tif(curr[i-1][j] == 1) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1) {\\n\\t\\t//check the lower neighbour\\n\\t\\tif(curr[i+1][j] == 1) liveNeighbours++;\\n\\t}\\n\\tif(j>0) {\\n\\t\\t//check the left neighbour\\n\\t\\tif(curr[i][j-1] == 1) liveNeighbours++;\\n\\t}\\n\\tif(j<n-1) {\\n\\t\\t//check the right neighbour\\n\\t\\tif(curr[i][j+1] == 1) liveNeighbours++;\\n\\t}\\n\\n\\tif(i>0 && j>0) {\\n\\t\\tif(curr[i-1][j-1] == 1) liveNeighbours++;\\n\\t}\\n\\tif(i>0 && j<n-1) {\\n\\t\\tif(curr[i-1][j+1] == 1) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1 && j>0) {\\n\\t\\tif(curr[i+1][j-1] == 1) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1 && j<n-1) {\\n\\t\\tif(curr[i+1][j+1] == 1) liveNeighbours++;\\n\\t}\\n\\treturn liveNeighbours;\\n}\\nvoid gameOfLife(vector<vector<int>>& board) {\\n\\tvector<vector<int>> curr = board;\\n\\tint m = board.size();\\n\\tint n = board[0].size();\\n\\tfor(int i = 0; i<m; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tint ln = getLiveNeighbours(curr, i, j, m, n);\\n\\t\\t\\tif(board[i][j] == 0) {\\n\\t\\t\\t\\t//currently dead\\n\\t\\t\\t\\t//can become alive if has exactly three live neighbours\\n\\t\\t\\t\\tif(ln == 3) {\\n\\t\\t\\t\\t\\tboard[i][j] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(board[i][j] == 1) {\\n\\t\\t\\t\\t//<2 -> die\\n\\t\\t\\t\\t//==2 || ==3 live\\n\\t\\t\\t\\t//>3 ->die\\n\\t\\t\\t\\tif(ln < 2 || ln > 3) {\\n\\t\\t\\t\\t\\tboard[i][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n### Complexity\\n**Time: O(mn)** as we iterate over the entire boardO(mn), checking eight neighbours (O(1)) at each cell.\\n**Space: O(mn)** from the copy that we make, either for storing or modifying.\\n<hr><br>\\n\\n## Approach 2: Remember our moves (in-place)\\nWhenever we are asked to do something in-place, we are mostly given the luxury of modifying our input data structure itself. For example see this question, even though a cell can only be in one of two states (dead or alive), we are given an integer matrix, where a bool matrix would obviously have been sufficient.\\nBut we can exploit that.\\n\\nWe can use it to remember our modifications (which won\\'t affect the other cells for now), so that we have a record of them, while also separating them from the old values themselves, that will affect the other cells.\\n\\nFor this, we introduce two new states for a cell:\\n```2: newly alive ``` and ```3: newly dead```\\n\\nNow let\\'s see how we will have to modify our **neighbour checking function** to accomodate these:\\nFor our intents and purposes (i.e checking the neighbours of a cell), the newly died cell is still alive, since the changes made by us have not been enforced right now.\\nHence the condition ```curr[x][y] == 1```  transforms to ```curr[x][y] == 1 || curr[x][y] == 3```.\\nEverything else stays the same here.\\n\\nOnto our **main function**:\\nWherever we were modifying the board, now we use our new states, so any cell that we mark as alive will be marked 2, and any cell which we mark as dead, will be marked 3 instead of 1 and 0 respectively. Then after finishing the whole processing (i.e the entire board), we iterate over the matrix again, replacing our new states (2, 3) with their respective values (1, 0).\\n\\n```\\nint getLiveNeighbours(vector<vector<int>>& curr, int i, int j, int m, int n) {\\n\\tint liveNeighbours = 0;\\n\\tif(i>0) {\\n\\t\\t//check the upper neighbour\\n\\t\\tif(curr[i-1][j] == 1 || curr[i-1][j] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1) {\\n\\t\\t//check the lower neighbour\\n\\t\\tif(curr[i+1][j] == 1 || curr[i+1][j] == 3) liveNeighbours++;\\n\\t}\\n\\tif(j>0) {\\n\\t\\t//check the left neighbour\\n\\t\\tif(curr[i][j-1] == 1 || curr[i][j-1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(j<n-1) {\\n\\t\\t//check the right neighbour\\n\\t\\tif(curr[i][j+1] == 1 || curr[i][j+1] == 3) liveNeighbours++;\\n\\t}\\n\\n\\tif(i>0 && j>0) {\\n\\t\\tif(curr[i-1][j-1] == 1 || curr[i-1][j-1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i>0 && j<n-1) {\\n\\t\\tif(curr[i-1][j+1] == 1 || curr[i-1][j+1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1 && j>0) {\\n\\t\\tif(curr[i+1][j-1] == 1 || curr[i+1][j-1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1 && j<n-1) {\\n\\t\\tif(curr[i+1][j+1] == 1 || curr[i+1][j+1] == 3) liveNeighbours++;\\n\\t}\\n\\treturn liveNeighbours;\\n}\\nvoid gameOfLife(vector<vector<int>>& board) {\\n\\tint m = board.size();\\n\\tint n = board[0].size();\\n\\tfor(int i = 0; i<m; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tint ln = getLiveNeighbours(board, i, j, m, n);\\n\\t\\t\\tif(board[i][j] == 0) {\\n\\t\\t\\t\\t//currently dead\\n\\t\\t\\t\\t//can become alive if has exactly three live neighbours\\n\\t\\t\\t\\tif(ln == 3) {\\n\\t\\t\\t\\t\\tboard[i][j] = 2; //newly alive\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(board[i][j] == 1) {\\n\\t\\t\\t\\t//<2 -> die\\n\\t\\t\\t\\t//==2 || ==3 live\\n\\t\\t\\t\\t//>3 ->die\\n\\t\\t\\t\\tif(ln < 2 || ln > 3) {\\n\\t\\t\\t\\t\\tboard[i][j] = 3; //newly dead\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t//final modifications 2->1, 3->0\\n\\tfor(int i = 0; i<m; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tif(board[i][j] == 2) board[i][j] = 1;\\n\\t\\t\\telse if(board[i][j] == 3) board[i][j] = 0;\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n## Complexity\\n**Time: O(mn)**, the same as before\\n**Space: O(1)**, as everything is done in-place, and with O(1) extra memory.\\n\\n<hr><br>\\n\\n**Upvote** if you liked this post, and feel free to ask doubts, or suggest corrections/improvements in the comments.\\nIf you notice any mistake, please do point out, as I\\'m also learning things, and may have made a genuine error, which I would want to avoid in the future.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint getLiveNeighbours(vector<vector<int>>& curr, int i, int j, int m, int n) {\\n\\tint liveNeighbours = 0;\\n\\tif(i>0) {\\n\\t\\t//check the upper neighbour\\n\\t\\tif(curr[i-1][j] == 1) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1) {\\n\\t\\t//check the lower neighbour\\n\\t\\tif(curr[i+1][j] == 1) liveNeighbours++;\\n\\t}\\n\\tif(j>0) {\\n\\t\\t//check the left neighbour\\n\\t\\tif(curr[i][j-1] == 1) liveNeighbours++;\\n\\t}\\n\\tif(j<n-1) {\\n\\t\\t//check the right neighbour\\n\\t\\tif(curr[i][j+1] == 1) liveNeighbours++;\\n\\t}\\n\\n\\tif(i>0 && j>0) {\\n\\t\\tif(curr[i-1][j-1] == 1) liveNeighbours++;\\n\\t}\\n\\tif(i>0 && j<n-1) {\\n\\t\\tif(curr[i-1][j+1] == 1) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1 && j>0) {\\n\\t\\tif(curr[i+1][j-1] == 1) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1 && j<n-1) {\\n\\t\\tif(curr[i+1][j+1] == 1) liveNeighbours++;\\n\\t}\\n\\treturn liveNeighbours;\\n}\\nvoid gameOfLife(vector<vector<int>>& board) {\\n\\tvector<vector<int>> curr = board;\\n\\tint m = board.size();\\n\\tint n = board[0].size();\\n\\tfor(int i = 0; i<m; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tint ln = getLiveNeighbours(curr, i, j, m, n);\\n\\t\\t\\tif(board[i][j] == 0) {\\n\\t\\t\\t\\t//currently dead\\n\\t\\t\\t\\t//can become alive if has exactly three live neighbours\\n\\t\\t\\t\\tif(ln == 3) {\\n\\t\\t\\t\\t\\tboard[i][j] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(board[i][j] == 1) {\\n\\t\\t\\t\\t//<2 -> die\\n\\t\\t\\t\\t//==2 || ==3 live\\n\\t\\t\\t\\t//>3 ->die\\n\\t\\t\\t\\tif(ln < 2 || ln > 3) {\\n\\t\\t\\t\\t\\tboard[i][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\n```2: newly alive ```\n```3: newly dead```\n```curr[x][y] == 1```\n```curr[x][y] == 1 || curr[x][y] == 3```\n```\\nint getLiveNeighbours(vector<vector<int>>& curr, int i, int j, int m, int n) {\\n\\tint liveNeighbours = 0;\\n\\tif(i>0) {\\n\\t\\t//check the upper neighbour\\n\\t\\tif(curr[i-1][j] == 1 || curr[i-1][j] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1) {\\n\\t\\t//check the lower neighbour\\n\\t\\tif(curr[i+1][j] == 1 || curr[i+1][j] == 3) liveNeighbours++;\\n\\t}\\n\\tif(j>0) {\\n\\t\\t//check the left neighbour\\n\\t\\tif(curr[i][j-1] == 1 || curr[i][j-1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(j<n-1) {\\n\\t\\t//check the right neighbour\\n\\t\\tif(curr[i][j+1] == 1 || curr[i][j+1] == 3) liveNeighbours++;\\n\\t}\\n\\n\\tif(i>0 && j>0) {\\n\\t\\tif(curr[i-1][j-1] == 1 || curr[i-1][j-1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i>0 && j<n-1) {\\n\\t\\tif(curr[i-1][j+1] == 1 || curr[i-1][j+1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1 && j>0) {\\n\\t\\tif(curr[i+1][j-1] == 1 || curr[i+1][j-1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1 && j<n-1) {\\n\\t\\tif(curr[i+1][j+1] == 1 || curr[i+1][j+1] == 3) liveNeighbours++;\\n\\t}\\n\\treturn liveNeighbours;\\n}\\nvoid gameOfLife(vector<vector<int>>& board) {\\n\\tint m = board.size();\\n\\tint n = board[0].size();\\n\\tfor(int i = 0; i<m; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tint ln = getLiveNeighbours(board, i, j, m, n);\\n\\t\\t\\tif(board[i][j] == 0) {\\n\\t\\t\\t\\t//currently dead\\n\\t\\t\\t\\t//can become alive if has exactly three live neighbours\\n\\t\\t\\t\\tif(ln == 3) {\\n\\t\\t\\t\\t\\tboard[i][j] = 2; //newly alive\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(board[i][j] == 1) {\\n\\t\\t\\t\\t//<2 -> die\\n\\t\\t\\t\\t//==2 || ==3 live\\n\\t\\t\\t\\t//>3 ->die\\n\\t\\t\\t\\tif(ln < 2 || ln > 3) {\\n\\t\\t\\t\\t\\tboard[i][j] = 3; //newly dead\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t//final modifications 2->1, 3->0\\n\\tfor(int i = 0; i<m; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tif(board[i][j] == 2) board[i][j] = 1;\\n\\t\\t\\telse if(board[i][j] == 3) board[i][j] = 0;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73366,
                "title": "clean-o-1-space-o-mn-time-java-solution",
                "content": "    public class Solution {\\n    int[][] dir ={{1,-1},{1,0},{1,1},{0,-1},{0,1},{-1,-1},{-1,0},{-1,1}};\\n    public void gameOfLife(int[][] board) {\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                int live=0;\\n                for(int[] d:dir){\\n                    if(d[0]+i<0 || d[0]+i>=board.length || d[1]+j<0 || d[1]+j>=board[0].length) continue;\\n                    if(board[d[0]+i][d[1]+j]==1 || board[d[0]+i][d[1]+j]==2) live++;\\n                }\\n                if(board[i][j]==0 && live==3) board[i][j]=3;\\n                if(board[i][j]==1 && (live<2 || live>3)) board[i][j]=2;\\n            }\\n        }\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                board[i][j] %=2;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int[][] dir ={{1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1937863,
                "title": "python-o-1-space-o-m-n-time-take-advantage-of-1-s",
                "content": "At first glance, I thought it was to be solved by DFS/BFS. However, I found key word: `simultaneously`, killing those thoughts.\\n\\nIMO, the interesting part of my solution is: \\n```\\nall new 0\\'s denotes as -1, (1 ==> 0)\\nall new 1\\'s denotes as 2   (0 ==> 1)\\n```\\n\\nsaves a few lines of code.\\n<br>\\n\\n```\\nclass Solution:\\n    def gameOfLife(self, b: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \\n        apply by using:\\n            under-population: < 2\\n            live to next generation: 2 or 3 \\n            over-population: > 3\\n            reproduction: == 3\\n        \\n        simultaneously: shoud not use DFS/BFS\\n            \\n        \\\\|/\\n        - -\\n        /|\\\\\\n        \"\"\"\\n        # all new 0\\'s denotes as -1, (1 ==> 0)\\n        # all new 1\\'s denotes as 2   (0 ==> 1)\\n        m, n = len(b), len(b[0])\\n        dirs = [[-1,-1],[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1]]\\n        for i in range(m):\\n            for j in range(n):\\n                livecount = 0\\n                for r, c in dirs:\\n                    nr, nc = i + r, j + c\\n                    if 0 <= nr < m and 0 <= nc < n and abs(b[nr][nc]) == 1: # originally 1\\'s\\n                        livecount += 1\\n                if b[i][j] == 1:\\n                    if livecount < 2 or livecount > 3:   \\n                        b[i][j] = -1\\n                else:\\n                    if livecount == 3:  \\n                        b[i][j] = 2\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if b[i][j] == 2:    b[i][j] = 1\\n                elif b[i][j] == -1: b[i][j] = 0\\n```\\nHope you enjoy!\\n\\nIf you have any question, or suggestion, please comment \\uD83D\\uDC47",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nall new 0\\'s denotes as -1, (1 ==> 0)\\nall new 1\\'s denotes as 2   (0 ==> 1)\\n```\n```\\nclass Solution:\\n    def gameOfLife(self, b: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \\n        apply by using:\\n            under-population: < 2\\n            live to next generation: 2 or 3 \\n            over-population: > 3\\n            reproduction: == 3\\n        \\n        simultaneously: shoud not use DFS/BFS\\n            \\n        \\\\|/\\n        - -\\n        /|\\\\\\n        \"\"\"\\n        # all new 0\\'s denotes as -1, (1 ==> 0)\\n        # all new 1\\'s denotes as 2   (0 ==> 1)\\n        m, n = len(b), len(b[0])\\n        dirs = [[-1,-1],[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1]]\\n        for i in range(m):\\n            for j in range(n):\\n                livecount = 0\\n                for r, c in dirs:\\n                    nr, nc = i + r, j + c\\n                    if 0 <= nr < m and 0 <= nc < n and abs(b[nr][nc]) == 1: # originally 1\\'s\\n                        livecount += 1\\n                if b[i][j] == 1:\\n                    if livecount < 2 or livecount > 3:   \\n                        b[i][j] = -1\\n                else:\\n                    if livecount == 3:  \\n                        b[i][j] = 2\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if b[i][j] == 2:    b[i][j] = 1\\n                elif b[i][j] == -1: b[i][j] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73229,
                "title": "python-solution-easy-to-understand",
                "content": "0,2 are \"dead\", and \"dead->live\"\\n1,3 are \"live\", and \"live->dead\"\\n\\n    def gameOfLife(self, board):\\n        m,n = len(board), len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == 0 or board[i][j] == 2:\\n                    if self.nnb(board,i,j) == 3:\\n                        board[i][j] = 2\\n                else:\\n                    if self.nnb(board,i,j) < 2 or self.nnb(board,i,j) >3:\\n                        board[i][j] = 3\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == 2: board[i][j] = 1\\n                if board[i][j] == 3: board[i][j] = 0\\n                \\n    def nnb(self, board, i, j):\\n        m,n = len(board), len(board[0])\\n        count = 0\\n        if i-1 >= 0 and j-1 >= 0:   count += board[i-1][j-1]%2\\n        if i-1 >= 0:                count += board[i-1][j]%2\\n        if i-1 >= 0 and j+1 < n:    count += board[i-1][j+1]%2\\n        if j-1 >= 0:                count += board[i][j-1]%2\\n        if j+1 < n:                 count += board[i][j+1]%2\\n        if i+1 < m and j-1 >= 0:    count += board[i+1][j-1]%2\\n        if i+1 < m:                 count += board[i+1][j]%2\\n        if i+1 < m and j+1 < n:     count += board[i+1][j+1]%2\\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "0,2 are \"dead\", and \"dead->live\"\\n1,3 are \"live\", and \"live->dead\"\\n\\n    def gameOfLife(self, board):\\n        m,n = len(board), len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == 0 or board[i][j] == 2:\\n                    if self.nnb(board,i,j) == 3:\\n                        board[i][j] = 2\\n                else:\\n                    if self.nnb(board,i,j) < 2 or self.nnb(board,i,j) >3:\\n                        board[i][j] = 3\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == 2: board[i][j] = 1\\n                if board[i][j] == 3: board[i][j] = 0\\n                \\n    def nnb(self, board, i, j):\\n        m,n = len(board), len(board[0])\\n        count = 0\\n        if i-1 >= 0 and j-1 >= 0:   count += board[i-1][j-1]%2\\n        if i-1 >= 0:                count += board[i-1][j]%2\\n        if i-1 >= 0 and j+1 < n:    count += board[i-1][j+1]%2\\n        if j-1 >= 0:                count += board[i][j-1]%2\\n        if j+1 < n:                 count += board[i][j+1]%2\\n        if i+1 < m and j-1 >= 0:    count += board[i+1][j-1]%2\\n        if i+1 < m:                 count += board[i+1][j]%2\\n        if i+1 < m and j+1 < n:     count += board[i+1][j+1]%2\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 1938031,
                "title": "0ms-beats-100-easy-clean-dry-run-explained",
                "content": "**NOTE:**  This approach is \"NOT in-place\", as I used an extra matrix. For \"in-place\" approach, there are already some great solutions in Discuss section. I tried to solve it as easy as possible for anyone having hard time with this question :) I will surely add the in-place solution, if/once I make one easier to understand :)\\n## Approach:\\n\\t\\n\\t1. First create a temporary matrix. We will update all the values to this matrix.\\n\\t2. Just loop through the matrix; at each cell, add sum of all the 8 neighbours (consider out of bound cells as 0). used \"liveNeighbors\" variable for this.  \\n\\t3. Then using the rules given in question, update the temporary matrix cells.\\n\\t4. After the loop, copy all the temporary matrix values to original matrix \"board\".\\n\\nIf you like it, pls **Upvote** :)\\n\\n## Code:\\n\\n\\tpublic void gameOfLife(int[][] board) {\\n        int rows = board.length, cols = board[0].length;\\n        int[][] tempBoard = new int[rows][cols];                                             // we will first update values in this temporary matrix\\n        for(int r = 0; r < rows; r++){\\n            for(int c = 0; c < cols; c++){\\n                int liveNeighbors = neighbor(board, r-1, c-1) + neighbor(board, r-1, c) + neighbor(board, r-1, c+1) + neighbor(board, r, c+1) + \\n                                    neighbor(board, r+1, c+1) + neighbor(board, r+1, c) + neighbor(board, r+1, c-1) + neighbor(board, r, c-1);\\n                //System.out.println(\"cell: (\"+r+\",\"+c+\") ,  liveNeighbors: \"+liveNeighbors);\\n                if(board[r][c] == 1){ \\n                    tempBoard[r][c] = (liveNeighbors < 2 || liveNeighbors > 3) ? 0 : 1;      // update temporary matrix, based on the rules in question\\n                }else{ \\n                    tempBoard[r][c] = (liveNeighbors == 3) ? 1 : 0;\\n                }\\n            }\\n        }\\n        \\n        for(int r = 0; r < rows; r++){\\n            board[r] = tempBoard[r].clone();                                                // copy all tempBoard elements back to board matrix\\n        }\\n    }\\n    \\n\\t// ----------------------------------------------------------------------- //\\n    public int neighbor(int[][] board, int r, int c){\\n        if( r < 0 || r >= board.length || c < 0 || c >= board[0].length || board[r][c] == 0 ){ return 0; }                          // out of bound cases\\n        return 1;\\n    }\\n\\n\\n//\\n//\\n//\\n//\\n\\n## Dry Run / Example:\\n\\tInput = [\\n\\t\\t\\t  [0,1,0], \\n\\t\\t\\t  [0,0,1], \\n\\t\\t\\t  [1,1,1], \\n\\t\\t\\t  [0,0,0]\\n\\t\\t    ]\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/7ef7b8cd-69f1-448d-a347-f75f28c53993_1649770827.9970846.png)\\n\\t\\n\\tcell: (0,0) ,  liveNeighbors: 1  \\n\\t(rest of the cells also call neighbor method 8 times just like I shown above)\\n\\tcell: (0,1) ,  liveNeighbors: 1\\n\\tcell: (0,2) ,  liveNeighbors: 2\\n\\tcell: (1,0) ,  liveNeighbors: 3\\n\\tcell: (1,1) ,  liveNeighbors: 5\\n\\tcell: (1,2) ,  liveNeighbors: 3\\n\\tcell: (2,0) ,  liveNeighbors: 1\\n\\tcell: (2,1) ,  liveNeighbors: 3\\n\\tcell: (2,2) ,  liveNeighbors: 2\\n\\tcell: (3,0) ,  liveNeighbors: 2\\n\\tcell: (3,1) ,  liveNeighbors: 3\\n\\tcell: (3,2) ,  liveNeighbors: 2\\n\\nLike I mentioned above, this approach is \"NOT in-place\". For that, there are already some great solutions in Discuss section.\\n \\nIf any questions, comment down below.\\nIf you like above explanation or code, pls **Upvote** :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "**NOTE:**  This approach is \"NOT in-place\", as I used an extra matrix. For \"in-place\" approach, there are already some great solutions in Discuss section. I tried to solve it as easy as possible for anyone having hard time with this question :) I will surely add the in-place solution, if/once I make one easier to understand :)\\n## Approach:\\n\\t\\n\\t1. First create a temporary matrix. We will update all the values to this matrix.\\n\\t2. Just loop through the matrix; at each cell, add sum of all the 8 neighbours (consider out of bound cells as 0). used \"liveNeighbors\" variable for this.  \\n\\t3. Then using the rules given in question, update the temporary matrix cells.\\n\\t4. After the loop, copy all the temporary matrix values to original matrix \"board\".\\n\\nIf you like it, pls **Upvote** :)\\n\\n## Code:\\n\\n\\tpublic void gameOfLife(int[][] board) {\\n        int rows = board.length, cols = board[0].length;\\n        int[][] tempBoard = new int[rows][cols];                                             // we will first update values in this temporary matrix\\n        for(int r = 0; r < rows; r++){\\n            for(int c = 0; c < cols; c++){\\n                int liveNeighbors = neighbor(board, r-1, c-1) + neighbor(board, r-1, c) + neighbor(board, r-1, c+1) + neighbor(board, r, c+1) + \\n                                    neighbor(board, r+1, c+1) + neighbor(board, r+1, c) + neighbor(board, r+1, c-1) + neighbor(board, r, c-1);\\n                //System.out.println(\"cell: (\"+r+\",\"+c+\") ,  liveNeighbors: \"+liveNeighbors);\\n                if(board[r][c] == 1){ \\n                    tempBoard[r][c] = (liveNeighbors < 2 || liveNeighbors > 3) ? 0 : 1;      // update temporary matrix, based on the rules in question\\n                }else{ \\n                    tempBoard[r][c] = (liveNeighbors == 3) ? 1 : 0;\\n                }\\n            }\\n        }\\n        \\n        for(int r = 0; r < rows; r++){\\n            board[r] = tempBoard[r].clone();                                                // copy all tempBoard elements back to board matrix\\n        }\\n    }\\n    \\n\\t// ----------------------------------------------------------------------- //\\n    public int neighbor(int[][] board, int r, int c){\\n        if( r < 0 || r >= board.length || c < 0 || c >= board[0].length || board[r][c] == 0 ){ return 0; }                          // out of bound cases\\n        return 1;\\n    }\\n\\n\\n//\\n//\\n//\\n//\\n\\n## Dry Run / Example:\\n\\tInput = [\\n\\t\\t\\t  [0,1,0], \\n\\t\\t\\t  [0,0,1], \\n\\t\\t\\t  [1,1,1], \\n\\t\\t\\t  [0,0,0]\\n\\t\\t    ]\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/7ef7b8cd-69f1-448d-a347-f75f28c53993_1649770827.9970846.png)\\n\\t\\n\\tcell: (0,0) ,  liveNeighbors: 1  \\n\\t(rest of the cells also call neighbor method 8 times just like I shown above)\\n\\tcell: (0,1) ,  liveNeighbors: 1\\n\\tcell: (0,2) ,  liveNeighbors: 2\\n\\tcell: (1,0) ,  liveNeighbors: 3\\n\\tcell: (1,1) ,  liveNeighbors: 5\\n\\tcell: (1,2) ,  liveNeighbors: 3\\n\\tcell: (2,0) ,  liveNeighbors: 1\\n\\tcell: (2,1) ,  liveNeighbors: 3\\n\\tcell: (2,2) ,  liveNeighbors: 2\\n\\tcell: (3,0) ,  liveNeighbors: 2\\n\\tcell: (3,1) ,  liveNeighbors: 3\\n\\tcell: (3,2) ,  liveNeighbors: 2\\n\\nLike I mentioned above, this approach is \"NOT in-place\". For that, there are already some great solutions in Discuss section.\\n \\nIf any questions, comment down below.\\nIf you like above explanation or code, pls **Upvote** :)",
                "codeTag": "Unknown"
            },
            {
                "id": 73271,
                "title": "python-solution-with-detailed-explanation",
                "content": "the key point is to understand that the change to a cell is only decided by its nearby 8 cell in the original grid.\\n\\nwe should not use the updated cell to compute to change decision for other cell,therefore, the brute force way is to store the result in a new grid,then assign result back\\n\\nBut usually it requires use O(1) space, so the problem becomes: How can we store store the middle result without use extra space.\\n\\nthe solution is to store the result in the origin grid as different number by some rule, so when we compute decision for other cell, we can know the original value of those nearby cell which has already been updated based on the rule\\n\\nfor example, we can do like this\\n\\nliving cells nearby   |   change   |   new value\\n```\\n<2        1->0     2\\n2,3       1->1     1\\n>3        1->0     2\\n3         0->1     3\\n```\\nso when we count living cells nearby, we need to count those value equals to 1 and 2\\n\\n```\\nclass Solution(object):\\n    def gameOfLife(self, board):\\n        if not board or len(board[0]) == 0:\\n            return\\n        m, n = len(board), len(board[0])\\n        for i, row in enumerate(board):\\n            for j, ele in enumerate(row):\\n                count = 0\\n                for a in xrange(max(0, i - 1), min(i + 2, m)):\\n                    for b in xrange(max(0, j - 1), min(j + 2, n)):\\n                        if (a, b) != (i, j) and 1 <= board[a][b] <= 2:\\n                            count += 1\\n                if board[i][j] == 0:\\n                    if count == 3:\\n                        board[i][j] = 3\\n                else:\\n                    if count < 2 or count > 3:\\n                        board[i][j] = 2\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if board[i][j] == 2:\\n                    board[i][j] = 0\\n                elif board[i][j] == 3:\\n                    board[i][j] = 1\\n```",
                "solutionTags": [],
                "code": "```\\n<2        1->0     2\\n2,3       1->1     1\\n>3        1->0     2\\n3         0->1     3\\n```\n```\\nclass Solution(object):\\n    def gameOfLife(self, board):\\n        if not board or len(board[0]) == 0:\\n            return\\n        m, n = len(board), len(board[0])\\n        for i, row in enumerate(board):\\n            for j, ele in enumerate(row):\\n                count = 0\\n                for a in xrange(max(0, i - 1), min(i + 2, m)):\\n                    for b in xrange(max(0, j - 1), min(j + 2, n)):\\n                        if (a, b) != (i, j) and 1 <= board[a][b] <= 2:\\n                            count += 1\\n                if board[i][j] == 0:\\n                    if count == 3:\\n                        board[i][j] = 3\\n                else:\\n                    if count < 2 or count > 3:\\n                        board[i][j] = 2\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if board[i][j] == 2:\\n                    board[i][j] = 0\\n                elif board[i][j] == 3:\\n                    board[i][j] = 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73252,
                "title": "c-ac-code-o-1-space-o-mn-time",
                "content": "    // Game of Life\\n    /*\\n    \\u72b6\\u6001: \\u524d\\u4e00\\u4f4d\\u8868\\u793a\\u4e0b\\u4e00\\u4ee3\\u7684\\u72b6\\u6001,\\u540e\\u4e00\\u4f4d\\u8868\\u793a\\u5f53\\u524d\\u7684\\u72b6\\u6001\\n    00: \\u6b7b->\\u6b7b\\n    10: \\u6b7b->\\u6d3b\\n    01: \\u6d3b->\\u6b7b\\n    11: \\u6d3b->\\u6d3b\\n    */\\n    class Solution {\\n    public:\\n        void gameOfLife(vector<vector<int>>& board) {\\n            int d[][2] = {{1,-1},{1,0},{1,1},{0,-1},{0,1},{-1,-1},{-1,0},{-1,1}};\\n            for(int i = 0; i < board.size(); i++){\\n                for(int j = 0; j < board[0].size(); j++){\\n                    int live = 0;\\n                    for(int k = 0; k < 8; k++){\\n                        int x = d[k][0] + i;\\n                        int y = d[k][1] + j;\\n                        if(x < 0 || x >= board.size() || y < 0 || y >= board[0].size()) {\\n                            continue;\\n                        }\\n                        if(board[x][y] & 1) {\\n                            live++;\\n                        }\\n                    }\\n                    // \\u6b7b\\u7684\\n                    if(board[i][j] == 0) {\\n                        if(live == 3){\\n                            board[i][j] = 2; // 2 : (10)\\n                        }\\n                    }\\n                    // \\u6d3b\\u7684\\n                    else {\\n                        if(live < 2 || live > 3){\\n                            board[i][j] = 1; // 1 : (01)\\n                        }else{\\n                            board[i][j] = 3; // 3 : (11)   \\n                        }\\n                    }\\n                }\\n            }\\n            for(int i = 0; i < board.size(); i++){\\n                for(int j=0; j < board[0].size(); j++){\\n                    board[i][j] >>=1;\\n                }\\n            }\\n        }\\n    };enter code here",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void gameOfLife(vector<vector<int>>& board) {\\n            int d[][2] = {{1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 994037,
                "title": "python-2-follow-up-questions-o-1-space-and-infinite-board-clean-concise",
                "content": "**\\u2714\\uFE0F Follow-up 1: Constant Space**\\n> Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.\\n\\n- While processing, store new value of the board into `1th` bit, while get the current board value in `0th` bit.\\n- Let the count live neighbors of cell (r, c) is `lives`, after processing:\\n\\t- The **cell(r, c) is live** if and only if `lives == 3` or `lives == 2 &&  board[r][c] == 1` \\n\\t- Else the **cell(r, c) is dead** \\n```python\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        m, n = len(board), len(board[0])\\n\\n        def countLiveNeighbors(r, c):\\n            cnt = 0\\n            for dr in range(-1, 2):\\n                for dc in range(-1, 2):\\n                    if dr == 0 and dc == 0: continue\\n                    nr, nc = dr + r, dc + c\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or getBit(board[nr][nc], 0) == 0: continue\\n                    cnt += 1\\n            return cnt\\n\\n        def setBit(x, k):\\n            return x | (1 << k)\\n\\n        def getBit(x, k):\\n            return (x >> k) & 1\\n\\n        for r in range(m):\\n            for c in range(n):\\n                lives = countLiveNeighbors(r, c)\\n                if lives == 3 or lives == 2 and getBit(board[r][c], 0) == 1:\\n                    board[r][c] = setBit(board[r][c], 1)\\n\\n        for r in range(m):\\n            for c in range(n):\\n                board[r][c] = getBit(board[r][c], 1)\\n```\\nComplexity:\\n- Time: `O(M * N)`, where `M` is number of rows, `N` is number of columns in the board.\\n- Space: `O(1)`\\n---\\n\\n**\\u2714\\uFE0F Follow-up 2: Infinite board**\\n> In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?\\n\\n- When the board is infinite, we can\\'t present the board using 2d array, because the number of rows and columns maybe too big.\\n- To mimic the infinite board follow up question, I add a new method `gameOfLifeInfinite`. And in `gameOfLife`, I\\'ve just converted the **board(m, n)** into **infinite board** by storing **live cells** into the set, and the row bound **m**, column bound **n** as well in case we want to limit the boundary.\\n- The output of `gameOfLifeInfinite` is the set of **live cells** after processing.\\n```python\\nclass Solution:\\n    def gameOfLifeInfinite(self, live: set, m: int, n: int) -> set:\\n        liveNeighborsCnt = defaultdict(int)  # liveNeighborsCnt[(r, c)] is the number of live neighbors around cell (r, c)\\n        for r, c in live:\\n            for dr in range(-1, 2):\\n                for dc in range(-1, 2):\\n                    if dr == 0 and dc == 0: continue\\n                    nr, nc = r + dr, c + dc\\n                    if nr < 0 or nr == m or nc < 0 or nc == n: continue  # Trim cells which have position out of the board \\n                    liveNeighborsCnt[(nr, nc)] += 1\\n\\n        ans = set()\\n        for (r, c), cnt in liveNeighborsCnt.items():\\n            if cnt == 3 or cnt == 2 and (r, c) in live:\\n                ans.add((r, c))\\n        return ans\\n\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        m, n = len(board), len(board[0])\\n        liveInput = set((r, c) for r in range(m) for c in range(n) if board[r][c] == 1)\\n        liveOutput = self.gameOfLifeInfinite(liveInput, m, n)\\n        for r in range(m):\\n            for c in range(n):\\n                board[r][c] = 1 if (r, c) in liveOutput else 0\\n```\\nComplexity for `gameOfLifeInfinite`:\\n- Time: `O(K)`, where `K` is number of live cells.\\n- Space: `O(K)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        m, n = len(board), len(board[0])\\n\\n        def countLiveNeighbors(r, c):\\n            cnt = 0\\n            for dr in range(-1, 2):\\n                for dc in range(-1, 2):\\n                    if dr == 0 and dc == 0: continue\\n                    nr, nc = dr + r, dc + c\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or getBit(board[nr][nc], 0) == 0: continue\\n                    cnt += 1\\n            return cnt\\n\\n        def setBit(x, k):\\n            return x | (1 << k)\\n\\n        def getBit(x, k):\\n            return (x >> k) & 1\\n\\n        for r in range(m):\\n            for c in range(n):\\n                lives = countLiveNeighbors(r, c)\\n                if lives == 3 or lives == 2 and getBit(board[r][c], 0) == 1:\\n                    board[r][c] = setBit(board[r][c], 1)\\n\\n        for r in range(m):\\n            for c in range(n):\\n                board[r][c] = getBit(board[r][c], 1)\\n```\n```python\\nclass Solution:\\n    def gameOfLifeInfinite(self, live: set, m: int, n: int) -> set:\\n        liveNeighborsCnt = defaultdict(int)  # liveNeighborsCnt[(r, c)] is the number of live neighbors around cell (r, c)\\n        for r, c in live:\\n            for dr in range(-1, 2):\\n                for dc in range(-1, 2):\\n                    if dr == 0 and dc == 0: continue\\n                    nr, nc = r + dr, c + dc\\n                    if nr < 0 or nr == m or nc < 0 or nc == n: continue  # Trim cells which have position out of the board \\n                    liveNeighborsCnt[(nr, nc)] += 1\\n\\n        ans = set()\\n        for (r, c), cnt in liveNeighborsCnt.items():\\n            if cnt == 3 or cnt == 2 and (r, c) in live:\\n                ans.add((r, c))\\n        return ans\\n\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        m, n = len(board), len(board[0])\\n        liveInput = set((r, c) for r in range(m) for c in range(n) if board[r][c] == 1)\\n        liveOutput = self.gameOfLifeInfinite(liveInput, m, n)\\n        for r in range(m):\\n            for c in range(n):\\n                board[r][c] = 1 if (r, c) in liveOutput else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73335,
                "title": "c-o-mn-time-o-1-space-sol",
                "content": "First this solution does not involve bit-manipulation and only involves addition of integers.\\n\\nThe idea is to go through the matrix from top-left corner to the bottom-right corner, and check only 4 cells (\"accumulate\" scores \"for both cells\" if the other cell is originally a 1). Graphically speaking, it is like this: \\n\\n    O O O \\n    O @ X\\n    X X X\\n\\nwhere the @ cell is the one that you are working on, 0 cells are those you have gone through (don't work on them again!), and the X cells are those you have not gone through and should work on. For example, if one X cell is originally a 1, you should add C (a constant) to @ cell, and simultaneously if @ cell is originally a 1, you add C to that X  cell. \\n\\nThe constant C can be 2. If it is 2 then when you will find that after done working on the current cell if it's value is 5 or 7 (cell @ is originally a 1 and have 2 or 3 neighbours) or 6 (cell @ is originally a 0 and have 3 neighbours), then you should reset it to be 1 (live), otherwise reset it to be zero (dead). And when accumulating scores, you know a cell is originally a 1 if it has odd-numbered score, and it is originally a 0 if it has even-numbered score. The code is\\n\\n    class Solution {\\n    public:\\n        void gameOfLife(vector<vector<int>>& board) {\\n            if(board.empty()) return;\\n            const int m = board.size();\\n            const int n = board[0].size();\\n            for(int i=0; i<m; i++) {\\n                for(int j=0; j<n; j++) {\\n                    check(board,i,j,i+1,j-1);\\n                    check(board,i,j,i+1,j);\\n                    check(board,i,j,i+1,j+1);\\n                    check(board,i,j,i,j+1);\\n                    if(board[i][j]>=5 && board[i][j]<=7) board[i][j]=1;\\n                    else board[i][j]=0;\\n                }\\n            }\\n        }\\n    private:\\n        void check(vector<vector<int>>& board, int i, int j, int a, int b) {\\n            const int m = board.size();\\n            const int n = board[0].size();\\n            if(a>=m || b<0 || b>=n) return;\\n            if(board[i][j]%2!=0) board[a][b]+=2;\\n            if(board[a][b]%2!=0) board[i][j]+=2;\\n        } \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void gameOfLife(vector<vector<int>>& board) {\\n            if(board.empty()) return;\\n            const int m = board.size();\\n            const int n = board[0].size();\\n            for(int i=0; i<m; i++) {\\n                for(int j=0; j<n; j++) {\\n                    check(board,i,j,i+1,j-1);\\n                    check(board,i,j,i+1,j);\\n                    check(board,i,j,i+1,j+1);\\n                    check(board,i,j,i,j+1);\\n                    if(board[i][j]>=5 && board[i][j]<=7) board[i][j]=1;\\n                    else board[i][j]=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1937883,
                "title": "java-simple-explained",
                "content": "**Idea:**\\n* For each cell on the board, count live neighbors\\n* If cell is dead and alive neighbors = 3, then, cell becomes alive\\n* Else if cell is alive and alive neighbors = 2 or 3, then cell lives on\\n* Else cell dies\\n* To do this in constant space, use the fact the all the cells on the board are 0 or 1 and are ints which have 32 bits data out of which only 1 bit is being used to represent 0 or 1\\n* So let the current state be there in the first bit (from right, i.e. LSB) and the next state in the second bit.\\n* After updating all the cells, right shift them by 1 bit, thereby representing the new state\\n>**T/S:** O(n)/O(1), where n = size(board) * size(board[0])\\n```\\nprivate static final int[][] DIRS = {{-1, -1}, // top-left\\n \\t\\t\\t\\t\\t\\t\\t\\t\\t {-1, 0},  // top\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t {-1, 1},  // top-right\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t {0, -1},  // left\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t {0, 1},   // right\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t {1, -1},  // bottom-left\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t {1, 0},   // bottom\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t {1, 1}};  // bottom-right\\n\\npublic void gameOfLife(int[][] board) {\\n\\tvar rows = board.length;\\n\\tvar cols = board[0].length;\\n\\tplayGame(board, rows, cols);\\n\\tupdateBoard(board, rows, cols);\\n}\\n\\nprivate void playGame(int[][] board, int rows, int cols) {\\n\\tfor (var i = 0; i < rows; i++)\\n\\t\\tfor (var j = 0; j < cols; j++) {\\n\\t\\t\\tvar alive = aliveNeighbors(board, rows, cols, i, j);\\n\\t\\t\\t// Dead cell with 3 live neighbors becomes alive\\n\\t\\t\\tif (board[i][j] == 0 && alive == 3) // board[i][j] = 00\\n\\t\\t\\t\\tboard[i][j] = 2; // board[i][j] = 10\\n\\t\\t\\t// Live cell with 2 or 3 live neighbors lives on\\n\\t\\t\\telse if (board[i][j] == 1 && (alive == 2 || alive == 3)) // board[i][j] = 01\\n\\t\\t\\t\\tboard[i][j] = 3; // board[i][j] = 11\\n\\t\\t}\\n}\\n\\nprivate int aliveNeighbors(int[][] board, int rows, int cols, int i, int j) {\\n\\tvar alive = 0;\\n\\tfor (var dir : DIRS) {\\n\\t\\tvar neighborX = i + dir[0];\\n\\t\\tvar neighborY = j + dir[1];\\n\\t\\tif (!isOutOfBounds(rows, cols, neighborX, neighborY))\\n\\t\\t\\talive += board[neighborX][neighborY] & 1;\\n\\t}\\n\\treturn alive;\\n}\\n\\nprivate boolean isOutOfBounds(int rows, int cols, int x, int y) {\\n\\treturn x < 0 || x >= rows || y < 0 || y >= cols;\\n}\\n\\nprivate void updateBoard(int[][] board, int rows, int cols) {\\n\\tfor (var i = 0; i < rows; i++)\\n\\t\\tfor (var j = 0; j < cols; j++)\\n\\t\\t\\tif (board[i][j] != 0) // this check is not necessary but improves efficiency\\n\\t\\t\\t\\tboard[i][j] >>= 1; // right shift 1 bit to replace old state with new state\\n}\\n```\\n\\n***Improvement***\\n* Since in the conditional check of the next state being alive, the goal is to set the the 2nd bit, it can be done by Bitwise OR with 2 (10), so this \\n```\\nif (board[i][j] == 0 && alive == 3)\\n\\tboard[i][j] = 2;\\nelse if (board[i][j] == 1 && (alive == 2 || alive == 3))\\n\\tboard[i][j] = 3;\\n```\\ncan be merged and replaced with this\\n```\\nif ((board[i][j] == 0 && alive == 3) || (board[i][j] == 1 && (alive == 2 || alive == 3)))\\n\\tboard[i][j] |= 2;\\n```\\n\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate static final int[][] DIRS = {{-1, -1}, // top-left\\n \\t\\t\\t\\t\\t\\t\\t\\t\\t {-1, 0},  // top\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t {-1, 1},  // top-right\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t {0, -1},  // left\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t {0, 1},   // right\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t {1, -1},  // bottom-left\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t {1, 0},   // bottom\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t {1, 1}};  // bottom-right\\n\\npublic void gameOfLife(int[][] board) {\\n\\tvar rows = board.length;\\n\\tvar cols = board[0].length;\\n\\tplayGame(board, rows, cols);\\n\\tupdateBoard(board, rows, cols);\\n}\\n\\nprivate void playGame(int[][] board, int rows, int cols) {\\n\\tfor (var i = 0; i < rows; i++)\\n\\t\\tfor (var j = 0; j < cols; j++) {\\n\\t\\t\\tvar alive = aliveNeighbors(board, rows, cols, i, j);\\n\\t\\t\\t// Dead cell with 3 live neighbors becomes alive\\n\\t\\t\\tif (board[i][j] == 0 && alive == 3) // board[i][j] = 00\\n\\t\\t\\t\\tboard[i][j] = 2; // board[i][j] = 10\\n\\t\\t\\t// Live cell with 2 or 3 live neighbors lives on\\n\\t\\t\\telse if (board[i][j] == 1 && (alive == 2 || alive == 3)) // board[i][j] = 01\\n\\t\\t\\t\\tboard[i][j] = 3; // board[i][j] = 11\\n\\t\\t}\\n}\\n\\nprivate int aliveNeighbors(int[][] board, int rows, int cols, int i, int j) {\\n\\tvar alive = 0;\\n\\tfor (var dir : DIRS) {\\n\\t\\tvar neighborX = i + dir[0];\\n\\t\\tvar neighborY = j + dir[1];\\n\\t\\tif (!isOutOfBounds(rows, cols, neighborX, neighborY))\\n\\t\\t\\talive += board[neighborX][neighborY] & 1;\\n\\t}\\n\\treturn alive;\\n}\\n\\nprivate boolean isOutOfBounds(int rows, int cols, int x, int y) {\\n\\treturn x < 0 || x >= rows || y < 0 || y >= cols;\\n}\\n\\nprivate void updateBoard(int[][] board, int rows, int cols) {\\n\\tfor (var i = 0; i < rows; i++)\\n\\t\\tfor (var j = 0; j < cols; j++)\\n\\t\\t\\tif (board[i][j] != 0) // this check is not necessary but improves efficiency\\n\\t\\t\\t\\tboard[i][j] >>= 1; // right shift 1 bit to replace old state with new state\\n}\\n```\n```\\nif (board[i][j] == 0 && alive == 3)\\n\\tboard[i][j] = 2;\\nelse if (board[i][j] == 1 && (alive == 2 || alive == 3))\\n\\tboard[i][j] = 3;\\n```\n```\\nif ((board[i][j] == 0 && alive == 3) || (board[i][j] == 1 && (alive == 2 || alive == 3)))\\n\\tboard[i][j] |= 2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73216,
                "title": "java-solution-using-2-bits-beats-99-75",
                "content": "       \\n    // use the 1st bit to represent next generation \\n    // use the 2nd bit to present current generation\\n\\n     public class Solution {\\n            public void gameOfLife(int[][] board) {\\n                int rows=board.length;\\n                int cols=board[0].length;\\n                for(int i=0;i<rows;++i){\\n                    for(int j=0;j<cols;++j){\\n                        int neighbors = getNeighbour(board, i, j);\\n                        if(board[i][j]==1){\\n                            if(neighbors==2 || neighbors==3)\\n                                board[i][j]=3;\\n                        }else{\\n                            if(neighbors==3)\\n                                board[i][j]=2;\\n                        }\\n                    }\\n                }    \\n                for(int i=0;i<rows;++i){\\n                    for(int j=0;j<cols;++j){\\n                        board[i][j]>>=1;\\n                    }\\n                }\\n            }\\n            \\n            private int getNeighbour(int[][] board, int row, int col){\\n                int cnt=0;\\n                for(int i=row-1;i<=row+1;++i){\\n                    for(int j=col-1;j<=col+1;++j){\\n                        if(i>=0 && i<board.length && j>=0 && j<board[0].length){\\n                            cnt += board[i][j]&1;\\n                        }\\n                    }\\n                }\\n                cnt-=board[row][col]&1;\\n                return cnt;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public void gameOfLife(int[][] board) {\\n                int rows=board.length;\\n                int cols=board[0].length;\\n                for(int i=0;i<rows;++i){\\n                    for(int j=0;j<cols;++j){\\n                        int neighbors = getNeighbour(board, i, j);\\n                        if(board[i][j]==1){\\n                            if(neighbors==2 || neighbors==3)\\n                                board[i][j]=3;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 994377,
                "title": "python-infinite-board-solution-explained",
                "content": "Let us solve the case of infinite board, which I think is the most interesting. Let us do it, using the following steps:\\n\\n1. Let us find all alive cells first.\\n2. Define list of neigbors: let us count 8 of them + we put the cell itself.\\n3. Now, for each alive cell we calculate number of active neigbours.\\n4. If it happens, that number of neigbours is equal to `3` and original cell is empty, then we need to make it alive.\\n5. If number of neigbours is not `2` or `3` (that is not `3` or `4` using also cell itself), then we need to make this cell dead.\\n\\n**Complexity**: time complexity is `O(mn)`, where `m` and `n` sizes of our board. However note, that it we do not need to find alive set fist, then we have complexity `O(A)`, where `A` is number of alive points on given iteration. Space complexity is `O(A)` as well.\\n\\n```\\nclass Solution:\\n    def gameOfLife(self, board):\\n        m, n = len(board), len(board[0])\\n        alive = set([(i, j) for i, j in product(range(m), range(n)) if board[i][j] == 1])\\n        neibs = list(product(range(-1, 2), range(-1, 2)))\\n        \\n        count = Counter()\\n        \\n        for i, j in alive:\\n            for dx, dy in neibs:\\n                count[(i+dx,j+dy)] += 1\\n                \\n        for x, y in count:\\n            if 0 <= x < m and 0 <= y < n:\\n                if count[x, y] == 3 and board[x][y] == 0: board[x][y] = 1\\n                if count[x, y] not in [3, 4]: board[x][y] = 0\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def gameOfLife(self, board):\\n        m, n = len(board), len(board[0])\\n        alive = set([(i, j) for i, j in product(range(m), range(n)) if board[i][j] == 1])\\n        neibs = list(product(range(-1, 2), range(-1, 2)))\\n        \\n        count = Counter()\\n        \\n        for i, j in alive:\\n            for dx, dy in neibs:\\n                count[(i+dx,j+dy)] += 1\\n                \\n        for x, y in count:\\n            if 0 <= x < m and 0 <= y < n:\\n                if count[x, y] == 3 and board[x][y] == 0: board[x][y] = 1\\n                if count[x, y] not in [3, 4]: board[x][y] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696582,
                "title": "python-very-simple-solution-with-explanation-no-space-used",
                "content": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        ## RC ##\\n        ## APPRAOCH : IN-PLACE MANIPULATION ##\\n        #  when the value needs to be updated, we donot just change  0 to 1 / 1 to 0 but we do in increments and decrements of 2. (table explains)        \\n        ##   previous value state change  current state   current value\\n        ##   0              no change     dead            0\\n        ##   1              no change     live            1\\n        ##   0              changed (+2)  live            2\\n        ##   1              changed (-2)  dead            -1\\n        \\n\\t\\t## TIME COMPLEXITY : O(MxN) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        directions = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]\\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                live = 0                # live neighbors count\\n                for x, y in directions: # check and count neighbors in all directions\\n                    if ( i + x < len(board) and i + x >= 0 ) and ( j + y < len(board[0]) and j + y >=0 ) and abs(board[i + x][j + y]) == 1:\\n                        live += 1\\n                if board[i][j] == 1 and (live < 2 or live > 3):     # Rule 1 or Rule 3\\n                    board[i][j] = -1\\n                if board[i][j] == 0 and live == 3:                  # Rule 4\\n                    board[i][j] = 2\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                board[i][j] = 1 if(board[i][j] > 0) else 0\\n        return board\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        ## RC ##\\n        ## APPRAOCH : IN-PLACE MANIPULATION ##\\n        #  when the value needs to be updated, we donot just change  0 to 1 / 1 to 0 but we do in increments and decrements of 2. (table explains)        \\n        ##   previous value state change  current state   current value\\n        ##   0              no change     dead            0\\n        ##   1              no change     live            1\\n        ##   0              changed (+2)  live            2\\n        ##   1              changed (-2)  dead            -1\\n        \\n\\t\\t## TIME COMPLEXITY : O(MxN) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        directions = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]\\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                live = 0                # live neighbors count\\n                for x, y in directions: # check and count neighbors in all directions\\n                    if ( i + x < len(board) and i + x >= 0 ) and ( j + y < len(board[0]) and j + y >=0 ) and abs(board[i + x][j + y]) == 1:\\n                        live += 1\\n                if board[i][j] == 1 and (live < 2 or live > 3):     # Rule 1 or Rule 3\\n                    board[i][j] = -1\\n                if board[i][j] == 0 and live == 3:                  # Rule 4\\n                    board[i][j] = 2\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                board[i][j] = 1 if(board[i][j] > 0) else 0\\n        return board\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174179,
                "title": "python-100-with-explanation",
                "content": "The idea is:\\nif board[x][y] == 1, change its value to count(x,y) + 1, the reason I add 1 is to keep it positive \\nelse:change its value to -count(x,y), so it will be either 0 or negative\\nThis way, we wouldn\\'t mess up the number of live neighbors.\\nThe first time we use this strategy to do counting. The second time, we set the value to 1 if we see \\n3 ( = 2 + 1, means 2 live neighbors), \\n4 (3 live neighbors) \\n-3 (3 live neighbors for dead cell)\\n```\\nclass Solution(object):\\n    def gameOfLife(self, board):\\n        \"\"\"\\n        :type board: List[List[int]]\\n        :rtype: void Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def count(x, y):\\n            res = 0\\n            for r in range(x-1, x+2):\\n                for c in range(y-1, y+2):\\n                    if (r != x or c != y) and 0 <= r < len(board) and 0 <= c < len(board[0]) and board[r][c] > 0:\\n                        res += 1\\n            return res\\n        \\n        for x in range(len(board)):\\n            for y in range(len(board[0])):\\n                board[x][y] = count(x,y) + 1 if board[x][y] == 1 else - count(x,y) \\n        \\n        for x in range(len(board)):\\n            for y in range(len(board[0])):\\n                board[x][y] = 1 if board[x][y] in {3,4,-3} else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def gameOfLife(self, board):\\n        \"\"\"\\n        :type board: List[List[int]]\\n        :rtype: void Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def count(x, y):\\n            res = 0\\n            for r in range(x-1, x+2):\\n                for c in range(y-1, y+2):\\n                    if (r != x or c != y) and 0 <= r < len(board) and 0 <= c < len(board[0]) and board[r][c] > 0:\\n                        res += 1\\n            return res\\n        \\n        for x in range(len(board)):\\n            for y in range(len(board[0])):\\n                board[x][y] = count(x,y) + 1 if board[x][y] == 1 else - count(x,y) \\n        \\n        for x in range(len(board)):\\n            for y in range(len(board[0])):\\n                board[x][y] = 1 if board[x][y] in {3,4,-3} else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938011,
                "title": "c-step-by-step-walk-through",
                "content": "```\\nAlgorithm\\n---------\\n#Step1: Store current state of the board\\n#Step2: Compute number of live neighbors in current state for each cell\\n#Step3: Apply the given conditions and update live status for next state\\n#Step4: Return\\n\\nComplexities\\n------------\\n#Time: O(row*col)\\n#Space: O(row*col)\\n```\\n```\\nclass Solution {\\npublic:\\n    int R, C;\\n    bool isLive(int status) {\\n        return status == 1;\\n    }\\n    int getLiveNeighborsCnt(int row, int col, vector<vector<int>>& board) {\\n        int cnt = 0;\\n        cnt += row - 1 >= 0 && board[row - 1][col] ? 1 : 0;\\n        cnt += row + 1 < R && board[row + 1][col] ? 1 : 0;\\n        cnt += col - 1 >= 0 && board[row][col - 1] ? 1 : 0;\\n        cnt += col + 1 < C && board[row][col + 1] ? 1 : 0;\\n        cnt += row - 1 >= 0 && col - 1 >= 0 && board[row - 1][col - 1] ? 1 : 0;\\n        cnt += row - 1 >= 0 && col + 1 < C && board[row - 1][col + 1] ? 1 : 0;\\n        cnt += row + 1 < R && col - 1 >= 0 && board[row + 1][col - 1] ? 1 : 0;\\n        cnt += row + 1 < R && col + 1 < C && board[row + 1][col + 1] ? 1 : 0;\\n        \\n        return cnt;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        R = board.size(), C = board[0].size();\\n\\t\\tint liveNeighborsCnt;\\n\\t\\t// store current board state\\n        vector<vector<int>> tempBoard = board;        \\n        for(int r = 0; r < R; r++) {\\n            for(int c = 0; c < C; c++) {\\n\\t\\t\\t\\t// compute number of live neighbors\\n                liveNeighborsCnt = getLiveNeighborsCnt(r, c, tempBoard);\\n\\t\\t\\t\\t// Apply conditions and update state of board\\n                if(isLive(board[r][c])) {\\n                    if(liveNeighborsCnt < 2 || liveNeighborsCnt > 3) board[r][c] = 0;\\n                } else {\\n                    board[r][c] = liveNeighborsCnt == 3 ? 1 : 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nAlgorithm\\n---------\\n#Step1: Store current state of the board\\n#Step2: Compute number of live neighbors in current state for each cell\\n#Step3: Apply the given conditions and update live status for next state\\n#Step4: Return\\n\\nComplexities\\n------------\\n#Time: O(row*col)\\n#Space: O(row*col)\\n```\n```\\nclass Solution {\\npublic:\\n    int R, C;\\n    bool isLive(int status) {\\n        return status == 1;\\n    }\\n    int getLiveNeighborsCnt(int row, int col, vector<vector<int>>& board) {\\n        int cnt = 0;\\n        cnt += row - 1 >= 0 && board[row - 1][col] ? 1 : 0;\\n        cnt += row + 1 < R && board[row + 1][col] ? 1 : 0;\\n        cnt += col - 1 >= 0 && board[row][col - 1] ? 1 : 0;\\n        cnt += col + 1 < C && board[row][col + 1] ? 1 : 0;\\n        cnt += row - 1 >= 0 && col - 1 >= 0 && board[row - 1][col - 1] ? 1 : 0;\\n        cnt += row - 1 >= 0 && col + 1 < C && board[row - 1][col + 1] ? 1 : 0;\\n        cnt += row + 1 < R && col - 1 >= 0 && board[row + 1][col - 1] ? 1 : 0;\\n        cnt += row + 1 < R && col + 1 < C && board[row + 1][col + 1] ? 1 : 0;\\n        \\n        return cnt;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        R = board.size(), C = board[0].size();\\n\\t\\tint liveNeighborsCnt;\\n\\t\\t// store current board state\\n        vector<vector<int>> tempBoard = board;        \\n        for(int r = 0; r < R; r++) {\\n            for(int c = 0; c < C; c++) {\\n\\t\\t\\t\\t// compute number of live neighbors\\n                liveNeighborsCnt = getLiveNeighborsCnt(r, c, tempBoard);\\n\\t\\t\\t\\t// Apply conditions and update state of board\\n                if(isLive(board[r][c])) {\\n                    if(liveNeighborsCnt < 2 || liveNeighborsCnt > 3) board[r][c] = 0;\\n                } else {\\n                    board[r][c] = liveNeighborsCnt == 3 ? 1 : 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937823,
                "title": "game-of-life-medium-learned-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int getLiveNeigh(vector<vector<int>>& temp, int i, int j, int m, int n) {\\n        int liveNeigh = 0;\\n        if(i > 0) {\\n            if(temp[i-1][j] == 1) {\\n                liveNeigh++;\\n            }\\n        } \\n        \\n        if(i < m-1) {\\n            if(temp[i+1][j] == 1) {\\n                liveNeigh++;\\n            }\\n        } \\n        \\n        if(j > 0) {\\n            if(temp[i][j-1] == 1) {\\n                liveNeigh++;\\n            }\\n        }\\n        \\n        if(j < n-1) {\\n            if(temp[i][j+1] == 1) {\\n                liveNeigh++;\\n            }\\n        } \\n        \\n        if(i > 0 && j > 0) {\\n            if(temp[i-1][j-1] == 1) {\\n                liveNeigh++;\\n            }\\n        } \\n        \\n        if(i < m-1 && j < n-1) {\\n            if(temp[i+1][j+1] == 1) {\\n                liveNeigh++;\\n            }\\n        } \\n        \\n        if(i < m-1 && j > 0) {\\n            if(temp[i+1][j-1] == 1) {\\n                liveNeigh++;\\n            }\\n        } \\n        \\n        if(i > 0 && j < n-1) {\\n            if(temp[i-1][j+1] == 1) {\\n                liveNeigh++;\\n            }\\n        }\\n        \\n        return liveNeigh;\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<vector<int>> temp = board;\\n        int m = board.size();\\n\\t    int n = board[0].size();\\n        for(int i=0; i < m; i++) {\\n            for(int j=0; j < n; j++) {\\n                int res = getLiveNeigh(temp, i, j, m, n);\\n                if(board[i][j] == 0) {\\n                    if(res == 3) {\\n                        board[i][j] = 1;\\n                    }\\n                } else {\\n                    if(res < 2 || res > 3) {\\n                        board[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\nIf you understood the problem, kindly **UpVote**.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getLiveNeigh(vector<vector<int>>& temp, int i, int j, int m, int n) {\\n        int liveNeigh = 0;\\n        if(i > 0) {\\n            if(temp[i-1][j] == 1) {\\n                liveNeigh++;\\n            }\\n        } \\n        \\n        if(i < m-1) {\\n            if(temp[i+1][j] == 1) {\\n                liveNeigh++;\\n            }\\n        } \\n        \\n        if(j > 0) {\\n            if(temp[i][j-1] == 1) {\\n                liveNeigh++;\\n            }\\n        }\\n        \\n        if(j < n-1) {\\n            if(temp[i][j+1] == 1) {\\n                liveNeigh++;\\n            }\\n        } \\n        \\n        if(i > 0 && j > 0) {\\n            if(temp[i-1][j-1] == 1) {\\n                liveNeigh++;\\n            }\\n        } \\n        \\n        if(i < m-1 && j < n-1) {\\n            if(temp[i+1][j+1] == 1) {\\n                liveNeigh++;\\n            }\\n        } \\n        \\n        if(i < m-1 && j > 0) {\\n            if(temp[i+1][j-1] == 1) {\\n                liveNeigh++;\\n            }\\n        } \\n        \\n        if(i > 0 && j < n-1) {\\n            if(temp[i-1][j+1] == 1) {\\n                liveNeigh++;\\n            }\\n        }\\n        \\n        return liveNeigh;\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<vector<int>> temp = board;\\n        int m = board.size();\\n\\t    int n = board[0].size();\\n        for(int i=0; i < m; i++) {\\n            for(int j=0; j < n; j++) {\\n                int res = getLiveNeigh(temp, i, j, m, n);\\n                if(board[i][j] == 0) {\\n                    if(res == 3) {\\n                        board[i][j] = 1;\\n                    }\\n                } else {\\n                    if(res < 2 || res > 3) {\\n                        board[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520732,
                "title": "java-tc-o-mn-sc-o-1-optimal-in-place-infinite-board-solutions",
                "content": "**Optimal In-place Solution**\\n```java\\n/**\\n * To solve it in place, we use 2 bits to store 2 states: [2nd bit, 1st bit] =\\n * [next state, current state]\\n *\\n * For each cell, check the current state of 8 neighbors, and set the cell\\'s 2nd\\n * bit. Transition 01 -> 11: when board == 1 and lives >= 2 && lives <= 3.\\n * Transition 00 -> 10: when board == 0 and lives == 3.\\n *\\n * To get the current state, simply do board[i][j] & 1\\n * To get the next state, simply do board[i][j] >>> 1\\n *\\n * Time Complexity: O(8*M*N +M*N) = O(M * N)\\n *\\n * Space Complexity: O(1)\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { 0, 1 }, { 1, 1 }, { 1, 0 }, { 1, -1 }, { 0, -1 }, { -1, -1 }, { -1, 0 }, { -1, 1 } };\\n\\n    public void gameOfLife(int[][] board) {\\n        if (board == null || board.length == 0 || board[0].length == 0) {\\n            return;\\n        }\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                int liveCount = 0;\\n                for (int[] d : DIRS) {\\n                    int x = i + d[0];\\n                    int y = j + d[1];\\n                    if (x >= 0 && x < rows && y >= 0 && y < cols) {\\n                        liveCount += board[x][y] & 1;\\n                    }\\n                }\\n                if (liveCount == 3 || (board[i][j] == 1 && liveCount == 2)) {\\n                    board[i][j] |= 2; // 1 << 1\\n                }\\n            }\\n        }\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                board[i][j] >>>= 1;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n**Follow-up: Infinite Board**\\n\\n```java\\n/**\\n * Follow-up: Infinite Board\\n *\\n * Time Complexity: O(8*N + 8*N) = O(N)\\n *\\n * Space Complexity: O(8*N + N) = O(N)\\n *\\n * N = Number of live cells\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { 0, 1 }, { 1, 1 }, { 1, 0 }, { 1, -1 }, { 0, -1 }, { -1, -1 }, { -1, 0 }, { -1, 1 } };\\n\\n    public void gameOfLife(int[][] board) {\\n        if (board == null || board.length == 0 || board[0].length == 0) {\\n            return;\\n        }\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        HashSet<Pair<Integer, Integer>> currentState = new HashSet<>();\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (board[i][j] == 1) {\\n                    currentState.add(new Pair<>(i, j));\\n                }\\n            }\\n        }\\n\\n        HashSet<Pair<Integer, Integer>> nextState = gameOfLifeInfinite(currentState);\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                board[i][j] = nextState.contains(new Pair<>(i, j)) ? 1 : 0;\\n            }\\n        }\\n    }\\n\\n    public HashSet<Pair<Integer, Integer>> gameOfLifeInfinite(HashSet<Pair<Integer, Integer>> currentState) {\\n        HashSet<Pair<Integer, Integer>> nextState = new HashSet<>();\\n        if (currentState == null || currentState.size() == 0) {\\n            return nextState;\\n        }\\n\\n        HashMap<Pair<Integer, Integer>, Integer> map = new HashMap<>();\\n        for (Pair<Integer, Integer> c : currentState) {\\n            for (int[] d : DIRS) {\\n                Pair<Integer, Integer> neighbor = new Pair<>(c.getKey() + d[0], c.getValue() + d[1]);\\n                map.put(neighbor, map.getOrDefault(neighbor, 0) + 1);\\n            }\\n        }\\n        for (Pair<Integer, Integer> c : map.keySet()) {\\n            int count = map.get(c);\\n            if (count == 3 || (count == 2 && currentState.contains(c))) {\\n                nextState.add(c);\\n            }\\n        }\\n        return nextState;\\n    }\\n}\\n```\\n\\n---\\n\\nSolution to other similiar question on LeetCode:\\n- [661. Image Smoother](https://leetcode.com/problems/image-smoother/discuss/1520730/Java-or-TC:-O(MN)-or-SC:-O(1)-or-Optimal-in-place-solution-without-creating-a-new-matrix)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * To solve it in place, we use 2 bits to store 2 states: [2nd bit, 1st bit] =\\n * [next state, current state]\\n *\\n * For each cell, check the current state of 8 neighbors, and set the cell\\'s 2nd\\n * bit. Transition 01 -> 11: when board == 1 and lives >= 2 && lives <= 3.\\n * Transition 00 -> 10: when board == 0 and lives == 3.\\n *\\n * To get the current state, simply do board[i][j] & 1\\n * To get the next state, simply do board[i][j] >>> 1\\n *\\n * Time Complexity: O(8*M*N +M*N) = O(M * N)\\n *\\n * Space Complexity: O(1)\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { 0, 1 }, { 1, 1 }, { 1, 0 }, { 1, -1 }, { 0, -1 }, { -1, -1 }, { -1, 0 }, { -1, 1 } };\\n\\n    public void gameOfLife(int[][] board) {\\n        if (board == null || board.length == 0 || board[0].length == 0) {\\n            return;\\n        }\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                int liveCount = 0;\\n                for (int[] d : DIRS) {\\n                    int x = i + d[0];\\n                    int y = j + d[1];\\n                    if (x >= 0 && x < rows && y >= 0 && y < cols) {\\n                        liveCount += board[x][y] & 1;\\n                    }\\n                }\\n                if (liveCount == 3 || (board[i][j] == 1 && liveCount == 2)) {\\n                    board[i][j] |= 2; // 1 << 1\\n                }\\n            }\\n        }\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                board[i][j] >>>= 1;\\n            }\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Follow-up: Infinite Board\\n *\\n * Time Complexity: O(8*N + 8*N) = O(N)\\n *\\n * Space Complexity: O(8*N + N) = O(N)\\n *\\n * N = Number of live cells\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { 0, 1 }, { 1, 1 }, { 1, 0 }, { 1, -1 }, { 0, -1 }, { -1, -1 }, { -1, 0 }, { -1, 1 } };\\n\\n    public void gameOfLife(int[][] board) {\\n        if (board == null || board.length == 0 || board[0].length == 0) {\\n            return;\\n        }\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        HashSet<Pair<Integer, Integer>> currentState = new HashSet<>();\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (board[i][j] == 1) {\\n                    currentState.add(new Pair<>(i, j));\\n                }\\n            }\\n        }\\n\\n        HashSet<Pair<Integer, Integer>> nextState = gameOfLifeInfinite(currentState);\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                board[i][j] = nextState.contains(new Pair<>(i, j)) ? 1 : 0;\\n            }\\n        }\\n    }\\n\\n    public HashSet<Pair<Integer, Integer>> gameOfLifeInfinite(HashSet<Pair<Integer, Integer>> currentState) {\\n        HashSet<Pair<Integer, Integer>> nextState = new HashSet<>();\\n        if (currentState == null || currentState.size() == 0) {\\n            return nextState;\\n        }\\n\\n        HashMap<Pair<Integer, Integer>, Integer> map = new HashMap<>();\\n        for (Pair<Integer, Integer> c : currentState) {\\n            for (int[] d : DIRS) {\\n                Pair<Integer, Integer> neighbor = new Pair<>(c.getKey() + d[0], c.getValue() + d[1]);\\n                map.put(neighbor, map.getOrDefault(neighbor, 0) + 1);\\n            }\\n        }\\n        for (Pair<Integer, Integer> c : map.keySet()) {\\n            int count = map.get(c);\\n            if (count == 3 || (count == 2 && currentState.contains(c))) {\\n                nextState.add(c);\\n            }\\n        }\\n        return nextState;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73312,
                "title": "javascript-in-place-solution-using-math-floor-and-math-ceil",
                "content": "    /**\\n     * @param {number[][]} board\\n     * @return {void} Do not return anything, modify board in-place instead.\\n     */\\n    var gameOfLife = function(board) {\\n        if(board.length === 0){\\n            return board;\\n        }\\n        \\n        var checkNeighbors = function(row, col){\\n          var score = -board[row][col];\\n          var r, c;\\n          for(r = row - 1; r <= row + 1; r++){\\n              for(c = col - 1; c <= col + 1; c++){\\n                  if(typeof board[r] !== \"undefined\" && typeof board[r][c] !== \"undefined\"){\\n                    score += Math.abs(Math.floor(board[r][c]));\\n                  }\\n              }\\n          }\\n          return score;\\n        };\\n        \\n        var r, c;\\n        for(r = 0; r < board.length; r++){\\n            for(c = 0; c < board[0].length; c++){\\n                var score = checkNeighbors(r, c);\\n                if(board[r][c] === 1){\\n                    if(score < 2 || score > 3){\\n                        board[r][c] = -0.5;\\n                    }\\n                }\\n                else if(board[r][c] === 0){\\n                    if(score === 3){\\n                        board[r][c] = 0.5;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(r = 0; r < board.length; r++){\\n            for(c = 0; c < board[0].length; c++){\\n                board[r][c] = Math.ceil(board[r][c]);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    /**\\n     * @param {number[][]} board\\n     * @return {void} Do not return anything, modify board in-place instead.\\n     */\\n    var gameOfLife = function(board) {\\n        if(board.length === 0){\\n            return board;\\n        }\\n        \\n        var checkNeighbors = function(row, col){\\n          var score = -board[row][col];\\n          var r, c;\\n          for(r = row - 1; r <= row + 1; r++){\\n              for(c = col - 1; c <= col + 1; c++){\\n                  if(typeof board[r] !== \"undefined\" && typeof board[r][c] !== \"undefined\"){\\n                    score += Math.abs(Math.floor(board[r][c]));\\n                  }\\n              }\\n          }\\n          return score;\\n        };\\n        \\n        var r, c;\\n        for(r = 0; r < board.length; r++){\\n            for(c = 0; c < board[0].length; c++){\\n                var score = checkNeighbors(r, c);\\n                if(board[r][c] === 1){\\n                    if(score < 2 || score > 3){\\n                        board[r][c] = -0.5;\\n                    }\\n                }\\n                else if(board[r][c] === 0){\\n                    if(score === 3){\\n                        board[r][c] = 0.5;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(r = 0; r < board.length; r++){\\n            for(c = 0; c < board[0].length; c++){\\n                board[r][c] = Math.ceil(board[r][c]);\\n            }\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 73244,
                "title": "clear-java-solution",
                "content": "    public class Solution {\\n        public void gameOfLife(int[][] board) {\\n            int m = board.length, n = board[0].length;\\n            int[][] result = new int[m][n];\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    int countLive = 0;\\n                    for (int p = Math.max(i-1,0); p < Math.min(i+2,m); p++) {\\n                        for (int q = Math.max(j-1,0); q < Math.min(j+2,n); q++) {\\n                            if (board[p][q]==2||board[p][q]==1) countLive++;//count status 0 is live\\n                        }\\n                    }\\n                    countLive -= board[i][j];\\n                    if (board[i][j] == 0 && countLive == 3) board[i][j] = 3; //status 0 is dead,next status is live\\n                    if (board[i][j] == 1 && (countLive < 2 || countLive > 3)) board[i][j] = 2; //status 0 is live,next status is dead\\n                    \\n                }\\n            }\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    board[i][j] %= 2;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void gameOfLife(int[][] board) {\\n            int m = board.length, n = board[0].length;\\n            int[][] result = new int[m][n];\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    int countLive = 0;\\n                    for (int p = Math.max(i-1,0); p < Math.min(i+2,m); p++) {\\n                        for (int q = Math.max(j-1,0); q < Math.min(j+2,n); q++) {\\n                            if (board[p][q]==2||board[p][q]==1) countLive++;//count status 0 is live\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1938258,
                "title": "o-1-space-inplace",
                "content": "**Explanation** :\\n\\nWe have to record 2 values for a cell  **{Orginal Value for neighbours,New value denoting live or death for result}**\\n    \\n+ There can be four cases:\\n **Previous-State**  and **Original-State** of a cell can be any of these follows :  **(die,die)** ,  **(die,live)** , **(live,live)** , **(live,die)**\\n       \\n   Now we have to use **a single value denoting both the properties of a call**.\\n     \\n   For **Original-State of Cell** -> if it is **0**, we will make it **2** and if it is **1**, we will make it **1**.\\n   **Now on the basis of count of live neighnours, we will updating the original**:\\n     `If A dead cell remains dead, we will make it -ve`\\n     `If A live cell becomes dead , we will make it -ve`\\n     \\n    **+sign -> Now it is live cell**\\n    **-sign -> Now it is dead cell**\\n    **abs(Val)==1 -> It was a live cell**\\n    **abs(val)==2 -> It was a dead cell**\\n     \\n     **Now result will be like this**:\\n     **+1** -> it was a live cell and new state is also live\\n     **-1** -> it was a live cell and new state is dead\\n     **+2** -> it was a dead cell and new state is live\\n     **-2** -> it was a dead cell and new state is also dead.\\n\\t \\n**C++**    \\n    \\n    void gameOfLife(vector<vector<int>>& A) {\\n        int m= size(A), n=size(A[0]);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int res= count(A,i,j,m,n); //count live neighbours\\n                //original alive\\n                if(A[i][j]==1){\\n                    if(res<2 or res>3) A[i][j]=-A[i][j];   \\n                }\\n                else{\\n                    A[i][j]=2;  //make it 2 for identifying it as a dead cell\\n                    if(res!=3) A[i][j]=-A[i][j]; //make -2 if still dead\\n                }\\n            }\\n        }\\n        //convert all -ve to 0 and +ve to 1\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++) A[i][j]= A[i][j]<0? 0 : 1;\\n    }\\n    \\n    //indices of neighbours in 8 direction\\n    int dis[8][2]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n    \\n    //function for counting the live neighbours of current cell\\n    int count(vector<vector<int>>& A,int i,int j,int m,int n){\\n        int cnt=0;\\n        for(int k=0;k<8;k++){\\n            int x= i+dis[k][0];\\n            int y= j+dis[k][1];\\n            if(x>=0 and y>=0 and x<m and y<n and abs(A[x][y])==1) cnt++;\\n        }\\n        return cnt;\\n    }\\n\\n**Time** - O(m * n)\\n**Space** - O(1)\\t \\n\\n**Java** :\\n\\n    public void gameOfLife(int[][] A) {\\n        int m= A.length, n=A[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int res= count(A,i,j,m,n); //count live neighbours\\n                //original alive\\n                if(A[i][j]==1){\\n                    if(res<2 || res>3) A[i][j]=-A[i][j];   \\n                }\\n                else{\\n                    A[i][j]=2;  //make it 2 for identifying it as a dead cell\\n                    if(res!=3) A[i][j]=-A[i][j]; //make -2 if still dead\\n                }\\n            }\\n        }\\n        \\n        //convert all -ve to 0 and +ve to 1\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++) A[i][j]= A[i][j]<0? 0 : 1;\\n    }\\n    \\n    //indices of neighbours in 8 direction\\n    int dis[][]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n    \\n    //function for counting the live neighbours of current cell\\n    int count(int[][] A,int i,int j,int m,int n){\\n        int cnt=0;\\n        for(int k=0;k<8;k++){\\n            int x= i+dis[k][0], y= j+dis[k][1];\\n            if(x>=0 && y>=0 && x<m && y<n && Math.abs(A[x][y])==1) cnt++;\\n        }\\n        return cnt;\\n    }\\n**Time** - O(m * n)\\n**Space** - O(1)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "**Explanation** :\\n\\nWe have to record 2 values for a cell  **{Orginal Value for neighbours,New value denoting live or death for result}**\\n    \\n+ There can be four cases:\\n **Previous-State**  and **Original-State** of a cell can be any of these follows :  **(die,die)** ,  **(die,live)** , **(live,live)** , **(live,die)**\\n       \\n   Now we have to use **a single value denoting both the properties of a call**.\\n     \\n   For **Original-State of Cell** -> if it is **0**, we will make it **2** and if it is **1**, we will make it **1**.\\n   **Now on the basis of count of live neighnours, we will updating the original**:\\n     `If A dead cell remains dead, we will make it -ve`\\n     `If A live cell becomes dead , we will make it -ve`\\n     \\n    **+sign -> Now it is live cell**\\n    **-sign -> Now it is dead cell**\\n    **abs(Val)==1 -> It was a live cell**\\n    **abs(val)==2 -> It was a dead cell**\\n     \\n     **Now result will be like this**:\\n     **+1** -> it was a live cell and new state is also live\\n     **-1** -> it was a live cell and new state is dead\\n     **+2** -> it was a dead cell and new state is live\\n     **-2** -> it was a dead cell and new state is also dead.\\n\\t \\n**C++**    \\n    \\n    void gameOfLife(vector<vector<int>>& A) {\\n        int m= size(A), n=size(A[0]);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int res= count(A,i,j,m,n); //count live neighbours\\n                //original alive\\n                if(A[i][j]==1){\\n                    if(res<2 or res>3) A[i][j]=-A[i][j];   \\n                }\\n                else{\\n                    A[i][j]=2;  //make it 2 for identifying it as a dead cell\\n                    if(res!=3) A[i][j]=-A[i][j]; //make -2 if still dead\\n                }\\n            }\\n        }\\n        //convert all -ve to 0 and +ve to 1\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++) A[i][j]= A[i][j]<0? 0 : 1;\\n    }\\n    \\n    //indices of neighbours in 8 direction\\n    int dis[8][2]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n    \\n    //function for counting the live neighbours of current cell\\n    int count(vector<vector<int>>& A,int i,int j,int m,int n){\\n        int cnt=0;\\n        for(int k=0;k<8;k++){\\n            int x= i+dis[k][0];\\n            int y= j+dis[k][1];\\n            if(x>=0 and y>=0 and x<m and y<n and abs(A[x][y])==1) cnt++;\\n        }\\n        return cnt;\\n    }\\n\\n**Time** - O(m * n)\\n**Space** - O(1)\\t \\n\\n**Java** :\\n\\n    public void gameOfLife(int[][] A) {\\n        int m= A.length, n=A[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int res= count(A,i,j,m,n); //count live neighbours\\n                //original alive\\n                if(A[i][j]==1){\\n                    if(res<2 || res>3) A[i][j]=-A[i][j];   \\n                }\\n                else{\\n                    A[i][j]=2;  //make it 2 for identifying it as a dead cell\\n                    if(res!=3) A[i][j]=-A[i][j]; //make -2 if still dead\\n                }\\n            }\\n        }\\n        \\n        //convert all -ve to 0 and +ve to 1\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++) A[i][j]= A[i][j]<0? 0 : 1;\\n    }\\n    \\n    //indices of neighbours in 8 direction\\n    int dis[][]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n    \\n    //function for counting the live neighbours of current cell\\n    int count(int[][] A,int i,int j,int m,int n){\\n        int cnt=0;\\n        for(int k=0;k<8;k++){\\n            int x= i+dis[k][0], y= j+dis[k][1];\\n            if(x>=0 && y>=0 && x<m && y<n && Math.abs(A[x][y])==1) cnt++;\\n        }\\n        return cnt;\\n    }\\n**Time** - O(m * n)\\n**Space** - O(1)",
                "codeTag": "Unknown"
            },
            {
                "id": 73361,
                "title": "python-just-one-simple-statement",
                "content": "Well, [simple statement](https://docs.python.org/2/reference/simple_stmts.html) as defined by Python :-P\\n\\n    def gameOfLife(self, board):\\n        board[:] = [[(2*sum(sum(row[j-(j>0):j+2])\\n                            for row in board[i-(i>0):i+2])\\n                      - live) % 13 % 8 / 5\\n                     for j, live in enumerate(row)]\\n                    for i, row in enumerate(board)]\\n\\n**Update**\\n\\n-3 votes? Guessing that people don't like the (2*count - live) % 13 % 8 / 5, which was my first attempt at finding an expression using \"count\" only once. Here's a nicer version, storing it in a variable so I can use it twice:\\n\\n    def gameOfLife(self, board):\\n        board[:] = [[int(3 in (count, count - live))\\n                     for j, live in enumerate(row)\\n                     for count in [sum(sum(row[j-(j>0):j+2])\\n                                       for row in board[i-(i>0):i+2])]]\\n                    for i, row in enumerate(board)]\\n\\nAn in case it needs an explanation, `count` tells me the number of living cells among (i, j) and its eight neighbors.\\n\\n**Update 2**\\n\\n-4 votes now... would someone maybe tell me why?\\n\\n**Update 3**\\n\\nChanged `max(i-1, 0)` to `i-(i>0)`. And same for `j`.",
                "solutionTags": [
                    "Python"
                ],
                "code": "Well, [simple statement](https://docs.python.org/2/reference/simple_stmts.html) as defined by Python :-P\\n\\n    def gameOfLife(self, board):\\n        board[:] = [[(2*sum(sum(row[j-(j>0):j+2])\\n                            for row in board[i-(i>0):i+2])\\n                      - live) % 13 % 8 / 5\\n                     for j, live in enumerate(row)]\\n                    for i, row in enumerate(board)]\\n\\n**Update**\\n\\n-3 votes? Guessing that people don't like the (2*count - live) % 13 % 8 / 5, which was my first attempt at finding an expression using \"count\" only once. Here's a nicer version, storing it in a variable so I can use it twice:\\n\\n    def gameOfLife(self, board):\\n        board[:] = [[int(3 in (count, count - live))\\n                     for j, live in enumerate(row)\\n                     for count in [sum(sum(row[j-(j>0):j+2])\\n                                       for row in board[i-(i>0):i+2])]]\\n                    for i, row in enumerate(board)]\\n\\nAn in case it needs an explanation, `count` tells me the number of living cells among (i, j) and its eight neighbors.\\n\\n**Update 2**\\n\\n-4 votes now... would someone maybe tell me why?\\n\\n**Update 3**\\n\\nChanged `max(i-1, 0)` to `i-(i>0)`. And same for `j`.",
                "codeTag": "Python3"
            },
            {
                "id": 993526,
                "title": "c-and-python-simple-solutions-w-comments-o-nm-time-o-1-space",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    // Helper function to check validility of neighbor\\n    bool isValidNeighbor(int x, int y, vector<vector<int>>& board) {\\n        return (x >= 0 && x < board.size() && y >= 0 && y < board[0].size());\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        // All directions of neighbors\\n        vector<int> ways_x = {0, 0, 1, 1, 1, -1, -1, -1};\\n        vector<int> ways_y = {1, -1, 1, -1, 0, 0, 1, -1};\\n        \\n        for (int row = 0; row < board.size(); row++) {\\n            for (int col = 0; col < board[0].size(); col++) {\\n                \\n                int count_live_neighbors = 0;\\n                \\n                // Loop to count all live neighbors\\n                for (int i = 0; i < 8; i++) {\\n                    int curr_x = row + ways_x[i], curr_y = col + ways_y[i];\\n                    if (isValidNeighbor(curr_x, curr_y, board) && abs(board[curr_x][curr_y]) == 1)\\n                        count_live_neighbors++;\\n                }\\n                \\n                // Rules 1 and 3: -1 indicates a cell that was live but now is dead.\\n                if (board[row][col] == 1 && (count_live_neighbors < 2 || count_live_neighbors > 3))\\n                    board[row][col] = -1;\\n                \\n                // Rule 4: 2 indicates a cell that was dead but now is live.\\n                if (board[row][col] == 0 && count_live_neighbors == 3)\\n                    board[row][col] = 2;\\n            }\\n        }\\n        \\n        // Get the final board\\n        for (int row = 0; row < board.size(); row++) {\\n            for (int col = 0; col < board[0].size(); col++) {\\n                if (board[row][col] >= 1)\\n                    board[row][col] = 1;\\n                else\\n                    board[row][col] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        # Helper function to check validility of neighbor\\n        def isValidNeighbor(x, y):\\n            return x < len(board) and x >= 0 and y < len(board[0]) and y >= 0\\n\\n        # All directions of neighbors\\n        ways_x = [0, 0, 1, 1, 1, -1, -1, -1]\\n        ways_y = [1, -1, 1, -1, 0, 0, 1, -1]\\n        \\n        for row in range(len(board)):\\n            for col in range(len(board[0])):\\n                \\n                # Loop to count all live neighbors\\n                count_live_neighbors = 0\\n                for i in range(8):\\n                    curr_x, curr_y = row + ways_x[i], col + ways_y[i]\\n                    if isValidNeighbor(curr_x, curr_y) and abs(board[curr_x][curr_y]) == 1:\\n                        count_live_neighbors+=1\\n                \\n                # Rules 1 and 3: -1 indicates a cell that was live but now is dead.\\n                if board[row][col] == 1 and (count_live_neighbors < 2 or count_live_neighbors > 3):\\n                    board[row][col] = -1\\n                    \\n                # Rule 4: 2 indicates a cell that was dead but now is live.\\n                if board[row][col] == 0 and count_live_neighbors == 3:\\n                    board[row][col] = 2\\n                 \\n        # Get the final board\\n        for row in range(len(board)):\\n            for col in range(len(board[0])):\\n                if board[row][col] >= 1:\\n                    board[row][col] = 1\\n                else:\\n                    board[row][col] = 0\\n```\\n**Like it? please upvote!!!\\nHave any comments? I\\'d love to hear...**",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to check validility of neighbor\\n    bool isValidNeighbor(int x, int y, vector<vector<int>>& board) {\\n        return (x >= 0 && x < board.size() && y >= 0 && y < board[0].size());\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        // All directions of neighbors\\n        vector<int> ways_x = {0, 0, 1, 1, 1, -1, -1, -1};\\n        vector<int> ways_y = {1, -1, 1, -1, 0, 0, 1, -1};\\n        \\n        for (int row = 0; row < board.size(); row++) {\\n            for (int col = 0; col < board[0].size(); col++) {\\n                \\n                int count_live_neighbors = 0;\\n                \\n                // Loop to count all live neighbors\\n                for (int i = 0; i < 8; i++) {\\n                    int curr_x = row + ways_x[i], curr_y = col + ways_y[i];\\n                    if (isValidNeighbor(curr_x, curr_y, board) && abs(board[curr_x][curr_y]) == 1)\\n                        count_live_neighbors++;\\n                }\\n                \\n                // Rules 1 and 3: -1 indicates a cell that was live but now is dead.\\n                if (board[row][col] == 1 && (count_live_neighbors < 2 || count_live_neighbors > 3))\\n                    board[row][col] = -1;\\n                \\n                // Rule 4: 2 indicates a cell that was dead but now is live.\\n                if (board[row][col] == 0 && count_live_neighbors == 3)\\n                    board[row][col] = 2;\\n            }\\n        }\\n        \\n        // Get the final board\\n        for (int row = 0; row < board.size(); row++) {\\n            for (int col = 0; col < board[0].size(); col++) {\\n                if (board[row][col] >= 1)\\n                    board[row][col] = 1;\\n                else\\n                    board[row][col] = 0;\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        # Helper function to check validility of neighbor\\n        def isValidNeighbor(x, y):\\n            return x < len(board) and x >= 0 and y < len(board[0]) and y >= 0\\n\\n        # All directions of neighbors\\n        ways_x = [0, 0, 1, 1, 1, -1, -1, -1]\\n        ways_y = [1, -1, 1, -1, 0, 0, 1, -1]\\n        \\n        for row in range(len(board)):\\n            for col in range(len(board[0])):\\n                \\n                # Loop to count all live neighbors\\n                count_live_neighbors = 0\\n                for i in range(8):\\n                    curr_x, curr_y = row + ways_x[i], col + ways_y[i]\\n                    if isValidNeighbor(curr_x, curr_y) and abs(board[curr_x][curr_y]) == 1:\\n                        count_live_neighbors+=1\\n                \\n                # Rules 1 and 3: -1 indicates a cell that was live but now is dead.\\n                if board[row][col] == 1 and (count_live_neighbors < 2 or count_live_neighbors > 3):\\n                    board[row][col] = -1\\n                    \\n                # Rule 4: 2 indicates a cell that was dead but now is live.\\n                if board[row][col] == 0 and count_live_neighbors == 3:\\n                    board[row][col] = 2\\n                 \\n        # Get the final board\\n        for row in range(len(board)):\\n            for col in range(len(board[0])):\\n                if board[row][col] >= 1:\\n                    board[row][col] = 1\\n                else:\\n                    board[row][col] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214063,
                "title": "easiest-java-solution-self-explanatory-code",
                "content": "```\\n   public void gameOfLife(int[][] board) {\\n\\n\\t\\tif(board == null || board.length == 0) \\n\\t\\t\\treturn;\\n\\t\\t\\n\\t\\tint[][] res = new int[board.length][board[0].length];\\n\\t\\t\\n\\t\\tfor (int i = 0; i < res.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < res[0].length; j++) {\\n\\t\\t\\t\\tint curr = 0;\\n\\t\\t\\t\\t//00 10 11\\n\\t\\t\\t\\t//10 11 12\\n\\t\\t\\t\\t//20 21 22\\n\\t\\t\\t\\t//assume you are at 11 position in above metrics and visit all directions\\n\\t\\t\\t\\t curr = cal(board,i - 1, j - 1) + cal(board,i - 1, j) + cal(board,i - 1, j + 1) + \\n\\t\\t\\t\\t           cal(board,i, j - 1) +  cal(board,i, j + 1) +\\n\\t\\t\\t\\t           cal(board,i + 1, j - 1) + cal(board,i + 1, j) + cal(board,i + 1, j + 1);\\n\\t\\t\\t\\t \\n\\t\\t\\t\\tif(board[i][j] == 1){\\n\\t\\t\\t\\t\\t if(curr < 2){\\n\\t\\t\\t\\t\\t\\t res[i][j] = 0;\\n\\t\\t\\t\\t\\t }else if(curr == 2 || curr == 3)\\n\\t\\t\\t\\t\\t\\t res[i][j] = 1;\\n\\t\\t\\t\\t\\t else if(curr > 3)\\n\\t\\t\\t\\t\\t\\t res[i][j] = 0;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tif(curr == 3)\\n\\t\\t\\t\\t\\t\\tres[i][j] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\tfor(int i=0; i<board.length; i++)\\n\\t\\t\\t  for(int j=0; j<board[i].length; j++)\\n\\t\\t\\t\\t  board[i][j]=res[i][j];\\n\\t\\n        \\n    }\\n    \\n    \\n    private int cal(int[][] board, int i, int j) {\\n\\t\\t\\n\\t\\tif(i >= 0 && i < board.length && j >= 0 && j < board[0].length)\\n\\t\\t\\treturn board[i][j];\\n\\t\\treturn 0;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n   public void gameOfLife(int[][] board) {\\n\\n\\t\\tif(board == null || board.length == 0) \\n\\t\\t\\treturn;\\n\\t\\t\\n\\t\\tint[][] res = new int[board.length][board[0].length];\\n\\t\\t\\n\\t\\tfor (int i = 0; i < res.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < res[0].length; j++) {\\n\\t\\t\\t\\tint curr = 0;\\n\\t\\t\\t\\t//00 10 11\\n\\t\\t\\t\\t//10 11 12\\n\\t\\t\\t\\t//20 21 22\\n\\t\\t\\t\\t//assume you are at 11 position in above metrics and visit all directions\\n\\t\\t\\t\\t curr = cal(board,i - 1, j - 1) + cal(board,i - 1, j) + cal(board,i - 1, j + 1) + \\n\\t\\t\\t\\t           cal(board,i, j - 1) +  cal(board,i, j + 1) +\\n\\t\\t\\t\\t           cal(board,i + 1, j - 1) + cal(board,i + 1, j) + cal(board,i + 1, j + 1);\\n\\t\\t\\t\\t \\n\\t\\t\\t\\tif(board[i][j] == 1){\\n\\t\\t\\t\\t\\t if(curr < 2){\\n\\t\\t\\t\\t\\t\\t res[i][j] = 0;\\n\\t\\t\\t\\t\\t }else if(curr == 2 || curr == 3)\\n\\t\\t\\t\\t\\t\\t res[i][j] = 1;\\n\\t\\t\\t\\t\\t else if(curr > 3)\\n\\t\\t\\t\\t\\t\\t res[i][j] = 0;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tif(curr == 3)\\n\\t\\t\\t\\t\\t\\tres[i][j] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\tfor(int i=0; i<board.length; i++)\\n\\t\\t\\t  for(int j=0; j<board[i].length; j++)\\n\\t\\t\\t\\t  board[i][j]=res[i][j];\\n\\t\\n        \\n    }\\n    \\n    \\n    private int cal(int[][] board, int i, int j) {\\n\\t\\t\\n\\t\\tif(i >= 0 && i < board.length && j >= 0 && j < board[0].length)\\n\\t\\t\\treturn board[i][j];\\n\\t\\treturn 0;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73334,
                "title": "ac-python-40-ms-solution-o-mn-time-o-1-extra-space",
                "content": "    def update(self, board, m, n, i, j):\\n        live = 0\\n        for p in xrange(max(i - 1, 0), min(i + 2, m)):\\n            for q in xrange(max(j - 1, 0), min(j + 2, n)):\\n                live += board[p][q] & 1\\n        if live == 3 or live == board[i][j] + 3:\\n            board[i][j] += 2\\n\\n    def gameOfLife(self, board):\\n        if not board or not board[0]:\\n            return\\n        m = len(board)\\n        n = len(board[0])\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                self.update(board, m, n, i, j)\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                board[i][j] >>= 1\\n\\n\\n    # 22 / 22 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 40 ms\\n\\n\\nEveryone knows how to update this board if another m * n array is allowed. The O(1) space solution is just using the wasted bits in the original array. Instead of only 0 and 1 we now need the second bit for the updated value. The living condition is just by definition.\\n\\nOf course, writing everything together will save several lines of code. However, implement things like this, readability and expandability counts. \\n\\nAs of the follow up question. \\nFor example your 3 * 3 initial board is the following:\\n\\n     1 1 1\\n     1 0 1\\n     1 1 1\\n\\nIn the case of only 3 * 3 the next generation is:\\n\\n     1 0 1\\n     0 0 0\\n     1 0 1\\n\\nHowever in the case of a infinite board the next generation is:\\n\\n\\n\\n     0 0 1 0 0\\n     0 1 0 1 0\\n     1 0 0 0 1\\n     0 1 0 1 0\\n     0 0 1 0 0\\n\\nQuestion is how to you implement this expandable board. One solution of the infinity situation is using a upper level grid, a grid of grids, instead of only one grid of cells. Note that we can be lazy. We only initialize (allocate the memory for real) a certain grid if any cell in it is activated. The rest of the unused grid can be pointer only.",
                "solutionTags": [],
                "code": "    def update(self, board, m, n, i, j):\\n        live = 0\\n        for p in xrange(max(i - 1, 0), min(i + 2, m)):\\n            for q in xrange(max(j - 1, 0), min(j + 2, n)):\\n                live += board[p][q] & 1\\n        if live == 3 or live == board[i][j] + 3:\\n            board[i][j] += 2\\n\\n    def gameOfLife(self, board):\\n        if not board or not board[0]:\\n            return\\n        m = len(board)\\n        n = len(board[0])\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                self.update(board, m, n, i, j)\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                board[i][j] >>= 1\\n\\n\\n    # 22 / 22 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 40 ms\\n\\n\\nEveryone knows how to update this board if another m * n array is allowed. The O(1) space solution is just using the wasted bits in the original array. Instead of only 0 and 1 we now need the second bit for the updated value. The living condition is just by definition.\\n\\nOf course, writing everything together will save several lines of code. However, implement things like this, readability and expandability counts. \\n\\nAs of the follow up question. \\nFor example your 3 * 3 initial board is the following:\\n\\n     1 1 1\\n     1 0 1\\n     1 1 1\\n\\nIn the case of only 3 * 3 the next generation is:\\n\\n     1 0 1\\n     0 0 0\\n     1 0 1\\n\\nHowever in the case of a infinite board the next generation is:\\n\\n\\n\\n     0 0 1 0 0\\n     0 1 0 1 0\\n     1 0 0 0 1\\n     0 1 0 1 0\\n     0 0 1 0 0\\n\\nQuestion is how to you implement this expandable board. One solution of the infinity situation is using a upper level grid, a grid of grids, instead of only one grid of cells. Note that we can be lazy. We only initialize (allocate the memory for real) a certain grid if any cell in it is activated. The rest of the unused grid can be pointer only.",
                "codeTag": "Python3"
            },
            {
                "id": 1694529,
                "title": "c-solution-with-full-explanations-time-complexity-o-m-n",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Every element has a maximum of 8 neighbours by which we have to find if the current element will be alive or dead in the next state.\\n- There are actually 2conditions:\\n    - *For 0*: if it has 3 neighbours with \\u20181\\u2019 then in the next state it will be 1.\\n    - *For 1*: if it has 2 or 3 neighbours with \\u20181\\u2019 then in the next state it will remain 1.\\n- But we have to solve this problem without any extra space.\\n- To keep track after changing an element:\\n    - if it changed from 1 to 0, then we\\u2019ll replace it with 2, so any value greater 1 is equal to 1.\\n    - And in case 0 to 1, then we\\u2019ll replace it with -2.\\n- We\\u2019re storing the number of neighbours \\u20181\\u2019 in count.\\n- **Time complexity:** O(m*n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size(), m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int count=0;\\n                \\n                //check for top row elements\\n                if(i>0 && j>0 && board[i-1][j-1]>=1) count++; //top left\\n                if(j>0 && board[i][j-1]>=1) count++; //top\\n                if(i<n-1 && j>0 && board[i+1][j-1]>=1) count++; //top right\\n                \\n                //check for current row elemnents \\n                if(i>0 && board[i-1][j]>=1) count++; //left\\n                if(i<n-1 && board[i+1][j]>=1) count++; //right\\n                \\n                //check for down row elemnents \\n                if(i>0 && j<m-1 && board[i-1][j+1]>=1) count++; //down left\\n                if(j<m-1 && board[i][j+1]>=1) count++; //down\\n                if(i<n-1 && j<m-1 && board[i+1][j+1]>=1) count++; //down right\\n\\n                if(board[i][j]==1 && (count<2 || count>3)) board[i][j]=2;\\n                if(board[i][j]==0 && count==3) board[i][j]=-2;     \\n            }\\n        }\\n         for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==2) board[i][j]=0;\\n                if(board[i][j]==-2) board[i][j]=1;\\n            }\\n        }\\n           \\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size(), m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int count=0;\\n                \\n                //check for top row elements\\n                if(i>0 && j>0 && board[i-1][j-1]>=1) count++; //top left\\n                if(j>0 && board[i][j-1]>=1) count++; //top\\n                if(i<n-1 && j>0 && board[i+1][j-1]>=1) count++; //top right\\n                \\n                //check for current row elemnents \\n                if(i>0 && board[i-1][j]>=1) count++; //left\\n                if(i<n-1 && board[i+1][j]>=1) count++; //right\\n                \\n                //check for down row elemnents \\n                if(i>0 && j<m-1 && board[i-1][j+1]>=1) count++; //down left\\n                if(j<m-1 && board[i][j+1]>=1) count++; //down\\n                if(i<n-1 && j<m-1 && board[i+1][j+1]>=1) count++; //down right\\n\\n                if(board[i][j]==1 && (count<2 || count>3)) board[i][j]=2;\\n                if(board[i][j]==0 && count==3) board[i][j]=-2;     \\n            }\\n        }\\n         for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==2) board[i][j]=0;\\n                if(board[i][j]==-2) board[i][j]=1;\\n            }\\n        }\\n           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993587,
                "title": "c-o-mn-time-o-1-space-with-trick-for-inplace-solution",
                "content": "Here is a small trick that i learned long time back.\\nIn a given integer space we can store 2 values, given that they are in the given integer range.\\nThe idea is to find the maximum value in the array and then store values in this manner `(old_value)*(max_element+1) + (new_value)`\\nWe can retrieve the `old_value` by simply dividing the number by `max_element+1`, and can retrieve the `new_value` by simply taking modulus with `max_element+1`.\\nSo here in this case, we know that all possible values are 0 or 1, so we can take 2 as `max_element+1`.\\nSo at the end we have a 2-d array filled with `old*(max+1)+new` format cells. And hence take modulus by 2 for the entire array at the end to get the new values.\\n```\\nint pos[8][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,1},{1,0},{1,-1}};\\nvoid gameOfLife(vector<vector<int>>& board) {\\n\\tint n = board.size(), m = board[0].size();\\n\\tfor(int i=0;i<n;i++)\\n\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tint num = 0;\\n\\t\\t\\tfor(int k=0;k<8;k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint x = i + pos[k][0], y = j + pos[k][1];\\n\\t\\t\\t\\tif(x>=0 && x<n && y>=0 && y<m)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(k<4 && board[x][y]/2==1) num++;\\n\\t\\t\\t\\t\\tif(k>=4 && board[x][y]==1) num++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}     \\n\\t\\t\\tif(board[i][j]==1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(num<2 || num>3) board[i][j] = 2;//board[i][j]*2 + 0;\\n\\t\\t\\t\\telse board[i][j] = 3;//board[i][j]*2 + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(num==3) board[i][j] = 1;//board[i][j]*2 + 1; \\n\\t\\t\\t}\\n\\t\\t}\\n\\tfor(int i=0;i<n;i++)\\n\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t\\tboard[i][j] = board[i][j]%2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint pos[8][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,1},{1,0},{1,-1}};\\nvoid gameOfLife(vector<vector<int>>& board) {\\n\\tint n = board.size(), m = board[0].size();\\n\\tfor(int i=0;i<n;i++)\\n\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tint num = 0;\\n\\t\\t\\tfor(int k=0;k<8;k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint x = i + pos[k][0], y = j + pos[k][1];\\n\\t\\t\\t\\tif(x>=0 && x<n && y>=0 && y<m)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(k<4 && board[x][y]/2==1) num++;\\n\\t\\t\\t\\t\\tif(k>=4 && board[x][y]==1) num++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}     \\n\\t\\t\\tif(board[i][j]==1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(num<2 || num>3) board[i][j] = 2;//board[i][j]*2 + 0;\\n\\t\\t\\t\\telse board[i][j] = 3;//board[i][j]*2 + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(num==3) board[i][j] = 1;//board[i][j]*2 + 1; \\n\\t\\t\\t}\\n\\t\\t}\\n\\tfor(int i=0;i<n;i++)\\n\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t\\tboard[i][j] = board[i][j]%2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938149,
                "title": "100-faster-java-ac-solution",
                "content": "**Brute Force Approach**\\n\\n* Make a matrix to store the current state as it would our previous state \\n* Make a matrix to count the people alive around a particular cell\\n* Change the given matrix according to the previous matrix and population count\\n\\n**TIME COMPLEXITY : O(N^2)**\\n**SPACE COMPLEXITY : O(N^2)**\\n\\n```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int n = board.length;\\n        int m = board[0].length;\\n        int prev [][] = new int [n][m];\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                prev[i][j]=board[i][j];\\n            }\\n        }\\n        int population_count [][] = new int [n][m];\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                int count = 0;\\n                if(i-1>=0&&j-1>=0&&i-1<n&&j-1<m)count+=board[i-1][j-1];\\n                if(i-1>=0&&j>=0&&i-1<n&&j<m)count+=board[i-1][j];\\n                if(i-1>=0&&j+1>=0&&i-1<n&&j+1<m)count+=board[i-1][j+1];\\n                if(i>=0&&j-1>=0&&i<n&&j-1<m)count+=board[i][j-1];\\n                if(i>=0&&j+1>=0&&i<n&&j+1<m)count+=board[i][j+1];\\n                if(i+1>=0&&j-1>=0&&i+1<n&&j-1<m)count+=board[i+1][j-1];\\n                if(i+1>=0&&j>=0&&i+1<n&&j<m)count+=board[i+1][j];\\n                if(i+1>=0&&j+1>=0&&i+1<n&&j+1<m)count+=board[i+1][j+1];\\n                population_count[i][j]=count;\\n            }\\n        }\\n        for(int i =0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(prev[i][j]==1){\\n                    if(population_count[i][j]<2){\\n                        board[i][j]=0;\\n                    }\\n                    else if(population_count[i][j]>3){\\n                        board[i][j]=0;\\n                    }\\n                }\\n                else{\\n                   if(population_count[i][j]==3){\\n                        board[i][j]=1;\\n                    } \\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**IF YOU FOUND IT HELPFUL PLEASE DO UPVOTE :)**",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int n = board.length;\\n        int m = board[0].length;\\n        int prev [][] = new int [n][m];\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                prev[i][j]=board[i][j];\\n            }\\n        }\\n        int population_count [][] = new int [n][m];\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                int count = 0;\\n                if(i-1>=0&&j-1>=0&&i-1<n&&j-1<m)count+=board[i-1][j-1];\\n                if(i-1>=0&&j>=0&&i-1<n&&j<m)count+=board[i-1][j];\\n                if(i-1>=0&&j+1>=0&&i-1<n&&j+1<m)count+=board[i-1][j+1];\\n                if(i>=0&&j-1>=0&&i<n&&j-1<m)count+=board[i][j-1];\\n                if(i>=0&&j+1>=0&&i<n&&j+1<m)count+=board[i][j+1];\\n                if(i+1>=0&&j-1>=0&&i+1<n&&j-1<m)count+=board[i+1][j-1];\\n                if(i+1>=0&&j>=0&&i+1<n&&j<m)count+=board[i+1][j];\\n                if(i+1>=0&&j+1>=0&&i+1<n&&j+1<m)count+=board[i+1][j+1];\\n                population_count[i][j]=count;\\n            }\\n        }\\n        for(int i =0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(prev[i][j]==1){\\n                    if(population_count[i][j]<2){\\n                        board[i][j]=0;\\n                    }\\n                    else if(population_count[i][j]>3){\\n                        board[i][j]=0;\\n                    }\\n                }\\n                else{\\n                   if(population_count[i][j]==3){\\n                        board[i][j]=1;\\n                    } \\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937910,
                "title": "c-simulation-solved-live-on-stream",
                "content": "We solve problems everyday 6pm PT.  There are dozens of us.  Link in profile\\n\\nTime Complexity = O(nm)\\nSpace Complexity = O(nm)\\n\\n```\\nclass Solution {\\n    \\n    vector<vector<int>> dirs = {\\n        {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0, -1}, {-1,-1} \\n    };\\n\\n    int getNeighbors(vector<vector<int>>& board, int r, int c) {\\n        int howManyAlive = 0;\\n        for(auto& dir : dirs) {\\n            int nr = r + dir[0];\\n            int nc = c + dir[1];\\n            if(nr < 0 || nr >= board.size()) continue;\\n            if(nc < 0 || nc >= board[r].size()) continue;\\n            \\n            howManyAlive += board[nr][nc];\\n        }\\n        return howManyAlive;\\n    }\\n    \\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int ROWS = board.size();\\n        int COLS = board[0].size();\\n        \\n        vector<vector<int>> newBoard(ROWS, vector<int>(COLS));\\n        for(int r = 0; r < ROWS; r++) {\\n            for(int c = 0; c < COLS; c++) {\\n                int howManyAlive = getNeighbors(board, r, c);\\n                if(board[r][c] == 0 && howManyAlive == 3) {\\n                    newBoard[r][c] = 1;\\n                } else if (board[r][c] == 1 && howManyAlive < 2) {\\n                    newBoard[r][c] = 0;\\n                } else if (board[r][c] == 1 && howManyAlive > 3) {\\n                    newBoard[r][c] = 0;\\n                } else if (board[r][c] == 1) {\\n                    newBoard[r][c] = 1;\\n                }\\n            }\\n        }\\n        board = newBoard;\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    vector<vector<int>> dirs = {\\n        {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0, -1}, {-1,-1} \\n    };\\n\\n    int getNeighbors(vector<vector<int>>& board, int r, int c) {\\n        int howManyAlive = 0;\\n        for(auto& dir : dirs) {\\n            int nr = r + dir[0];\\n            int nc = c + dir[1];\\n            if(nr < 0 || nr >= board.size()) continue;\\n            if(nc < 0 || nc >= board[r].size()) continue;\\n            \\n            howManyAlive += board[nr][nc];\\n        }\\n        return howManyAlive;\\n    }\\n    \\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int ROWS = board.size();\\n        int COLS = board[0].size();\\n        \\n        vector<vector<int>> newBoard(ROWS, vector<int>(COLS));\\n        for(int r = 0; r < ROWS; r++) {\\n            for(int c = 0; c < COLS; c++) {\\n                int howManyAlive = getNeighbors(board, r, c);\\n                if(board[r][c] == 0 && howManyAlive == 3) {\\n                    newBoard[r][c] = 1;\\n                } else if (board[r][c] == 1 && howManyAlive < 2) {\\n                    newBoard[r][c] = 0;\\n                } else if (board[r][c] == 1 && howManyAlive > 3) {\\n                    newBoard[r][c] = 0;\\n                } else if (board[r][c] == 1) {\\n                    newBoard[r][c] = 1;\\n                }\\n            }\\n        }\\n        board = newBoard;\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939837,
                "title": "0-ms-easy-java-solution-using-matrix",
                "content": "# **Game of Life**\\n\\nThis problem is pretty simple as it only involves matrix traversal, checking the neighbours and updating the value in temp[ ][ ].\\n\\n**Note :-** This is not inplace \\uD83D\\uDE05\\n\\n**Algorithm**\\n\\n\\t\\tStep  1    :-    iterate through the board[][] matrix\\n\\t\\tStep  2    :-    check if the north-west neighbour( board[i-1][ j-1] ) of the present cell is 1\\n\\t\\t\\t\\t\\t\\t\\tthen\\n\\t\\t\\t\\t\\t\\t\\tupdate count by 1\\n\\t\\tStep  3    :-    check if the north neighbour( board[i-1][ j] ) of the present cell is 1 \\n\\t\\t\\t\\t\\t\\t\\tthen\\n\\t\\t\\t\\t\\t\\t\\tupdate count by 1\\n\\t\\tStep  4    :-    check if the north-east neighbour( board[i-1][ j+1] ) of the present cell is 1 \\n\\t\\t\\t\\t\\t\\t\\tthen\\n\\t\\t\\t\\t\\t\\t\\tupdate count by 1\\n\\t\\tStep  5    :-    check if the east neighbour( board[i][j+1] ) of the present cell is 1 \\n\\t\\t\\t\\t\\t\\t\\tthen\\n\\t\\t\\t\\t\\t\\t\\tupdate count by 1\\n\\t\\tStep  6    :-    check if the south-east neighbour( board[i+1][j+1] ) of the present cell is 1 \\n\\t\\t\\t\\t\\t\\t\\tthen\\n\\t\\t\\t\\t\\t\\t\\tupdate count by 1\\n\\t\\tStep  7    :-    check if the south neighbour( board[i+1][j] ) of the present cell is 1 \\n\\t\\t\\t\\t\\t\\t\\tthen\\n\\t\\t\\t\\t\\t\\t\\tupdate count by 1\\n\\t\\tStep  8    :-    check if the south-west neighbour( board[i+1][j-1] ) of the present cell is 1 \\n\\t\\t\\t\\t\\t\\t\\tthen\\n\\t\\t\\t\\t\\t\\t\\tupdate count by 1\\n\\t\\tStep  9    :-    check if the west neighbour( board[i-1][j] ) of the present cell is 1 \\n\\t\\t\\t\\t\\t\\t\\tthen\\n\\t\\t\\t\\t\\t\\t\\tupdate count by 1\\n\\t\\tStep 10    :-    check if the current cell is live and  live neighbours are less than 2 (condition for under-population)\\n\\t\\t\\t\\t\\t\\t\\tthen\\n\\t\\t\\t\\t\\t\\t\\tupdate temp[i][j] to 0\\n\\t\\tStep 11    :-    check if the current cell is live and  live neighbours are less than equal to 3 (condition for next-generation)\\n\\t\\t\\t\\t\\t\\t\\tthen\\n\\t\\t\\t\\t\\t\\t\\tupdate temp[i][j] to 1\\n\\t\\tStep 12    :-    check if the current cell is live and  live neighbours are greater than 3 (condition for over-population)\\n\\t\\t\\t\\t\\t\\t\\tthen\\n\\t\\t\\t\\t\\t\\t\\tupdate temp[i][j] to 0\\n\\t\\tStep 13    :-    check if the current cell is dead and  live neighbours are equal to 3 (condition for reproduction)\\n\\t\\t\\t\\t\\t\\t\\tthen\\n\\t\\t\\t\\t\\t\\t\\tupdate temp[i][j] to 1\\n\\t\\tStep 14    :-    end of iterating loop\\n\\t\\tStep 15    :-    copy the temp [][] to boards[][] \\n\\t\\n\\t\\n**Java Code**\\n```\\nclass Solution\\n{\\n    public static void gameOfLife(int[][] board)\\n    {\\n        int m= board.length;\\n        int n= board[0].length;\\n        int temp[][] =new int[m][n];\\n        for(int i=0;i<m;++i)\\n        {\\n            for(int j=0;j<n;++j)\\n            {\\n                int c=0;\\n                if(i-1>=0 && j-1>=0)//north-west\\n                    c=board[i-1][j-1]==1?c+1:c;\\n                \\n                if(i-1>=0 )//north\\n                    c=board[i-1][j]==1?c+1:c;\\n                \\n                if(i-1>=0 && j+1<n)//north-east\\n                    c=board[i-1][j+1]==1?c+1:c;\\n                \\n                if(j+1<n)//east\\n                    c=board[i][j+1]==1?c+1:c;\\n                \\n                if(i+1<m && j+1<n)//south-east\\n                    c=board[i+1][j+1]==1?c+1:c;\\n                \\n                if(i+1<m)//south\\n                    c=board[i+1][j]==1?c+1:c;\\n                \\n                if(i+1<m && j-1>=0)//south-west\\n                    c=board[i+1][j-1]==1?c+1:c;\\n                \\n                if(j-1>=0)//west\\n                    c=board[i][j-1]==1?c+1:c;\\n                \\n                //updating value in temp[ ][ ] \\n                if(board[i][j]==1 && c<2)\\n                    temp[i][j]=0;\\n                \\n                else if(board[i][j]==1 && c<=3)\\n                    temp[i][j]=1;\\n                \\n                else if(board[i][j]==1 && c>3)\\n                    temp[i][j]=0;\\n                \\n                else if(board[i][j]==0 && c==3)\\n                    temp[i][j]=1;   \\n            }\\n        }\\n        for(int i=0;i<board.length;++i)//copying the temp to board\\n        {\\n          for(int j=0;j<board[0].length;++j)\\n            board[i][j]=temp[i][j];\\n        }\\n    }\\n}\\n```\\n\\nYume o akiramete shinde kure \\uD83D\\uDE0A\\n\\nThank you!!",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\n    public static void gameOfLife(int[][] board)\\n    {\\n        int m= board.length;\\n        int n= board[0].length;\\n        int temp[][] =new int[m][n];\\n        for(int i=0;i<m;++i)\\n        {\\n            for(int j=0;j<n;++j)\\n            {\\n                int c=0;\\n                if(i-1>=0 && j-1>=0)//north-west\\n                    c=board[i-1][j-1]==1?c+1:c;\\n                \\n                if(i-1>=0 )//north\\n                    c=board[i-1][j]==1?c+1:c;\\n                \\n                if(i-1>=0 && j+1<n)//north-east\\n                    c=board[i-1][j+1]==1?c+1:c;\\n                \\n                if(j+1<n)//east\\n                    c=board[i][j+1]==1?c+1:c;\\n                \\n                if(i+1<m && j+1<n)//south-east\\n                    c=board[i+1][j+1]==1?c+1:c;\\n                \\n                if(i+1<m)//south\\n                    c=board[i+1][j]==1?c+1:c;\\n                \\n                if(i+1<m && j-1>=0)//south-west\\n                    c=board[i+1][j-1]==1?c+1:c;\\n                \\n                if(j-1>=0)//west\\n                    c=board[i][j-1]==1?c+1:c;\\n                \\n                //updating value in temp[ ][ ] \\n                if(board[i][j]==1 && c<2)\\n                    temp[i][j]=0;\\n                \\n                else if(board[i][j]==1 && c<=3)\\n                    temp[i][j]=1;\\n                \\n                else if(board[i][j]==1 && c>3)\\n                    temp[i][j]=0;\\n                \\n                else if(board[i][j]==0 && c==3)\\n                    temp[i][j]=1;   \\n            }\\n        }\\n        for(int i=0;i<board.length;++i)//copying the temp to board\\n        {\\n          for(int j=0;j<board[0].length;++j)\\n            board[i][j]=temp[i][j];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400981,
                "title": "c-faster-than-100-o-mn-time-o-1-space",
                "content": "##### **Intuition** : Use different integers to denote the cells whose state has changed from the previous state, and then update the state of the orignal board using the new values stored in it.\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) \\n    {\\n        int n = board.size(), m = board[0].size();\\n        \\n        // 0 -> prev dead, now dead\\n        // 1 -> prev alive, now alive\\n        // 2 -> prev alive, now dead\\n        // 3 -> prev dead, now alive\\n        \\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                int neigh = get_live_neighbors(board, i, j);\\n                \\n                if(!board[i][j])\\n                {\\n                    if(neigh == 3)\\n                        board[i][j] = 3;\\n                }\\n                else\\n                {\\n                    if(neigh < 2 or neigh > 3)\\n                        board[i][j] = 2;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            for(int j = 0 ; j < m ; j++)\\n                board[i][j] %= 2;\\n        \\n    }\\nprivate:\\n    int mx[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n    int my[8] = {0, 1, 1, 1, 0, -1, -1, -1};\\n    \\n    int get_live_neighbors(vector<vector<int>> &board, int a, int b)\\n    {\\n        int n = 0;\\n        \\n        for(int i = 0 ; i < 8 ; i++)\\n        {\\n            int x = mx[i] + a, y = my[i] + b;\\n            \\n            if(0 <= x and x < board.size() and 0 <= y and y < board[0].size())\\n                if(board[x][y] == 1 or board[x][y] == 2)\\n                    n++;\\n        }\\n        \\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) \\n    {\\n        int n = board.size(), m = board[0].size();\\n        \\n        // 0 -> prev dead, now dead\\n        // 1 -> prev alive, now alive\\n        // 2 -> prev alive, now dead\\n        // 3 -> prev dead, now alive\\n        \\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                int neigh = get_live_neighbors(board, i, j);\\n                \\n                if(!board[i][j])\\n                {\\n                    if(neigh == 3)\\n                        board[i][j] = 3;\\n                }\\n                else\\n                {\\n                    if(neigh < 2 or neigh > 3)\\n                        board[i][j] = 2;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            for(int j = 0 ; j < m ; j++)\\n                board[i][j] %= 2;\\n        \\n    }\\nprivate:\\n    int mx[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n    int my[8] = {0, 1, 1, 1, 0, -1, -1, -1};\\n    \\n    int get_live_neighbors(vector<vector<int>> &board, int a, int b)\\n    {\\n        int n = 0;\\n        \\n        for(int i = 0 ; i < 8 ; i++)\\n        {\\n            int x = mx[i] + a, y = my[i] + b;\\n            \\n            if(0 <= x and x < board.size() and 0 <= y and y < board[0].size())\\n                if(board[x][y] == 1 or board[x][y] == 2)\\n                    n++;\\n        }\\n        \\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407373,
                "title": "javascript-o-1-sollution",
                "content": "```\\n/** \\n * rules:\\n * live -> die = -1\\n * die -> live = 2 \\n */\\nvar gameOfLife = function(board) {\\n    for (let i=0;i<board.length;i++) {\\n        for (let j=0;j<board[0].length;j++) {\\n            let cell = board[i][j];\\n            let neighbors = getNeighbors(i,j,board);\\n            if (cell == 0 && neighbors == 3) {\\n                board[i][j] = 2\\n            }\\n            if (cell == 1 && (neighbors < 2 || neighbors > 3)) {\\n                board[i][j] = -1;\\n            }\\n        }\\n    }\\n    for (let i=0;i<board.length;i++) {\\n        for (let j=0;j<board[0].length;j++) {\\n            if (board[i][j] == -1) board[i][j] = 0;\\n            if (board[i][j] == 2) board[i][j] = 1;\\n        }\\n    }\\n};\\n\\n\\nvar getNeighbors = function(r, c, board) {\\n    let radius = [-1,0,+1], count = 0;\\n    for (let i=0;i<radius.length;i++) {\\n        for (let j=0;j<radius.length;j++) {\\n            if (!(radius[i] == 0 && radius[j] == 0) && board[r + radius[i]] != null) {\\n                let neighbor = board[r + radius[i]][c + radius[j]];\\n                if (Math.abs(neighbor) == 1) count += 1; \\n            }\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/** \\n * rules:\\n * live -> die = -1\\n * die -> live = 2 \\n */\\nvar gameOfLife = function(board) {\\n    for (let i=0;i<board.length;i++) {\\n        for (let j=0;j<board[0].length;j++) {\\n            let cell = board[i][j];\\n            let neighbors = getNeighbors(i,j,board);\\n            if (cell == 0 && neighbors == 3) {\\n                board[i][j] = 2\\n            }\\n            if (cell == 1 && (neighbors < 2 || neighbors > 3)) {\\n                board[i][j] = -1;\\n            }\\n        }\\n    }\\n    for (let i=0;i<board.length;i++) {\\n        for (let j=0;j<board[0].length;j++) {\\n            if (board[i][j] == -1) board[i][j] = 0;\\n            if (board[i][j] == 2) board[i][j] = 1;\\n        }\\n    }\\n};\\n\\n\\nvar getNeighbors = function(r, c, board) {\\n    let radius = [-1,0,+1], count = 0;\\n    for (let i=0;i<radius.length;i++) {\\n        for (let j=0;j<radius.length;j++) {\\n            if (!(radius[i] == 0 && radius[j] == 0) && board[r + radius[i]] != null) {\\n                let neighbor = board[r + radius[i]][c + radius[j]];\\n                if (Math.abs(neighbor) == 1) count += 1; \\n            }\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73329,
                "title": "java-in-place-o-mn-solution",
                "content": "Use bit operation to store new value in higher bit.\\n\\n    public void gameOfLife(int[][] board) {\\n        if (board == null || board.length == 0) {\\n            return;\\n        }\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int count = getNeighbors(board, i, j, m , n);\\n                if (count == 3 || board[i][j] + count == 3) {\\n                    board[i][j] ^= 2;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = board[i][j] >> 1;\\n            }\\n        }\\n    }\\n\\n    private int getNeighbors(int[][] board, int i, int j, int m, int n) {\\n        int result = 0;\\n        for (int x = Math.max(i-1, 0); x < Math.min(i+2, m); x++) {\\n            for (int y = Math.max(j-1, 0); y < Math.min(j+2, n); y++) {\\n                result += (board[x][y] & 1);\\n            }\\n        }\\n        return result - (board[i][j] & 1);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Use bit operation to store new value in higher bit.\\n\\n    public void gameOfLife(int[][] board) {\\n        if (board == null || board.length == 0) {\\n            return;\\n        }\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int count = getNeighbors(board, i, j, m , n);\\n                if (count == 3 || board[i][j] + count == 3) {\\n                    board[i][j] ^= 2;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = board[i][j] >> 1;\\n            }\\n        }\\n    }\\n\\n    private int getNeighbors(int[][] board, int i, int j, int m, int n) {\\n        int result = 0;\\n        for (int x = Math.max(i-1, 0); x < Math.min(i+2, m); x++) {\\n            for (int y = Math.max(j-1, 0); y < Math.min(j+2, n); y++) {\\n                result += (board[x][y] & 1);\\n            }\\n        }\\n        return result - (board[i][j] & 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 994473,
                "title": "c-time-o-mn-space-o-1-single-pass",
                "content": "Single pass approach with no extra space:\\n\\nAt each index, store the number of \"live\" neighbors by shifting the count left once.  Traverse the input left-right and top-bottom, and from each index, update the neighbor count for each of the neighbors that have not yet been visited.  The answer for each index is determined immediately, and its value is no longer needed.\\n\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<pair<int, int>> next_neighbors = {{1, 0}, {0, 1}, {1, 1}, {1, -1}};\\n        \\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[i].size(); j++)\\n            {\\n                int neighbors = board[i][j] >> 1, value = board[i][j] & 1;\\n                \\n                for (pair<int, int> next : next_neighbors)\\n                {\\n                    if (i + next.first < 0 || i + next.first >= board.size() ||\\n                        j + next.second < 0 || j + next.second >= board[i].size())\\n                        continue;\\n                    \\n                    neighbors += (board[i + next.first][j + next.second] & 1);\\n                    board[i + next.first][j + next.second] += value << 1;\\n                }\\n                \\n                board[i][j] = value == 1 ? neighbors == 2 || neighbors == 3 : neighbors == 3;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<pair<int, int>> next_neighbors = {{1, 0}, {0, 1}, {1, 1}, {1, -1}};\\n        \\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[i].size(); j++)\\n            {\\n                int neighbors = board[i][j] >> 1, value = board[i][j] & 1;\\n                \\n                for (pair<int, int> next : next_neighbors)\\n                {\\n                    if (i + next.first < 0 || i + next.first >= board.size() ||\\n                        j + next.second < 0 || j + next.second >= board[i].size())\\n                        continue;\\n                    \\n                    neighbors += (board[i + next.first][j + next.second] & 1);\\n                    board[i + next.first][j + next.second] += value << 1;\\n                }\\n                \\n                board[i][j] = value == 1 ? neighbors == 2 || neighbors == 3 : neighbors == 3;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891561,
                "title": "c-easy-code",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid gameOfLife(vector<vector<int>>& board) {\\n\\t\\t\\tvector<vector<int>> v = board;\\n\\n\\t\\t\\tfor(int i=0;i<board.size();i++){\\n\\t\\t\\t\\tfor(int j=0;j<board[i].size();j++){\\n\\n\\t\\t\\t\\t\\t//c1 will keep track of the no of 1\\'s in\\n\\t\\t\\t\\t\\t// all the eight neighbour\\n\\t\\t\\t\\t\\tint c1 = 0;\\n\\n\\t\\t\\t\\t\\t//upper left\\n\\t\\t\\t\\t\\tif((i-1)>=0 && (j-1)>=0){\\n\\t\\t\\t\\t\\t\\tif(board[i-1][j-1] ==1)\\n\\t\\t\\t\\t\\t\\t\\tc1++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//upper\\n\\t\\t\\t\\t\\tif((i-1)>=0 && j>=0){\\n\\t\\t\\t\\t\\t\\tif(board[i-1][j] == 1)\\n\\t\\t\\t\\t\\t\\t\\tc1++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//upper right \\n\\t\\t\\t\\t\\tif((i-1)>=0 && (j+1)<board[i].size()){\\n\\t\\t\\t\\t\\t\\tif(board[i-1][j+1] == 1)\\n\\t\\t\\t\\t\\t\\t\\tc1++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//left \\n\\t\\t\\t\\t\\tif((i>=0) && (j-1)>=0){\\n\\t\\t\\t\\t\\t\\tif(board[i][j-1] == 1)\\n\\t\\t\\t\\t\\t\\t\\tc1++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//right\\n\\t\\t\\t\\t\\tif(i>=0 && (j+1)<board[i].size()){\\n\\t\\t\\t\\t\\t\\tif(board[i][j+1] == 1)\\n\\t\\t\\t\\t\\t\\t\\tc1++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//lower left\\n\\t\\t\\t\\t\\tif((i+1)<board.size() && (j-1)>=0){\\n\\t\\t\\t\\t\\t\\tif(board[i+1][j-1] == 1)\\n\\t\\t\\t\\t\\t\\t\\tc1++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//down\\n\\t\\t\\t\\t\\tif((i+1)<board.size() && j>=0){\\n\\t\\t\\t\\t\\t\\tif(board[i+1][j] == 1)\\n\\t\\t\\t\\t\\t\\t\\tc1++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//lower right \\n\\t\\t\\t\\t\\tif((i+1)<board.size() && (j+1)<board[i].size()){\\n\\t\\t\\t\\t\\t\\tif(board[i+1][j+1] == 1)\\n\\t\\t\\t\\t\\t\\t\\tc1++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//now check the value of the current cell\\n\\t\\t\\t\\t\\tint val = board[i][j];\\n\\n\\t\\t\\t\\t\\tif(val == 0){\\n\\t\\t\\t\\t\\t\\t//check do we have 3 c1, to make this cell alive\\n\\t\\t\\t\\t\\t\\tif(c1 == 3)\\n\\t\\t\\t\\t\\t\\t\\tv[i][j] = 1;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tv[i][j] = 0;\\n\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t//check the value of c1\\n\\t\\t\\t\\t\\t\\tif((c1<2) || (c1>3))\\n\\t\\t\\t\\t\\t\\t\\tv[i][j] = 0;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tv[i][j] = 1;\\n\\n\\t\\t\\t\\t\\t}     \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tboard = v;\\n\\n\\t\\t}\\n\\t};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid gameOfLife(vector<vector<int>>& board) {\\n\\t\\t\\tvector<vector<int>> v = board;\\n\\n\\t\\t\\tfor(int i=0;i<board.size();i++){\\n\\t\\t\\t\\tfor(int j=0;j<board[i].size();j++){\\n\\n\\t\\t\\t\\t\\t//c1 will keep track of the no of 1\\'s in\\n\\t\\t\\t\\t\\t// all the eight neighbour\\n\\t\\t\\t\\t\\tint c1 = 0;\\n\\n\\t\\t\\t\\t\\t//upper left\\n\\t\\t\\t\\t\\tif((i-1)>=0 && (j-1)>=0){\\n\\t\\t\\t\\t\\t\\tif(board[i-1][j-1] ==1)\\n\\t\\t\\t\\t\\t\\t\\tc1++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 73218,
                "title": "javascript-in-place-solution",
                "content": "Our update on the board cannot affect the judge of live neighbors, so we use work-around\\n\\n```\\n/**\\n * @param {number[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nlet gameOfLife = (board) => {\\n  for (let i = 0; i < board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++){\\n      let liveCells = aliveNeighbors(board, i, j)\\n      if (board[i][j] === 1 && (liveCells < 2 || liveCells > 3)) {\\n          board[i][j] = 2\\n        }\\n      if (board[i][j] === 0 && liveCells === 3) {\\n        board[i][j] = 3\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++){\\n      board[i][j] %= 2\\n    }\\n  }\\n};\\n\\nlet aliveNeighbors = (board, i, j) => {\\n  let count = 0\\n  let indexes = [[1, -1], [1, 0], [1, 1], [0, -1], [0, 1], [-1, -1], [-1, 0], [-1, 1]]\\n  for (let index of indexes) {\\n    if (index[0] + i < 0 || index[0] + i > board.length - 1 ||\\n    index[1] + j < 0 || index[1] + j > board[0].length - 1) continue\\n    if (board[index[0] + i][index[1] + j] === 1 ||\\n    board[index[0] + i][index[1] + j] === 2) count++\\n  }\\n  return count\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nlet gameOfLife = (board) => {\\n  for (let i = 0; i < board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++){\\n      let liveCells = aliveNeighbors(board, i, j)\\n      if (board[i][j] === 1 && (liveCells < 2 || liveCells > 3)) {\\n          board[i][j] = 2\\n        }\\n      if (board[i][j] === 0 && liveCells === 3) {\\n        board[i][j] = 3\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++){\\n      board[i][j] %= 2\\n    }\\n  }\\n};\\n\\nlet aliveNeighbors = (board, i, j) => {\\n  let count = 0\\n  let indexes = [[1, -1], [1, 0], [1, 1], [0, -1], [0, 1], [-1, -1], [-1, 0], [-1, 1]]\\n  for (let index of indexes) {\\n    if (index[0] + i < 0 || index[0] + i > board.length - 1 ||\\n    index[1] + j < 0 || index[1] + j > board[0].length - 1) continue\\n    if (board[index[0] + i][index[1] + j] === 1 ||\\n    board[index[0] + i][index[1] + j] === 2) count++\\n  }\\n  return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73297,
                "title": "0ms-c-solution-easy-to-understand",
                "content": "We only need one bit to store life of an element and an integer has 32 bits. So let's store the new state in the  bit left to the rightmost bit. In the second scanning, we move each element to right by one bit.\\n\\n    void gameOfLife(vector<vector<int>>& board) {\\n\\t    if (board.empty()) return;\\n\\t    int m = board.size(), n = board[0].size();\\n\\t    int around[8][2] = { \\n\\t\\t    { -1, -1 }, { -1, 0 }, { -1, 1 },\\n\\t\\t    { 0, -1 },             { 0, 1 },\\n\\t\\t    { 1, -1 },  { 1, 0 },  { 1, 1 }\\n\\t    };\\n\\t    for (int i = 0; i < m; i++) {\\n\\t\\t    for (int j = 0; j < n; j++) {\\n\\t\\t\\t    int liveCount = 0;\\n\\t\\t\\t    for (int k = 0; k < 8; k++) {\\n\\t\\t\\t\\t    int x = i + around[k][0], y = j + around[k][1];\\n\\t\\t\\t\\t    if (x > -1 && x < m && y > -1 && y < n) liveCount += (0x1 & board[x][y]);\\n\\t\\t\\t    }\\n\\t\\t\\t    if (board[i][j] == 0) {\\n\\t\\t\\t\\t    if (liveCount == 3) board[i][j] |= 0x2;\\n\\t\\t\\t    } else {\\n\\t\\t\\t\\t    if (liveCount == 2 || liveCount == 3) {\\n\\t\\t\\t\\t\\t    board[i][j] |= 0x2;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\n\\t    for (auto& line : board) {\\n\\t\\t    for (auto& life : line) {\\n\\t\\t\\t    life = life >> 1;\\n\\t\\t    }\\n\\t    }\\n    }",
                "solutionTags": [],
                "code": "We only need one bit to store life of an element and an integer has 32 bits. So let's store the new state in the  bit left to the rightmost bit. In the second scanning, we move each element to right by one bit.\\n\\n    void gameOfLife(vector<vector<int>>& board) {\\n\\t    if (board.empty()) return;\\n\\t    int m = board.size(), n = board[0].size();\\n\\t    int around[8][2] = { \\n\\t\\t    { -1, -1 }, { -1, 0 }, { -1, 1 },\\n\\t\\t    { 0, -1 },             { 0, 1 },\\n\\t\\t    { 1, -1 },  { 1, 0 },  { 1, 1 }\\n\\t    };\\n\\t    for (int i = 0; i < m; i++) {\\n\\t\\t    for (int j = 0; j < n; j++) {\\n\\t\\t\\t    int liveCount = 0;\\n\\t\\t\\t    for (int k = 0; k < 8; k++) {\\n\\t\\t\\t\\t    int x = i + around[k][0], y = j + around[k][1];\\n\\t\\t\\t\\t    if (x > -1 && x < m && y > -1 && y < n) liveCount += (0x1 & board[x][y]);\\n\\t\\t\\t    }\\n\\t\\t\\t    if (board[i][j] == 0) {\\n\\t\\t\\t\\t    if (liveCount == 3) board[i][j] |= 0x2;\\n\\t\\t\\t    } else {\\n\\t\\t\\t\\t    if (liveCount == 2 || liveCount == 3) {\\n\\t\\t\\t\\t\\t    board[i][j] |= 0x2;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\n\\t    for (auto& line : board) {\\n\\t\\t    for (auto& life : line) {\\n\\t\\t\\t    life = life >> 1;\\n\\t\\t    }\\n\\t    }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73324,
                "title": "using-bit-manipulation-should-not-count-as-o-1",
                "content": "Really, I think using extra storage in high bits of ints isn't really O(1). The authors should really have changed the input to vector<vector<bool>> to make this impossible.\\nAnd while I'm not aware of a real O(1) solution, O(n) for n*m sized board is relatively easy: just store the original state of  'previous row':\\n\\n    class Solution {\\n    public:\\n        struct Fb {\\n            vector<vector<int>>& board;\\n            vector<int> frontier;\\n            int fpos;\\n            Fb(vector<vector<int>>& b) : board(b), frontier(board[0]), fpos(-1) {}\\n            int at(int i, int j) {\\n                if (j < 0 || j >= frontier.size())\\n                    return 0;\\n                if (i < 0 || i >= board.size())\\n                    return 0;\\n                if (i == fpos) {\\n                    return frontier[j];\\n                }\\n                return board[i][j];\\n            }\\n            void push(vector<int>& nf) {\\n                fpos++;\\n                if (fpos < board.size())\\n                    frontier = board[fpos];\\n                if (fpos >= 0)\\n                    swap(board[fpos], nf);\\n            }\\n        };\\n        void gameOfLife(vector<vector<int>>& board) {\\n            Fb fb(board);\\n            vector<int> newline(board[0].size(), 0);\\n            for (int i = 0; i < board.size(); ++i) {\\n                for (int j = 0; j < board[i].size(); ++j) {\\n                    int count = fb.at(i-1, j-1) + fb.at(i-1, j) + fb.at(i-1, j+1) \\n                            + fb.at(i, j-1) + fb.at(i, j+1) \\n                            + fb.at(i+1, j-1) + fb.at(i+1, j) + fb.at(i+1, j+1);\\n                    int me = fb.at(i, j);\\n                    if (me) {\\n                        newline[j] = (count == 2 || count == 3) ? 1 : 0;\\n                    }\\n                    else {\\n                        newline[j] = count == 3 ? 1 : 0;\\n                    }\\n                }\\n                fb.push(newline);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        struct Fb {\\n            vector<vector<int>>& board;\\n            vector<int> frontier;\\n            int fpos;\\n            Fb(vector<vector<int>>& b) : board(b), frontier(board[0]), fpos(-1) {}",
                "codeTag": "Java"
            },
            {
                "id": 3091162,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<vector<int>> dir{{1,-1},{1,0},{1,1},{0,-1},{0,1},{-1,-1},{-1,0},{-1,1}};\\n        int m=board.size();\\n        int n=board[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int a=0;\\n                for(int k=0;k<8;k++)\\n                {\\n                    int r=i+dir[k][0];\\n                    int c=j+dir[k][1];\\n                    if(r>=0 && r<m && c>=0 && c<n)\\n                    {\\n                        if(board[r][c]==1 || board[r][c]==2)\\n                        a++;\\n                    }\\n                }\\n                if((a<2 || a>3) && board[i][j]==1)\\n                board[i][j]=2;\\n                if(a==3 && board[i][j]==0)\\n                board[i][j]=3;\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        board[i][j]%=2;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<vector<int>> dir{{1,-1},{1,0},{1,1},{0,-1},{0,1},{-1,-1},{-1,0},{-1,1}};\\n        int m=board.size();\\n        int n=board[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int a=0;\\n                for(int k=0;k<8;k++)\\n                {\\n                    int r=i+dir[k][0];\\n                    int c=j+dir[k][1];\\n                    if(r>=0 && r<m && c>=0 && c<n)\\n                    {\\n                        if(board[r][c]==1 || board[r][c]==2)\\n                        a++;\\n                    }\\n                }\\n                if((a<2 || a>3) && board[i][j]==1)\\n                board[i][j]=2;\\n                if(a==3 && board[i][j]==0)\\n                board[i][j]=3;\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        board[i][j]%=2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894489,
                "title": "c-o-1-space-very-very-easy-solution-well-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe main problem here is to keep track of cells which transition their state from dead to alive and vice verse. \\nWhy dont we use extra digits (2 & 3) on the same board to keep track. \\nWe basically need to keep track of 2 things ->\\n- Cells coming alive (i.e 0 to 1 transitions) : **Mark such cells as **3****.\\n- Cells going dead (i.e 1 to 0 transitions) : **Mark such cells as 2**.\\nNow for each cell, visit its 8 neighbours and if it is 1 or 2 we know that it used to be 1 earlier and hence count them as Live. Otherwise count them as Dead.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size(), m = board[0].size(); // Size of board\\n        int dx[] = {-1,-1,-1,0,0,1,1,1}; \\n        int dy[] = {-1,0,1,-1,1,-1,0,1}; /*Direction vectors to visit  8 neighbours */\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0; j < m ; j++){ // For each cell of the board\\n                int countLive = 0; // Count how many live neighbours it has\\n                for(int k = 0; k < 8 ; k++){ // visit its 8 neighbours\\n                    int destx = i + dx[k];\\n                    int desty = j + dy[k]; // current neighbour is destx and desty\\n                    if(destx < 0 || desty < 0 || destx >= n || desty >= m) continue; // neighbour should be within boundary of the board\\n                    if(board[destx][desty] == 1 || board[destx][desty] == 2) countLive++; // 1 or 2 means it was alive in previous state\\n                } \\n                if((countLive < 2 || countLive > 3) && board[i][j] == 1) board[i][j] = 2; //conditions for a live cell to die\\n                if(board[i][j] == 0 && countLive == 3) board[i][j] = 3; // conditions for a dead cell to come alive\\n            }\\n        }\\n        for(int i = 0 ; i < n;  i++){\\n            for(int j = 0; j < m; j++){\\n                if(board[i][j] == 2) board[i][j] = 0;\\n                if(board[i][j] == 3) board[i][j] = 1;\\n                // mark each newly alive and dead cell as 0 and 1.\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size(), m = board[0].size(); // Size of board\\n        int dx[] = {-1,-1,-1,0,0,1,1,1}; \\n        int dy[] = {-1,0,1,-1,1,-1,0,1}; /*Direction vectors to visit  8 neighbours */\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0; j < m ; j++){ // For each cell of the board\\n                int countLive = 0; // Count how many live neighbours it has\\n                for(int k = 0; k < 8 ; k++){ // visit its 8 neighbours\\n                    int destx = i + dx[k];\\n                    int desty = j + dy[k]; // current neighbour is destx and desty\\n                    if(destx < 0 || desty < 0 || destx >= n || desty >= m) continue; // neighbour should be within boundary of the board\\n                    if(board[destx][desty] == 1 || board[destx][desty] == 2) countLive++; // 1 or 2 means it was alive in previous state\\n                } \\n                if((countLive < 2 || countLive > 3) && board[i][j] == 1) board[i][j] = 2; //conditions for a live cell to die\\n                if(board[i][j] == 0 && countLive == 3) board[i][j] = 3; // conditions for a dead cell to come alive\\n            }\\n        }\\n        for(int i = 0 ; i < n;  i++){\\n            for(int j = 0; j < m; j++){\\n                if(board[i][j] == 2) board[i][j] = 0;\\n                if(board[i][j] == 3) board[i][j] = 1;\\n                // mark each newly alive and dead cell as 0 and 1.\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938725,
                "title": "c-easy-intuitive-approach-0ms-time-comments-provided",
                "content": "Calculate the number of live cell in neighbour of current cell and apply given rules accordingly\\n\\n\\n| PLEASE UPVOTE IF YOU LIKE THE SOLUTION |\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int x,int y,int n,int m){\\n        if(x<0 || x>=n || y<0 || y>=m)return 0;\\n        return 1;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        \\n        \\n        int dx[8]={-1,-1,-1,0,1,1,1,0};\\n        int dy[8]={-1,0,1,1,1,0,-1,-1};\\n        \\n        // create a ans vector to store next state\\n        \\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int live=0;\\n                \\n                // move in ll eight direction and count the no. of live cells\\n                for(int k=0;k<8;k++){\\n                    int cx=i+dx[k];\\n                    int cy=j+dy[k];\\n                    if(isValid(cx,cy,n,m) && board[cx][cy]==1){\\n                        live++;\\n            \\n                    }\\n                }\\n            \\n                // Check if current cell is live or dead and apply rules accordingly and update ans vector\\n                if(board[i][j]==1){\\n                    if(live<2 || live >3){\\n                        ans[i][j]=0;\\n                    }else{\\n                        ans[i][j]=1;\\n                    }\\n                }\\n                else{\\n                    if(live==3){\\n                        ans[i][j]=1;\\n                    }else{\\n                        ans[i][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n        // update board to next state\\n        board=ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int x,int y,int n,int m){\\n        if(x<0 || x>=n || y<0 || y>=m)return 0;\\n        return 1;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        \\n        \\n        int dx[8]={-1,-1,-1,0,1,1,1,0};\\n        int dy[8]={-1,0,1,1,1,0,-1,-1};\\n        \\n        // create a ans vector to store next state\\n        \\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int live=0;\\n                \\n                // move in ll eight direction and count the no. of live cells\\n                for(int k=0;k<8;k++){\\n                    int cx=i+dx[k];\\n                    int cy=j+dy[k];\\n                    if(isValid(cx,cy,n,m) && board[cx][cy]==1){\\n                        live++;\\n            \\n                    }\\n                }\\n            \\n                // Check if current cell is live or dead and apply rules accordingly and update ans vector\\n                if(board[i][j]==1){\\n                    if(live<2 || live >3){\\n                        ans[i][j]=0;\\n                    }else{\\n                        ans[i][j]=1;\\n                    }\\n                }\\n                else{\\n                    if(live==3){\\n                        ans[i][j]=1;\\n                    }else{\\n                        ans[i][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n        // update board to next state\\n        board=ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423328,
                "title": "really-easy-to-understand-c-solution-beats-100",
                "content": "```\\nclass Solution {\\nprivate:\\n    int countLivingRelatives(int row, int col, vector<vector<int>>& board) {\\n        int count = 0;\\n        int width = static_cast<int>(board[0].size()) - 1;\\n        int height = static_cast<int>(board.size()) - 1;\\n\\n        // left/right\\n        if (col > 0 && board[row][col - 1] > 0) count++;\\n        if (col < width && board[row][col + 1] > 0) count++;\\n        \\n        // top\\n        if (row > 0) {\\n            if (board[row - 1][col] > 0) count++;\\n            if (col > 0 && board[row - 1][col - 1] > 0) count++;\\n            if (col < width && board[row - 1][col + 1] > 0) count++;\\n        }\\n\\n        // bottom\\n        if (row < height) {\\n            if (board[row + 1][col] > 0) count++;\\n            if (col > 0 && board[row + 1][col - 1] > 0) count++;\\n            if (col < width && board[row + 1][col + 1] > 0) count++;\\n        }\\n\\n        return count;\\n    }\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                auto count = countLivingRelatives(i, j, board);\\n\\n                if (board[i][j] == 1) {\\n                    if (count < 2 || count > 3) board[i][j] = 2; // will be killed\\n                } else {\\n                    if (count == 3) board[i][j] = -1; // will come to life\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (board[i][j] == 2) board[i][j] = 0;\\n                if (board[i][j] == -1) board[i][j] = 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int countLivingRelatives(int row, int col, vector<vector<int>>& board) {\\n        int count = 0;\\n        int width = static_cast<int>(board[0].size()) - 1;\\n        int height = static_cast<int>(board.size()) - 1;\\n\\n        // left/right\\n        if (col > 0 && board[row][col - 1] > 0) count++;\\n        if (col < width && board[row][col + 1] > 0) count++;\\n        \\n        // top\\n        if (row > 0) {\\n            if (board[row - 1][col] > 0) count++;\\n            if (col > 0 && board[row - 1][col - 1] > 0) count++;\\n            if (col < width && board[row - 1][col + 1] > 0) count++;\\n        }\\n\\n        // bottom\\n        if (row < height) {\\n            if (board[row + 1][col] > 0) count++;\\n            if (col > 0 && board[row + 1][col - 1] > 0) count++;\\n            if (col < width && board[row + 1][col + 1] > 0) count++;\\n        }\\n\\n        return count;\\n    }\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                auto count = countLivingRelatives(i, j, board);\\n\\n                if (board[i][j] == 1) {\\n                    if (count < 2 || count > 3) board[i][j] = 2; // will be killed\\n                } else {\\n                    if (count == 3) board[i][j] = -1; // will come to life\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (board[i][j] == 2) board[i][j] = 0;\\n                if (board[i][j] == -1) board[i][j] = 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142566,
                "title": "succinct-human-readable-javascript-solution",
                "content": "I\\'ve made a solution which I believe is readable and separates the parameters of the game of life from the algorithm which implements it. I include comments on my justifications for factoring.\\n\\nI appreciate any feedback or disagreements with my opinion :)\\n\\n```js\\nconst directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1,1]];\\n\\n// I included a more optimal liner for countNeighbors for fun\\n// Good luck getting smooth code review on something like this, though.\\n// It relies on the face that `undefined & 1 === 0`\\n// It\\'s ridiculous for readers to immediately expect that\\n// const countNeighbors = (board, x, y) => directions.reduce((count, [dX, dY]) => count + (board[x+dX] && board[x+dX][y+dY] & 1), 0);\\nconst countNeighbors = (board, x, y) => directions.map(([dX, dY]) => board[x+dX] ? board[x+dX][y+dY] : undefined)\\n    .filter(neighbor => neighbor !== undefined)\\n    .map(neighbor => neighbor & 1)\\n    .reduce((acc, neighbor) => acc + neighbor, 0);\\n\\n// You could argue that these should not be independent functions as they\\'re quite coupled to `gameOfLife` function\\n// However, I believe these are the most likely changed parameters of `gameOfLife`. \\n// This is separation of business logic from algorithm IMO\\nconst reproduces = (board, i, j, neighbors) => neighbors === 3 && board[i][j] === 0;\\nconst survies = (board, i, j, neighbors) => board[i][j] === 1 && (neighbors === 2 || neighbors === 3);\\n\\n/**\\n * @param {number[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar gameOfLife = function(board) {\\n    for (let i of board.keys()) {\\n        for (let j of board[i].keys()) {\\n            const neighbors = countNeighbors(board, i, j);\\n            board[i][j] += reproduces(board, i, j, neighbors) || survies(board, i, j, neighbors) ? 2 : 0;\\n        }\\n    }\\n    for (let i of board.keys()) {\\n        for (let j of board[i].keys()) {\\n            board[i][j] = board[i][j] >> 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nconst directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1,1]];\\n\\n// I included a more optimal liner for countNeighbors for fun\\n// Good luck getting smooth code review on something like this, though.\\n// It relies on the face that `undefined & 1 === 0`\\n// It\\'s ridiculous for readers to immediately expect that\\n// const countNeighbors = (board, x, y) => directions.reduce((count, [dX, dY]) => count + (board[x+dX] && board[x+dX][y+dY] & 1), 0);\\nconst countNeighbors = (board, x, y) => directions.map(([dX, dY]) => board[x+dX] ? board[x+dX][y+dY] : undefined)\\n    .filter(neighbor => neighbor !== undefined)\\n    .map(neighbor => neighbor & 1)\\n    .reduce((acc, neighbor) => acc + neighbor, 0);\\n\\n// You could argue that these should not be independent functions as they\\'re quite coupled to `gameOfLife` function\\n// However, I believe these are the most likely changed parameters of `gameOfLife`. \\n// This is separation of business logic from algorithm IMO\\nconst reproduces = (board, i, j, neighbors) => neighbors === 3 && board[i][j] === 0;\\nconst survies = (board, i, j, neighbors) => board[i][j] === 1 && (neighbors === 2 || neighbors === 3);\\n\\n/**\\n * @param {number[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar gameOfLife = function(board) {\\n    for (let i of board.keys()) {\\n        for (let j of board[i].keys()) {\\n            const neighbors = countNeighbors(board, i, j);\\n            board[i][j] += reproduces(board, i, j, neighbors) || survies(board, i, j, neighbors) ? 2 : 0;\\n        }\\n    }\\n    for (let i of board.keys()) {\\n        for (let j of board[i].keys()) {\\n            board[i][j] = board[i][j] >> 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939049,
                "title": "short-two-pass-in-place-solution",
                "content": "**Idea:** Use the second bit of each cell to store its new state.\\n\\n**Pass 1:** For each cell, count its neighbors and, if it stays or becomes alive, set its second bit (`+= 2`).\\n**Pass 2:** Discard the previous state which is stored in the first bit (`/= 2`).\\n\\n**Notes:**\\n- When counting neighbors, only consider the first bit (`% 2`)\\n- When counting neighbors, it\\'s OK to count the cell itself. We only need to modify the survival/born condition a little.\\n\\n```csharp\\npublic void GameOfLife(int[][] board)\\n{\\n    int m = board.Length;\\n    int n = board[0].Length;\\n    \\n\\t// Pass 1: Calculate the new state\\n    for (int i = 0; i < m; i++)\\n        for (int j = 0; j < n; j++)\\n        {\\n\\t\\t\\t// count neighbors\\n\\t\\t\\tint count = 0;\\n            for (int p = Math.Max(i - 1, 0); p < Math.Min(i + 2, m); p++)\\n                for (int q = Math.Max(j - 1, 0); q < Math.Min(j + 2, n); q++)\\n                    count += board[p][q] % 2;\\n\\t\\t\\t\\t\\t\\n            if (count == 3 || count - board[i][j] == 3)\\n                board[i][j] += 2;\\n        }\\n    \\n\\t// Pass 2: Discard the previous state\\n    for (int i = 0; i < m; i++)\\n        for (int j = 0; j < n; j++)\\n            board[i][j] /= 2;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic void GameOfLife(int[][] board)\\n{\\n    int m = board.Length;\\n    int n = board[0].Length;\\n    \\n\\t// Pass 1: Calculate the new state\\n    for (int i = 0; i < m; i++)\\n        for (int j = 0; j < n; j++)\\n        {\\n\\t\\t\\t// count neighbors\\n\\t\\t\\tint count = 0;\\n            for (int p = Math.Max(i - 1, 0); p < Math.Min(i + 2, m); p++)\\n                for (int q = Math.Max(j - 1, 0); q < Math.Min(j + 2, n); q++)\\n                    count += board[p][q] % 2;\\n\\t\\t\\t\\t\\t\\n            if (count == 3 || count - board[i][j] == 3)\\n                board[i][j] += 2;\\n        }\\n    \\n\\t// Pass 2: Discard the previous state\\n    for (int i = 0; i < m; i++)\\n        for (int j = 0; j < n; j++)\\n            board[i][j] /= 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938603,
                "title": "c-simple-brute-force-with-no-extra-space-in-place-faster-than-100-enjoy",
                "content": "100% faster In-Place approach\\n\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) \\n    {\\n\\t\\t// size of board (m * n)\\n        int m = board.size(), n = board[0].size(), cnt;\\n\\t\\t// vectors X & Y is used to visit all 8 neighbour.\\n        vector<int> X{-1, 0, 1}, Y{-1, 0, 1};\\n\\t\\t// Iterating over board from top to down & left to right\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n\\t\\t\\t\\t// store count of alive neighbour.\\n                cnt = 0;\\n\\t\\t\\t\\t// while using X & Y vectors to visit all neighbour we also visit our current cell & if it is alive it will be counted so decrementing cnt.\\n                if(board[i][j] == 1)\\n                    cnt--;\\n\\t\\t\\t\\t// using X & Y to visit all neighbour \\n\\t\\t\\t\\t// [i - 1, j - 1][i - 1, j + 0][i - 1, j + 1][i + 0, j - 1][i + 0, j + 0][i + 0, j + 1][i + 1, j - 1][i + 1, j + 0][i + 1, j + 1]\\n                for(auto x : X)\\n                {\\n                    for(auto y : Y)\\n                    {\\n\\t\\t\\t\\t\\t\\tif(i + x >= 0 && j + y >= 0 && i + x <= m - 1 && j + y <= n - 1)\\n                        {\\n\\t\\t\\t\\t\\t\\t\\t// since board is changing simultaneously I am coding the state of the cell so when i am visiting them as neighbour of other cell i should know what was their previous value (i.e. in starting state).\\n\\t\\t\\t\\t\\t\\t\\t// 0 -> 0 = -1 if original value is 0 & new value is 0 then representing it with -1\\n\\t\\t\\t\\t\\t\\t\\t// 0 -> 1 = -2 if original value is 0 & new value is 1 then representing it with -2\\n\\t\\t\\t\\t\\t\\t\\t// 1 -> 0 = -3 if original value is 1 & new value is 0 then representing it with -3\\n\\t\\t\\t\\t\\t\\t\\t// 1 -> 1 = -4 if original value is 1 & new value is 1 then representing it with -4\\n\\t\\t\\t\\t\\t\\t\\t// in case of -3 & -4 the original value of cell was 1 & we have to consider them while counting alive neighbour, & 1 represent unvisited neighbour (i.e. neighbour who is situated in right side & bottom of current cell).\\n\\t\\t\\t\\t\\t\\t\\tif(board[i + x][j + y] == 1 || board[i + x][j + y] == -3 || board[i + x][j + y] == -4)\\n                                cnt++;\\n                        }\\n                    }\\n                }\\n\\t\\t\\t\\t// if less than 2 or greater than 3 neighbours are alive then current cell dies.\\n\\t\\t\\t\\tif(cnt < 2 || cnt > 3)\\n\\t\\t\\t\\t\\t// coding state so i can know the previous value (i.e. before i visited them)\\n                    board[i][j] == 0 ? board[i][j] = -1 : board[i][j] = -3;\\n\\t\\t\\t\\t// if 2 neighbours are alive then current cell stays alive.\\n                else if(cnt == 2)\\n                    board[i][j] == 0 ? board[i][j] = -1 : board[i][j] = -4;\\n\\t\\t\\t\\t// if exactly 3 neighbour are alive than currenct cell come back to life.\\n                else if(cnt == 3)\\n                    board[i][j] == 0 ? board[i][j] = -2 : board[i][j] = -4;\\n            }\\n        }\\n\\t\\t// assigning new values to the cell based on our coding scheme.\\n\\t\\tfor(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(board[i][j] == -1)\\n                    board[i][j] = 0;\\n                else if(board[i][j] == -2)\\n                    board[i][j] = 1;\\n                else if(board[i][j] == -3)\\n                    board[i][j] = 0;\\n                else\\n                    board[i][j] = 1;\\n            }\\n        } \\n    }\\n};\\n\\n```\\n\\nThank You for reading, for any doubt leave a comment.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) \\n    {\\n\\t\\t// size of board (m * n)\\n        int m = board.size(), n = board[0].size(), cnt;\\n\\t\\t// vectors X & Y is used to visit all 8 neighbour.\\n        vector<int> X{-1, 0, 1}, Y{-1, 0, 1};\\n\\t\\t// Iterating over board from top to down & left to right\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n\\t\\t\\t\\t// store count of alive neighbour.\\n                cnt = 0;\\n\\t\\t\\t\\t// while using X & Y vectors to visit all neighbour we also visit our current cell & if it is alive it will be counted so decrementing cnt.\\n                if(board[i][j] == 1)\\n                    cnt--;\\n\\t\\t\\t\\t// using X & Y to visit all neighbour \\n\\t\\t\\t\\t// [i - 1, j - 1][i - 1, j + 0][i - 1, j + 1][i + 0, j - 1][i + 0, j + 0][i + 0, j + 1][i + 1, j - 1][i + 1, j + 0][i + 1, j + 1]\\n                for(auto x : X)\\n                {\\n                    for(auto y : Y)\\n                    {\\n\\t\\t\\t\\t\\t\\tif(i + x >= 0 && j + y >= 0 && i + x <= m - 1 && j + y <= n - 1)\\n                        {\\n\\t\\t\\t\\t\\t\\t\\t// since board is changing simultaneously I am coding the state of the cell so when i am visiting them as neighbour of other cell i should know what was their previous value (i.e. in starting state).\\n\\t\\t\\t\\t\\t\\t\\t// 0 -> 0 = -1 if original value is 0 & new value is 0 then representing it with -1\\n\\t\\t\\t\\t\\t\\t\\t// 0 -> 1 = -2 if original value is 0 & new value is 1 then representing it with -2\\n\\t\\t\\t\\t\\t\\t\\t// 1 -> 0 = -3 if original value is 1 & new value is 0 then representing it with -3\\n\\t\\t\\t\\t\\t\\t\\t// 1 -> 1 = -4 if original value is 1 & new value is 1 then representing it with -4\\n\\t\\t\\t\\t\\t\\t\\t// in case of -3 & -4 the original value of cell was 1 & we have to consider them while counting alive neighbour, & 1 represent unvisited neighbour (i.e. neighbour who is situated in right side & bottom of current cell).\\n\\t\\t\\t\\t\\t\\t\\tif(board[i + x][j + y] == 1 || board[i + x][j + y] == -3 || board[i + x][j + y] == -4)\\n                                cnt++;\\n                        }\\n                    }\\n                }\\n\\t\\t\\t\\t// if less than 2 or greater than 3 neighbours are alive then current cell dies.\\n\\t\\t\\t\\tif(cnt < 2 || cnt > 3)\\n\\t\\t\\t\\t\\t// coding state so i can know the previous value (i.e. before i visited them)\\n                    board[i][j] == 0 ? board[i][j] = -1 : board[i][j] = -3;\\n\\t\\t\\t\\t// if 2 neighbours are alive then current cell stays alive.\\n                else if(cnt == 2)\\n                    board[i][j] == 0 ? board[i][j] = -1 : board[i][j] = -4;\\n\\t\\t\\t\\t// if exactly 3 neighbour are alive than currenct cell come back to life.\\n                else if(cnt == 3)\\n                    board[i][j] == 0 ? board[i][j] = -2 : board[i][j] = -4;\\n            }\\n        }\\n\\t\\t// assigning new values to the cell based on our coding scheme.\\n\\t\\tfor(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(board[i][j] == -1)\\n                    board[i][j] = 0;\\n                else if(board[i][j] == -2)\\n                    board[i][j] = 1;\\n                else if(board[i][j] == -3)\\n                    board[i][j] = 0;\\n                else\\n                    board[i][j] = 1;\\n            }\\n        } \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666625,
                "title": "c-solution-o-n-m-time-o-1-space-clean-explained-solution-and-code",
                "content": "**Please read this solution only after you have tried to code the question.**\\n\\n**Explanation:**\\n\\nThe Question depicts that the births and deaths occurs simultaneously. This means if a dead state satisfies the conditions to be changed to alive state, It will still be treated as dead state when any of its neighbours are looking for alive state neighbours and vice-versa.\\n\\nHence, We need to keep track of indices to be changed in the board matrix and change it such that for its neighbours it should still be treated as it\\'s initial state and after  we should also know that this element\\'s state needs to be changed.\\n\\n**I recommend you to give this idea a thought before moving forward with the solution**\\n\\n**Solution:**\\n\\nWe will **change alive state (1) to 2** (could be any number>1) and whenever we will look for alive neighbours we will look if the value is >=1.\\n\\nSimilarly, We will **change dead state (0) to -1** (could be any number<0) and whenever we will look for dead neighbours we will look if the value is <=0.\\n\\n* We will iterate over all elements and count its alive neighbours.\\n* While calculating alive neighbours, we will check if board [i] [j] >=1. *( As some neighbours could be changed to 2 ).*\\n* If the element is in alive state and it does not have 2 or 3 alive neighbours , we change it to 2.\\n* If the element is in dead state and it has exactly 3 alive neighbours , we change it to -1.\\n* After traversing all the elements, we finally change all the 2s to 0 and all the -1s to 1. *( Since, we changed 1 to 2 which was to be changed to 0 and vice-versa)*\\n\\n**Time complexity:** O(n*m).\\n**Space Complexity:** O(1)\\n\\n**CODE:**\\n```  \\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                int cnt = 0;\\n                \\n                // Conditions to check if live state is present vertically and horizontally\\n                if(i>0 && board[i-1][j]>=1) cnt++;\\n                if(i<n-1 && board[i+1][j]>=1) cnt++; \\n                if(j>0 && board[i][j-1]>=1) cnt++; \\n                if(j<m-1 && board[i][j+1]>=1) cnt++;\\n                \\n                // Conditions to check if live state is present diagonally\\n                if(i>0 && j>0 && board[i-1][j-1]>=1) cnt++; \\n                if(i>0 && j<m-1 && board[i-1][j+1]>=1) cnt++; \\n                if(i<n-1 && j>0 && board[i+1][j-1]>=1) cnt++; \\n                if(i<n-1 && j<m-1 && board[i+1][j+1]>=1) cnt++; \\n                \\n                // Replacing live state (1) as dead state (0) as 2 if cnt<2 OR cnt>3\\n                // Replacing dead state (0) as alive state (0) as -1 if cnt==3\\n\\t\\t\\t\\t\\n                if(board[i][j]==1 && (cnt<2 || cnt>3)) board[i][j]=2;\\n                \\n                if(board[i][j]==0 && cnt==3) board[i][j]=-1;\\n            }\\n        }\\n        \\n\\t\\t// Replacing all the 2s to 0 and -1s to 1\\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==2) board[i][j]=0;\\n                if(board[i][j]==-1) board[i][j]=1;\\n            }\\n        }\\n            \\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```  \\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                int cnt = 0;\\n                \\n                // Conditions to check if live state is present vertically and horizontally\\n                if(i>0 && board[i-1][j]>=1) cnt++;\\n                if(i<n-1 && board[i+1][j]>=1) cnt++; \\n                if(j>0 && board[i][j-1]>=1) cnt++; \\n                if(j<m-1 && board[i][j+1]>=1) cnt++;\\n                \\n                // Conditions to check if live state is present diagonally\\n                if(i>0 && j>0 && board[i-1][j-1]>=1) cnt++; \\n                if(i>0 && j<m-1 && board[i-1][j+1]>=1) cnt++; \\n                if(i<n-1 && j>0 && board[i+1][j-1]>=1) cnt++; \\n                if(i<n-1 && j<m-1 && board[i+1][j+1]>=1) cnt++; \\n                \\n                // Replacing live state (1) as dead state (0) as 2 if cnt<2 OR cnt>3\\n                // Replacing dead state (0) as alive state (0) as -1 if cnt==3\\n\\t\\t\\t\\t\\n                if(board[i][j]==1 && (cnt<2 || cnt>3)) board[i][j]=2;\\n                \\n                if(board[i][j]==0 && cnt==3) board[i][j]=-1;\\n            }\\n        }\\n        \\n\\t\\t// Replacing all the 2s to 0 and -1s to 1\\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==2) board[i][j]=0;\\n                if(board[i][j]==-1) board[i][j]=1;\\n            }\\n        }\\n            \\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421291,
                "title": "c-short-using-bits",
                "content": "```\\n void gameOfLife(vector<vector<int>>& matrix) {\\n   int n=matrix.size(), m=matrix[0].size();\\n    \\n    for(int i=0;i<n; i++){\\n      for(int j=0;j<m; j++){\\n        int count =0; //count living neighbours\\n\\n          for(int I=max(i-1,0); I<min(i+2,n); I++)   //check for all 8 neighbours\\n           for(int J=max(j-1,0); J<min(j+2,m); J++)\\n            if(I!=i || J!=j)                        //skip the cell on which we are standing\\n              count+= matrix[I][J] & 1;      //bit and operation to check state(living or dead)\\n\\n       if ((count | matrix[i][j]) == 3)       // this will handle all condition , (count val | cell state = next state of cell ) -- >  (11|0=11(Live), 11|1=11(Live),  10|1=11(Live), 10|0=10(dead) )\\n          matrix[i][j] |= 2;  //set the next state live \\n      }\\n    }\\n\\n   for(int i=0;i<n; i++)\\n      for(int j=0;j<m; j++)\\n         matrix[i][j]>>= 1; // move to the next state by bitwise shift \\n }\\n```",
                "solutionTags": [],
                "code": "```\\n void gameOfLife(vector<vector<int>>& matrix) {\\n   int n=matrix.size(), m=matrix[0].size();\\n    \\n    for(int i=0;i<n; i++){\\n      for(int j=0;j<m; j++){\\n        int count =0; //count living neighbours\\n\\n          for(int I=max(i-1,0); I<min(i+2,n); I++)   //check for all 8 neighbours\\n           for(int J=max(j-1,0); J<min(j+2,m); J++)\\n            if(I!=i || J!=j)                        //skip the cell on which we are standing\\n              count+= matrix[I][J] & 1;      //bit and operation to check state(living or dead)\\n\\n       if ((count | matrix[i][j]) == 3)       // this will handle all condition , (count val | cell state = next state of cell ) -- >  (11|0=11(Live), 11|1=11(Live),  10|1=11(Live), 10|0=10(dead) )\\n          matrix[i][j] |= 2;  //set the next state live \\n      }\\n    }\\n\\n   for(int i=0;i<n; i++)\\n      for(int j=0;j<m; j++)\\n         matrix[i][j]>>= 1; // move to the next state by bitwise shift \\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1274985,
                "title": "c-0ms-o-1-space-o-mn-time-with-detailed-explanation",
                "content": "We are storing two data at same point (i,j). Initial state and the new state. As for example, board[i][j] = (inState2+newState). From which we can get initial state as board[i][j]/2 and final as state board[i][j]%2.\\nSteps-\\n* Make every board element having two states.\\n* Calculate according to the initial state and store new states also according to the conditions given.\\n* Finalise the board using by updating every element of the board to their new state value.\\n**Code-**\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size(),m=board[0].size();\\n        vector<int>dir{-1,0,1,0,-1,-1,1,1,-1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int cnt=0;\\n                for(int k=0;k<8;k++){\\n                    int r=i+dir[k],c=j+dir[k+1];\\n                    if(r<0||c<0||r>=n||c>=m||board[r][c]%2==0)continue;\\n                    cnt++;\\n                }\\n                if(board[i][j]%2==0){\\n                    if(cnt==3){\\n                        board[i][j]=board[i][j]%2+1*2;\\n                    }\\n                    else{\\n                        board[i][j]=board[i][j]%2+0*2;\\n                    }\\n                }\\n                else{\\n                    if(cnt<2||cnt>=4){\\n                        board[i][j]=board[i][j]%2+0*2;\\n                    }\\n                    else {\\n                        board[i][j]=board[i][j]%2+1*2;\\n                    }\\n                   \\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)board[i][j]/=2;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size(),m=board[0].size();\\n        vector<int>dir{-1,0,1,0,-1,-1,1,1,-1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int cnt=0;\\n                for(int k=0;k<8;k++){\\n                    int r=i+dir[k],c=j+dir[k+1];\\n                    if(r<0||c<0||r>=n||c>=m||board[r][c]%2==0)continue;\\n                    cnt++;\\n                }\\n                if(board[i][j]%2==0){\\n                    if(cnt==3){\\n                        board[i][j]=board[i][j]%2+1*2;\\n                    }\\n                    else{\\n                        board[i][j]=board[i][j]%2+0*2;\\n                    }\\n                }\\n                else{\\n                    if(cnt<2||cnt>=4){\\n                        board[i][j]=board[i][j]%2+0*2;\\n                    }\\n                    else {\\n                        board[i][j]=board[i][j]%2+1*2;\\n                    }\\n                   \\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)board[i][j]/=2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720216,
                "title": "short-and-simple-beats-100-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& b) {\\n        int r = b.size(), c = b[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\\n                int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n\\n                int o = 0, z = 0;\\n                for (int idx = 0; idx < 8; idx++) {\\n                    int nx = i + dx[idx], ny = j + dy[idx];\\n                    if (nx < 0 || nx >= r || ny < 0 || ny >= c) continue;\\n                    b[nx][ny] == 1 ? o++ : z++;\\n                }\\n\\n                if (b[i][j] == 1 && o < 2) ans[i][j] = 0;\\n                else if (b[i][j] == 1 && (o == 2 || o == 3)) ans[i][j] = 1;\\n                else if (b[i][j] == 1 && o > 3) ans[i][j] = 0;\\n                else if (b[i][j] == 0 && o == 3) ans[i][j] = 1;\\n            }\\n        }\\n\\n        b = ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& b) {\\n        int r = b.size(), c = b[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\\n                int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n\\n                int o = 0, z = 0;\\n                for (int idx = 0; idx < 8; idx++) {\\n                    int nx = i + dx[idx], ny = j + dy[idx];\\n                    if (nx < 0 || nx >= r || ny < 0 || ny >= c) continue;\\n                    b[nx][ny] == 1 ? o++ : z++;\\n                }\\n\\n                if (b[i][j] == 1 && o < 2) ans[i][j] = 0;\\n                else if (b[i][j] == 1 && (o == 2 || o == 3)) ans[i][j] = 1;\\n                else if (b[i][j] == 1 && o > 3) ans[i][j] = 0;\\n                else if (b[i][j] == 0 && o == 3) ans[i][j] = 1;\\n            }\\n        }\\n\\n        b = ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365172,
                "title": "in-place-approach-using-bit-manipulation-with-detailed-explanation",
                "content": "# Intuition\\n **Initial Approach**\\n- Create a new board of the same size as the input board to hold the next state.\\n- Iterate over every cell in the input board and apply the rules of the game\\n- Return the new board containing the next state.\\n\\nHere time and space complexity will be $$O(mn)$$. But as mentioned in the follow ups we need to solve it using in-place. To do this, we can use a  encoding to represent the current and next states of each cell.\\n\\n# Approach\\n**Bit manipulation Approach**\\n\\nI\\'am using bit manipulation approach to solve this problem using in-place.\\nWe can encode the current state of a cell using a single bit (i.e., 0 or 1).To represent the next state, we can use a bit in the second position of the same integer. For example - if the current state of a cell is 1 and its next state is also 1, we can represent this as the integer 3 (binary 11).\\n```\\n        currentState  nextState    binary    integer\\n              0          0           00         0\\n              0          1           01         1\\n              1          0           10         2\\n              1          1           11         3\\n```\\nWith this encoding, we can update each cell based on the current state of its neighbors and once we have updated all the next states of all the cells in the board, we can decode the next state of each cell from its integer representation and use it as the new current state. Here space complexity will be $$O(1)$$ since we are not creating a new board.\\n\\n**Infinite Board Follow up**\\n\\nIn my opinion this is a subjective problem whose solution can varies based on the environment and use case. \\nFor example if in some case where this infinitely large board can\\'t be load into the memory, then we can make chunks of it and compute the output using these chunks (since the next state of a cell only depends on left column, right column, above row and below row). \\nIf this infinitely large board contains a lot of zeros (deads) then we can also use sparse matrix which can significantly reduce the memory usage and improve the efficiency of the algorithm. We can use a hash table to store the coordinates of the live cells only. The keys of the hash table are the coordinates of the live cells and the values are the corresponding cell values. Now we iterate the hash table, and calculate liveNeighbours of a cell. After this update the hash table with the new state, and remove any dead cells from the hash table.\\n\\n# Complexity\\n- Time complexity: $$O(mn)$$\\n\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    fun gameOfLife(board: Array<IntArray>) {\\n        val rowMax = board.size\\n        val columnMax = board[0].size\\n\\n        // For in-place solution we use bit-manipulation.\\n        // First bit will represent current state\\n        // Second bit will represent next state\\n        // currentState  nextState    binary    integer\\n        //       0          0           00         0\\n        //       0          1           01         1\\n        //       1          0           10         2\\n        //       1          1           11         3\\n\\n\\n        // iterate board\\n        for (row in 0 until rowMax) {\\n            for (column in 0 until columnMax) {\\n                val lives = countAliveNeighbors(board, rowMax, columnMax, row, column)\\n                setNextState(lives, board, row, column)\\n            }\\n        }\\n\\n        // Decode new board\\n        for (row in 0 until rowMax) {\\n            for (column in 0 until columnMax) {\\n                board[row][column] = board[row][column] shr 1 // Shift second bit to 1st bit\\n            }\\n        }\\n    }\\n\\n    private fun setNextState(lives: Int, board: Array<IntArray>, row: Int, column: Int) {\\n        if (board[row][column] == 1 && (lives == 2 || lives == 3)) {\\n            // set next state as alive\\n            board[row][column] = board[row][column] or 2 // Set second bit to 1 (OR with 10)\\n        } else if (board[row][column] == 0 && lives == 3) {\\n            // set next state as alive\\n            board[row][column] = board[row][column] or 2 // Set second bit to 1 (OR with 10)\\n        } else {\\n            // set next state as dead\\n            board[row][column] = board[row][column] or 0 // set second bit to 0 (OR with 00)\\n        }\\n    }\\n\\n    private fun countAliveNeighbors(\\n        board: Array<IntArray>,\\n        rowMax: Int,\\n        columnMax: Int,\\n        currentRow: Int,\\n        currentColumn: Int\\n    ): Int {\\n        var count = 0\\n\\n        // creating row boundaries (either left or right from current row-index)\\n        for (row in Math.max(0, currentRow - 1)..Math.min(rowMax - 1, currentRow + 1)) {\\n            // creating column boundaries (either top or bottom from current column-index)\\n            for (column in Math.max(0, currentColumn - 1)..Math.min(\\n                columnMax - 1,\\n                currentColumn + 1\\n            )) {\\n                if (row == currentRow && column == currentColumn) continue  // skip current grid\\n                count += board[row][column] and 1 // Check first bit for alive status (AND with 01)\\n            }\\n        }\\n        return count\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n        currentState  nextState    binary    integer\\n              0          0           00         0\\n              0          1           01         1\\n              1          0           10         2\\n              1          1           11         3\\n```\n```\\nclass Solution {\\n\\n    fun gameOfLife(board: Array<IntArray>) {\\n        val rowMax = board.size\\n        val columnMax = board[0].size\\n\\n        // For in-place solution we use bit-manipulation.\\n        // First bit will represent current state\\n        // Second bit will represent next state\\n        // currentState  nextState    binary    integer\\n        //       0          0           00         0\\n        //       0          1           01         1\\n        //       1          0           10         2\\n        //       1          1           11         3\\n\\n\\n        // iterate board\\n        for (row in 0 until rowMax) {\\n            for (column in 0 until columnMax) {\\n                val lives = countAliveNeighbors(board, rowMax, columnMax, row, column)\\n                setNextState(lives, board, row, column)\\n            }\\n        }\\n\\n        // Decode new board\\n        for (row in 0 until rowMax) {\\n            for (column in 0 until columnMax) {\\n                board[row][column] = board[row][column] shr 1 // Shift second bit to 1st bit\\n            }\\n        }\\n    }\\n\\n    private fun setNextState(lives: Int, board: Array<IntArray>, row: Int, column: Int) {\\n        if (board[row][column] == 1 && (lives == 2 || lives == 3)) {\\n            // set next state as alive\\n            board[row][column] = board[row][column] or 2 // Set second bit to 1 (OR with 10)\\n        } else if (board[row][column] == 0 && lives == 3) {\\n            // set next state as alive\\n            board[row][column] = board[row][column] or 2 // Set second bit to 1 (OR with 10)\\n        } else {\\n            // set next state as dead\\n            board[row][column] = board[row][column] or 0 // set second bit to 0 (OR with 00)\\n        }\\n    }\\n\\n    private fun countAliveNeighbors(\\n        board: Array<IntArray>,\\n        rowMax: Int,\\n        columnMax: Int,\\n        currentRow: Int,\\n        currentColumn: Int\\n    ): Int {\\n        var count = 0\\n\\n        // creating row boundaries (either left or right from current row-index)\\n        for (row in Math.max(0, currentRow - 1)..Math.min(rowMax - 1, currentRow + 1)) {\\n            // creating column boundaries (either top or bottom from current column-index)\\n            for (column in Math.max(0, currentColumn - 1)..Math.min(\\n                columnMax - 1,\\n                currentColumn + 1\\n            )) {\\n                if (row == currentRow && column == currentColumn) continue  // skip current grid\\n                count += board[row][column] and 1 // Check first bit for alive status (AND with 01)\\n            }\\n        }\\n        return count\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050857,
                "title": "c-easy-solution-with-comments",
                "content": "\\n\\n# Approach\\nCheck all the nearby elements of the given board and store the number in a variable named as temp. Modify the values of the newboard accordingly.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int r=board.size();\\n        int c=board[0].size();\\n\\n        vector<vector<int>> newboard=board;\\n    \\n    for(int i=0;i<board.size();i++){\\n        for(int j=0;j<board[i].size();j++){\\n            int temp=0;//this contains count of nearby 1\\'s\\n\\n            //used for checking nearby elemts\\n            int dx[8]={0,0,1,1,1,-1,-1,-1}; \\n            int dy[8]={1,-1,0,1,-1,0,1,-1};\\n\\n                for(int k=0;k<8;k++){\\n                int newx=i+dx[k];\\n                int newy=j+dy[k];\\n\\n                    //if indexes don\\'t exist\\n                    if(newx<0 || newx>=r || newy<0 || newy>=c){continue;}\\n\\n                    if(board[newx][newy]==1){\\n                        temp++;\\n                    }\\n                }\\n        \\n            //update values of newboard according to given conditions\\n            if(board[i][j]==1 && temp<2){newboard[i][j]=0;}\\n            if(board[i][j]==1 && temp>3){newboard[i][j]=0;}\\n            if(board[i][j]==0 && temp==3){newboard[i][j]=1;}    \\n        }\\n    } \\n    board=newboard;   \\n    }\\n};\\n```\\n**Please upvote if it helps. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int r=board.size();\\n        int c=board[0].size();\\n\\n        vector<vector<int>> newboard=board;\\n    \\n    for(int i=0;i<board.size();i++){\\n        for(int j=0;j<board[i].size();j++){\\n            int temp=0;//this contains count of nearby 1\\'s\\n\\n            //used for checking nearby elemts\\n            int dx[8]={0,0,1,1,1,-1,-1,-1}; \\n            int dy[8]={1,-1,0,1,-1,0,1,-1};\\n\\n                for(int k=0;k<8;k++){\\n                int newx=i+dx[k];\\n                int newy=j+dy[k];\\n\\n                    //if indexes don\\'t exist\\n                    if(newx<0 || newx>=r || newy<0 || newy>=c){continue;}\\n\\n                    if(board[newx][newy]==1){\\n                        temp++;\\n                    }\\n                }\\n        \\n            //update values of newboard according to given conditions\\n            if(board[i][j]==1 && temp<2){newboard[i][j]=0;}\\n            if(board[i][j]==1 && temp>3){newboard[i][j]=0;}\\n            if(board[i][j]==0 && temp==3){newboard[i][j]=1;}    \\n        }\\n    } \\n    board=newboard;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940323,
                "title": "constant-space-solution",
                "content": "here we do in place calculations as we store the new values by adding with 10\\nthus we can get new values by dividing with 10 and old values by just modulus  with 10\\n\\n\\n\\n```\\nint count(int i,int j,vector<vector<int>>& a)\\n    {\\n     int n=a.size(),m=a[0].size();   \\n        int c=0;\\n        for(int x=-1;x<=1;x++)\\n        {\\n            for(int y=-1;y<=1;y++)\\n            {  if(x==0 && y==0) continue;\\n             \\n                int ni=i+x;\\n                int nj=j+y;\\n                \\n                if(ni>=0 && ni<n && nj>=0 && nj<m)\\n                {\\n                    if(a[ni][nj]%10==1)c++;\\n                }\\n            }\\n        }\\n        \\n        return c;\\n        \\n        \\n    }\\n    void gameOfLife(vector<vector<int>>& a) {\\n        int i,j,n=a.size(),m=a[0].size();\\n    \\n    for(i=0;i<n;i++)\\n    {\\n        for(j=0;j<m;j++)\\n        {\\n            if(a[i][j]==0)\\n            {\\n                int total_alive=count(i,j,a);\\n                \\n                if(total_alive==3)\\n                {\\n                    a[i][j]=10;\\n                }\\n            }\\n            else{\\n                int total_alive=count(i,j,a);\\n                \\n                if(total_alive<2)\\n                {\\n                    a[i][j]=1;\\n                }\\n                else if(total_alive<=3)\\n                {\\n                    a[i][j]+=10;\\n                }\\n                else if(total_alive>3)\\n                {\\n                    a[i][j]=1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    for(i=0;i<n;i++)\\n    {\\n        for(j=0;j<m;j++)\\n        {a[i][j]/=10;}\\n    }\\n    \\n    \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint count(int i,int j,vector<vector<int>>& a)\\n    {\\n     int n=a.size(),m=a[0].size();   \\n        int c=0;\\n        for(int x=-1;x<=1;x++)\\n        {\\n            for(int y=-1;y<=1;y++)\\n            {  if(x==0 && y==0) continue;\\n             \\n                int ni=i+x;\\n                int nj=j+y;\\n                \\n                if(ni>=0 && ni<n && nj>=0 && nj<m)\\n                {\\n                    if(a[ni][nj]%10==1)c++;\\n                }\\n            }\\n        }\\n        \\n        return c;\\n        \\n        \\n    }\\n    void gameOfLife(vector<vector<int>>& a) {\\n        int i,j,n=a.size(),m=a[0].size();\\n    \\n    for(i=0;i<n;i++)\\n    {\\n        for(j=0;j<m;j++)\\n        {\\n            if(a[i][j]==0)\\n            {\\n                int total_alive=count(i,j,a);\\n                \\n                if(total_alive==3)\\n                {\\n                    a[i][j]=10;\\n                }\\n            }\\n            else{\\n                int total_alive=count(i,j,a);\\n                \\n                if(total_alive<2)\\n                {\\n                    a[i][j]=1;\\n                }\\n                else if(total_alive<=3)\\n                {\\n                    a[i][j]+=10;\\n                }\\n                else if(total_alive>3)\\n                {\\n                    a[i][j]=1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    for(i=0;i<n;i++)\\n    {\\n        for(j=0;j<m;j++)\\n        {a[i][j]/=10;}\\n    }\\n    \\n    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938252,
                "title": "c-o-1-space-solution-100-faster-with-explanation",
                "content": "# Daily Challenge:-12/04/2022\\n**Approach:**-This is the Matrix Simulation Problem .\\n-->What the Problem is Saying We have to apply that same thing.\\n-->For Every (i,j) we call a Check function which keep track of count.\\n-->For Every (i,j) We check neighbour is a valid neighbor or not i.e isvalid function.\\n\\n-->Any cell =5 means it was Previously live now it is dead.\\n\\n-->Any cell =6 means Previously it was dead now live.\\n\\n-->After Checking for all the cells.\\nThose cells which are 5 make them Zero and Those which are 6 make them 1\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    bool isvalid(int i,int j)\\n    {\\n        if(i>=0&&i<m&&j>=0&&j<n)\\n            return 1;\\n        return 0;\\n    }\\n    void check(vector<vector<int>>&board,int i,int j)\\n    {\\n        int count=0;\\n        /*Below is the Check for all 8 direction of given i,j*/\\n        if(isvalid(i,j+1)&&(board[i][j+1]==1||board[i][j+1]==5))\\n            count++;\\n        if(isvalid(i,j-1)&&(board[i][j-1]==1||board[i][j-1]==5))\\n            count++;\\n        if(isvalid(i+1,j+1)&&(board[i+1][j+1]==1||board[i+1][j+1]==5))\\n            count++;\\n        if(isvalid(i+1,j-1)&&(board[i+1][j-1]==1||board[i+1][j-1]==5))\\n            count++;\\n        if(isvalid(i-1,j-1)&&(board[i-1][j-1]==1||board[i-1][j-1]==5))\\n            count++;\\n        if(isvalid(i-1,j+1)&&(board[i-1][j+1]==1||board[i-1][j+1]==5))\\n            count++;\\n        if(isvalid(i+1,j)&&(board[i+1][j]==1||board[i+1][j]==5))\\n            count++;\\n        if(isvalid(i-1,j)&&(board[i-1][j]==1||board[i-1][j]==5))\\n            count++;\\n        \\n        \\n        if(board[i][j]==1) //If the cell we are checking is 1.\\n        {\\n           if(count<2)\\n             board[i][j]=5; //Previously it was live now it is dead\\n           if(count>3)\\n             board[i][j]=5; //Previously it was live now it is dead\\n        }\\n        else if(board[i][j]==0) //If the cell foe which we are checking is dead i.e 1.\\n        {\\n            if(count==3)\\n            board[i][j]=6; //Previously it was dead now it is live.\\n        }\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        m=board.size(),n=board[0].size(); //Globalvariable.\\n        for(int i=0;i<m;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                check(board,i,j);\\n            }\\n        }\\n\\n        /*Those cells which are 5 make them Zero and Those which are 6 make them 1*/\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(board[i][j]==5)\\n                    board[i][j]=0;\\n                if(board[i][j]==6)\\n                    board[i][j]=1;\\n            }\\n        }\\n    }\\n};\\n```\\n*If you find it helpful.Please Upvote.*",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    bool isvalid(int i,int j)\\n    {\\n        if(i>=0&&i<m&&j>=0&&j<n)\\n            return 1;\\n        return 0;\\n    }\\n    void check(vector<vector<int>>&board,int i,int j)\\n    {\\n        int count=0;\\n        /*Below is the Check for all 8 direction of given i,j*/\\n        if(isvalid(i,j+1)&&(board[i][j+1]==1||board[i][j+1]==5))\\n            count++;\\n        if(isvalid(i,j-1)&&(board[i][j-1]==1||board[i][j-1]==5))\\n            count++;\\n        if(isvalid(i+1,j+1)&&(board[i+1][j+1]==1||board[i+1][j+1]==5))\\n            count++;\\n        if(isvalid(i+1,j-1)&&(board[i+1][j-1]==1||board[i+1][j-1]==5))\\n            count++;\\n        if(isvalid(i-1,j-1)&&(board[i-1][j-1]==1||board[i-1][j-1]==5))\\n            count++;\\n        if(isvalid(i-1,j+1)&&(board[i-1][j+1]==1||board[i-1][j+1]==5))\\n            count++;\\n        if(isvalid(i+1,j)&&(board[i+1][j]==1||board[i+1][j]==5))\\n            count++;\\n        if(isvalid(i-1,j)&&(board[i-1][j]==1||board[i-1][j]==5))\\n            count++;\\n        \\n        \\n        if(board[i][j]==1) //If the cell we are checking is 1.\\n        {\\n           if(count<2)\\n             board[i][j]=5; //Previously it was live now it is dead\\n           if(count>3)\\n             board[i][j]=5; //Previously it was live now it is dead\\n        }\\n        else if(board[i][j]==0) //If the cell foe which we are checking is dead i.e 1.\\n        {\\n            if(count==3)\\n            board[i][j]=6; //Previously it was dead now it is live.\\n        }\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        m=board.size(),n=board[0].size(); //Globalvariable.\\n        for(int i=0;i<m;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                check(board,i,j);\\n            }\\n        }\\n\\n        /*Those cells which are 5 make them Zero and Those which are 6 make them 1*/\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(board[i][j]==5)\\n                    board[i][j]=0;\\n                if(board[i][j]==6)\\n                    board[i][j]=1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030067,
                "title": "javascript-in-place-solution-that-s-easy-to-understand",
                "content": "To do this in place (also known as O(1) or constant space), we need to change the value of a processed cell to a value that we can recognize later and know these two specific things:\\n1. Is the cell currently alive or dead?\\n2. Is the cell going to be alive or dead next cycle?\\n\\nThis is the way that I accomplished this:\\n\\n**Is the cell currently alive or dead?**\\nTo denote a **initially** dead cell, I used `-` (negative) to denote this. To denote an initially alive cell, I just kept it unsigned / positive `+`\\n\\n**Is the cell going to be alive or dead next cycle?**\\nSo right now, we know a cell is alive if it is `1`, and we know it is dead if it is `0`. Looking at this, I realized we could use modulo (`%`) 2 on 1 or 0, and still have the same value.\\n\\n`0 % 2 = 0` and `1 % 2 = 1`\\n\\nWith these building blocks, I was ready to start doing this in place. \\n\\n* If a cell is dead, but will be alive next rotation, we use `-1`\\n* If a cell is dead now, and dead later, we still use `0`\\n* If a cell is alive now, but will be dead later, we use `2`\\n* If a cell is alive now, and alive next rotation, we use `1`\\n\\nWe know a **processed cell is initially dead** if it is less than zero, and we know a **processed cell is initially alive** if it is greater than or equal to 1 (or greater than zero whatever your flavor is).\\n\\n```\\nvar gameOfLife = function (board) {\\n\\tfor (var row = 0; row <= board.length - 1; row++) {\\n\\t\\tfor (var col = 0; col <= board[0].length - 1; col++) {\\n\\t\\t\\tboard[row][col] = bfs(board, row, col);\\n\\t\\t}\\n\\t}\\n\\n\\tfor (var row = 0; row <= board.length - 1; row++) {\\n\\t\\tfor (var col = 0; col <= board[0].length - 1; col++) {\\n\\t\\t\\tboard[row][col] = Math.abs(board[row][col] % 2);\\n\\t\\t}\\n\\t}\\n\\treturn board;\\n};\\n\\n// up, down, left, right, diagonals (4)\\nconst bfs = (board, row, col) => {\\n\\tvar isPixelDead = board[row][col] === 0,\\n\\t\\tliveCellCount = 0,\\n\\t\\tmoves = [\\n\\t\\t\\t[row - 1, col - 1], // top left\\n\\t\\t\\t[row - 1, col], // top\\n\\t\\t\\t[row - 1, col + 1], // top right\\n\\t\\t\\t[row, col - 1], // left\\n\\t\\t\\t[row, col + 1], // right\\n\\t\\t\\t[row + 1, col - 1], // bottom left\\n\\t\\t\\t[row + 1, col], // bottom\\n\\t\\t\\t[row + 1, col + 1], // bottom right\\n\\t\\t];\\n\\n\\tfor (var i = 0; i <= moves.length - 1; i++) {\\n\\t\\tlet [newRow, newCol] = moves[i];\\n\\n\\t\\tif (isInBounds(board, newRow, newCol) && board[newRow][newCol] >= 1) {\\n\\t\\t\\tliveCellCount++;\\n\\t\\t}\\n\\t}\\n\\n\\tif (isPixelDead) {\\n\\t\\t// dead now, alive next cycle\\n\\t\\tif (liveCellCount === 3) return -1;\\n\\t\\t// dead now, and dead later\\n\\t\\treturn 0;\\n\\t} else {\\n\\t\\t// alive now, won\\'t be alive next cycle\\n\\t\\tif (liveCellCount < 2 || liveCellCount > 3) return 2;\\n\\t\\t// alive now, and alive later\\n\\t\\telse if (liveCellCount === 2 || liveCellCount === 3) return 1;\\n\\t}\\n};\\n\\nconst isInBounds = (board, row, col) => {\\n\\treturn (\\n\\t\\trow >= 0 &&\\n\\t\\trow <= board.length - 1 &&\\n\\t\\tcol >= 0 &&\\n\\t\\tcol <= board[0].length - 1\\n\\t);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar gameOfLife = function (board) {\\n\\tfor (var row = 0; row <= board.length - 1; row++) {\\n\\t\\tfor (var col = 0; col <= board[0].length - 1; col++) {\\n\\t\\t\\tboard[row][col] = bfs(board, row, col);\\n\\t\\t}\\n\\t}\\n\\n\\tfor (var row = 0; row <= board.length - 1; row++) {\\n\\t\\tfor (var col = 0; col <= board[0].length - 1; col++) {\\n\\t\\t\\tboard[row][col] = Math.abs(board[row][col] % 2);\\n\\t\\t}\\n\\t}\\n\\treturn board;\\n};\\n\\n// up, down, left, right, diagonals (4)\\nconst bfs = (board, row, col) => {\\n\\tvar isPixelDead = board[row][col] === 0,\\n\\t\\tliveCellCount = 0,\\n\\t\\tmoves = [\\n\\t\\t\\t[row - 1, col - 1], // top left\\n\\t\\t\\t[row - 1, col], // top\\n\\t\\t\\t[row - 1, col + 1], // top right\\n\\t\\t\\t[row, col - 1], // left\\n\\t\\t\\t[row, col + 1], // right\\n\\t\\t\\t[row + 1, col - 1], // bottom left\\n\\t\\t\\t[row + 1, col], // bottom\\n\\t\\t\\t[row + 1, col + 1], // bottom right\\n\\t\\t];\\n\\n\\tfor (var i = 0; i <= moves.length - 1; i++) {\\n\\t\\tlet [newRow, newCol] = moves[i];\\n\\n\\t\\tif (isInBounds(board, newRow, newCol) && board[newRow][newCol] >= 1) {\\n\\t\\t\\tliveCellCount++;\\n\\t\\t}\\n\\t}\\n\\n\\tif (isPixelDead) {\\n\\t\\t// dead now, alive next cycle\\n\\t\\tif (liveCellCount === 3) return -1;\\n\\t\\t// dead now, and dead later\\n\\t\\treturn 0;\\n\\t} else {\\n\\t\\t// alive now, won\\'t be alive next cycle\\n\\t\\tif (liveCellCount < 2 || liveCellCount > 3) return 2;\\n\\t\\t// alive now, and alive later\\n\\t\\telse if (liveCellCount === 2 || liveCellCount === 3) return 1;\\n\\t}\\n};\\n\\nconst isInBounds = (board, row, col) => {\\n\\treturn (\\n\\t\\trow >= 0 &&\\n\\t\\trow <= board.length - 1 &&\\n\\t\\tcol >= 0 &&\\n\\t\\tcol <= board[0].length - 1\\n\\t);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 996844,
                "title": "game-of-life-inplace-solution-c-solution",
                "content": "**Time :O(8  * m * n)        Space : O(1)**\\n\\n1) First we will Traverse and Change all the 0s  into -1 **---->** when live neighbour count is 3\\n2) Also, change the board value from 1 to 2.**------>** if live neighbours count is <2 & >3\\n------------------------------------------------------------------------------------------------------\\n\\t\\n3) also if we find -1 we will take it as 0 as it was originally 0\\n4) and if we find a 2 we will take it as 1 as it was originally 1\\n------------------------------------------------------------------------------------------\\n5) We will change all the 2 value to 0  revert(step 2)\\n6) We will change all the -1 value to 1  revert(step 1)\\n\\t\\n\\t\\n```\\nclass Solution {\\npublic:\\n    bool valid(int i, int j, int n, int m)\\n    {\\n        if(i<0 || i>=n || j<0 || j>=m)\\n            return false;\\n        return true;\\n    }\\n    int countLiveNeigh(int i, int j, vector<vector<int>>& b)\\n    {\\n        int chi[] = {1, -1, 1, -1, -1, 0, 1,  0};\\n        int chj[] = {1, -1, -1, 1,  0, 1, 0, -1};\\n        int liveN = 0;\\n        for(int ch = 0; ch < 8; ch++) {\\n            if(valid(i + chi[ch], j + chj[ch], b.size(), b[0].size()) \\n               && \\n               (b[i+chi[ch]][j + chj[ch]] == 1 || b[i+chi[ch]][j + chj[ch]] == 2)\\n              )\\n                liveN += 1;\\n        }\\n        \\n        return liveN;\\n    }\\n    \\n\\tvoid gameOfLife(vector<vector<int>>& board) {\\n\\n        if(!board.size())\\n            return;\\n        \\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        for(int r = 0; r < n; r++) {\\n            for(int c = 0; c < m; c++) {\\n                \\n                int liveN = countLiveNeigh(r, c, board);\\n                if(board[r][c] == 1 && (liveN < 2 || liveN > 3))\\n                    board[r][c] = 2; // turn to 0(2)\\n                \\n                else if(board[r][c] == 0 && liveN == 3)\\n                    board[r][c] = -1; // turn to 1(-1)\\n            }\\n        }\\n        \\n        for(int r = 0; r < n; r++) {\\n            for(int c = 0; c < m; c++) {\\n                if(board[r][c] == 2)\\n                    board[r][c] = 0;\\n                else if(board[r][c] == -1)\\n                    board[r][c] = 1;\\n            }\\n        }\\n        \\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int i, int j, int n, int m)\\n    {\\n        if(i<0 || i>=n || j<0 || j>=m)\\n            return false;\\n        return true;\\n    }\\n    int countLiveNeigh(int i, int j, vector<vector<int>>& b)\\n    {\\n        int chi[] = {1, -1, 1, -1, -1, 0, 1,  0};\\n        int chj[] = {1, -1, -1, 1,  0, 1, 0, -1};\\n        int liveN = 0;\\n        for(int ch = 0; ch < 8; ch++) {\\n            if(valid(i + chi[ch], j + chj[ch], b.size(), b[0].size()) \\n               && \\n               (b[i+chi[ch]][j + chj[ch]] == 1 || b[i+chi[ch]][j + chj[ch]] == 2)\\n              )\\n                liveN += 1;\\n        }\\n        \\n        return liveN;\\n    }\\n    \\n\\tvoid gameOfLife(vector<vector<int>>& board) {\\n\\n        if(!board.size())\\n            return;\\n        \\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        for(int r = 0; r < n; r++) {\\n            for(int c = 0; c < m; c++) {\\n                \\n                int liveN = countLiveNeigh(r, c, board);\\n                if(board[r][c] == 1 && (liveN < 2 || liveN > 3))\\n                    board[r][c] = 2; // turn to 0(2)\\n                \\n                else if(board[r][c] == 0 && liveN == 3)\\n                    board[r][c] = -1; // turn to 1(-1)\\n            }\\n        }\\n        \\n        for(int r = 0; r < n; r++) {\\n            for(int c = 0; c < m; c++) {\\n                if(board[r][c] == 2)\\n                    board[r][c] = 0;\\n                else if(board[r][c] == -1)\\n                    board[r][c] = 1;\\n            }\\n        }\\n        \\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180712,
                "title": "easy-and-fast-python-solution-with-detailed-explanation",
                "content": "There are quite a few excellent solutions, but I found most of them don't have clear expalnations. Here is my python solution with the logic explained in the comments.\n\n```\nclass Solution(object):\n    def gameOfLife(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: void Do not return anything, modify board in-place instead.\n        \"\"\"\n        # Apparently, need to search for the number of live neighbors around each broad[i][j].\n        # To achieve O(1) space complexity, two scans over \"board\" are required.      \n        # The key idea is to encode the board[i][j] values in the first scan, and decode in the \n        # second scan. The encoded board[i][j] values should maintain the feature of original value\n        # so that it does not affect the live neighbor search for the following elements.\n        #\n        # Notice that there are four possibilities for board[i][j] convertion:\n        #   if board[i][j] == 0, then in the next generation\n        #       board[i][j] = 1,  if numOfLiveNeighbors==3\n        #       board[i][j] = 0 otherwise\n        #   \n        #   if board[i][j] == 1, then in the next generation\n        #       board[i][j] = 1,  if numOfLiveNeighbors==2 or 3\n        #       board[i][j] = 0 otherwise\n        # Four codes (1,2,3,4) can be assigned to the four possibilities, respectively\n        # \"1\" : 1 -> 1, \"2\" : 0 -> 1, \"3\" : 1 ->0,  \"4\" : 0 -> 0\n        #\n        # Theresore, 0 can be coded to 2 or 4, depending on the next-generation value, and 1 can be         \n        # converted to 1 or 3. In the search for numOfLiveNeighbors, instead of searching for neighbors \n        # whose value is 1, we should search for neighbors with odd values (1 or 3). After encoding \n        # the original \"board\". In the second scan, if b[i][j] == 1 or 2, then b[i][j] = 1, otherwise 0.\n        def getLiveNeighbors(r, c, row, col): \n            counter = 0\n            for i in range(r-1, r+2):\n                for j in range(c-1, c+2):\n                    if (not (i==r and j==c)) and 0<=i<row and 0<=j<col and board[i][j]%2 == 1:\n                        counter += 1\n            return counter\n                    \n        row = len(board)\n        col = len(board[0])\n        for r in range(row):\n            for c in range(col):\n                LiveNeighbors = getLiveNeighbors(r,c, row, col)\n                if board[r][c] == 0:\n                    if LiveNeighbors == 3:\n                        board[r][c] = 2\n                    else:\n                        board[r][c] = 4\n                    \n                if board[r][c] == 1:\n                    if LiveNeighbors ==2 or LiveNeighbors == 3:\n                        board[r][c] = 1\n                    else:\n                        board[r][c] = 3\n        \n        for r in range(row):\n            for c in range(col):\n                board[r][c] = 1 if 1 <= board[r][c] <=2 else 0\n\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def gameOfLife(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: void Do not return anything, modify board in-place instead.\n        \"\"\"\n        # Apparently, need to search for the number of live neighbors around each broad[i][j].\n        # To achieve O(1) space complexity, two scans over \"board\" are required.      \n        # The key idea is to encode the board[i][j] values in the first scan, and decode in the \n        # second scan. The encoded board[i][j] values should maintain the feature of original value\n        # so that it does not affect the live neighbor search for the following elements.\n        #\n        # Notice that there are four possibilities for board[i][j] convertion:\n        #   if board[i][j] == 0, then in the next generation\n        #       board[i][j] = 1,  if numOfLiveNeighbors==3\n        #       board[i][j] = 0 otherwise\n        #   \n        #   if board[i][j] == 1, then in the next generation\n        #       board[i][j] = 1,  if numOfLiveNeighbors==2 or 3\n        #       board[i][j] = 0 otherwise\n        # Four codes (1,2,3,4) can be assigned to the four possibilities, respectively\n        # \"1\" : 1 -> 1, \"2\" : 0 -> 1, \"3\" : 1 ->0,  \"4\" : 0 -> 0\n        #\n        # Theresore, 0 can be coded to 2 or 4, depending on the next-generation value, and 1 can be         \n        # converted to 1 or 3. In the search for numOfLiveNeighbors, instead of searching for neighbors \n        # whose value is 1, we should search for neighbors with odd values (1 or 3). After encoding \n        # the original \"board\". In the second scan, if b[i][j] == 1 or 2, then b[i][j] = 1, otherwise 0.\n        def getLiveNeighbors(r, c, row, col): \n            counter = 0\n            for i in range(r-1, r+2):\n                for j in range(c-1, c+2):\n                    if (not (i==r and j==c)) and 0<=i<row and 0<=j<col and board[i][j]%2 == 1:\n                        counter += 1\n            return counter\n                    \n        row = len(board)\n        col = len(board[0])\n        for r in range(row):\n            for c in range(col):\n                LiveNeighbors = getLiveNeighbors(r,c, row, col)\n                if board[r][c] == 0:\n                    if LiveNeighbors == 3:\n                        board[r][c] = 2\n                    else:\n                        board[r][c] = 4\n                    \n                if board[r][c] == 1:\n                    if LiveNeighbors ==2 or LiveNeighbors == 3:\n                        board[r][c] = 1\n                    else:\n                        board[r][c] = 3\n        \n        for r in range(row):\n            for c in range(col):\n                board[r][c] = 1 if 1 <= board[r][c] <=2 else 0\n\n```",
                "codeTag": "Java"
            },
            {
                "id": 73303,
                "title": "0ms-c-solution-in-place-o-n-2",
                "content": "    const int dx[] = {0, 0, 1, 1, 1,-1,-1,-1};\\n    const int dy[] = {1,-1, 0, 1,-1, 0, 1,-1};\\n    void gameOfLife(int** board, int row, int col) {\\n    for(int i =  0; i < row; i++)\\n        for(int j = 0; j < col; j++)\\n        {\\n            int cnt = 0;\\n            for(int k = 0; k < 8; k++)\\n            {\\n                int x = i + dx[k], y = j + dy[k];\\n                if(x < 0 || y < 0 || x >= row || y >= col)\\n                    continue;\\n                cnt += (board[x][y]&1);\\n            }\\n            if((board[i][j] & 1) &&(cnt == 2 || cnt ==3) )\\n                board[i][j] |= 2;\\n            if(!(board[i][j] & 1) && cnt == 3)\\n                board[i][j] |= 2;\\n        }\\n    for(int i = 0; i < row; i++)\\n        for(int j = 0; j < col; j++)\\n            board[i][j] >>= 1;\\n    }",
                "solutionTags": [],
                "code": "    const int dx[] = {0, 0, 1, 1, 1,-1,-1,-1};\\n    const int dy[] = {1,-1, 0, 1,-1, 0, 1,-1};\\n    void gameOfLife(int** board, int row, int col) {\\n    for(int i =  0; i < row; i++)\\n        for(int j = 0; j < col; j++)\\n        {\\n            int cnt = 0;\\n            for(int k = 0; k < 8; k++)\\n            {\\n                int x = i + dx[k], y = j + dy[k];\\n                if(x < 0 || y < 0 || x >= row || y >= col)\\n                    continue;\\n                cnt += (board[x][y]&1);\\n            }\\n            if((board[i][j] & 1) &&(cnt == 2 || cnt ==3) )\\n                board[i][j] |= 2;\\n            if(!(board[i][j] & 1) && cnt == 3)\\n                board[i][j] |= 2;\\n        }\\n    for(int i = 0; i < row; i++)\\n        for(int j = 0; j < col; j++)\\n            board[i][j] >>= 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73346,
                "title": "java-1ms-solution",
                "content": "    public class Solution {\\n        public void gameOfLife(int[][] board) {\\n    \\t\\tfor(int r = 0; r < board.length; r++){\\n    \\t\\t\\tfor(int c = 0; c < board[0].length; c++){\\n    \\t\\t\\t\\tint aliveNeighbours = getAliveNeighbours(board, r, c);\\n    \\t\\t\\t\\tif(board[r][c] == 0  && aliveNeighbours == 3){\\n    \\t\\t\\t\\t\\tboard[r][c] = 2;\\n    \\t\\t\\t\\t}else if(board[r][c] == 1 && (aliveNeighbours < 2 || aliveNeighbours > 3)){\\n    \\t\\t\\t\\t\\t\\tboard[r][c] = 3;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor(int r = 0; r < board.length; r++){\\n    \\t\\t\\tfor(int c = 0; c < board[0].length; c++){\\n    \\t\\t\\t\\tboard[r][c] = (board[r][c] == 3) ? 0 : (board[r][c] == 2) ? 1: board[r][c];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tprivate int getAliveNeighbours(int board[][], int r, int c){\\n    \\t\\tint aliveNeighbours = 0;\\n    \\t\\tfor(int i = (r-1 < 0 ? 0 : r-1); i <= (r+1 > board.length-1 ? board.length-1 : r+1) ; i++){\\n    \\t\\t\\tfor(int j = (c-1 < 0 ? 0 : c-1); j <= (c+1 > board[0].length -1 ? board[0].length -1 : c+1); j++){\\n    \\t\\t\\t\\tif(i == r && j == c) continue;\\n    \\t\\t\\t\\tif(board[i][j] == 1 || board[i][j] == 3) \\n    \\t\\t\\t\\t\\taliveNeighbours++; \\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn aliveNeighbours;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void gameOfLife(int[][] board) {\\n    \\t\\tfor(int r = 0; r < board.length; r++){\\n    \\t\\t\\tfor(int c = 0; c < board[0].length; c++){\\n    \\t\\t\\t\\tint aliveNeighbours = getAliveNeighbours(board, r, c);\\n    \\t\\t\\t\\tif(board[r][c] == 0  && aliveNeighbours == 3){\\n    \\t\\t\\t\\t\\tboard[r][c] = 2;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3933616,
                "title": "c-beats-100-well-documented-code-two-approches-o-m-n-o-1-space",
                "content": "\\n---\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to update the grid according to the following rules : \\n1. Any live cell with fewer than two live neighbors dies as if caused by under-population.\\n2. Any live cell with two or three live neighbors lives on to the next generation.\\n3. Any live cell with more than three live neighbors dies, as if by over-population.\\n4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\\n\\n\\n---\\n\\n\\n# Approach 1 : Using extra space for copying the board\\n<!-- Describe your approach to solving the problem. -->\\n- In this approach, we will make a copy of original board and then modify the original board by counting the live neighbours from the copy board.\\n\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n\\n        int rows = board.size();\\n        int cols = board[0].size();\\n\\n        //copying the board to 2-D vector copy\\n        vector<vector<int>> copy(board);\\n\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                //for counting live neighbors of the element\\n                int liveNeighbors = 0; \\n                \\n                //iterating through all the neighbors of the element (inside the board and outside the board)\\n                for(int m=i-1; m<i+2; m++)\\n                {\\n                    for(int n=j-1; n<j+2; n++)\\n                    {\\n                        //we will skip the iteration when element itself is encountered\\n                        if(m==i && n==j)\\n                            continue;\\n\\n                        //checking the bounds, if indices are in range, we will check for liveNeighbors\\n                        if(m>=0 && m<rows && n>=0 && n<cols && copy[m][n] == 1)\\n                            liveNeighbors++;\\n                    }\\n                }\\n                \\n                //for live cells, if liveNeighbors are less than 2 or more than 3, cells will die and dead cells are already dead, so we need not check cell to be live or dead\\n                if(liveNeighbors < 2 || liveNeighbors > 3)\\n                    board[i][j] = 0;\\n\\n                //for dead cells, if liveNeighbors are exactly 3, it will live and live cell will also live for exactly 3 liveNeighbors\\n                else if(liveNeighbors == 3)\\n                    board[i][j] = 1;\\n\\n                //For live cells, if liveNeighbors are exactly 2, it will live but we need not update it as it is already live\\n\\n            }\\n        }\\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\nWe are using extra space for copying the board.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n# Approach 2 : Using no extra space\\n<!-- Describe your approach to solving the problem. -->\\n- In this approach, we will use two extra digits i.e. 2 and 3 for in-place modifications.\\n- Digits will be as follows : \\n`0 - Dead cell which will remain dead in next state`\\n`1 - Live cell which will die in next state`\\n`2 - Dead cell which will live in next state`\\n`3 - Live cell which will live in next state`\\n\\n\\nSo the approach is that we will iterate through each cell of the board and count the live Neighbors. On the basis of the conditions given in the question, we will modify the board accordingly.\\n- For live cells, if liveNeighbors are exactly 2 or 3, they will live in next state, so we will change them to 3 by adding 2 to its value . If liveNeighbors are less than 2 or more than 3, they will die in next state so we will leave it as 1.\\n-`It can be observed that even after modifying the value of live cell to 3, we can still know about the its current state by using board[i][j] mod 2 as 3%2=1.`\\n\\n- For dead cells, if liveNeighbors are exactly 3, they will live so we will update them to 2 by adding 2 to it. Otherwise they will remain dead in next state for rest of the cases, so we will not change it.\\n-`It can be observed that even after modifying the value of dead cell to 2, we can still know about the its current state by using board[i][j] mod 2 as 2%2=0.`\\n\\nSo we will use board[i][j] % 2 for checking its current state.\\n\\nNow we will iterate through the board and for all cells with values 0 or 1, we will set it to 0 and for values 2 and 3, we will set it to 1.\\n\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n\\n        int rows = board.size();\\n        int cols = board[0].size();\\n\\n\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                //for counting live neighbors of the element\\n                int liveNeighbors = 0;\\n\\n                 //iterating through all the neighbors of the element (inside the board and outside the board)\\n                for(int m=i-1; m<i+2; m++)\\n                {\\n                    for(int n=j-1; n<j+2; n++)\\n                    {\\n                        //we will skip the iteration when element itself is encountered\\n                        if(m==i && n==j)\\n                            continue;\\n                        \\n                        //checking the bounds, if indices are in range, we will check for liveNeighbors\\n                        if(m>=0 && m<rows && n>=0 && n<cols && board[m][n]%2 == 1)\\n                            liveNeighbors++;\\n                    }\\n                }\\n                \\n                //for live cells, doing the modifications\\n                if(board[i][j]%2 == 1)\\n                {\\n                    if(liveNeighbors == 2 || liveNeighbors == 3)\\n                        board[i][j] += 2;\\n                }\\n                //for dead cells, doing the modifications\\n                else\\n                {\\n                    if(liveNeighbors == 3)\\n                        board[i][j] += 2;\\n                }\\n            }\\n        }\\n\\n        //iterating through the board and setting the values accordingly\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                if(board[i][j] >= 2)\\n                    board[i][j] = 1;\\n\\n                else\\n                    board[i][j] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\nNo extra space is used\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n### Do upvote if it helps :)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n\\n        int rows = board.size();\\n        int cols = board[0].size();\\n\\n        //copying the board to 2-D vector copy\\n        vector<vector<int>> copy(board);\\n\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                //for counting live neighbors of the element\\n                int liveNeighbors = 0; \\n                \\n                //iterating through all the neighbors of the element (inside the board and outside the board)\\n                for(int m=i-1; m<i+2; m++)\\n                {\\n                    for(int n=j-1; n<j+2; n++)\\n                    {\\n                        //we will skip the iteration when element itself is encountered\\n                        if(m==i && n==j)\\n                            continue;\\n\\n                        //checking the bounds, if indices are in range, we will check for liveNeighbors\\n                        if(m>=0 && m<rows && n>=0 && n<cols && copy[m][n] == 1)\\n                            liveNeighbors++;\\n                    }\\n                }\\n                \\n                //for live cells, if liveNeighbors are less than 2 or more than 3, cells will die and dead cells are already dead, so we need not check cell to be live or dead\\n                if(liveNeighbors < 2 || liveNeighbors > 3)\\n                    board[i][j] = 0;\\n\\n                //for dead cells, if liveNeighbors are exactly 3, it will live and live cell will also live for exactly 3 liveNeighbors\\n                else if(liveNeighbors == 3)\\n                    board[i][j] = 1;\\n\\n                //For live cells, if liveNeighbors are exactly 2, it will live but we need not update it as it is already live\\n\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n\\n        int rows = board.size();\\n        int cols = board[0].size();\\n\\n\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                //for counting live neighbors of the element\\n                int liveNeighbors = 0;\\n\\n                 //iterating through all the neighbors of the element (inside the board and outside the board)\\n                for(int m=i-1; m<i+2; m++)\\n                {\\n                    for(int n=j-1; n<j+2; n++)\\n                    {\\n                        //we will skip the iteration when element itself is encountered\\n                        if(m==i && n==j)\\n                            continue;\\n                        \\n                        //checking the bounds, if indices are in range, we will check for liveNeighbors\\n                        if(m>=0 && m<rows && n>=0 && n<cols && board[m][n]%2 == 1)\\n                            liveNeighbors++;\\n                    }\\n                }\\n                \\n                //for live cells, doing the modifications\\n                if(board[i][j]%2 == 1)\\n                {\\n                    if(liveNeighbors == 2 || liveNeighbors == 3)\\n                        board[i][j] += 2;\\n                }\\n                //for dead cells, doing the modifications\\n                else\\n                {\\n                    if(liveNeighbors == 3)\\n                        board[i][j] += 2;\\n                }\\n            }\\n        }\\n\\n        //iterating through the board and setting the values accordingly\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                if(board[i][j] >= 2)\\n                    board[i][j] = 1;\\n\\n                else\\n                    board[i][j] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236510,
                "title": "289-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe code implements the Game of Life, a cellular automaton, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). The function takes the current state of the board as input and returns the next state.\\n\\nThe algorithm works by iterating over each cell in the board and counting the number of live neighbors. It then applies the rules of the Game of Life to determine the state of the cell in the next generation.\\n\\nThe first for loop iterates over each row in the board, and the second for loop iterates over each cell in each row. For each cell, the algorithm counts the number of live neighbors by iterating over its 8 neighbors using two nested for loops. The max() and min() functions are used to handle the boundary cells.\\n\\nThe if statements apply the rules of the Game of Life. If a live cell has 2 or 3 live neighbors, it lives on to the next generation, and if a dead cell has exactly 3 live neighbors, it becomes a live cell. The |= operator is used to set the second bit to 1, which indicates the cell\\'s state in the next generation.\\n\\nFinally, the second for loop is used to right-shift each cell\\'s value by 1 to get the next state of the board.\\n\\nThe code uses bit manipulation to store the state of each cell in the current generation and the next generation. It updates the state of the current generation by setting the second bit to 1 and uses the first bit to store the state of the next generation. The right-shift operation is used to get the next generation\\'s state by discarding the second bit.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def gameOfLife(self, board: List[List[int]]) -> None:\\n    m = len(board)\\n    n = len(board[0])\\n\\n    for i in range(m):\\n      for j in range(n):\\n        ones = 0\\n        for x in range(max(0, i - 1), min(m, i + 2)):\\n          for y in range(max(0, j - 1), min(n, j + 2)):\\n            ones += board[x][y] & 1\\n        # Any live cell with 2 or 3 live neighbors\\n        # lives on to the next generation\\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\\n          board[i][j] |= 0b10\\n        # Any dead cell with exactly 3 live neighbors\\n        # becomes a live cell, as if by reproduction\\n        if board[i][j] == 0 and ones == 3:\\n          board[i][j] |= 0b10\\n\\n    for i in range(m):\\n      for j in range(n):\\n        board[i][j] >>= 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n  def gameOfLife(self, board: List[List[int]]) -> None:\\n    m = len(board)\\n    n = len(board[0])\\n\\n    for i in range(m):\\n      for j in range(n):\\n        ones = 0\\n        for x in range(max(0, i - 1), min(m, i + 2)):\\n          for y in range(max(0, j - 1), min(n, j + 2)):\\n            ones += board[x][y] & 1\\n        # Any live cell with 2 or 3 live neighbors\\n        # lives on to the next generation\\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\\n          board[i][j] |= 0b10\\n        # Any dead cell with exactly 3 live neighbors\\n        # becomes a live cell, as if by reproduction\\n        if board[i][j] == 0 and ones == 3:\\n          board[i][j] |= 0b10\\n\\n    for i in range(m):\\n      for j in range(n):\\n        board[i][j] >>= 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127108,
                "title": "easy-c-solution-brute-force-optimize-in-place",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using Two approach.\\n\\n1. Using two nested loops (Brute Force).\\n2. Using two nested loops - In-place (optimize).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity provided in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity provided in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(n*m), where n is the number of row and m is number of column of board. Here two nested \\n    loops create time complexity\\n    Space Complexity : O(n*m). visited matrix space.\\n\\n    Using Matrix.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    int checkAllDirection(vector<vector<int>>& board, int row, int col, int n, int m, \\n    vector<vector<int>>& visited, int dxdy[][2]){\\n        int count = 0;\\n        \\n        for(int i=0; i<8; i++){\\n            int newrow = row + dxdy[i][0];\\n            int newcol = col + dxdy[i][1];\\n\\n            if(newrow>=0 && newcol>=0 && newrow<n && newcol<m && board[newrow][newcol] == 1){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> visited = board;\\n        int dxdy[8][2] = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int count = checkAllDirection(board, i, j, n, m, visited, dxdy);\\n                if(count < 2 && board[i][j] == 1){\\n                    visited[i][j] = 0;\\n                }\\n                else if((count == 2 || count == 3) && board[i][j] == 1){\\n                    visited[i][j] = 1;\\n                }\\n                else if(count > 3 && board[i][j] == 1){\\n                    visited[i][j] = 0;\\n                }\\n                else if(count == 3 && board[i][j] == 0){\\n                    visited[i][j] = 1;\\n                }\\n            }\\n        }\\n        board = visited;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(n*m) where n is the number of row and m is number of column of board. Here two nested\\n    loops create time complexity.\\n    Space Complexity : O(1) constant space (In-place).\\n\\n    Using matrix.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    int checkAllDirection(vector<vector<int>>& board, int row, int col, int n, int m, \\n    vector<vector<int>>&  visited, int dxdy[][2]){\\n        int count = 0;\\n        \\n        for(int i=0; i<8; i++){\\n            int newrow = row + dxdy[i][0];\\n            int newcol = col + dxdy[i][1];\\n\\n            if(newrow>=0 && newcol>=0 && newrow<n && newcol<m && board[newrow][newcol] == 1){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        int dxdy[8][2] = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int live = 0;\\n                for(int k=0; k<8; k++){\\n                    int x = i + dxdy[k][0];\\n                    int y = j + dxdy[k][1];\\n\\n                    if(x<0 || y<0 || x>=n || y>=m){\\n                        continue;\\n                    }\\n                    if(board[x][y] & 1){\\n                        live++;\\n                    }\\n                }\\n\\n                // for dead cell\\n                if(board[i][j] == 0 && live == 3){\\n                    board[i][j] = 2;\\n                }\\n                else if(board[i][j] == 1 && (live == 2 || live == 3)){\\n                    board[i][j] = 3;\\n                }\\n                else if(board[i][j] == 1 && (live < 2 || live > 3)){\\n                    board[i][j] = 1;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                board[i][j] >>= 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(n*m), where n is the number of row and m is number of column of board. Here two nested \\n    loops create time complexity\\n    Space Complexity : O(n*m). visited matrix space.\\n\\n    Using Matrix.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    int checkAllDirection(vector<vector<int>>& board, int row, int col, int n, int m, \\n    vector<vector<int>>& visited, int dxdy[][2]){\\n        int count = 0;\\n        \\n        for(int i=0; i<8; i++){\\n            int newrow = row + dxdy[i][0];\\n            int newcol = col + dxdy[i][1];\\n\\n            if(newrow>=0 && newcol>=0 && newrow<n && newcol<m && board[newrow][newcol] == 1){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> visited = board;\\n        int dxdy[8][2] = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int count = checkAllDirection(board, i, j, n, m, visited, dxdy);\\n                if(count < 2 && board[i][j] == 1){\\n                    visited[i][j] = 0;\\n                }\\n                else if((count == 2 || count == 3) && board[i][j] == 1){\\n                    visited[i][j] = 1;\\n                }\\n                else if(count > 3 && board[i][j] == 1){\\n                    visited[i][j] = 0;\\n                }\\n                else if(count == 3 && board[i][j] == 0){\\n                    visited[i][j] = 1;\\n                }\\n            }\\n        }\\n        board = visited;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(n*m) where n is the number of row and m is number of column of board. Here two nested\\n    loops create time complexity.\\n    Space Complexity : O(1) constant space (In-place).\\n\\n    Using matrix.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    int checkAllDirection(vector<vector<int>>& board, int row, int col, int n, int m, \\n    vector<vector<int>>&  visited, int dxdy[][2]){\\n        int count = 0;\\n        \\n        for(int i=0; i<8; i++){\\n            int newrow = row + dxdy[i][0];\\n            int newcol = col + dxdy[i][1];\\n\\n            if(newrow>=0 && newcol>=0 && newrow<n && newcol<m && board[newrow][newcol] == 1){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        int dxdy[8][2] = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int live = 0;\\n                for(int k=0; k<8; k++){\\n                    int x = i + dxdy[k][0];\\n                    int y = j + dxdy[k][1];\\n\\n                    if(x<0 || y<0 || x>=n || y>=m){\\n                        continue;\\n                    }\\n                    if(board[x][y] & 1){\\n                        live++;\\n                    }\\n                }\\n\\n                // for dead cell\\n                if(board[i][j] == 0 && live == 3){\\n                    board[i][j] = 2;\\n                }\\n                else if(board[i][j] == 1 && (live == 2 || live == 3)){\\n                    board[i][j] = 3;\\n                }\\n                else if(board[i][j] == 1 && (live < 2 || live > 3)){\\n                    board[i][j] = 1;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                board[i][j] >>= 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452500,
                "title": "c-2-solutions-o-1-space-direction-array-follow-up-part-also",
                "content": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int arr[8][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n        int m = board.size();\\n        int n = board[0].size();\\n        vector<vector<int>> nums(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int count=0;\\n                for(int k=0;k<8;k++){\\n                    int row = i+arr[k][0];\\n                    int col = j+arr[k][1];\\n                    if(row>=0&&col>=0&&row<m&&col<n&&board[row][col]==1)count++;\\n                }\\n                if(board[i][j]==1){\\n                    if(count==2||count==3)nums[i][j] = 1;\\n                }else{\\n                    if(count==3)nums[i][j] = 1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j] = nums[i][j];\\n            }\\n        }\\n        \\n    }\\n};\\n```\\n```\\nvoid gameOfLife(vector<vector<int>>& board) {\\n        int arr[8][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n        int m = board.size();\\n        int n = board[0].size();\\n        //vector<vector<int>> nums(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int count=0;\\n                for(int k=0;k<8;k++){\\n                    int row = i+arr[k][0];\\n                    int col = j+arr[k][1];\\n                    if(row>=0&&col>=0&&row<m&&col<n&&(board[row][col]==1||board[row][col]==2))count++;\\n                }\\n                if(board[i][j]==1){\\n                    if(count<2||count>3)board[i][j] = 2;\\n                }else{\\n                    if(count==3)board[i][j] = 3;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]%=2;\\n            }\\n        }\\n        \\n    }\\n```\\n```\\n//follow up -> 2\\n//for the follow up 2 -> keep only one row at a time and process it  \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int arr[8][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n        int m = board.size();\\n        int n = board[0].size();\\n        vector<vector<int>> nums(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int count=0;\\n                for(int k=0;k<8;k++){\\n                    int row = i+arr[k][0];\\n                    int col = j+arr[k][1];\\n                    if(row>=0&&col>=0&&row<m&&col<n&&board[row][col]==1)count++;\\n                }\\n                if(board[i][j]==1){\\n                    if(count==2||count==3)nums[i][j] = 1;\\n                }else{\\n                    if(count==3)nums[i][j] = 1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j] = nums[i][j];\\n            }\\n        }\\n        \\n    }\\n};\\n```\n```\\nvoid gameOfLife(vector<vector<int>>& board) {\\n        int arr[8][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n        int m = board.size();\\n        int n = board[0].size();\\n        //vector<vector<int>> nums(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int count=0;\\n                for(int k=0;k<8;k++){\\n                    int row = i+arr[k][0];\\n                    int col = j+arr[k][1];\\n                    if(row>=0&&col>=0&&row<m&&col<n&&(board[row][col]==1||board[row][col]==2))count++;\\n                }\\n                if(board[i][j]==1){\\n                    if(count<2||count>3)board[i][j] = 2;\\n                }else{\\n                    if(count==3)board[i][j] = 3;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]%=2;\\n            }\\n        }\\n        \\n    }\\n```\n```\\n//follow up -> 2\\n//for the follow up 2 -> keep only one row at a time and process it  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939986,
                "title": "0ms-beats-100-easy-clean-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        \\n        int row=board.size();\\n        int col=board[0].size();\\n        \\n        int dx[8]={-1,-1,-1,0,0,1,1,1};    // These are the eight directions\\n        int dy[8]={-1,0,1,-1,1,-1,0,1};\\n        \\n       vector<vector<int>>dp(row,vector<int>(col));   // To store result, don\\'t confuse with name dp\\uD83E\\uDD23\\uD83E\\uDD23\\n        \\n        for(int i=0;i<row;i++)                      // for Every postion\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                 int count=0;\\n                 for(int k=0;k<8;k++)            // Check its adjacent 8 directions which have live neighbors \\n                 {\\n                     int newi=i+dx[k];\\n                     int newj=j+dy[k];\\n                     \\n                     if(newi>=0 && newj>=0 && newi<row && newj<col && board[newi][newj]==1)\\n                         count++;\\n                     \\n                     \\n                 }\\n                if(board[i][j]==1 && (count<2 ||count>3)) dp[i][j]=0;         // Set Answers acc. to given condition\\n                else if(board[i][j]==1 && (count ==2 || count==3)) dp[i][j]=1;\\n                else if(board[i][j]==0 && count==3 ) dp[i][j]=1;\\n                else dp[i][j]=0;\\n                 \\n            }\\n        }\\n        board=dp;      // Store result in original grid\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        \\n        int row=board.size();\\n        int col=board[0].size();\\n        \\n        int dx[8]={-1,-1,-1,0,0,1,1,1};    // These are the eight directions\\n        int dy[8]={-1,0,1,-1,1,-1,0,1};\\n        \\n       vector<vector<int>>dp(row,vector<int>(col));   // To store result, don\\'t confuse with name dp\\uD83E\\uDD23\\uD83E\\uDD23\\n        \\n        for(int i=0;i<row;i++)                      // for Every postion\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                 int count=0;\\n                 for(int k=0;k<8;k++)            // Check its adjacent 8 directions which have live neighbors \\n                 {\\n                     int newi=i+dx[k];\\n                     int newj=j+dy[k];\\n                     \\n                     if(newi>=0 && newj>=0 && newi<row && newj<col && board[newi][newj]==1)\\n                         count++;\\n                     \\n                     \\n                 }\\n                if(board[i][j]==1 && (count<2 ||count>3)) dp[i][j]=0;         // Set Answers acc. to given condition\\n                else if(board[i][j]==1 && (count ==2 || count==3)) dp[i][j]=1;\\n                else if(board[i][j]==0 && count==3 ) dp[i][j]=1;\\n                else dp[i][j]=0;\\n                 \\n            }\\n        }\\n        board=dp;      // Store result in original grid\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939638,
                "title": "c-o-1-space-complexity-with-image-explanation-beats-100-percent",
                "content": "Instead of using extra space, we edit the same matrix as follows:\\n\\nIf a living cell turns dead we remark it as -1: 1 -> 0 == -1\\nIf a dead cell turns alive we remark it as +10: 0 -> 1 == +10\\n\\nAnd then at last we run a for loop through matrix and change +10 to 1 and -1 to 0.\\nVector neibhours is used to access neighbouring elements\\n\\nFollowing image explains the change in matrix:\\n\\n![image](https://assets.leetcode.com/users/images/d2c73aa1-455d-47a8-9edd-1a283b0ba78c_1649771345.541082.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    void Live_or_Dead(vector<vector<int>> &board, int row, int col, int m, int n, vector<pair<int, int>> &neighbours) {\\n        int count = 0;\\n        \\n        for(auto it: neighbours) {\\n            int x = it.first + row;             \\n            int y = it.second + col;\\n            \\n            if(x >= 0 && y >= 0 && x < m && y < n) {\\n                if(board[x][y] == 1 || board[x][y] == -1)\\n                    count++;\\n            }\\n        }\\n                \\n        if(board[row][col] == 0) {\\n            if(count == 3)\\n                board[row][col] = 10; // 10 corresponds to a dead cell who has become alive\\n        }\\n        else {\\n            if(count < 2 || count > 3)\\n                board[row][col] = -1;\\n            else\\n                board[row][col] = 1;\\n        }\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        vector<pair<int, int>> neighbours {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                Live_or_Dead(board, i, j, m, n, neighbours);\\n            }\\n        }\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(board[i][j] == -1)\\n                    board[i][j] = 0;\\n                else if(board[i][j] == 10)\\n                    board[i][j] = 1;\\n            }\\n        }\\n        \\n    }    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void Live_or_Dead(vector<vector<int>> &board, int row, int col, int m, int n, vector<pair<int, int>> &neighbours) {\\n        int count = 0;\\n        \\n        for(auto it: neighbours) {\\n            int x = it.first + row;             \\n            int y = it.second + col;\\n            \\n            if(x >= 0 && y >= 0 && x < m && y < n) {\\n                if(board[x][y] == 1 || board[x][y] == -1)\\n                    count++;\\n            }\\n        }\\n                \\n        if(board[row][col] == 0) {\\n            if(count == 3)\\n                board[row][col] = 10; // 10 corresponds to a dead cell who has become alive\\n        }\\n        else {\\n            if(count < 2 || count > 3)\\n                board[row][col] = -1;\\n            else\\n                board[row][col] = 1;\\n        }\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        vector<pair<int, int>> neighbours {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                Live_or_Dead(board, i, j, m, n, neighbours);\\n            }\\n        }\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(board[i][j] == -1)\\n                    board[i][j] = 0;\\n                else if(board[i][j] == 10)\\n                    board[i][j] = 1;\\n            }\\n        }\\n        \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939127,
                "title": "0ms-faster-than-100-o-1-space-o-mn-time-in-place-stored-two-values-at-1-place",
                "content": "##### Concept\\n```\\n## Use the concept of storing two values at one place\\n## let\\'s denote old value by \\'a\\' and new value by \\'b\\'\\n## so represent integer by a+c*b\\n## where c is greater than a and b\\n\\n## To extract old value (a)\\n(a+c*b) % c  -> a\\n\\n## To extract new value (b)\\n(a+c*b)/ c  -> b\\n```\\n\\n\\n##### C++\\n```\\nint work(vector<vector<int>>& board, int r , int c){\\n        int m=board.size(),n=board[0].size(),cnt=0;\\n        for(int i=-1;i<=1;i++)\\n            for(int j=-1;j<=1;j++){\\n                if(i==0 and j==0) continue;\\n                int newr=r+i,newc=c+j;\\n                if(newr<0 or newr>=m or newc<0 or newc>=n) continue;\\n                cnt+=(board[newr][newc]%2);\\n            }\\n        \\n        if(board[r][c]==1) return cnt==2 or cnt==3;\\n        else return cnt==3;\\n       \\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        int m=board.size(),n=board[0].size();\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                int old=board[i][j];\\n                int newval=work(board,i,j);\\n                board[i][j]=old+2*newval;\\n            }\\n        \\n        for(auto &r:board)\\n            for(auto &ele:r) ele=ele/2;\\n    }\\n````",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n## Use the concept of storing two values at one place\\n## let\\'s denote old value by \\'a\\' and new value by \\'b\\'\\n## so represent integer by a+c*b\\n## where c is greater than a and b\\n\\n## To extract old value (a)\\n(a+c*b) % c  -> a\\n\\n## To extract new value (b)\\n(a+c*b)/ c  -> b\\n```\n```\\nint work(vector<vector<int>>& board, int r , int c){\\n        int m=board.size(),n=board[0].size(),cnt=0;\\n        for(int i=-1;i<=1;i++)\\n            for(int j=-1;j<=1;j++){\\n                if(i==0 and j==0) continue;\\n                int newr=r+i,newc=c+j;\\n                if(newr<0 or newr>=m or newc<0 or newc>=n) continue;\\n                cnt+=(board[newr][newc]%2);\\n            }\\n        \\n        if(board[r][c]==1) return cnt==2 or cnt==3;\\n        else return cnt==3;\\n       \\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        int m=board.size(),n=board[0].size();\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                int old=board[i][j];\\n                int newval=work(board,i,j);\\n                board[i][j]=old+2*newval;\\n            }\\n        \\n        for(auto &r:board)\\n            for(auto &ele:r) ele=ele/2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937802,
                "title": "c-beats-100-in-place",
                "content": "```\\n    int countNeighbors(const vector<vector<int>>& board, int r, int c) {\\n        bool up = r > 0;\\n        bool down = r < board.size() - 1;\\n        bool left = c > 0;\\n        bool right = c < board[0].size() - 1;\\n        int count = 0;\\n        \\n        if (up) {\\n            count += board[r - 1][c] & 1;\\n            if (left) {\\n                count += board[r - 1][c - 1] & 1;\\n            }\\n            if (right) {\\n                count += board[r - 1][c + 1] & 1;\\n            }\\n        }\\n        if (down) {\\n            count += board[r + 1][c] & 1;\\n            if (left) {\\n                count += board[r + 1][c - 1] & 1;\\n            }\\n            if (right) {\\n                count += board[r + 1][c + 1] & 1;\\n            }\\n        }\\n        if (left) {\\n            count += board[r][c - 1] & 1;\\n        }\\n        if (right) {\\n            count += board[r][c + 1] & 1;\\n        }\\n        return count;\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        for (int i = 0; i < board.size(); i += 1) {\\n            for (int j = 0; j < board[0].size(); j += 1) {\\n                int living_neighbors = countNeighbors(board, i, j);\\n                if (board[i][j] == 1 && (living_neighbors == 2 || living_neighbors == 3)) {\\n                    board[i][j] += 2;\\n                } else if (board[i][j] == 0 && living_neighbors == 3) {\\n                    board[i][j] += 2;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < board.size(); i += 1) {\\n            for (int j = 0; j < board[0].size(); j += 1) {\\n                if (board[i][j] & 2) {\\n                    board[i][j] = 1;\\n                } else {\\n                    board[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```\\nUse the first bit (ones) to represent whether the cell is currently alive. Use the second bit (twos) to represent whether the cell will be alive next round.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int countNeighbors(const vector<vector<int>>& board, int r, int c) {\\n        bool up = r > 0;\\n        bool down = r < board.size() - 1;\\n        bool left = c > 0;\\n        bool right = c < board[0].size() - 1;\\n        int count = 0;\\n        \\n        if (up) {\\n            count += board[r - 1][c] & 1;\\n            if (left) {\\n                count += board[r - 1][c - 1] & 1;\\n            }\\n            if (right) {\\n                count += board[r - 1][c + 1] & 1;\\n            }\\n        }\\n        if (down) {\\n            count += board[r + 1][c] & 1;\\n            if (left) {\\n                count += board[r + 1][c - 1] & 1;\\n            }\\n            if (right) {\\n                count += board[r + 1][c + 1] & 1;\\n            }\\n        }\\n        if (left) {\\n            count += board[r][c - 1] & 1;\\n        }\\n        if (right) {\\n            count += board[r][c + 1] & 1;\\n        }\\n        return count;\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        for (int i = 0; i < board.size(); i += 1) {\\n            for (int j = 0; j < board[0].size(); j += 1) {\\n                int living_neighbors = countNeighbors(board, i, j);\\n                if (board[i][j] == 1 && (living_neighbors == 2 || living_neighbors == 3)) {\\n                    board[i][j] += 2;\\n                } else if (board[i][j] == 0 && living_neighbors == 3) {\\n                    board[i][j] += 2;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < board.size(); i += 1) {\\n            for (int j = 0; j < board[0].size(); j += 1) {\\n                if (board[i][j] & 2) {\\n                    board[i][j] = 1;\\n                } else {\\n                    board[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 993721,
                "title": "python-easy-explanation-blackboard",
                "content": "* **Simple and easy python3 solution**\\n* **The approach is well explained in the below image**\\n\\n![image](https://assets.leetcode.com/users/images/39e33672-382a-45d0-b007-8d2aaa09fc49_1609327530.110837.png)\\n\\n\\n```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m, n, livecells, ans = len(board), len(board[0]), 0, []\\n        modified_board = collections.deque([collections.deque(x) for x in board])\\n        for rows in modified_board:\\n            rows.appendleft(0)\\n            rows.append(0)\\n        modified_board.appendleft([0] * (n + 2))\\n        modified_board.append([0] * (n + 2))\\n        for i in range(1, m + 1):\\n            temp = []\\n            for j in range(1, n + 1):\\n                livecells = 0\\n                for k in range(i - 1, i + 2):\\n                    for l in range(j - 1, j + 2):\\n                        if modified_board[k][l]:\\n                            livecells += 1\\n                if modified_board[i][j]:\\n                    livecells -= 1\\n                    if livecells < 2:\\n                        temp.append(0)\\n                    elif 2 <= livecells <= 3:\\n                        temp.append(1)\\n                    else:\\n                        temp.append(0)\\n                else:\\n                    if livecells == 3:\\n                        temp.append(1)\\n                    else:\\n                        temp.append(0)\\n            ans.append(temp)\\n        for i in range(m):\\n            for j in range(n):\\n                board[i][j] = ans[i][j]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m, n, livecells, ans = len(board), len(board[0]), 0, []\\n        modified_board = collections.deque([collections.deque(x) for x in board])\\n        for rows in modified_board:\\n            rows.appendleft(0)\\n            rows.append(0)\\n        modified_board.appendleft([0] * (n + 2))\\n        modified_board.append([0] * (n + 2))\\n        for i in range(1, m + 1):\\n            temp = []\\n            for j in range(1, n + 1):\\n                livecells = 0\\n                for k in range(i - 1, i + 2):\\n                    for l in range(j - 1, j + 2):\\n                        if modified_board[k][l]:\\n                            livecells += 1\\n                if modified_board[i][j]:\\n                    livecells -= 1\\n                    if livecells < 2:\\n                        temp.append(0)\\n                    elif 2 <= livecells <= 3:\\n                        temp.append(1)\\n                    else:\\n                        temp.append(0)\\n                else:\\n                    if livecells == 3:\\n                        temp.append(1)\\n                    else:\\n                        temp.append(0)\\n            ans.append(temp)\\n        for i in range(m):\\n            for j in range(n):\\n                board[i][j] = ans[i][j]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 934891,
                "title": "well-commented-readable-javascript-o-n-m-time-space-solution",
                "content": "The O(1) space solution in the Solutions tab is great and understandable. Just wanted to share my non-constant space solution that can easily be modified into the O(1) one!\\n\\n```\\nvar gameOfLife = function(board) {\\n  const hash = {};\\n  const directions = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];\\n\\n  for (let r = 0; r < board.length; r++) {\\n    for (let c = 0; c < board[r].length; c++) {\\n      let numLiveNeighbors = 0;\\n\\t  \\n\\t  // Having a directions array keeps things a little neater\\n      for (let [x, y] of directions) {\\n\\t\\t// Make sure we don\\'t go out of bounds\\n        if (r + x >= 0 && r + x < board.length && c + y >= 0 && c + y < board[r].length) {\\n\\t\\t  // If the neighbor is alive, count it\\n          if (board[r + x][c + y] === 1) {\\n            numLiveNeighbors++;\\n          }\\n        }\\n      }\\n\\t  // For each cell, store its live neighbors count\\n      hash[[r, c].toString()] = numLiveNeighbors;\\n    }\\n  }\\n\\n  for (let r = 0; r < board.length; r++) {\\n    for (let c = 0; c < board[r].length; c++) {\\n      // Retrieve live neighbor count for this cell\\n      const storedLiveNeighbors = hash[[r, c].toString()];\\n\\n      if (board[r][c] === 1) {\\n        // Kill if underpopulated or overpopulated\\n        if (storedLiveNeighbors < 2 || storedLiveNeighbors > 3) {\\n          board[r][c] = 0;\\n        }\\n      } else { // Must be a 0\\n        // Bring to life if it can be reproduced\\n        if (storedLiveNeighbors === 3) {\\n          board[r][c] = 1;\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar gameOfLife = function(board) {\\n  const hash = {};\\n  const directions = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];\\n\\n  for (let r = 0; r < board.length; r++) {\\n    for (let c = 0; c < board[r].length; c++) {\\n      let numLiveNeighbors = 0;\\n\\t  \\n\\t  // Having a directions array keeps things a little neater\\n      for (let [x, y] of directions) {\\n\\t\\t// Make sure we don\\'t go out of bounds\\n        if (r + x >= 0 && r + x < board.length && c + y >= 0 && c + y < board[r].length) {\\n\\t\\t  // If the neighbor is alive, count it\\n          if (board[r + x][c + y] === 1) {\\n            numLiveNeighbors++;\\n          }\\n        }\\n      }\\n\\t  // For each cell, store its live neighbors count\\n      hash[[r, c].toString()] = numLiveNeighbors;\\n    }\\n  }\\n\\n  for (let r = 0; r < board.length; r++) {\\n    for (let c = 0; c < board[r].length; c++) {\\n      // Retrieve live neighbor count for this cell\\n      const storedLiveNeighbors = hash[[r, c].toString()];\\n\\n      if (board[r][c] === 1) {\\n        // Kill if underpopulated or overpopulated\\n        if (storedLiveNeighbors < 2 || storedLiveNeighbors > 3) {\\n          board[r][c] = 0;\\n        }\\n      } else { // Must be a 0\\n        // Bring to life if it can be reproduced\\n        if (storedLiveNeighbors === 3) {\\n          board[r][c] = 1;\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678852,
                "title": "javascript-easy-to-understand-short-code",
                "content": "```\\nvar gameOfLife = function(board) {\\n    const clen = board[0].length\\n    const rlen = board.length\\n\\t// deep clone\\n    const oldBoard = JSON.parse(JSON.stringify(board))\\n\\n    for (let r=0; r < rlen; r+=1) {\\n        for (let c=0; c < clen; c+=1){\\n            const directions = [[r-1,c],[r-1,c-1],[r-1,c+1],[r+1,c-1],[r+1,c],[r,c-1],[r+1,c+1],[r,c+1]]\\n            let liveCount = 0\\n\\t\\t\\t// check neighbours\\n            for (const loc of directions) {\\n                const [rn, cn] = loc\\n                if (oldBoard[rn])\\n                    if(oldBoard[rn][cn] === 1) liveCount +=1\\n            }\\n\\t\\t\\t// update cell\\n            if (oldBoard[r][c] === 1 && liveCount < 2) board[r][c] = 0\\n            else if (oldBoard[r][c] === 1 && liveCount > 3) board[r][c] = 0  \\n            else if (oldBoard[r][c] === 0 && liveCount === 3) board[r][c] = 1\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar gameOfLife = function(board) {\\n    const clen = board[0].length\\n    const rlen = board.length\\n\\t// deep clone\\n    const oldBoard = JSON.parse(JSON.stringify(board))\\n\\n    for (let r=0; r < rlen; r+=1) {\\n        for (let c=0; c < clen; c+=1){\\n            const directions = [[r-1,c],[r-1,c-1],[r-1,c+1],[r+1,c-1],[r+1,c],[r,c-1],[r+1,c+1],[r,c+1]]\\n            let liveCount = 0\\n\\t\\t\\t// check neighbours\\n            for (const loc of directions) {\\n                const [rn, cn] = loc\\n                if (oldBoard[rn])\\n                    if(oldBoard[rn][cn] === 1) liveCount +=1\\n            }\\n\\t\\t\\t// update cell\\n            if (oldBoard[r][c] === 1 && liveCount < 2) board[r][c] = 0\\n            else if (oldBoard[r][c] === 1 && liveCount > 3) board[r][c] = 0  \\n            else if (oldBoard[r][c] === 0 && liveCount === 3) board[r][c] = 1\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 440197,
                "title": "test-cases",
                "content": "```\\n[]\\n[[]]\\n[[1]]\\n[[0]]\\n[[1]]\\n[[1],[1]]\\n[[1],[1],[1]]\\n[[0,0,0],[1,1,1],[0,0,0]]\\n[[1,0,1],[0,1,0],[1,0,1]]\\n[[0,0,0],[0,0,0],[0,0,0]]\\n[[0,0,0],[0,1,0],[0,0,0]]\\n[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\\n[[1,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\n[[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\n[[0,0,0,1],[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\n[[0,0,0,0],[1,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\n[[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\n[[0,0,0,0],[0,0,1,0],[0,1,1,0],[0,0,0,0]]\\n[[0,0,0,0],[0,1,0,0],[0,1,1,0],[0,0,0,0]]\\n[[0,0,0,0],[0,1,1,0],[0,0,1,0],[0,0,0,0]]\\n[[0,0,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]]\\n[[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0],[0,0,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0],[0,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,0,1,0],[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]]\\n[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\\n[[1,0,0,1,0,0,1,0,0,1]]\\n[[1],[0],[0],[1],[0],[0],[1],[0],[0],[1]]\\n[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]\\n[[0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]\\n[[0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0]]\\n[[1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0]]\\n[[1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,1],[1,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,1,1],[1,0,1,0,1,0,0,1,1,0,1,0,0,0,0,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1],[1,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,0,1,0,0,1,0,1,1,0,1,0,1,0,0,0,0,0]]\\n```",
                "solutionTags": [],
                "code": "```\\n[]\\n[[]]\\n[[1]]\\n[[0]]\\n[[1]]\\n[[1],[1]]\\n[[1],[1],[1]]\\n[[0,0,0],[1,1,1],[0,0,0]]\\n[[1,0,1],[0,1,0],[1,0,1]]\\n[[0,0,0],[0,0,0],[0,0,0]]\\n[[0,0,0],[0,1,0],[0,0,0]]\\n[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\\n[[1,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\n[[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\n[[0,0,0,1],[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\n[[0,0,0,0],[1,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\n[[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\n[[0,0,0,0],[0,0,1,0],[0,1,1,0],[0,0,0,0]]\\n[[0,0,0,0],[0,1,0,0],[0,1,1,0],[0,0,0,0]]\\n[[0,0,0,0],[0,1,1,0],[0,0,1,0],[0,0,0,0]]\\n[[0,0,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]]\\n[[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0],[0,0,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0],[0,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,0,1,0],[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]]\\n[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\\n[[1,0,0,1,0,0,1,0,0,1]]\\n[[1],[0],[0],[1],[0],[0],[1],[0],[0],[1]]\\n[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]\\n[[0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]\\n[[0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0]]\\n[[1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0]]\\n[[1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,1],[1,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,1,1],[1,0,1,0,1,0,0,1,1,0,1,0,0,0,0,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1],[1,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,0,1,0,0,1,0,1,1,0,1,0,1,0,0,0,0,0]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 210030,
                "title": "beats-100-java-solutions-without-tricky-bit-manipulation-in-place-and-o-1-memory",
                "content": "Idea is to store the current state plus the next state or the number of neighbors in place.\\nNumber of neighbors will be in range 0 to 8. So we can multiply that by 10 and add the current state to it. So **%10** of that will give out the current state and **/10** will reveal the number of neighbors.\\n```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int iL = board.length;\\n        int jL = board.length>0? board[0].length:0;\\n        for(int i=0; i< board.length; i++)\\n            for(int j=0; j< board[0].length; j++) // Counting all possible neighbors\\n            {\\n                board[i][j]= (((i!=0?board[i-1][j]:0)+(i!=0 && j!=jL-1?board[i-1][j+1]:0)+(j!=jL-1?board[i][j+1]:0) + (i!=iL-1 && j!=jL-1?board[i+1][j+1]:0)+(i!=iL-1?board[i+1][j]:0)+(i!=iL-1 && j!=0?board[i+1][j-1]:0)+(j!=0?board[i][j-1]:0)+(i!=0 && j!=0?board[i-1][j-1]:0))%10)*10+ board[i][j];\\n            }\\n        \\n        for(int i=0; i< board.length; i++)\\n            for(int j=0; j< board[0].length; j++)\\n            {\\n                board[i][j]= updateState(board[i][j]%10, board[i][j]/10);\\n            }\\n    }\\n    private int updateState(int cS, int n) // deriving next state based on neighbor count\\n    {\\n        int oS = 1;\\n        if(cS == 1)\\n        {\\n         if(n<2 || n > 3)\\n             oS = 0;\\n        }\\n        else\\n        {\\n            if(n !=3)\\n                oS=0;\\n        }\\n        return oS;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int iL = board.length;\\n        int jL = board.length>0? board[0].length:0;\\n        for(int i=0; i< board.length; i++)\\n            for(int j=0; j< board[0].length; j++) // Counting all possible neighbors\\n            {\\n                board[i][j]= (((i!=0?board[i-1][j]:0)+(i!=0 && j!=jL-1?board[i-1][j+1]:0)+(j!=jL-1?board[i][j+1]:0) + (i!=iL-1 && j!=jL-1?board[i+1][j+1]:0)+(i!=iL-1?board[i+1][j]:0)+(i!=iL-1 && j!=0?board[i+1][j-1]:0)+(j!=0?board[i][j-1]:0)+(i!=0 && j!=0?board[i-1][j-1]:0))%10)*10+ board[i][j];\\n            }\\n        \\n        for(int i=0; i< board.length; i++)\\n            for(int j=0; j< board[0].length; j++)\\n            {\\n                board[i][j]= updateState(board[i][j]%10, board[i][j]/10);\\n            }\\n    }\\n    private int updateState(int cS, int n) // deriving next state based on neighbor count\\n    {\\n        int oS = 1;\\n        if(cS == 1)\\n        {\\n         if(n<2 || n > 3)\\n             oS = 0;\\n        }\\n        else\\n        {\\n            if(n !=3)\\n                oS=0;\\n        }\\n        return oS;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73370,
                "title": "python-solution-o-mn-time-o-1-space",
                "content": "The idea is to use the second bit to store the updated state for each cell during the updating process. When the updating is finished, move 2nd bit to the first bit. Running time is about 40+ ms.\\n\\n    class Solution(object):\\n        def gameOfLife(self, board):\\n            \"\"\"\\n            :type board: List[List[int]]\\n            :rtype: void Do not return anything, modify board in-place instead.\\n            \"\"\"\\n            if len(board) == 0 or len(board[0]) == 0:\\n                return\\n            \\n            # calculate the number of live neighbors for cell (i,j)\\n            def findLiveNeighbor(board, i, j):\\n                count = 0\\n                for a,b in [(i-1,j-1),(i-1,j),(i-1,j+1),(i+1,j-1),(i+1,j),(i+1,j+1),(i,j-1),(i,j+1)]:\\n                    if a >= 0 and a < len(board) and b >= 0 and b < len(board[0]) and board[a][b] % 2 == 1:\\n                        count += 1\\n                return count        \\n                \\n            for i in xrange(len(board)):\\n                for j in xrange(len(board[0])):\\n                    liveNeighbors = findLiveNeighbor(board, i, j)\\n                    if board[i][j] == 0 and liveNeighbors == 3 or board[i][j] == 1 and liveNeighbors in [2,3]:\\n                            board[i][j] |= 2\\n            for i in xrange(len(board)):\\n                for j in xrange(len(board[0])):\\n                    board[i][j] >>= 1\\n            return",
                "solutionTags": [],
                "code": "The idea is to use the second bit to store the updated state for each cell during the updating process. When the updating is finished, move 2nd bit to the first bit. Running time is about 40+ ms.\\n\\n    class Solution(object):\\n        def gameOfLife(self, board):\\n            \"\"\"\\n            :type board: List[List[int]]\\n            :rtype: void Do not return anything, modify board in-place instead.\\n            \"\"\"\\n            if len(board) == 0 or len(board[0]) == 0:\\n                return\\n            \\n            # calculate the number of live neighbors for cell (i,j)\\n            def findLiveNeighbor(board, i, j):\\n                count = 0\\n                for a,b in [(i-1,j-1),(i-1,j),(i-1,j+1),(i+1,j-1),(i+1,j),(i+1,j+1),(i,j-1),(i,j+1)]:\\n                    if a >= 0 and a < len(board) and b >= 0 and b < len(board[0]) and board[a][b] % 2 == 1:\\n                        count += 1\\n                return count        \\n                \\n            for i in xrange(len(board)):\\n                for j in xrange(len(board[0])):\\n                    liveNeighbors = findLiveNeighbor(board, i, j)\\n                    if board[i][j] == 0 and liveNeighbors == 3 or board[i][j] == 1 and liveNeighbors in [2,3]:\\n                            board[i][j] |= 2\\n            for i in xrange(len(board)):\\n                for j in xrange(len(board[0])):\\n                    board[i][j] >>= 1\\n            return",
                "codeTag": "Java"
            },
            {
                "id": 3485695,
                "title": "easy-to-understand-beginner-friendly",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int cal(vector<vector<int>>board,int i,int j)\\n    {\\n        int n=board.size(),m=board[0].size();\\n        int sum=0;\\n        if(i>0)  sum+=board[i-1][j];//up\\n        if(i<n-1) sum+=board[i+1][j];//down\\n        if(j>0) sum+=board[i][j-1];//left\\n        if(j<m-1) sum+=board[i][j+1];//right\\n        if(i>0 && j>0) sum+=board[i-1][j-1];//top left diagonal\\n        if(i<n-1 && j>0) sum+=board[i+1][j-1];//down left diagonal\\n        if(i>0 && j<m-1) sum+=board[i-1][j+1];//top right diagonal\\n        if(i<n-1 && j<m-1) sum+=board[i+1][j+1];//down right diagonal\\n        return sum;\\n    }\\n\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size(),m=board[0].size();\\n      vector<vector<int>> ans(n,vector<int>(m));\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n              int sum=cal(board,i,j);\\n              if(board[i][j]==0 && sum==3)\\n              ans[i][j]=1;\\n              else\\n              ans[i][j]=0;\\n              if(board[i][j]==1 &&sum<2)\\n              ans[i][j]=0;\\n              else if(board[i][j]==1 && sum==2 ||sum==3)\\n              ans[i][j]=1;\\n              else\\n              ans[i][j]=0;\\n          }\\n      }\\n        board=ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cal(vector<vector<int>>board,int i,int j)\\n    {\\n        int n=board.size(),m=board[0].size();\\n        int sum=0;\\n        if(i>0)  sum+=board[i-1][j];//up\\n        if(i<n-1) sum+=board[i+1][j];//down\\n        if(j>0) sum+=board[i][j-1];//left\\n        if(j<m-1) sum+=board[i][j+1];//right\\n        if(i>0 && j>0) sum+=board[i-1][j-1];//top left diagonal\\n        if(i<n-1 && j>0) sum+=board[i+1][j-1];//down left diagonal\\n        if(i>0 && j<m-1) sum+=board[i-1][j+1];//top right diagonal\\n        if(i<n-1 && j<m-1) sum+=board[i+1][j+1];//down right diagonal\\n        return sum;\\n    }\\n\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size(),m=board[0].size();\\n      vector<vector<int>> ans(n,vector<int>(m));\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n              int sum=cal(board,i,j);\\n              if(board[i][j]==0 && sum==3)\\n              ans[i][j]=1;\\n              else\\n              ans[i][j]=0;\\n              if(board[i][j]==1 &&sum<2)\\n              ans[i][j]=0;\\n              else if(board[i][j]==1 && sum==2 ||sum==3)\\n              ans[i][j]=1;\\n              else\\n              ans[i][j]=0;\\n          }\\n      }\\n        board=ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122091,
                "title": "c-accepted-runtime-0-ms",
                "content": "**Approach for Game of Life**\\n\\nFirstly the whole question depends on the number of live nighbours of particular board cell.\\nSo we calculate the **no. of live neighbours**.\\n\\nNow for Calculating Live neigbours, \\nSuppose we need to calculate the live neigbour of cell (1,1).\\n### we should check all the 8 neighbours.\\n![Image](https://github.com/mansi2024/ImagesUse/blob/main/Group%201%20(1).png?raw=true)\\nHere in the figure, We are calculating the neighbours of (1,1) index,\\nSo we add the supposed index marking of the neighbour to the given index to calculate the index of the other neighbours.\\nAs we can see (1,1)+(-1,-1)=>(0,0) which is the actual index of the (-1,-1)place.\\nlike that we calculate the neighbour index.\\n\\n### Now check if the neighbour index is valid if valid then\\nif the cell is 1 -> and it has less than 2 and more than 3 neighbours than make it -1.\\nif the cell is 0 -> and it has exactly 3 live nighbours make it as 2.\\n\\n### Now traverse through the matrix and if the cell value is >=1 make it 1.else make it 0.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidNeighbour(int x,int y, vector<vector<int>>& board){\\n        return(x>=0 && x<board.size() && y>=0 && y<board[0].size());\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<int> dx = {0,0,1,1,1,-1,-1,-1};\\n        vector<int> dy = {1,-1,1,-1,0,0,1,-1};{\\n        \\n        for(int row=0; row<board.size();row++)\\n            for(int column=0; column<board[0].size(); column++){\\n                int countLive=0;\\n\\n                for(int i=0;i<8;i++){\\n                    int curr_x = row+dx[i], curr_y = column+dy[i];\\n                    if(isValidNeighbour(curr_x,curr_y,board) && abs(board[curr_x][curr_y])==1)\\n                     countLive++;\\n                }\\n\\n                if(board[row][column]==1 && (countLive<2 || countLive>3))\\n                 board[row][column]=-1;\\n\\n                if(board[row][column]==0 && countLive==3)\\n                 board[row][column]=2;\\n            }\\n        }\\n        for(int row=0; row<board.size(); row++){\\n            for(int column=0; column<board[0].size(); column++){\\n                if(board[row][column]>=1)\\n                  board[row][column]=1;\\n                else\\n                  board[row][column]=0;\\n            }\\n        }\\n\\n    }\\n};\\n```\\n**If You liked it then please upvote it**.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidNeighbour(int x,int y, vector<vector<int>>& board){\\n        return(x>=0 && x<board.size() && y>=0 && y<board[0].size());\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<int> dx = {0,0,1,1,1,-1,-1,-1};\\n        vector<int> dy = {1,-1,1,-1,0,0,1,-1};{\\n        \\n        for(int row=0; row<board.size();row++)\\n            for(int column=0; column<board[0].size(); column++){\\n                int countLive=0;\\n\\n                for(int i=0;i<8;i++){\\n                    int curr_x = row+dx[i], curr_y = column+dy[i];\\n                    if(isValidNeighbour(curr_x,curr_y,board) && abs(board[curr_x][curr_y])==1)\\n                     countLive++;\\n                }\\n\\n                if(board[row][column]==1 && (countLive<2 || countLive>3))\\n                 board[row][column]=-1;\\n\\n                if(board[row][column]==0 && countLive==3)\\n                 board[row][column]=2;\\n            }\\n        }\\n        for(int row=0; row<board.size(); row++){\\n            for(int column=0; column<board[0].size(); column++){\\n                if(board[row][column]>=1)\\n                  board[row][column]=1;\\n                else\\n                  board[row][column]=0;\\n            }\\n        }\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770484,
                "title": "c-0ms-o-1-space",
                "content": "Basically this can be done using another matrix, but still we can do this without using any extra space. Let us discuss the approach: \\n\\nSo, let\\'s say you have changed the given matrix for example :\\n\\nThis is the given matrix:\\n0,1,0\\n0,0,1\\n1,1,1\\n0,0,0\\n\\nif you pick the box (2,0)[assume 0 based indexing], the live boxes around it are only 1, so according to question it dies and becoms 0. But if you change the original matrix then the next boxes (2,1) , (2,2) will also die for the same reason, but it should not happen.\\n\\nSo, to avoid this just insted of making it 0 or 1 in the original matrix change it to an other number, like if it satisfies 1st condition which is \"Any live cell with fewer than two live neighbors dies as if caused by under-population\", so if this condition is satisfying by a box then insted of making 0 make it \\'2\\'. And now if you encounter any box other than 0 or 1 then you can just get the past form of the box. For example, if the box is 2 then atpresent it is dead but in the past it was alive(1). So, like wise you can follow for all 4 conditions and atlast you can change the matrix.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>movements = {{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                int childlivecount = 0;\\n                for(auto &mvt:movements){\\n                    int ni = i+mvt.first;\\n                    int nj = j+mvt.second;\\n                    if(ni<0 || nj<0 || ni>=r || nj>=c) continue;\\n                    if(board[ni][nj] == 1) childlivecount++;\\n                    else if(board[ni][nj] == 2) childlivecount++;\\n                    else if(board[ni][nj] == 3) childlivecount++;\\n                    else if(board[ni][nj] == 4) childlivecount++;\\n                }\\n                if((board[i][j] == 5 || board[i][j] == 0)){\\n                    if(childlivecount == 3){\\n                        board[i][j] = 5;\\n                    }\\n                    else{\\n                        //Same\\n                    }\\n                }\\n                else if(childlivecount < 2) board[i][j] = 2;\\n                else if(childlivecount == 2 || childlivecount == 3) board[i][j] = 3;\\n                else if(childlivecount > 3) board[i][j] = 4;\\n            }\\n        }\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(board[i][j] == 2) board[i][j] = 0;\\n                else if(board[i][j] == 3) board[i][j] = 1;\\n                else if(board[i][j] == 4) board[i][j] = 0;\\n                else if(board[i][j] == 5) board[i][j] = 1;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>movements = {{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                int childlivecount = 0;\\n                for(auto &mvt:movements){\\n                    int ni = i+mvt.first;\\n                    int nj = j+mvt.second;\\n                    if(ni<0 || nj<0 || ni>=r || nj>=c) continue;\\n                    if(board[ni][nj] == 1) childlivecount++;\\n                    else if(board[ni][nj] == 2) childlivecount++;\\n                    else if(board[ni][nj] == 3) childlivecount++;\\n                    else if(board[ni][nj] == 4) childlivecount++;\\n                }\\n                if((board[i][j] == 5 || board[i][j] == 0)){\\n                    if(childlivecount == 3){\\n                        board[i][j] = 5;\\n                    }\\n                    else{\\n                        //Same\\n                    }\\n                }\\n                else if(childlivecount < 2) board[i][j] = 2;\\n                else if(childlivecount == 2 || childlivecount == 3) board[i][j] = 3;\\n                else if(childlivecount > 3) board[i][j] = 4;\\n            }\\n        }\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(board[i][j] == 2) board[i][j] = 0;\\n                else if(board[i][j] == 3) board[i][j] = 1;\\n                else if(board[i][j] == 4) board[i][j] = 0;\\n                else if(board[i][j] == 5) board[i][j] = 1;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500859,
                "title": "clean-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int m, n;   //   m x n grid...\\n    \\n    // all the 8 positions we need to check...\\n    \\n    vector<pair<int, int> > movements = {\\n\\t{-1, 0}, {1, 0},\\n\\t{-1, -1},{-1, 1},\\n\\t{0, -1}, {0, 1},\\n\\t{1, -1}, {1, 1}\\n};\\n \\n    //this is to check if the position is valid( i.e. not out of the grid)...\\n    \\n    bool isValid(int x, int y){\\n\\treturn x >= 0 && y >=  0 && x < m && y < n;\\n}\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        m = board.size();\\n        n = board[0].size();\\n        \\n        vector<vector<int>> res = board;\\n        \\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                \\n                int ct = 0;   // it will store no. of live neighbours...\\n                for(auto movement : movements){\\n                    int x = i + movement.first;\\n                    int y = j + movement.second;\\n                    if(isValid(x, y)){\\n                        if(res[x][y] == 1){\\n                                ++ct;\\n                        }\\n                    }\\n                }\\n               if(res[i][j] == 0){\\n                   if(ct == 3)\\n                       board[i][j] = 1;\\n               }\\n                else{\\n                    if(ct < 2 || ct > 3)\\n                        board[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;   //   m x n grid...\\n    \\n    // all the 8 positions we need to check...\\n    \\n    vector<pair<int, int> > movements = {\\n\\t{-1, 0}, {1, 0},\\n\\t{-1, -1},{-1, 1},\\n\\t{0, -1}, {0, 1},\\n\\t{1, -1}, {1, 1}\\n};\\n \\n    //this is to check if the position is valid( i.e. not out of the grid)...\\n    \\n    bool isValid(int x, int y){\\n\\treturn x >= 0 && y >=  0 && x < m && y < n;\\n}\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        m = board.size();\\n        n = board[0].size();\\n        \\n        vector<vector<int>> res = board;\\n        \\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                \\n                int ct = 0;   // it will store no. of live neighbours...\\n                for(auto movement : movements){\\n                    int x = i + movement.first;\\n                    int y = j + movement.second;\\n                    if(isValid(x, y)){\\n                        if(res[x][y] == 1){\\n                                ++ct;\\n                        }\\n                    }\\n                }\\n               if(res[i][j] == 0){\\n                   if(ct == 3)\\n                       board[i][j] = 1;\\n               }\\n                else{\\n                    if(ct < 2 || ct > 3)\\n                        board[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492335,
                "title": "simple-python-solution-using-hashmap-beats-95",
                "content": "class Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        row_len = len(board)\\n        col_len = len(board[0])\\n        switch ={}\\n        directions = [(1,1),(1,-1),(-1,1),(1,0),(0,1),(-1,0),(0,-1),(-1,-1)]\\n        \\n        for i in range(row_len):\\n            for j in range(col_len):\\n                live = 0 \\n                \\n                for x, y in directions:\\n                    if (i+x >=0 and i+x < row_len) and (j+y>=0 and j+y< col_len) :\\n                        \\n                        if board[i+x][j+y] == 1:\\n                            live += 1\\n                                       \\n                            \\n                if board[i][j] == 0:\\n                    if live ==3:\\n                        switch[(i,j)] = 1\\n                        \\n                elif live< 2 or live >3:\\n                        switch[(i,j)] = 0\\n                        \\n                    \\n                 \\n        for key in switch.keys():\\n            board[key[0]][key[1]] = switch[key]\\n                    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        row_len = len(board)\\n        col_len = len(board[0])\\n        switch ={}",
                "codeTag": "Java"
            },
            {
                "id": 2452359,
                "title": "c-intuition-based-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<vector<int>> arr = board;\\n        int m = board.size();\\n        int n = board[0].size();\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                int live = 0;\\n                int col=j, row=i;\\n                int r, c;\\n                r = row-1;\\n                c = col;\\n                if(r>=0 && arr[r][c] == 1){\\n                    //cout<<\"up\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row+1;\\n                c = col;\\n                if(r<m && arr[r][c] == 1){\\n                    //cout<<\"down\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row;\\n                c = col-1;\\n                if(c>=0 && arr[r][c] == 1){\\n                    //cout<<\"left\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row;\\n                c = col+1;\\n                if(c<n && arr[r][c] == 1){\\n                    //cout<<\"right\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row-1;\\n                c = col-1;\\n                if(r>=0 && c>=0 && arr[r][c] == 1){\\n                    //cout<<\"left-up\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row+1;\\n                c = col+1;\\n                if(r<m && c<n && arr[r][c] == 1){\\n                    //cout<<\"right-down\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row-1;\\n                c = col+1;\\n                if(r>=0 && c<n && arr[r][c] == 1){\\n                    //cout<<\"right-up\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row+1;\\n                c = col-1;\\n                if(c>=0 && r<m && arr[r][c] == 1){\\n                    //cout<<\"left-down\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                //cout<<endl<<i<<\" \"<<j<<\" \"<<live<<\" \"<<endl;\\n                if(board[i][j] == 1 && live < 2){\\n                    board[i][j] = 0;\\n                }\\n                if(board[i][j] == 1 && live > 3){\\n                    board[i][j] = 0;\\n                }\\n                if(board[i][j] == 0 && live == 3){\\n                    board[i][j] = 1;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<vector<int>> arr = board;\\n        int m = board.size();\\n        int n = board[0].size();\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                int live = 0;\\n                int col=j, row=i;\\n                int r, c;\\n                r = row-1;\\n                c = col;\\n                if(r>=0 && arr[r][c] == 1){\\n                    //cout<<\"up\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row+1;\\n                c = col;\\n                if(r<m && arr[r][c] == 1){\\n                    //cout<<\"down\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row;\\n                c = col-1;\\n                if(c>=0 && arr[r][c] == 1){\\n                    //cout<<\"left\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row;\\n                c = col+1;\\n                if(c<n && arr[r][c] == 1){\\n                    //cout<<\"right\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row-1;\\n                c = col-1;\\n                if(r>=0 && c>=0 && arr[r][c] == 1){\\n                    //cout<<\"left-up\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row+1;\\n                c = col+1;\\n                if(r<m && c<n && arr[r][c] == 1){\\n                    //cout<<\"right-down\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row-1;\\n                c = col+1;\\n                if(r>=0 && c<n && arr[r][c] == 1){\\n                    //cout<<\"right-up\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                r = row+1;\\n                c = col-1;\\n                if(c>=0 && r<m && arr[r][c] == 1){\\n                    //cout<<\"left-down\"<<\"(\"<<r<<\",\"<<c<<\")\"<<\" \";\\n                    live++;\\n                }\\n                //cout<<endl<<i<<\" \"<<j<<\" \"<<live<<\" \"<<endl;\\n                if(board[i][j] == 1 && live < 2){\\n                    board[i][j] = 0;\\n                }\\n                if(board[i][j] == 1 && live > 3){\\n                    board[i][j] = 0;\\n                }\\n                if(board[i][j] == 0 && live == 3){\\n                    board[i][j] = 1;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2164029,
                "title": "single-short-function-99-faster-91-less-intuitive-beginner-solution-with-process-and-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/00ec0fe6-7b0e-457f-ba30-3e1151b28e8d_1655506082.2529001.png)\\n________________________________\\n#### Need:\\n1. modify board **in-place**\\n2. apply the rules simultaneously (to all cells in one same round). \\n\\tNamely, the modification of one cell should not affect the condition(neighbouring) for other cells\\n3. verify and save only **valid neighbours** for rule checking\\n4. only need to count the number of **live cells** in valid neighbours for the rules:\\n```\\nlive cells count   |   changes\\n< 2                    1 -> 0     \\n== 2 or 3              1 -> 1     # no change\\n> 3                    1 -> 0     \\n\\n== 3                   0 -> 1     \\n!= 3                   0 -> 0     # no change\\n\\n```\\n\\n\\n#### Ideas: \\n1. iterate over the given 2D array `board` and modify cells  `board[i][j]`  according to the rules\\n2. backup the current state using `copy.deepcopy(board)`\\n3. define index for all possible 8 neighbours: `neighbours_index`, verify and save only **valid neighbours** `valid_nei` that are in range\\n4. apply rules aboveusing using if conditions to live `cell ==1` and dead `cell == 0` cells respecrively \\n\\n#### Process:\\n```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        saved_state = copy.deepcopy(board)\\n\\n        for i, row in enumerate(board):\\n            for j, cell in enumerate(row):\\n\\t\\t\\t\\n\\t\\t\\t# Neighbours:\\n                neighbours_index = [(i - 1, j - 1), (i - 1, j), (i - 1, j + 1),\\n                                    (i, j - 1), (i, j + 1),\\n                                    (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)]\\n                valid_nei = []\\n                for row, col in neighbours_index:\\n                    if row in range(len(board)) and col in range(len(board[0])):\\n                        valid_nei.append(saved_state[row][col])     # can use list comprehension\\n\\t\\t\\n\\t\\t\\t# Cells:\\n                if cell == 1:\\n                    if valid_nei.count(1) < 2:\\n                        board[i][j] = 0\\n                    elif valid_nei.count(1) > 3:\\n                        board[i][j] = 0\\n                    elif valid_nei.count(1) == 2 or valid_nei.count(1) == 3:\\n                        board[i][j] = 1    # no change\\n                elif cell == 0:\\n                    if valid_nei.count(1) == 3:\\n                        board[i][j] = 1\\n                    else:\\n                        board[i][j] = 0    # no chagne\\n```\\n\\n#### Clean-up:\\nObserve, \\n- `valid_nei` can be easily shorten by list cokprehension\\n- there are two conditions (rules) are changing anying in `board`\\n\\n#### \\u2705 Submitted Code:\\n```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        saved_state = copy.deepcopy(board)\\n\\n        for i, row in enumerate(board):\\n            for j, cell in enumerate(row):\\n\\n                neighbours_index = [(i - 1, j - 1), (i - 1, j), (i - 1, j + 1),\\n                                    (i, j - 1), (i, j + 1),\\n                                    (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)]\\n                valid_nei = [saved_state[row][col] for row, col in neighbours_index if row in range(len(board)) and col in range(len(board[0])) ]        \\n\\n                if cell == 1:\\n                    if valid_nei.count(1) < 2:\\n                        board[i][j] = 0\\n                    elif valid_nei.count(1) > 3:\\n                        board[i][j] = 0\\n                elif cell == 0:\\n                    if valid_nei.count(1) == 3:\\n                        board[i][j] = 1\\n```\\n\\n--------------------------------------------------------\\n\\nAs a total beginner, I am writing these all out to help myself, and hopefully also help anyone out there who is like me at the same time.\\n\\nPlease upvote\\u2B06\\uFE0F if you find this helpful or worth-reading for beginners in anyway.\\nYour upvote is much more than just supportive to me. \\uD83D\\uDE33\\uD83E\\uDD13\\uD83E\\uDD70\\n\\nIf you find this is not helpful, needs improvement, or is questionable, would you please leave a quick comment below to point out the problem before you decide to downvote? It will be very helpful for me (maybe also others) to learn as a beginner.\\n\\nThank you very much either way \\uD83E\\uDD13.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nlive cells count   |   changes\\n< 2                    1 -> 0     \\n== 2 or 3              1 -> 1     # no change\\n> 3                    1 -> 0     \\n\\n== 3                   0 -> 1     \\n!= 3                   0 -> 0     # no change\\n\\n```\n```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        saved_state = copy.deepcopy(board)\\n\\n        for i, row in enumerate(board):\\n            for j, cell in enumerate(row):\\n\\t\\t\\t\\n\\t\\t\\t# Neighbours:\\n                neighbours_index = [(i - 1, j - 1), (i - 1, j), (i - 1, j + 1),\\n                                    (i, j - 1), (i, j + 1),\\n                                    (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)]\\n                valid_nei = []\\n                for row, col in neighbours_index:\\n                    if row in range(len(board)) and col in range(len(board[0])):\\n                        valid_nei.append(saved_state[row][col])     # can use list comprehension\\n\\t\\t\\n\\t\\t\\t# Cells:\\n                if cell == 1:\\n                    if valid_nei.count(1) < 2:\\n                        board[i][j] = 0\\n                    elif valid_nei.count(1) > 3:\\n                        board[i][j] = 0\\n                    elif valid_nei.count(1) == 2 or valid_nei.count(1) == 3:\\n                        board[i][j] = 1    # no change\\n                elif cell == 0:\\n                    if valid_nei.count(1) == 3:\\n                        board[i][j] = 1\\n                    else:\\n                        board[i][j] = 0    # no chagne\\n```\n```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        saved_state = copy.deepcopy(board)\\n\\n        for i, row in enumerate(board):\\n            for j, cell in enumerate(row):\\n\\n                neighbours_index = [(i - 1, j - 1), (i - 1, j), (i - 1, j + 1),\\n                                    (i, j - 1), (i, j + 1),\\n                                    (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)]\\n                valid_nei = [saved_state[row][col] for row, col in neighbours_index if row in range(len(board)) and col in range(len(board[0])) ]        \\n\\n                if cell == 1:\\n                    if valid_nei.count(1) < 2:\\n                        board[i][j] = 0\\n                    elif valid_nei.count(1) > 3:\\n                        board[i][j] = 0\\n                elif cell == 0:\\n                    if valid_nei.count(1) == 3:\\n                        board[i][j] = 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104723,
                "title": "c-simple-and-easy-solution",
                "content": "If you like please upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int noOfOnes(int i, int j ,vector<vector<int>>& board, int m, int n ){\\n        int count =0;\\n        \\n        if(i>0 and board[i-1][j]>=1 ) count++;\\n        if(i<m-1 and board[i+1][j]>=1 ) count++;\\n        if(j>0 and board[i][j-1]>= 1 ) count++;\\n        if(j<n-1 and board[i][j+1]>=1 ) count++;\\n        if(i>0 and j>0 and board[i-1][j-1]>= 1) count++;        \\n        if(i<m-1 and j<n-1 and board[i+1][j+1]>= 1) count++;\\n        if(i<m-1 and j>0 and board[i+1][j-1]>= 1) count++;\\n        if(i>0 and j<n-1 and board[i-1][j+1]>= 1 ) count++;\\n        \\n        return count;\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        \\n        int m = board.size();\\n        int n= board[0].size();\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n ; j++){\\n                if(board[i][j]==0){\\n                    if(noOfOnes(i,j,board,m,n)==3){\\n                        board[i][j]=-1;\\n                    }\\n                }else if(board[i][j]==1){\\n                    if(noOfOnes(i,j,board,m,n) < 2){\\n                        board[i][j] =2;\\n                    }else if(noOfOnes(i,j,board,m,n) >3){\\n                        board[i][j] =2;\\n                    }\\n                }\\n            }\\n        }\\n        \\n         for(int i=0; i<m; i++){\\n            for(int j=0; j<n ; j++){\\n              if(board[i][j]==2){\\n                  board[i][j]=0;\\n              }else if(board[i][j]==-1){\\n                  board[i][j]=1;\\n              }\\n            }\\n         }  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int noOfOnes(int i, int j ,vector<vector<int>>& board, int m, int n ){\\n        int count =0;\\n        \\n        if(i>0 and board[i-1][j]>=1 ) count++;\\n        if(i<m-1 and board[i+1][j]>=1 ) count++;\\n        if(j>0 and board[i][j-1]>= 1 ) count++;\\n        if(j<n-1 and board[i][j+1]>=1 ) count++;\\n        if(i>0 and j>0 and board[i-1][j-1]>= 1) count++;        \\n        if(i<m-1 and j<n-1 and board[i+1][j+1]>= 1) count++;\\n        if(i<m-1 and j>0 and board[i+1][j-1]>= 1) count++;\\n        if(i>0 and j<n-1 and board[i-1][j+1]>= 1 ) count++;\\n        \\n        return count;\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        \\n        int m = board.size();\\n        int n= board[0].size();\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n ; j++){\\n                if(board[i][j]==0){\\n                    if(noOfOnes(i,j,board,m,n)==3){\\n                        board[i][j]=-1;\\n                    }\\n                }else if(board[i][j]==1){\\n                    if(noOfOnes(i,j,board,m,n) < 2){\\n                        board[i][j] =2;\\n                    }else if(noOfOnes(i,j,board,m,n) >3){\\n                        board[i][j] =2;\\n                    }\\n                }\\n            }\\n        }\\n        \\n         for(int i=0; i<m; i++){\\n            for(int j=0; j<n ; j++){\\n              if(board[i][j]==2){\\n                  board[i][j]=0;\\n              }else if(board[i][j]==-1){\\n                  board[i][j]=1;\\n              }\\n            }\\n         }  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941558,
                "title": "second-follow-up-solution-in-c-sparse-matrix",
                "content": "```\\n// Follow up where the board is infinite\\n// Using sparse matrix solution. I.e., only store live cells.\\n// Using map and set instead of unordered_map and unordered_set because there is no default hash for pair\\n\\nclass Solution {\\nprivate:\\n    set<pair<int, int>> simulate(const set<pair<int, int>> &live_cells){\\n        map<pair<int, int>, int> live_neigh_count;\\n        // For each live cell, increment its neighs by 1\\n        int delta[] = {-1, 0, 1};\\n        for(const auto &[i, j]: live_cells)\\n            for(const int dx: delta)\\n                for(const int dy: delta)\\n                    if(dx != 0 || dy != 0)\\n                        live_neigh_count[{i + dx, j + dy}]++;\\n        \\n        set<pair<int, int>> new_live_cells;\\n        \\n        for(const auto &[cell, live_count]: live_neigh_count)\\n            if(live_count == 3 || live_count == 2 && live_cells.count(cell))\\n                new_live_cells.insert(cell);\\n        \\n        return new_live_cells;\\n    }\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        set<pair<int, int>> live_cells;\\n        for(size_t i = 0; i < board.size(); i++)\\n            for(size_t j = 0; j < board[0].size(); j++)\\n                if(board[i][j] == 1)\\n                    live_cells.emplace(i, j);\\n        \\n        set<pair<int, int>> new_live_cells = simulate(live_cells);\\n        \\n        for(size_t i = 0; i < board.size(); i++)\\n            for(size_t j = 0; j < board[0].size(); j++)\\n                if(new_live_cells.count({i, j}))\\n                    board[i][j] = 1;\\n                else\\n                    board[i][j] = 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Follow up where the board is infinite\\n// Using sparse matrix solution. I.e., only store live cells.\\n// Using map and set instead of unordered_map and unordered_set because there is no default hash for pair\\n\\nclass Solution {\\nprivate:\\n    set<pair<int, int>> simulate(const set<pair<int, int>> &live_cells){\\n        map<pair<int, int>, int> live_neigh_count;\\n        // For each live cell, increment its neighs by 1\\n        int delta[] = {-1, 0, 1};\\n        for(const auto &[i, j]: live_cells)\\n            for(const int dx: delta)\\n                for(const int dy: delta)\\n                    if(dx != 0 || dy != 0)\\n                        live_neigh_count[{i + dx, j + dy}]++;\\n        \\n        set<pair<int, int>> new_live_cells;\\n        \\n        for(const auto &[cell, live_count]: live_neigh_count)\\n            if(live_count == 3 || live_count == 2 && live_cells.count(cell))\\n                new_live_cells.insert(cell);\\n        \\n        return new_live_cells;\\n    }\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        set<pair<int, int>> live_cells;\\n        for(size_t i = 0; i < board.size(); i++)\\n            for(size_t j = 0; j < board[0].size(); j++)\\n                if(board[i][j] == 1)\\n                    live_cells.emplace(i, j);\\n        \\n        set<pair<int, int>> new_live_cells = simulate(live_cells);\\n        \\n        for(size_t i = 0; i < board.size(); i++)\\n            for(size_t j = 0; j < board[0].size(); j++)\\n                if(new_live_cells.count({i, j}))\\n                    board[i][j] = 1;\\n                else\\n                    board[i][j] = 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940452,
                "title": "python-easy-solution-faster-than-90-o-n",
                "content": "```\\nclass Solution:\\n    \\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def check(i,j,n,m):\\n            if i>=0 and i<n and j>=0 and j<m:\\n                return True\\n            else:\\n                return False\\n        n=len(board)\\n        m=len(board[0])\\n        count=0\\n        d=[]\\n        for i in range(n):\\n            a=[]\\n            for j in range(m):\\n                a.append(board[i][j])\\n            d.append(a)\\n    \\n        for i in range(n):\\n            for j in range(m):\\n                if check(i-1,j-1,n,m):\\n                    if d[i-1][j-1]==1:\\n                        count+=1\\n                if check(i-1,j,n,m):\\n                    if d[i-1][j]==1:\\n                        count+=1\\n                if check(i-1,j+1,n,m):\\n                    if d[i-1][j+1]==1:\\n                        count+=1\\n                if check(i,j-1,n,m):\\n                    if d[i][j-1]==1:\\n                        count+=1\\n                if check(i,j+1,n,m):\\n                    if d[i][j+1]==1:\\n                        count+=1\\n                if check(i+1,j-1,n,m):\\n                    if d[i+1][j-1]==1:\\n                        count+=1\\n                if check(i+1,j,n,m):\\n                    if d[i+1][j]==1:\\n                        count+=1\\n                if check(i+1,j+1,n,m):\\n                    if d[i+1][j+1]==1:\\n                        count+=1\\n                if count<2 or count>3:\\n                    board[i][j]=0\\n                elif count==3:\\n                    board[i][j]=1\\n                count=0\\n        return board\\n        \\n            \\n            \\n        \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def check(i,j,n,m):\\n            if i>=0 and i<n and j>=0 and j<m:\\n                return True\\n            else:\\n                return False\\n        n=len(board)\\n        m=len(board[0])\\n        count=0\\n        d=[]\\n        for i in range(n):\\n            a=[]\\n            for j in range(m):\\n                a.append(board[i][j])\\n            d.append(a)\\n    \\n        for i in range(n):\\n            for j in range(m):\\n                if check(i-1,j-1,n,m):\\n                    if d[i-1][j-1]==1:\\n                        count+=1\\n                if check(i-1,j,n,m):\\n                    if d[i-1][j]==1:\\n                        count+=1\\n                if check(i-1,j+1,n,m):\\n                    if d[i-1][j+1]==1:\\n                        count+=1\\n                if check(i,j-1,n,m):\\n                    if d[i][j-1]==1:\\n                        count+=1\\n                if check(i,j+1,n,m):\\n                    if d[i][j+1]==1:\\n                        count+=1\\n                if check(i+1,j-1,n,m):\\n                    if d[i+1][j-1]==1:\\n                        count+=1\\n                if check(i+1,j,n,m):\\n                    if d[i+1][j]==1:\\n                        count+=1\\n                if check(i+1,j+1,n,m):\\n                    if d[i+1][j+1]==1:\\n                        count+=1\\n                if count<2 or count>3:\\n                    board[i][j]=0\\n                elif count==3:\\n                    board[i][j]=1\\n                count=0\\n        return board\\n        \\n            \\n            \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938314,
                "title": "c-matrix-easy-o-mxn-solution-with-comments-beats-100",
                "content": "**Code:**\\n```\\nclass Solution {\\npublic:\\n    \\n    int findSum(vector<vector<int>> &board, int r, int c)\\n    {\\n        int sum=0;\\n        for(int i=r-1; i<=r+1; i++)\\n        {\\n            for(int j=c-1; j<=c+1; j++)\\n            {\\n                if((i==r && j==c) || i<0 || j<0 || i==board.size() \\n                   || j==board[0].size()) //boundary conditions\\n                    continue;\\n                \\n                //to convert 2, 3 into 0, 1\\n                sum += (board[i][j] %2); \\n            }\\n        }\\n        return sum;\\n    }\\n      \\n    //since we need to change states in the given board (void function)\\n    //and also keep track of previous state we represent changed state with 2 and 3\\n    //2 shows we changed from die to live and while find sum 2%2=0 that shows previously it was die\\n    //3 shows we changed from live to die and while find sum 3%2=1 that shows previously it was alive\\n    //it will be more clear when you see the code\\n    void gameOfLife(vector<vector<int>>& board) \\n    {\\n        int r=board.size(), c=board[0].size();\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                int sum = findSum(board, i, j);\\n                \\n                if(board[i][j] && (sum<2 || sum>3)) //when cell is alive\\n                    board[i][j] = 3; //it shows live cell dies \\n                \\n                if(!board[i][j] && sum==3) //when cell is dead\\n                    board[i][j] = 2; //it shows dead cell becomes alive \\n            }\\n        } \\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                //change into real representation 0,1\\n                if(board[i][j] == 3) board[i][j] = 0; \\n                if(board[i][j] == 2) board[i][j] = 1;   \\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findSum(vector<vector<int>> &board, int r, int c)\\n    {\\n        int sum=0;\\n        for(int i=r-1; i<=r+1; i++)\\n        {\\n            for(int j=c-1; j<=c+1; j++)\\n            {\\n                if((i==r && j==c) || i<0 || j<0 || i==board.size() \\n                   || j==board[0].size()) //boundary conditions\\n                    continue;\\n                \\n                //to convert 2, 3 into 0, 1\\n                sum += (board[i][j] %2); \\n            }\\n        }\\n        return sum;\\n    }\\n      \\n    //since we need to change states in the given board (void function)\\n    //and also keep track of previous state we represent changed state with 2 and 3\\n    //2 shows we changed from die to live and while find sum 2%2=0 that shows previously it was die\\n    //3 shows we changed from live to die and while find sum 3%2=1 that shows previously it was alive\\n    //it will be more clear when you see the code\\n    void gameOfLife(vector<vector<int>>& board) \\n    {\\n        int r=board.size(), c=board[0].size();\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                int sum = findSum(board, i, j);\\n                \\n                if(board[i][j] && (sum<2 || sum>3)) //when cell is alive\\n                    board[i][j] = 3; //it shows live cell dies \\n                \\n                if(!board[i][j] && sum==3) //when cell is dead\\n                    board[i][j] = 2; //it shows dead cell becomes alive \\n            }\\n        } \\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                //change into real representation 0,1\\n                if(board[i][j] == 3) board[i][j] = 0; \\n                if(board[i][j] == 2) board[i][j] = 1;   \\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722673,
                "title": "python-3-o-mn-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m, n = len(board), len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                \\n                # count number of live neighbours\\n                live_neighbours = 0\\n                for x in range(max(i-1, 0), min(i+2, m)):\\n                    for y in range(max(j-1, 0), min(j+2, n)):\\n                        if i == x and j == y:\\n                            continue\\n                        live_neighbours += board[x][y] % 2\\n                \\n                # mark the cell if it needs to change states\\n                if board[i][j] == 0:\\n                    if live_neighbours == 3:\\n                        board[i][j] = 2\\n                elif live_neighbours < 2 or live_neighbours > 3:\\n                    board[i][j] = 3\\n        \\n        # change all required states\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == 2:\\n                    board[i][j] = 1\\n                elif board[i][j] == 3:\\n                    board[i][j] = 0",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m, n = len(board), len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                \\n                # count number of live neighbours\\n                live_neighbours = 0\\n                for x in range(max(i-1, 0), min(i+2, m)):\\n                    for y in range(max(j-1, 0), min(j+2, n)):\\n                        if i == x and j == y:\\n                            continue\\n                        live_neighbours += board[x][y] % 2\\n                \\n                # mark the cell if it needs to change states\\n                if board[i][j] == 0:\\n                    if live_neighbours == 3:\\n                        board[i][j] = 2\\n                elif live_neighbours < 2 or live_neighbours > 3:\\n                    board[i][j] = 3\\n        \\n        # change all required states\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == 2:\\n                    board[i][j] = 1\\n                elif board[i][j] == 3:\\n                    board[i][j] = 0",
                "codeTag": "Java"
            },
            {
                "id": 1581053,
                "title": "2-minutes-read-bit-magic-solution-using-9-bits",
                "content": "So, comming straight to the point, this might not be the most optimal solution. But as we all know, it\\'s not always about the best algorithm, it\\'s mostly about what all possible algorithms and ways are there, that could be applied to solve a problem. \\n\\n<br>\\n\\n\\uD83E\\uDD14 **ALGORITHM**\\n1. For each index `(i, j)` of the matrix:\\n\\t1. If it is `0`, do nothing.\\n\\t2. If it is `1`, increase (if possible):\\n\\t\\ta. The upper-left cell i.e. `(i - 1, j - 1)` by 2<sup>1</sup>.\\n\\t\\tb. The upper cell i.e. `(i - 1, j )` by 2<sup>2</sup>.\\n\\t\\tc. The upper-right cell i.e. `(i - 1, j + 1)` by 2<sup>3</sup>.\\n\\t\\td. The left cell i.e. `(i, j - 1)` by 2<sup>4</sup>.\\n\\t\\te. The right cell i.e. `(i, j + 1)` by 2<sup>5</sup>.\\n\\t\\tf. The bottom-left cell i.e. `(i + 1, j - 1)` by 2<sup>6</sup>.\\n\\t\\tg. The bottom cell i.e. `(i + 1, j)` by 2<sup>7</sup>.\\n\\t\\th. The bottom-right cell i.e. `(i + 1, j + 1)` by 2<sup>8</sup>.\\n2. Now move through each index `(i, j)` again and count the set bits from bit `1` to bit `8`, and bit `0` would be your current bit, and according to the 4 rules given in the problem, set this index as `1` or `0` accordingly.\\n\\n<br>\\n\\n\\uD83D\\uDCA1 **EXPLANATION**\\nFirst let\\'s look at a general diagram of an element at index `(i, j)`, using which we would be able to understand things better.\\n> `[1]` &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `[2]` &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `[3]`\\n>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `\\\\` &nbsp;&nbsp;&nbsp; `|`  &nbsp;&nbsp;&nbsp; `/`\\n> `[4]` `-` `(i, j)` `-` `[5]`\\n>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `/` &nbsp;&nbsp;&nbsp; `|`  &nbsp;&nbsp;&nbsp; `\\\\`\\n> `[6]` &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `[7]` &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `[8]`\\n\\nThe figure illustrates the neighbouring cells (if they exist), which the current cell `(i, j)` could affect. So, if the cell `(i, j)` is `1`, it would add the count of ones to these 8 neighbours of it. Now to keep a track of which neighbours are `1` and which not, we could use a 9-bit representation for these numbers (let\\'s call this as our *magical number*), where `0th` bit would represent whether the current cell is `1` or `0`, and the rest 8 would represent the 8 neighbours of this cell, being `1` or `0`, if that neighbour is `1` or `0` respectively. We would also, replace our current cell with this new *magical number*, as it\\'s self explanatory of the states of itself and it\\'s neighbour cells.\\n\\nOnce each element is replaced with it\\'s corresponding *magical numbers*, we could traverse through the grid once more, and change a cell `(i, j)` to `1` or `0`, according to the conditions stated in the problem. To aid us in applying the conditions, the count of neighbours which are `1` would be the count of set bits in the number at `(i, j)`, starting from bit `1` to bit `9`, and the current element would have been `1` or `0` depending upon the bit `0`.\\n\\n<br>\\n\\n\\uD83D\\uDCBB\\uFE0F **[JAVA] CODE**\\n```java\\nclass Solution {\\n    public void func(int board[][], int x, int y) {\\n        int m = board.length, n = board[0].length;\\n        int pos = 0;\\n        if((board[x][y] & 1) == 0) return;\\n        for(int i = x - 1; i <= x + 1; i++) {\\n            for(int j = y - 1; j <= y + 1; j++) {\\n                if(i == x && j == y) continue;\\n                pos++;\\n                if(i < 0 || i >= m || j < 0 || j >= n) continue;\\n                board[i][j] += (1 << pos);\\n            }\\n        }\\n    }\\n    public void gameOfLife(int[][] board) {\\n        int m = board.length, n = board[0].length;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                func(board, i, j);\\n            }\\n        }\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int count = 0;\\n                for(int mask = 1; mask <= 9; mask++) {\\n                    if(((1 << mask) & board[i][j]) != 0) {\\n                        count++;\\n                    }\\n                }\\n                int curr = (board[i][j] & 1);\\n                if(curr == 1) {\\n                    if(count < 2) board[i][j] = 0;\\n                    else if(count >= 2 && count < 4) board[i][j] = 1;\\n                    else board[i][j] = 0;\\n                }\\n                else {\\n                    if(count == 3) board[i][j] = 1;\\n                    else board[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\n<br>\\n\\nUpvote if you liked, downvote if you didn\\'t. And also, don\\'t forget to share your comments and feedbacks \\uD83D\\uDE07.",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n    public void func(int board[][], int x, int y) {\\n        int m = board.length, n = board[0].length;\\n        int pos = 0;\\n        if((board[x][y] & 1) == 0) return;\\n        for(int i = x - 1; i <= x + 1; i++) {\\n            for(int j = y - 1; j <= y + 1; j++) {\\n                if(i == x && j == y) continue;\\n                pos++;\\n                if(i < 0 || i >= m || j < 0 || j >= n) continue;\\n                board[i][j] += (1 << pos);\\n            }\\n        }\\n    }\\n    public void gameOfLife(int[][] board) {\\n        int m = board.length, n = board[0].length;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                func(board, i, j);\\n            }\\n        }\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int count = 0;\\n                for(int mask = 1; mask <= 9; mask++) {\\n                    if(((1 << mask) & board[i][j]) != 0) {\\n                        count++;\\n                    }\\n                }\\n                int curr = (board[i][j] & 1);\\n                if(curr == 1) {\\n                    if(count < 2) board[i][j] = 0;\\n                    else if(count >= 2 && count < 4) board[i][j] = 1;\\n                    else board[i][j] = 0;\\n                }\\n                else {\\n                    if(count == 3) board[i][j] = 1;\\n                    else board[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388180,
                "title": "c-in-place-implementation",
                "content": "```c++ \\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j,int n,int m){\\n        return i>=0 && j>=0 && j<m && i<n;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        \\n        vector<pair<int,int>>adjcells={{-1,0},{0,-1},{-1,-1},{1,0},{0,1},\\n                                       {1,1},{1,-1},{-1,1}};\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                int cnt = 0;\\n                for(int k=0;k<adjcells.size();k++){\\n                    int x = i + adjcells[k].first;\\n                    int y = j + adjcells[k].second;\\n                    \\n                    if(isvalid(x,y,n,m)){\\n                        // cout<<x<<\" \"<<y<<\"\\\\n\";\\n                        if(board[x][y]%10==1) cnt++;\\n                    }\\n                }\\n                // cout<<cnt<<\"\\\\n\";\\n                if(board[i][j]){\\n                    if (cnt==2 || cnt==3)\\n                       board[i][j] = 1*10 + board[i][j];\\n                    else {\\n                        board[i][j] = 0*10 + board[i][j];\\n                    }\\n                }\\n                else{\\n                    if(cnt == 3)\\n                        board[i][j] = 1*10 + board[i][j];\\n                    else{\\n                        board[i][j] = 0*10 + board[i][j];\\n                    }\\n                }    \\n            }\\n        }\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                board[i][j] = board[i][j]/10;\\n            }\\n        }\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isvalid(int i,int j,int n,int m){\\n        return i>=0 && j>=0 && j<m && i<n;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1383784,
                "title": "easy-python-solution-93-o-1-space-complexity-o-mn-time",
                "content": "The idea is store old and new value of a cell in the cell itself and use % and / operation to differentiate between old and new values.\\nExample: for each i,j\\n\\tif old value = 0 and new value = 0 , store board[i][j] = 0,\\n\\tif old value = 0 and new value = 1 , store board[i][j] = 2,\\n\\tif old value = 1 and new value = 0 , store board[i][j] = 1,\\n\\tif old value = 1 and new value = 1 , store board[i][j] = 3\\nTo get old value simplify do (board[i][j] % 2) and for new value do (board[i][j] / 2)\\n\\nNow, for cells that have been already created i.e up, left, diagonally up-right and diagonal up-left use the old value. \\n\\n\\n```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                neighbours = []\\n                if j!=0 and i!=0:\\n                    neighbours.append(board[i-1][j-1] % 2)\\n                if j != len(board[0])-1 and i != len(board) -1 :\\n                    neighbours.append(board[i+1][j+1])\\n                if j!=len(board[0])-1 and i!=0:\\n                    neighbours.append(board[i-1][j+1] % 2)\\n                if j!=0 and i!=len(board)-1:\\n                    neighbours.append(board[i+1][j-1])\\n                \\n                if i !=0:\\n                    neighbours.append(board[i-1][j] % 2)\\n                if i != len(board)-1:\\n                    neighbours.append(board[i+1][j])\\n                if j !=0:\\n                    neighbours.append(board[i][j-1] % 2)\\n                if j!=len(board[0])-1:\\n                    neighbours.append(board[i][j+1])\\n                    \\n                oneCount = neighbours.count(1)\\n                if oneCount < 2:\\n                    board[i][j] = 0 if board[i][j]==0 else 1\\n                elif oneCount == 2:\\n                    board[i][j] = 0 if board[i][j]==0 else 3\\n                elif oneCount > 3:\\n                    board[i][j] = 0 if board[i][j]==0 else 1\\n                elif oneCount == 3:\\n                    board[i][j] = 2 if board[i][j]==0 else 3\\n            \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                board[i][j] = board[i][j] // 2\\n                \\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                neighbours = []\\n                if j!=0 and i!=0:\\n                    neighbours.append(board[i-1][j-1] % 2)\\n                if j != len(board[0])-1 and i != len(board) -1 :\\n                    neighbours.append(board[i+1][j+1])\\n                if j!=len(board[0])-1 and i!=0:\\n                    neighbours.append(board[i-1][j+1] % 2)\\n                if j!=0 and i!=len(board)-1:\\n                    neighbours.append(board[i+1][j-1])\\n                \\n                if i !=0:\\n                    neighbours.append(board[i-1][j] % 2)\\n                if i != len(board)-1:\\n                    neighbours.append(board[i+1][j])\\n                if j !=0:\\n                    neighbours.append(board[i][j-1] % 2)\\n                if j!=len(board[0])-1:\\n                    neighbours.append(board[i][j+1])\\n                    \\n                oneCount = neighbours.count(1)\\n                if oneCount < 2:\\n                    board[i][j] = 0 if board[i][j]==0 else 1\\n                elif oneCount == 2:\\n                    board[i][j] = 0 if board[i][j]==0 else 3\\n                elif oneCount > 3:\\n                    board[i][j] = 0 if board[i][j]==0 else 1\\n                elif oneCount == 3:\\n                    board[i][j] = 2 if board[i][j]==0 else 3\\n            \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                board[i][j] = board[i][j] // 2\\n                \\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263002,
                "title": "easy-java-beats-100-simple-solution",
                "content": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int R = board.length;\\n        int C = board[0].length;\\n        int[] dx = {1,1,0,-1,-1,-1,0,1};\\n        int[] dy = {0,1,1,1,0,-1,-1,-1};\\n        \\n        for(int i=0; i< R; i++){\\n            for(int j=0; j< C; j++){\\n                int livesCount =0;\\n                for(int k=0; k<8; k++){\\n                    if(isSafe(i + dx[k], j + dy[k], R, C) && Math.abs(board[i + dx[k]][j + dy[k]]) == 1){\\n                        livesCount++;\\n                    }\\n                }\\n                if(board[i][j] ==0 && livesCount == 3){\\n                    board[i][j] =2;\\n                }\\n                if(board[i][j] == 1 && (livesCount <2 || livesCount >3)){\\n                    board[i][j] = -1;\\n                }\\n            }\\n        }\\n        for(int i=0; i< R; i++){\\n            for(int j=0; j< C; j++){\\n                board[i][j] = board[i][j] >0 ? 1: 0;\\n            }\\n        }\\n    }\\n    boolean isSafe(int x, int y, int R, int C){\\n        return (x >=0 && x<R && y>=0 && y<C);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void gameOfLife(int[][] board) {\\n        int R = board.length;\\n        int C = board[0].length;\\n        int[] dx = {1,1,0,-1,-1,-1,0,1}",
                "codeTag": "Java"
            },
            {
                "id": 1227196,
                "title": "java-100-faster-solution-with-o-1-extra-space",
                "content": "Since we have to calculate the next state in-place, let\\'s modify the existing board to store a special value that will help us determine the next state.\\n1. We are choosing -1 to represent the state where the existing value of board[i][j]==0 and it\\'s new state is 1. Here `negative` means that the existing value is 0. This will ensure that we don\\'t count this cell value while calculating the `liveNeighbourCount` for the neighbouring cells.\\n2. We are choosing 2 to represent the state where the existing value of board[i][j]==1 and the `liveNeighbourCount` is not 2 or 3. Here `positive` represents that the existing value of teh cell is 1, but it\\'s new state is 0.\\n3. Else, the cell value remains as it is.\\n```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int[][] directions = {{-1,0}, {1,0}, {0,1}, {0,-1}, {-1,-1}, {-1,1},\\n                            {1,-1}, {1,1}};\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        \\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                int liveNeighbourCount = 0;\\n                for(int[] d : directions){\\n                    int row = i+d[0];\\n                    int col = j+d[1];\\n                    if(row >= 0 && row < rows && col >= 0 && col < cols && board[row][col]>0){\\n                        liveNeighbourCount++;   \\n                    }\\n                }\\n                \\n                if(board[i][j] == 0 && liveNeighbourCount == 3){\\n                    board[i][j] = -1;\\n                }else if(board[i][j] == 1 && (liveNeighbourCount < 2 || liveNeighbourCount > 3)){\\n                    board[i][j] = 2;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(board[i][j] == -1){\\n                    board[i][j] = 1;\\n                }else if(board[i][j] == 2){\\n                    board[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int[][] directions = {{-1,0}, {1,0}, {0,1}, {0,-1}, {-1,-1}, {-1,1},\\n                            {1,-1}, {1,1}};\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        \\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                int liveNeighbourCount = 0;\\n                for(int[] d : directions){\\n                    int row = i+d[0];\\n                    int col = j+d[1];\\n                    if(row >= 0 && row < rows && col >= 0 && col < cols && board[row][col]>0){\\n                        liveNeighbourCount++;   \\n                    }\\n                }\\n                \\n                if(board[i][j] == 0 && liveNeighbourCount == 3){\\n                    board[i][j] = -1;\\n                }else if(board[i][j] == 1 && (liveNeighbourCount < 2 || liveNeighbourCount > 3)){\\n                    board[i][j] = 2;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(board[i][j] == -1){\\n                    board[i][j] = 1;\\n                }else if(board[i][j] == 2){\\n                    board[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166076,
                "title": "python-easy-clean-code-beats-98",
                "content": "1. In first pass, create neighbors matrix which holds the total number of neighbors of each cell\\n2. In second pass, apply the rules on current state of the board to create new state\\n\\n```\\nclass Solution:\\n    def gameOfLife(self, board: [[int]]) -> None:\\n        def neighbors_of_cell(x: int, y: int) -> int:\\n            left = board[x - 1][y] if x else 0\\n            right = board[x + 1][y] if x + 1 < m else 0\\n            up = board[x][y - 1] if y else 0\\n            down = board[x][y + 1] if y + 1 < n else 0\\n            left_up = board[x - 1][y - 1] if x and y else 0\\n            left_down = board[x - 1][y + 1] if x and y + 1 < n else 0\\n            right_up = board[x + 1][y - 1] if x + 1 < m and y else 0\\n            right_down = board[x + 1][y + 1] if x + 1 < m and y + 1 < n else 0\\n            return left + right + up + down + left_up + left_down + right_up + right_down\\n\\n        m = len(board)\\n        n = len(board[0])\\n        neighbors = [[0 for _ in range(n)] for _ in range(m)]  # represents live neighbors of each cell\\n\\n        for r in range(m):\\n            for c in range(n):\\n                neighbors[r][c] = neighbors_of_cell(r, c)\\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c]:  # live cell\\n                    if neighbors[r][c] > 3:  # over-population\\n                        board[r][c] = 0\\n                    elif neighbors[r][c] < 2:  # under-population\\n                        board[r][c] = 0\\n                else:  # dead cell\\n                    if neighbors[r][c] == 3:  # reproduction\\n                        board[r][c] = 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gameOfLife(self, board: [[int]]) -> None:\\n        def neighbors_of_cell(x: int, y: int) -> int:\\n            left = board[x - 1][y] if x else 0\\n            right = board[x + 1][y] if x + 1 < m else 0\\n            up = board[x][y - 1] if y else 0\\n            down = board[x][y + 1] if y + 1 < n else 0\\n            left_up = board[x - 1][y - 1] if x and y else 0\\n            left_down = board[x - 1][y + 1] if x and y + 1 < n else 0\\n            right_up = board[x + 1][y - 1] if x + 1 < m and y else 0\\n            right_down = board[x + 1][y + 1] if x + 1 < m and y + 1 < n else 0\\n            return left + right + up + down + left_up + left_down + right_up + right_down\\n\\n        m = len(board)\\n        n = len(board[0])\\n        neighbors = [[0 for _ in range(n)] for _ in range(m)]  # represents live neighbors of each cell\\n\\n        for r in range(m):\\n            for c in range(n):\\n                neighbors[r][c] = neighbors_of_cell(r, c)\\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c]:  # live cell\\n                    if neighbors[r][c] > 3:  # over-population\\n                        board[r][c] = 0\\n                    elif neighbors[r][c] < 2:  # under-population\\n                        board[r][c] = 0\\n                else:  # dead cell\\n                    if neighbors[r][c] == 3:  # reproduction\\n                        board[r][c] = 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994213,
                "title": "game-of-life-in-place-c-easy-solution",
                "content": "```\\n    void gameOfLife(vector<vector<int>>& board) {\\n//         using simple traversing\\n//         time O(8 * n * m) || space O(1) - inplace\\n        \\n//         logic:\\n//         turn 0 -> -1 (if we have 3 live neighbors)\\n//         turn 1 -> 2 (if we have < 2 live neighbors || we have > 3 live neighbors)\\n//         while traversing consider -1 as 0 and 2 as 1 for other live(1) and dead(0)\\n        \\n//         traverse again the board and change -1 -> 1 && 2 -> 0\\n        \\n        if(!board.size())\\n            return;\\n        \\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int r = 0; r < n; r++) {\\n            for(int c = 0; c < m; c++) {\\n                \\n                int liveN = getLiveNeighbors(r, c, board);\\n                if(board[r][c] == 1 && (liveN < 2 || liveN > 3))\\n                    board[r][c] = 2; // turn to 0(2)\\n                \\n                else if(board[r][c] == 0 && liveN == 3)\\n                    board[r][c] = -1; // turn to 1(-1)\\n            }\\n        }\\n        \\n        for(int r = 0; r < n; r++) {\\n            for(int c = 0; c < m; c++) {\\n                if(board[r][c] == 2)\\n                    board[r][c] = 0;\\n                else if(board[r][c] == -1)\\n                    board[r][c] = 1;\\n            }\\n        }\\n        \\n    }\\n    \\n    int getLiveNeighbors(int i, int j, vector<vector<int>> &b){\\n        \\n        int chi[] = {1, -1, 1, -1, -1, 0, 1,  0};\\n        int chj[] = {1, -1, -1, 1,  0, 1, 0, -1};\\n        int liveN = 0;\\n        for(int ch = 0; ch < 8; ch++) {\\n            if(valid(i + chi[ch], j + chj[ch], b.size(), b[0].size()) \\n               && \\n               (b[i+chi[ch]][j + chj[ch]] == 1 || b[i+chi[ch]][j + chj[ch]] == 2)\\n              )\\n                liveN += 1;\\n        }\\n        \\n        return liveN;\\n    }\\n    \\n    bool valid(int i, int j, int n, int m){\\n        if(i < 0 || i >= n || j < 0 || j >= m)\\n            return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    void gameOfLife(vector<vector<int>>& board) {\\n//         using simple traversing\\n//         time O(8 * n * m) || space O(1) - inplace\\n        \\n//         logic:\\n//         turn 0 -> -1 (if we have 3 live neighbors)\\n//         turn 1 -> 2 (if we have < 2 live neighbors || we have > 3 live neighbors)\\n//         while traversing consider -1 as 0 and 2 as 1 for other live(1) and dead(0)\\n        \\n//         traverse again the board and change -1 -> 1 && 2 -> 0\\n        \\n        if(!board.size())\\n            return;\\n        \\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int r = 0; r < n; r++) {\\n            for(int c = 0; c < m; c++) {\\n                \\n                int liveN = getLiveNeighbors(r, c, board);\\n                if(board[r][c] == 1 && (liveN < 2 || liveN > 3))\\n                    board[r][c] = 2; // turn to 0(2)\\n                \\n                else if(board[r][c] == 0 && liveN == 3)\\n                    board[r][c] = -1; // turn to 1(-1)\\n            }\\n        }\\n        \\n        for(int r = 0; r < n; r++) {\\n            for(int c = 0; c < m; c++) {\\n                if(board[r][c] == 2)\\n                    board[r][c] = 0;\\n                else if(board[r][c] == -1)\\n                    board[r][c] = 1;\\n            }\\n        }\\n        \\n    }\\n    \\n    int getLiveNeighbors(int i, int j, vector<vector<int>> &b){\\n        \\n        int chi[] = {1, -1, 1, -1, -1, 0, 1,  0};\\n        int chj[] = {1, -1, -1, 1,  0, 1, 0, -1};\\n        int liveN = 0;\\n        for(int ch = 0; ch < 8; ch++) {\\n            if(valid(i + chi[ch], j + chj[ch], b.size(), b[0].size()) \\n               && \\n               (b[i+chi[ch]][j + chj[ch]] == 1 || b[i+chi[ch]][j + chj[ch]] == 2)\\n              )\\n                liveN += 1;\\n        }\\n        \\n        return liveN;\\n    }\\n    \\n    bool valid(int i, int j, int n, int m){\\n        if(i < 0 || i >= n || j < 0 || j >= m)\\n            return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 994174,
                "title": "c-simulation-with-bit-manipulation",
                "content": "```\\nclass Solution { // Simulation with bit operation\\npublic: \\n    void gameOfLife(vector<vector<int>>& board) {\\n        const int m = board.size(), n = m == 0 ? 0: board[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++){\\n                //int lives=0-(board[i][j]&1); //(i,j) will be blindly included later, so deduct first\\n                int lives = 0;\\n                //int lives=0-board[i][j]&1; //err, Note1: the precedence of \\u2018&\\u2019 is lower than \\u2018-\\u2018\\n                for(int r = max(0, i - 1); r <= min(i+1, m-1); r++)\\n                    for(int c = max(0, j - 1); c <= min(j+1, n-1); c++)\\n                        lives += board[r][c]&1;                \\n                lives -= (board[i][j]&1);                \\n\\t\\t\\t\\tif((board[i][j]&1) == 1 && lives >=2 && lives <= 3) board[i][j] |= 0b10; // rule 2\\n                if((board[i][j]&1) == 0 && lives == 3) board[i][j] |= 0b10;   // rule 4\\n                // rule 1 & 3 leads to dead, which will be covered all-in-one in the final stage.\\n            }\\n        \\n        \\n        //for_each(board.begin(), board.end(), [](auto& e){for_each(e.begin(), e.end(), [](auto& i){ i >>= 1;});} ); // Ok but I dislike it        \\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                board[i][j] >>= 1;                \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { // Simulation with bit operation\\npublic: \\n    void gameOfLife(vector<vector<int>>& board) {\\n        const int m = board.size(), n = m == 0 ? 0: board[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++){\\n                //int lives=0-(board[i][j]&1); //(i,j) will be blindly included later, so deduct first\\n                int lives = 0;\\n                //int lives=0-board[i][j]&1; //err, Note1: the precedence of \\u2018&\\u2019 is lower than \\u2018-\\u2018\\n                for(int r = max(0, i - 1); r <= min(i+1, m-1); r++)\\n                    for(int c = max(0, j - 1); c <= min(j+1, n-1); c++)\\n                        lives += board[r][c]&1;                \\n                lives -= (board[i][j]&1);                \\n\\t\\t\\t\\tif((board[i][j]&1) == 1 && lives >=2 && lives <= 3) board[i][j] |= 0b10; // rule 2\\n                if((board[i][j]&1) == 0 && lives == 3) board[i][j] |= 0b10;   // rule 4\\n                // rule 1 & 3 leads to dead, which will be covered all-in-one in the final stage.\\n            }\\n        \\n        \\n        //for_each(board.begin(), board.end(), [](auto& e){for_each(e.begin(), e.end(), [](auto& i){ i >>= 1;});} ); // Ok but I dislike it        \\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                board[i][j] >>= 1;                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993794,
                "title": "c-in-place-vs-not-in-place-solutions-compared-and-explained-100-time-90-space",
                "content": "First of all, my first approach was to create a 2d array (much cheaper than a 2d vector) where I would store all the neighbours for each specific cell, then loop again to update board accordingly.\\n\\nTo do so, first of all we can declare `maxX` and `maxY` as class variables and update them in the very first line of our main code; luckily we know we will always get at least one column and at least one row, so no need to check for edge cases - usually just a boring chore!\\n\\nStill in the main function, we will then declare `neighbours`, our aforementioned 2d array, and move to fill it with a nested loop by `y` and `x`, calling `checkNeighbours` on each cell.\\n\\nThis helper function takes our original `board` (be sure to pass it as a reference!) and the 2 coordinates of the currently parsed cell to check for its neighbours with another nested loop.\\n\\nHere we will set `res` to be the opposite of the matching `board` value and then will go on for each dimension we will initially compute its starting value as the maximum between `0` and its current value `- 1` and the limit value (excluded) as the minimum as its current value `+ 2` and the coordinate specific maximum.\\n\\nSince we set `res` initially to be `-board[y][x]`, it means we will not count its own value and thus we can directly return it at the end of our helper.\\n\\nFinally, again with a nested loop by `y` and `x`, we will update `board`, setting each cell as live if it either was a dead one with exactly `neighbours[y][x] == 3` or if it was already alive and has `neighbours[y][x] > 1 && neighbours[y][x] < 4`, as per specs (and the famous classical rules); dead in every other case.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxX, maxY;\\n    int checkNeighbours(vector<vector<int>>& board, int x, int y) {\\n        // support variables\\n        int res = -board[y][x];\\n        // checking the neighbours\\n        for (int cy = max(0, y - 1), lmtY = min(maxY, y + 2); cy < lmtY; cy++) {\\n            for (int cx = max(0, x - 1), lmtX = min(maxX, x + 2); cx < lmtX; cx++) res += board[cy][cx];\\n        }\\n        return res;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        // updating class variables\\n        maxY = board.size(), maxX = board[0].size();\\n        // support variables\\n        int neighbours[maxY][maxX];\\n        // commputing neighbours\\n        for (int y = 0; y < maxY; y++) {\\n            for (int x = 0; x < maxX; x++) {\\n                neighbours[y][x] = checkNeighbours(board, x, y);\\n            }\\n        }\\n        // updating board\\n        for (int y = 0; y < maxY; y++) {\\n            for (int x = 0, currCell, currNeighbours; x < maxX; x++) {\\n                currCell = board[y][x];\\n                currNeighbours = neighbours[y][x];\\n                board[y][x] = !currCell && currNeighbours == 3 ||\\n                    currCell && currNeighbours > 1 && currNeighbours < 4;\\n            }\\n        }\\n    }\\n};\\n```\\n\\nAn alternate version, more in line with the functional programming craze popular these days, has more or less the same base logic, but instead of storing data in advance in `neighbours` to then update `board`, we create a completely new container `newBoard` (be sure to make it already of the right size - reallocations sting!) and populate it directly with the values the board will have at the next tick.\\n\\nFinally, we just overwrite `board` with `newBoard` using a single assignment instead of looping there again.\\n\\nThe code has more or less the same speed and burns a bit more memory - shame no larger test cases were given to see a possibly more marked difference in performance:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxX, maxY;\\n    int checkNeighbours(vector<vector<int>>& board, int x, int y) {\\n        // support variables\\n        int res = -board[y][x];\\n        // checking the neighbours\\n        for (int cy = max(0, y - 1), lmtY = min(maxY, y + 2); cy < lmtY; cy++) {\\n            for (int cx = max(0, x - 1), lmtX = min(maxX, x + 2); cx < lmtX; cx++) res += board[cy][cx];\\n        }\\n        return res;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        // updating class variables\\n        maxY = board.size(), maxX = board[0].size();\\n        // support variables\\n        vector<vector<int>> newBoard(maxY);\\n        // commputing newBoard\\n        for (int y = 0; y < maxY; y++) {\\n            newBoard[y] = vector<int>(maxX);\\n            for (int x = 0, currCell, currNeighbours; x < maxX; x++) {\\n                currCell = board[y][x];\\n                currNeighbours = checkNeighbours(board, x, y);\\n                newBoard[y][x] = !currCell && currNeighbours == 3 ||\\n                    currCell && currNeighbours > 1 && currNeighbours < 4;\\n            }\\n        }\\n        // updating board\\n        board = newBoard;\\n    }\\n};\\n```\\n\\nFor the very last version, we adapt the first solution so that instead of having an external array (`neighbours`) we mark the existing `board` in place, with resurrecting cells getting a `-1` value and dying cells getting a `2` so that in `checkNeighbours` we can just check for values `> 0` as currently alive and in a second loop we can convert the marked one to a proper value in the usual `0 - 1` range.\\n\\nThis approach does not seem to have any peculiar gain in terms of performance, but again it might just be due to working on relatively small matrixes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxX, maxY;\\n    int checkNeighbours(vector<vector<int>>& board, int x, int y) {\\n        // support variables\\n        int res = -(board[y][x] > 0);\\n        // checking the neighbours\\n        for (int cy = max(0, y - 1), lmtY = min(maxY, y + 2); cy < lmtY; cy++) {\\n            for (int cx = max(0, x - 1), lmtX = min(maxX, x + 2); cx < lmtX; cx++) res += board[cy][cx] > 0;\\n        }\\n        return res;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        // updating class variables\\n        maxY = board.size(), maxX = board[0].size();\\n        // commputing newBoard\\n        for (int y = 0; y < maxY; y++) {\\n            for (int x = 0, currCell, currNeighbours; x < maxX; x++) {\\n                currCell = board[y][x];\\n                currNeighbours = checkNeighbours(board, x, y);\\n                // marking resurrecting cells with -1 and dying cells with 2\\n                board[y][x] = !currCell && currNeighbours == 3 ? -1 :\\n                    currCell && (currNeighbours < 2 || currNeighbours > 3) ? 2 : currCell;\\n            }\\n        }\\n        // updating board\\n        for (int y = 0; y < maxY; y++) {\\n            for (int x = 0, currCell; x < maxX; x++) {\\n                currCell = board[y][x];\\n                board[y][x] = currCell == -1 ? 1 : currCell == 2 ? 0 : currCell;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxX, maxY;\\n    int checkNeighbours(vector<vector<int>>& board, int x, int y) {\\n        // support variables\\n        int res = -board[y][x];\\n        // checking the neighbours\\n        for (int cy = max(0, y - 1), lmtY = min(maxY, y + 2); cy < lmtY; cy++) {\\n            for (int cx = max(0, x - 1), lmtX = min(maxX, x + 2); cx < lmtX; cx++) res += board[cy][cx];\\n        }\\n        return res;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        // updating class variables\\n        maxY = board.size(), maxX = board[0].size();\\n        // support variables\\n        int neighbours[maxY][maxX];\\n        // commputing neighbours\\n        for (int y = 0; y < maxY; y++) {\\n            for (int x = 0; x < maxX; x++) {\\n                neighbours[y][x] = checkNeighbours(board, x, y);\\n            }\\n        }\\n        // updating board\\n        for (int y = 0; y < maxY; y++) {\\n            for (int x = 0, currCell, currNeighbours; x < maxX; x++) {\\n                currCell = board[y][x];\\n                currNeighbours = neighbours[y][x];\\n                board[y][x] = !currCell && currNeighbours == 3 ||\\n                    currCell && currNeighbours > 1 && currNeighbours < 4;\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxX, maxY;\\n    int checkNeighbours(vector<vector<int>>& board, int x, int y) {\\n        // support variables\\n        int res = -board[y][x];\\n        // checking the neighbours\\n        for (int cy = max(0, y - 1), lmtY = min(maxY, y + 2); cy < lmtY; cy++) {\\n            for (int cx = max(0, x - 1), lmtX = min(maxX, x + 2); cx < lmtX; cx++) res += board[cy][cx];\\n        }\\n        return res;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        // updating class variables\\n        maxY = board.size(), maxX = board[0].size();\\n        // support variables\\n        vector<vector<int>> newBoard(maxY);\\n        // commputing newBoard\\n        for (int y = 0; y < maxY; y++) {\\n            newBoard[y] = vector<int>(maxX);\\n            for (int x = 0, currCell, currNeighbours; x < maxX; x++) {\\n                currCell = board[y][x];\\n                currNeighbours = checkNeighbours(board, x, y);\\n                newBoard[y][x] = !currCell && currNeighbours == 3 ||\\n                    currCell && currNeighbours > 1 && currNeighbours < 4;\\n            }\\n        }\\n        // updating board\\n        board = newBoard;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxX, maxY;\\n    int checkNeighbours(vector<vector<int>>& board, int x, int y) {\\n        // support variables\\n        int res = -(board[y][x] > 0);\\n        // checking the neighbours\\n        for (int cy = max(0, y - 1), lmtY = min(maxY, y + 2); cy < lmtY; cy++) {\\n            for (int cx = max(0, x - 1), lmtX = min(maxX, x + 2); cx < lmtX; cx++) res += board[cy][cx] > 0;\\n        }\\n        return res;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        // updating class variables\\n        maxY = board.size(), maxX = board[0].size();\\n        // commputing newBoard\\n        for (int y = 0; y < maxY; y++) {\\n            for (int x = 0, currCell, currNeighbours; x < maxX; x++) {\\n                currCell = board[y][x];\\n                currNeighbours = checkNeighbours(board, x, y);\\n                // marking resurrecting cells with -1 and dying cells with 2\\n                board[y][x] = !currCell && currNeighbours == 3 ? -1 :\\n                    currCell && (currNeighbours < 2 || currNeighbours > 3) ? 2 : currCell;\\n            }\\n        }\\n        // updating board\\n        for (int y = 0; y < maxY; y++) {\\n            for (int x = 0, currCell; x < maxX; x++) {\\n                currCell = board[y][x];\\n                board[y][x] = currCell == -1 ? 1 : currCell == 2 ? 0 : currCell;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572405,
                "title": "java-o-n-inplace-solution",
                "content": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        for (int i=0;i<board.length;i++){\\n            for (int j=0;j<board[i].length;j++){\\n                int aliveNeighbours = 0;\\n                    if (j>0)aliveNeighbours += board[i][j-1];\\n                    if (i>0)aliveNeighbours += board[i-1][j];\\n                    if (i<board.length-1)aliveNeighbours += board[i+1][j];\\n                    if (j<board[i].length-1)aliveNeighbours += board[i][j+1];\\n                    if (j>0 && i>0)aliveNeighbours+=board[i-1][j-1];\\n                    if (j>0 && i<board.length-1)aliveNeighbours+=board[i+1][j-1];\\n                    if (i>0 && j<board[i].length-1)aliveNeighbours+=board[i-1][j+1];\\n                    if (i<board.length-1 && j<board[i].length-1)aliveNeighbours+=board[i+1][j+1];\\n                \\n                aliveNeighbours%=10;\\n                int isAlive=0;\\n                if (aliveNeighbours<2 || aliveNeighbours>3)isAlive = 0;\\n                else if (aliveNeighbours==3)isAlive = 1;\\n                else isAlive = board[i][j];\\n                board[i][j]+=10*isAlive;\\n            }\\n        }\\n        \\n        for (int i=0;i<board.length;i++)\\n           for (int j=0;j<board[i].length;j++)board[i][j]/=10;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        for (int i=0;i<board.length;i++){\\n            for (int j=0;j<board[i].length;j++){\\n                int aliveNeighbours = 0;\\n                    if (j>0)aliveNeighbours += board[i][j-1];\\n                    if (i>0)aliveNeighbours += board[i-1][j];\\n                    if (i<board.length-1)aliveNeighbours += board[i+1][j];\\n                    if (j<board[i].length-1)aliveNeighbours += board[i][j+1];\\n                    if (j>0 && i>0)aliveNeighbours+=board[i-1][j-1];\\n                    if (j>0 && i<board.length-1)aliveNeighbours+=board[i+1][j-1];\\n                    if (i>0 && j<board[i].length-1)aliveNeighbours+=board[i-1][j+1];\\n                    if (i<board.length-1 && j<board[i].length-1)aliveNeighbours+=board[i+1][j+1];\\n                \\n                aliveNeighbours%=10;\\n                int isAlive=0;\\n                if (aliveNeighbours<2 || aliveNeighbours>3)isAlive = 0;\\n                else if (aliveNeighbours==3)isAlive = 1;\\n                else isAlive = board[i][j];\\n                board[i][j]+=10*isAlive;\\n            }\\n        }\\n        \\n        for (int i=0;i<board.length;i++)\\n           for (int j=0;j<board[i].length;j++)board[i][j]/=10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516894,
                "title": "python-3-in-place-o-m-n-runtime-28ms",
                "content": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        # 0 -> 0 status = 0\\n        # 1 -> 1 status = 1\\n        # 1 -> 0 status = 2\\n        # 0 -> 1 status = 3\\n        m, n = len(board), len(board[0])\\n        directions = [(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\\n        for x in range(m):\\n            for y in range(n):\\n                lives = 0\\n                for dx, dy in directions:\\n                    nx = x + dx\\n                    ny = y + dy\\n                    if 0<=nx<m and 0<=ny<n and (board[nx][ny] == 1 or board[nx][ny] == 2) :\\n                        lives+=1\\n\\n                if board[x][y] == 0 and lives==3:\\n                    board[x][y] = 3\\n                elif board[x][y] == 1 and (lives<2 or lives>3):\\n                    board[x][y] = 2\\n        for x in range(m):\\n            for y in range(n):\\n                board[x][y] = board[x][y]%2\\n        return board\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        # 0 -> 0 status = 0\\n        # 1 -> 1 status = 1\\n        # 1 -> 0 status = 2\\n        # 0 -> 1 status = 3\\n        m, n = len(board), len(board[0])\\n        directions = [(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]\\n        for x in range(m):\\n            for y in range(n):\\n                lives = 0\\n                for dx, dy in directions:\\n                    nx = x + dx\\n                    ny = y + dy\\n                    if 0<=nx<m and 0<=ny<n and (board[nx][ny] == 1 or board[nx][ny] == 2) :\\n                        lives+=1\\n\\n                if board[x][y] == 0 and lives==3:\\n                    board[x][y] = 3\\n                elif board[x][y] == 1 and (lives<2 or lives>3):\\n                    board[x][y] = 2\\n        for x in range(m):\\n            for y in range(n):\\n                board[x][y] = board[x][y]%2\\n        return board\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250584,
                "title": "python-in-place-solution-using-bit-manipulation-with-explanation",
                "content": "The basic idea is to store the updated value in higher bit.\\nlower bit represents current value and higher bit represents updated value.\\nWhen current value is 0 and updated value is 0 -> 00\\nWhen current value is 0 and updated value is 1 -> 10\\nWhen current value is 1 and updated value is 0 -> 01\\nWhen current value is 1 and updated value is 1 -> 11\\nThis way,  value&1 it will always give current value since that is the lower bit! \\n\\nThe first iteration over the matrix is used to update the values.\\nAnd we right shift the value by 1 so as to get the updated value in the next iteration.\\n\\n```\\n        m = len(board)\\n        n = len(board[0])\\n        for i in range(0,m):\\n            for j in range(0,n):\\n                count =0 \\n                indices = [(i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1)]\\n                for r,c in indices:\\n                    if 0<=r<m and 0<=c<n:\\n                        if board[r][c] & 1:\\n                            count+=1\\n                            \\n                if board[i][j] == 1:\\n                    if count < 2 or count >3:\\n                        continue\\n                    else:\\n                        board[i][j]|=2\\n                else:\\n                    if count == 3:\\n                        board[i][j] |=2\\n        \\n        for i in range(0,m):\\n            for j in range(0,n):\\n                board[i][j] = board[i][j] >> 1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "The basic idea is to store the updated value in higher bit.\\nlower bit represents current value and higher bit represents updated value.\\nWhen current value is 0 and updated value is 0 -> 00\\nWhen current value is 0 and updated value is 1 -> 10\\nWhen current value is 1 and updated value is 0 -> 01\\nWhen current value is 1 and updated value is 1 -> 11\\nThis way,  value&1 it will always give current value since that is the lower bit! \\n\\nThe first iteration over the matrix is used to update the values.\\nAnd we right shift the value by 1 so as to get the updated value in the next iteration.\\n\\n```\\n        m = len(board)\\n        n = len(board[0])\\n        for i in range(0,m):\\n            for j in range(0,n):\\n                count =0 \\n                indices = [(i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1)]\\n                for r,c in indices:\\n                    if 0<=r<m and 0<=c<n:\\n                        if board[r][c] & 1:\\n                            count+=1\\n                            \\n                if board[i][j] == 1:\\n                    if count < 2 or count >3:\\n                        continue\\n                    else:\\n                        board[i][j]|=2\\n                else:\\n                    if count == 3:\\n                        board[i][j] |=2\\n        \\n        for i in range(0,m):\\n            for j in range(0,n):\\n                board[i][j] = board[i][j] >> 1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 73262,
                "title": "one-pass-java-solution-with-explanations",
                "content": "We tried to solve the problem with one pass and O(1) space consumption. The code is so long that it doesn't run though.\\n\\nThe basic idea is:\\nIf the original state is 1\\n    If it will be 1, it is temporarily set to 1 and will forever be 1.\\n    If it will be 0, it is temporarily set to -5 and will become 0 at some point.\\nIf the original state is 0\\n    If it will be 1, it is temporarily set to 5 and will become 1 at some point.\\n    If it will be 0, it is temporarily set to 0 and will forever be 0.\\n\\nSo when do we change the 5s and -5s back to 1 and 0? The idea is when we iterate through the array row by row and col by col, a cell will never be used to determine the next state of another cell when we go past the cell to the south east of it. So each time we deal with a cell, we change the cell to its north west back to 0 or 1.\\n\\nThere is border conditions to be dealt with, so the code is quite long.\\n\\n```\\npublic class Solution {\\n    public void gameOfLife(int[][] board) {\\n        int numRows = board.length;\\n        int numCols = board[0].length;\\n        \\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = 0; j < numCols; j++) {\\n                if (i == numRows - 1) {\\n                    if (i == 0) {\\n                        if (j == numCols - 1) {\\n                            if (j == 0) continue;\\n                            if (board[i][j] == 0) {\\n                                switch(board[i][j - 1]) {\\n                                    case 5:\\n                                        board[i][j - 1] = 1;\\n                                        break;\\n                                    case 0:\\n                                        break;\\n                                    case 1:\\n                                        break;\\n                                    case -5:\\n                                        board[i][j - 1] = 0;\\n                                        break;\\n                                }\\n                            } else {\\n                                switch(board[i][j - 1]) {\\n                                    case 5:\\n                                        board[i][j] = 0;\\n                                        board[i][j - 1] = 1;\\n                                        break;\\n                                    case 0:\\n                                        board[i][j] = 0;\\n                                        break;\\n                                    case 1:\\n                                        board[i][j] = 0;\\n                                        break;\\n                                    case -5:\\n                                        board[i][j] = 0;\\n                                        board[i][j - 1] = 0;\\n                                        break;\\n                                    default:\\n                                        break;\\n                                }\\n                            }\\n                        } else if (j == 0) {\\n                            if (board[i][j] == 1) board[i][j] = -5;\\n                        } else {\\n                            if (board[i][j] == 1) {\\n                                int liveNeighborCount = 0;\\n                                if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                                if (board[i][j + 1] == 1) liveNeighborCount++;\\n                                \\n                                switch(liveNeighborCount) {\\n                                    case 2:\\n                                        board[i][j] = 1;\\n                                        break;\\n                                    default:\\n                                        board[i][j] = -5;\\n                                        break;\\n                                }\\n                                \\n                                if (board[i][j - 1] == 5) board[i][j - 1] = 1;\\n                                if (board[i][j - 1] == -5) board[i][j - 1] = 0;\\n                            }\\n                        }\\n                    } else {\\n                        if (j == numCols - 1) {\\n                            if (j == 0) {\\n                                board[i][j] = 0;\\n                                \\n                                if (board[i - 1][j] == 5) board[i - 1][j] = 1;\\n                                if (board[i - 1][j] == -5) board[i - 1][j] = 0;\\n                            } else {\\n                                int liveNeighborCount = 0;\\n                                \\n                                if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                                if (board[i - 1][j - 1] == 1 || board[i - 1][j - 1] == 5) liveNeighborCount++;\\n                                if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                                \\n                                switch(liveNeighborCount) {\\n                                    case 0:\\n                                        if (board[i][j] == 1) board[i][j] = 0;\\n                                        break;\\n                                    case 1:\\n                                        if (board[i][j] == 1) board[i][j] = 0;\\n                                        break;\\n                                    case 3:\\n                                        if (board[i][j] == 0) board[i][j] = 1;\\n                                    default:\\n                                        break;\\n                                }\\n                                \\n                                if (board[i][j - 1] == 5) board[i][j - 1] = 1;\\n                                if (board[i][j - 1] == -5) board[i][j - 1] = 0;\\n                                if (board[i - 1][j - 1] == 5) board[i - 1][j - 1] = 1;\\n                                if (board[i - 1][j - 1] == -5) board[i - 1][j - 1] = 0;\\n                                if (board[i - 1][j] == 5) board[i - 1][j] = 1;\\n                                if (board[i - 1][j] == -5) board[i - 1][j] = 0;\\n                            }\\n                        } else if (j == 0) {\\n                            int liveNeighborCount = 0;\\n                            \\n                            if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                            if (board[i - 1][j + 1] == 1 || board[i - 1][j + 1] == 5) liveNeighborCount++;\\n                            if (board[i][j + 1] == 1) liveNeighborCount++;\\n                            \\n                            switch(liveNeighborCount) {\\n                                case 0:\\n                                    if (board[i][j] == 1) board[i][j] = -5;\\n                                    break;\\n                                case 1:\\n                                    if (board[i][j] == 1) board[i][j] = -5;\\n                                    break;\\n                                case 3:\\n                                    if (board[i][j] == 0) board[i][j] = 5;\\n                                default:\\n                                    break;\\n                            }\\n                        } else {\\n                            int liveNeighborCount = 0;\\n                            \\n                            if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                            if (board[i - 1][j - 1] == 1 || board[i - 1][j - 1] == 5) liveNeighborCount++;\\n                            if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                            if (board[i - 1][j + 1] == 1 || board[i - 1][j + 1] == 5) liveNeighborCount++;\\n                            if (board[i][j + 1] == 1) liveNeighborCount++;\\n                            \\n                            if (liveNeighborCount < 2 || liveNeighborCount > 3) if (board[i][j] == 1) board[i][j] = -5;\\n                            if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                            \\n                            if (board[i][j - 1] == 5) board[i][j - 1] = 1;\\n                            if (board[i][j - 1] == -5) board[i][j - 1] = 0;\\n                            if (board[i - 1][j - 1] == 5) board[i - 1][j - 1] = 1;\\n                            if (board[i - 1][j - 1] == -5) board[i - 1][j - 1] = 0;\\n                        }\\n                    }\\n                } else if (i == 0) {\\n                    if (j == numCols - 1) {\\n                        if (j == 0) {\\n                            if (board[i][j] == 1) board[i][j] = -5;\\n                        } else {\\n                            int liveNeighborCount = 0;\\n                            \\n                            if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                            if (board[i + 1][j - 1] == 1) liveNeighborCount++;\\n                            if (board[i + 1][j] == 1) liveNeighborCount++;\\n                            \\n                            if (liveNeighborCount < 2) if (board[i][j] == 1) board[i][j] = -5;\\n                            if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                        }\\n                    } else if (j == 0) {\\n                        int liveNeighborCount = 0;\\n                        \\n                        if (board[i][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j] == 1) liveNeighborCount++;\\n                        \\n                        if (liveNeighborCount < 2) if (board[i][j] == 1) board[i][j] = -5;\\n                        if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                    } else {\\n                        int liveNeighborCount = 0;\\n                        \\n                        if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                        if (board[i + 1][j - 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i][j + 1] == 1) liveNeighborCount++;\\n                        \\n                        if (liveNeighborCount < 2 || liveNeighborCount > 3) if (board[i][j] == 1) board[i][j] = -5;\\n                        if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                    }\\n                } else {\\n                    if (j == numCols - 1) {\\n                        if (j == 0) {\\n                            int liveNeighborCount = 0;\\n                            \\n                            if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                            if (board[i + 1][j] == 1) liveNeighborCount++;\\n                            \\n                            if (liveNeighborCount < 2) if (board[i][j] == 1) board[i][j] = -5;\\n                            \\n                            if (board[i - 1][j] == 5) board[i - 1][j - 1] = 1;\\n                            if (board[i - 1][j] == -5) board[i - 1][j - 1] = 0;\\n                        } else {\\n                            int liveNeighborCount = 0;\\n                            \\n                            if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                            if (board[i - 1][j - 1] == 1 || board[i - 1][j - 1] == 5) liveNeighborCount++;\\n                            if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                            if (board[i + 1][j - 1] == 1) liveNeighborCount++;\\n                            if (board[i + 1][j ] == 1) liveNeighborCount++;\\n                            \\n                            if (liveNeighborCount < 2 || liveNeighborCount > 3) if (board[i][j] == 1) board[i][j] = -5;\\n                            if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                            \\n                            if (board[i - 1][j - 1] == 5) board[i][j - 1] = 1;\\n                            if (board[i - 1][j - 1] == -5) board[i][j - 1] = 0;\\n                            if (board[i - 1][j] == 5) board[i - 1][j - 1] = 1;\\n                            if (board[i - 1][j] == -5) board[i - 1][j - 1] = 0;\\n                        }\\n                    } else if (j == 0) {\\n                        int liveNeighborCount = 0;\\n                        \\n                        if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                        if (board[i - 1][j + 1] == 1|| board[i - 1][j + 1] == 5) liveNeighborCount++;\\n                        if (board[i][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j] == 1) liveNeighborCount++;\\n                        \\n                        if (liveNeighborCount < 2 || liveNeighborCount > 3) if (board[i][j] == 1) board[i][j] = -5;\\n                        if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                    } else {\\n                        int liveNeighborCount = 0;\\n                        \\n                        if (board[i - 1][j - 1] == 1 || board[i - 1][j - 1] == 5) liveNeighborCount++;\\n                        if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                        if (board[i - 1][j + 1] == 1|| board[i - 1][j + 1] == 5) liveNeighborCount++;\\n                        if (board[i][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j - 1] == 1) liveNeighborCount++;\\n                        if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                        \\n                        if (liveNeighborCount < 2 || liveNeighborCount > 3) if (board[i][j] == 1) board[i][j] = -5;\\n                        if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                        \\n                        if (board[i - 1][j - 1] == 5) board[i - 1][j - 1] = 1;\\n                        if (board[i - 1][j - 1] == -5) board[i - 1][j - 1] = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void gameOfLife(int[][] board) {\\n        int numRows = board.length;\\n        int numCols = board[0].length;\\n        \\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = 0; j < numCols; j++) {\\n                if (i == numRows - 1) {\\n                    if (i == 0) {\\n                        if (j == numCols - 1) {\\n                            if (j == 0) continue;\\n                            if (board[i][j] == 0) {\\n                                switch(board[i][j - 1]) {\\n                                    case 5:\\n                                        board[i][j - 1] = 1;\\n                                        break;\\n                                    case 0:\\n                                        break;\\n                                    case 1:\\n                                        break;\\n                                    case -5:\\n                                        board[i][j - 1] = 0;\\n                                        break;\\n                                }\\n                            } else {\\n                                switch(board[i][j - 1]) {\\n                                    case 5:\\n                                        board[i][j] = 0;\\n                                        board[i][j - 1] = 1;\\n                                        break;\\n                                    case 0:\\n                                        board[i][j] = 0;\\n                                        break;\\n                                    case 1:\\n                                        board[i][j] = 0;\\n                                        break;\\n                                    case -5:\\n                                        board[i][j] = 0;\\n                                        board[i][j - 1] = 0;\\n                                        break;\\n                                    default:\\n                                        break;\\n                                }\\n                            }\\n                        } else if (j == 0) {\\n                            if (board[i][j] == 1) board[i][j] = -5;\\n                        } else {\\n                            if (board[i][j] == 1) {\\n                                int liveNeighborCount = 0;\\n                                if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                                if (board[i][j + 1] == 1) liveNeighborCount++;\\n                                \\n                                switch(liveNeighborCount) {\\n                                    case 2:\\n                                        board[i][j] = 1;\\n                                        break;\\n                                    default:\\n                                        board[i][j] = -5;\\n                                        break;\\n                                }\\n                                \\n                                if (board[i][j - 1] == 5) board[i][j - 1] = 1;\\n                                if (board[i][j - 1] == -5) board[i][j - 1] = 0;\\n                            }\\n                        }\\n                    } else {\\n                        if (j == numCols - 1) {\\n                            if (j == 0) {\\n                                board[i][j] = 0;\\n                                \\n                                if (board[i - 1][j] == 5) board[i - 1][j] = 1;\\n                                if (board[i - 1][j] == -5) board[i - 1][j] = 0;\\n                            } else {\\n                                int liveNeighborCount = 0;\\n                                \\n                                if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                                if (board[i - 1][j - 1] == 1 || board[i - 1][j - 1] == 5) liveNeighborCount++;\\n                                if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                                \\n                                switch(liveNeighborCount) {\\n                                    case 0:\\n                                        if (board[i][j] == 1) board[i][j] = 0;\\n                                        break;\\n                                    case 1:\\n                                        if (board[i][j] == 1) board[i][j] = 0;\\n                                        break;\\n                                    case 3:\\n                                        if (board[i][j] == 0) board[i][j] = 1;\\n                                    default:\\n                                        break;\\n                                }\\n                                \\n                                if (board[i][j - 1] == 5) board[i][j - 1] = 1;\\n                                if (board[i][j - 1] == -5) board[i][j - 1] = 0;\\n                                if (board[i - 1][j - 1] == 5) board[i - 1][j - 1] = 1;\\n                                if (board[i - 1][j - 1] == -5) board[i - 1][j - 1] = 0;\\n                                if (board[i - 1][j] == 5) board[i - 1][j] = 1;\\n                                if (board[i - 1][j] == -5) board[i - 1][j] = 0;\\n                            }\\n                        } else if (j == 0) {\\n                            int liveNeighborCount = 0;\\n                            \\n                            if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                            if (board[i - 1][j + 1] == 1 || board[i - 1][j + 1] == 5) liveNeighborCount++;\\n                            if (board[i][j + 1] == 1) liveNeighborCount++;\\n                            \\n                            switch(liveNeighborCount) {\\n                                case 0:\\n                                    if (board[i][j] == 1) board[i][j] = -5;\\n                                    break;\\n                                case 1:\\n                                    if (board[i][j] == 1) board[i][j] = -5;\\n                                    break;\\n                                case 3:\\n                                    if (board[i][j] == 0) board[i][j] = 5;\\n                                default:\\n                                    break;\\n                            }\\n                        } else {\\n                            int liveNeighborCount = 0;\\n                            \\n                            if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                            if (board[i - 1][j - 1] == 1 || board[i - 1][j - 1] == 5) liveNeighborCount++;\\n                            if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                            if (board[i - 1][j + 1] == 1 || board[i - 1][j + 1] == 5) liveNeighborCount++;\\n                            if (board[i][j + 1] == 1) liveNeighborCount++;\\n                            \\n                            if (liveNeighborCount < 2 || liveNeighborCount > 3) if (board[i][j] == 1) board[i][j] = -5;\\n                            if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                            \\n                            if (board[i][j - 1] == 5) board[i][j - 1] = 1;\\n                            if (board[i][j - 1] == -5) board[i][j - 1] = 0;\\n                            if (board[i - 1][j - 1] == 5) board[i - 1][j - 1] = 1;\\n                            if (board[i - 1][j - 1] == -5) board[i - 1][j - 1] = 0;\\n                        }\\n                    }\\n                } else if (i == 0) {\\n                    if (j == numCols - 1) {\\n                        if (j == 0) {\\n                            if (board[i][j] == 1) board[i][j] = -5;\\n                        } else {\\n                            int liveNeighborCount = 0;\\n                            \\n                            if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                            if (board[i + 1][j - 1] == 1) liveNeighborCount++;\\n                            if (board[i + 1][j] == 1) liveNeighborCount++;\\n                            \\n                            if (liveNeighborCount < 2) if (board[i][j] == 1) board[i][j] = -5;\\n                            if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                        }\\n                    } else if (j == 0) {\\n                        int liveNeighborCount = 0;\\n                        \\n                        if (board[i][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j] == 1) liveNeighborCount++;\\n                        \\n                        if (liveNeighborCount < 2) if (board[i][j] == 1) board[i][j] = -5;\\n                        if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                    } else {\\n                        int liveNeighborCount = 0;\\n                        \\n                        if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                        if (board[i + 1][j - 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i][j + 1] == 1) liveNeighborCount++;\\n                        \\n                        if (liveNeighborCount < 2 || liveNeighborCount > 3) if (board[i][j] == 1) board[i][j] = -5;\\n                        if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                    }\\n                } else {\\n                    if (j == numCols - 1) {\\n                        if (j == 0) {\\n                            int liveNeighborCount = 0;\\n                            \\n                            if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                            if (board[i + 1][j] == 1) liveNeighborCount++;\\n                            \\n                            if (liveNeighborCount < 2) if (board[i][j] == 1) board[i][j] = -5;\\n                            \\n                            if (board[i - 1][j] == 5) board[i - 1][j - 1] = 1;\\n                            if (board[i - 1][j] == -5) board[i - 1][j - 1] = 0;\\n                        } else {\\n                            int liveNeighborCount = 0;\\n                            \\n                            if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                            if (board[i - 1][j - 1] == 1 || board[i - 1][j - 1] == 5) liveNeighborCount++;\\n                            if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                            if (board[i + 1][j - 1] == 1) liveNeighborCount++;\\n                            if (board[i + 1][j ] == 1) liveNeighborCount++;\\n                            \\n                            if (liveNeighborCount < 2 || liveNeighborCount > 3) if (board[i][j] == 1) board[i][j] = -5;\\n                            if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                            \\n                            if (board[i - 1][j - 1] == 5) board[i][j - 1] = 1;\\n                            if (board[i - 1][j - 1] == -5) board[i][j - 1] = 0;\\n                            if (board[i - 1][j] == 5) board[i - 1][j - 1] = 1;\\n                            if (board[i - 1][j] == -5) board[i - 1][j - 1] = 0;\\n                        }\\n                    } else if (j == 0) {\\n                        int liveNeighborCount = 0;\\n                        \\n                        if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                        if (board[i - 1][j + 1] == 1|| board[i - 1][j + 1] == 5) liveNeighborCount++;\\n                        if (board[i][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j] == 1) liveNeighborCount++;\\n                        \\n                        if (liveNeighborCount < 2 || liveNeighborCount > 3) if (board[i][j] == 1) board[i][j] = -5;\\n                        if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                    } else {\\n                        int liveNeighborCount = 0;\\n                        \\n                        if (board[i - 1][j - 1] == 1 || board[i - 1][j - 1] == 5) liveNeighborCount++;\\n                        if (board[i - 1][j] == 1 || board[i - 1][j] == 5) liveNeighborCount++;\\n                        if (board[i - 1][j + 1] == 1|| board[i - 1][j + 1] == 5) liveNeighborCount++;\\n                        if (board[i][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j + 1] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j] == 1) liveNeighborCount++;\\n                        if (board[i + 1][j - 1] == 1) liveNeighborCount++;\\n                        if (board[i][j - 1] == 1 || board[i][j - 1] == 5) liveNeighborCount++;\\n                        \\n                        if (liveNeighborCount < 2 || liveNeighborCount > 3) if (board[i][j] == 1) board[i][j] = -5;\\n                        if (liveNeighborCount == 3) if (board[i][j] == 0) board[i][j] = 5;\\n                        \\n                        if (board[i - 1][j - 1] == 5) board[i - 1][j - 1] = 1;\\n                        if (board[i - 1][j - 1] == -5) board[i - 1][j - 1] = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73315,
                "title": "a-c-solution-using-bitmap-method",
                "content": "The method of the this solution is to use the bits to mark down the number of live cells around.\\nThe first bit of board[i][j] is to record whether board[i][j] is one. If board[i][j]==0, that bit is 0, otherwise that bit is set to 1.\\nAnd if one 'neighbour' of board[i][j] is 1, an additional bit of board[i][j] would be set to 1. In the end, we can judge whether board[i][j] is 0 or 1 initially by the first bit of board[i][j], and we can judge the number of live neighbour live cell by the number of addtional non-zero bit of board[i][j].\\n\\n    class Solution {\\n    public:\\n    void gameOfLife(vector<vector<int> >& board) {\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                int ptr=1;\\n                for(int k=0;k<8;k++)\\n                {\\n                    int curx=i+dirx[k],cury=j+diry[k];\\n                    if(curx<0||curx>=board.size()||cury<0||cury>=board[0].size()) continue;\\n                    if(board[curx][cury]&1) board[i][j]|=(1<<(ptr++));\\n                }\\n            }\\n        }\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]&1)//if board[i][j] is 1 initially\\n                {\\n                    if(board[i][j]<Twy||board[i][j]>Thwy) board[i][j]=0;//judge the number of the live neighbour bit\\n                    else board[i][j]=1;\\n                }\\n                else//0 initially\\n                {\\n                    if(board[i][j]==Thwn) board[i][j]=1;//three live neighbour cells\\n                    else board[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n    private:\\n    int dirx[8]={0,0,1,1,1,-1,-1,-1};\\n    int diry[8]={1,-1,-1,1,0,-1,1,0};\\n    const int Thwn=14,Twn=6,Thwy=15,Twy=7;//some constants to judge the number of live neighbour cell\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    void gameOfLife(vector<vector<int> >& board) {\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                int ptr=1;\\n                for(int k=0;k<8;k++)\\n                {\\n                    int curx=i+dirx[k],cury=j+diry[k];\\n                    if(curx<0||curx>=board.size()||cury<0||cury>=board[0].size()) continue;\\n                    if(board[curx][cury]&1) board[i][j]|=(1<<(ptr++));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 73321,
                "title": "c-implementation",
                "content": "Why can not use \\n        \\n             count+=board[ss][tt]&1;\\n   \\nAccording the Def of the problem, we know that if the around live count = 3, all the node will live on.\\n\\nBut if the count = 2, only the live node will keep live. All the other cases will become dead.\\n\\n\\n    class Solution {\\n    public:\\n        void gameOfLife(vector<vector<int>>& board) {\\n            int m=board.size(), n=m?board[0].size():0;\\n            for(int i=0; i<m; i++){\\n                for(int j=0; j<n; j++){\\n                    int count=0;\\n                    for(int ss=max(i-1, 0); ss<min(i+2, m); ss++){\\n                        for(int tt=max(j-1, 0); tt<min(j+2, n); tt++){\\n                            count+=board[ss][tt]&1;\\n                        }\\n                    }\\n                    count-=board[i][j];\\n                    \\n                    if(count==3 || (board[i][j]&&count==2))\\n                        board[i][j]|=2;\\n                }\\n            }\\n            \\n            for(int i=0; i<m; i++)\\n                for(int j=0; j<n; j++)\\n                    board[i][j]>>=1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void gameOfLife(vector<vector<int>>& board) {\\n            int m=board.size(), n=m?board[0].size():0;\\n            for(int i=0; i<m; i++){\\n                for(int j=0; j<n; j++){\\n                    int count=0;\\n                    for(int ss=max(i-1, 0); ss<min(i+2, m); ss++){\\n                        for(int tt=max(j-1, 0); tt<min(j+2, n); tt++){\\n                            count+=board[ss][tt]&1;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 73340,
                "title": "my-c-code-0ms-o-row-col-time-in-place",
                "content": "Use the second bit of board[][] to save the new state\\n\\n    class Solution {\\n    private:\\n        int countLiveNeighbor(vector<vector<int>>& board, int i, int j, int row, int col)\\n        {\\n            int m,n, count= -(board[i][j] & 0x1);\\n            for(m=max(0,i-1); m<min(row, i+2); ++m)\\n                for(n=max(0,j-1); n<min(col, j+2); ++n)\\n                    count += (board[m][n] & 0x1);\\n            return count ;\\n        }\\n    public:\\n        void gameOfLife(vector<vector<int>>& board) {\\n            int i, j, row, col;\\n            if( !(row=board.size()) || !(col=board[0].size()) ) return;\\n            \\n            for(i=0; i<row; ++i)\\n                for(j=0; j<col;j++)\\n                {\\n                    int liveN = countLiveNeighbor(board, i, j, row, col);\\n                    if(board[i][j]) board[i][j] += (liveN==3 || liveN ==2)? 2:0 ;\\n                    else board[i][j] = liveN==3?2:0;\\n                }\\n    \\n            for(i=0; i<row; ++i)\\n                for(j=0; j<col;j++)\\n                    board[i][j] = board[i][j]>>1 ;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        int countLiveNeighbor(vector<vector<int>>& board, int i, int j, int row, int col)\\n        {\\n            int m,n, count= -(board[i][j] & 0x1);\\n            for(m=max(0,i-1); m<min(row, i+2); ++m)\\n                for(n=max(0,j-1); n<min(col, j+2); ++n)\\n                    count += (board[m][n] & 0x1);\\n            return count ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3959575,
                "title": "simplest-and-most-efficient-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        int delr[] = {0, -1, -1, -1, 0, 1, 1, 1};\\n        int delc[] = {1, 1, 0, -1, -1, -1, 0, 1};\\n        \\n        vector<vector<int>> newBoard = board;\\n\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                int liveNeighbors = 0;\\n\\n                for (int i = 0; i < 8; i++) {\\n                    int nr = r + delr[i];\\n                    int nc = c + delc[i];\\n\\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && (board[nr][nc] == 1 ||  board[nr][nc] == -1)) {\\n                        liveNeighbors++;\\n                    }\\n                }\\n\\n                if (board[r][c] == 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {\\n                    newBoard[r][c] = -1;\\n                } \\n                else if (board[r][c] == 0 && liveNeighbors == 3) {\\n                    newBoard[r][c] = 2;\\n                }\\n            }\\n        }\\n\\n        // Update the board state\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                \\n                if (newBoard[r][c] == -1) {\\n                    board[r][c] = 0;\\n                } \\n                else if (newBoard[r][c] == 2) {\\n                    board[r][c] = 1;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        int delr[] = {0, -1, -1, -1, 0, 1, 1, 1};\\n        int delc[] = {1, 1, 0, -1, -1, -1, 0, 1};\\n        \\n        vector<vector<int>> newBoard = board;\\n\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                int liveNeighbors = 0;\\n\\n                for (int i = 0; i < 8; i++) {\\n                    int nr = r + delr[i];\\n                    int nc = c + delc[i];\\n\\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && (board[nr][nc] == 1 ||  board[nr][nc] == -1)) {\\n                        liveNeighbors++;\\n                    }\\n                }\\n\\n                if (board[r][c] == 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {\\n                    newBoard[r][c] = -1;\\n                } \\n                else if (board[r][c] == 0 && liveNeighbors == 3) {\\n                    newBoard[r][c] = 2;\\n                }\\n            }\\n        }\\n\\n        // Update the board state\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                \\n                if (newBoard[r][c] == -1) {\\n                    board[r][c] = 0;\\n                } \\n                else if (newBoard[r][c] == 2) {\\n                    board[r][c] = 1;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854374,
                "title": "java-simple-approach-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int i,j;\\n        i=board.length;\\n        j=board[0].length;\\n        int[][] myMatrix=new int[i][j];\\n        for(int e=0;e<i;e++){\\n            for(int f=0;f<j;f++){\\n                int sum=0;\\n                if(e-1>-1 && f-1>-1) sum+=board[e-1][f-1];\\n                if(e-1>-1) sum+=board[e-1][f];\\n                if(e-1>-1 && f+1<j) sum+=board[e-1][f+1];\\n                if(f-1>-1) sum+=board[e][f-1];\\n                if(f+1<j) sum+=board[e][f+1];\\n                if(e+1<i && f-1>-1) sum+=board[e+1][f-1];\\n                if(e+1<i) sum+=board[e+1][f];\\n                if(e+1<i && f+1<j) sum+=board[e+1][f+1];\\n                if(board[e][f]==0){\\n                    if(sum==3) myMatrix[e][f]=1;\\n                    else myMatrix[e][f]=0;\\n                }else{\\n                    if(sum==2 || sum==3) myMatrix[e][f]=1;\\n                    else myMatrix[e][f]=0;\\n                }\\n            }\\n        }\\n        for(int e=0;e<i;e++){\\n            for(int f=0;f<j;f++){\\n                board[e][f]=myMatrix[e][f];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int i,j;\\n        i=board.length;\\n        j=board[0].length;\\n        int[][] myMatrix=new int[i][j];\\n        for(int e=0;e<i;e++){\\n            for(int f=0;f<j;f++){\\n                int sum=0;\\n                if(e-1>-1 && f-1>-1) sum+=board[e-1][f-1];\\n                if(e-1>-1) sum+=board[e-1][f];\\n                if(e-1>-1 && f+1<j) sum+=board[e-1][f+1];\\n                if(f-1>-1) sum+=board[e][f-1];\\n                if(f+1<j) sum+=board[e][f+1];\\n                if(e+1<i && f-1>-1) sum+=board[e+1][f-1];\\n                if(e+1<i) sum+=board[e+1][f];\\n                if(e+1<i && f+1<j) sum+=board[e+1][f+1];\\n                if(board[e][f]==0){\\n                    if(sum==3) myMatrix[e][f]=1;\\n                    else myMatrix[e][f]=0;\\n                }else{\\n                    if(sum==2 || sum==3) myMatrix[e][f]=1;\\n                    else myMatrix[e][f]=0;\\n                }\\n            }\\n        }\\n        for(int e=0;e<i;e++){\\n            for(int f=0;f<j;f++){\\n                board[e][f]=myMatrix[e][f];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752686,
                "title": "java-comprehensive-t-s-o-nxm-runtime-100-0-ms-memory-94-88-40-6-mb",
                "content": "# Intuition & Approach\\n###### $$Runtime:$$ *100% (0 ms)*, $$Memory:$$ *94.98% (40.6 MB)*, $$T/C:$$ *O(M * N)*\\n\\nThe given code implements the ***Game of Life*** algorithm. \\n> *The Game of Life is a cellular automaton devised by the mathematician John Conway. It consists of a grid of cells, where each cell can be either alive (represented by 1) or dead (represented by 0). The state of each cell in the grid evolves over time based on a set of rules*.\\n\\n**The algorithm works as follows:**\\n\\n1. The `gameOfLife` method takes a 2D array representing the initial state of the game and modifies it to the next state.\\n\\n2. It initializes variables `M` and `N` to store the dimensions of the `board`, and `x` to keep track of the row index in the source array.\\n\\n3. It creates a new 2D array called `source` and copies the initial state of the game into it using the clone method. This serves as a source of truth for the current state of the game while updating the `board`.\\n\\n4. It iterates over each cell in the `board` using a single loop and applies the `applyRules` method on each cell.\\n\\n5. The `applyRules` method takes the `grid = board`, `source`, and the current indices `i` and `j` as parameters.\\n\\n6. It counts the number of live neighbors around the current cell by calling the `countLiveNeighbors` method.\\n\\n7. If the current cell is alive `(grid[i][j] == 1)` and has exactly 2 or 3 live neighbors, it *remains alive in the next state*. Otherwise, it *dies* `(grid[i][j] = 0)`.\\n\\n8. If the current cell is dead `(grid[i][j] == 0)` and has exactly 3 live neighbors, it *becomes alive in the next state*. Otherwise, it *remains dead*.\\n\\n9. The `countLiveNeighbors` method recursively counts the number of live neighbors around the given cell.\\n\\n10. It checks the boundary conditions and returns `0` if the cell is outside the grid.\\n\\n11. If `skip` is `true`, it counts the number of live neighbors by recursively calling `countLiveNeighbors` on each adjacent cell using the `dx` and `dy` arrays. The `skip` parameter is used to *avoid counting the center cell as a neighbor of itself*.\\n\\n12. The final `count` of live neighbors is returned.\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nLet `M` be the number of rows and `N` be the number of columns in the grid.\\nThe `gameOfLife` method iterates over all `M * N` cells, resulting in a time complexity of `O(M * N)`.\\nThe `applyRules` method and `countLiveNeighbors` method both have a constant time complexity since they perform a fixed number of opreations.\\nThe space complexity of the algorithm is `O(M * N)` because it craetes a new 2D array (`source`) of the same size as the input grid.\\n\\n# Code\\n``` java []\\nclass Solution {\\n    private final int[] dx = {-1, 1, 0, 0, -1, -1, 1, 1};\\n    private final int[] dy = {0, 0, -1, 1, -1, 1, -1, 1};\\n\\n    public void gameOfLife(int[][] board) {\\n        int M = board.length, N = board[0].length, x = 0;\\n        int[][] source = new int[M][N];\\n\\n        for (int[] v : board)\\n            source[x++] = v.clone();\\n        \\n        for(int i = 0; i < M * N; applyRules(board, source, i / N, i++ % N));\\n    }\\n\\n    private void applyRules(int[][] grid, int[][] source, int i, int j) {\\n        int neighbors = countLiveNeighbors(source, i, j, true);\\n\\n        if(neighbors == 3)\\n            grid[i][j] = 1;\\n        else if(neighbors != 2)\\n            grid[i][j] = 0;\\n    }\\n\\n    private int countLiveNeighbors(int[][] grid, int i, int j, boolean skip) {\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length)\\n            return 0;\\n        \\n        if(!skip)\\n            return grid[i][j];\\n            // return grid[i][j] == 1 ? 1 : 0;\\n        \\n        int count = 0;\\n        for (int k = 0; k < dx.length; count += countLiveNeighbors(grid, i + dx[k], j + dy[k++], false));\\n        \\n        return count;\\n    }\\n}\\n```\\n``` java []\\n    // potentially more efficient\\n    private int countLiveNeighbors(int[][] grid, int i, int j) {\\n        int count = 0;\\n\\n        for(int k = 0; k < dx.length; k++) {\\n            int r = i + dx[k];\\n            int c = j + dy[k];\\n            if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length)\\n                continue;\\n            \\n            count += grid[r][c];\\n        }\\n\\n        return count;\\n    }\\n}\\n````\\n\\n**The code is designed to be beginner-friendly, and it can be further optimized for efficiency by considering the following optimizations:**\\n\\n- Use an in-place update strategy: Rather than updating the cells directly in the grid array while iterating over them, you can use a marking strategy. Mark the cells that need to be updated with a specific value to represent a transitioning from dead to alive and vice versa. After marking all the cells, perform a second pass to apply the updates based on the marked values. This reduces the possibility of overwriting values prematurely during the iteration. this strategy requires a bit of additional logic that expresses the previous value of the cell. This strategy eliminates the need for extra memory allocation and the overhead of copying the entire data, and simply avoid creating a separate `source` array for cloning the original state.\\n\\n- Optimize neighbor counting: The current implementation uses recursion to count live neighbors, which can be computationally expensive. You can optmize this process by counting live neighbors iteratively. Instead of recursively traversing all eight neighboring cells, you can directly check the eight adjacent cells and count the live ones. This avoids unnecessary function calls and improves performance\\n\\n- You can going the extra mile and specify the amount of iterations that are performed in the `countLiveNeighbors` method according to the coordinates. for example, in any `M * N` matrix - first we find the maximal `K` (represent the maximum possible number of neighboors, easily can result by manipulating the middlemost cell considering the parity of the number of rows and columns, for example if `N` and `M` are odd so the middlemost is `(M / 2, N / 2)`), and then we will make an adjustment according to the cell coordinates. (for ex., for each cell in a frame, there will be at most `(K / 2) + 1` neighbors). In general, the maximum value for `K` for any matrix is 8, and the minimum value is 3 so there is no effect in terms of complexity analysis (we typically ignore constant factors because they do not affect the overall growth rate of the algorithm as the input size increases, `T(N*M*K)=O(N*M) where K is constant`).\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    private final int[] dx = {-1, 1, 0, 0, -1, -1, 1, 1};\\n    private final int[] dy = {0, 0, -1, 1, -1, 1, -1, 1};\\n\\n    public void gameOfLife(int[][] board) {\\n        int M = board.length, N = board[0].length, x = 0;\\n        int[][] source = new int[M][N];\\n\\n        for (int[] v : board)\\n            source[x++] = v.clone();\\n        \\n        for(int i = 0; i < M * N; applyRules(board, source, i / N, i++ % N));\\n    }\\n\\n    private void applyRules(int[][] grid, int[][] source, int i, int j) {\\n        int neighbors = countLiveNeighbors(source, i, j, true);\\n\\n        if(neighbors == 3)\\n            grid[i][j] = 1;\\n        else if(neighbors != 2)\\n            grid[i][j] = 0;\\n    }\\n\\n    private int countLiveNeighbors(int[][] grid, int i, int j, boolean skip) {\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length)\\n            return 0;\\n        \\n        if(!skip)\\n            return grid[i][j];\\n            // return grid[i][j] == 1 ? 1 : 0;\\n        \\n        int count = 0;\\n        for (int k = 0; k < dx.length; count += countLiveNeighbors(grid, i + dx[k], j + dy[k++], false));\\n        \\n        return count;\\n    }\\n}\\n```\n``` java []\\n    // potentially more efficient\\n    private int countLiveNeighbors(int[][] grid, int i, int j) {\\n        int count = 0;\\n\\n        for(int k = 0; k < dx.length; k++) {\\n            int r = i + dx[k];\\n            int c = j + dy[k];\\n            if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length)\\n                continue;\\n            \\n            count += grid[r][c];\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751252,
                "title": "java-easy-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(2NxM)\\n\\n- Space complexity:\\nO(NxM)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        /*\\n        I mutate the numbers to know how to rewrite it in the second pass\\n        0->0: 0\\n        0->1: 11\\n        1->0: 10\\n        1->1: 1\\n        */\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        for(int i = 0; i< rows; i++){\\n            for(int j = 0; j< cols; j++){\\n                if(board[i][j] == 0) processDead(board, i, j);\\n                else processAlive(board, i, j);\\n            }            \\n        }\\n\\n        for(int i = 0; i< rows; i++){\\n            for(int j = 0; j< cols; j++){\\n                if(board[i][j] == 10) board[i][j] = 0;\\n                if(board[i][j] == 11) board[i][j] = 1;\\n            }            \\n        }\\n    }\\n\\n\\n    private void processAlive(int[][] board, int row, int col){\\n        int alive = 0;  \\n        if (isAlive(board, row-1, col-1)) alive++;\\n        if (isAlive(board, row-1, col)) alive++;\\n        if (isAlive(board, row-1, col+1)) alive++;\\n        if (isAlive(board, row, col-1)) alive++;\\n        if (isAlive(board, row, col+1)) alive++;\\n        if (isAlive(board, row+1, col-1)) alive++;\\n        if (isAlive(board, row+1, col)) alive++;\\n        if (isAlive(board, row+1, col+1)) alive++;\\n        if(alive < 2 ) board[row][col] = 10;\\n        if(alive >3) board[row][col] = 10;\\n    }\\n\\n    private void processDead(int[][] board, int row, int col){\\n        int alive = 0;\\n        if (isAlive(board, row-1, col-1)) alive++;\\n        if (isAlive(board, row-1, col)) alive++;\\n        if (isAlive(board, row-1, col+1)) alive++;\\n        if (isAlive(board, row, col-1)) alive++;\\n        if (isAlive(board, row, col+1)) alive++;\\n        if (isAlive(board, row+1, col-1)) alive++;\\n        if (isAlive(board, row+1, col)) alive++;\\n        if (isAlive(board, row+1, col+1)) alive++;\\n        if(alive ==3) board[row][col] = 11;\\n    }\\n\\n    private boolean isAlive(int[][] board, int row, int col){\\n        if(row < 0 || col < 0 || row>board.length-1 || col > board[0].length-1) return false;\\n        return board[row][col] == 1 || board[row][col] == 10;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        /*\\n        I mutate the numbers to know how to rewrite it in the second pass\\n        0->0: 0\\n        0->1: 11\\n        1->0: 10\\n        1->1: 1\\n        */\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        for(int i = 0; i< rows; i++){\\n            for(int j = 0; j< cols; j++){\\n                if(board[i][j] == 0) processDead(board, i, j);\\n                else processAlive(board, i, j);\\n            }            \\n        }\\n\\n        for(int i = 0; i< rows; i++){\\n            for(int j = 0; j< cols; j++){\\n                if(board[i][j] == 10) board[i][j] = 0;\\n                if(board[i][j] == 11) board[i][j] = 1;\\n            }            \\n        }\\n    }\\n\\n\\n    private void processAlive(int[][] board, int row, int col){\\n        int alive = 0;  \\n        if (isAlive(board, row-1, col-1)) alive++;\\n        if (isAlive(board, row-1, col)) alive++;\\n        if (isAlive(board, row-1, col+1)) alive++;\\n        if (isAlive(board, row, col-1)) alive++;\\n        if (isAlive(board, row, col+1)) alive++;\\n        if (isAlive(board, row+1, col-1)) alive++;\\n        if (isAlive(board, row+1, col)) alive++;\\n        if (isAlive(board, row+1, col+1)) alive++;\\n        if(alive < 2 ) board[row][col] = 10;\\n        if(alive >3) board[row][col] = 10;\\n    }\\n\\n    private void processDead(int[][] board, int row, int col){\\n        int alive = 0;\\n        if (isAlive(board, row-1, col-1)) alive++;\\n        if (isAlive(board, row-1, col)) alive++;\\n        if (isAlive(board, row-1, col+1)) alive++;\\n        if (isAlive(board, row, col-1)) alive++;\\n        if (isAlive(board, row, col+1)) alive++;\\n        if (isAlive(board, row+1, col-1)) alive++;\\n        if (isAlive(board, row+1, col)) alive++;\\n        if (isAlive(board, row+1, col+1)) alive++;\\n        if(alive ==3) board[row][col] = 11;\\n    }\\n\\n    private boolean isAlive(int[][] board, int row, int col){\\n        if(row < 0 || col < 0 || row>board.length-1 || col > board[0].length-1) return false;\\n        return board[row][col] == 1 || board[row][col] == 10;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716086,
                "title": "using-auxiliary-board-python-o-mn",
                "content": "# Code\\n```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def withinbounds(a, b):\\n            if (a>=0 and a<=len(board)-1) and (b>=0 and b<=len(board[0])-1):\\n                return True\\n            return False\\n\\n        def neighbours(i, j):\\n            # use offset to generate neighbours\\n            # check if neighbour is within matrix, and not the same element again\\n            n = []\\n            for a in range(-1, 2):\\n                for b in range(-1, 2):\\n                    if a == 0 and b == 0:\\n                        continue\\n                    if withinbounds(i+a, j+b):\\n                        n.append(board[i+a][j+b])\\n            return n\\n\\n        # create auxiliary matrix with same size as board\\n        aux = [[0 for i in range(len(board[0]))]for j in range(len(board))]\\n\\n        # fill aux with number of live neighbours\\n        for i in range(len(aux)):\\n            for j in range(len(aux[0])):\\n                n = sum(neighbours(i, j))\\n                aux[i][j] = n\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == 1:\\n                    live = aux[i][j]\\n                    if live < 2 or live > 3:\\n                        board[i][j] = 0\\n                else:\\n                    live = aux[i][j]\\n                    if live == 3:\\n                        board[i][j] = 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def withinbounds(a, b):\\n            if (a>=0 and a<=len(board)-1) and (b>=0 and b<=len(board[0])-1):\\n                return True\\n            return False\\n\\n        def neighbours(i, j):\\n            # use offset to generate neighbours\\n            # check if neighbour is within matrix, and not the same element again\\n            n = []\\n            for a in range(-1, 2):\\n                for b in range(-1, 2):\\n                    if a == 0 and b == 0:\\n                        continue\\n                    if withinbounds(i+a, j+b):\\n                        n.append(board[i+a][j+b])\\n            return n\\n\\n        # create auxiliary matrix with same size as board\\n        aux = [[0 for i in range(len(board[0]))]for j in range(len(board))]\\n\\n        # fill aux with number of live neighbours\\n        for i in range(len(aux)):\\n            for j in range(len(aux[0])):\\n                n = sum(neighbours(i, j))\\n                aux[i][j] = n\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == 1:\\n                    live = aux[i][j]\\n                    if live < 2 or live > 3:\\n                        board[i][j] = 0\\n                else:\\n                    live = aux[i][j]\\n                    if live == 3:\\n                        board[i][j] = 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577546,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size();\\nint m=board[0].size();\\nvector<vector<int>> grid=board;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)\\n            {\\n               // int t=board[i][j];\\n                int live=0,dead=0;\\n               // if(t==1){\\n                    if(i-1>=0  && j-1>=0)\\n                    {\\n                        int t1=board[i-1][j-1];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                     if(i-1>=0  )\\n                    {\\n                        int t1=board[i-1][j];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n\\n                    if(i-1>=0  && j+1<m)\\n                    {\\n                        int t1=board[i-1][j+1];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                    if(i>=0  && j-1>=0)\\n                    {\\n                        int t1=board[i][j-1];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                    if( j+1<m)\\n                    {\\n                        int t1=board[i][j+1];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                    if(i+1<n  && j-1>=0)\\n                    {\\n                        int t1=board[i+1][j-1];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                     if(i+1<n  )\\n                    {\\n                        int t1=board[i+1][j];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                     if(i+1<n  && j+1<m)\\n                    {\\n                        int t1=board[i+1][j+1];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                 \\nif(board[i][j]==1)\\n{\\n    if(live<2)grid[i][j]=0;\\n    if(live==2 || live==3)grid[i][j]=1;\\n    if(live>3)grid[i][j]=0;\\n}\\nelse if(board[i][j]==0)\\n{\\n    if(live==3)grid[i][j]=1;\\n}\\n    else\\n    grid[i][j]=board[i][j];            \\n            }\\n        }\\n        board=grid;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size();\\nint m=board[0].size();\\nvector<vector<int>> grid=board;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)\\n            {\\n               // int t=board[i][j];\\n                int live=0,dead=0;\\n               // if(t==1){\\n                    if(i-1>=0  && j-1>=0)\\n                    {\\n                        int t1=board[i-1][j-1];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                     if(i-1>=0  )\\n                    {\\n                        int t1=board[i-1][j];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n\\n                    if(i-1>=0  && j+1<m)\\n                    {\\n                        int t1=board[i-1][j+1];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                    if(i>=0  && j-1>=0)\\n                    {\\n                        int t1=board[i][j-1];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                    if( j+1<m)\\n                    {\\n                        int t1=board[i][j+1];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                    if(i+1<n  && j-1>=0)\\n                    {\\n                        int t1=board[i+1][j-1];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                     if(i+1<n  )\\n                    {\\n                        int t1=board[i+1][j];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                     if(i+1<n  && j+1<m)\\n                    {\\n                        int t1=board[i+1][j+1];\\n                        if(t1==0)dead++;\\n                        else live++;\\n                    }\\n                 \\nif(board[i][j]==1)\\n{\\n    if(live<2)grid[i][j]=0;\\n    if(live==2 || live==3)grid[i][j]=1;\\n    if(live>3)grid[i][j]=0;\\n}\\nelse if(board[i][j]==0)\\n{\\n    if(live==3)grid[i][j]=1;\\n}\\n    else\\n    grid[i][j]=board[i][j];            \\n            }\\n        }\\n        board=grid;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380797,
                "title": "super-easy-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int getNeighbors(vector<vector<int>>& board, int i, int j){\\n        int result = 0;\\n        result += getLive(board, i-1, j-1); // top-left\\n        result += getLive(board, i-1, j); // top\\n        result += getLive(board, i-1, j+1); // top-right\\n        result += getLive(board, i, j-1); // left\\n        // result += getLive(board, i, j); // doesn\\'t count itself\\n        result += getLive(board, i, j+1); // right\\n        result += getLive(board, i+1, j-1); // bottom-left\\n        result += getLive(board, i+1, j); // bottom\\n        result += getLive(board, i+1, j+1); // bottom-right\\n        return result;\\n    }\\n    int getLive(vector<vector<int>>& board, int i, int j){\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size())\\n            return 0;\\n        else\\n            return board[i][j];\\n    }\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<vector<int>> init = board;\\n        int row = board.size();\\n        int col = board[0].size();\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                int n =  getNeighbors(init,i,j);\\n                int cell = init[i][j];\\n                if(cell == 1){ // when cell lives\\n                    if(n < 2) cell = 0;\\n                    else if(n == 2 || n == 3)   cell = 1;\\n                    else if(n > 3) cell = 0;\\n                } else { // when cell died\\n                    if(n == 3) cell =1;\\n                }\\n                if(init[i][j] != cell) // if changed cells stadius\\n                    board[i][j] = cell;\\n            }    \\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int getNeighbors(vector<vector<int>>& board, int i, int j){\\n        int result = 0;\\n        result += getLive(board, i-1, j-1); // top-left\\n        result += getLive(board, i-1, j); // top\\n        result += getLive(board, i-1, j+1); // top-right\\n        result += getLive(board, i, j-1); // left\\n        // result += getLive(board, i, j); // doesn\\'t count itself\\n        result += getLive(board, i, j+1); // right\\n        result += getLive(board, i+1, j-1); // bottom-left\\n        result += getLive(board, i+1, j); // bottom\\n        result += getLive(board, i+1, j+1); // bottom-right\\n        return result;\\n    }\\n    int getLive(vector<vector<int>>& board, int i, int j){\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size())\\n            return 0;\\n        else\\n            return board[i][j];\\n    }\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<vector<int>> init = board;\\n        int row = board.size();\\n        int col = board[0].size();\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                int n =  getNeighbors(init,i,j);\\n                int cell = init[i][j];\\n                if(cell == 1){ // when cell lives\\n                    if(n < 2) cell = 0;\\n                    else if(n == 2 || n == 3)   cell = 1;\\n                    else if(n > 3) cell = 0;\\n                } else { // when cell died\\n                    if(n == 3) cell =1;\\n                }\\n                if(init[i][j] != cell) // if changed cells stadius\\n                    board[i][j] = cell;\\n            }    \\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327805,
                "title": "python-o-m-n-space-and-time-solution",
                "content": "\\nThis won\\'t work in the interview as it requires you to do\\nmodification inplace.\\n```\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        m,n = len(board),len(board[0])\\n        newboard = copy.deepcopy(board);\\n        # tl,tc,tr,cr,br,bc,bl,cl\\n        directions = [[-1,-1],[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1]]\\n        for i in range(0,len(board)):\\n            for j in range(0,len(board[0])):\\n                count = 0\\n                for dir in directions:\\n                    x = i+dir[0]\\n                    y = j+dir[1]\\n                    if( x >= 0 and y >=0 and x < m and y < n):\\n                        if(board[x][y] == 1 ):  count += 1\\n                if(board[i][j] == 1 and (count<2 or count >3 ) ):\\n                        newboard[i][j] = 0\\n                elif(board[i][j] == 0 and count == 3 ):\\n                        newboard[i][j] = 1\\n        \\n        for i in range(0,len(board)):\\n            for j in range(0,len(board[0])):\\n                board[i][j] = newboard[i][j]\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        m,n = len(board),len(board[0])\\n        newboard = copy.deepcopy(board);\\n        # tl,tc,tr,cr,br,bc,bl,cl\\n        directions = [[-1,-1],[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1]]\\n        for i in range(0,len(board)):\\n            for j in range(0,len(board[0])):\\n                count = 0\\n                for dir in directions:\\n                    x = i+dir[0]\\n                    y = j+dir[1]\\n                    if( x >= 0 and y >=0 and x < m and y < n):\\n                        if(board[x][y] == 1 ):  count += 1\\n                if(board[i][j] == 1 and (count<2 or count >3 ) ):\\n                        newboard[i][j] = 0\\n                elif(board[i][j] == 0 and count == 3 ):\\n                        newboard[i][j] = 1\\n        \\n        for i in range(0,len(board)):\\n            for j in range(0,len(board[0])):\\n                board[i][j] = newboard[i][j]\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3175712,
                "title": "c-beats-100-space-o-1-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIs to have a separated matrix for storing the result value and perform the given operation using if else.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- \\xA0Now we need to solve the problem inplace.\\n\\n- \\xA0So we need to store two value in a given element in the matix.\\n\\n- Only change the value in matrix if the `board[i][j] != result[i][j]`\\n\\n- \\xA0If by applying the given statement to problem, the value of `board[i][j] `changes, so we simply `add 2` into the board matrix.\\n\\n-  Which checking for the neighbours, if `board[i][j]` value is `greater than 1`, means we have changed the value, so, the previous value will be just `board[i][j]-2` (Because we added the 2 when there is difference)\\n\\n-  after applying all the operation, At last, we difference values has been changed\\n\\n- \\xA0if board value is 0 and result value is 1, so we have done 0+2 = 2, when result value is 1.\\n\\n- \\xA0if board value is 1 and result value is 0, so we have done 1+2 = 3, when result value is 0.\\n\\n-  Convert all greater value than 1 to respective result value.\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int neighbourCount(vector<vector<int>>& board, int i, int j){\\n        // counting the neighbour which is 1\\n        int x[] = {i-1, i-1, i-1, i, i, i+1, i+1, i+1};\\n        int y[] = {j-1, j, j+1, j-1, j+1, j-1, j, j+1};\\n        int count = 0;\\n        int bs = board.size();\\n        int bis = board[i].size();\\n        for(int k=0; k<8; k++){\\n            if(x[k] >= 0 && x[k] < bs && y[k] >= 0 && y[k] < bis ){\\n                if( board[x[k]][y[k]] == 1 || (board[x[k]][y[k]] > 1 && board[x[k]][y[k]]-2==1))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int b = board.size();\\n        int bi = board[0].size();\\n        for(int i=0; i<b; i++){\\n            for(int j=0; j<bi; j++){\\n                if(board[i][j] == 1 ){\\n\\n                    int count = neighbourCount(board, i, j);\\n                    if(count < 2 || count >= 4){\\n                        board[i][j] += 2;\\n                    }\\n                  \\n                    int count = neighbourCount(board, i, j);\\n                    if(count == 3){\\n                        board[i][j] += 2;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<b; i++){\\n            for(int j=0; j<bi; j++){\\n                if(board[i][j] == 2){\\n                    board[i][j] = 1;\\n                }else if(board[i][j] == 3){\\n                    board[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int neighbourCount(vector<vector<int>>& board, int i, int j){\\n        // counting the neighbour which is 1\\n        int x[] = {i-1, i-1, i-1, i, i, i+1, i+1, i+1};\\n        int y[] = {j-1, j, j+1, j-1, j+1, j-1, j, j+1};\\n        int count = 0;\\n        int bs = board.size();\\n        int bis = board[i].size();\\n        for(int k=0; k<8; k++){\\n            if(x[k] >= 0 && x[k] < bs && y[k] >= 0 && y[k] < bis ){\\n                if( board[x[k]][y[k]] == 1 || (board[x[k]][y[k]] > 1 && board[x[k]][y[k]]-2==1))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int b = board.size();\\n        int bi = board[0].size();\\n        for(int i=0; i<b; i++){\\n            for(int j=0; j<bi; j++){\\n                if(board[i][j] == 1 ){\\n\\n                    int count = neighbourCount(board, i, j);\\n                    if(count < 2 || count >= 4){\\n                        board[i][j] += 2;\\n                    }\\n                  \\n                    int count = neighbourCount(board, i, j);\\n                    if(count == 3){\\n                        board[i][j] += 2;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<b; i++){\\n            for(int j=0; j<bi; j++){\\n                if(board[i][j] == 2){\\n                    board[i][j] = 1;\\n                }else if(board[i][j] == 3){\\n                    board[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986863,
                "title": "simple-python-solution-easy",
                "content": "# Approach\\nFor each cell, \\n* check the count of neighbouring lives (`getNeighbourLivesCount(x, y)`), \\n* check using the rules if value of the cell needs to be updated\\n* if yes, push the tuple `(cell\\'s row, cell\\'s column, cell\\'s new value)` into a list (`points`)\\n\\nAfter you have traversed the board and generated the list, loop through this list and for each tuple update the new value into the resp. cell\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n\\n        m = len(board)\\n        n = len(board[0])\\n\\n        def getNeighbourLivesCount(x, y):\\n            count = (\\n                (board[x-1][y] if x>0 else 0) +\\n                (board[x-1][y-1] if x>0 and y>0 else 0) +\\n                (board[x-1][y+1] if x>0 and y<n-1 else 0) +\\n                (board[x+1][y] if x<m-1 else 0) +\\n                (board[x+1][y-1] if x<m-1 and y>0 else 0) +\\n                (board[x+1][y+1] if x<m-1 and y<n-1 else 0) +\\n                (board[x][y-1] if y>0 else 0) +\\n                (board[x][y+1] if y<n-1 else 0)\\n            )\\n            return count\\n\\n        points = []\\n        for i in range(m):\\n            for j in range(n):\\n                count = getNeighbourLivesCount(i, j)\\n                if count<2 or count>3:\\n                    if board[i][j] != 0:\\n                        points.append((i,j,0))\\n                elif count==3:\\n                    if board[i][j] != 1:\\n                        points.append((i,j,1))\\n        \\n        for (i,j,val) in points:\\n            board[i][j] = val\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n\\n        m = len(board)\\n        n = len(board[0])\\n\\n        def getNeighbourLivesCount(x, y):\\n            count = (\\n                (board[x-1][y] if x>0 else 0) +\\n                (board[x-1][y-1] if x>0 and y>0 else 0) +\\n                (board[x-1][y+1] if x>0 and y<n-1 else 0) +\\n                (board[x+1][y] if x<m-1 else 0) +\\n                (board[x+1][y-1] if x<m-1 and y>0 else 0) +\\n                (board[x+1][y+1] if x<m-1 and y<n-1 else 0) +\\n                (board[x][y-1] if y>0 else 0) +\\n                (board[x][y+1] if y<n-1 else 0)\\n            )\\n            return count\\n\\n        points = []\\n        for i in range(m):\\n            for j in range(n):\\n                count = getNeighbourLivesCount(i, j)\\n                if count<2 or count>3:\\n                    if board[i][j] != 0:\\n                        points.append((i,j,0))\\n                elif count==3:\\n                    if board[i][j] != 1:\\n                        points.append((i,j,1))\\n        \\n        for (i,j,val) in points:\\n            board[i][j] = val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943250,
                "title": "java-o-1-space-2-pass",
                "content": "# Intuition\\nConstant space approach, where I\\'d count live neighbors based on the fact that cell % 2 == 1\\nIf I were to find a dead cell and change it into an alive I\\'d make it 2 so that it\\'s previous state is maintained. Similarly if I find an alive one and make it dead I\\'d make it 3 as it\\'s previous alive state (3 % 2 == 1) is maintained.\\n\\n# Approach\\nSo based on the above intuition, one traversal for making all the necessary changes and then the other one for updating the board according to \"if it\\'s a 2, I\\'d make it a 1 and if it\\'s a 3, a 0\". \\n\\n# Complexity\\n- Time complexity: 2*(m*n)\\n\\n- Space complexity: Used constant extra space, more specifically 8*2 for the directions arrays (for convenience).\\n\\n# Code\\n```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int dirx[] = new int[]{1,0,-1,0,1,1,-1,-1};\\n        int diry[] = new int[]{0,1,0,-1,1,-1,1,-1};\\n        int m = board.length;\\n        int n = board[0].length;\\n        for (int i = 0; i <m; i++){\\n            for (int j = 0; j < n; j++){\\n                int live_count = 0;\\n                for (int t = 0; t < 8; t++){\\n                    int newx = i + dirx[t];\\n                    int newy = j + diry[t];\\n                    if (newx >= 0 && newx< m && newy >= 0 && newy < n){\\n                        if (board[newx][newy] % 2 == 1){\\n                            live_count++;\\n                        }\\n                    }\\n                }\\n                if (board[i][j] % 2 == 0){\\n                    if (live_count == 3)\\n                        board[i][j] = 2;\\n                }\\n                else {      \\n                    if (!(live_count >= 2 && live_count <= 3)){\\n                        board[i][j] = 3;\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (board[i][j] == 2)\\n                    board[i][j] = 1;\\n                else if (board[i][j] == 3)\\n                    board[i][j] = 0;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int dirx[] = new int[]{1,0,-1,0,1,1,-1,-1};\\n        int diry[] = new int[]{0,1,0,-1,1,-1,1,-1};\\n        int m = board.length;\\n        int n = board[0].length;\\n        for (int i = 0; i <m; i++){\\n            for (int j = 0; j < n; j++){\\n                int live_count = 0;\\n                for (int t = 0; t < 8; t++){\\n                    int newx = i + dirx[t];\\n                    int newy = j + diry[t];\\n                    if (newx >= 0 && newx< m && newy >= 0 && newy < n){\\n                        if (board[newx][newy] % 2 == 1){\\n                            live_count++;\\n                        }\\n                    }\\n                }\\n                if (board[i][j] % 2 == 0){\\n                    if (live_count == 3)\\n                        board[i][j] = 2;\\n                }\\n                else {      \\n                    if (!(live_count >= 2 && live_count <= 3)){\\n                        board[i][j] = 3;\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (board[i][j] == 2)\\n                    board[i][j] = 1;\\n                else if (board[i][j] == 3)\\n                    board[i][j] = 0;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784867,
                "title": "c-easy-approach-0-ms-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //  funcion to check validility of neighbor\\n    bool isValidNeighbor(int x, int y, vector<vector<int>>& board) {\\n        return (x >= 0 && x < board.size() && y >= 0 && y < board[0].size());\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) { \\n        vector<int> dx = {0, 0, 1, 1, 1, -1, -1, -1}; //8 coordinated for neighbours\\n        vector<int> dy = {1, -1, 1, -1, 0, 0, 1, -1};\\n        \\n        for (int row = 0; row < board.size(); row++) {\\n            for (int col = 0; col < board[0].size(); col++) {\\n                \\n                int count_live_neighbors = 0;\\n                \\n                for (int i = 0; i < 8; i++) {\\n                    int curr_x = row + dx[i], curr_y = col +dy[i];\\n                    if (isValidNeighbor(curr_x, curr_y, board) && abs(board[curr_x][curr_y]) == 1)\\n                        count_live_neighbors++;\\n                }\\n                \\n                if (board[row][col] == 1 && (count_live_neighbors < 2 || count_live_neighbors > 3))\\n                    board[row][col] = -1;\\n                \\n                if (board[row][col] == 0 && count_live_neighbors == 3)\\n                    board[row][col] = 2;\\n            }\\n        }\\n        \\n        for (int row = 0; row < board.size(); row++) {\\n            for (int col = 0; col < board[0].size(); col++) {\\n                if (board[row][col] > 1)\\n                    board[row][col] = 1;\\n                if(board[row][col] <0)\\n                    board[row][col] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //  funcion to check validility of neighbor\\n    bool isValidNeighbor(int x, int y, vector<vector<int>>& board) {\\n        return (x >= 0 && x < board.size() && y >= 0 && y < board[0].size());\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) { \\n        vector<int> dx = {0, 0, 1, 1, 1, -1, -1, -1}; //8 coordinated for neighbours\\n        vector<int> dy = {1, -1, 1, -1, 0, 0, 1, -1};\\n        \\n        for (int row = 0; row < board.size(); row++) {\\n            for (int col = 0; col < board[0].size(); col++) {\\n                \\n                int count_live_neighbors = 0;\\n                \\n                for (int i = 0; i < 8; i++) {\\n                    int curr_x = row + dx[i], curr_y = col +dy[i];\\n                    if (isValidNeighbor(curr_x, curr_y, board) && abs(board[curr_x][curr_y]) == 1)\\n                        count_live_neighbors++;\\n                }\\n                \\n                if (board[row][col] == 1 && (count_live_neighbors < 2 || count_live_neighbors > 3))\\n                    board[row][col] = -1;\\n                \\n                if (board[row][col] == 0 && count_live_neighbors == 3)\\n                    board[row][col] = 2;\\n            }\\n        }\\n        \\n        for (int row = 0; row < board.size(); row++) {\\n            for (int col = 0; col < board[0].size(); col++) {\\n                if (board[row][col] > 1)\\n                    board[row][col] = 1;\\n                if(board[row][col] <0)\\n                    board[row][col] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721006,
                "title": "java-in-just-1-ms-o-n",
                "content": "# Approach\\nLooping over and applying rules to each cell[O(9 * N)]. Created an array where added results and copied [O(N)] into the given array.\\n\\n# Complexity\\n- Time complexity: actually it is O(9 * N + N) => O(10 * N). Since we omit coefficients, then I can say that complexity is O(N)\\n\\n- Space complexity:\\nO(N + N) => O(2 * N) => O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int m = board.length, n = board[0].length;\\n        int[][] res = new int[m][n];\\n\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                applyRules(row, col, board, res);\\n            }\\n        }\\n\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                board[row][col] = res[row][col];\\n            }\\n        }\\n    }\\n\\n    private void applyRules(int row, int col, int[][] grid, int[][] res) {\\n        int count = 0;\\n        for (int r = row - 1; r <= row + 1; r++) {\\n            for (int c = col - 1; c <= col + 1; c++) {\\n                if (r == row && c == col) continue;\\n                if (cellExists(r, c, grid)) {\\n                    count += grid[r][c];\\n                }\\n            }\\n        }\\n        if (count < 2 || count > 3) res[row][col] = 0;\\n        else if (count == 3) res[row][col] = 1;\\n        else res[row][col] = grid[row][col];\\n    }\\n\\n    private boolean cellExists(int row, int col, int[][] grid) {\\n        return (row <= grid.length - 1 && row >= 0) && (col <= grid[0].length - 1 && col >= 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int m = board.length, n = board[0].length;\\n        int[][] res = new int[m][n];\\n\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                applyRules(row, col, board, res);\\n            }\\n        }\\n\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                board[row][col] = res[row][col];\\n            }\\n        }\\n    }\\n\\n    private void applyRules(int row, int col, int[][] grid, int[][] res) {\\n        int count = 0;\\n        for (int r = row - 1; r <= row + 1; r++) {\\n            for (int c = col - 1; c <= col + 1; c++) {\\n                if (r == row && c == col) continue;\\n                if (cellExists(r, c, grid)) {\\n                    count += grid[r][c];\\n                }\\n            }\\n        }\\n        if (count < 2 || count > 3) res[row][col] = 0;\\n        else if (count == 3) res[row][col] = 1;\\n        else res[row][col] = grid[row][col];\\n    }\\n\\n    private boolean cellExists(int row, int col, int[][] grid) {\\n        return (row <= grid.length - 1 && row >= 0) && (col <= grid[0].length - 1 && col >= 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700495,
                "title": "python-easy-solution-t-c-o-m-x-n-s-c-o-1",
                "content": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \\n        #  1 -> 0  : 2\\n        #  1 -> 1  : 1\\n        #  1 -> 0  : 3\\n        #  0 -> 1  : 4\\n        \\n        row = len(board)\\n        col = len(board[0])\\n        \\n        def neicheck(ri , co):\\n            di = [[1,0] , [0, 1], [1, 1], [-1, 0] , [0 , -1], [- 1, - 1], [1, -1], [-1, 1]]\\n            \\n            count = 0\\n            for a in di:\\n                roo = ri + a[0]\\n                coo = co + a[1]\\n                    \\n                if 0<= roo < row and 0<= coo < col and (board[roo][coo]== 1 or board[roo][coo] == 2 or board[roo][coo] ==3):\\n                    count = count+1\\n            return count\\n        \\n        for r in range(row):\\n            for c in range(col):\\n                val = neicheck(r,c)\\n                if board[r][c] == 0 :\\n                    if val == 3:\\n                        board[r][c]= 4\\n                elif board[r][c] == 1:\\n                    if val in [2, 3]:\\n                        board[r][c]=1\\n                    elif val > 3:\\n                        board[r][c] = 3\\n                    elif val < 2 :\\n                        board[r][c] = 2\\n                        \\n        for  i in board:\\n            print(i)\\n                                    \\n        for r in range(row):\\n            for c in range(col):\\n                if board[r][c] == 2:\\n                    board[r][c] = 0\\n                elif board[r][c] == 3:\\n                    board[r][c]=0\\n                elif board[r][c] ==4:\\n                    board[r][c]=1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \\n        #  1 -> 0  : 2\\n        #  1 -> 1  : 1\\n        #  1 -> 0  : 3\\n        #  0 -> 1  : 4\\n        \\n        row = len(board)\\n        col = len(board[0])\\n        \\n        def neicheck(ri , co):\\n            di = [[1,0] , [0, 1], [1, 1], [-1, 0] , [0 , -1], [- 1, - 1], [1, -1], [-1, 1]]\\n            \\n            count = 0\\n            for a in di:\\n                roo = ri + a[0]\\n                coo = co + a[1]\\n                    \\n                if 0<= roo < row and 0<= coo < col and (board[roo][coo]== 1 or board[roo][coo] == 2 or board[roo][coo] ==3):\\n                    count = count+1\\n            return count\\n        \\n        for r in range(row):\\n            for c in range(col):\\n                val = neicheck(r,c)\\n                if board[r][c] == 0 :\\n                    if val == 3:\\n                        board[r][c]= 4\\n                elif board[r][c] == 1:\\n                    if val in [2, 3]:\\n                        board[r][c]=1\\n                    elif val > 3:\\n                        board[r][c] = 3\\n                    elif val < 2 :\\n                        board[r][c] = 2\\n                        \\n        for  i in board:\\n            print(i)\\n                                    \\n        for r in range(row):\\n            for c in range(col):\\n                if board[r][c] == 2:\\n                    board[r][c] = 0\\n                elif board[r][c] == 3:\\n                    board[r][c]=0\\n                elif board[r][c] ==4:\\n                    board[r][c]=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689968,
                "title": "c-o-1-space-o-mn-time-easiest-solution",
                "content": "**Please upvote **\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        int dx[]={-1,-1,0,1,1,1,0,-1};\\n        int dy[]={0,1,1,1,0,-1,-1,-1};\\n        vector<vector<int>> v(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int cur=board[i][j];\\n                int val=1;\\n                int c=0;\\n                for(int k=0;k<8;k++){\\n                    int x=i+dx[k];\\n                    int y=j+dy[k];\\n                    if(x>=0 && x<n && y>=0 && y<m){\\n                        if(abs(board[x][y])==1)c++;\\n                    }\\n                }\\n                \\n                if(cur==0){\\n                    if(c==3){\\n                        // now for others it is 0\\n                        // but it will be 1\\n                        board[i][j]=-2;\\n                    }\\n                }else{\\n                    if(c<2 || c>3){\\n                        // we want that it is still one for others \\n                        // but it is actually 0\\n                        board[i][j]=-1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==-2)board[i][j]=1;\\n                else if(board[i][j]==-1)board[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        int dx[]={-1,-1,0,1,1,1,0,-1};\\n        int dy[]={0,1,1,1,0,-1,-1,-1};\\n        vector<vector<int>> v(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int cur=board[i][j];\\n                int val=1;\\n                int c=0;\\n                for(int k=0;k<8;k++){\\n                    int x=i+dx[k];\\n                    int y=j+dy[k];\\n                    if(x>=0 && x<n && y>=0 && y<m){\\n                        if(abs(board[x][y])==1)c++;\\n                    }\\n                }\\n                \\n                if(cur==0){\\n                    if(c==3){\\n                        // now for others it is 0\\n                        // but it will be 1\\n                        board[i][j]=-2;\\n                    }\\n                }else{\\n                    if(c<2 || c>3){\\n                        // we want that it is still one for others \\n                        // but it is actually 0\\n                        board[i][j]=-1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==-2)board[i][j]=1;\\n                else if(board[i][j]==-1)board[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682976,
                "title": "easy-fastest-solution-100-0ms-c",
                "content": "```\\n>>>>>>>>>>>>>>>>>>spread love by upvoting<<<<<<<<<<<<<<<<<< \\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Game of Life.\\nMemory Usage: 7 MB, less than 58.92% of C++ online submissions for Game of Life.\\n\\n        we just traverse every index in matrix and apply condition given in question \\n\\n\\n        int a=bo.size(),b=bo[0].size();\\n        vector<vector<int>>v(a,vector<int>(b,-1));\\n        \\n        int a1[8]={1,-1,0,0,1,1,-1,-1};\\n        int a2[8]={0,0,1,-1,1,-1,-1,1};\\n        for(int i=0;i<a;i++){\\n\\n        \\n            for(int j=0;j<b;j++){\\n                int ans=0;\\n                \\n                for(int k=0;k<8;k++){\\n                    int s1=i+a1[k];\\n                    int s2=j+a2[k];\\n                    if(s1>=0 && s1<a && s2>=0 && s2<b && bo[s1][s2]==1)\\n                    ans++;\\n                    \\n                }\\n                \\n                if(bo[i][j]==1){\\n                    if(ans<2)\\n                     v[i][j]=0;\\n                    if(ans==2 || ans==3)\\n                      v[i][j]=1;  \\n                    if(ans>3)\\n                     v[i][j]=0;  \\n                }\\n                else{\\n                    if(ans==3)\\n                     v[i][j]=1;\\n                    else\\n                     v[i][j]=0;   \\n                }   \\n            }       \\n        }\\n \\n        bo=v;\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\n>>>>>>>>>>>>>>>>>>spread love by upvoting<<<<<<<<<<<<<<<<<< \\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Game of Life.\\nMemory Usage: 7 MB, less than 58.92% of C++ online submissions for Game of Life.\\n\\n        we just traverse every index in matrix and apply condition given in question \\n\\n\\n        int a=bo.size(),b=bo[0].size();\\n        vector<vector<int>>v(a,vector<int>(b,-1));\\n        \\n        int a1[8]={1,-1,0,0,1,1,-1,-1};\\n        int a2[8]={0,0,1,-1,1,-1,-1,1};\\n        for(int i=0;i<a;i++){\\n\\n        \\n            for(int j=0;j<b;j++){\\n                int ans=0;\\n                \\n                for(int k=0;k<8;k++){\\n                    int s1=i+a1[k];\\n                    int s2=j+a2[k];\\n                    if(s1>=0 && s1<a && s2>=0 && s2<b && bo[s1][s2]==1)\\n                    ans++;\\n                    \\n                }\\n                \\n                if(bo[i][j]==1){\\n                    if(ans<2)\\n                     v[i][j]=0;\\n                    if(ans==2 || ans==3)\\n                      v[i][j]=1;  \\n                    if(ans>3)\\n                     v[i][j]=0;  \\n                }\\n                else{\\n                    if(ans==3)\\n                     v[i][j]=1;\\n                    else\\n                     v[i][j]=0;   \\n                }   \\n            }       \\n        }\\n \\n        bo=v;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2633997,
                "title": "python-easy-simple-91-faster",
                "content": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m = len(board)\\n        n = len(board[0])\\n        d = [(1,0) , (-1,0) , (0,1) , (0,-1) , (1,1) , (-1,-1) , (1,-1) , (-1,1)]\\n        dummy = []\\n        for i in board :\\n            dummy.append(i[:])\\n            \\n        for i in range(m) :\\n            for j in range(n) :\\n                live = 0\\n                dead = 0\\n                for x , y in d :\\n                    a = x + i\\n                    b = y + j\\n                    \\n                    if m > a >= 0 and n > b >= 0 :\\n                        if dummy[a][b] == 1 :\\n                            live += 1\\n                            \\n                            \\n                        else :\\n                            dead += 1\\n                 \\n                if dummy[i][j] == 1:\\n                        \\n                    if live < 2 :\\n                        board[i][j] = 0\\n                    elif 3 >= live >= 2 :\\n                        board[i][j] = 1\\n                    elif live > 3 :\\n                        board[i][j] = 0\\n                    \\n                else :\\n                    if live == 3 :\\n                        board[i][j] = 1\\n",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m = len(board)\\n        n = len(board[0])\\n        d = [(1,0) , (-1,0) , (0,1) , (0,-1) , (1,1) , (-1,-1) , (1,-1) , (-1,1)]\\n        dummy = []\\n        for i in board :\\n            dummy.append(i[:])\\n            \\n        for i in range(m) :\\n            for j in range(n) :\\n                live = 0\\n                dead = 0\\n                for x , y in d :\\n                    a = x + i\\n                    b = y + j\\n                    \\n                    if m > a >= 0 and n > b >= 0 :\\n                        if dummy[a][b] == 1 :\\n                            live += 1\\n                            \\n                            \\n                        else :\\n                            dead += 1\\n                 \\n                if dummy[i][j] == 1:\\n                        \\n                    if live < 2 :\\n                        board[i][j] = 0\\n                    elif 3 >= live >= 2 :\\n                        board[i][j] = 1\\n                    elif live > 3 :\\n                        board[i][j] = 0\\n                    \\n                else :\\n                    if live == 3 :\\n                        board[i][j] = 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2623742,
                "title": "beginner-friendly-commented-code-in-c",
                "content": "```\\n// Since the board has ints but only the 1-bit is used, we\\'ll use the 2-bit to store the new state. At the end, replace the old state with the new state by shifting all values one bit to the right.\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int a, int b, int n, int m) {\\n        if (a>=0 && a<n && b>=0 && b<m) return true;\\n        return false;\\n    }\\n    \\n    // this function will return the count of neighbouring 0 and 1\\n    pair<int,int> padosi(int x, int y, int n, int m, vector<vector<int>>& mt){\\n        int c0=0; int c1 = 0;\\n        vector<int> v1 = {-1,0,1};\\n        for (auto it : v1) {\\n            for (auto jt : v1) {\\n                if (it==0 && jt==0) continue;\\n                else if (check(x+it,y+jt,n,m)==true) {\\n                    // don\\'t forget to do mod 10. Mod 10 will ensure that we are taking only the original (0/1) into consideration\\n                    if (mt[x+it][y+jt]%10==1) {\\n                        c1++;\\n                    }\\n                    else {c0++;}\\n                }\\n            }\\n        }\\n        return {c0,c1};\\n        \\n    }\\n    // 2 is newly live\\n    // 3 is newly dead\\n    void gameOfLife(vector<vector<int>>& mt) {\\n        int n = mt.size(); int m = mt[0].size();\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<m; j++) {\\n                pair<int,int> curr = padosi(i,j,n,m,mt); int c1 = curr.second; int c0 = curr.first;\\n                // don\\'t forget to do mod 10. Mod 10 will ensure that we are taking only the original (0/1) into consideration\\n                if (mt[i][j]%10==1) {\\n                    if (c1==2 || c1==3) {\\n                        mt[i][j] = 20+mt[i][j]; \\n                    }\\n                    else mt[i][j] = 30 + mt[i][j];\\n                }\\n                if (mt[i][j]%10==0) {\\n                    if (c1==3) {mt[i][j] = 20+mt[i][j];}\\n                    else mt[i][j] = 30+mt[i][j];\\n                }\\n            }\\n        }\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<m; j++) {\\n                if (mt[i][j]/10==2) mt[i][j]=1;\\n                if (mt[i][j]/10==3) mt[i][j]=0;\\n            }\\n        }\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Since the board has ints but only the 1-bit is used, we\\'ll use the 2-bit to store the new state. At the end, replace the old state with the new state by shifting all values one bit to the right.\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int a, int b, int n, int m) {\\n        if (a>=0 && a<n && b>=0 && b<m) return true;\\n        return false;\\n    }\\n    \\n    // this function will return the count of neighbouring 0 and 1\\n    pair<int,int> padosi(int x, int y, int n, int m, vector<vector<int>>& mt){\\n        int c0=0; int c1 = 0;\\n        vector<int> v1 = {-1,0,1};\\n        for (auto it : v1) {\\n            for (auto jt : v1) {\\n                if (it==0 && jt==0) continue;\\n                else if (check(x+it,y+jt,n,m)==true) {\\n                    // don\\'t forget to do mod 10. Mod 10 will ensure that we are taking only the original (0/1) into consideration\\n                    if (mt[x+it][y+jt]%10==1) {\\n                        c1++;\\n                    }\\n                    else {c0++;}\\n                }\\n            }\\n        }\\n        return {c0,c1};\\n        \\n    }\\n    // 2 is newly live\\n    // 3 is newly dead\\n    void gameOfLife(vector<vector<int>>& mt) {\\n        int n = mt.size(); int m = mt[0].size();\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<m; j++) {\\n                pair<int,int> curr = padosi(i,j,n,m,mt); int c1 = curr.second; int c0 = curr.first;\\n                // don\\'t forget to do mod 10. Mod 10 will ensure that we are taking only the original (0/1) into consideration\\n                if (mt[i][j]%10==1) {\\n                    if (c1==2 || c1==3) {\\n                        mt[i][j] = 20+mt[i][j]; \\n                    }\\n                    else mt[i][j] = 30 + mt[i][j];\\n                }\\n                if (mt[i][j]%10==0) {\\n                    if (c1==3) {mt[i][j] = 20+mt[i][j];}\\n                    else mt[i][j] = 30+mt[i][j];\\n                }\\n            }\\n        }\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<m; j++) {\\n                if (mt[i][j]/10==2) mt[i][j]=1;\\n                if (mt[i][j]/10==3) mt[i][j]=0;\\n            }\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329218,
                "title": "javascript-in-place-solution-with-comments",
                "content": "This solution is O(n) where n is the amount of tiles on the board and the space complexity is O(1) since it is done in place\\n```js\\nconst gameOfLife = function (board) {\\n\\t\\n\\t//iterate through the board from the top left corner\\n\\tfor (let row = 0; row < board.length; row++) {\\n\\t\\tfor (let col = 0; col < board[0].length; col++) {\\n\\t\\t\\tconst liveNeighborCount = liveNeighborCheck(row, col)\\n\\t\\t\\tconst tile = board[row][col]\\n\\t\\t\\t//if the cell is live\\n\\t\\t\\tif (tile === 1 || tile === \"liveToDead\") {\\n\\t\\t\\t\\t//if it has less than two or more than 3 live neighbors\\n\\t\\t\\t\\tif (liveNeighborCount < 2 || liveNeighborCount > 3) {\\n\\t\\t\\t\\t\\t//set the value to an arbitrary value that isn\\'t 0 or 1\\n\\t\\t\\t\\t\\t//I chose \"liveToDead\" since it\\'s easy to remember what to do with it later\\n\\t\\t\\t\\t\\tboard[row][col] = \"liveToDead\"\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//else (it\\'s dead), if it has 3 neighbors\\n\\t\\t\\telse if (liveNeighborCount === 3)\\n\\t\\t\\t\\t//set the value to an arbitrary value that isn\\'t 0, 1, or the last arbitrary value chosen\\n\\t\\t\\t\\t//I chose \"deadToLive\" since it\\'s easy to remember what to do with it later\\n\\t\\t\\t\\tboard[row][col] = \"deadToLive\"\\n\\t\\t}\\n\\t}\\n\\n\\t//chenge each cell with \"liveToDead\" to 0 and any cell with \"deadToLive\" to 1\\n\\tfor (let row = 0; row < board.length; row++) {\\n\\t\\tfor (let col = 0; col < board[0].length; col++) {\\n\\t\\t\\tconst tile = board[row][col]\\n\\t\\t\\tif (tile === \"liveToDead\") {\\n\\t\\t\\t\\tboard[row][col] = 0\\n\\t\\t\\t}\\n\\t\\t\\telse if (tile === \"deadToLive\") {\\n\\t\\t\\t\\tboard[row][col] = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfunction liveNeighborCheck(rowMiddle, colMiddle) {\\n\\t\\tlet count = 0\\n\\t\\t//iterate through a 3x3 square with the center being the row and column passed in\\n\\t\\tfor (let row = rowMiddle - 1; row <= rowMiddle + 1; row++) {\\n\\t\\t\\tfor (let col = colMiddle - 1; col <= colMiddle + 1; col++) {\\n\\t\\t\\t\\t//if the tile is not the center\\n\\t\\t\\t\\tif (!(row === rowMiddle && col === colMiddle)) {\\n\\t\\t\\t\\t\\tconst tile = board?.[row]?.[col]\\n\\t\\t\\t\\t\\t//if the tile is in bounds and live\\n\\t\\t\\t\\t\\tif (tile === 1 || tile === \"liveToDead\") {\\n\\t\\t\\t\\t\\t\\t//increment the count\\n\\t\\t\\t\\t\\t\\tcount++\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//return the count\\n\\t\\treturn count\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst gameOfLife = function (board) {\\n\\t\\n\\t//iterate through the board from the top left corner\\n\\tfor (let row = 0; row < board.length; row++) {\\n\\t\\tfor (let col = 0; col < board[0].length; col++) {\\n\\t\\t\\tconst liveNeighborCount = liveNeighborCheck(row, col)\\n\\t\\t\\tconst tile = board[row][col]\\n\\t\\t\\t//if the cell is live\\n\\t\\t\\tif (tile === 1 || tile === \"liveToDead\") {\\n\\t\\t\\t\\t//if it has less than two or more than 3 live neighbors\\n\\t\\t\\t\\tif (liveNeighborCount < 2 || liveNeighborCount > 3) {\\n\\t\\t\\t\\t\\t//set the value to an arbitrary value that isn\\'t 0 or 1\\n\\t\\t\\t\\t\\t//I chose \"liveToDead\" since it\\'s easy to remember what to do with it later\\n\\t\\t\\t\\t\\tboard[row][col] = \"liveToDead\"\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//else (it\\'s dead), if it has 3 neighbors\\n\\t\\t\\telse if (liveNeighborCount === 3)\\n\\t\\t\\t\\t//set the value to an arbitrary value that isn\\'t 0, 1, or the last arbitrary value chosen\\n\\t\\t\\t\\t//I chose \"deadToLive\" since it\\'s easy to remember what to do with it later\\n\\t\\t\\t\\tboard[row][col] = \"deadToLive\"\\n\\t\\t}\\n\\t}\\n\\n\\t//chenge each cell with \"liveToDead\" to 0 and any cell with \"deadToLive\" to 1\\n\\tfor (let row = 0; row < board.length; row++) {\\n\\t\\tfor (let col = 0; col < board[0].length; col++) {\\n\\t\\t\\tconst tile = board[row][col]\\n\\t\\t\\tif (tile === \"liveToDead\") {\\n\\t\\t\\t\\tboard[row][col] = 0\\n\\t\\t\\t}\\n\\t\\t\\telse if (tile === \"deadToLive\") {\\n\\t\\t\\t\\tboard[row][col] = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfunction liveNeighborCheck(rowMiddle, colMiddle) {\\n\\t\\tlet count = 0\\n\\t\\t//iterate through a 3x3 square with the center being the row and column passed in\\n\\t\\tfor (let row = rowMiddle - 1; row <= rowMiddle + 1; row++) {\\n\\t\\t\\tfor (let col = colMiddle - 1; col <= colMiddle + 1; col++) {\\n\\t\\t\\t\\t//if the tile is not the center\\n\\t\\t\\t\\tif (!(row === rowMiddle && col === colMiddle)) {\\n\\t\\t\\t\\t\\tconst tile = board?.[row]?.[col]\\n\\t\\t\\t\\t\\t//if the tile is in bounds and live\\n\\t\\t\\t\\t\\tif (tile === 1 || tile === \"liveToDead\") {\\n\\t\\t\\t\\t\\t\\t//increment the count\\n\\t\\t\\t\\t\\t\\tcount++\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//return the count\\n\\t\\treturn count\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307563,
                "title": "beats-100-other-solutions",
                "content": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        height, width = len(board), len(board[0])\\n        \\n        def evaluate_neighbors(i, j):\\n            n_alive = 0\\n            \\n            # right\\n            if j < width - 1:\\n                neighbor = board[i][j + 1]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # left\\n            if j > 0:\\n                neighbor = board[i][j - 1]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # up\\n            if i > 0:\\n                neighbor = board[i - 1][j]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # down\\n            if i < height - 1:\\n                neighbor = board[i + 1][j]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # top-left\\n            if i > 0 and j > 0:\\n                neighbor = board[i - 1][j - 1]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # top-right\\n            if i > 0 and j < width - 1:\\n                neighbor = board[i - 1][j + 1]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # bottom-left\\n            if i < height - 1 and j > 0:\\n                neighbor = board[i + 1][j - 1]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # bottom-right\\n            if i < height - 1 and j < width - 1:\\n                neighbor = board[i + 1][j + 1]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n                \\n            return n_alive\\n            \\n            \\n        next_state = []\\n        \\n        for i in range(height):\\n            curr_row, next_state_row = board[i], []\\n            \\n            for j in range(width):\\n                n_alive = evaluate_neighbors(i, j)\\n                curr_cell_alive = curr_row[j] == 1\\n                \\n                if curr_cell_alive and (n_alive < 2 or n_alive > 3):\\n                    next_state_row.append(0)\\n                    \\n                elif curr_cell_alive or n_alive == 3:\\n                    next_state_row.append(1)\\n                    \\n                else:\\n                    next_state_row.append(0)\\n                    \\n            next_state.append(next_state_row)\\n            \\n        for i in range(height):\\n            for j in range(width):\\n                board[i][j] = next_state[i][j]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        height, width = len(board), len(board[0])\\n        \\n        def evaluate_neighbors(i, j):\\n            n_alive = 0\\n            \\n            # right\\n            if j < width - 1:\\n                neighbor = board[i][j + 1]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # left\\n            if j > 0:\\n                neighbor = board[i][j - 1]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # up\\n            if i > 0:\\n                neighbor = board[i - 1][j]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # down\\n            if i < height - 1:\\n                neighbor = board[i + 1][j]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # top-left\\n            if i > 0 and j > 0:\\n                neighbor = board[i - 1][j - 1]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # top-right\\n            if i > 0 and j < width - 1:\\n                neighbor = board[i - 1][j + 1]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # bottom-left\\n            if i < height - 1 and j > 0:\\n                neighbor = board[i + 1][j - 1]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n            \\n            # bottom-right\\n            if i < height - 1 and j < width - 1:\\n                neighbor = board[i + 1][j + 1]\\n                \\n                n_alive += 1 if neighbor == 1 else 0\\n                \\n            return n_alive\\n            \\n            \\n        next_state = []\\n        \\n        for i in range(height):\\n            curr_row, next_state_row = board[i], []\\n            \\n            for j in range(width):\\n                n_alive = evaluate_neighbors(i, j)\\n                curr_cell_alive = curr_row[j] == 1\\n                \\n                if curr_cell_alive and (n_alive < 2 or n_alive > 3):\\n                    next_state_row.append(0)\\n                    \\n                elif curr_cell_alive or n_alive == 3:\\n                    next_state_row.append(1)\\n                    \\n                else:\\n                    next_state_row.append(0)\\n                    \\n            next_state.append(next_state_row)\\n            \\n        for i in range(height):\\n            for j in range(width):\\n                board[i][j] = next_state[i][j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263543,
                "title": "easy-java-implementation",
                "content": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        // 0 and stays 0 \\n        // 1 and stats 1\\n        // 0 and becomes alive than 2\\n        // 1 and becomes dead than 3\\n        // check count of 1 and 3 at 8 positions\\n        \\n        \\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                int countOne = count(board,i,j);\\n                \\n                if(board[i][j] == 1){\\n                    if(countOne < 2 || countOne >3) board[i][j] = 3;\\n                    \\n                }else{\\n                    if(countOne == 3) board[i][j] = 2;\\n                }\\n            }\\n        }\\n        \\n        fixBoard(board);\\n        \\n    }\\n    \\n    public int count(int[][] board, int row, int col){\\n        int countOne = 0;\\n        \\n        //topleft\\n        if(row > 0 && col > 0){\\n            if(board[row-1][col-1] == 1 || board[row-1][col-1] == 3) countOne++;\\n        } \\n        \\n        \\n        //top\\n        if(row > 0){\\n            if(board[row-1][col]== 1 || board[row-1][col] == 3) countOne++;\\n        }\\n        \\n        //topright\\n        if(row > 0 && col<board[0].length-1){\\n            if(board[row-1][col+1]== 1 || board[row-1][col+1] == 3) countOne++;\\n        }\\n        //left\\n        if(col > 0){\\n            if(board[row][col-1]== 1 || board[row][col-1] == 3) countOne++;\\n        }\\n        //right\\n        if(col < board[0].length -1){\\n            if(board[row][col+1]== 1 || board[row][col+1] == 3) countOne++;\\n        }\\n        //bottomleft\\n        if(row < board.length-1 && col > 0){\\n            if(board[row+1][col-1]== 1 || board[row+1][col-1] == 3) countOne++;\\n        }\\n        //bottom\\n        if(row < board.length-1){\\n            if(board[row+1][col]== 1 || board[row+1][col] == 3) countOne++;\\n        }\\n        //bottomright\\n        if(row < board.length-1 && col<board[0].length-1){\\n            if(board[row+1][col+1]== 1 || board[row+1][col+1] == 3) countOne++;\\n        }\\n        return countOne;\\n    }\\n    \\n    public void fixBoard(int[][] board){\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                if(board[i][j] == 2) board[i][j] = 1;\\n                else if(board[i][j] == 3) board[i][j] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        // 0 and stays 0 \\n        // 1 and stats 1\\n        // 0 and becomes alive than 2\\n        // 1 and becomes dead than 3\\n        // check count of 1 and 3 at 8 positions\\n        \\n        \\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                int countOne = count(board,i,j);\\n                \\n                if(board[i][j] == 1){\\n                    if(countOne < 2 || countOne >3) board[i][j] = 3;\\n                    \\n                }else{\\n                    if(countOne == 3) board[i][j] = 2;\\n                }\\n            }\\n        }\\n        \\n        fixBoard(board);\\n        \\n    }\\n    \\n    public int count(int[][] board, int row, int col){\\n        int countOne = 0;\\n        \\n        //topleft\\n        if(row > 0 && col > 0){\\n            if(board[row-1][col-1] == 1 || board[row-1][col-1] == 3) countOne++;\\n        } \\n        \\n        \\n        //top\\n        if(row > 0){\\n            if(board[row-1][col]== 1 || board[row-1][col] == 3) countOne++;\\n        }\\n        \\n        //topright\\n        if(row > 0 && col<board[0].length-1){\\n            if(board[row-1][col+1]== 1 || board[row-1][col+1] == 3) countOne++;\\n        }\\n        //left\\n        if(col > 0){\\n            if(board[row][col-1]== 1 || board[row][col-1] == 3) countOne++;\\n        }\\n        //right\\n        if(col < board[0].length -1){\\n            if(board[row][col+1]== 1 || board[row][col+1] == 3) countOne++;\\n        }\\n        //bottomleft\\n        if(row < board.length-1 && col > 0){\\n            if(board[row+1][col-1]== 1 || board[row+1][col-1] == 3) countOne++;\\n        }\\n        //bottom\\n        if(row < board.length-1){\\n            if(board[row+1][col]== 1 || board[row+1][col] == 3) countOne++;\\n        }\\n        //bottomright\\n        if(row < board.length-1 && col<board[0].length-1){\\n            if(board[row+1][col+1]== 1 || board[row+1][col+1] == 3) countOne++;\\n        }\\n        return countOne;\\n    }\\n    \\n    public void fixBoard(int[][] board){\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                if(board[i][j] == 2) board[i][j] = 1;\\n                else if(board[i][j] == 3) board[i][j] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256301,
                "title": "0ms-fastest-o-1-sc-mn-tc-c",
                "content": "```\\nbool check(int i,int j,int n,int m){\\n        if(i<0||j<0||i>=n||j>=m)return false;\\n        return true;\\n    }\\n    \\n    int sol(int i,int j,int n,int m,vector<vector<int>>&nums){\\n        int count =0;\\n        for(int p=-1;p<=1;p++){\\n            for(int q=-1;q<=1;q++){\\n                if(!p&&!q)continue;                \\n                if(check(i+p,j+q,n,m)&&(nums[i+p][j+q]==1||nums[i+p][j+q]==2))count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int t=sol(i,j,n,m,board);\\n                if(board[i][j]&&(t<2||t>3)) board[i][j]=2;\\n                else if(!board[i][j]&&t==3)board[i][j]=3;\\n            }\\n            \\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==2)board[i][j]=0;\\n                else if(board[i][j]==3)board[i][j]=1;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool check(int i,int j,int n,int m){\\n        if(i<0||j<0||i>=n||j>=m)return false;\\n        return true;\\n    }\\n    \\n    int sol(int i,int j,int n,int m,vector<vector<int>>&nums){\\n        int count =0;\\n        for(int p=-1;p<=1;p++){\\n            for(int q=-1;q<=1;q++){\\n                if(!p&&!q)continue;                \\n                if(check(i+p,j+q,n,m)&&(nums[i+p][j+q]==1||nums[i+p][j+q]==2))count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int t=sol(i,j,n,m,board);\\n                if(board[i][j]&&(t<2||t>3)) board[i][j]=2;\\n                else if(!board[i][j]&&t==3)board[i][j]=3;\\n            }\\n            \\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==2)board[i][j]=0;\\n                else if(board[i][j]==3)board[i][j]=1;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2239694,
                "title": "fully-explained-solution-for-beginner-in-place",
                "content": "So the idea is very simple we count the number of live neighbours for each cell.\\n**if our current cell is live (i.e 1) then we can have 3 cases :**\\n**i)** **number of live neighbours is less than 2.**\\n\\n\\tIn this case our current cell will die due to under population So we will mark it  3.\\n**ii) number of live neighbours is 2 or 3.**\\n\\n\\tIn this case our current cell will live So we will mark it 4.\\n**iii) number of live neighbours is greater then 4.**\\n\\n\\t In this case our current cell will die due to over population So we will mark it 5.\\n  \\n**if our current cell is dead (i.e 0) and if it has exactly 3 live neighbour then this cell will become alive So we will mark it as 6.**\\n\\nNow at the end we again itetrate the matrix and we will update the cell according to the value present on it.\\n\\nIf you like the explanation \\n**Please do upvote !!**\\n\\n`public void gameOfLife(int[][] matrix) {`\\n        \\n        int oneButDies = 3;\\n        int oneButLive = 4;\\n        int oneButOver = 5;\\n        int zeroButLive = 6;\\n        \\n        for(int i=0;i<matrix.length;i++){   \\n            for(int j=0;j<matrix[0].length;j++){\\n                \\n                int cnt = countLiveNeighbours(matrix,i,j);\\n               \\n                if(matrix[i][j] == 1){     \\n                    if(cnt<2) matrix[i][j] = oneButDies;\\n                    else if(cnt==2 || cnt==3) matrix[i][j] = oneButLive;\\n                    else if(cnt>3) matrix[i][j] = oneButOver;\\n                    \\n                }\\n                else {\\n                    if(cnt == 3) matrix[i][j] = zeroButLive;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j =0;j<matrix[0].length;j++){\\n                \\n                if(matrix[i][j] == oneButDies) matrix[i][j] = 0;\\n                else if(matrix[i][j] == oneButLive) matrix[i][j] = 1;\\n                else if(matrix[i][j] == oneButOver) matrix[i][j] = 0;\\n                else if(matrix[i][j] == zeroButLive) matrix[i][j] = 1;\\n                \\n            }\\n        }  \\n    }\\n    \\n    int[] dy = new int[]{0,1,0,-1,1,-1,1,-1};\\n    int[] dx = new int[]{1,0,-1,0,1,1,-1,-1};\\n    \\n    public int countLiveNeighbours(int matrix[][],int row,int col){\\n        int cnt = 0;\\n        for(int i=0;i<8;i++){\\n            int r = row+dy[i];\\n            int c = col+dx[i];\\n\\n            if(r<0 || r>=matrix.length || c<0 || c>=matrix[0].length) continue;\\n            \\n            if(matrix[r][c] == 1 || matrix[r][c] == 3 || matrix[r][c] == 4 || matrix[r][c]==5) cnt++;\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [],
                "code": "So the idea is very simple we count the number of live neighbours for each cell.\\n**if our current cell is live (i.e 1) then we can have 3 cases :**\\n**i)** **number of live neighbours is less than 2.**\\n\\n\\tIn this case our current cell will die due to under population So we will mark it  3.\\n**ii) number of live neighbours is 2 or 3.**\\n\\n\\tIn this case our current cell will live So we will mark it 4.\\n**iii) number of live neighbours is greater then 4.**\\n\\n\\t In this case our current cell will die due to over population So we will mark it 5.\\n  \\n**if our current cell is dead (i.e 0) and if it has exactly 3 live neighbour then this cell will become alive So we will mark it as 6.**\\n\\nNow at the end we again itetrate the matrix and we will update the cell according to the value present on it.\\n\\nIf you like the explanation \\n**Please do upvote !!**\\n\\n`public void gameOfLife(int[][] matrix) {`\\n        \\n        int oneButDies = 3;\\n        int oneButLive = 4;\\n        int oneButOver = 5;\\n        int zeroButLive = 6;\\n        \\n        for(int i=0;i<matrix.length;i++){   \\n            for(int j=0;j<matrix[0].length;j++){\\n                \\n                int cnt = countLiveNeighbours(matrix,i,j);\\n               \\n                if(matrix[i][j] == 1){     \\n                    if(cnt<2) matrix[i][j] = oneButDies;\\n                    else if(cnt==2 || cnt==3) matrix[i][j] = oneButLive;\\n                    else if(cnt>3) matrix[i][j] = oneButOver;\\n                    \\n                }\\n                else {\\n                    if(cnt == 3) matrix[i][j] = zeroButLive;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j =0;j<matrix[0].length;j++){\\n                \\n                if(matrix[i][j] == oneButDies) matrix[i][j] = 0;\\n                else if(matrix[i][j] == oneButLive) matrix[i][j] = 1;\\n                else if(matrix[i][j] == oneButOver) matrix[i][j] = 0;\\n                else if(matrix[i][j] == zeroButLive) matrix[i][j] = 1;\\n                \\n            }\\n        }  \\n    }\\n    \\n    int[] dy = new int[]{0,1,0,-1,1,-1,1,-1};\\n    int[] dx = new int[]{1,0,-1,0,1,1,-1,-1};\\n    \\n    public int countLiveNeighbours(int matrix[][],int row,int col){\\n        int cnt = 0;\\n        for(int i=0;i<8;i++){\\n            int r = row+dy[i];\\n            int c = col+dx[i];\\n\\n            if(r<0 || r>=matrix.length || c<0 || c>=matrix[0].length) continue;\\n            \\n            if(matrix[r][c] == 1 || matrix[r][c] == 3 || matrix[r][c] == 4 || matrix[r][c]==5) cnt++;\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2230959,
                "title": "simple-c-code-100-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int dirx[8] = {0,0,-1,1,-1,1,-1,1};\\n    int diry[8] = {-1,1,0,0,-1,1,1,-1};\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> glitch(n, vector<int> (m));\\n        glitch = board;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                int ones = 0;\\n                for(int k = 0; k < 8; k++)\\n                {\\n                    int x = i + dirx[k];\\n                    int y = j + diry[k];\\n                    if(x >= n || y >= m || x < 0 || y < 0 || glitch[x][y] == 0) continue;\\n                    ones++;\\n                }\\n                if(board[i][j] == 0 && ones == 3)\\n                {\\n                    board[i][j] = 1;\\n                }\\n                else if(board[i][j] == 1)\\n                {\\n                    if(ones == 2 || ones == 3)\\n                        board[i][j] = 1;\\n                    else\\n                        board[i][j] = 0;\\n                }\\n            }\\n        }\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dirx[8] = {0,0,-1,1,-1,1,-1,1};\\n    int diry[8] = {-1,1,0,0,-1,1,1,-1};\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> glitch(n, vector<int> (m));\\n        glitch = board;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                int ones = 0;\\n                for(int k = 0; k < 8; k++)\\n                {\\n                    int x = i + dirx[k];\\n                    int y = j + diry[k];\\n                    if(x >= n || y >= m || x < 0 || y < 0 || glitch[x][y] == 0) continue;\\n                    ones++;\\n                }\\n                if(board[i][j] == 0 && ones == 3)\\n                {\\n                    board[i][j] = 1;\\n                }\\n                else if(board[i][j] == 1)\\n                {\\n                    if(ones == 2 || ones == 3)\\n                        board[i][j] = 1;\\n                    else\\n                        board[i][j] = 0;\\n                }\\n            }\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156132,
                "title": "easy-to-understand-c-solution-beats-100-tc-o-mn-sp-1",
                "content": "```\\n// Define 4 conditions of board[i][j]\\n//  0 indicates board[i][j] will stay 0 in the next stage\\n//  1 indicates board[i][j] will stay 1 in the next stage\\n//  2 indicates board[i][j] was 0 and will become 1 in the next stage\\n//  3 indicates board[i][j] was 1 and will become 0 in the next stage\\n\\nclass Solution\\n{\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) \\n    {\\n        int m = board.size();\\n        int n = board[0].size();\\n        int X[] = {0, 1, 1, 1, 0,-1,-1,-1};\\n        int Y[] = {1, 1, 0,-1,-1,-1, 0, 1};\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int count = 0;\\n                for(int k = 0; k < 8; k++)\\n                {\\n                    int x = i + X[k];\\n                    int y = j + Y[k];\\n                    \\n                    if( x >= 0 && x < m && y >= 0 && y < n && \\n                       (board[x][y] == 1 || board[x][y] == 3 ) )\\n                        count++;\\n                }\\n                if(count < 2 && board[i][j] == 1)    board[i][j] = 3;\\n                else if(count > 3 && board[i][j] == 1) board[i][j] = 3;\\n                else if(count == 3 && board[i][j] == 0) board[i][j] = 2;\\n            }\\n        }\\n        \\n//      after the conditions have been set we simply change the board[i][j] values to  0 and 1\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(board[i][j] == 2)        board[i][j] = 1;\\n                else if(board[i][j] == 3)   board[i][j] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\n// Define 4 conditions of board[i][j]\\n//  0 indicates board[i][j] will stay 0 in the next stage\\n//  1 indicates board[i][j] will stay 1 in the next stage\\n//  2 indicates board[i][j] was 0 and will become 1 in the next stage\\n//  3 indicates board[i][j] was 1 and will become 0 in the next stage\\n\\nclass Solution\\n{\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) \\n    {\\n        int m = board.size();\\n        int n = board[0].size();\\n        int X[] = {0, 1, 1, 1, 0,-1,-1,-1};\\n        int Y[] = {1, 1, 0,-1,-1,-1, 0, 1};\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int count = 0;\\n                for(int k = 0; k < 8; k++)\\n                {\\n                    int x = i + X[k];\\n                    int y = j + Y[k];\\n                    \\n                    if( x >= 0 && x < m && y >= 0 && y < n && \\n                       (board[x][y] == 1 || board[x][y] == 3 ) )\\n                        count++;\\n                }\\n                if(count < 2 && board[i][j] == 1)    board[i][j] = 3;\\n                else if(count > 3 && board[i][j] == 1) board[i][j] = 3;\\n                else if(count == 3 && board[i][j] == 0) board[i][j] = 2;\\n            }\\n        }\\n        \\n//      after the conditions have been set we simply change the board[i][j] values to  0 and 1\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(board[i][j] == 2)        board[i][j] = 1;\\n                else if(board[i][j] == 3)   board[i][j] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114691,
                "title": "c-inplace-solution",
                "content": "If the value of any cell is updated, upcoming calculations will be effected. So, to update values from 0 to 1 or 1 to 0, what about adding 2 to them. My suggestion is as follows:\\n* For each cell, check if cell needs to be updated. If update is needed (0 to 1 OR 1 to 0), add 2 to cells. \\n* To check the number of live cells, instead of checking value == 0, check if value % 2 == 0. \\n* After traversing all the cells, \\n\\t* 0 means dead cells and they will remain dead. \\n\\t* 1 means live cells and they will remain live.\\n\\t* 2 means dead cell who will become live.\\n\\t* 3 means live cell who will become dead.\\n* To update all the cells to valid values, update those having >= 2 condition to (3-x) to make 2->1 and 3->0\\n\\nMy code:\\n```c++\\nclass Solution {\\npublic:\\n    \\n    bool change(vector<vector<int>>& board, int i, int j) {\\n        unsigned short int numOnes = 0;\\n        \\n        for(int ii = -1; ii <= 1; ii++) {\\n            for (int jj =-1; jj <= 1; jj++) {\\n                if(ii == 0 && jj == 0)\\n                    continue;\\n                if(i + ii < 0 || i + ii == board.size())\\n                    continue;\\n                if(j + jj < 0 || j + jj == board[0].size())\\n                    continue;\\n                \\n                numOnes += (board[i+ii][j+jj]%2);\\n            }\\n        }\\n        \\n        if (board[i][j] && (numOnes < 2 || numOnes > 3))\\n            return true;\\n        if(!board[i][j] && numOnes == 3)\\n            return true;\\n        return false;\\n        \\n    }\\n    \\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        // make 0->2 to 1->3 to make sure they will be updated. mod 2 values will remain same.\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(change(board,i,j)) {\\n                    board[i][j] += 2;\\n                }\\n            }\\n        }\\n        \\n        // if board value is above 1, 3-value will be 0 or 1 (2 will be 1, 3 will be 0).\\n        // Let current value of board[i][j] be x. (x%2) = old value, (3-x) will be new value.\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                board[i][j] = board[i][j] >= 2 ? 3-board[i][j] : board[i][j];\\n            }\\n        }\\n        \\n    }\\n};\\n```\\n\\nLet me know if you have suggestions or questions.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    \\n    bool change(vector<vector<int>>& board, int i, int j) {\\n        unsigned short int numOnes = 0;\\n        \\n        for(int ii = -1; ii <= 1; ii++) {\\n            for (int jj =-1; jj <= 1; jj++) {\\n                if(ii == 0 && jj == 0)\\n                    continue;\\n                if(i + ii < 0 || i + ii == board.size())\\n                    continue;\\n                if(j + jj < 0 || j + jj == board[0].size())\\n                    continue;\\n                \\n                numOnes += (board[i+ii][j+jj]%2);\\n            }\\n        }\\n        \\n        if (board[i][j] && (numOnes < 2 || numOnes > 3))\\n            return true;\\n        if(!board[i][j] && numOnes == 3)\\n            return true;\\n        return false;\\n        \\n    }\\n    \\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        // make 0->2 to 1->3 to make sure they will be updated. mod 2 values will remain same.\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(change(board,i,j)) {\\n                    board[i][j] += 2;\\n                }\\n            }\\n        }\\n        \\n        // if board value is above 1, 3-value will be 0 or 1 (2 will be 1, 3 will be 0).\\n        // Let current value of board[i][j] be x. (x%2) = old value, (3-x) will be new value.\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                board[i][j] = board[i][j] >= 2 ? 3-board[i][j] : board[i][j];\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078130,
                "title": "simple-java-solution-with-no-extra-space",
                "content": "To avoid extra space we have to store a particular state of the position in a unique number so that later we can change that number back to 0 or 1 before returning.\\n\\nWe will encounter 4 states while making changes to the given matrix.\\n1. ``live cell -> live cell``     [we will store this state with number 2]\\n2. ``live cell -> dead cell``  [we will store this state with number 3]\\n3. ``dead-> dead cell``       [we will store this state with number 4]\\n4. ``dead -> live cell``        [we will store this state with number 5]\\n\\nThus while making changes to given matrix we have to follow original state. Live cell will be either 1( if a cell is not reached by any yet), 2 and 3. Dead cell will be given by 0(if a cell is not reached by any yet), 4 and 5. At last after all processing we will make 2 or 5 back to 1 as their current state is live and 3 or 4 to 0 as their current state is dead.\\n`` \\n I used array a,b to avoid those 8 if cases to be written again & again :)\\n``\\n```\\nclass Solution {\\n    public void gameOfLife(int[][] arr) {\\n        int n=arr.length;\\n        int m=arr[0].length;\\n        int a[]= new int[]{-1,-1,-1,0,0,1,1,1};\\n        int b[]= new int[]{-1,0,1,-1,1,-1,0,1};\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int count=0;\\n                for(int p=0;p<8;p++)\\n                {\\n                    if(check(i+a[p],j+b[p],arr) && (arr[i+a[p]][j+b[p]]==1 || arr[i+a[p]][j+b[p]]==2 || arr[i+a[p]][j+b[p]]==3) )\\n                        count++;\\n                }\\n                if((arr[i][j]==0 || arr[i][j]==4 || arr[i][j]==5) && count==3)\\n                {\\n                    arr[i][j]=5;\\n                }\\n                else if(arr[i][j]==1 || arr[i][j]==2 || arr[i][j]==3)\\n                {\\n                    if(count<2)\\n                        arr[i][j]=3;\\n                    else if(count==2 || count==3)\\n                        arr[i][j]=2;\\n                    else if(count>3)\\n                        arr[i][j]=3;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(arr[i][j]==2 || arr[i][j]==5)\\n                    arr[i][j]=1;\\n                else if(arr[i][j]==3 || arr[i][j]==4)\\n                    arr[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n    \\n    public boolean check(int i, int j,int arr[][])\\n    {\\n        int n=arr.length,m=arr[0].length;\\n        if(i<0 || i>=n || j<0 || j>=m)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void gameOfLife(int[][] arr) {\\n        int n=arr.length;\\n        int m=arr[0].length;\\n        int a[]= new int[]{-1,-1,-1,0,0,1,1,1};\\n        int b[]= new int[]{-1,0,1,-1,1,-1,0,1};\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int count=0;\\n                for(int p=0;p<8;p++)\\n                {\\n                    if(check(i+a[p],j+b[p],arr) && (arr[i+a[p]][j+b[p]]==1 || arr[i+a[p]][j+b[p]]==2 || arr[i+a[p]][j+b[p]]==3) )\\n                        count++;\\n                }\\n                if((arr[i][j]==0 || arr[i][j]==4 || arr[i][j]==5) && count==3)\\n                {\\n                    arr[i][j]=5;\\n                }\\n                else if(arr[i][j]==1 || arr[i][j]==2 || arr[i][j]==3)\\n                {\\n                    if(count<2)\\n                        arr[i][j]=3;\\n                    else if(count==2 || count==3)\\n                        arr[i][j]=2;\\n                    else if(count>3)\\n                        arr[i][j]=3;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(arr[i][j]==2 || arr[i][j]==5)\\n                    arr[i][j]=1;\\n                else if(arr[i][j]==3 || arr[i][j]==4)\\n                    arr[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n    \\n    public boolean check(int i, int j,int arr[][])\\n    {\\n        int n=arr.length,m=arr[0].length;\\n        if(i<0 || i>=n || j<0 || j>=m)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059227,
                "title": "c-easy-inplace-calculation-no-extra-space",
                "content": "\\t\\tLoop through every cell of the board and find the two conditions; we see that cell will be alive in the following two conditions :\\n\\n* \\t\\tThe count of neighboring ones is exactly three irrespective of the initial value; this will be checked by checking the tens position of the cell value( cell/10)==3.\\n* \\t\\tThe count of neighboring ones is precisely two, and the initial value is one; this will be satisfied when we have 1 at one place and two at the tens place (cell==21)\\n* \\t\\tIn all other conditions, the cell value will be equal to zero.\\n\\t\\n\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        vector<vector<int>> dir={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\\n        // dir contains all 8  directions of traversal\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++){\\n                int cnt=0; //for every place we count number of neighbouring ones\\n                for(vector<int> &d:dir){\\n                    int x=i+d[0];\\n                    int y=j+d[1];\\n                    if(x>=0 && y>=0 && x<n && y<m && board[x][y]%10==1) cnt++;\\n                    // conditions to ensure (x,y) are in bound.\\n                    //board[x][y]%10==1 to check the value in ones position as \\n                    //overall value may have changed but ones position will \\n                    //always have the intial value.\\n                }\\n                board[i][j]+=10*cnt; // Place count of neighbouring ones at tens position\\n            }\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(board[i][j]==21 || board[i][j]/10==3) board[i][j]=1;\\n                // If cell was alive and remaining ones are two or remainig ones\\n                //are exactly three irrespective of cells initial state\\n                else board[i][j]=0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        vector<vector<int>> dir={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\\n        // dir contains all 8  directions of traversal\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++){\\n                int cnt=0; //for every place we count number of neighbouring ones\\n                for(vector<int> &d:dir){\\n                    int x=i+d[0];\\n                    int y=j+d[1];\\n                    if(x>=0 && y>=0 && x<n && y<m && board[x][y]%10==1) cnt++;\\n                    // conditions to ensure (x,y) are in bound.\\n                    //board[x][y]%10==1 to check the value in ones position as \\n                    //overall value may have changed but ones position will \\n                    //always have the intial value.\\n                }\\n                board[i][j]+=10*cnt; // Place count of neighbouring ones at tens position\\n            }\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(board[i][j]==21 || board[i][j]/10==3) board[i][j]=1;\\n                // If cell was alive and remaining ones are two or remainig ones\\n                //are exactly three irrespective of cells initial state\\n                else board[i][j]=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056358,
                "title": "0-ms-beats-100-beginner-friendly-with-comments-in-each-step",
                "content": "Go through the code you\\'ll easily solve it after this approach\\nIf you liked it then please upvote\\n\\n```\\nvoid fun(vector<vector<int>> &board, vector<vector<int>> &ans, int row, int col)\\n{\\n    // var to store the count of neighbour 1\\'s\\n    int count1 = 0;\\n\\n    //all possible 8 directions\\n    int indexes[8][2] = {{0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}, {-1, -1}, {-1, 0}, {-1, 1}};\\n\\n    //go to all 8 directions and store the count of neighbour 1\\'s\\n    for (int i = 0; i < 8; i++)\\n    {\\n        //new position\\n        int x = row + indexes[i][0];\\n        int y = col + indexes[i][1];\\n\\n        // excludingv index out of bound conditions \\n        if (x < 0 || y < 0 || x >= board.size() || y >= board[0].size())\\n        {\\n            continue;\\n        }\\n\\n        if (ans[x][y] == 1)\\n        {\\n            count1++;\\n        }\\n\\n        x = row; // backtrack\\n        y = col; //backtrack\\n    }\\n    \\n    //any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\\n    if (ans[row][col] == 0 && count1 == 3)\\n    {\\n        board[row][col] = 1;\\n    }\\n    // under-population.\\n    else if (ans[row][col] == 1 && count1 == 1 || count1 == 0)\\n    {\\n        board[row][col] = 0;\\n    }\\n    // over-population.\\n    else if (ans[row][col] == 1 && count1 > 3)\\n    {\\n        board[row][col] = 0;\\n    }\\n    // Any live cell with two or three live neighbors lives on to the next generation.\\n    else if (ans[row][col] == 1 && count1 == 2 || count1 == 3)\\n    {\\n        board[row][col] = 1;\\n    }\\n}\\n\\nvoid gameOfLife(vector<vector<int>> &board, vector<vector<int>> &ans)\\n{\\n    // we are taking values in another matrix for checking all the conditions \\n    // since that board matrix will be updated everytime it will give differemt results\\n    vector<vector<int>> ans = board;\\n    int n = board.size();\\n    int m = board[0].size();\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < m; j++)\\n        {\\n            // for each index check the 4 conditons \\n            // if satisfies update \\n            fun(board, ans, i, j);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid fun(vector<vector<int>> &board, vector<vector<int>> &ans, int row, int col)\\n{\\n    // var to store the count of neighbour 1\\'s\\n    int count1 = 0;\\n\\n    //all possible 8 directions\\n    int indexes[8][2] = {{0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}, {-1, -1}, {-1, 0}, {-1, 1}};\\n\\n    //go to all 8 directions and store the count of neighbour 1\\'s\\n    for (int i = 0; i < 8; i++)\\n    {\\n        //new position\\n        int x = row + indexes[i][0];\\n        int y = col + indexes[i][1];\\n\\n        // excludingv index out of bound conditions \\n        if (x < 0 || y < 0 || x >= board.size() || y >= board[0].size())\\n        {\\n            continue;\\n        }\\n\\n        if (ans[x][y] == 1)\\n        {\\n            count1++;\\n        }\\n\\n        x = row; // backtrack\\n        y = col; //backtrack\\n    }\\n    \\n    //any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\\n    if (ans[row][col] == 0 && count1 == 3)\\n    {\\n        board[row][col] = 1;\\n    }\\n    // under-population.\\n    else if (ans[row][col] == 1 && count1 == 1 || count1 == 0)\\n    {\\n        board[row][col] = 0;\\n    }\\n    // over-population.\\n    else if (ans[row][col] == 1 && count1 > 3)\\n    {\\n        board[row][col] = 0;\\n    }\\n    // Any live cell with two or three live neighbors lives on to the next generation.\\n    else if (ans[row][col] == 1 && count1 == 2 || count1 == 3)\\n    {\\n        board[row][col] = 1;\\n    }\\n}\\n\\nvoid gameOfLife(vector<vector<int>> &board, vector<vector<int>> &ans)\\n{\\n    // we are taking values in another matrix for checking all the conditions \\n    // since that board matrix will be updated everytime it will give differemt results\\n    vector<vector<int>> ans = board;\\n    int n = board.size();\\n    int m = board[0].size();\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < m; j++)\\n        {\\n            // for each index check the 4 conditons \\n            // if satisfies update \\n            fun(board, ans, i, j);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2039388,
                "title": "c-update-matrix-in-place-o-m-n-time-o-1-space",
                "content": "The trick with this problem is to recognize that if we are iterating through the matrix and directly update cells with 0 or 1 based on what their next state should be, our logic on subsequent cells will be incorrect.\\n\\nWe need to either create a new matrix to represent the next state (which will take O(m\\\\*n) space) or we need new values to represent births and deaths so we can easily determine what the previous state was for a given cell.\\n\\nThis solution uses 2 and 3 as special identifiers for a birth or a death respectively.\\nThe first pass will evaluate each cell and updates values in the case of a birth or death. To determine whether a neighbor is alive or dead *this round*, it will look at `board[i][j] %2 == 1` \\n0 = dead -> dead\\n1 = alive -> alive\\n2 = dead -> alive (birth)\\n3 = alive -> dead (death)\\n\\nThe second pass will find instances of the special identifiers (values 2 and 3) and update the values to the new alive or dead state of the cell.\\n\\n**Time complexity: O(m\\\\*n)** because we are traversing every cell of the board in two passes and the first pass performs eight operations per cell (note that this time complexity is *linear* with respect to the size of the board).\\n**Space complexity: O(1)** because all updates to the board are done in-place.\\n\\n```\\nclass Solution {\\npublic:\\n    // returns whether cell at i,j is alive or not\\n    bool isAlive(const vector<vector<int>>& board, int i, int j) {\\n        if (i < 0 || i >= board.size()) return false;\\n        if (j < 0 || j >= board[0].size()) return false;\\n        \\n        return (board[i][j] % 2 == 1);\\n    }\\n    \\n    /*\\n        returns number of living neighbors the current cell has this round\\n       (even if a given neighbor will change its state this round)\\n    */\\n    int getLivingNeighborCount(const vector<vector<int>>& board, int i, int j) {\\n        // check cell\\'s eight neighbors\\n        int livingCount = 0;\\n        for (int rowStep = -1; rowStep <= 1; rowStep++) {\\n            for (int colStep = -1; colStep <= 1; colStep++) {\\n                if (rowStep == 0 && colStep == 0) continue; // don\\'t include board[i][j] in its neighbors\\n                if (isAlive(board, i+rowStep, j+colStep)) livingCount++;\\n            }\\n        }\\n        return livingCount;\\n    }\\n    \\n    /*\\n        marks cells that will be born this round (i.e. go from dead to alive) with a value of 2\\n        marks cells that will die this round (i.e. go from alive to dead) with a value of 3\\n    */\\n    void updateWithBirthsAndDeaths(vector<vector<int>>& board) {\\n        if (board.empty()) return;\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int livingNeighbors = getLivingNeighborCount(board, i, j);\\n                if (board[i][j] && livingNeighbors < 2) board[i][j] = 3;    // under-population (death)\\n                else if (board[i][j] && livingNeighbors > 3) board[i][j] = 3;   // over-population (death)\\n                else if (board[i][j] == 0 && livingNeighbors == 3) board[i][j] = 2; // reproduction (birth)\\n            }\\n        }\\n    }\\n    \\n    /*\\n        updates cells that a value of 2 to value 1 (cell is now alive)\\n        updates cells that a value of 3 to value 0 (cell is now dead)\\n    */\\n    void resolveBirthsAndDeaths(vector<vector<int>>& board) {\\n        if (board.empty()) return;\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == 2) board[i][j] = 1;  // birth\\n                if (board[i][j] == 3) board[i][j] = 0;  // death\\n            }\\n        } \\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        // mark appropriate cells with 2 for a birth, 3 for a death\\n        updateWithBirthsAndDeaths(board);\\n        \\n        // resolve cells with birth and death markers with 0 or 1 values for alive or dead\\n        resolveBirthsAndDeaths(board);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // returns whether cell at i,j is alive or not\\n    bool isAlive(const vector<vector<int>>& board, int i, int j) {\\n        if (i < 0 || i >= board.size()) return false;\\n        if (j < 0 || j >= board[0].size()) return false;\\n        \\n        return (board[i][j] % 2 == 1);\\n    }\\n    \\n    /*\\n        returns number of living neighbors the current cell has this round\\n       (even if a given neighbor will change its state this round)\\n    */\\n    int getLivingNeighborCount(const vector<vector<int>>& board, int i, int j) {\\n        // check cell\\'s eight neighbors\\n        int livingCount = 0;\\n        for (int rowStep = -1; rowStep <= 1; rowStep++) {\\n            for (int colStep = -1; colStep <= 1; colStep++) {\\n                if (rowStep == 0 && colStep == 0) continue; // don\\'t include board[i][j] in its neighbors\\n                if (isAlive(board, i+rowStep, j+colStep)) livingCount++;\\n            }\\n        }\\n        return livingCount;\\n    }\\n    \\n    /*\\n        marks cells that will be born this round (i.e. go from dead to alive) with a value of 2\\n        marks cells that will die this round (i.e. go from alive to dead) with a value of 3\\n    */\\n    void updateWithBirthsAndDeaths(vector<vector<int>>& board) {\\n        if (board.empty()) return;\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int livingNeighbors = getLivingNeighborCount(board, i, j);\\n                if (board[i][j] && livingNeighbors < 2) board[i][j] = 3;    // under-population (death)\\n                else if (board[i][j] && livingNeighbors > 3) board[i][j] = 3;   // over-population (death)\\n                else if (board[i][j] == 0 && livingNeighbors == 3) board[i][j] = 2; // reproduction (birth)\\n            }\\n        }\\n    }\\n    \\n    /*\\n        updates cells that a value of 2 to value 1 (cell is now alive)\\n        updates cells that a value of 3 to value 0 (cell is now dead)\\n    */\\n    void resolveBirthsAndDeaths(vector<vector<int>>& board) {\\n        if (board.empty()) return;\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == 2) board[i][j] = 1;  // birth\\n                if (board[i][j] == 3) board[i][j] = 0;  // death\\n            }\\n        } \\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        // mark appropriate cells with 2 for a birth, 3 for a death\\n        updateWithBirthsAndDeaths(board);\\n        \\n        // resolve cells with birth and death markers with 0 or 1 values for alive or dead\\n        resolveBirthsAndDeaths(board);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029539,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public void gameOfLife(int[][] n) {\\n        int a=n.length,b=n[0].length;\\n        int m[][]=new int[a][b];\\n        for(int i=0;i<a;i++)\\n        {\\n            for(int j=0;j<b;j++)\\n            {\\n                m[i][j]=n[i][j];\\n            }\\n        }\\n        for(int i=0;i<a;i++)\\n        {\\n            for(int j=0;j<b;j++)\\n            {\\n                int k=task(m,i,j);\\n                if(m[i][j]==0&&k==3)\\n                    n[i][j]=1;\\n                else if(m[i][j]==1&&(k==2||k==3))\\n                    n[i][j]=1;\\n                else if(m[i][j]==1&&(k<2||k>3))\\n                    n[i][j]=0;\\n            }\\n        }\\n    }\\n    static int task(int n[][], int i, int j)\\n    {\\n        int f=0;\\n        int d[][] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n        for(int di[]:d)\\n        {\\n            int x=di[0]+i;\\n            int y=di[1]+j;\\n            if(x<0||y<0||x>=n.length||y>=n[0].length)\\n                continue;\\n            else if(n[x][y]==1)\\n                f++;\\n        }\\n        return f;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public void gameOfLife(int[][] n) {\\n        int a=n.length,b=n[0].length;\\n        int m[][]=new int[a][b];\\n        for(int i=0;i<a;i++)\\n        {\\n            for(int j=0;j<b;j++)\\n            {\\n                m[i][j]=n[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2004024,
                "title": "game-of-life-medium-learned-c-100-fast",
                "content": "\\tbool isValidNeighbor(int x, int y, vector<vector<int>>& board) {\\n        return (x >= 0 && x < board.size() && y >= 0 && y < board[0].size());\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) { \\n        vector<int> dx = {0, 0, 1, 1, 1, -1, -1, -1}; //8 coordinated for neighbours\\n        vector<int> dy = {1, -1, 1, -1, 0, 0, 1, -1};\\n        \\n        for (int row = 0; row < board.size(); row++) {\\n            for (int col = 0; col < board[0].size(); col++) {\\n                \\n                int count_live_neighbors = 0;\\n                \\n                for (int i = 0; i < 8; i++) {\\n                    int curr_x = row + dx[i], curr_y = col +dy[i];\\n                    if (isValidNeighbor(curr_x, curr_y, board) && abs(board[curr_x][curr_y]) == 1)\\n                        count_live_neighbors++;\\n                }\\n                \\n                if (board[row][col] == 1 && (count_live_neighbors < 2 || count_live_neighbors > 3))\\n                    board[row][col] = -1;\\n                \\n                if (board[row][col] == 0 && count_live_neighbors == 3)\\n                    board[row][col] = 2;\\n            }\\n        }\\n        \\n        for (int row = 0; row < board.size(); row++) {\\n            for (int col = 0; col < board[0].size(); col++) {\\n                if (board[row][col] >= 1)\\n                    board[row][col] = 1;\\n                else\\n                    board[row][col] = 0;\\n            }\\n        }\\n    }\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\tbool isValidNeighbor(int x, int y, vector<vector<int>>& board) {\\n        return (x >= 0 && x < board.size() && y >= 0 && y < board[0].size());\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) { \\n        vector<int> dx = {0, 0, 1, 1, 1, -1, -1, -1}; //8 coordinated for neighbours\\n        vector<int> dy = {1, -1, 1, -1, 0, 0, 1, -1};\\n        \\n        for (int row = 0; row < board.size(); row++) {\\n            for (int col = 0; col < board[0].size(); col++) {\\n                \\n                int count_live_neighbors = 0;\\n                \\n                for (int i = 0; i < 8; i++) {\\n                    int curr_x = row + dx[i], curr_y = col +dy[i];\\n                    if (isValidNeighbor(curr_x, curr_y, board) && abs(board[curr_x][curr_y]) == 1)\\n                        count_live_neighbors++;\\n                }\\n                \\n                if (board[row][col] == 1 && (count_live_neighbors < 2 || count_live_neighbors > 3))\\n                    board[row][col] = -1;\\n                \\n                if (board[row][col] == 0 && count_live_neighbors == 3)\\n                    board[row][col] = 2;\\n            }\\n        }\\n        \\n        for (int row = 0; row < board.size(); row++) {\\n            for (int col = 0; col < board[0].size(); col++) {\\n                if (board[row][col] >= 1)\\n                    board[row][col] = 1;\\n                else\\n                    board[row][col] = 0;\\n            }\\n        }\\n    }\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1940731,
                "title": "simple-solution",
                "content": "```\\npair<int,int> find(vector<vector<int>>& nums,int ro,int co){\\n        int row = nums.size()-1,col = nums[0].size()-1;\\n        pair<int,int> p;\\n        int z=0,o=0;\\n        if(ro-1>=0){\\n            if(nums[ro-1][co] == 1) o++;\\n            else z++;\\n        }\\n        if(ro+1<=row){\\n            if(nums[ro+1][co] == 1) o++;\\n            else z++;\\n        }\\n        if(co-1>=0){\\n            if(nums[ro][co-1] == 1) o++;\\n            else z++;\\n        }\\n        if(co+1<=col){\\n            if(nums[ro][co+1] == 1) o++;\\n            else z++;\\n        }\\n        if(ro-1>=0 && co-1>=0){\\n            if(nums[ro-1][co-1] == 1) o++;\\n            else z++;\\n        }\\n        if(ro-1>=0 && co+1<=col){\\n            if(nums[ro-1][co+1] == 1) o++;\\n            else z++;\\n        }\\n        if(ro+1<=row && co-1>=0){\\n            if(nums[ro+1][co-1] == 1) o++;\\n            else z++;\\n        }\\n        if(ro+1<=row && co+1<=col){\\n            if(nums[ro+1][co+1] == 1) o++;\\n            else z++;\\n        }\\n        return {z,o};\\n    }\\n    void gameOfLife(vector<vector<int>>& nums) {\\n        vector<vector<pair<int,int>>> v(nums.size(),vector<pair<int,int>>(nums[0].size()));\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums[0].size();j++){\\n                pair<int,int> p;\\n                p = find(nums,i,j);\\n                v[i][j] = p;\\n            }\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums[0].size();j++){\\n                int ones = v[i][j].second;\\n                int zero = v[i][j].first;\\n                if(nums[i][j] == 0){\\n                    if(ones == 3) nums[i][j] = 1;\\n                }else{\\n                    if(ones < 2 || ones > 3) nums[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\npair<int,int> find(vector<vector<int>>& nums,int ro,int co){\\n        int row = nums.size()-1,col = nums[0].size()-1;\\n        pair<int,int> p;\\n        int z=0,o=0;\\n        if(ro-1>=0){\\n            if(nums[ro-1][co] == 1) o++;\\n            else z++;\\n        }\\n        if(ro+1<=row){\\n            if(nums[ro+1][co] == 1) o++;\\n            else z++;\\n        }\\n        if(co-1>=0){\\n            if(nums[ro][co-1] == 1) o++;\\n            else z++;\\n        }\\n        if(co+1<=col){\\n            if(nums[ro][co+1] == 1) o++;\\n            else z++;\\n        }\\n        if(ro-1>=0 && co-1>=0){\\n            if(nums[ro-1][co-1] == 1) o++;\\n            else z++;\\n        }\\n        if(ro-1>=0 && co+1<=col){\\n            if(nums[ro-1][co+1] == 1) o++;\\n            else z++;\\n        }\\n        if(ro+1<=row && co-1>=0){\\n            if(nums[ro+1][co-1] == 1) o++;\\n            else z++;\\n        }\\n        if(ro+1<=row && co+1<=col){\\n            if(nums[ro+1][co+1] == 1) o++;\\n            else z++;\\n        }\\n        return {z,o};\\n    }\\n    void gameOfLife(vector<vector<int>>& nums) {\\n        vector<vector<pair<int,int>>> v(nums.size(),vector<pair<int,int>>(nums[0].size()));\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums[0].size();j++){\\n                pair<int,int> p;\\n                p = find(nums,i,j);\\n                v[i][j] = p;\\n            }\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums[0].size();j++){\\n                int ones = v[i][j].second;\\n                int zero = v[i][j].first;\\n                if(nums[i][j] == 0){\\n                    if(ones == 3) nums[i][j] = 1;\\n                }else{\\n                    if(ones < 2 || ones > 3) nums[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940727,
                "title": "c-check-all-8-directions-to-follow-the-rules-dlc-april13",
                "content": "```\\nclass Solution {\\npublic:\\n   int getLiveNeighbours(vector<vector<int>>& curr, int i, int j, int m, int n) {\\n\\tint liveNeighbours = 0;\\n\\tif(i>0) {\\n\\t\\t//check the upper neighbour\\n\\t\\tif(curr[i-1][j] == 1 || curr[i-1][j] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1) {\\n\\t\\t//check the lower neighbour\\n\\t\\tif(curr[i+1][j] == 1 || curr[i+1][j] == 3) liveNeighbours++;\\n\\t}\\n\\tif(j>0) {\\n\\t\\t//check the left neighbour\\n\\t\\tif(curr[i][j-1] == 1 || curr[i][j-1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(j<n-1) {\\n\\t\\t//check the right neighbour\\n\\t\\tif(curr[i][j+1] == 1 || curr[i][j+1] == 3) liveNeighbours++;\\n\\t}\\n\\n\\tif(i>0 && j>0) {\\n\\t\\tif(curr[i-1][j-1] == 1 || curr[i-1][j-1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i>0 && j<n-1) {\\n\\t\\tif(curr[i-1][j+1] == 1 || curr[i-1][j+1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1 && j>0) {\\n\\t\\tif(curr[i+1][j-1] == 1 || curr[i+1][j-1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1 && j<n-1) {\\n\\t\\tif(curr[i+1][j+1] == 1 || curr[i+1][j+1] == 3) liveNeighbours++;\\n\\t}\\n\\treturn liveNeighbours;\\n}\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n\\tint m = board.size();\\n\\tint n = board[0].size();\\n\\tfor(int i = 0; i<m; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tint ln = getLiveNeighbours(board, i, j, m, n);\\n\\t\\t\\tif(board[i][j] == 0) {\\n\\t\\t\\t\\t//currently dead\\n\\t\\t\\t\\t//can become alive if has exactly three live neighbours\\n\\t\\t\\t\\tif(ln == 3) {\\n\\t\\t\\t\\t\\tboard[i][j] = 2; //newly alive\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(board[i][j] == 1) {\\n\\t\\t\\t\\t//<2 -> die\\n\\t\\t\\t\\t//==2 || ==3 live\\n\\t\\t\\t\\t//>3 ->die\\n\\t\\t\\t\\tif(ln < 2 || ln > 3) {\\n\\t\\t\\t\\t\\tboard[i][j] = 3; //newly dead\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t//final modifications 2->1, 3->0\\n\\tfor(int i = 0; i<m; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tif(board[i][j] == 2) board[i][j] = 1;\\n\\t\\t\\telse if(board[i][j] == 3) board[i][j] = 0;\\n\\t\\t}\\n\\t}\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int getLiveNeighbours(vector<vector<int>>& curr, int i, int j, int m, int n) {\\n\\tint liveNeighbours = 0;\\n\\tif(i>0) {\\n\\t\\t//check the upper neighbour\\n\\t\\tif(curr[i-1][j] == 1 || curr[i-1][j] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1) {\\n\\t\\t//check the lower neighbour\\n\\t\\tif(curr[i+1][j] == 1 || curr[i+1][j] == 3) liveNeighbours++;\\n\\t}\\n\\tif(j>0) {\\n\\t\\t//check the left neighbour\\n\\t\\tif(curr[i][j-1] == 1 || curr[i][j-1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(j<n-1) {\\n\\t\\t//check the right neighbour\\n\\t\\tif(curr[i][j+1] == 1 || curr[i][j+1] == 3) liveNeighbours++;\\n\\t}\\n\\n\\tif(i>0 && j>0) {\\n\\t\\tif(curr[i-1][j-1] == 1 || curr[i-1][j-1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i>0 && j<n-1) {\\n\\t\\tif(curr[i-1][j+1] == 1 || curr[i-1][j+1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1 && j>0) {\\n\\t\\tif(curr[i+1][j-1] == 1 || curr[i+1][j-1] == 3) liveNeighbours++;\\n\\t}\\n\\tif(i<m-1 && j<n-1) {\\n\\t\\tif(curr[i+1][j+1] == 1 || curr[i+1][j+1] == 3) liveNeighbours++;\\n\\t}\\n\\treturn liveNeighbours;\\n}\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n\\tint m = board.size();\\n\\tint n = board[0].size();\\n\\tfor(int i = 0; i<m; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tint ln = getLiveNeighbours(board, i, j, m, n);\\n\\t\\t\\tif(board[i][j] == 0) {\\n\\t\\t\\t\\t//currently dead\\n\\t\\t\\t\\t//can become alive if has exactly three live neighbours\\n\\t\\t\\t\\tif(ln == 3) {\\n\\t\\t\\t\\t\\tboard[i][j] = 2; //newly alive\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(board[i][j] == 1) {\\n\\t\\t\\t\\t//<2 -> die\\n\\t\\t\\t\\t//==2 || ==3 live\\n\\t\\t\\t\\t//>3 ->die\\n\\t\\t\\t\\tif(ln < 2 || ln > 3) {\\n\\t\\t\\t\\t\\tboard[i][j] = 3; //newly dead\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t//final modifications 2->1, 3->0\\n\\tfor(int i = 0; i<m; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tif(board[i][j] == 2) board[i][j] = 1;\\n\\t\\t\\telse if(board[i][j] == 3) board[i][j] = 0;\\n\\t\\t}\\n\\t}\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940402,
                "title": "c-in-place-memory-84-4",
                "content": "```c++\\nclass Solution {\\n    \\n    int markDeadFromAlive = 100;\\n    int markAliveFromDead = 101;\\n    \\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        \\n        int row = size(board);\\n        int column = size(board[0]);\\n        \\n        vector<pair<int, int>> directions = { \\n            {-1, -1}, { -1, 0}, { -1, 1}, \\n            {0,-1}, {0, 1},\\n            {1, -1}, {1, 0}, {1, 1}\\n        };\\n        \\n        auto isValid = [row, column](int i, int j) -> bool {\\n            if (!( i >= 0 && i < row)) { return false; }\\n            if (!( j >= 0 && j < column)) { return false; }\\n            return true;\\n        };\\n        \\n        auto getCount = [&] (int i, int j) -> int {\\n            int count = 0;\\n            for (auto x: directions) {\\n                if ( isValid( i + x.first, j + x.second ) ) {\\n                    count += ( board[i + x.first][j + x.second] == 1 \\n                              || board[i + x.first][j + x.second] == markDeadFromAlive ? 1 : 0 ); \\n                }\\n            }\\n            return count;\\n        };\\n        \\n        for( int i = 0; i < size(board); i++ ) {\\n            for( int j = 0; j < size(board[0]); j++ ) {\\n                int count = getCount(i, j);\\n                if ( count == 3 ) {\\n                    if ( board[i][j] == 0 ) board[i][j] = markAliveFromDead;\\n                } else if( count < 2 ) {\\n                    if ( board[i][j] == 1 ) board[i][j] = markDeadFromAlive;\\n                } else if ( count > 3 ) {\\n                    if ( board[i][j] == 1 ) board[i][j] = markDeadFromAlive;\\n                }\\n            }\\n        }\\n        \\n        for( int i = 0; i < size(board); i++ ) {\\n            for( int j = 0; j < size(board[0]); j++ ) {\\n                if (board[i][j] == markDeadFromAlive) {\\n                    board[i][j] = 0;\\n                } else if (board[i][j] == markAliveFromDead) {\\n                    board[i][j] = 1;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\n    \\n    int markDeadFromAlive = 100;\\n    int markAliveFromDead = 101;\\n    \\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        \\n        int row = size(board);\\n        int column = size(board[0]);\\n        \\n        vector<pair<int, int>> directions = { \\n            {-1, -1}, { -1, 0}, { -1, 1}, \\n            {0,-1}, {0, 1},\\n            {1, -1}, {1, 0}, {1, 1}\\n        };\\n        \\n        auto isValid = [row, column](int i, int j) -> bool {\\n            if (!( i >= 0 && i < row)) { return false; }\\n            if (!( j >= 0 && j < column)) { return false; }\\n            return true;\\n        };\\n        \\n        auto getCount = [&] (int i, int j) -> int {\\n            int count = 0;\\n            for (auto x: directions) {\\n                if ( isValid( i + x.first, j + x.second ) ) {\\n                    count += ( board[i + x.first][j + x.second] == 1 \\n                              || board[i + x.first][j + x.second] == markDeadFromAlive ? 1 : 0 ); \\n                }\\n            }\\n            return count;\\n        };\\n        \\n        for( int i = 0; i < size(board); i++ ) {\\n            for( int j = 0; j < size(board[0]); j++ ) {\\n                int count = getCount(i, j);\\n                if ( count == 3 ) {\\n                    if ( board[i][j] == 0 ) board[i][j] = markAliveFromDead;\\n                } else if( count < 2 ) {\\n                    if ( board[i][j] == 1 ) board[i][j] = markDeadFromAlive;\\n                } else if ( count > 3 ) {\\n                    if ( board[i][j] == 1 ) board[i][j] = markDeadFromAlive;\\n                }\\n            }\\n        }\\n        \\n        for( int i = 0; i < size(board); i++ ) {\\n            for( int j = 0; j < size(board[0]); j++ ) {\\n                if (board[i][j] == markDeadFromAlive) {\\n                    board[i][j] = 0;\\n                } else if (board[i][j] == markAliveFromDead) {\\n                    board[i][j] = 1;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940256,
                "title": "0ms-100-faster-than-java-submission-easy-to-understand",
                "content": "Easy and clean code.\\n\\nclass Solution {\\n    public void gameOfLife(int[][] a) {\\n        \\n        int n=a.length;\\n        int m=a[0].length;\\n        \\n        int[][] re = new int[n][m];\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                int one=0;\\n                \\n        \\n                    if(i<n && j+1<m && a[i][j+1]==1)\\n                    {\\n                        one++;\\n                    }\\n                    if(i<n && j-1>=0 && a[i][j-1]==1)\\n                    {\\n                        one++;\\n                    }\\n                    if(i+1<n && j<m && a[i+1][j]==1)\\n                    {\\n                        one++;\\n                    }\\n                    if(i-1>=0 && j<m && a[i-1][j]==1)\\n                    {\\n                        one++;\\n                    }\\n                    \\n                    if(i-1>=0 && j+1<m && a[i-1][j+1]==1)\\n                    {\\n                        one++;\\n                    }\\n                    if(i+1<n && j+1<m && a[i+1][j+1]==1)\\n                    {\\n                        one++;\\n                    }\\n                    if(i+1<n && j-1>=0 && a[i+1][j-1]==1)\\n                    {\\n                        one++;\\n                    }\\n                    if(i-1>=0 && j-1>=0 && a[i-1][j-1]==1)\\n                    {\\n                        one++;\\n                    }\\n                    \\n                if(a[i][j]==1)\\n                {\\n                    if(one<2)\\n                    {\\n                        re[i][j]=0;\\n                    }\\n                    else if(one==2 || one==3)\\n                    {\\n                        re[i][j]=1;\\n                    }\\n                    else\\n                    {\\n                        re[i][j]=0;\\n                    }\\n                }\\n                else\\n                {\\n                    if(one==3)\\n                        re[i][j]=1;\\n                    else\\n                        re[i][j]=0;\\n                }\\n                \\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                a[i][j]=re[i][j];\\n            }\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void gameOfLife(int[][] a) {\\n        \\n        int n=a.length;\\n        int m=a[0].length;\\n        \\n        int[][] re = new int[n][m];\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                int one=0;\\n                \\n        \\n                    if(i<n && j+1<m && a[i][j+1]==1)\\n                    {\\n                        one++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1939976,
                "title": "why-is-my-solution-not-working",
                "content": "```\\n    ans = [\\n        [0 for i in range(len(board[0]))] for j in range(len(board))\\n    ]\\n    for i in range(len(board)):\\n        for j in range(len(board[i])):\\n            #number of live neigbours\\n            nol = 0\\n            if i > 0:\\n                if j > 0:\\n                    if board[i-1][j-1] == 1:\\n                        nol += 1\\n                if board[i-1][j] == 1:\\n                    nol += 1\\n                if j < len(board[i])-1:\\n                    if board[i-1][j+1] == 1:\\n                        nol += 1\\n            if j > 0:\\n                if board[i][j-1] == 1:\\n                    nol += 1\\n            if j < len(board[i])-1:\\n                if board[i][j+1] == 1:\\n                    nol += 1\\n            if i < len(board)-1:\\n                if j > 0:\\n                    if board[i+1][j-1] == 1:\\n                        nol += 1\\n                if board[i+1][j] == 1:\\n                    nol += 1\\n                if j < len(board[i])-1:\\n                    if board[i+1][j+1] == 1:\\n                        nol += 1\\n            # next-gen\\n            if nol < 2:\\n                ans[i][j] = 0\\n            elif nol == 2:\\n                ans[i][j] = board[i][j]\\n            elif nol == 3:\\n                ans[i][j] = 1\\n            else:\\n                ans[i][j] = 0\\n    board = ans\\n    print(board)\\n```\\nIt is printing the ans but not replacing the board in Output\\nOutput remains the same as Input",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    ans = [\\n        [0 for i in range(len(board[0]))] for j in range(len(board))\\n    ]\\n    for i in range(len(board)):\\n        for j in range(len(board[i])):\\n            #number of live neigbours\\n            nol = 0\\n            if i > 0:\\n                if j > 0:\\n                    if board[i-1][j-1] == 1:\\n                        nol += 1\\n                if board[i-1][j] == 1:\\n                    nol += 1\\n                if j < len(board[i])-1:\\n                    if board[i-1][j+1] == 1:\\n                        nol += 1\\n            if j > 0:\\n                if board[i][j-1] == 1:\\n                    nol += 1\\n            if j < len(board[i])-1:\\n                if board[i][j+1] == 1:\\n                    nol += 1\\n            if i < len(board)-1:\\n                if j > 0:\\n                    if board[i+1][j-1] == 1:\\n                        nol += 1\\n                if board[i+1][j] == 1:\\n                    nol += 1\\n                if j < len(board[i])-1:\\n                    if board[i+1][j+1] == 1:\\n                        nol += 1\\n            # next-gen\\n            if nol < 2:\\n                ans[i][j] = 0\\n            elif nol == 2:\\n                ans[i][j] = board[i][j]\\n            elif nol == 3:\\n                ans[i][j] = 1\\n            else:\\n                ans[i][j] = 0\\n    board = ans\\n    print(board)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1939830,
                "title": "c-solution-with-notes",
                "content": "```\\nclass Solution {\\nprivate:\\n    //8 neighbors\\n    vector<pair<int,int>> neighbors {\\n        {-1,0}, //top\\n        {1,0},  //bottom\\n        {0,-1}, //left\\n        {0,1},  //right\\n        {-1,-1},//top-left\\n        {-1,1}, //top-right\\n        {1,-1}, //bottom-left\\n        {1,1},  //bottom-right\\n    };\\n    \\n    \\n    //check if the dead cell will be live (if there are exactly 3 live neighbors)\\n    bool dead_cell_check(vector<vector<int>>& board, int i, int j){\\n        int count_neighbors = 0;\\n        \\n        for (auto n : neighbors)\\n            if (no_out_range(board, i + n.first, j + n.second) && board[i + n.first][j + n.second] == 1)\\n                count_neighbors++;\\n        \\n        return count_neighbors == 3;\\n    }\\n\\n    //check if the live cell will be dead (if there are more than 3 or less than 2 live neighbors)\\n    bool live_cell_check(vector<vector<int>>& board, int i, int j){\\n        int count_neighbors = 0;\\n        \\n        for (auto n : neighbors)\\n            if (no_out_range(board, i + n.first, j + n.second) && board[i + n.first][j + n.second] == 1)\\n                count_neighbors++;\\n        \\n        return count_neighbors < 2 || count_neighbors > 3;\\n    }\\n    \\n    //make sure that i and j is not out of range\\n    bool no_out_range(vector<vector<int>>& board, int i, int j){\\n        return (i >= 0 && i < board.size() && j >= 0 && j < board[0].size());\\n    }\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<pair<int,int>> need_to_be_updated;\\n        \\n        //check for each cell if it needs to be changed (if a live cell becomes death or if a death cell becomes live)\\n        for (int i = 0; i < board.size(); i++)\\n            for (int j = 0; j < board[0].size(); j++)\\n                //check for death cell\\n                if (board[i][j] == 0 && dead_cell_check(board,i,j))\\n                    need_to_be_updated.push_back({i,j});\\n                //check for live cell\\n                else if (board[i][j] == 1 && live_cell_check(board,i,j))\\n                    need_to_be_updated.push_back({i,j});\\n            \\n        //update\\n        for (auto x : need_to_be_updated){\\n            int i = x.first, j = x.second;\\n            \\n            if (board[i][j] == 1)\\n                board[i][j] = 0;\\n            else \\n                board[i][j] = 1;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    //8 neighbors\\n    vector<pair<int,int>> neighbors {\\n        {-1,0}, //top\\n        {1,0},  //bottom\\n        {0,-1}, //left\\n        {0,1},  //right\\n        {-1,-1},//top-left\\n        {-1,1}, //top-right\\n        {1,-1}, //bottom-left\\n        {1,1},  //bottom-right\\n    };\\n    \\n    \\n    //check if the dead cell will be live (if there are exactly 3 live neighbors)\\n    bool dead_cell_check(vector<vector<int>>& board, int i, int j){\\n        int count_neighbors = 0;\\n        \\n        for (auto n : neighbors)\\n            if (no_out_range(board, i + n.first, j + n.second) && board[i + n.first][j + n.second] == 1)\\n                count_neighbors++;\\n        \\n        return count_neighbors == 3;\\n    }\\n\\n    //check if the live cell will be dead (if there are more than 3 or less than 2 live neighbors)\\n    bool live_cell_check(vector<vector<int>>& board, int i, int j){\\n        int count_neighbors = 0;\\n        \\n        for (auto n : neighbors)\\n            if (no_out_range(board, i + n.first, j + n.second) && board[i + n.first][j + n.second] == 1)\\n                count_neighbors++;\\n        \\n        return count_neighbors < 2 || count_neighbors > 3;\\n    }\\n    \\n    //make sure that i and j is not out of range\\n    bool no_out_range(vector<vector<int>>& board, int i, int j){\\n        return (i >= 0 && i < board.size() && j >= 0 && j < board[0].size());\\n    }\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<pair<int,int>> need_to_be_updated;\\n        \\n        //check for each cell if it needs to be changed (if a live cell becomes death or if a death cell becomes live)\\n        for (int i = 0; i < board.size(); i++)\\n            for (int j = 0; j < board[0].size(); j++)\\n                //check for death cell\\n                if (board[i][j] == 0 && dead_cell_check(board,i,j))\\n                    need_to_be_updated.push_back({i,j});\\n                //check for live cell\\n                else if (board[i][j] == 1 && live_cell_check(board,i,j))\\n                    need_to_be_updated.push_back({i,j});\\n            \\n        //update\\n        for (auto x : need_to_be_updated){\\n            int i = x.first, j = x.second;\\n            \\n            if (board[i][j] == 1)\\n                board[i][j] = 0;\\n            else \\n                board[i][j] = 1;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939417,
                "title": "java-very-simple-0ms-faster-than-100",
                "content": "**Runtime**: 0 ms, faster than 100.00% of Java online submissions for Game of Life.\\n**Memory Usage**: 39.9 MB, less than 99.82% of Java online submissions for Game of Life\\n\\n```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int R = board.length;\\n            int C = board[0].length;\\n\\n            int[] dx = {1, 1, 0, -1, -1, -1, 0, 1};\\n            int[] dy = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n            for (int i = 0; i < R; i++) {\\n                for (int j = 0; j < C; j++) {\\n                    int liveCounts = 0;\\n                    for (int k = 0; k < 8; k++)\\n                        if (isSafe(i + dx[k],j+dy[k],R,C) && Math.abs(board[i +dx[k]][j + dy[k]]) == 1)\\n                            liveCounts++;\\n\\n                    if (board[i][j] == 0 && liveCounts == 3)\\n                        board[i][j] = 2;\\n                    if (board[i][j] == 1 && (liveCounts < 2 || liveCounts > 3))\\n                        board[i][j] = -1;\\n                }\\n            }\\n\\n            for (int i = 0; i < R; i++)\\n                for (int j = 0; j < C; j++)\\n                    board[i][j] = board[i][j] > 0 ? 1 : 0;\\n        }\\n\\n        private boolean isSafe(int x, int y, int R, int C) {\\n            return (x >= 0 && x < R && y >= 0 && y < C);\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int R = board.length;\\n            int C = board[0].length;\\n\\n            int[] dx = {1, 1, 0, -1, -1, -1, 0, 1};\\n            int[] dy = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n            for (int i = 0; i < R; i++) {\\n                for (int j = 0; j < C; j++) {\\n                    int liveCounts = 0;\\n                    for (int k = 0; k < 8; k++)\\n                        if (isSafe(i + dx[k],j+dy[k],R,C) && Math.abs(board[i +dx[k]][j + dy[k]]) == 1)\\n                            liveCounts++;\\n\\n                    if (board[i][j] == 0 && liveCounts == 3)\\n                        board[i][j] = 2;\\n                    if (board[i][j] == 1 && (liveCounts < 2 || liveCounts > 3))\\n                        board[i][j] = -1;\\n                }\\n            }\\n\\n            for (int i = 0; i < R; i++)\\n                for (int j = 0; j < C; j++)\\n                    board[i][j] = board[i][j] > 0 ? 1 : 0;\\n        }\\n\\n        private boolean isSafe(int x, int y, int R, int C) {\\n            return (x >= 0 && x < R && y >= 0 && y < C);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939289,
                "title": "c-short-easy-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int returnNeighborCount(vector<vector<int>>& board,int i,int j) {\\n        \\n        int c=0;\\n        int iEnd=board.size()-1;\\n        int jEnd=board[0].size()-1;\\n\\t\\t\\n\\t\\t//at border values of matrxix, index bound error will happen, min max will take care of that\\n\\t\\t\\n        for(int x = max(0, i-1); x <= min(i+1, iEnd); x++) \\n            for(int y =max(0, j-1); y <= min(j+1, jEnd); y++)      \\n                if(board[x][y]==1 and (x!=i or y!=j)) \\n\\t\\t\\t\\t\\tc++;\\n        return c;\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& board) {\\n        \\n        int n=board.size();\\n        int m=board[0].size();\\n        vector<vector<int>> vec(n,vector<int>(m, 0)); //create 2d array of same size to store count of 1s\\n        \\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                vec[i][j]=returnNeighborCount(board,i,j); //store count of neigboring 1s corresponding to every value in \\'board\\'\\n\\n        for(int i=0;i<n;i++) \\n            for(int j=0;j<m;j++) {\\n                if(vec[i][j]<2 or vec[i][j]>3)   //conditions given in question\\n                    board[i][j]=0;\\n                else if(vec[i][j]==3)\\n                    board[i][j]=1;\\n            }\\n    }\\n};\\n\\nif(helpful)\\n\\tupVote();\\nif(anyDoubts)\\n\\tcomment();",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int returnNeighborCount(vector<vector<int>>& board,int i,int j) {\\n        \\n        int c=0;\\n        int iEnd=board.size()-1;\\n        int jEnd=board[0].size()-1;\\n\\t\\t\\n\\t\\t//at border values of matrxix, index bound error will happen, min max will take care of that\\n\\t\\t\\n        for(int x = max(0, i-1); x <= min(i+1, iEnd); x++) \\n            for(int y =max(0, j-1); y <= min(j+1, jEnd); y++)      \\n                if(board[x][y]==1 and (x!=i or y!=j)) \\n\\t\\t\\t\\t\\tc++;\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1939163,
                "title": "c-100-faster-code",
                "content": "class Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int i=board.size();\\n        int j=board[0].size();\\n        vector<int> v(i*j);\\n        \\n        int index=0;\\n        for(int a=0;a<i;a++){\\n            for(int b=0;b<j;b++){\\n                int count=0;\\n                \\n                if(a>0&&b>0)\\n                board[a-1][b-1]==1?count=count+1:count=count;\\n                \\n                if(a>0)\\n                board[a-1][b]==1?count=count+1:count=count;\\n                \\n                if(a>0 && b<j-1)\\n                board[a-1][b+1]==1?count=count+1:count=count;\\n                \\n                if(b>0)\\n                board[a][b-1]==1?count=count+1:count=count;\\n                \\n                if(b<j-1)\\n                board[a][b+1]==1?count=count+1:count=count;\\n                \\n                if(a<i-1 && b>0)\\n                board[a+1][b-1]==1?count=count+1:count=count;\\n                \\n                if(a<i-1)\\n                board[a+1][b]==1?count=count+1:count=count;\\n                \\n                if(a<i-1 && b<j-1)\\n                board[a+1][b+1]==1?count=count+1:count=count;\\n                \\n                if(board[a][b]==0){\\n                    count==3?v[index]=1:v[index]=0;\\n                    index++;\\n                }\\n                else{\\n                    if(count<2)\\n                        v[index++]=0;\\n                    else if(count==2 || count==3)\\n                        v[index++]=1;\\n                    else\\n                        v[index++]=0;\\n                }\\n                \\n            }\\n        }\\n        \\n        index=0;\\n        for(int a=0;a<i;a++){\\n            for(int b=0;b<j;b++){\\n                board[a][b]=v[index];\\n                index++;\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int i=board.size();\\n        int j=board[0].size();\\n        vector<int> v(i*j);\\n        \\n        int index=0;\\n        for(int a=0;a<i;a++){\\n            for(int b=0;b<j;b++){\\n                int count=0;\\n                \\n                if(a>0&&b>0)\\n                board[a-1][b-1]==1?count=count+1:count=count;\\n                \\n                if(a>0)\\n                board[a-1][b]==1?count=count+1:count=count;\\n                \\n                if(a>0 && b<j-1)\\n                board[a-1][b+1]==1?count=count+1:count=count;\\n                \\n                if(b>0)\\n                board[a][b-1]==1?count=count+1:count=count;\\n                \\n                if(b<j-1)\\n                board[a][b+1]==1?count=count+1:count=count;\\n                \\n                if(a<i-1 && b>0)\\n                board[a+1][b-1]==1?count=count+1:count=count;\\n                \\n                if(a<i-1)\\n                board[a+1][b]==1?count=count+1:count=count;\\n                \\n                if(a<i-1 && b<j-1)\\n                board[a+1][b+1]==1?count=count+1:count=count;\\n                \\n                if(board[a][b]==0){\\n                    count==3?v[index]=1:v[index]=0;\\n                    index++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1939009,
                "title": "intuitive-o-1-space-approach-how-to-think-of-space-optimization-c-commented-code",
                "content": "**Question Explanation:**\\nOnly In these two situations, the board value will come out to be \\'1\\' :\\n* Any live cell with two or three live neighbors lives on to the next generation.\\n* Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\\n\\nIn all the other situations cell value will be zero.\\nTo do this using extra space is very easy, just create an answer matrix and simulate the situations; since all changes will be done in the answer matrix, the original board will not be disturbed; hence all the conditions can be checked one by one, and at last, board matrix can be replaced with answer matrix.\\n\\n**How to think of Space Optimization:**\\nWe will have to think of some trick to do all operations in the given board matrix itself. To know the final state of the board, we require two things:\\n* Initial value of the cell\\n* Count of the neighboring cells having a value of 1\\n\\nSince we know the count of neighboring ones can only be a single-digit value (between 0 and 8), we can append that value to the cell itself; that can be done by placing that value in the tens position of the number. We can traverse from every cell in all eight directions and find neighboring tens and append that value to the cell; this is done by multiplying the ones count by ten and adding it to the cell value after this operation is done for all cells. At each cell, one\\'s position will have a digit equal to the initial state, and tens positions will have a digit equal to the count of neighboring ones.\\nAfter this, we again loop through every cell of the board and find the two conditions; we see that cell will be alive in the following two conditions : \\n* The count of neighboring ones is exactly three irrespective of the initial value; this will be checked by checking the tens position of the cell value( cell/10)==3.\\n* The count of neighboring ones is precisely two, and the initial value is one; this will be satisfied when we have 1 at one place and two at the tens place (cell==21)\\n\\nIn all other conditions, the cell value will be equal to zero.\\n\\n**Commented C++ Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        vector<vector<int>> dir={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\\n        // dir contains all 8  directions of traversal\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++){\\n                int cnt=0; //for every place we count number of neighbouring ones\\n                for(vector<int> &d:dir){\\n                    int x=i+d[0];\\n                    int y=j+d[1];\\n                    if(x>=0 && y>=0 && x<n && y<m && board[x][y]%10==1) cnt++;\\n                    // conditions to ensure (x,y) are in bound.\\n                    //board[x][y]%10==1 to check the value in ones position as \\n                    //overall value may have changed but ones position will \\n                    //always have the intial value.\\n                }\\n                board[i][j]+=10*cnt; // Place count of neighbouring ones at tens position\\n            }\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(board[i][j]==21 || board[i][j]/10==3) board[i][j]=1;\\n                // If cell was alive and remaining ones are two or remainig ones\\n                //are exactly three irrespective of cells initial state\\n                else board[i][j]=0;\\n    }\\n};\\n```\\n\\n**Complexity Analysis :**\\nTime: O(N*M) (two pass through entire board grid)\\nSpace: O(1) (All operations performed in given board itself)\\n\\nComment down below, If you have any queries or suggestions :)\\nBest Wishes,\\nAnurag\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        vector<vector<int>> dir={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\\n        // dir contains all 8  directions of traversal\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++){\\n                int cnt=0; //for every place we count number of neighbouring ones\\n                for(vector<int> &d:dir){\\n                    int x=i+d[0];\\n                    int y=j+d[1];\\n                    if(x>=0 && y>=0 && x<n && y<m && board[x][y]%10==1) cnt++;\\n                    // conditions to ensure (x,y) are in bound.\\n                    //board[x][y]%10==1 to check the value in ones position as \\n                    //overall value may have changed but ones position will \\n                    //always have the intial value.\\n                }\\n                board[i][j]+=10*cnt; // Place count of neighbouring ones at tens position\\n            }\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(board[i][j]==21 || board[i][j]/10==3) board[i][j]=1;\\n                // If cell was alive and remaining ones are two or remainig ones\\n                //are exactly three irrespective of cells initial state\\n                else board[i][j]=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938915,
                "title": "simple-c",
                "content": "```\\n   vector<pair<int,int>>dir={{-1,0},{1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};//all eight direction\\n bool isvalid(vector<vector<int>>&board,int i,int j){\\n     int n=board.size(),m=board[0].size();\\n     if(i<0||i>=n||j<0||j>=m||board[i][j]==0)return false;\\n     return true;\\n }\\n int count(vector<vector<int>>&board,int i,int j){\\n     int ans=0;\\n     for(auto it:dir){\\n         int x=i+it.first,y=j+it.second;\\n         if(isvalid(board,x,y))ans++;\\n     }\\n     return ans;\\n }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<vector<int>>helper=board;\\n        int n=board.size(),m=board[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // cout<<count(board,i,j)<<\" \";\\n                if(board[i][j]==0 and count(board,i,j)==3)helper[i][j]=1;\\n                else if(board[i][j]==1 and count(board,i,j)>3)helper[i][j]=0;\\n                else if(board[i][j]==1 and count(board,i,j)<2)helper[i][j]=0;\\n                else if(board[i][j]==1 and (count(board,i,j)==2||3))helper[i][j]=1;\\n            }\\n        }\\n        board=helper;\\n            \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   vector<pair<int,int>>dir={{-1,0},{1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};//all eight direction\\n bool isvalid(vector<vector<int>>&board,int i,int j){\\n     int n=board.size(),m=board[0].size();\\n     if(i<0||i>=n||j<0||j>=m||board[i][j]==0)return false;\\n     return true;\\n }\\n int count(vector<vector<int>>&board,int i,int j){\\n     int ans=0;\\n     for(auto it:dir){\\n         int x=i+it.first,y=j+it.second;\\n         if(isvalid(board,x,y))ans++;\\n     }\\n     return ans;\\n }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<vector<int>>helper=board;\\n        int n=board.size(),m=board[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // cout<<count(board,i,j)<<\" \";\\n                if(board[i][j]==0 and count(board,i,j)==3)helper[i][j]=1;\\n                else if(board[i][j]==1 and count(board,i,j)>3)helper[i][j]=0;\\n                else if(board[i][j]==1 and count(board,i,j)<2)helper[i][j]=0;\\n                else if(board[i][j]==1 and (count(board,i,j)==2||3))helper[i][j]=1;\\n            }\\n        }\\n        board=helper;\\n            \\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1938775,
                "title": "c-o-1-space-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int count(vector<vector<int>>&board,int i,int j){  //count_of_live_neighbour\\n        int sol=0,n=board.size(),m=board[0].size();\\n        if(i>0){ //counting upper side of i\\n            if(board[i-1][j]==-1 or board[i-1][j]==1)sol++;\\n            if(j>0 and (board[i-1][j-1]==-1 or board[i-1][j-1]==1))sol++;\\n            if(j<m-1 and (board[i-1][j+1]==-1 or board[i-1][j+1]==1))sol++;\\n        }\\n        if(i<n-1){  //counting lower side of i\\n             if(board[i+1][j]==-1 or board[i+1][j]==1)sol++;\\n            if(j>0 and (board[i+1][j-1]==-1 or board[i+1][j-1]==1))sol++;\\n            if(j<m-1 and (board[i+1][j+1]==-1 or board[i+1][j+1]==1))sol++;\\n        }\\n        if(j>0 and (board[i][j-1]==-1 or board[i][j-1]==1))sol++;//counting left hand side of j\\n        if(j<m-1 and (board[i][j+1]==-1 or board[i][j+1]==1))sol++;//counting right hand side of j\\n        return sol;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n =board.size(),m=board[0].size();\\n        for(int i = 0 ; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int k=count(board,i,j);  //count of live neighbour\\n                if(board[i][j]==0){ //RULE --->4\\n                    if(k==3)board[i][j]=-2;\\n                }\\n                else{  //RULE--->1 && 3\\n                    if(k<2 or k>3)board[i][j]=-1;\\n                }\\n            }\\n        }\\n        for(int i = 0 ; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==0 or board[i][j]==1)continue;\\n                if(board[i][j]==-1)board[i][j]=0;   //Convertion to 0-1 matrix\\n                else if(board[i][j]==-2)board[i][j]=1;\\n            }\\n        }\\n    }\\n};\\n```\\n**Please do upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(vector<vector<int>>&board,int i,int j){  //count_of_live_neighbour\\n        int sol=0,n=board.size(),m=board[0].size();\\n        if(i>0){ //counting upper side of i\\n            if(board[i-1][j]==-1 or board[i-1][j]==1)sol++;\\n            if(j>0 and (board[i-1][j-1]==-1 or board[i-1][j-1]==1))sol++;\\n            if(j<m-1 and (board[i-1][j+1]==-1 or board[i-1][j+1]==1))sol++;\\n        }\\n        if(i<n-1){  //counting lower side of i\\n             if(board[i+1][j]==-1 or board[i+1][j]==1)sol++;\\n            if(j>0 and (board[i+1][j-1]==-1 or board[i+1][j-1]==1))sol++;\\n            if(j<m-1 and (board[i+1][j+1]==-1 or board[i+1][j+1]==1))sol++;\\n        }\\n        if(j>0 and (board[i][j-1]==-1 or board[i][j-1]==1))sol++;//counting left hand side of j\\n        if(j<m-1 and (board[i][j+1]==-1 or board[i][j+1]==1))sol++;//counting right hand side of j\\n        return sol;\\n    }\\n    void gameOfLife(vector<vector<int>>& board) {\\n        int n =board.size(),m=board[0].size();\\n        for(int i = 0 ; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int k=count(board,i,j);  //count of live neighbour\\n                if(board[i][j]==0){ //RULE --->4\\n                    if(k==3)board[i][j]=-2;\\n                }\\n                else{  //RULE--->1 && 3\\n                    if(k<2 or k>3)board[i][j]=-1;\\n                }\\n            }\\n        }\\n        for(int i = 0 ; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==0 or board[i][j]==1)continue;\\n                if(board[i][j]==-1)board[i][j]=0;   //Convertion to 0-1 matrix\\n                else if(board[i][j]==-2)board[i][j]=1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938774,
                "title": "c-easy-explanation-comments-daily-leetcoding-challenge-april-day-12",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    // it will checkall the 8 directions or negihbours\\n    int dir[8][2] = {{1,0},{0,1},{-1,0},{0,-1},{1,1},{-1,-1},{-1,1},{1,-1}};\\n    \\n    void gameOfLife(vector<vector<int>>& board) \\n    {\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        // for getting all the states (dead & live)\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                int state = getState(board, i, j);\\n                // cout<<\"state \"<<state<<\" i \"<<i<<\" j \"<<j<<\" b \"<<board[i][j]<<endl;\\n                board[i][j] = state;\\n            }\\n        }\\n        \\n        //recover state\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(board[i][j]==-1) board[i][j] = 0;\\n                else if(board[i][j]==2) board[i][j] = 1;\\n            }\\n        }\\n    }\\n    \\n    int getState(vector<vector<int>>& board, int i, int j)\\n    {\\n        int live = 0;\\n        int dead = 0;\\n        \\n        // check for its neighbours\\n        for(int k=0; k<8; k++)\\n        {\\n            int x = i+dir[k][0];       //x-axis\\n            int y = j+dir[k][1];       //y-axis\\n            \\n            // if it accross the limits then continue\\n            if(x<0 || y<0 || x>=board.size() || y>=board[0].size()) \\n                continue;\\n            \\n            if(board[x][y]==1 || board[x][y] == -1)\\n                live++;\\n            else \\n                dead++;\\n        }\\n        \\n        // if current cell live then check for the condition\\n        if(board[i][j]==1)\\n        {\\n            // if it is caused by under or over population then it will become dead\\n            if(live < 2 || live > 3)\\n                return -1; // -1 means live cell died\\n            \\n            // else it will be remaining alive\\n            return 1;\\n        }\\n        \\n        // if current cell dead then check for the condition\\n        if(live==3) \\n            return 2; // 2 means dead cell will live\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // it will checkall the 8 directions or negihbours\\n    int dir[8][2] = {{1,0},{0,1},{-1,0},{0,-1},{1,1},{-1,-1},{-1,1},{1,-1}};\\n    \\n    void gameOfLife(vector<vector<int>>& board) \\n    {\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        // for getting all the states (dead & live)\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                int state = getState(board, i, j);\\n                // cout<<\"state \"<<state<<\" i \"<<i<<\" j \"<<j<<\" b \"<<board[i][j]<<endl;\\n                board[i][j] = state;\\n            }\\n        }\\n        \\n        //recover state\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(board[i][j]==-1) board[i][j] = 0;\\n                else if(board[i][j]==2) board[i][j] = 1;\\n            }\\n        }\\n    }\\n    \\n    int getState(vector<vector<int>>& board, int i, int j)\\n    {\\n        int live = 0;\\n        int dead = 0;\\n        \\n        // check for its neighbours\\n        for(int k=0; k<8; k++)\\n        {\\n            int x = i+dir[k][0];       //x-axis\\n            int y = j+dir[k][1];       //y-axis\\n            \\n            // if it accross the limits then continue\\n            if(x<0 || y<0 || x>=board.size() || y>=board[0].size()) \\n                continue;\\n            \\n            if(board[x][y]==1 || board[x][y] == -1)\\n                live++;\\n            else \\n                dead++;\\n        }\\n        \\n        // if current cell live then check for the condition\\n        if(board[i][j]==1)\\n        {\\n            // if it is caused by under or over population then it will become dead\\n            if(live < 2 || live > 3)\\n                return -1; // -1 means live cell died\\n            \\n            // else it will be remaining alive\\n            return 1;\\n        }\\n        \\n        // if current cell dead then check for the condition\\n        if(live==3) \\n            return 2; // 2 means dead cell will live\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1938624,
                "title": "linear-searching-brute-force-faster-than-100-at-least-for-now",
                "content": "Although this approach is not space friendly but it solves the problem in general O(n) time.\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<pair<int, int>> v;\\n        int n = board.size(); // size of row\\n        int m = board[0].size(); // size of column\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int cnt = 0; // to store the count of live neighbor cells\\n                if(i){\\n                    if(j < m-1) cnt += board[i-1][j+1]; // up-right\\n                    if(j) cnt += board[i-1][j-1];   //up-left\\n                    cnt += board[i-1][j];  // up\\n                }\\n                if(j)  cnt += board[i][j-1]; // left\\n                if(i < n-1){\\n                    if(j < m-1) cnt += board[i+1][j+1];  // down-right\\n                    if(j) cnt += board[i+1][j-1]; // down-left\\n                    cnt += board[i+1][j]; // down\\n                }\\n                if(j<m-1) cnt += board[i][j+1]; // right\\n                \\n                if(cnt < 2 && board[i][j]) v.push_back(make_pair(i, j));\\n                if(cnt > 3 && board[i][j]) v.push_back(make_pair(i, j));\\n                if(cnt == 3 && !board[i][j]) v.push_back(make_pair(i, j)); \\n            } \\n        }\\n        for(auto it: v) board[it.first][it.second]^=1; // all those pair of indices which are in vector pair v will be flipped\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        vector<pair<int, int>> v;\\n        int n = board.size(); // size of row\\n        int m = board[0].size(); // size of column\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int cnt = 0; // to store the count of live neighbor cells\\n                if(i){\\n                    if(j < m-1) cnt += board[i-1][j+1]; // up-right\\n                    if(j) cnt += board[i-1][j-1];   //up-left\\n                    cnt += board[i-1][j];  // up\\n                }\\n                if(j)  cnt += board[i][j-1]; // left\\n                if(i < n-1){\\n                    if(j < m-1) cnt += board[i+1][j+1];  // down-right\\n                    if(j) cnt += board[i+1][j-1]; // down-left\\n                    cnt += board[i+1][j]; // down\\n                }\\n                if(j<m-1) cnt += board[i][j+1]; // right\\n                \\n                if(cnt < 2 && board[i][j]) v.push_back(make_pair(i, j));\\n                if(cnt > 3 && board[i][j]) v.push_back(make_pair(i, j));\\n                if(cnt == 3 && !board[i][j]) v.push_back(make_pair(i, j)); \\n            } \\n        }\\n        for(auto it: v) board[it.first][it.second]^=1; // all those pair of indices which are in vector pair v will be flipped\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938607,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int m  = board.length, n=board[0].length;\\n        int[][] fin = new int[m][n];\\n                   // board[i-1][j];    up\\n                   // board[i+1][j];    down\\n                   // board[i][j-1];    left\\n                   // board[i][j+1];    right \\n                   // board[i-1][j-1];  up left corner\\n                   // board[i+1][j+1];  down right corner\\n                   // board[i-1][j+1];  up right corner\\n                   // board[i+1][j-1];  down left corner\\n        for(int i=0; i<m; i++) {\\n            \\n            for(int j=0; j<n; j++) {\\n                int nbr = 0;\\n                \\n                if((i-1>=0) && board[i-1][j]==1) nbr++; \\n                if((i+1<m) && board[i+1][j]==1) nbr++;\\n                if((j-1>=0) && board[i][j-1]==1) nbr++;\\n                if((j+1<n) && board[i][j+1]==1) nbr++;\\n                if((i-1>=0) && (j-1>=0) && board[i-1][j-1]==1) nbr++;\\n                if((i+1<m) && (j+1<n) && board[i+1][j+1]==1) nbr++;\\n                if((i-1>=0) && (j+1<n) && board[i-1][j+1]==1) nbr++;\\n                if((i+1<m) && (j-1>=0) && board[i+1][j-1]==1) nbr++;\\n                \\n                if(nbr<2) fin[i][j]=0;\\n                else if(nbr>3) fin[i][j]=0;\\n                else if((nbr!=3) && board[i][j]==0) fin[i][j]=0;\\n                else fin[i][j]=1;\\n            }\\n            \\n        }\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                board[i][j] = fin[i][j];\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void gameOfLife(int[][] board) {\\n        int m  = board.length, n=board[0].length;\\n        int[][] fin = new int[m][n];\\n                   // board[i-1][j];    up\\n                   // board[i+1][j];    down\\n                   // board[i][j-1];    left\\n                   // board[i][j+1];    right \\n                   // board[i-1][j-1];  up left corner\\n                   // board[i+1][j+1];  down right corner\\n                   // board[i-1][j+1];  up right corner\\n                   // board[i+1][j-1];  down left corner\\n        for(int i=0; i<m; i++) {\\n            \\n            for(int j=0; j<n; j++) {\\n                int nbr = 0;\\n                \\n                if((i-1>=0) && board[i-1][j]==1) nbr++; \\n                if((i+1<m) && board[i+1][j]==1) nbr++;\\n                if((j-1>=0) && board[i][j-1]==1) nbr++;\\n                if((j+1<n) && board[i][j+1]==1) nbr++;\\n                if((i-1>=0) && (j-1>=0) && board[i-1][j-1]==1) nbr++;\\n                if((i+1<m) && (j+1<n) && board[i+1][j+1]==1) nbr++;\\n                if((i-1>=0) && (j+1<n) && board[i-1][j+1]==1) nbr++;\\n                if((i+1<m) && (j-1>=0) && board[i+1][j-1]==1) nbr++;\\n                \\n                if(nbr<2) fin[i][j]=0;\\n                else if(nbr>3) fin[i][j]=0;\\n                else if((nbr!=3) && board[i][j]==0) fin[i][j]=0;\\n                else fin[i][j]=1;\\n            }\\n            \\n        }\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                board[i][j] = fin[i][j];\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938550,
                "title": "c-2-solutions-with-w-o-space-o-n-n-time-easy-clean-code",
                "content": "**1. Using extra space**\\nTime - O ( n * n )\\nSpace - O ( n * n )\\n```\\nclass Solution {\\npublic:\\n    int dx[8]={-1,-1,-1,0,0,1,1,1};\\n    int dy[8]={-1,0,1,-1,1,-1,0,1};\\n    \\n    bool isvalid(int i,int j,int m,int n)\\n    {\\n        return (i>=0 && j>=0 && i<m && j<n);\\n    }\\n    \\n    int check(vector<vector<int>>& b,int i,int j,int m,int n)\\n    {\\n        int k,c=0;\\n        \\n        for(k=0;k<8;k++)\\n        {\\n            if(isvalid(i+dx[k],j+dy[k],m,n) && b[i+dx[k]][j+dy[k]]==1)\\n                c++;\\n        }\\n        \\n        if(b[i][j]==0)\\n        {\\n            if(c==3)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        else\\n        {\\n            if(c<2 || c>3)\\n                return 0;\\n            else\\n                return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& b) {\\n        int m=b.size(),n=b[0].size();\\n        vector<vector<int>> ans(m,vector<int> (n));\\n        int i,j;\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                ans[i][j]=check(b,i,j,m,n);\\n            }\\n        }\\n        \\n        b=ans;\\n    }\\n};\\n```\\n\\n**2. Without using extra space ( inplace )**\\nTime - O ( n * n )\\nSpace - O ( 1 )\\n```\\nclass Solution {\\npublic:\\n    // 1 -> 0 = -1\\n    // 0 -> 1 = 2\\n    \\n    int dx[8]={-1,-1,-1,0,0,1,1,1};\\n    int dy[8]={-1,0,1,-1,1,-1,0,1};\\n    \\n    bool isvalid(int i,int j,int m,int n)\\n    {\\n        return (i>=0 && j>=0 && i<m && j<n);\\n    }\\n    \\n    void check(vector<vector<int>>& b,int i,int j,int m,int n)\\n    {\\n        int k,c=0;\\n        \\n        for(k=0;k<8;k++)\\n        {\\n            if(isvalid(i+dx[k],j+dy[k],m,n) && (b[i+dx[k]][j+dy[k]]==1 || b[i+dx[k]][j+dy[k]]==-1))\\n                c++;\\n        }\\n        \\n        if(b[i][j]==0)\\n        {\\n            if(c==3)\\n                b[i][j]=2;\\n        }\\n        else\\n        {\\n            if(c<2 || c>3)\\n                b[i][j]=-1;\\n        }\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& b) {\\n        int m=b.size(),n=b[0].size();\\n        int i,j;\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                check(b,i,j,m,n);\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(b[i][j]==-1)\\n                    b[i][j]=0;\\n                else if(b[i][j]==2)\\n                    b[i][j]=1;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Do share your views & upvote if you like !!!** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[8]={-1,-1,-1,0,0,1,1,1};\\n    int dy[8]={-1,0,1,-1,1,-1,0,1};\\n    \\n    bool isvalid(int i,int j,int m,int n)\\n    {\\n        return (i>=0 && j>=0 && i<m && j<n);\\n    }\\n    \\n    int check(vector<vector<int>>& b,int i,int j,int m,int n)\\n    {\\n        int k,c=0;\\n        \\n        for(k=0;k<8;k++)\\n        {\\n            if(isvalid(i+dx[k],j+dy[k],m,n) && b[i+dx[k]][j+dy[k]]==1)\\n                c++;\\n        }\\n        \\n        if(b[i][j]==0)\\n        {\\n            if(c==3)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        else\\n        {\\n            if(c<2 || c>3)\\n                return 0;\\n            else\\n                return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& b) {\\n        int m=b.size(),n=b[0].size();\\n        vector<vector<int>> ans(m,vector<int> (n));\\n        int i,j;\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                ans[i][j]=check(b,i,j,m,n);\\n            }\\n        }\\n        \\n        b=ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // 1 -> 0 = -1\\n    // 0 -> 1 = 2\\n    \\n    int dx[8]={-1,-1,-1,0,0,1,1,1};\\n    int dy[8]={-1,0,1,-1,1,-1,0,1};\\n    \\n    bool isvalid(int i,int j,int m,int n)\\n    {\\n        return (i>=0 && j>=0 && i<m && j<n);\\n    }\\n    \\n    void check(vector<vector<int>>& b,int i,int j,int m,int n)\\n    {\\n        int k,c=0;\\n        \\n        for(k=0;k<8;k++)\\n        {\\n            if(isvalid(i+dx[k],j+dy[k],m,n) && (b[i+dx[k]][j+dy[k]]==1 || b[i+dx[k]][j+dy[k]]==-1))\\n                c++;\\n        }\\n        \\n        if(b[i][j]==0)\\n        {\\n            if(c==3)\\n                b[i][j]=2;\\n        }\\n        else\\n        {\\n            if(c<2 || c>3)\\n                b[i][j]=-1;\\n        }\\n    }\\n    \\n    void gameOfLife(vector<vector<int>>& b) {\\n        int m=b.size(),n=b[0].size();\\n        int i,j;\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                check(b,i,j,m,n);\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(b[i][j]==-1)\\n                    b[i][j]=0;\\n                else if(b[i][j]==2)\\n                    b[i][j]=1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564953,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1565007,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1572618,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1794854,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1567475,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1566712,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1575241,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1572434,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1572122,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1571539,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1564953,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1565007,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1572618,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1794854,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1567475,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1566712,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1575241,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1572434,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1572122,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            },
            {
                "id": 1571539,
                "content": [
                    {
                        "username": "EthanLi",
                        "content": "It seems that encoding inside original int[][] just utilized spare spaces from matrix. What if the input matrix is a boolean matrix? Is there still a way to solve it without extra space? Thanks."
                    },
                    {
                        "username": "xuyirui",
                        "content": "1.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\n\\n2.What If the matrix is too big that it cannot store completely in RAM?\\nI know One way is to read and process line by line. can you provide implementation details?\\n\\n3.How do you solve this problem using multithreads?"
                    },
                    {
                        "username": "jaggz01",
                        "content": "2. maybe only store its neighboring cell values for the calculation ? i.e only ready the neighboring 8 cells for a given cell and rest keep it on disk ? dont know if thats right."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni think this problem is meaningless nonsense."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "this automaton in particular is quite relevant in computation theory, in determining the decidibility of an algorithm. It was quite interesting to learn about how freaky computers can be"
                    },
                    {
                        "username": "mrthewalrus",
                        "content": "Every single problem on this site is meaningless nonsense. That\\'s not really the site\\'s fault, it\\'s the fault of the software industry, for standardizing on having one or more of these meaningless nonsense problems as part of their interview process for a job that is totally unrelated to the skills being tested in those interviews."
                    },
                    {
                        "username": "fakename_bill",
                        "content": "To do it in-place, you need to traverse the board in two passes.\\n\\nIn the first pass, add 2 to the value of all cells that will be live in the next generation. Test whether neighbors are live or dead by checking if (cell % 2 == 1) instead of (cell == 1). This way, adding 2 to mark a cell as live in the next generation will not affect neighbors checking the cell\\'s current state. After the first pass is complete, every cell will contain one of the following values:\\n0 : Dead now, dead in the next generation.\\n1: Live now, dead in the next generation.\\n2: Dead now, live in the next generation.\\n3: Live now, live in the next generation.\\n\\nIn the second pass, divide the value in each cell by 2 to get the final results for the next generation.\\n0, 1: Now 0, or dead.\\n2, 3: Now 1, or live."
                    },
                    {
                        "username": "zerocores",
                        "content": "[@asjikdnbaousduashojc](/asjikdnbaousduashojc) it\\'s not about the input data or test cases here. The interviewer can simply compress it to counter this solution."
                    },
                    {
                        "username": "asjikdnbaousduashojc",
                        "content": "[@zerocores](/zerocores) I wonder in which language is the board passed as a matrix of bools or bits. I think every language uses int."
                    },
                    {
                        "username": "zerocores",
                        "content": "This is not considered as constant space because the solution actually extends (0, 1) to (0, 1, 2, 3) which is 1 bit -> 2 bits.\\nIf we simply encode 8 cells into a byte, this solution will actually use double the original size which is O(m*n)"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for the help! Initially I was unable to think of a solution without using any extra space, but this comment of yours really made doing the problem in constant space easy and simple! Thanks again!"
                    },
                    {
                        "username": "w22we33",
                        "content": "This question is originated from Conway\\'s Game of Life. RIP to Prof. Conway.\\nConway\\'s Game of Life: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\nNews: https://twitter.com/CardColm/status/1249038195880341505"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/game-of-life/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** O(mn) Space Solution\n\n  \n**Approach 2:** O(1) Space Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kache_",
                        "content": "Heads up, the javascript problem expects you to mutate the board, not return a new reference entirely."
                    },
                    {
                        "username": "qaref18",
                        "content": "In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"
                    },
                    {
                        "username": "myemailbig123",
                        "content": "I am getting next compilation error: \"Line 123: cannot assign value of type \\'UnsafeMutablePointer<Int32>?\\' to type \\'Int32\\'\"\\nline 123 is out of my code. So seems issue outside my code"
                    },
                    {
                        "username": "makowan",
                        "content": "Does \"in-place\" must be O(1) space? and O(n)?"
                    },
                    {
                        "username": "LeoBKChen",
                        "content": "must be O(1) space "
                    }
                ]
            }
        ]
    }
]